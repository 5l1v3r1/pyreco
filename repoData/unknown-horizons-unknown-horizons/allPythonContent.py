__FILENAME__ = all_images
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

'''
Generate html output for a page displaying all images currently available
in the repository and in a certain directory. Does not wite anything to a
file, you will need to redirect output.
Change `where` below to anything else as you see fit.
'''

import os
import os.path


# All gui images and icons
where = 'content/gui/'

# All atlas files
# where = 'content/gfx/atlas/'

# All building, unit and other images (including atlas files)
# Warning: This most likely is too huge to be of any help.
# where = 'content/gfx/'

# make this script work both when started inside development and in the uh root dir
if not os.path.exists('content'):
	os.chdir('..')
assert os.path.exists('content'), 'Content dir not found.'

base_url = 'file://localhost/' + os.path.abspath(os.getcwd()) + '/'

for root, dirs, files in sorted(os.walk(where)):
	for f in sorted(files):
		if not f.endswith(('.png', '.jpg')):
			continue
		url = base_url + '/' + root + '/' + f
		print '<a href="{url}"><img src="{url}" /></a>'.format(url=url)

########NEW FILE########
__FILENAME__ = diplomacy_graphs
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

"""
This is a balancing tool for diplomacy which makes setting diplomacy parameters (such as mid, root or peek) easier.
It requires matplotlib (along with pylab) library in order to plot functions.

Usage:
1. Run the script from UH root, i.e. python development/combat_ai/diplomacy_graphs.py
2. A graph should appear on screen displaying current functions for each of the settings (see parameter_sets below)
3. After you close the plot window, next one should appear
4. Uncomment functions from parameter_sets you don't want to have displayed
"""

import sys
import pylab

sys.path.append(".")
sys.path.append("./horizons")
sys.path.append("./horizons/util")

try:
	import run_uh
except ImportError as e:
	print e.message
	print "Please run from Unknown Horizons root dir"
	sys.exit(1)

from run_uh import init_environment
init_environment(False)

import horizons.main

from horizons.ai.aiplayer.behavior.diplomacysettings import DiplomacySettings
from horizons.ai.aiplayer.behavior.behaviorcomponents import BehaviorDiplomatic

_move_f = BehaviorDiplomatic._move_f
_get_quadratic_function = BehaviorDiplomatic._get_quadratic_function
get_enemy_function = BehaviorDiplomatic.get_enemy_function
get_ally_function = BehaviorDiplomatic.get_ally_function
get_neutral_function = BehaviorDiplomatic.get_neutral_function

def diplomacy_graph():
	header = "Diplomacy function"
	x_label = "relationship_score"
	y_label = "probability"

	# define functions here to plot them.
	# Second parameter is color
	upper_boundary = DiplomacySettings.upper_boundary

	parameter_sets = (

		("BehaviorGood.allied_player", DiplomacySettings.Good.parameters_allied),
		("BehaviorGood.neutral_player", DiplomacySettings.Good.parameters_neutral),
		("BehaviorGood.hostile_player", DiplomacySettings.Good.parameters_hostile),

		("BehaviorNeutral.allied_player", DiplomacySettings.Neutral.parameters_hostile),
		("BehaviorNeutral.neutral_player", DiplomacySettings.Neutral.parameters_neutral),
		("BehaviorNeutral.hostile_player", DiplomacySettings.Neutral.parameters_hostile),

		("BehaviorEvil.allied_player", DiplomacySettings.Evil.parameters_hostile),
		("BehaviorEvil.neutral_player", DiplomacySettings.Evil.parameters_neutral),
		("BehaviorEvil.hostile_player", DiplomacySettings.Evil.parameters_hostile),

	)


	for parameter_name, parameters in parameter_sets:

		# always print upper boundary
		x = [-10, 10]
		y = [upper_boundary]*2
		pylab.plot (x,y,color='y', marker=None)

		functions = []
		if 'enemy' in parameters:
			functions.append((get_enemy_function(**parameters['enemy']),'r'))
		if 'ally' in parameters:
			functions.append((get_ally_function(**parameters['ally']), 'g'))
		if 'neutral' in parameters:
			functions.append((get_neutral_function(**parameters['neutral']), 'b'))

		for f, c in functions:
			gen = [(x/10.0, f(x/10.0)) for x in xrange(-100, 100) ]
			x = [item[0] for item in gen]
			y = [item[1] for item in gen]
			pylab.plot(x,y, color=c,marker=None)
			pylab.xlabel(x_label)
			pylab.ylabel(y_label)
			pylab.title(parameter_name)
			pylab.grid(True)
		pylab.show()

if(__name__=="__main__"):
	diplomacy_graph()
########NEW FILE########
__FILENAME__ = compare_string_lengths_in_pos
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import sys

usage = "<filename> [lower_bound] [upper_bound]"
usage = "<filename>"

if len(sys.argv) < 2:
	print usage
	sys.exit(1)

filename = sys.argv[1]

file = open(filename, "r")

i = 0
translations = {}

state = 0

for line in file:
	line = line.strip()

	if state == 0:
		if not "msgid" in line:
			continue
		translations[i] = {}
		translations[i][0] = line
		state += 1

	elif state == 1:
		if "msgstr" in line:
			translations[i][1] = line
			state += 1
		else:
			translations[i][0] += line

	elif state == 2:
		if line.startswith("#") or not line:
			state = 0
			i += 1
		else:
			translations[i][1] += line


for t in translations:
	orig  = translations[t][0]
	trans = translations[t][1]

	if orig.startswith("#") or trans.startswith("#"):
		continue

	if orig.startswith("msgid"): orig = orig[6:]
	if trans.startswith("msgstr"): trans = trans[7:]

	if trans == "\"\"":
		continue

	len_ratio = float(len(orig))/len(trans)

	if len_ratio > 1.4 or len_ratio < 0.6 and \
			abs(len(orig)-len(trans)) > 2:
		print 'string length ratio:', len_ratio
		print orig
		print trans
		print



########NEW FILE########
__FILENAME__ = compile_translation_win
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os
import glob

if os.path.basename(os.getcwd()) != 'development':
	print 'Please run the script from the "development" directory!'
	quit()

if not os.path.isdir('../po/uh/'):
	print 'The translations directory does not exist! Quiting..'
	quit()

os.chdir('..')
files = glob.glob('po/uh/*.po')
for x in files:
	file = x.rpartition("\\")[2]
	dir = file[:-len('.po')]
	dir = os.path.join('content', 'lang', dir, 'LC_MESSAGES', '')
	if not os.path.isdir(dir):
		os.makedirs(dir)
	print 'Generating translations for', file
	command = 'msgfmt ' + x + ' -o ' + dir + 'unknown-horizons.mo'
	os.system(command)

print '\n== Completed generating translations ==\n'

########NEW FILE########
__FILENAME__ = compress_map
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import bz2
import sys

args = sys.argv[1:]

if not args:
	print 'USAGE: ' + sys.argv[0] + ' map1.sqlite map2.sqlite ... mapx.sqlite'
	print
	print 'maps will be saved as "mapx.map"'
	print 'to convert all maps, use "' + sys.argv[0] + ' content/maps/*sqlite"'
	sys.exit()

for filename in args:
	if not filename.endswith(".sqlite"):
		print "Invalid filename:", filename
		continue
	infile = None
	try:
		infile = open(filename, "r")
	except IOError as e:
		print "Error:", e.message
		continue

	outfile = open(filename.replace('.sqlite','.map'), 'w')
	outfile.write( bz2.compress( infile.read() ) )

########NEW FILE########
__FILENAME__ = docstringer
#!/usr/bin/env python2

# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import re
import sys

is_function = re.compile(r'^(\s*)def ([^(]+)[(](.*)[)]:\s*$')
is_decorator = re.compile(r'^(\s*)@\s*(.+)\s*$')
func_param = re.compile(r'\s*(?:,\s*)?([^,=\s]+)(?:\s*=\s*([^\s,]+))?')
is_empty = re.compile(r'^(\s*)(?:#.*)?$')

files = sys.argv[1:]
for filename in files:
	print 'Adding documentation stubs to:', filename
	file = open(filename, 'r+')
	funk_reg = None
	newfile = []
	for line in file:
		if is_function.match(line) is not None:
			funk_reg = is_function.match(line)
		elif funk_reg is not None and line.strip().startswith('"""'):
			newfile.append(funk_reg.group())
			newfile.append(line)
			funk_reg = None
		elif funk_reg is not None:
			params = func_param.findall(funk_reg.group(3))
			indent = funk_reg.group(1) + '\t' * (funk_reg.group(2) != '__init__')
			docstub = [(indent + '"""\n')]
			for i in params:
				if i[0] != 'self' and i[0] != 'cls':
					docstub.append(("%s@param %s:\n" % (indent, i[0])))
			docstub.append((indent + '"""\n'))
			if funk_reg.group(2) == '__init__':
				newfile.extend(docstub)
				newfile.append(funk_reg.group())
			else:
				newfile.append(funk_reg.group())
				newfile.extend(docstub)
			newfile.append(line)
			funk_reg = None
		else:
			newfile.append(line)
	file.seek(0)
	file.writelines(newfile)
	file.close()
	print 'Done'

########NEW FILE########
__FILENAME__ = extract_strings_from_objects
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

###############################################################################
#
# == I18N DEV USE CASES: CHEATSHEET ==
#
# ** Refer to  development/create_pot.sh  for help with building or updating
#    the translation files for Unknown Horizons.
#
###############################################################################
#
# THIS SCRIPT IS A HELPER SCRIPT. DO NOT INVOKE MANUALLY!
#
###############################################################################


HEADER = '''\
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

###############################################################################
#
# == I18N DEV USE CASES: CHEATSHEET ==
#
# ** Refer to  development/create_pot.sh  for help with building or updating
#    the translation files for Unknown Horizons.
#
###############################################################################
#
# WARNING: This file is generated automagically.
#          You need to update it to see changes to strings in-game.
#          DO NOT MANUALLY UPDATE THIS FILE (by editing strings).
#          The script to generate .pot templates calls the following:
# ./development/extract_strings_from_objects.py  horizons/i18n/objecttranslations.py
#
# NOTE: In string-freeze mode (shortly before releases, usually
#       announced in a meeting), updates to this file must not happen
#       without permission of the responsible translation admin!
#
###############################################################################










object_translations = {
'''

FOOTER = '''
}
'''
ROWINDENT = '''
		'''

OBJECT_PATH = 'content/objects/'

locations_to_translate = [
	OBJECT_PATH + 'buildings/',
	OBJECT_PATH + 'units/ships/',
	OBJECT_PATH + 'gui_buildmenu/',
	]

files_to_skip = [
	'usablefisher.yaml',
	]

import os
import sys

from yaml import load
from yaml import SafeLoader as Loader

from horizons.constants import TIER, RES, UNITS, BUILDINGS

# cannot import parse_token from horizons.util.yamlcache here!
#TODO Make sure to keep both in sync and/or fix the import trouble!
def parse_token(token, token_klass):
	"""Helper function that tries to parse a constant name.
	Does not do error detection, but passes unparseable stuff through.
	Allowed values: integer or token_klass.LIKE_IN_CONSTANTS
	@param token_klass: "TIER", "RES", "UNITS" or "BUILDINGS"
	"""
	classes = {'TIER': TIER, 'RES': RES, 'UNITS': UNITS, 'BUILDINGS': BUILDINGS}

	if not isinstance(token, basestring):
		return token # probably numeric already
	if not token.startswith(token_klass):
		return token
	try:
		return getattr( classes[token_klass], token.split(".", 2)[1])
	except AttributeError as e: # token not defined here
		err = "This means that you either have to add an entry in horizons/constants.py "\
		      "in the class %s for %s,\nor %s is actually a typo." % (token_klass, token, token)
		raise Exception( str(e) + "\n\n" + err +"\n" )

def list_all_files():
	result = []
	for folder in locations_to_translate:
		for directory, subdirs, files in os.walk(folder):
			for filename in files:
				if filename.endswith('.yaml') and filename not in files_to_skip:
					result.append(os.path.join(directory, filename))
	return sorted(result)

def content_from_file(filename):
	parsed = load(file(filename, 'r'), Loader=Loader)
	object_strings = []
	if not parsed:
		return ''
	def add_line(value, component, sep, key, filename):
		if value.startswith('_ '):
			text = '_("{value}")'.format(value=value[2:])
			component = component + sep + str(parse_token(key, 'TIER'))
			filename = filename.rsplit('.yaml')[0].split(OBJECT_PATH)[1].replace('/',':')
			comment = '%s of %s' %(component, filename)
			object_strings.append('# %s' %comment + ROWINDENT + '%-30s: %s' % (('"%s"') % component, text))

	for component, value in parsed.iteritems():
		if isinstance(value, basestring):
			add_line(value, component, '', '', filename)
		elif isinstance(value, dict):
			for key, subvalue in value.iteritems():
				if isinstance(subvalue, basestring):
					add_line(subvalue, component, "_", str(key), filename)
		elif isinstance(value, list): # build menu definitions
			for attrlist in value:
				if isinstance(attrlist, dict):
					for key, subvalue in attrlist.iteritems():
						if isinstance(subvalue, basestring):
							add_line(subvalue, component, "_", str(key), filename)
				else:
					for subvalue in attrlist:
						if isinstance(subvalue, basestring):
							add_line(subvalue, 'headline', '', '', filename)

	strings = sorted(object_strings)

	if strings:
		return ('\n\t"%s" : {' % filename) + \
		       (ROWINDENT + '%s,' % (','+ROWINDENT).join(strings)) + ROWINDENT + '},'
	else:
		return ''

filesnippets = (content_from_file(filename) for filename in list_all_files())
filesnippets = (content for content in filesnippets if content != '')

output = '%s%s%s' % (HEADER, '\n'.join(filesnippets), FOOTER)

if len(sys.argv) > 1:
	file(sys.argv[1], 'w').write(output)
else:
	print output

########NEW FILE########
__FILENAME__ = extract_strings_from_sqlite
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

###############################################################################
#
# == I18N DEV USE CASES: CHEATSHEET ==
#
# ** Refer to  development/create_pot.sh  for help with building or updating
#    the translation files for Unknown Horizons.
#
###############################################################################
#
# THIS SCRIPT IS A HELPER SCRIPT. DO NOT INVOKE MANUALLY!
#
###############################################################################

import os
import sqlalchemy
import sqlalchemy.orm
import sqlalchemy.ext.declarative
import sqlite3
import sys
import tempfile
from collections import defaultdict

sys.path.append(".")
sys.path.append("./horizons")

from horizons.constants import PATHS


# sqlalchemy doesn't support importing sql files,
# therefore we work around this by using sqlite3

filename = tempfile.mkstemp(text = True)[1]
conn = sqlite3.connect(filename)

for db_file in PATHS.DB_FILES:
	conn.executescript( open(db_file, "r").read())

conn.commit()

engine = sqlalchemy.create_engine('sqlite:///'+filename) # must be 4 slashes total, sqlalchemy breaks the unixoid conventions here

Session = sqlalchemy.orm.sessionmaker(bind=engine)
db_session = Session()

Base = sqlalchemy.ext.declarative.declarative_base()



#
# Classes
#

class Message(Base):
	__tablename__ = 'message_text'

	text = sqlalchemy.Column(sqlalchemy.String, primary_key=True)

class Resource(Base):
	__tablename__ = 'resource'

	name = sqlalchemy.Column(sqlalchemy.String, primary_key=True)

class Tier(Base):
	__tablename__ = 'tier'

	name = sqlalchemy.Column(sqlalchemy.String, primary_key=True)

#
# print it
#

class MSGID_collect:
	msgids = defaultdict(list)

	def __init__(self):
		pass

	def add_to_collection(self, msgid, place):
		self.msgids[msgid].append(place)

	def __str__(self):
		s = []
		for text, locations in self.msgids.items():
			comment = '#. This is a database entry: %s\n' % ','.join(locations)
			s += [comment + build_msgid(text)]
		return '\n'.join(s).strip()

def build_msgid(msgid):
	return 'msgid "%s"\nmsgstr ""\n' % msgid.replace('"','\\"')

def collect_all():
	collector = MSGID_collect()

	for message in db_session.query(Message):
		collector.add_to_collection(message.text, 'a messagewidget message (left part of the screen)')

	for resource in db_session.query(Resource):
		collector.add_to_collection(resource.name, 'the name of a resource')

	for tier in db_session.query(Tier):
		collector.add_to_collection(tier.name, 'the name of an inhabitant tier (level)')

	return collector


print collect_all()
os.unlink(filename)

########NEW FILE########
__FILENAME__ = extract_strings_from_xml
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

###############################################################################
#
# == I18N DEV USE CASES: CHEATSHEET ==
#
# ** Refer to  development/create_pot.sh  for help with building or updating
#    the translation files for Unknown Horizons.
#
###############################################################################
#
# THIS SCRIPT IS A HELPER SCRIPT. DO NOT INVOKE MANUALLY!
#
###############################################################################

import os
import sys
from xml.dom import minidom

from horizons.gui.widgets.imagebutton import OkButton, CancelButton, DeleteButton


if len(sys.argv) != 2:
	print 'Error: Provide a file to write strings to as argument. Exiting.'
	sys.exit(1)

header = u'''\
# Encoding: utf-8
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

###############################################################################
#
# == I18N DEV USE CASES: CHEATSHEET ==
#
# ** Refer to  development/create_pot.sh  for help with building or updating
#    the translation files for Unknown Horizons.
#
###############################################################################
#
# WARNING: This file is generated automagically.
#          You need to update it to see changes to strings in-game.
#          DO NOT MANUALLY UPDATE THIS FILE (by editing strings).
#          The script to generate .pot templates calls the following:
# ./development/extract_strings_from_xml.py  horizons/gui/translations.py
#
# NOTE: In string-freeze mode (shortly before releases, usually
#       announced in a meeting), updates to this file must not happen
#       without permission of the responsible translation admin!
#
###############################################################################

from horizons.constants import VERSION

text_translations = {}

def set_translations():
	global text_translations
	text_translations = {
'''

FOOTER = u'''
	}
'''

FILE = u'''
	{filename!r} : {{
{entries}		}},
'''

ENTRY = u'''\
		({widget!r:<32}, {attribute!r:<10}): {text},
'''

files_to_skip = [
	'credits.xml',
	'stringpreviewwidget.xml',
	'startup_error_popup.xml',
]


def print_n_no_name(n, text):
	print '\tWarning: ',
	print '%s without name. Add unique name if desired: text="%s"' % (n, text)

def list_all_files():
	result = []
	walker = os.walk('content/gui/xml')
	for root, dirs, files in walker:
		for filename in files:
			if filename.endswith('.xml'):
				result.append(('%s/%s' % (root, filename), filename not in files_to_skip))
	return sorted(result)

def content_from_element(element_name, parse_tree, attribute):
	"""Extracts text content of one attribute from a widget in the DOM.

	element_name: name of widget
	parse_tree: xml tree to parse
	attribute: usually 'text' or 'helptext'
	"""
	default_names = {
		'OkButton': OkButton.DEFAULT_NAME,
		'CancelButton': CancelButton.DEFAULT_NAME,
		'DeleteButton': DeleteButton.DEFAULT_NAME,
	}
	element_strings = []
	element_list = parse_tree.getElementsByTagName(element_name)

	for element in element_list:
		name = element.getAttribute('name')
		text = element.getAttribute(attribute)
		i18n = element.getAttribute('comment') # translator comment about widget context
		if i18n == 'noi18n':
			# comment='noi18n' in widgets where translation is not desired
			continue

		if i18n == 'noi18n_%s' % attribute:
			# comment='noi18n_tooltip' in widgets where tooltip translation is not
			# desired, but text should be translated.
			continue

		if not name:
			if element_name in default_names:
				name = default_names[element_name]
			elif text:
				print_n_no_name(element_name, text)

		if text and name:
			if name == 'version_label':
				text = 'VERSION.string()'
			else:
				text = '_(u"%s")' % text
			newline = ENTRY.format(attribute=attribute, widget=name, text=text)
			element_strings.append(newline)

	return ''.join(sorted(element_strings))

def content_from_file(filename, parse=True):
	"""Set parse=False if you want to list the widget in guitranslations,
	but not the strings. Usually because those strings are not reasonable
	to translate (credits, development widgets).
	"""
	def empty():
		return FILE.format(filename=printname, entries='')

	parsed = minidom.parse(filename)

	#HACK! we strip the string until no "/" occurs and then use the remaining part
	# this is necessary because of our dynamic widget loading (by unique file names)
	printname = filename.rsplit("/", 1)[1]
	if not parse:
		return empty()

	strings = ''
	for w in ['Button', 'CheckBox', 'Label', 'RadioButton']:
		strings += content_from_element(w, parsed, 'text')
	for w in ['CancelButton', 'DeleteButton', 'OkButton', 'Button', 'Icon', 'ImageButton', 'Label', 'ProgressBar']:
		strings += content_from_element(w, parsed, 'helptext')

	if not strings:
		return empty()

	return FILE.format(filename=printname, entries=strings)

filesnippets = (content_from_file(filename, parse) for (filename, parse) in list_all_files())
filesnippets = ''.join(content for content in filesnippets if content)

output = '%s%s%s' % (header, filesnippets, FOOTER)

file(sys.argv[1], 'w').write(output.encode('utf-8'))

########NEW FILE########
__FILENAME__ = generate_credits
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from collections import OrderedDict


sections = ['UH-Team', 'Patchers', 'Translators', 'Packagers', 'Special Thanks']
section_widgets = {s: 'credits_' + s.lower() for s in sections}
section_widgets.update({'UH-Team': 'credits_team', 'Special Thanks': 'credits_thanks'})

# Whether to add ScrollAreas around the page
huge_pages = ['Translators']

INPUT = 'doc/AUTHORS.md'
OUTPUT = 'content/gui/xml/mainmenu/credits.xml'

HEADER = ur'''<?xml version="1.0"?>

<!--  /!\ WARNING /!\
This document was auto-generated from %s.
Please edit %s instead if you need to change something,
afterwards run %s to refresh this file.
-->

<Container name="credits_window" size="1000,580">
	<Icon image="content/gui/images/background/book.png" position="100,0" />
	<Container name="left_pickbelts" size="170,580" position="30,0" />''' % (INPUT, INPUT, __file__)
FOOTER = ur'''
<OkButton position="800,500" helptext="Exit to main menu" />

<Container name="right_pickbelts" position="835,0" size="170,580" />

</Container>'''

XML_MESS = [  # (search, replace) list of stuff we need to replace before writing xml manually
	('&', '&amp;'),
]

def write(f, level, text, newline=True):
	wtext = u'\n' * newline + u'\t' * level + text
	for search, replace in XML_MESS:
		wtext = wtext.replace(search, replace)
	f.write(wtext.encode('utf8'))

def close_box(box, level):
	write(f, level, u'</%sBox>' % box)
def close_vbox(level):
	close_box('V', level)
def close_hbox(level):
	close_box('H', level)


class PageBreak(Exception):
	"""Used to wrap content onto two-page logbook layout."""


def parse_markdown(infile):
	"""Parses very simple markdown files (#headings and *lists).

	No support for line breaks."""
	tree = OrderedDict()
	headings = [(0, tree)]

	with open(infile) as f:
		for line in f:
			line = line.strip()
			if line.startswith('#'):
				parts = line.split(' ')
				heading_level = parts[0].count('##')
				while heading_level <= headings[-1][0]:
					headings.pop()

				parts = parts[1:]
				if set(parts[-1]) == set('#'):
					parts = parts[:-1]
				text = ' '.join(parts)
				dct = OrderedDict()
				headings[-1][1][text] = dct
				headings.append((heading_level, dct))
			elif line.startswith('*') or line.startswith('- -'):
				if 'items' not in headings[-1][1]:
					headings[-1][1]['items'] = []

				heading = line[1:].lstrip()
				headings[-1][1]['items'].append(heading)
			elif not line:
				pass
			else:
				raise Exception('Unexpected line: ' + line)
	return headings[0][1]


def write_page(heading, content):
	def write_page_header():
		if heading in huge_pages:
			write(f, 1, u'<ScrollArea name="%s" '
					  u'max_size="310,500" min_size="310,500">' % heading.lower())
			# Make sure there is no max_size set in this case!
			write(f, 1, u'<VBox min_size="310,500">')
		else:
			write(f, 1, u'<VBox max_size="310,500" min_size="310,500">')

	def write_page_footer():
		close_vbox(1)
		if heading in huge_pages:
			write(f, 1, u'</ScrollArea>')

	write(f, 0, u'\n<HBox name="%s" position="185,45" padding="10">' % section_widgets[heading])

	write_page_header()

	write(f, 2, u'<Label text="%s" name="headline" />' % heading)
	write(f, 2, u'<hr />')

	for h3, lines in content.items():
		try:
			write_subsection(h3, lines)
		except PageBreak:
			# On to the right part of this page, add second VBox to HBox
			write_page_footer()
			write_page_header()

	write_page_footer()
	close_hbox(0)


def write_subsection(subheading, subcontent):
	write(f, 2, u'<VBox> <Label text="%s" name="headline" />' % subheading)
	write(f, 3, u'<VBox name="box">')
	for line in subcontent['items']:  # finally, names
		if set(line) == set('- '):
			close_vbox(3)
			close_vbox(2)
			raise PageBreak
		else:
			write(f, 4, u'<Label text="%s" />' % unicode(line, 'utf-8'))
	close_vbox(3)
	close_vbox(2)


credits = parse_markdown(INPUT)

# Now manually write pychan-suited xml file

with open(OUTPUT, 'w') as f:
	write(f, 0, HEADER, newline=False)
	for h1, dct in credits.items():  # credits pages (pickbelts)
		write_page(h1, dct)
	write(f, 0, FOOTER)

########NEW FILE########
__FILENAME__ = networkclient
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


import getopt
import os
import sys
import platform
import signal
import logging
import logging.config
import logging.handlers

sys.path.append(os.getcwd())
from horizons.network.client import Client, ClientMode
import horizons.network

#-------------------------------------------------------------------------------

class AlarmException(Exception):
  pass

def alarmhandler(signum, frame):
  raise AlarmException

def nbrawinput(prompt='', timeout=1):
  signal.signal(signal.SIGALRM, alarmhandler)
  signal.alarm(timeout)
  try:
    text = raw_input(prompt)
    signal.alarm(0)
    return text
  except AlarmException:
    """nothing in here"""
  signal.signal(signal.SIGALRM, signal.SIG_IGN)
  return None

#-------------------------------------------------------------------------------

def usage():
  print "Usage: %s -h host -p port" % (sys.argv[0])

def onquit(*args):
  try:
    client.disconnect()
  except horizons.network.NetworkException:
    """ignore the errors"""
  sys.exit(0)

def onconnect(*args):
  global client
  client.connect()

def ondisconnect(*args):
  global client
  client.disconnect()

def onlist(*args):
  global client
  games = client.listgames(*args)
  if games:
    print "[GAMESLIST]"
    for game in games:
      print "  [%s] map=%s maxplayers=%d playercnt=%d name=%s" % (game.uuid, game.mapname, game.maxplayers, game.playercnt, game.name)
  else:
    print "No games available"

def oncreate(*args):
  global client
  if len(args) != 3:
    print "Syntax: create <mapname> <maxplayers> <gamename>"
    return
  try:
    maxplayers = int(args[1])
    game = client.creategame(unicode(args[0]), maxplayers, unicode(args[2]))
    print "[GAME] [%s] mapname=%s maxplayers=%d playercnt=%d" % (game.uuid, game.mapname, game.maxplayers, game.playercnt)
    for player in game.players:
      print "  Player: %s (%s)" % (player.name, player.sid)
  except (ValueError, IndexError):
    print "Maxplayers must be an integer"

def onjoin(*args):
  global client
  if len(args) != 1:
    print "Syntax: join <uuid>"
    return
  try:
    game = client.joingame(unicode(args[0]))
    print "[GAME] [%s] mapname=%s maxplayers=%d playercnt=%d" % (game.uuid, game.mapname, game.maxplayers, game.playercnt)
    for player in game.players:
      print "  Player: %s (%s)" % (player.name, player.sid)
  except ValueError:
    print "Invalid UUID"

def onleave(*args):
  global client
  client.leavegame()

def onchat(*args):
  global client
  client.chat(u' '.join(args))

def cb_onchat(game, player, msg):
  print "[ONCHAT] [%s] %s: %s" % (game.uuid, player, msg)

def cb_onjoin(game, player):
  print "[ONJOIN] [%s] %s joins" % (game.uuid, player)

def cb_onleave(game, player):
  print "[ONLEAVE] [%s] %s leaves" % (game.uuid, player)

def cb_onchangename(game, oldplayer, newplayer, myself):
  global name
  print "[ONCHANGENAME] [%s] %s changed name to %s" % (game.uuid, oldplayer.name, newplayer.name)
  if myself:
    name = newplayer.name
    print "[NAME] My new name is %s" % (name)

def cb_ongameprepare(game):
  print "[ONGAMEPREPARE]"

def cb_ongamestarts(game):
  print "[ONGAMESTART]"

def cb_ongamedata(data):
  print "[ONGAMEDATA]: %s" % (data)

def onauto(*args):
  global client
  mapname = u"autocreated"
  gamename = u"mygame"
  maxplayers = 4
  if len(args) >= 1:
    mapname = unicode(args[0])
  if len(args) >= 2:
    try:
      maxplayers = int(args[1])
    except (ValueError, IndexError):
      print "Maxplayers must be an integer"
      return
  client.connect()
  games = client.listgames(mapname, maxplayers)
  if games:
    game = client.joingame(games[0].uuid)
  else:
    game = client.creategame(mapname, maxplayers, gamename)
  print "[GAME] [%s] mapname=%s maxplayers=%d playercnt=%d" % (game.uuid, game.mapname, game.maxplayers, game.playercnt)
  for player in game.players:
    print "  Player: %s" % (player.name)
  client.chat("I am here guys. Game can start")

def ongamedata(*args):
  global client
  if client.mode is not ClientMode.Game:
    print "[ERROR] Client not in game mode"
    return
  client.send(u' '.join(args))

def onname(*args):
  global name, client
  if len(args) == 1:
    # see documentation for client.changename() why this code is like that
    if not client.changename(unicode(args[0])):
      return
    name = unicode(args[0])
  print "[NAME] My name is %s" % (name)

def onstatus(*args):
  global name, client
  statusstr = "[STATUS]"
  statusstr += " name=%s" % (name)
  statusstr += " mode=%s" % ("GAME" if client.mode is ClientMode.Game else "Server")
  statusstr += " connected=%s" % ("yes" if client.isconnected() else "no")
  statusstr += " server=%s" % (client.serveraddress)
  print statusstr
  if client.isconnected():
    if client.game is not None:
      print "[STATUS] game: uuid=%s mapname=%s maxplayers=%d playercnt=%d" % (client.game.uuid, client.game.mapname, client.game.maxplayers, client.game.playercnt)
      for player in client.game.players:
        print "[STATUS]  Player: %s" % (player.name)

def onhelp(*args):
  global commands, prompt
  print "Available commands:"
  for command in sorted(commands.iterkeys()):
    print "  %s" % (command)

#-------------------------------------------------------------------------------

host = None
port = 0
commands = {
  'help':       onhelp,
  'connect':    onconnect,
  'disconnect': ondisconnect,
  'list':       onlist,
  'create':     oncreate,
  'join':       onjoin,
  'leave':      onleave,
  'chat':       onchat,
  'quit':       onquit,
  'auto':       onauto,
  'gamedata':   ongamedata,
  'name':       onname,
  'status':     onstatus,
}
prompt = ">>>"

if platform.system() == "Windows":
  print "Testclient doesn't run on windows"
  sys.exit(1)

try:
  opts, args = getopt.getopt(sys.argv[1:], 'h:p:')
except getopt.GetoptError as err:
  print str(err)
  usage()
  sys.exit(1)

try:
  for (key, value) in opts:
    if key == '-h':
      host = value
    if key == '-p':
      port = int(value)
except (ValueError, IndexError):
  port = 0

if host == None or port == None or port <= 0:
  usage()
  sys.exit(1)

logging.config.fileConfig( os.path.join('content', 'logging.conf'))
logging.getLogger().addHandler(logging.StreamHandler(sys.stderr))
logging.getLogger("network").setLevel(logging.DEBUG)

client = None
version = u"0.512a"
name = u"client-%u" % (os.getpid())
onname()
client = Client(name, version, [host, port], None)
client.register_callback("lobbygame_chat", cb_onchat)
client.register_callback("lobbygame_join", cb_onjoin)
client.register_callback("lobbygame_leave", cb_onleave)
client.register_callback("lobbygame_changename", cb_onchangename)
client.register_callback("lobbygame_starts", cb_ongameprepare)
client.register_callback("game_starts", cb_ongamestarts)
client.register_callback("game_data", cb_ongamedata)

print prompt,
while True:
  try:
    if client.isconnected():
      client.ping()

    text = nbrawinput()
    if text is None:
      continue

    pieces = filter(lambda x: len(x.strip()) > 0, text.strip().split(' '))
    if len(pieces) <= 0:
      print prompt,
      continue

    cmd = pieces.pop(0)
    if cmd not in commands:
      print "[ERROR] Unknown command"
    else:
      commands[cmd](*pieces)
  except horizons.network.NetworkException as e:
    print "[ERROR] %s" % (e)
  print prompt,

########NEW FILE########
__FILENAME__ = nsiscripter
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os
import os.path
import sys

def remove_double(liste):
	return [i.replace('\\\\', '\\') for i in liste]

if not os.path.split(os.getcwd())[1] == 'development':
	print "This program expects to be invoked from the Unknown Horizons development directory"
	sys.exit(-1)

os.chdir('..') #Change to the root directory

installed_files = [] #List of files being installed
installed_dirs  = [] #List of directories being installed

inst = []
remf = []
remd = []

for root, dirs, files in os.walk('.'):
	if 'development' in dirs:
		dirs.remove('development')
	if '.git' in dirs:
		dirs.remove('.git')
	if root[-4:] == 'fife' and len(root.split('\\')) == 2:
		for d in dirs[:]:
			if d not in ('engine', 'tools'):
				dirs.remove(d)
	if '.gitignore' in files:
		files.remove('.gitignore')
	if 'Thumbs.db' in files:
		files.remove('Thumbs.db')
	if 'Setup.exe' in files:
		files.remove('Setup.exe')

	if files or dirs:
		rootp = root[2:]
		if rootp[:4] == 'fife':
			if rootp[-4:] == 'fife' and len(rootp.split('\\')) == 1:
				files = filter(lambda f: f in ('AUTHORS', 'COPYING', 'README'), files)
			elif 'editor' in rootp.split('\\'):
				files = filter(lambda s: s.split('.')[-1] not in ('pyc', 'log'), files)
			else:
				files = filter(lambda s: s.split('.')[-1] in ('dll', 'py', 'pyd'), files)
			if not len(files):
				continue
		else:
			files = filter(lambda s: s.split('.')[-1] not in ('pyc', 'log', 'nsi'), files)
		inst.append( ('	SetOutPath "$INSTDIR/%s"' % rootp).replace('/', '\\'))
		installed_dirs.append(rootp)
		for j in files:
			inst.append( ('	File "./%s/%s"' % (rootp, j)).replace('/', '\\'))
			installed_files.append('%s/%s' % (rootp, j))
			if j[-3:] == '.py':
				installed_files.append('%s.pyc' % ('%s/%s' % (rootp, j))[:-3])

installed_dirs.extend(['fife\\engine\\python', 'fife\\engine', 'fife'])

for f in installed_files:
	remf.append( ('	Delete "$INSTDIR/%s"' % f).replace('/', '\\'))

for d in installed_dirs:
	pref = ""
	for i in d.split('/'):
		pref = i if not pref else "%s/%s" % (pref, i)
		remd.append( ('	RMDir "$INSTDIR/%s"' % pref).replace('/', '\\'))

if len(sys.argv) > 1:
	version = sys.argv[1]
else:
	version = raw_input('Version: ')

file('install.nsi', 'w').write(file('development/nsi.template', 'r').read() % (version, '\n'.join(remove_double(inst)), "0x%08X", '\n'.join(remove_double(remf)), '\n'.join(remove_double(sorted(list(set(remd)), lambda x,y: 1 if len(x) < len(y) else -1)))))

########NEW FILE########
__FILENAME__ = print_db_data
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

"""
This script prints misc data from the db
in human readable form.

Run without arguments for help
"""

import inspect
import pprint
import sys
from collections import defaultdict

sys.path.append(".")
sys.path.append("./horizons")
sys.path.append("./horizons/util")

try:
	import run_uh
except ImportError as e:
	print e.message
	print 'Please run from uh root dir'
	sys.exit(1)


from run_uh import init_environment
init_environment(True)

import horizons.main
from horizons.constants import UNITS, BUILDINGS, TIER
from horizons.scenario.actions import ACTIONS
from horizons.scenario.conditions import CONDITIONS

db = horizons.main._create_main_db()

# we also need to load entities to get access to the yaml data
from horizons.extscheduler import ExtScheduler
from horizons.component.storagecomponent import StorageComponent
from horizons.entities import Entities
from horizons.ext.dummy import Dummy
ExtScheduler.create_instance(Dummy()) # sometimes needed by entities in subsequent calls
Entities.load_buildings(db, load_now=True)
Entities.load_units(load_now=True)

building_name_mapping = dict( (b.id, b.name) for b in Entities.buildings.itervalues() )
unit_name_mapping = dict( (u.id, u.name) for u in Entities.units.itervalues() )

def get_obj_name(obj):
	global db
	if obj < UNITS.DIFFERENCE_BUILDING_UNIT_ID:
		return db("SELECT name FROM building where id = ?", obj)[0][0]
	else:
		return unit_name_mapping[obj]

def get_res_name(res):
	global db
	try:
		name = db("SELECT name FROM resource WHERE id = ?", res)[0][0]
	except IndexError: # might be a unit instead
		name = get_obj_name(res)
	return name

def get_settler_name(tier):
	global db
	return db("SELECT name FROM tier WHERE level = ?", tier)[0][0]

def format_prodline(line_list, depth):
	for res, amount in line_list:
		print ' '*depth, '{amount:>4} {name:16} ({id:2})'.format(
			amount=abs(amount), name=get_res_name(res), id=res)

def print_production_lines():
	print 'Production lines per building:'
	for b in Entities.buildings.itervalues():
		print '\n', b.name, '\n', '='*len(b.name)
		for comp in b.component_templates:
			if not isinstance(comp, dict):
				continue
			for name, data in comp.iteritems():
				if 'produce' not in name.lower():
					continue
				for id, dct in data.get('productionlines').iteritems():
					if not dct:
						continue
					changes_animation = dct.get('changes_animation') is None
					changes_anim_text = changes_animation and 'changes animation' or 'does not change animation'
					disabled_by_default = dct.get('enabled_by_default') is not None
					enabled_text = (disabled_by_default and 'not ' or '') + 'enabled by default'
					time = dct.get('time') or 1
					print '{time:>3}s'.format(time=time), '('+changes_anim_text+',', enabled_text+')'
					consumes = dct.get('consumes')
					if consumes:
						print '   consumes'
						format_prodline(consumes, 4)
					produces = dct.get('produces')
					if produces:
						print '   produces'
						format_prodline(produces, 4)

def print_verbose_lines():
	print 'Data has been moved, this view is unavailable for now'
	return
	def _output_helper_prodlines(string, list):
		if len(list) == 1:
			for res, amount in list:
				print '      ' + str(string) + ':\t%s %s(%s)' % (abs(amount), get_res_name(res), res)
		elif len(list) > 1:
			print '      ' + str(string) + ': '
			for res, amount in list:
				print '\t\t%s %s (%s)' % (abs(amount), get_res_name(res), res)

	print 'Production Lines:'
	for prod_line in db("SELECT id, object_id, time, enabled_by_default FROM production_line \
	                     WHERE object_id != 3 ORDER BY object_id"):
		# do not include tent production lines here
		id = prod_line[0]
		object = prod_line[1]
		(consumption,production) = get_prod_line(id, list)

		print '%2s: %s(%s) needs %s seconds to' % (id, get_obj_name(object), object, prod_line[2])
		_output_helper_prodlines('consume', consumption)
		_output_helper_prodlines('produce', production)

def print_res():
	print 'Resources' + '\n' + '%2s: %-15s %5s %10s %19s' % ('id', 'resource', 'value', 'tradeable', 'shown_in_inventory')
	print '=' * 56
	for id, name, value, trade, inventory in db("SELECT id, name, value, tradeable, shown_in_inventory FROM resource"):
		print "%2s: %-16s %4s %6s %13s " % (id, name[0:16], value or '-', trade or '-', inventory or '-')

def print_building():
	print 'Buildings' + '\n' + 'Running costs scheme:'
	print '=' * 2 + 'Running===Paused' + '=' * 2
	for (cost, cost_inactive) in [('0-10',0),('11-24',5),('25-40',10),('>40',15)]:
		print "   %5s :   %2s" % (cost or '--', cost_inactive or '--')
	print '\n' + '=' * 23 + 'R===P' + '=' * 50
	for b in Entities.buildings.itervalues():
		print "%2s: %-16s %3s / %2s %5sx%1s %4s   %s" % \
		(b.id, b.name, b.running_costs or '--', b.running_costs_inactive or '--',
		 b.size[0], b.size[1], b.radius, b.baseclass)

def print_unit():
	print "Units (id: name (radius) from class)"
	for u in Entities.units.itervalues():
		print "%2s: %-22s (%2s) from %s" % ((u.id - UNITS.DIFFERENCE_BUILDING_UNIT_ID),
			u.name, u.radius, u.baseclass)
	print "Add %s to each ID if you want to use them." % UNITS.DIFFERENCE_BUILDING_UNIT_ID

def print_storage():
	for b in Entities.buildings.itervalues():
		try:
			stor = b.get_component_template( StorageComponent )
		except KeyError:
			continue
		if not stor:
			continue
		try:
			stor.values()[0].values()[0]
		except IndexError:
			continue
		print '%s(%i) can store:' % (b.name, b.id)
		for res, amount in stor.values()[0].values()[0].iteritems():
			print "\t%2s tons of %s(%s)" % (amount, get_res_name(res), res)

	print "\nAll others can store 30 tons of each res."
	#TODO show buildings with default storage here

def print_collectors():
	print 'Collectors: (building amount collector)'
	for b in Entities.buildings.itervalues():
		for comp in b.component_templates:
			if not isinstance(comp, dict):
				continue
			for name, data in comp.iteritems():
				if 'collect' not in name.lower():
					continue
				for id, amount in data.get('collectors').iteritems():
					print "%2s: %-18s %s %s (%s)" % (b.id, b.name, amount, get_obj_name(id), id)

def print_building_costs():
	print 'Building costs:'
	no_costs = []
	for b in Entities.buildings.itervalues():
		if not b.costs:
			no_costs.append(b)
			continue
		s = ''
		for res, amount in b.costs.iteritems():
			s += "%4i %s(%s) " % (amount, get_res_name(res),res)
		print "%2s: %-18s %s" % (b.id, b.name, s)

	print "\nBuildings without building costs:"
	for b in no_costs:
		print "%2i: %s" % (b.id, b.name)

def print_collector_restrictions():
	for u in Entities.units.itervalues():
		for comp in u.component_templates:
			if not isinstance(comp, dict):
				continue
			for name, data in comp.iteritems():
				if 'restricted' not in name.lower():
					continue
				print '%s(%s) is restricted to:' % (u.class_name, u.id)
				for building in data.get('allowed'):
					print '\t%s(%s)' % (building_name_mapping[building], building)

def print_tier_data():
	print 'Data has been moved, this view is unavailable for now'
	return
	upgrade_tiers = xrange(1, TIER.CURRENT_MAX+1)
	print '%15s %s %s  %s' % ('tier', 'max_inh', 'base_tax', 'upgrade_prod_line')
	print '=' * 64
	for inc, name, inh, tax in db('SELECT level, name, inhabitants_max, tax_income FROM tier'):
		str = '%3s %11s %5s    %4s' % ((inc+1), name, inh, tax)
		if inc+1 in upgrade_tiers:
			line = db("SELECT production_line FROM upgrade_material WHERE level = ?", inc+1)[0][0]
			str += 5 * ' ' + '%2s: ' % line
			(consumption, _) = get_prod_line(line, list)
			for (res, amount) in consumption:
				str += '%i %s(%s), ' % (-amount, get_res_name(res), res)
		print str

def print_colors():
	print 'Colors' + '\n' + '%2s: %12s  %3s  %3s  %3s  %3s  #%6s' % ('id', 'name', 'R ', 'G ', 'B ', 'A ', 'HEX   ')
	print '=' * 45
	for id_, name, R, G, B, alpha in db("SELECT id, name, red, green, blue, alpha FROM colors"):
		print '%2s: %12s  %3s  %3s  %3s  %3s  #' % (id_, name, R, G, B, alpha) + 3*'%02x' % (R, G, B)

def print_scenario_actions():
	print 'Available scenario actions and their arguments:'
	for action in ACTIONS.registry:
		arguments = inspect.getargspec(ACTIONS.get(action))[0][1:] # exclude session
		print '%-12s  %s' % (action, arguments or '')

def print_scenario_conditions():
	print 'Available scenario conditions and their arguments:'
	for condition in CONDITIONS.registry:
		arguments = inspect.getargspec(CONDITIONS.get(condition))[0][1:] # exclude session
		print '%-36s  %s' % (condition, arguments or '')

def print_names():
	text = ''
	for (table, type) in [('city', 'player'), ('city', 'pirate'), ('ship','player'), ('ship','pirate'), ('ship','fisher'), ('ship','trader')]:
		sql = "SELECT name FROM %snames WHERE for_%s = 1" % (table, type)
		names = db(sql)
		text += '\n' + "%s %s names" % (type, table) + '[list]\n'
		for name in map(lambda x: x[0], names):
			text += '[*] %s' % name + '\n'
		text += '[/list]' + '\n'
	print text

def print_settler_needs():
	klass = Entities.buildings[ BUILDINGS.RESIDENTIAL ]
	comp = [ i for i in klass.component_templates if i.keys()[0] == u'ProducerComponent' ][0]
	lines = comp.values()[0][u'productionlines']
	per_level = defaultdict(list)
	for line_data in lines.itervalues():
		level = line_data.get("level", [-1])
		for l in level:
			per_level[l].extend( [ res for (res, num) in line_data[u'consumes'] ] )
	data = dict( (k, sorted(db.get_res_name(i) for i in v)) for k,v in per_level.iteritems())
	print "Needed resources per tier"
	pprint.pprint(data)
	print '\nChanges per level:'
	for i in xrange(len(data)-2):
		s = str(i)+"/"+str(i+1)+": "
		for r in data[i+1]:
			if r not in data[i]:
				s += "+"+r+", "
		for r in data[i]:
			if r not in data[i+1]:
				s += "-"+r+", "
		print s


functions = {
		'actions' : print_scenario_actions,
		'buildings' : print_building,
		'building_costs' : print_building_costs,
		'colors' : print_colors,
		'collectors' : print_collectors,
		'collector_restrictions': print_collector_restrictions,
		'conditions' : print_scenario_conditions,
		'tiers' : print_tier_data,
		'lines' : print_production_lines,
		'names' : print_names,
		'resources' : print_res,
		'settler_needs' : print_settler_needs,
		'storage' : print_storage,
		'units' : print_unit,
		'verbose_lines' : print_production_lines,
		}
abbrevs = {
		'b' : 'buildings',
		'bc': 'building_costs',
		'building' : 'buildings',
		'c' : 'collectors',
		'cl' : 'colors',
		'cr': 'collector_restrictions',
		'i' : 'tiers',
		'tier' : 'tiers',
		'n' : 'names',
		'pl' : 'lines',
		'res' : 'resources',
		'settler_lines': 'tiers',
		'sl': 'tiers',
		'sn': 'settler_needs',
		'unit': 'units',
		'vl': 'verbose_lines',
		}

flags = dict(functions)
for (x,y) in abbrevs.iteritems(): # add convenience abbreviations to possible flags
	flags[x] = functions[y]

args = sys.argv

if len(args) == 1:
	print 'Start with one of those args: %s \nSupported abbreviations: %s' % (sorted(functions.keys()), sorted(abbrevs.keys()))
else:
	for i in flags.iteritems():
		if i[0].startswith(args[1]):
			i[1]()
			sys.exit(0)
	print 'Start with one of those args: %s \nSupported abbreviations: %s' % (functions.keys(), abbrevs.keys())

########NEW FILE########
__FILENAME__ = print_profile_output
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import pstats
import sys


if not sys.argv:
	print 'profile_output.py file [ sortstats [ ( callees | callers ) ] ]'
	sys.exit(1)

p = pstats.Stats(sys.argv[1])

p.strip_dirs()

arg2 = None if len(sys.argv) < 3 else sys.argv[2]

p.sort_stats(-1 if arg2 is None else arg2)

if not len(sys.argv) > 3:
	p.print_stats()
elif sys.argv[3] == 'callees':
	p.print_callees()
elif sys.argv[3] == 'callers':
	p.print_callers()
else:
	print 'invalid arg'


########NEW FILE########
__FILENAME__ = stringpreviewwidget
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.gui.util import load_uh_widget
from horizons.util.yamlcache import YamlCache
from horizons.savegamemanager import SavegameManager
from horizons.gui.widgets.imagebutton import OkButton
from horizons.gui.widgets.logbook import LogBook
from horizons.gui.windows import Window, WindowManager
from horizons.scheduler import Scheduler

class StringPreviewWidget(Window):
	"""Widget for testing Logbook strings.
	It provides a list of scenarios, of which the user can select one and display
	its strings in a logbook"""
	def __init__(self, session):
		super(StringPreviewWidget, self).__init__()
		self._init_gui(session)
		# allow for misc delayed initialization to finish before pausing
		Scheduler().add_new_object(session.speed_pause, self, 2)

	def show(self):
		self._gui.show()

	def _init_gui(self, session):
		self._gui = load_uh_widget("stringpreviewwidget.xml")
		self._gui.mapEvents({ 'load' : self.load })
		self.scenarios = SavegameManager.get_scenarios()
		self.listbox = self._gui.findChild(name="scenario_list")
		self.listbox.items = self.scenarios[1]
		self.listbox.distributeData({'scenario_list': 0})
		self.listbox.capture(self.update_infos)

		self.statslabel = self._gui.findChild(name="stats")

		self.windows = WindowManager()
		self.logbook = LogBook(session, self.windows)
		self.logbook._gui.mapEvents({
			OkButton.DEFAULT_NAME : self.logbook.hide,
		})
		self.update_infos()

	def update_infos(self):
		"""Updates the status label while scrolling the scenario list. No up-
		date to logbook messages. Those are loaded after Load/Reload is clicked.
		"""
		scenario_file_path = self.scenarios[0][self.listbox.selected]
		data = YamlCache.load_yaml_data(open(scenario_file_path, 'r'))

		if 'metadata' in data:
			# no stats available => empty label
			stats = data['metadata'].get('translation_status', '')
		else:
			# Old scenario syntax version without metadata
			stats = data.get('translation_status', '')
		self.statslabel.text = unicode(stats)

	def load(self):
		"""Load selected scenario and show strings"""
		# remember current entry
		cur_entry = self.logbook.get_cur_entry()
		cur_entry = cur_entry if cur_entry is not None else 0
		self.logbook.clear()

		# get logbook actions from scenario file and add them to our logbook
		scenario_file_path = self.scenarios[0][self.listbox.selected]
		data = YamlCache.load_yaml_data(open(scenario_file_path, 'r'))
		events = data['events']
		for event in events:
			for action in event['actions']:
				if action['type'] in ('logbook', 'logbook'):
					self.logbook.add_captainslog_entry(action['arguments'], show_logbook=False)

		try:
			self.logbook.set_cur_entry(cur_entry)
		except ValueError:
			pass # no entries
		self.logbook._redraw_captainslog()
		self.logbook.show()

########NEW FILE########
__FILENAME__ = time_uh
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import ctypes
import multiprocessing
import os
import os.path
import subprocess
import sys
import time

from optparse import AmbiguousOptionError, BadOptionError, OptionParser

# make this script work both when started inside development and in the uh root dir
if not os.path.exists('content'):
	os.chdir('..')
assert os.path.exists('content'), 'Content dir not found.'
sys.path.append('.')

class PassThroughOptionParser(OptionParser):
	"""Consider unrecognised options to be arguments."""
	def _process_args(self, largs, rargs, values):
		while rargs:
			try:
				OptionParser._process_args(self, largs, rargs, values)
			except (AmbiguousOptionError, BadOptionError), e:
				largs.append(e.opt_str)

def get_range(expr):
	if not expr:
		return [None]
	parts = []
	for part in expr.split(','):
		parts.append(int(part.strip()))
	return range(*tuple(parts))

def get_length(r):
	return max(len(str(min(r))), len(str(max(r))))

dev_null = open(os.devnull, 'w')

class GameTimer(object):
	def __init__(self, name, args):
		self.name = name
		self.args = args
		self.returncode = None
		self.time = None

	def run(self):
		start = time.time()
		args = ' '.join([sys.executable, 'run_uh.py'] + self.args)
		proc = subprocess.Popen(args, executable=sys.executable, stdin=dev_null, stdout=dev_null, stderr=dev_null)
		proc.wait()
		self.returncode = proc.returncode
		self.time = time.time() - start

	def __cmp__(self, other):
		if self.returncode != other.returncode:
			return -1 if self.returncode < other.returncode else 1
		if self.time == other.time:
			return 0
		return -1 if self.time < other.time else 1

def run_game_timer(game, queue, counter):
	game.run()
	queue.put_nowait(game)
	counter.value -= 1

def show_data(games):
	print
	for game in sorted(games):
		s = game.time
		h = s // 3600
		s %= 3600
		m = s // 60
		s %= 60
		print game.name, '%d:%02d:%06.3fs' % (h, m, s), game.returncode

if __name__ == '__main__':
	parser = PassThroughOptionParser()
	parser.add_option("-p", "--processes", dest="num_processes", metavar="<processes>",
	    type="int", default=1, help="Run <processes> processes in parallel.")
	parser.add_option("--game-seed-range", dest="game_seed_range",
	    help="Use the given expression (same as for xrange) to run a number of game instances with --sp-seed=SEED")
	parser.add_option("--map-seed-range", dest="map_seed_range",
	    help="Use the given expression (same as for xrange) to run a number of game instances with --start-specific-random-map=SEED")
	(options, args) = parser.parse_args()

	games = []
	game_seed_len = get_length(get_range(options.game_seed_range))
	map_seed_len = get_length(get_range(options.map_seed_range))
	for sp_seed in get_range(options.game_seed_range):
		for map_seed in get_range(options.map_seed_range):
			name = 'game'
			args_t = args + []
			if sp_seed is not None:
				args_t.append('--sp-seed=' + str(sp_seed))
				name += ('-s%0' + str(game_seed_len) + 'd') % sp_seed
			if map_seed is not None:
				args_t.append('--start-specific-random-map=' + str(map_seed))
				name += ('-m%0' + str(map_seed_len) + 'd') % map_seed
			games.append(GameTimer(name, args_t))

	manager = multiprocessing.Manager()
	queue = manager.Queue()
	counter = manager.Value(ctypes.c_int, len(games))
	pool = multiprocessing.Pool(processes=options.num_processes)
	for game in games:
		pool.apply_async(run_game_timer, [game, queue, counter])
	pool.close()

	data = []
	try:
		while not queue.empty() or counter.value > 0:
			changed = False
			while not queue.empty():
				game = queue.get()
				data.append(game)
				changed = True
			if changed:
				show_data(data)
			time.sleep(0.05)
	except KeyboardInterrupt:
		pool.terminate()

########NEW FILE########
__FILENAME__ = translate_scenario
#!/usr/bin/env python2
# Encoding: utf-8
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import gettext
import os
import re
import subprocess
import sys
import yaml

# Where to find initial untranslated scenario (with language `en`) and,
# simultaneously, where to write final translated scenario .yaml to
YAML_PATH = '{path_prefix}content/scenarios/{scenario}_{language}.yaml'
# Where to write compiled (bytecode) translations for scenarios to.
# Note: this is a temporary path and only required as intermediate step.
MO_OUTPUT = 'po/mo/'
MSGFMT_PATH = '{MO_OUTPUT}/{language}/LC_MESSAGES/'
# Where we store our gettext scenario translation files (in non-GNU layout)
PO_INPUT_PATH = 'po/scenarios/{language}/{scenario}.po'

# po/scenarios/sv/The_Unknown.po
WEBLATE_PATH = re.compile(r'''
	(.*/?)         # path to UH in Weblate repo
	po/scenarios/  # path in UH repo
	([^/]*)/       # \2 == 'sv'
	([^\.]*)\.po   # \3 == 'The_Unknown'
	''', re.VERBOSE)

def setup_paths():
	match = WEBLATE_PATH.match(sys.argv[1])
	path_prefix = match.group(1)
	# ISO 639-1 code of desired translation on Weblate (`af`, `hr`, ...)
	language_path = match.group(2)
	# name of English .yaml scenario file
	scenario_path = match.group(3)

	if not os.path.exists(scenario_path):
		scenario_path = YAML_PATH.format(path_prefix=path_prefix, scenario=scenario_path, language='en')
	if not os.path.exists(scenario_path):
		print 'Scenario file not found:', scenario_path
		sys.exit(1)

	# drop [_en].yaml suffix and paths to file to obtain base scenario name
	scenario = os.path.splitext(os.path.basename(scenario_path))[0]
	if scenario.endswith('_en'):
		scenario = scenario[:-3]

	if os.path.exists(language_path):
		dirname = os.path.dirname(language_path)
		language = dirname.split(os.path.sep)[-1]
	else:
		language = language_path
		language_path = PO_INPUT_PATH.format(scenario=scenario, language=language)

	yaml_output = YAML_PATH.format(path_prefix=path_prefix, scenario=scenario, language=language)
	msgfmt_output = MSGFMT_PATH.format(MO_OUTPUT=MO_OUTPUT, language=language) + '%s.mo' % scenario

	# If path for compiled translations does not exist yet, create it
	subprocess.call(['mkdir', '-p', MSGFMT_PATH.format(MO_OUTPUT=MO_OUTPUT, language=language)])

	return (path_prefix,
	        scenario, scenario_path,
	        language, language_path,
	        yaml_output, msgfmt_output)


def setup_gettext(scenario, language):
	try:
		translation = gettext.translation(scenario, MO_OUTPUT, [language])
	except IOError:
		# IOError: [Errno 2] No translation file found for domain
		print('No compiled translation for domain `%s` and language `%s` in `%s`. '
		      'Exiting.' % (scenario, language, MO_OUTPUT))
		sys.exit(1)
	else:
		translation.install(unicode=True)


def compile_scenario_po(output_mo):
	input_po = sys.argv[1]
	if not os.path.exists(input_po):
		print('Input file does not exist: %s' % input_po)
		sys.exit(1)
	try:
		stats = subprocess.check_output([
			'msgfmt',
			'--statistics',
			'--check-format',
			input_po,
			'-o', output_mo,
		], stderr=subprocess.STDOUT)
	except subprocess.CalledProcessError:
		#TODO handle
		print('Error while compiling translation `%s`, probably malformed `.po`. '
		      'Exiting.' % input_po)
		sys.exit(1)
	else:
		return stats


def write_translated_yaml(fileish, where, metadata, generator):
	"""Copy content of .yaml scenario file while translating parts of it.

	In particular, arguments of these event types will be translated:
		Headline, Label, Message
	Uses a regular gettext .po file on Weblate to read translations from.
	The .pot template file for those currently is generated by invoking
	`create_scenario_pot.sh` with the scenario name as parameter.
	Scenario translation files are stored in po/scenarios/.
	"""

	def translate(string):
		return _(string.rstrip('\n'))

	def preprint(yamlish, new_anchor, just_copy=True):
		"""Prepare untranslated .yaml input *yamlish* for translation

		Depending on current state of our manual parser, we either want to
		just copy the lines (because there is nothing to translate), or pass
		some arguments to gettext where they will be translated and written
		back to the new file.
		To retain yaml anchors (`&THESE_THINGS`) and their references, split
		the yaml stream into chunks for each anchor we detect. Using
		yaml.SafeLoader on those chunks is possible to obtain correct data
		structures (since we are hacking the output to repair indentation).
		"""
		if just_copy:
			where.writelines(yamlish)
			where.write(new_anchor)
			return

		new_anchor = new_anchor.rstrip('\n')
		loaded_yaml = yaml.safe_load(''.join(yamlish))
		all_events = []
		for event in loaded_yaml:
			if isinstance(event, basestring):
				if event.strip():
					event = translate(event)
			if isinstance(event, list):
				widget = event[0]
				if widget in ('Gallery', 'Image', 'Pagebreak'):
					pass
				if widget in ('Headline', 'Label', 'BoldLabel', 'Message'):
					event = [widget] + map(translate, event[1:])

			all_events.append(event)

		# allow_unicode: Without this, would dump '\xF6' instead of 'ö'.
		# width: Default width would wrap at ~80 chars, not matching the english sources
		dumpster = yaml.safe_dump(all_events, allow_unicode=True, width=1000)
		# Manually indent since we manually keep anchors
		# (pyyaml would rename and otherwise mess with them)
		for line in dumpster.split('\n'):
			indent = '  ' if line else ''
			where.write(indent + line + '\n')

		where.write(new_anchor + '\n')

	def write_translated_metadata(translated_metadata):
		# Prepare 'metadata' dictionary for the translated scenario
		file_metadata = yaml.safe_load(''.join(fileish))['metadata']
		translated_metadata = file_metadata.copy()
		# Manually invoke translation of strings exposed to player that are
		# reasonable to translate.
		for key in ('author', 'description', 'difficulty'):
			value = file_metadata[key]
			translated_metadata[key] = translate(value)
		# Add (untranslated) information passed to this function, such as
		# translation status from gettext or the file locale, if available.
		if metadata:
			translated_metadata.update(metadata)
		# All of this is dumped to file when we encounter a 'metadata:' line
		# while manually parsing the original scenario line-by-line. Ugly.
		m = {'metadata': translated_metadata}
		dumped = yaml.safe_dump(m, allow_unicode=True, width=1000, default_flow_style=False)
		where.write(dumped)

	where.write('''\
# DO NOT MANUALLY EDIT THIS FILE.

# It was automatically generated by {0}
# using translation files from Weblate and the original scenario file
# {1}
\n'''.format(generator, metadata['original']))

	# Manually track currently seen anchor (to delimit sections)
	anchors = []
	# List of yaml content lines for each section (to be loaded by `yaml`)
	sections = [[]]
	# Copy everything looking like a header (lines before the first anchor)
	seen_start_anchor = False
	# Copy everything after `logbook-data` (scenario conditions/actions, metadata)
	copy_again = False

	for line in fileish:

		if copy_again:
			if line.startswith('metadata:'):
				write_translated_metadata(1)
				break
			where.write(line)

		elif line.startswith('- '):
			# New anchor detected.
			# If this is our first anchor, stop just copying lines
			# and enter translation mode instead (seen_start_anchor)
			anchors.append(line)
			preprint(sections[-1], anchors[-1], just_copy=not seen_start_anchor)
			sections.append([])

			if not seen_start_anchor:
				seen_start_anchor = True

		elif line.startswith('events:'):
			# Only try to translate logbook-data. This ends logbook-data section.
			anchors.append(line)
			preprint(sections[-1], anchors[-1], just_copy=not seen_start_anchor)
			sections.append([])

			# Thus, abort and only copy from here on
			copy_again = True

		else:
			sections[-1].append(line)


def main():
	(path_prefix, scenario, scenario_path, language, language_path, yaml_output, msgfmt_output) = setup_paths()
	# This writes .mo files in the *scenario* domain, so setup_gettext needs
	# to come afterwards!
	tl_status = compile_scenario_po(msgfmt_output)
	setup_gettext(scenario, language)

	metadata = {
		'translation_status': tl_status.rstrip(),
		'locale': language,
		'original': scenario_path[len(path_prefix):],
	}

	generator = os.path.join('development', os.path.basename(__file__))

	with open(yaml_output, 'w') as out:
		with open(scenario_path, 'r') as f:
			english_scenario = f.readlines()
		write_translated_yaml(english_scenario, out, metadata, generator)


if __name__ == '__main__':
	if len(sys.argv) != 2:
		print 'Usage: {0} scenario_translation_file'.format(os.path.basename(__file__))
		print '\tscenario_translation_file: `po/scenarios/sv/tutorial.po`'
		print 'Run from main UH directory!'
		sys.exit(1)
	else:
		main()

########NEW FILE########
__FILENAME__ = update_translations
#!/usr/bin/env python2
# Encoding: utf-8
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import re
import subprocess
import sys
from collections import defaultdict
from glob import glob

from horizons.constants import LANGUAGENAMES


LANG_RE = re.compile(r'.*/(.*).po')
SCENARIO_LANG_RE = re.compile(r'.*/(.*)/[^/]*.po')

INTERFACE_TRANSLATIONS = glob('po/uh/*.po')
INTERFACE_TEMPLATE = 'po/uh/unknown-horizons.pot'

MP_SERVER_TRANSLATIONS = glob('po/uh-server/*.po')
MP_SERVER_TEMPLATE = 'po/uh-server/unknown-horizons-server.pot'

GLOSSARY_TRANSLATIONS = glob('po/terminology/*.po')
GLOSSARY_TEMPLATE = 'po/terminology/pootle-terminology.pot'

SCENARIO_TRANSLATIONS = {}
SCENARIO_TEMPLATE = {}
ALL_SCENARIOS = ('tutorial', 'The_Unknown')
for s in ALL_SCENARIOS:
	SCENARIO_TRANSLATIONS[s] = glob('po/scenarios/*/%s.po' % s)
	SCENARIO_TEMPLATE[s] = 'po/scenarios/templates/%s.pot' % s

VOICES_TRANSLATIONS = glob('po/voices/*.po')
VOICES_TEMPLATE = 'po/voices/unknown-horizons-voices.pot'

JUST_NAME = re.compile(r'^\s*[0-9]*\s(\S.*)$')
GLOBAL_AUTHORS = ('Translators', 'Chris Oelmueller', 'Michal Čihař', 'Michal Čihař Čihař')
language_authors = defaultdict(set)


def update_from_template(input_po, input_template):
	"""
	@param input_po: the translation to be updated against new template
	@param input_template: the reference .pot template catalog
	"""
	print('Updating %s:' % input_po)
	try:
		subprocess.call([
			'msgmerge',
			'--previous',
			'--update',
			input_po,
			input_template,
		], stderr=subprocess.STDOUT)
	except subprocess.CalledProcessError:
		#TODO handle
		print('Error while updating translation `%s`. Exiting.' % input_po)
		sys.exit(1)


def update_authors_per_file(input_po, regexp=LANG_RE, since='weblate-credits..', pushed_by='Weblate'):
	authors = subprocess.check_output([
		'git',
		'shortlog',
		since,
		'--committer',
		pushed_by,
		'-sn', # Use 'sne' to include email (if that is ever needed)
		'--',
		input_po,
	], stderr=subprocess.STDOUT)

	#TODO Clearly the above can never fail, ever. But what if it did?
	lang = regexp.search(input_po).groups()[0]
	for author_line in authors.split('\n'):
		if not author_line:
			continue
		author = JUST_NAME.search(author_line).groups()[0]
		if author in GLOBAL_AUTHORS:
			continue
		english_lang = LANGUAGENAMES.get_english(lang)
		language_authors[english_lang].add(author)


def main():
	# Main interface translation (old 'uh' project in pootle)
	for f in INTERFACE_TRANSLATIONS:
		#update_from_template(f, INTERFACE_TEMPLATE)
		update_authors_per_file(f)

	# MP server message translation (old 'mp-server' project in pootle)
	for f in MP_SERVER_TRANSLATIONS:
		update_from_template(f, MP_SERVER_TEMPLATE)
		update_authors_per_file(f)

	# Glossary translation (old 'terminology' project in pootle)
	#for f in GLOSSARY_TRANSLATIONS:
	#	update_from_template(f, GLOSSARY_TEMPLATE)
	#	update_authors_per_file(f)

	# Scenario translation (old 'scenarios' project in pootle)
	for scenario, translations in SCENARIO_TRANSLATIONS.items():
		for f in translations:
			update_from_template(f, SCENARIO_TEMPLATE[scenario])
			update_authors_per_file(f, regexp=SCENARIO_LANG_RE)

	# Voices translation
	for f in VOICES_TRANSLATIONS:
		update_from_template(f, VOICES_TEMPLATE)
		update_authors_per_file(f)

	# Output data ready for AUTHORS.md copy/paste
	print '-- New translation contributors since last update:'
	sort_order = lambda (lang, _): LANGUAGENAMES.get_by_value(lang, english=True)
	for language, authors in sorted(language_authors.items(), key=sort_order):
		print '\n####', language
		#TODO
		# The sorted() below will not correctly sort names containing non-ascii.
		# You'll need to rely on manual copy/paste and ordering anyways, so just
		# keep your eyes open a bit more than usual.
		for author in sorted(authors):
			print_ready = map(str.capitalize, author.split())
			print '*', ' '.join(print_ready)


if __name__ == '__main__':
	main()

########NEW FILE########
__FILENAME__ = areabuilder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import copy
import logging
from collections import deque

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.roadplanner import RoadPlanner
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE, BUILD_RESULT
from horizons.constants import BUILDINGS
from horizons.util.python import decorators
from horizons.util.shapes import Rect
from horizons.util.worldobject import WorldObject
from horizons.entities import Entities

class AreaBuilder(WorldObject):
	"""A class governing the use of a specific type of area of a settlement."""

	log = logging.getLogger("ai.aiplayer.area_builder")

	def __init__(self, settlement_manager):
		super(AreaBuilder, self).__init__()
		self.__init(settlement_manager)

	def __init(self, settlement_manager):
		self.settlement_manager = settlement_manager
		self.land_manager = settlement_manager.land_manager
		self.island = self.land_manager.island
		self.session = self.island.session
		self.owner = self.land_manager.owner
		self.settlement = self.land_manager.settlement
		self.plan = {} # {(x, y): (purpose, subclass specific data), ...}

	@classmethod
	def load(cls, db, settlement_manager):
		self = cls.__new__(cls)
		self._load(db, settlement_manager)
		return self

	def _load(self, db, settlement_manager, worldid):
		self.__init(settlement_manager)
		super(AreaBuilder, self).load(db, worldid)

	def iter_neighbor_tiles(self, rect):
		"""Iterate over the tiles that share a side with the given Rect."""
		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		for x, y in rect.tuple_iter():
			for dx, dy in moves:
				coords = (x + dx, y + dy)
				if not rect.contains_tuple(coords):
					yield self.island.get_tile_tuple(coords)

	def iter_possible_road_coords(self, rect, blocked_rect):
		"""Iterate over the possible road tiles that share a side with the given Rect and are not in the blocked Rect."""
		blocked_coords_set = set(coords for coords in blocked_rect.tuple_iter())
		for tile in self.iter_neighbor_tiles(rect):
			if tile is None:
				continue
			coords = (tile.x, tile.y)
			if coords in blocked_coords_set or coords in self.land_manager.coastline or coords not in self.settlement.ground_map:
				continue
			if coords in self.land_manager.roads or (coords in self.plan and self.plan[coords][0] == BUILDING_PURPOSE.NONE):
				yield coords

	@classmethod
	def __fill_distance(cls, distance, nodes):
		"""
		Fill the distance dict with the shortest distance from the starting nodes.

		@param distance: {(x, y): distance, ...}
		@param nodes: {(x, y): penalty, ...}
		"""

		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		queue = deque([item for item in distance.iteritems()])

		while queue:
			(coords, dist) = queue.popleft()
			for dx, dy in moves:
				coords2 = (coords[0] + dx, coords[1] + dy)
				if coords2 in nodes and coords2 not in distance:
					distance[coords2] = dist + 1
					queue.append((coords2, dist + 1))

	def get_path_nodes(self):
		"""Return a dict {(x, y): penalty, ...} of current and possible future road tiles in the settlement."""
		moves = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]

		nodes = {} # {(x, y): penalty, ...}
		distance_to_road = {}
		distance_to_boundary = {}
		for coords in self.plan:
			if coords not in self.settlement.ground_map or coords in self.land_manager.coastline:
				continue
			if self.plan[coords][0] == BUILDING_PURPOSE.NONE:
				nodes[coords] = 1
			elif self.plan[coords][0] == BUILDING_PURPOSE.ROAD:
				nodes[coords] = 1
				distance_to_road[coords] = 0

			for (dx, dy) in moves:
				coords2 = (coords[0] + dx, coords[1] + dy)
				if coords2 not in self.land_manager.production:
					distance_to_boundary[coords] = 1
					break

		for coords in self.land_manager.village:
			if coords in self.land_manager.roads and coords in self.settlement.ground_map:
				nodes[coords] = 1
				distance_to_road[coords] = 0
				for (dx, dy) in moves:
					coords2 = (coords[0] + dx, coords[1] + dy)
					if coords2 not in self.land_manager.production:
						distance_to_boundary[coords] = 1
						break

		self.__fill_distance(distance_to_road, self.island.path_nodes.nodes)
		self.__fill_distance(distance_to_boundary, self.island.path_nodes.nodes)

		for coords in nodes:
			if coords in distance_to_road:
				distance = distance_to_road[coords]
				if distance > self.personality.path_road_penalty_threshold:
					nodes[coords] += self.personality.path_distant_road_penalty
				elif distance > 0:
					nodes[coords] += self.personality.path_near_road_constant_penalty + \
						(self.personality.path_road_penalty_threshold - distance + 1) * self.personality.path_near_road_linear_penalty
			else:
				nodes[coords] += self.personality.path_unreachable_road_penalty

			if coords in distance_to_boundary:
				distance = distance_to_boundary[coords]
				if 1 < distance <= self.personality.path_boundary_penalty_threshold:
					nodes[coords] += self.personality.path_near_boundary_constant_penalty + \
						(self.personality.path_boundary_penalty_threshold - distance + 1) * self.personality.path_near_boundary_linear_penalty
			else:
				nodes[coords] += self.personality.path_unreachable_boundary_penalty

		return nodes

	def _get_road_to_builder(self, builder):
		"""Return a path from the builder to a building with general collectors (None if impossible)."""
		loading_area = builder.get_loading_area()
		collector_coords = set()
		for building in self.collector_buildings:
			if loading_area.distance(building.position) == 1:
				return []
			if loading_area.distance(building.position) > building.radius:
				continue # the collector building is too far to be useful
			for coords in self.iter_possible_road_coords(building.position, building.position):
				collector_coords.add(coords)

		destination_coords = set(self.iter_possible_road_coords(loading_area, builder.position))
		if self is self.settlement_manager.production_builder:
			if not self.settlement_manager.production_builder.road_connectivity_cache.is_connection_possible(collector_coords, destination_coords):
				return None

		blocked_coords = set([coords for coords in builder.position.tuple_iter()]).union(self.land_manager.coastline)
		beacon = Rect.init_from_borders(loading_area.left - 1, loading_area.top - 1,
		                                loading_area.right + 1, loading_area.bottom + 1)

		return RoadPlanner()(self.owner.personality_manager.get('RoadPlanner'), collector_coords,
			destination_coords, beacon, self.get_path_nodes(), blocked_coords=blocked_coords)

	def build_road(self, path):
		"""Build the road given a valid path or None. Return True if it worked, False if the path was None."""
		if path is not None:
			for x, y in path:
				self.register_change_list([(x, y)], BUILDING_PURPOSE.ROAD, None)
				building = self.island.ground_map[(x, y)].object
				if building is not None and building.id == BUILDINGS.TRAIL:
					continue
				assert BasicBuilder(BUILDINGS.TRAIL, (x, y), 0).execute(self.land_manager)
		return path is not None

	def build_road_connection(self, builder):
		"""Build a road connecting the builder to a building with general collectors. Return True if it worked, False if the path was None."""
		path = self._get_road_to_builder(builder)
		return self.build_road(path)

	def get_road_cost(self, path):
		"""Return the cost of building a road on the given path as {resource_id: amount, ...} or None if impossible."""
		if path is None:
			return None
		length = 0
		if path is not None:
			for x, y in path:
				building = self.island.ground_map[(x, y)].object
				if building is None or building.id != BUILDINGS.TRAIL:
					length += 1
		if length == 0:
			return {}
		costs = copy.copy(Entities.buildings[BUILDINGS.TRAIL].costs)
		for resource in costs:
			costs[resource] *= length
		return costs

	def get_road_connection_cost(self, builder):
		"""
		Return the cost of building a road from the builder to a building with general collectors.

		The returned format is {resource_id: amount, ...} if it is possible to build a road and None otherwise.
		"""
		return self.get_road_cost(self._get_road_to_builder(builder))

	def have_resources(self, building_id):
		"""Return a boolean showing whether we currently have the resources to build a building of the given type."""
		return Entities.buildings[building_id].have_resources([self.settlement], self.owner)

	def build_best_option(self, options, purpose):
		"""
		Try to build the highest valued option. Return a BUILD_RESULT constant showing how it went.

		@param options: [(value, builder), ...]
		@param purpose: a BUILDING_PURPOSE constant
		"""

		if not options:
			return BUILD_RESULT.IMPOSSIBLE

		best_index = 0
		best_value = options[0][0]
		for i in xrange(1, len(options)):
			if options[i][0] > best_value:
				best_index = i
				best_value = options[i][0]

		builder = options[best_index][1]
		if not builder.execute(self.land_manager):
			return BUILD_RESULT.UNKNOWN_ERROR
		self.register_change_list(list(builder.position.tuple_iter()), BUILDING_PURPOSE.RESERVED, None)
		self.register_change_list([builder.position.origin.to_tuple()], purpose, None)
		return BUILD_RESULT.OK

	def extend_settlement(self, position):
		"""Build a storage to extend the settlement towards the given position. Return a BUILD_RESULT constant."""
		return self.settlement_manager.production_builder.extend_settlement_with_storage(position)

	def handle_lost_area(self, coords_list):
		"""Handle losing the potential land in the given coordinates list."""
		# remove the affected tiles from the plan
		for coords in coords_list:
			if coords in self.plan:
				del self.plan[coords]

	def add_building(self, building):
		"""Called when a new building is added in the area (the building already exists during the call)."""
		self.display()

	def remove_building(self, building):
		"""Called when a building is removed from the area (the building still exists during the call)."""
		self.display()

	def display(self):
		"""Show the plan on the map unless it is disabled in the settings."""
		raise NotImplementedError('This function has to be overridden.')

	def _init_cache(self):
		"""Initialize the cache that knows the last time the buildability of a rectangle may have changed in this area."""
		self.last_change_id = -1

	def register_change(self, x, y, purpose, data):
		"""Register the (potential) change of the purpose of land at the given coordinates."""
		if (x, y) in self.plan:
			self.plan[(x, y)] = (purpose, data)
			if purpose == BUILDING_PURPOSE.ROAD:
				self.land_manager.roads.add((x, y))

	def register_change_list(self, coords_list, purpose, data):
		for (x, y) in coords_list:
			self.register_change(x, y, purpose, data)

decorators.bind_all(AreaBuilder)

########NEW FILE########
__FILENAME__ = basicbuilder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import copy

from horizons.entities import Entities
from horizons.constants import BUILDINGS
from horizons.command.building import Build
from horizons.util.python import decorators
from horizons.util.shapes import Point, Rect
from horizons.world.building.production import Mine

class BasicBuilder(object):
	"""An object of this class represents a non-checked plan to build a building at a specific place."""

	rotations = [45, 135, 225, 315]
	# don't change the orientation of the following building types
	non_rotatable_buildings = [BUILDINGS.WAREHOUSE, BUILDINGS.FISHER, BUILDINGS.BOAT_BUILDER,
		BUILDINGS.MINE, BUILDINGS.SALT_PONDS]

	__slots__ = ('building_id', 'coords', 'orientation', 'position')

	def __init__(self, building_id, coords, orientation):
		self.building_id = building_id
		self.coords = coords
		self.orientation = orientation

		size = Entities.buildings[building_id].size
		if orientation % 2 != 0:
			size = (size[1], size[0])
		self.position = Rect.init_from_topleft_and_size_tuples(coords, size)

	def _get_rotation(self, session, build_position_rotation):
		"""Return the rotation of the new building (randomize it if allowed)."""
		if self.building_id in self.non_rotatable_buildings:
			return build_position_rotation
		if Entities.buildings[self.building_id].size[0] == Entities.buildings[self.building_id].size[1]:
			# any orientation could be chosen
			return self.rotations[session.random.randint(0, 3)]
		else:
			# there are two possible orientations
			assert 0 <= self.orientation <= 1
			return self.rotations[self.orientation + 2 * session.random.randint(0, 1)]

	def get_loading_area(self):
		"""Return the position of the loading area."""
		if self.building_id == BUILDINGS.MINE:
			return Mine.get_loading_area(self.building_id, self.rotations[self.orientation], self.position)
		else:
			return self.position

	def execute(self, land_manager, ship=None):
		"""Build the building."""
		building_class = Entities.buildings[self.building_id]
		building_level = building_class.get_initial_level(land_manager.owner)
		action_set_id = building_class.get_random_action_set(level = building_level)

		build_position = Entities.buildings[self.building_id].check_build(land_manager.session,
		    Point(*self.coords), rotation=self.rotations[self.orientation],
		    check_settlement=(ship is None), ship=ship, issuer=land_manager.owner)
		assert build_position.buildable

		cmd = Build(self.building_id, self.coords[0], self.coords[1], land_manager.island,
			self._get_rotation(land_manager.session, build_position.rotation),
			settlement=land_manager.settlement, ship=ship, tearset=build_position.tearset,
			action_set_id=action_set_id)
		result = cmd(land_manager.owner)
		assert result
		return result

	def have_resources(self, land_manager, ship=None, extra_resources=None):
		"""Return a boolean showing whether we have the resources to build the building right now."""
		# the copy has to be made because Build.check_resources modifies it
		extra_resources = copy.copy(extra_resources) if extra_resources is not None else {}
		inventories = [land_manager.settlement, ship]
		return Build.check_resources(extra_resources, Entities.buildings[self.building_id].costs, land_manager.owner, inventories)[0]

	def __cmp__(self, other):
		"""Objects of this class should never be compared to ensure deterministic ordering and good performance."""
		raise NotImplementedError()

	def __str__(self):
		return 'BasicBuilder of building %d at %s, orientation %d' % (self.building_id, self.coords, self.orientation)

	__cache = {}

	@classmethod
	def clear_cache(cls):
		cls.__cache.clear()

	@classmethod
	def create(cls, building_id, coords, orientation):
		"""
		Create or get a cached version of the BasicBuilder.

		This is supposed to speed up the process in case identical BasicBuilder instances
		would be created. The constructor should be used directly otherwise.
		"""

		key = (building_id, coords, orientation)
		if key not in cls.__cache:
			cls.__cache[key] = BasicBuilder(building_id, coords, orientation)
		return cls.__cache[key]

decorators.bind_all(BasicBuilder)

########NEW FILE########
__FILENAME__ = behaviorcomponents
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
from collections import defaultdict

from horizons.ai.aiplayer.behavior.diplomacysettings import DiplomacySettings
from horizons.ai.aiplayer.behavior.movecallbacks import BehaviorMoveCallback
from horizons.ai.aiplayer.combat.combatmanager import CombatManager
from horizons.ai.aiplayer.strategy.mission.chaseshipsandattack import ChaseShipsAndAttack
from horizons.ai.aiplayer.strategy.mission.pirateroutine import PirateRoutine
from horizons.ai.aiplayer.strategy.mission.surpriseattack import SurpriseAttack
from horizons.ai.aiplayer.combat.unitmanager import UnitManager

from horizons.command.diplomacy import AddEnemyPair
from horizons.component.namedcomponent import NamedComponent
from horizons.constants import BUILDINGS
from horizons.ext.enum import Enum
from horizons.util.python.callback import Callback
from horizons.util.shapes import Circle
from horizons.world.units.movingobject import MoveNotPossible


class BehaviorComponent(object):
	"""
	This is an abstract BehaviorComponent - a building block for AI Behavior.
	"""
	log = logging.getLogger('ai.aiplayer.behavior.behaviorcomponents')
	default_certainty = 1.0
	minimal_fleet_size = 1

	def __init__(self, owner):
		self.owner = owner
		self.combat_manager = owner.combat_manager
		self.unit_manager = owner.unit_manager
		self.world = owner.world
		self.session = owner.session

		# Witchery below is a way to have certainty() always return the same certainty if it's not defined per behavior.
		self._certainty = defaultdict(lambda: (lambda **env: self.default_certainty))

	def certainty(self, action_name, **environment):
		certainty = self._certainty[action_name](**environment)
		assert certainty is not None, "Certainty function returned None instead of a float. Certainty in %s for %s" % (self.__class__.__name__, action_name)
		return certainty

	# common certainties used by various behaviors
	def _certainty_has_boat_builder(self, **environment):
		if self.owner.count_buildings(BUILDINGS.BOAT_BUILDER):
			return self.default_certainty
		else:
			return 0.0

	def _certainty_has_fleet(self, **environment):
		idle_ships = environment['idle_ships']
		if idle_ships:
			return self.default_certainty
		else:
			return 0.0

# Components below are roughly divided into "Aggressive, Normal, Cautious" etc.
# (division below is not related to the way dictionaries in BehaviorManager are named (offensive, idle, defensive))


class BehaviorDoNothing(BehaviorComponent):
	"""
	Behavior that does nothing. Used mainly for idle actions (we don't want to scout too often).
	"""

	def __init__(self, owner):
		super(BehaviorDoNothing, self).__init__(owner)

	def no_one_in_sight(self, **environment):
		pass


class BehaviorPirateRoutine(BehaviorComponent):
	"""
	Idle behavior for Pirate player. It has to be specialized for Pirate since general AI does not have home_point.
	Responsible for pirate ships routine when no one is around. States change in a loop:
	idle -> moving_random -> going_home -> idle
	"""

	sail_home_chance = 0.3  # sail_home_chance to sail home, 1-sail_home_chance to sail randomly
	pirate_caught_ship_radius = 5
	pirate_home_radius = 2

	def __init__(self, owner):
		super(BehaviorPirateRoutine, self).__init__(owner)

	def no_one_in_sight(self, **environment):
		"""
		Idle action, sail randomly when no ship was spotted nearby.
		"""
		ship_group = environment['ship_group']
		for ship in ship_group:
			rand_val = self.session.random.random()
			if self.owner.ships[ship] == self.owner.shipStates.idle:
				if rand_val < self.sail_home_chance:
					self._sail_home(ship)
				else:
					self._sail_random(ship)

			self.log.debug('BehaviorPirateRoutine: Ship:%s no_one_in_sight' % ship.get_component(NamedComponent).name)

	def trading_ships_in_sight(self, **environment):
		ship_group = environment['ship_group']
		for ship in ship_group:
			self._chase_closest_ship(ship)
			self.log.debug('BehaviorPirateRoutine: Ship:%s trading_ships_in_sight' % ship.get_component(NamedComponent).name)

	def _arrived(self, ship):
		"""
		Callback function executed once ship arrives at the destination after certain action.
		Practically only changes ship state to idle.
		"""
		owner = ship.owner
		self.log.debug('Player %s: Ship %s: arrived at destination after "%s"' % (owner.name,
			ship.get_component(NamedComponent).name, owner.ships[ship]))
		owner.ships[ship] = owner.shipStates.idle

	def _chase_closest_ship(self, pirate_ship):
		owner = pirate_ship.owner
		ship = owner.get_nearest_player_ship(pirate_ship)
		if ship:
			owner.ships[pirate_ship] = owner.shipStates.chasing_ship

			# if ship was caught
			if ship.position.distance(pirate_ship.position) <= self.pirate_caught_ship_radius:
				self.log.debug('Pirate %s: Ship %s(%s) caught %s' % (owner.worldid,
					pirate_ship.get_component(NamedComponent).name, owner.ships[pirate_ship], ship))
				self._sail_home(pirate_ship)
			else:
				try:
					pirate_ship.move(Circle(ship.position, self.pirate_caught_ship_radius - 1), Callback(self._sail_home, pirate_ship))
					owner.ships[pirate_ship] = owner.shipStates.chasing_ship
					self.log.debug('Pirate %s: Ship %s(%s) chasing %s' % (owner.worldid,
						pirate_ship.get_component(NamedComponent).name, owner.ships[pirate_ship], ship.get_component(NamedComponent).name))
				except MoveNotPossible:
					self.log.debug('Pirate %s: Ship %s(%s) unable to chase the closest ship %s' % (owner.worldid,
						pirate_ship.get_component(NamedComponent).name, owner.ships[pirate_ship], ship.get_component(NamedComponent).name))
					owner.ships[pirate_ship] = owner.shipStates.idle

	def _sail_home(self, pirate_ship):
		owner = pirate_ship.owner
		try:
			pirate_ship.move(Circle(owner.home_point, self.pirate_home_radius), Callback(self._arrived, pirate_ship))
			owner.ships[pirate_ship] = owner.shipStates.going_home
			self.log.debug('Pirate %s: Ship %s(%s): sailing home at %s' % (owner.worldid, pirate_ship.get_component(NamedComponent).name,
				owner.ships[pirate_ship], owner.home_point))
		except MoveNotPossible:
			owner.ships[pirate_ship] = owner.shipStates.idle
			self.log.debug('Pirate %s: Ship %s: unable to move home at %s' % (owner.worldid, pirate_ship.get_component(NamedComponent).name, owner.home_point))

	def _sail_random(self, pirate_ship):

		owner = pirate_ship.owner
		session = owner.session
		point = session.world.get_random_possible_ship_position()
		try:
			pirate_ship.move(point, Callback(self._arrived, pirate_ship))
			owner.ships[pirate_ship] = owner.shipStates.moving_random
			self.log.debug('Pirate %s: Ship %s(%s): moving random at %s' % (owner.worldid, pirate_ship.get_component(NamedComponent).name,
				owner.ships[pirate_ship], point))
		except MoveNotPossible:
			owner.ships[pirate_ship] = owner.shipStates.idle
			self.log.debug('Pirate %s: Ship %s: unable to move random at %s' % (owner.worldid, pirate_ship.get_component(NamedComponent).name, point))


# Common certainty functions for offensive actions
def certainty_power_balance_exp(**environment):
	"""
	Return power_balance^2, altering the exponent will impact the weight certainty has.
	"""
	return BehaviorComponent.default_certainty * (environment['power_balance'] ** 2)


def certainty_power_balance_inverse(**environment):
	"""
	Return power_balance reciprocal,
	"""

	return BehaviorComponent.default_certainty * (1. / environment['power_balance'])


class BehaviorRegular(BehaviorComponent):
	"""
	A well-balanced way to respond to situations in game.
	"""
	power_balance_threshold = 1.0

	def __init__(self, owner):
		super(BehaviorRegular, self).__init__(owner)
		self._certainty['pirate_ships_in_sight'] = certainty_power_balance_exp
		self._certainty['fighting_ships_in_sight'] = certainty_power_balance_exp
		self._certainty['player_shares_island'] = self._certainty_player_shares_island
		self._certainty['hostile_player'] = self._certainty_hostile_player
		self._certainty['debug'] = self._certainty_ship_amount

	def pirate_ships_in_sight(self, **environment):
		"""
		Attacks pirates only if they are enemies already and the power balance is advantageous.
		"""
		pirates = environment['enemies']
		ship_group = environment['ship_group']
		power_balance = environment['power_balance']

		# It's enough to check if first pirate is hostile, since there is only one pirate player.
		if self.session.world.diplomacy.are_enemies(self.owner, pirates[0].owner):
			# Let each ship attack it's closest enemy to maximize dps (in a way)
			ship_pairs = UnitManager.get_closest_ships_for_each(ship_group, pirates)
			for ship, pirate in ship_pairs:
				ship.attack(pirates[0])
			BehaviorComponent.log.info('%s: Attacked pirate ship', self.__class__.__name__)
		else:
			BehaviorComponent.log.info('%s: Pirate ship was not hostile', self.__class__.__name__)

	def fighting_ships_in_sight(self, **environment):
		"""
		Attacks frigates only if they are enemies already and the power balance is advantageous.
		"""
		enemies = environment['enemies']
		ship_group = environment['ship_group']
		power_balance = environment['power_balance']

		if power_balance > self.power_balance_threshold:
			BehaviorComponent.log.info('%s: Enemy group is too strong', self.__class__.__name__)
			return

		if self.session.world.diplomacy.are_enemies(self.owner, enemies[0].owner):
			ship_pairs = UnitManager.get_closest_ships_for_each(ship_group, enemies)
			for ship, enemy_ship in ship_pairs:
				ship.attack(enemy_ship)

			BehaviorComponent.log.info('%s: Attacked enemy ship', self.__class__.__name__)
		else:
			BehaviorComponent.log.info('%s: Enemy ship was not hostile', self.__class__.__name__)

	def working_ships_in_sight(self, **environment):
		"""
		Attacks working ships only if they are hostile.
		"""
		enemies = environment['enemies']
		ship_group = environment['ship_group']

		if self.session.world.diplomacy.are_enemies(self.owner, enemies[0].owner):
			for ship in ship_group:
				ship.attack(enemies[0])
			BehaviorComponent.log.info('%s: Attacked enemy ship', self.__class__.__name__)
		else:
			BehaviorComponent.log.info('%s: Enemy worker was not hostile', self.__class__.__name__)

	def _certainty_player_shares_island(self, **environment):
		"""
		Dummy certainty that checks for a fleets size only.
		"""
		idle_ships = environment['idle_ships']

		if len(idle_ships) < self.minimal_fleet_size:
			return 0.0

		return self.default_certainty

	def _certainty_ship_amount(self, **environment):
		idle_ships = environment['idle_ships']

		if len(idle_ships) < self.minimal_fleet_size:
			return 0.0
		else:
			return self.default_certainty

	def _certainty_hostile_player(self, **environment):
		enemy_player = environment['player']
		idle_ships = environment['idle_ships']

		enemy_ships = self.unit_manager.get_player_ships(enemy_player)

		if not enemy_ships or len(idle_ships) < self.minimal_fleet_size:
			return 0.0

		return self.default_certainty

	def player_shares_island(self, **environment):
		"""
		Response to player that shares an island with AI player.
		Regular AI should simply attack given player.
		"""
		enemy_player = environment['player']
		idle_ships = environment['idle_ships']

		if not enemy_player.settlements:
			return None

		target_point = self.unit_manager.get_warehouse_area(enemy_player.settlements[0], 13)

		return_point = idle_ships[0].position.copy()
		mission = SurpriseAttack.create(self.owner.strategy_manager.report_success,
			self.owner.strategy_manager.report_failure, idle_ships, target_point, return_point, enemy_player)
		return mission

	def hostile_player(self, **environment):
		"""
		Arrage an attack for hostile ships.
		"""
		enemy_player = environment['player']
		idle_ships = environment['idle_ships']
		enemy_ships = self.unit_manager.get_player_ships(enemy_player)

		# TODO: pick target ship better
		target_ship = enemy_ships[0]
		mission = ChaseShipsAndAttack.create(self.owner.strategy_manager.report_success,
			self.owner.strategy_manager.report_failure, idle_ships, target_ship)

		return mission

	def neutral_player(self, **environment):
		"""
		Not concerned about neutral players.
		"""
		return None


class BehaviorAggressive(BehaviorComponent):

	power_balance_threshold = 0.8 # allow to attack targets that are slightly stronger

	def __init__(self, owner):
		super(BehaviorAggressive, self).__init__(owner)
		self._certainty['neutral_player'] = self._certainty_neutral_player
		self._certainty['fighting_ships_in_sight'] = self._certainty_fighting_ships_in_sight

	def _certainty_fighting_ships_in_sight(self, **environment):
		return self.default_certainty

	def fighting_ships_in_sight(self, **environment):
		"""
		Attacks frigates only if they are enemies already and the power balance is advantageous.
		"""
		enemies = environment['enemies']
		ship_group = environment['ship_group']
		power_balance = environment['power_balance']

		if power_balance < self.power_balance_threshold:
			BehaviorComponent.log.info('%s: Enemy group is too strong', self.__class__.__name__)
			return

		# attack ship with the lowest HP
		target_ship = UnitManager.get_lowest_hp_ship(enemies)

		if self.session.world.diplomacy.are_enemies(self.owner, target_ship.owner):
			for ship in ship_group:
				ship.attack(target_ship)
			BehaviorComponent.log.info('%s: Attacked enemy ship', self.__class__.__name__)
		else:
			BehaviorComponent.log.info('%s: Enemy ship was not hostile', self.__class__.__name__)

	def _certainty_neutral_player(self, **environment):
		idle_ships = environment['idle_ships']

		if len(idle_ships) >= self.minimal_fleet_size:
			return self.default_certainty
		elif self.owner.count_buildings(BUILDINGS.BOAT_BUILDER):
			return self.default_certainty
		else:
			return 0.0

	def neutral_player(self, **environment):
		"""
		Start war with neutral player
		-make a SurpriseAttack if possible.
		-break diplomacy otherwise.
		"""
		idle_ships = environment['idle_ships']
		enemy_player = environment['player']

		# Nothing to do when AI or enemy don't have a settlement yet
		if not enemy_player.settlements or not self.owner.settlements:
			return None

		# Send a surprise attack if there are ships available, otherwise simply declare war
		if idle_ships:
			target_point = self.unit_manager.get_warehouse_area(enemy_player.settlements[0])
			return_point = self.unit_manager.get_warehouse_area(self.owner.settlements[0], 15)
			mission = SurpriseAttack.create(self.owner.strategy_manager.report_success,
				self.owner.strategy_manager.report_failure, idle_ships, target_point, return_point, enemy_player)
			return mission
		else:
			AddEnemyPair(self.owner, enemy_player).execute(self.session)


class BehaviorCautious(BehaviorComponent):

	def __init__(self, owner):
		super(BehaviorCautious, self).__init__(owner)

	def neutral_player(self, **environment):
		"""
		Not concerned about neutral players.
		"""
		return None


class BehaviorSmart(BehaviorComponent):

	def fighting_ships_in_sight(self, **environment):
		"""
		Attacks frigates, and keeps distance based on power balance.
		"""
		enemies = environment['enemies']
		ship_group = environment['ship_group']
		power_balance = environment['power_balance']

		if power_balance >= 1.0:
			range_function = CombatManager.close_range
		else:
			range_function = CombatManager.fallback_range

		ship_pairs = UnitManager.get_closest_ships_for_each(ship_group, enemies)
		for ship, enemy_ship in ship_pairs:
			if self.session.world.diplomacy.are_enemies(ship.owner, enemy_ship.owner):
				BehaviorMoveCallback.maintain_distance_and_attack(ship, enemy_ship, range_function(ship))
				BehaviorComponent.log.info('%s: Attack: %s -> %s', self.__class__.__name__,
					ship.get_component(NamedComponent).name, enemy_ship.get_component(NamedComponent).name)
			else:
				BehaviorComponent.log.info('%s: Enemy ship %s was not hostile', self.__class__.__name__,
					ship.get_component(NamedComponent).name)

	def working_ships_in_sight(self, **environment):
		"""
		Attacks working ships only if they are hostile.
		"""
		enemies = environment['enemies']
		ship_group = environment['ship_group']

		if self.session.world.diplomacy.are_enemies(self.owner, enemies[0].owner):
			# working ships won't respond with fire, each ship should attack the closest one, and chase them if necessary.
			ship_pairs = UnitManager.get_closest_ships_for_each(ship_group, enemies)
			for ship, enemy_ship in ship_pairs:
				range_function = CombatManager.close_range
				BehaviorMoveCallback.maintain_distance_and_attack(ship, enemy_ship, range_function(ship))
			BehaviorComponent.log.info('%s: Attacked enemy ship', self.__class__.__name__)
		else:
			BehaviorComponent.log.info('%s: Enemy worker was not hostile', self.__class__.__name__)


# Behaviors calculate single value against each of the players (you can think of it as of respect, or "relationship_score" values towards other player)
# Each AI values different traits in others. Based on that value AI can break diplomacy with an ally, declare a war, or
# act the other way around: form an alliance
class BehaviorDiplomatic(BehaviorComponent):
	"""
	Behaviors that handle diplomacy.
	"""

	# value to which each function is related, so even when relationship_score is at the peek somewhere (e.g. it's value is 1.0)
	# probability to actually choose given action is peek/upper_boundary (0.2 in case of upper_boundary = 5.0)
	upper_boundary = DiplomacySettings.upper_boundary

	# possible actions behavior can take
	actions = Enum('wait', 'war', 'peace', 'neutral')

	def calculate_relationship_score(self, balance, weights):
		"""
		Calculate total relationship_score based on balances and their weights.
		Count only balances that have weight defined (this way "default" weight is 0)
		"""
		return sum((getattr(balance, key) * value for key, value in weights.iteritems()))

	@classmethod
	def _move_f(cls, f, v_x, v_y):
		"""
		Return function f moved by vector (v_x, v_y)
		"""
		return lambda x: f(x - v_x) + v_y

	def handle_diplomacy(self, parameters, **environment):
		"""
		Main function responsible for handling diplomacy.
		"""
		player = environment['player']
		balance = self.owner.strategy_manager.calculate_player_balance(player)
		relationship_score = self.calculate_relationship_score(balance, self.weights)
		action = self._get_action(relationship_score, **parameters)
		self.log.debug("%s vs %s | Dipomacy: balance:%s, relationship_score:%s, action:%s", self.owner.name, player.name, balance, relationship_score, action)
		self._perform_action(action, **environment)

	def _perform_action(self, action, **environment):
		"""
		Execute action from actions Enum.
		"""
		player = environment['player']

		# ideally this shouldn't automatically change diplomacy for both players (i.e. add_pair) but do it for one side only.

		if action == self.actions.war:
			self.session.world.diplomacy.add_enemy_pair(self.owner, player)
		elif action == self.actions.peace:
			self.session.world.diplomacy.add_ally_pair(self.owner, player)
		elif action == self.actions.neutral:
			self.session.world.diplomacy.add_neutral_pair(self.owner, player)

	@classmethod
	def _get_quadratic_function(cls, mid, root, peek=1.0):
		"""
		Functions for border distributions such as enemy or ally (left or right parabola).
		@param mid: value on axis X that is to be center of the parabola
		@type mid: float
		@param root: value on axis X which is a crossing point of axis OX and the function itself
		@type root: float
		@param peek: value on axis Y which is a peek of a function
		@type peek: float
		@return: quadratic function
		@rtype: lambda(x)
		"""

		# base function is upside-down parabola, stretched in X in order to have roots at exactly 'root' value.
		# (-1. / (abs(mid - root) ** 2)) part is for stretching the parabola in X axis and flipping it upside down, we have to use
		# abs(mid - root) because it's later moved by mid
		# Note: Multiply by 1./abs(mid-root) to scale function in X (e.g. if mid is 1.0 and root is 1.5 -> make original x^2 function 2 times narrower
		base = lambda x: (-1. / (abs(mid - root) ** 2)) * (x ** 2)

		# we move the function so it looks like "distribution", i.e. move it far left (or right), and assume the peek is 1.0
		moved = cls._move_f(base, mid, 1.0)

		# in case of negative values of f(x) we want to have 0.0 instead
		# we multiply by peek here in order to scale function in Y
		final_function = lambda x: max(0.0, moved(x) * peek)

		return final_function

	@classmethod
	def get_enemy_function(cls, root, peek=1.0):
		return cls._get_quadratic_function(-10.0, root, peek)

	@classmethod
	def get_ally_function(cls, root, peek=1.0):
		return cls._get_quadratic_function(10.0, root, peek)

	@classmethod
	def get_neutral_function(cls, mid, root, peek=1.0):
		return cls._get_quadratic_function(mid, root, peek)

	def _choose_random_from_tuple(self, tuple):
		"""
		Choose random action from tuple of (name, value)
		"""
		total_probability = sum((item[1] for item in tuple))
		random_value = self.session.random.random() * total_probability
		counter = 0.0
		for item in tuple:
			if item[1] + counter >= random_value:
				return item[0]
			else:
				counter+= item[1]

	def _get_action(self, relationship_score, **parameters):
		possible_actions = []
		if 'enemy' in parameters:
			enemy_params = parameters['enemy']
			possible_actions.append((self.actions.war, self.get_enemy_function(**enemy_params)(relationship_score), ))

		if 'ally' in parameters:
			ally_params = parameters['ally']
			possible_actions.append((self.actions.peace, self.get_ally_function(**ally_params)(relationship_score), ))

		if 'neutral' in parameters:
			neutral_params = parameters['neutral']
			possible_actions.append((self.actions.neutral, self.get_neutral_function(**neutral_params)(relationship_score), ))

		max_probability = max((item[1] for item in possible_actions))
		random_value = self.session.random.random() * self.upper_boundary
		if random_value < max_probability: #do something
			return self._choose_random_from_tuple(possible_actions)
		else:
			return self.actions.wait

	def hostile_player(self, **environment):
		"""
		Calculate balance, and change diplomacy towards a player to neutral or ally.
		This has a very small chance though, since BehaviorEvil enjoys to be in a war.
		"""

		# Parameters are crucial in determining how AI should behave:
		# 'ally' and 'enemy' parameters are tuples of 1 or 2 values that set width or width and height of the parabola.
		# By default parabola peek is fixed at 1.0, but could be changed (by providing second parameter)
		# to manipulate the chance with which given actions is called
		# 'neutral' parameter is a tuple up to three values, first one determining where the center of the parabola is

		self.handle_diplomacy(self.parameters_hostile, **environment)

	def neutral_player(self, **environment):
		self.handle_diplomacy(self.parameters_neutral, **environment)

	def allied_player(self, **environment):
		self.handle_diplomacy(self.parameters_allied, **environment)


class BehaviorEvil(BehaviorDiplomatic):
	"""
	Diplomatic behavior.
	Evil AI likes players that are:
		- stronger
		- bigger (in terms of terrain)
		- wealthier
	Neutral towards:
		- poorer
	Dislikes:
		- weaker
		- smaller
	"""

	def __init__(self, owner):
		super(BehaviorEvil, self).__init__(owner)
		self._certainty['hostile_player'] = self._certainty_has_fleet
		self._certainty['neutral_player'] = self._certainty_has_boat_builder

	weights = DiplomacySettings.Evil.weights
	parameters_hostile = DiplomacySettings.Evil.parameters_hostile
	parameters_neutral = DiplomacySettings.Evil.parameters_neutral
	parameters_allied = DiplomacySettings.Evil.parameters_allied


class BehaviorGood(BehaviorDiplomatic):
	"""
	Diplomatic behavior.
	Good AI likes players that are:
		- weaker
		- smaller
	Neutral towards:
		- wealth
	Dislikes:
		-
	"""

	weights = DiplomacySettings.Good.weights
	parameters_hostile = DiplomacySettings.Good.parameters_hostile
	parameters_neutral = DiplomacySettings.Good.parameters_neutral
	parameters_allied = DiplomacySettings.Good.parameters_allied


class BehaviorNeutral(BehaviorDiplomatic):
	"""
	Diplomatic behavior.
	Neutral AI likes players that are:
		- wealthier
	Neutral towards:
		- strength
		- size (favor bigger though)
	Dislikes:
		-
	"""

	weights = DiplomacySettings.Neutral.weights
	parameters_hostile = DiplomacySettings.Neutral.parameters_hostile
	parameters_neutral = DiplomacySettings.Neutral.parameters_neutral
	parameters_allied = DiplomacySettings.Neutral.parameters_allied


class BehaviorDebug(BehaviorComponent):

	def __init__(self, owner):
		super(BehaviorDebug, self).__init__(owner)

	def debug(self, **environment):
		"""
		For debugging purposes.
		"""

		return None


class BehaviorRegularPirate(BehaviorComponent):

	power_balance_threshold = 1.0

	def __init__(self, owner):
		super(BehaviorRegularPirate, self).__init__(owner)
		self._certainty['fighting_ships_in_sight'] = certainty_power_balance_exp
		self._certainty['pirate_routine'] = self._certainty_pirate_routine

	def fighting_ships_in_sight(self, **environment):
		"""
		Attacks frigates only if they are enemies already and the power balance is advantageous.
		"""
		enemies = environment['enemies']
		ship_group = environment['ship_group']
		power_balance = environment['power_balance']

		if power_balance < self.power_balance_threshold:
			BehaviorComponent.log.info('%s: Enemy ship was too strong, did not attack', self.__class__.__name__)
			return

		if not self.session.world.diplomacy.are_enemies(self.owner, enemies[0].owner):
			BehaviorComponent.log.info('%s: Enemy ship was not hostile', self.__class__.__name__)
			return

		for ship in ship_group:
			ship.attack(enemies[0])
		BehaviorComponent.log.info('%s: Attacked enemy ship', self.__class__.__name__)

	def _certainty_pirate_routine(self, **environment):
		idle_ships = environment['idle_ships']
		if len(idle_ships) >= self.minimal_fleet_size:
			return self.default_certainty
		else:
			return 0.0

	def pirate_routine(self, **environment):
		"""
		Strategy that spawns pirate's idle-sailing routine.
		"""
		idle_ships = environment['idle_ships']

		# Use a one-ship group:
		idle_ships = idle_ships[:1]

		mission = PirateRoutine.create(self.owner.strategy_manager.report_success, self.owner.strategy_manager.report_failure, idle_ships)
		BehaviorComponent.log.info('BehaviorRegularPirate: pirate_routine request')
		return mission


class BehaviorAggressivePirate(BehaviorComponent):

	def __init__(self, owner):
		super(BehaviorAggressivePirate, self).__init__(owner)
		self._certainty['fighting_ships_in_sight'] = certainty_power_balance_exp

	def fighting_ships_in_sight(self, **environment):
		"""
		Attacks frigates only if they are enemies. Does not care about power balance.
		"""

		enemies = environment['enemies']
		ship_group = environment['ship_group']

		if not self.session.world.diplomacy.are_enemies(self.owner, enemies[0].owner):
			BehaviorComponent.log.info('%s: Enemy ship was not hostile', self.__class__.__name__)
			return

		target_ship = UnitManager.get_lowest_hp_ship(enemies)
		for ship in ship_group:
			ship.attack(target_ship)
		BehaviorComponent.log.info('%s: Attacked enemy ship', self.__class__.__name__)

class BehaviorBreakDiplomacy(BehaviorComponent):
	"""
	Temporary action for breaking diplomacy with other players.
	"""

	def __init__(self, owner):
		super(BehaviorBreakDiplomacy, self).__init__(owner)

	def fighting_ships_in_sight(self, **environment):
		enemies = environment['enemies']
		ship_group = environment['ship_group']

		if not self.session.world.diplomacy.are_enemies(self.owner, enemies[0].owner):
			AddEnemyPair(self.owner, enemies[0].owner).execute(self.session)
		BehaviorComponent.log.info('Player:%s broke diplomacy with %s' % (self.owner.name, enemies[0].owner.name))


class BehaviorCoward(BehaviorComponent):

	def __init__(self, owner):
		super(BehaviorCoward, self).__init__(owner)
		# Certainty here is a hyperbolic function from power_balance
		# (higher power_balance -> lesser chance of doing nothing)
		self._certainty['pirate_ships_in_sight'] = certainty_power_balance_inverse

	def pirate_ships_in_sight(self, **environment):
		"""
		Dummy action, do nothing really.
		"""
		BehaviorComponent.log.info('Pirates give me chills man.')


def certainty_are_enemies(**environment):
	"""
	returns 0.0 if two players are enemies already, default certainty otherwise.
	"""
	enemies = environment['enemies']
	ship_group = environment['ship_group']

	player = ship_group[0].owner
	enemy_player = enemies[0].owner

	return 0.0 if player.session.world.diplomacy.are_enemies(player, enemy_player) else BehaviorComponent.default_certainty


class BehaviorPirateHater(BehaviorComponent):

	def __init__(self, owner):
		super(BehaviorPirateHater, self).__init__(owner)
		self._certainty['pirate_ships_in_sight'] = certainty_are_enemies

	def pirate_ships_in_sight(self, **environment):
		"""
		Breaks diplomacy and attacks pirates.
		"""
		enemies = environment['enemies']
		ship_group = environment['ship_group']
		power_balance = environment['power_balance']

		if not self.session.world.diplomacy.are_enemies(self.owner, enemies[0].owner):
				AddEnemyPair(self.owner, enemies[0].owner).execute(self.session)
		BehaviorComponent.log.info('I feel urgent need to wipe out them pirates.')

########NEW FILE########
__FILENAME__ = diplomacysettings
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


class DiplomacySettings:
	upper_boundary = 5.0
	class Evil:
		# negative weights favors opposite balance, e.g. enemy is stronger => higher relationship_score
		weights = {
			'power': -0.6,
			'wealth': -0.3,
			'terrain': -0.1,
		}

		parameters_hostile = {
			'neutral': {'mid':0.0, 'root':2.0, 'peek':0.2}, # parabola with the center at 0.0, of root at 2.0 and -2.0. Peek at 0.5 (on Y axis)
			'ally': {'root':7.0, },
		}
		parameters_neutral = {
			'enemy': {'root':-2.5, },
			'ally': {'root':5.0, 'peek':0.7, },
		}
		parameters_allied = {
			'neutral': {'mid':-2.0, 'root':-0.5, 'peek':0.2, }, # parabola with the center at -2.0, of root at -0.5 (the other at -3.5). Peek at 0.2 (on Y axis)
			'enemy': {'root': -3.5, }, # smaller chance to go straight from allied to hostile
		}
	class Good:
		weights = {
			'power': 0.4,
			'terrain': 0.4,
			'wealth': 0.0,
		}

		parameters_hostile = {
			'neutral': {'mid': -2.0, 'root': -0.5, 'peek': 0.2, },
			'ally': {'root': 1.0, },
		}

		parameters_neutral = {
			'ally': {'root': 4.0, },
			'enemy': {'root': -6.7, 'peek':0.4 },
		}

		parameters_allied = {
			'neutral': {'mid': -3.0, 'root': -1.5, 'peek': 0.2, },
			'enemy': {'root': -8.0, },
		}
	class Neutral:
		weights = {
			'wealth': -0.8,
			'power': -0.1,
			'terrain': -0.1,
		}

		parameters_hostile = {
			'neutral': {'mid': 0.0, 'root': 2.0, 'peek': 0.3, },
			'ally': {'root': 4.0, },
		}

		parameters_neutral = {
			'ally': {'root': 5.0, },
			'enemy': {'root': -5.0, },
		}

		parameters_allied = {
			'neutral':{'mid': -1.0, 'root': 0.0, 'peek': 0.3, },
			'enemy': {'root': -7.0, },
		}

########NEW FILE########
__FILENAME__ = movecallbacks
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.component.namedcomponent import NamedComponent
from horizons.util.python.callback import Callback
from horizons.util.shapes import Annulus
from horizons.world.units.movingobject import MoveNotPossible

class BehaviorMoveCallback:
	"""
	Container class for general purpose ship moves and move callbacks.
	"""
	log = logging.getLogger('ai.aiplayer.combat.movecallbacks')

	@classmethod
	def _get_annulus(cls, position, range, range_delta):
		return Annulus(position, max(0, range - range_delta), range + range_delta)

	@classmethod
	def _arrived(cls, ship):
		combat_manager = ship.owner.combat_manager
		combat_manager.set_ship_state(ship, combat_manager.shipStates.idle)
		cls.log.debug("%s: _arrived: Ship %s arrived at target", cls.__name__, ship.get_component(NamedComponent).name)

	@classmethod
	def maintain_distance_and_attack(cls, ship, enemy, range, range_delta=1):
		"""
		Attacks given target if possible and adjust ship position to keep given range.
		"""
		combat_manager = ship.owner.combat_manager

		distance = ship.position.distance(enemy.position)
		cls.log.debug("maintain_distance_and_attack: Ship: %s, Enemy: %s, distance: %s, range: %s, range_delta: %s", ship.get_component(NamedComponent).name,
			enemy.get_component(NamedComponent).name, distance, range, range_delta)

		if ship.can_attack_position(enemy.position):
			ship.attack(enemy) # attack ship if close enough to fire
			cls.log.debug("%s: maintain_distance_and_attack: Attack: %s -> %s", cls.__name__,
				ship.get_component(NamedComponent).name, enemy.get_component(NamedComponent).name)

		# calculate distance between each ship and adjust distance
		if abs(distance - range) > range_delta:
			try:
				target = cls._get_annulus(enemy.position, range, range_delta)
				ship.move(target, callback=Callback(cls._arrived, ship))

				# set state to moving since we don't attack during that
				combat_manager.set_ship_state(ship, combat_manager.shipStates.moving)
				cls.log.debug("%s: maintain_distance_and_attack: Moving towards the target", cls.__name__)
			except MoveNotPossible:
				cls.log.debug("%s: maintain_distance_and_attack: Move was not possible", cls.__name__)

########NEW FILE########
__FILENAME__ = profile
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

import random
from horizons.ai.aiplayer.behavior import BehaviorManager

from horizons.ai.aiplayer.behavior.behaviorcomponents import (
	BehaviorPirateHater, BehaviorCoward, BehaviorRegular, BehaviorPirateRoutine,
	BehaviorBreakDiplomacy, BehaviorDoNothing, BehaviorRegularPirate, BehaviorAggressive,
	BehaviorAggressivePirate, BehaviorDebug, BehaviorSmart, BehaviorEvil, BehaviorNeutral,
	BehaviorGood, BehaviorCautious)
from horizons.ai.aiplayer.strategy.condition import (
	ConditionNeutral, ConditionSharingSettlement, ConditionHostile, ConditionDebug,
	ConditionPirateRoutinePossible, ConditionAllied)


class BehaviorProfile(object):
	def __init__(self):
		"""
		Init actions and strategies with required types.
		e.g. self.strategies is a dict of Enum => {}, each of such items is later filled by concrete BehaviorProfile.
		"""
		super(BehaviorProfile, self).__init__()
		self.actions = dict(((action_type, {}) for action_type in BehaviorManager.action_types))
		self.strategies = dict(((strategy_type, {}) for strategy_type in BehaviorManager.strategy_types))
		self.conditions = {}


class BehaviorProfileAggressive(BehaviorProfile):

	def __init__(self, player):
		super(BehaviorProfileAggressive, self).__init__()

		self.conditions = {
			ConditionHostile(player): 1.1,
			ConditionSharingSettlement(player): 1.0,
			ConditionNeutral(player): 0.3,
			ConditionAllied(player): 0.3,
		}

		self.actions[BehaviorManager.action_types.offensive][BehaviorRegular(player)] = 0.35
		self.actions[BehaviorManager.action_types.offensive][BehaviorAggressive(player)] = 0.65
		self.actions[BehaviorManager.action_types.idle][BehaviorDoNothing(player)] = 1.0

		self.strategies[BehaviorManager.strategy_types.offensive][BehaviorRegular(player)] = 1.0

		self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorAggressive(player)] = 0.05
		self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorEvil(player)] = 0.75
		self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorNeutral(player)] = 0.2


class BehaviorProfileBalanced(BehaviorProfile):

	def __init__(self, player):
		super(BehaviorProfileBalanced, self).__init__()

		self.conditions = {
			ConditionHostile(player): 1.1,
			ConditionSharingSettlement(player): 1.0,
			ConditionNeutral(player): 0.3,
			ConditionAllied(player): 0.29,
		}

		self.actions[BehaviorManager.action_types.offensive][BehaviorRegular(player)] = 0.8
		self.actions[BehaviorManager.action_types.offensive][BehaviorAggressive(player)] = 0.2
		self.actions[BehaviorManager.action_types.idle][BehaviorDoNothing(player)] = 1.0

		self.strategies[BehaviorManager.strategy_types.offensive][BehaviorRegular(player)] = 1.0

		self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorEvil(player)] = 0.05
		self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorNeutral(player)] = 0.9
		self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorGood(player)] = 0.05

class BehaviorProfileCautious(BehaviorProfile):

	def __init__(self, player):
		super(BehaviorProfileCautious, self).__init__()

		self.conditions = {
			ConditionHostile(player): 0.9,
			#ConditionSharingSettlement(player): 1.0,  # does not respond to enemy sharing a settlement
			ConditionNeutral(player): 0.3,
			ConditionAllied(player): 0.29,
		}

		self.actions[BehaviorManager.action_types.offensive][BehaviorRegular(player)] = 0.8
		self.actions[BehaviorManager.action_types.idle][BehaviorDoNothing(player)] = 1.0

		self.strategies[BehaviorManager.strategy_types.offensive][BehaviorRegular(player)] = 1.0
		self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorGood(player)] = 0.7
		self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorNeutral(player)] = 0.3


class BehaviorProfilePirateRegular(BehaviorProfile):

	def __init__(self, player):
		super(BehaviorProfilePirateRegular, self).__init__()

		self.conditions = {
			ConditionPirateRoutinePossible(player): 1.0,
		}

		self.actions[BehaviorManager.action_types.offensive][BehaviorRegularPirate(player)] = 0.75
		self.actions[BehaviorManager.action_types.offensive][BehaviorAggressivePirate(player)] = 0.25
		self.actions[BehaviorManager.action_types.idle][BehaviorDoNothing(player)] = 0.5

		self.strategies[BehaviorManager.strategy_types.idle][BehaviorRegularPirate(player)] = 1.0


class BehaviorProfileManager(object):
	"""
	BehaviorProfileManager is an object that defines the dictionary with BehaviorComponents for AIPlayer.
	If it proves to be useful it will handle loading AI profiles from YAML.
	"""

	log = logging.getLogger("ai.aiplayer.behavior.profilemanager")

	@classmethod
	def get_random_player_profile(cls, player, token):
		return cls._get_random_profile(player, token, get_available_player_profiles())

	@classmethod
	def get_random_pirate_profile(cls, player, token):
		return cls._get_random_profile(player, token, get_available_pirate_profiles())

	@classmethod
	def _get_random_profile(cls, player, token, profiles):
		random_generator = random.Random()
		random_generator.seed(token)

		total, random_value = 0.0, random_generator.random()

		probabilities_sum = sum([item[1] for item in profiles])

		assert probabilities_sum > 1e-7, "sum of BehaviorProfile probabilities is too low: %s" % probabilities_sum

		random_value *= probabilities_sum

		chosen_profile = None
		for profile, probability in profiles:
			if (total + probability) >= random_value:
				chosen_profile = profile
				break
			total += probability

		cls.log.debug("BehaviorProfileManager: Player %s was given %s", player.name, chosen_profile.__name__)
		return chosen_profile(player)


class BehaviorProfileDebug(BehaviorProfile):

	def __init__(self, player):
		super(BehaviorProfileDebug, self).__init__()

		self.conditions = {
			#ConditionHostile(player): 1.1,
			#ConditionSharingSettlement(player): 1.0,
			ConditionNeutral(player): 0.4,
			#ConditionAllied(player): 0.3,
			#ConditionDebug(player): 1.0,
		}

		self.actions[BehaviorManager.action_types.offensive][BehaviorSmart(player)] = 1.0

		self.strategies[BehaviorManager.strategy_types.offensive][BehaviorRegular(player)] = 1.0
		#self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorAggressive(player)] = 0.02
		#self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorDebug(player)] = 1.0
		#self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorEvil(player)] = 1.0
		#self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorGood(player)] = 1.0
		self.strategies[BehaviorManager.strategy_types.diplomatic][BehaviorNeutral(player)] = 1.0


# Each AI player is assigned a Profile with certain probability.
# actions, strategies and conditions are encapsulated inside a profile itself.
def get_available_player_profiles():
	return (
		(BehaviorProfileCautious, 0.3),
		(BehaviorProfileAggressive, 0.1),
		(BehaviorProfileBalanced, 0.6),
		#(BehaviorProfileDebug, 1.0),
	)

def get_available_pirate_profiles():
	return (
		(BehaviorProfilePirateRegular, 1.0),
	)

########NEW FILE########
__FILENAME__ = boatbuilder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS
from horizons.util.python import decorators
from horizons.entities import Entities

class AbstractBoatBuilder(AbstractBuilding):
	@property
	def evaluator_class(self):
		return BoatBuilderEvaluator

	@property
	def producer_building(self):
		""" Boat builders don't produce any resources """
		return False

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.BOAT_BUILDER] = cls

class BoatBuilderEvaluator(BuildingEvaluator):
	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.BOAT_BUILDER, (x, y), orientation)

		distance_to_collector = cls._distance_to_nearest_collector(area_builder, builder)
		if distance_to_collector is None:
			return None # require boat builders to have a collector building in range

		personality = area_builder.owner.personality_manager.get('BoatBuilderEvaluator')
		alignment = cls._get_alignment(area_builder, builder.position.tuple_iter())
		value = float(Entities.buildings[BUILDINGS.BOAT_BUILDER].radius) / distance_to_collector + alignment * personality.alignment_importance
		return BoatBuilderEvaluator(area_builder, builder, value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.BOAT_BUILDER

AbstractBoatBuilder.register_buildings()

decorators.bind_all(AbstractBoatBuilder)
decorators.bind_all(BoatBuilderEvaluator)

########NEW FILE########
__FILENAME__ = brickyard
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS
from horizons.util.python import decorators
from horizons.entities import Entities

class AbstractBrickyard(AbstractBuilding):
	@property
	def evaluator_class(self):
		return BrickyardEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.BRICKYARD] = cls

class BrickyardEvaluator(BuildingEvaluator):
	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.BRICKYARD, (x, y), orientation)

		distance_to_clay_pit = cls._distance_to_nearest_building(area_builder, builder, BUILDINGS.CLAY_PIT)
		distance_to_collector = cls._distance_to_nearest_collector(area_builder, builder)
		if distance_to_clay_pit is None and distance_to_collector is None:
			return None

		personality = area_builder.owner.personality_manager.get('BrickyardEvaluator')
		distance_penalty = Entities.buildings[BUILDINGS.BRICKYARD].radius * personality.distance_penalty

		alignment = cls._get_alignment(area_builder, builder.position.tuple_iter())
		distance = cls._weighted_distance(distance_to_clay_pit, [(personality.collector_distance_importance, distance_to_collector)], distance_penalty)
		value = float(Entities.buildings[BUILDINGS.BRICKYARD].radius) / distance + alignment * personality.alignment_importance
		return BrickyardEvaluator(area_builder, builder, value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.BRICKYARD

AbstractBrickyard.register_buildings()

decorators.bind_all(AbstractBrickyard)
decorators.bind_all(BrickyardEvaluator)

########NEW FILE########
__FILENAME__ = charcoalburner
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.entities import Entities
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class AbstractCharcoalBurner(AbstractBuilding):
	@property
	def evaluator_class(self):
		return CharcoalBurnerEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.CHARCOAL_BURNER] = cls

class CharcoalBurnerEvaluator(BuildingEvaluator):
	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.CHARCOAL_BURNER, (x, y), orientation)

		distance_to_collector = cls._distance_to_nearest_collector(area_builder, builder)
		if distance_to_collector is None:
			return None

		personality = area_builder.owner.personality_manager.get('CharcoalBurnerEvaluator')
		distance_penalty = Entities.buildings[BUILDINGS.CHARCOAL_BURNER].radius * personality.distance_penalty

		distance_to_iron_mine = cls._distance_to_nearest_building(area_builder, builder, BUILDINGS.MINE)
		distance_to_lumberjack = cls._distance_to_nearest_building(area_builder, builder, BUILDINGS.LUMBERJACK)
		alignment = cls._get_alignment(area_builder, builder.position.tuple_iter())

		distance = cls._weighted_distance(distance_to_collector, [(personality.lumberjack_distance_importance, distance_to_lumberjack),
			(personality.iron_mine_distance_importance, distance_to_iron_mine)], distance_penalty)
		value = float(Entities.buildings[BUILDINGS.CHARCOAL_BURNER].radius) / distance + alignment * personality.alignment_importance
		return CharcoalBurnerEvaluator(area_builder, builder, value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.CHARCOAL_BURNER

AbstractCharcoalBurner.register_buildings()

decorators.bind_all(AbstractCharcoalBurner)
decorators.bind_all(CharcoalBurnerEvaluator)

########NEW FILE########
__FILENAME__ = claydeposit
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fakeresourcedeposit import AbstractFakeResourceDeposit
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class AbstractClayDeposit(AbstractFakeResourceDeposit):
	@classmethod
	def get_higher_level_building_id(cls):
		return BUILDINGS.CLAY_PIT

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.CLAY_DEPOSIT] = cls

AbstractClayDeposit.register_buildings()

decorators.bind_all(AbstractClayDeposit)

########NEW FILE########
__FILENAME__ = claypit
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS, RES
from horizons.util.python import decorators
from horizons.component.storagecomponent import StorageComponent
from horizons.entities import Entities

class AbstractClayPit(AbstractBuilding):
	def iter_potential_locations(self, settlement_manager):
		building_class = Entities.buildings[BUILDINGS.CLAY_PIT]
		for building in settlement_manager.settlement.buildings_by_id.get(BUILDINGS.CLAY_DEPOSIT, []):
			if building.get_component(StorageComponent).inventory[RES.RAW_CLAY]:
				coords = building.position.origin.to_tuple()
				if coords in settlement_manager.production_builder.simple_collector_area_cache.cache[building_class.size]:
					yield (coords[0], coords[1], 0)

	@property
	def evaluator_class(self):
		return ClayPitEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.CLAY_PIT] = cls

class ClayPitEvaluator(BuildingEvaluator):
	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.CLAY_PIT, (x, y), orientation)
		distance_to_collector = cls._distance_to_nearest_collector(area_builder, builder, False)
		value = 1.0 / (distance_to_collector + 1)
		return ClayPitEvaluator(area_builder, builder, value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.CLAY_PIT

AbstractClayPit.register_buildings()

decorators.bind_all(AbstractClayPit)
decorators.bind_all(ClayPitEvaluator)

########NEW FILE########
__FILENAME__ = distillery
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS
from horizons.util.python import decorators
from horizons.entities import Entities

class AbstractDistillery(AbstractBuilding):
	@property
	def evaluator_class(self):
		return DistilleryEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.DISTILLERY] = cls

class DistilleryEvaluator(BuildingEvaluator):
	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.DISTILLERY, (x, y), orientation)

		distance_to_farm = None
		for building in area_builder.settlement.buildings_by_id.get(BUILDINGS.FARM, []):
			distance = builder.position.distance(building.position)
			if distance <= Entities.buildings[BUILDINGS.DISTILLERY].radius:
				sugarcane_producer = False
				for provider in building.get_providers():
					if isinstance(provider, Entities.buildings[BUILDINGS.SUGARCANE_FIELD]):
						sugarcane_producer = True
						break
				if sugarcane_producer:
					distance_to_farm = distance if distance_to_farm is None or distance < distance_to_farm else distance_to_farm

		distance_to_collector = cls._distance_to_nearest_collector(area_builder, builder)
		if distance_to_collector is None:
			return None # require distilleries to have a collector building in range

		personality = area_builder.owner.personality_manager.get('DistilleryEvaluator')
		distance_penalty = Entities.buildings[BUILDINGS.DISTILLERY].radius * personality.distance_penalty

		alignment = cls._get_alignment(area_builder, builder.position.tuple_iter())
		distance = cls._weighted_distance(distance_to_collector, [(personality.farm_distance_importance, distance_to_farm)], distance_penalty)
		value = float(Entities.buildings[BUILDINGS.DISTILLERY].radius) / distance + alignment * personality.alignment_importance
		return DistilleryEvaluator(area_builder, builder, value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.DISTILLERY

AbstractDistillery.register_buildings()

decorators.bind_all(AbstractDistillery)
decorators.bind_all(DistilleryEvaluator)

########NEW FILE########
__FILENAME__ = doctor
# ###################################################
# Copyright (C) 2013 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class AbstractDoctor(AbstractBuilding):
	def iter_potential_locations(self, settlement_manager):
		spots_in_settlement = settlement_manager.settlement.buildability_cache.cache[(2, 2)]
		village_builder = settlement_manager.village_builder
		for coords in village_builder.special_building_assignments[BUILDING_PURPOSE.DOCTOR].iterkeys():
			if coords not in spots_in_settlement or village_builder.plan[coords][1][0] > village_builder.current_section:
				continue
			object = settlement_manager.settlement.ground_map[coords].object
			if object is None or object.buildable_upon:
				yield (coords[0], coords[1], 0)

	@property
	def producer_building(self):
		"""Doctors don't produce any resources."""
		return False

	@property
	def evaluator_class(self):
		return DoctorEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.DOCTOR] = cls

class DoctorEvaluator(BuildingEvaluator):
	need_collector_connection = False
	record_plan_change = False

	@classmethod
	def create(cls, production_builder, x, y, orientation):
		settlement_manager = production_builder.settlement_manager
		village_builder = settlement_manager.village_builder
		builder = BasicBuilder.create(BUILDINGS.DOCTOR, (x, y), orientation)

		assigned_residences = village_builder.special_building_assignments[BUILDING_PURPOSE.DOCTOR][(x, y)]
		total = len(assigned_residences)
		not_serviced = 0
		for residence_coords in assigned_residences:
			if village_builder.plan[residence_coords][0] == BUILDING_PURPOSE.RESIDENCE:
				not_serviced += 1

		if not_serviced <= 0 or not_serviced < total * settlement_manager.owner.personality_manager.get('AbstractDoctor').fraction_of_assigned_residences_built:
			return None

		return DoctorEvaluator(village_builder, builder, not_serviced)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.DOCTOR

AbstractDoctor.register_buildings()

decorators.bind_all(AbstractDoctor)
decorators.bind_all(DoctorEvaluator)

########NEW FILE########
__FILENAME__ = fakeresourcedeposit
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.world.production.productionline import ProductionLine
from horizons.util.python import decorators
from horizons.entities import Entities
from horizons.world.production.producer import Producer

class AbstractFakeResourceDeposit(AbstractBuilding):
	def __init__(self, building_id, name, settler_level):
		super(AbstractFakeResourceDeposit, self).__init__(building_id, name, settler_level)
		self.lines = {} # output_resource_id: ProductionLine
		self.__init_production_lines()

	@classmethod
	def get_higher_level_building_id(cls):
		raise NotImplementedError('This function has to be overridden.')


	def __init_production_lines(self):
		production_lines = self._get_producer_building().get_component_template(Producer)['productionlines']
		for key, value in production_lines.iteritems():
			production_line = ProductionLine(key, value)
			production_line.id = None
			production_line.production = {}
			production_line.produced_res = {}
			for resource_id, amount in production_line.consumed_res.iteritems():
				production_line.production[resource_id] = -amount
				production_line.produced_res[resource_id] = -amount
			production_line.consumed_res = {}
			self.lines[production_line.produced_res.keys()[0]] = production_line

	def _get_producer_building(self):
		return Entities.buildings[self.get_higher_level_building_id()]

	@classmethod
	def load(cls, db, building_id):
		# load the higher level building data because resource deposits don't actually produce anything
		name = cls._load_name(db, building_id)
		settler_level = cls._load_settler_level(building_id)
		return cls(building_id, name, settler_level)

	def get_expected_cost(self, resource_id, production_needed, settlement_manager):
		""" you don't actually build resource deposits """
		return 0

	@property
	def directly_buildable(self):
		""" You don't actually build resource deposits """
		return False

	@property
	def ignore_production(self):
		return True

decorators.bind_all(AbstractFakeResourceDeposit)

########NEW FILE########
__FILENAME__ = farm
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from collections import defaultdict

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.constants import BUILD_RESULT, BUILDING_PURPOSE
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.constants import RES, BUILDINGS
from horizons.util.python import decorators
from horizons.world.buildability.terraincache import TerrainRequirement


class FarmOptionCache(object):
	def __init__(self, settlement_manager):
		self.settlement_manager = settlement_manager
		abstract_farm =  AbstractBuilding.buildings[BUILDINGS.FARM]
		self.field_spots_set = abstract_farm._get_buildability_intersection(settlement_manager, (3, 3), TerrainRequirement.LAND, False)
		self.farm_spots_set = self.field_spots_set.intersection(settlement_manager.production_builder.simple_collector_area_cache.cache[(3, 3)])
		self.road_spots_set = abstract_farm._get_buildability_intersection(settlement_manager, (1, 1), TerrainRequirement.LAND, False).union(settlement_manager.land_manager.roads)
		self.raw_options = self._get_raw_options(self.farm_spots_set, self.field_spots_set, self.road_spots_set)
		self.max_fields = self._get_max_fields()
		self._positive_alignment = None

	def _get_raw_options(self, farm_spots_set, field_spots_set, road_spots_set):
		field_row3 = {}
		field_col3 = {}

		for coords in farm_spots_set:
			x, y = coords
			row_score = 1
			if (x - 3, y) in field_spots_set:
				row_score += 1
			if (x + 3, y) in field_spots_set:
				row_score += 1
			field_row3[coords] = row_score

			col_score = 1
			if (x, y - 3) in field_spots_set:
				col_score += 1
			if (x, y + 3) in field_spots_set:
				col_score += 1
			field_col3[coords] = col_score

		road_row3 = set()
		road_col3 = set()
		for (x, y) in road_spots_set:
			if (x + 2, y) in road_spots_set and (x + 1, y) in road_spots_set:
				road_row3.add((x, y))
			if (x, y + 2) in road_spots_set and (x, y + 1) in road_spots_set:
				road_col3.add((x, y))

		road_row9 = set()
		for (x, y) in road_row3:
			if (x - 3, y) in road_row3 and (x + 3, y) in road_row3:
				road_row9.add((x, y))

		road_col9 = set()
		for (x, y) in road_col3:
			if (x, y - 3) in road_col3 and (x, y + 3) in road_col3:
				road_col9.add((x, y))

		raw_options = []
		for coords in sorted(farm_spots_set):
			x, y = coords

			row_score = field_row3[coords] - 1
			if (x, y - 1) in road_row9:
				score = row_score
				if (x, y - 4) in field_row3:
					score += field_row3[(x, y - 4)]
				if (x, y + 3) in field_row3:
					score += field_row3[(x, y + 3)]
				if score > 0:
					raw_options.append((score, coords, 0))
			if (x, y + 3) in road_row9:
				score = row_score
				if (x, y - 3) in field_row3:
					score += field_row3[(x, y - 3)]
				if (x, y + 4) in field_row3:
					score += field_row3[(x, y + 4)]
				if score > 0:
					raw_options.append((score, coords, 1))

			col_score = field_col3[coords] - 1
			if (x - 1, y) in road_col9:
				score = col_score
				if (x - 4, y) in field_col3:
					score += field_col3[(x - 4, y)]
				if (x + 3, y) in field_col3:
					score += field_col3[(x + 3, y)]
				if score > 0:
					raw_options.append((score, coords, 2))
			if (x + 3, y) in road_col9:
				score = col_score
				if (x - 3, y) in field_col3:
					score += field_col3[(x - 3, y)]
				if (x + 4, y) in field_col3:
					score += field_col3[(x + 4, y)]
				if score > 0:
					raw_options.append((score, coords, 3))

		return raw_options

	def _get_max_fields(self):
		max_fields = 0
		for (num_fields, _, _) in self.raw_options:
			if num_fields > max_fields:
				max_fields = num_fields
		return max_fields

	def get_positive_alignment(self):
		if self._positive_alignment is None:
			land_manager = self.settlement_manager.land_manager
			village_builder = self.settlement_manager.village_builder
			positive_alignment = land_manager.coastline.union(land_manager.roads, village_builder.plan.iterkeys())
			production_builder_plan = self.settlement_manager.production_builder.plan
			for (coords, purpose) in production_builder_plan:
				if purpose != BUILDING_PURPOSE.NONE:
					positive_alignment.add(coords)
			self._positive_alignment = positive_alignment
		return self._positive_alignment


class AbstractFarm(AbstractBuilding):
	@property
	def directly_buildable(self):
		""" farms have to be triggered by fields """
		return False

	@property
	def evaluator_class(self):
		return FarmEvaluator

	def get_expected_cost(self, resource_id, production_needed, settlement_manager):
		""" the fields have to take into account the farm cost """
		return 0

	@classmethod
	def get_purpose(cls, resource_id):
		return {
			RES.FOOD:           BUILDING_PURPOSE.POTATO_FIELD,
			RES.WOOL:           BUILDING_PURPOSE.PASTURE,
			RES.SUGAR:          BUILDING_PURPOSE.SUGARCANE_FIELD,
			RES.TOBACCO_LEAVES: BUILDING_PURPOSE.TOBACCO_FIELD,
			RES.HERBS:          BUILDING_PURPOSE.HERBARY,
		}.get(resource_id)

	def get_evaluators(self, settlement_manager, resource_id):
		options_cache = self._get_option_cache(settlement_manager)
		raw_options = options_cache.raw_options
		if not raw_options:
			return []

		farm_field_buckets = []
		for _ in xrange(9):
			farm_field_buckets.append([])

		for option in raw_options:
			farm_field_buckets[option[0]].append(option)

		personality = settlement_manager.owner.personality_manager.get('FarmEvaluator')
		options_left = personality.max_options
		chosen_raw_options = []
		for i in xrange(8, 0, -1):
			if len(farm_field_buckets[i]) > options_left:
				chosen_raw_options.extend(settlement_manager.session.random.sample(farm_field_buckets[i], options_left))
				options_left = 0
			else:
				chosen_raw_options.extend(farm_field_buckets[i])
				options_left -= len(farm_field_buckets[i])
			if options_left == 0:
				break

		max_fields = options_cache.max_fields
		field_spots_set = options_cache.field_spots_set
		road_spots_set = options_cache.road_spots_set
		positive_alignment = options_cache.get_positive_alignment()
		production_builder = settlement_manager.production_builder
		field_purpose = self.get_purpose(resource_id)
		road_configs = [(0, -1), (0, 3), (-1, 0), (3, 0)]
		options = []

		# create evaluators for completely new farms
		for (_, (x, y), road_config) in chosen_raw_options:
			road_dx, road_dy = road_configs[road_config]
			evaluator = FarmEvaluator.create(production_builder, x, y, road_dx, road_dy, max_fields, field_purpose, field_spots_set, road_spots_set, positive_alignment)
			if evaluator is not None:
				options.append(evaluator)

		# create evaluators for modified farms (change unused field type)
		for coords_list in production_builder.unused_fields.itervalues():
			for x, y in coords_list:
				evaluator = ModifiedFieldEvaluator.create(production_builder, x, y, field_purpose)
				if evaluator is not None:
					options.append(evaluator)
		return options

	__cache = {}
	def _get_option_cache(self, settlement_manager):
		production_builder = settlement_manager.production_builder
		current_cache_changes = (production_builder.island.last_change_id, production_builder.last_change_id)

		worldid = settlement_manager.worldid
		if worldid in self.__cache and self.__cache[worldid][0] != current_cache_changes:
			del self.__cache[worldid]

		if worldid not in self.__cache:
			self.__cache[worldid] = (current_cache_changes, FarmOptionCache(settlement_manager))
		return self.__cache[worldid][1]

	@classmethod
	def clear_cache(cls):
		cls.__cache.clear()

	def get_max_fields(self, settlement_manager):
		return self._get_option_cache(settlement_manager).max_fields

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.FARM] = cls


class FarmEvaluator(BuildingEvaluator):
	__field_pos_offsets = [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
	__moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
	__field_offsets = None

	__slots__ = ('farm_plan', 'field_purpose')

	def __init__(self, area_builder, builder, value, farm_plan, fields, field_purpose):
		super(FarmEvaluator, self).__init__(area_builder, builder, value)
		self.farm_plan = farm_plan
		self.field_purpose = field_purpose

	@classmethod
	def init_field_offsets(cls):
		# right next to the farm
		first_class = [(-3, -3), (-3, 0), (-3, 3), (0, -3), (0, 3), (3, -3), (3, 0), (3, 3)]
		# offset by a road right next to the farm
		second_class = [(-4, -3), (-4, 0), (-4, 3), (-3, -4), (-3, 4), (0, -4), (0, 4), (3, -4), (3, 4), (4, -3), (4, 0), (4, 3)]
		# offset by crossing roads
		third_class = [(-4, -4), (-4, 4), (4, -4), (4, 4)]
		cls.__field_offsets = first_class + second_class + third_class

	@classmethod
	def _suitable_for_road(self, production_builder, coords):
		return coords in production_builder.land_manager.roads or (coords in production_builder.plan and production_builder.plan[coords][0] == BUILDING_PURPOSE.NONE)

	@classmethod
	def create(cls, area_builder, farm_x, farm_y, road_dx, road_dy, min_fields, field_purpose, field_spots_set, road_spots_set, positive_alignment):
		farm_plan = {}

		# place the farm area road
		existing_roads = 0
		for other_offset in xrange(-3, 6):
			coords = None
			if road_dx == 0:
				coords = (farm_x + other_offset, farm_y + road_dy)
			else:
				coords = (farm_x + road_dx, farm_y + other_offset)
			assert coords in road_spots_set

			farm_plan[coords] = BUILDING_PURPOSE.ROAD
			if coords in area_builder.land_manager.roads:
				existing_roads += 1

		# place the fields
		fields = 0
		for (dx, dy) in cls.__field_offsets:
			if fields >= 8:
				break # unable to place more anyway
			coords = (farm_x + dx, farm_y + dy)
			if coords not in field_spots_set:
				continue

			field_fits = True
			for (fdx, fdy) in cls.__field_pos_offsets:
				coords2 = (coords[0] + fdx, coords[1] + fdy)
				if coords2 in farm_plan:
					field_fits = False
					break
			if not field_fits:
				continue # some part of the area is reserved for something else

			fields += 1
			for (fdx, fdy) in cls.__field_pos_offsets:
				coords2 = (coords[0] + fdx, coords[1] + fdy)
				farm_plan[coords2] = BUILDING_PURPOSE.RESERVED
			farm_plan[coords] = field_purpose
		if fields < min_fields:
			return None # go for the most fields possible

		# add the farm itself to the plan
		builder = BasicBuilder.create(BUILDINGS.FARM, (farm_x, farm_y), 0)
		for coords in builder.position.tuple_iter():
			farm_plan[coords] = BUILDING_PURPOSE.RESERVED
		farm_plan[(farm_x, farm_y)] = BUILDING_PURPOSE.FARM

		# calculate the alignment value and the rectangle that contains the whole farm
		alignment = 0
		min_x, max_x, min_y, max_y = None, None, None, None
		for x, y in farm_plan:
			min_x = x if min_x is None or min_x > x else min_x
			max_x = x if max_x is None or max_x < x else max_x
			min_y = y if min_y is None or min_y > y else min_y
			max_y = y if max_y is None or max_y < y else max_y

			for dx, dy in cls.__moves:
				coords = (x + dx, y + dy)
				if coords not in farm_plan and coords in positive_alignment:
					alignment += 1

		# calculate the value of the farm road end points (larger is better)
		personality = area_builder.owner.personality_manager.get('FarmEvaluator')
		immediate_connections = 0
		for other_offset in [-4, 6]:
			if road_dx == 0:
				coords = (farm_x + other_offset, farm_y + road_dy)
			else:
				coords = (farm_x + road_dx, farm_y + other_offset)
			if coords in area_builder.land_manager.roads:
				immediate_connections += personality.immediate_connection_road
			elif coords in area_builder.plan:
				if area_builder.plan[coords][0] == BUILDING_PURPOSE.NONE:
					immediate_connections += personality.immediate_connection_free

		extra_space = (max_x - min_x + 1) * (max_y - min_y + 1) - 9 * (fields + 2)
		value = fields + existing_roads * personality.existing_road_importance + \
			alignment * personality.alignment_importance - extra_space * personality.wasted_space_penalty + \
			immediate_connections * personality.immediate_connection_importance
		return FarmEvaluator(area_builder, builder, value, farm_plan, fields, field_purpose)

	def _register_changes(self, changes, just_roads):
		for (purpose, data), coords_list in changes.iteritems():
			if just_roads == (purpose == BUILDING_PURPOSE.ROAD):
				self.area_builder.register_change_list(coords_list, purpose, data)

	def execute(self):
		# cheap resource check first, then pre-reserve the tiles and check again
		if not self.builder.have_resources(self.area_builder.land_manager):
			return (BUILD_RESULT.NEED_RESOURCES, None)

		changes = defaultdict(list)
		reverse_changes = defaultdict(list)
		for coords, purpose in self.farm_plan.iteritems():
			# completely ignore the road in the plan for now
			if purpose == BUILDING_PURPOSE.ROAD:
				continue
			assert coords not in self.area_builder.land_manager.roads

			changes[(purpose, None)].append(coords)
			reverse_changes[self.area_builder.plan[coords]].append(coords)
		self._register_changes(changes, False)

		resource_check = self.have_resources()
		if resource_check is None:
			self._register_changes(reverse_changes, False)
			self.log.debug('%s, unable to reach by road', self)
			return (BUILD_RESULT.IMPOSSIBLE, None)
		elif not resource_check:
			self._register_changes(reverse_changes, False)
			return (BUILD_RESULT.NEED_RESOURCES, None)
		assert self.area_builder.build_road_connection(self.builder)

		building = self.builder.execute(self.area_builder.land_manager)
		if not building:
			# TODO: make sure the plan and the reality stay in a reasonable state
			# the current code makes the plan look as if everything was built but in reality
			# a farm may be missing if there was not enough money after building the road.
			self.log.debug('%s, unknown error', self)
			return (BUILD_RESULT.UNKNOWN_ERROR, None)

		for coords, purpose in self.farm_plan.iteritems():
			if purpose == self.field_purpose:
				self.area_builder.unused_fields[self.field_purpose].append(coords)
		self._register_changes(changes, True)
		return (BUILD_RESULT.OK, building)


class ModifiedFieldEvaluator(BuildingEvaluator):
	"""This evaluator evaluates the cost of changing the type of an unused field."""

	__slots__ = ('_old_field_purpose')

	def __init__(self, area_builder, builder, value, old_field_purpose):
		super(ModifiedFieldEvaluator, self).__init__(area_builder, builder, value)
		self._old_field_purpose = old_field_purpose

	@classmethod
	def create(cls, area_builder, x, y, new_field_purpose):
		building_id = {
			BUILDING_PURPOSE.POTATO_FIELD:    BUILDINGS.POTATO_FIELD,
			BUILDING_PURPOSE.PASTURE:         BUILDINGS.PASTURE,
			BUILDING_PURPOSE.SUGARCANE_FIELD: BUILDINGS.SUGARCANE_FIELD,
			BUILDING_PURPOSE.TOBACCO_FIELD:   BUILDINGS.TOBACCO_FIELD,
			BUILDING_PURPOSE.HERBARY:         BUILDINGS.HERBARY,
		}.get(new_field_purpose)

		personality = area_builder.owner.personality_manager.get('ModifiedFieldEvaluator')
		value = {
			BUILDING_PURPOSE.POTATO_FIELD:    personality.add_potato_field_value,
			BUILDING_PURPOSE.PASTURE:         personality.add_pasture_value,
			BUILDING_PURPOSE.SUGARCANE_FIELD: personality.add_sugarcane_field_value,
			BUILDING_PURPOSE.TOBACCO_FIELD:   personality.add_tobacco_field_value,
			BUILDING_PURPOSE.HERBARY:         personality.add_herbary_field_value,
		}.get(new_field_purpose, 0)

		old_field_purpose = area_builder.plan[(x, y)][0]
		value -= {
			BUILDING_PURPOSE.POTATO_FIELD:    personality.remove_unused_potato_field_penalty,
			BUILDING_PURPOSE.PASTURE:         personality.remove_unused_pasture_penalty,
			BUILDING_PURPOSE.SUGARCANE_FIELD: personality.remove_unused_sugarcane_field_penalty,
			BUILDING_PURPOSE.TOBACCO_FIELD:   personality.remove_unused_tobacco_field_penalty,
			BUILDING_PURPOSE.HERBARY:         personality.remove_unused_herbary_field_penalty,
		}.get(old_field_purpose, 0)

		builder = BasicBuilder.create(building_id, (x, y), 0)
		return ModifiedFieldEvaluator(area_builder, builder, value, old_field_purpose)

	def execute(self):
		if not self.builder.have_resources(self.area_builder.land_manager):
			return (BUILD_RESULT.NEED_RESOURCES, None)

		building = self.builder.execute(self.area_builder.land_manager)
		if not building:
			self.log.debug('%s, unknown error', self)
			return (BUILD_RESULT.UNKNOWN_ERROR, None)

		# remove the old designation
		self.area_builder.unused_fields[self._old_field_purpose].remove(self.builder.position.origin.to_tuple())

		return (BUILD_RESULT.OK, building)

AbstractFarm.register_buildings()
FarmEvaluator.init_field_offsets()

decorators.bind_all(AbstractFarm)
decorators.bind_all(FarmEvaluator)
decorators.bind_all(ModifiedFieldEvaluator)

########NEW FILE########
__FILENAME__ = field
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import math

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.constants import BUILD_RESULT, BUILDING_PURPOSE
from horizons.constants import RES, BUILDINGS
from horizons.util.python import decorators

class AbstractField(AbstractBuilding):
	def get_expected_cost(self, resource_id, production_needed, settlement_manager):
		total_cost = 0
		extra_fields_needed = int(math.ceil(max(0.0, production_needed / self.get_expected_production_level(resource_id))))
		field_spots_available = len(settlement_manager.production_builder.unused_fields[self.get_purpose(resource_id)])
		if field_spots_available >= extra_fields_needed:
			return extra_fields_needed * self.get_expected_building_cost()
		else:
			total_cost += field_spots_available * self.get_expected_building_cost()
			extra_fields_needed -= field_spots_available

		fields_per_farm = AbstractBuilding.buildings[BUILDINGS.FARM].get_max_fields(settlement_manager)
		if fields_per_farm == 0:
			return 1e100

		# TODO: fix the resource gathering code to request resources in larger chunks so this hack doesn't have to be used
		# use fractional farm costs to give farms a chance to picked
		extra_farms_needed = float(extra_fields_needed) / fields_per_farm
		#extra_farms_needed = int(math.ceil(float(extra_fields_needed) / fields_per_farm))

		total_cost += self.get_expected_building_cost() * extra_fields_needed
		total_cost += AbstractBuilding.buildings[BUILDINGS.FARM].get_expected_building_cost() * extra_farms_needed
		return total_cost

	@classmethod
	def get_purpose(cls, resource_id):
		return {
			RES.POTATOES:       BUILDING_PURPOSE.POTATO_FIELD,
			RES.LAMB_WOOL:      BUILDING_PURPOSE.PASTURE,
			RES.RAW_SUGAR:      BUILDING_PURPOSE.SUGARCANE_FIELD,
			RES.TOBACCO_PLANTS: BUILDING_PURPOSE.TOBACCO_FIELD,
			RES.HERBS:          BUILDING_PURPOSE.HERBARY,
		}.get(resource_id)

	@classmethod
	def get_higher_level_resource(cls, resource_id):
		return {
			RES.POTATOES:       RES.FOOD,
			RES.LAMB_WOOL:      RES.WOOL,
			RES.RAW_SUGAR:      RES.SUGAR,
			RES.TOBACCO_PLANTS: RES.TOBACCO_LEAVES,
			RES.HERBS:          RES.MEDICAL_HERBS,
		}.get(resource_id)

	def build(self, settlement_manager, resource_id):
		production_builder = settlement_manager.production_builder
		purpose = self.get_purpose(resource_id)
		if not production_builder.unused_fields[purpose]:
			return (BUILD_RESULT.NEED_PARENT_FIRST, None)
		if not self.have_resources(settlement_manager):
			return (BUILD_RESULT.NEED_RESOURCES, None)

		assert production_builder.unused_fields[purpose], 'expected field spot to be available'
		coords = production_builder.unused_fields[purpose][0]
		building = BasicBuilder(self.id, coords, 0).execute(settlement_manager.land_manager)
		assert building

		production_builder.unused_fields[purpose].popleft()
		production_builder.register_change_list([coords], purpose, None)
		return (BUILD_RESULT.OK, building)

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.POTATO_FIELD] = cls
		cls._available_buildings[BUILDINGS.PASTURE] = cls
		cls._available_buildings[BUILDINGS.SUGARCANE_FIELD] = cls
		cls._available_buildings[BUILDINGS.TOBACCO_FIELD] = cls
		cls._available_buildings[BUILDINGS.HERBARY] = cls

AbstractField.register_buildings()

decorators.bind_all(AbstractField)

########NEW FILE########
__FILENAME__ = firestation
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class AbstractFireStation(AbstractBuilding):
	def iter_potential_locations(self, settlement_manager):
		spots_in_settlement = settlement_manager.settlement.buildability_cache.cache[(2, 2)]
		village_builder = settlement_manager.village_builder
		for coords in village_builder.special_building_assignments[BUILDING_PURPOSE.FIRE_STATION].iterkeys():
			if coords not in spots_in_settlement or village_builder.plan[coords][1][0] > village_builder.current_section:
				continue
			object = settlement_manager.settlement.ground_map[coords].object
			if object is None or object.buildable_upon:
				yield (coords[0], coords[1], 0)

	@property
	def producer_building(self):
		"""Fire stations don't produce any resources."""
		return False

	@property
	def evaluator_class(self):
		return FireStationEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.FIRE_STATION] = cls

class FireStationEvaluator(BuildingEvaluator):
	need_collector_connection = False
	record_plan_change = False

	@classmethod
	def create(cls, production_builder, x, y, orientation):
		settlement_manager = production_builder.settlement_manager
		village_builder = settlement_manager.village_builder
		builder = BasicBuilder.create(BUILDINGS.FIRE_STATION, (x, y), orientation)

		assigned_residences = village_builder.special_building_assignments[BUILDING_PURPOSE.FIRE_STATION][(x, y)]
		total = len(assigned_residences)
		not_serviced = 0
		for residence_coords in assigned_residences:
			if village_builder.plan[residence_coords][0] == BUILDING_PURPOSE.RESIDENCE:
				not_serviced += 1

		if not_serviced <= 0 or not_serviced < total * settlement_manager.owner.personality_manager.get('AbstractFireStation').fraction_of_assigned_residences_built:
			return None

		return FireStationEvaluator(village_builder, builder, not_serviced)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.FIRE_STATION

AbstractFireStation.register_buildings()

decorators.bind_all(AbstractFireStation)
decorators.bind_all(FireStationEvaluator)

########NEW FILE########
__FILENAME__ = fishdeposit
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class AbstractFishDeposit(AbstractBuilding):
	def get_expected_cost(self, resource_id, production_needed, settlement_manager):
		""" You don't actually build fish deposits """
		return 0

	@property
	def directly_buildable(self):
		""" You don't actually build fish deposits """
		return False

	@property
	def ignore_production(self):
		return True

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.FISH_DEPOSIT] = cls

AbstractFishDeposit.register_buildings()

decorators.bind_all(AbstractFishDeposit)

########NEW FILE########
__FILENAME__ = fisher
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import copy
import math
import heapq

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS, COLLECTORS, GAME_SPEED, RES
from horizons.util.python import decorators
from horizons.util.shapes import distances
from horizons.scheduler import Scheduler

class AbstractFisher(AbstractBuilding):
	def get_production_level(self, building, resource_id):
		return self.get_expected_production_level(resource_id) * building.get_non_paused_utilization()

	def get_expected_cost(self, resource_id, production_needed, settlement_manager):
		evaluator = BuildingEvaluator.get_best_evaluator(self.get_evaluators(settlement_manager, resource_id))
		if evaluator is None:
			return None

		current_expected_production_level = evaluator.get_expected_production_level(resource_id)
		extra_buildings_needed = math.ceil(max(0.0, production_needed / current_expected_production_level))
		return extra_buildings_needed * self.get_expected_building_cost()

	def iter_potential_locations(self, settlement_manager):
		options = list(super(AbstractFisher, self).iter_potential_locations(settlement_manager))
		personality = settlement_manager.owner.personality_manager.get('AbstractFisher')
		return settlement_manager.session.random.sample(options, min(len(options), personality.max_options))

	@property
	def evaluator_class(self):
		return FisherEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.FISHER] = cls

class FisherEvaluator(BuildingEvaluator):
	refill_cycle_in_tiles = 12 # TODO: replace this with a direct calculation

	__slots__ = ('__production_level', )

	def __init__(self, area_builder, builder, value):
		super(FisherEvaluator, self).__init__(area_builder, builder, value)
		self.__production_level = None

	def get_expected_production_level(self, resource_id):
		assert resource_id == RES.FOOD
		if self.__production_level is None:
			fishers_coords = [fisher.position.origin.to_tuple() for fisher in self.area_builder.owner.fishers]
			self.__production_level = FisherSimulator.extra_productivity(self.area_builder.session,
				fishers_coords, self.builder.position.origin.to_tuple())
		return self.__production_level

	@classmethod
	def create(cls, area_builder, x, y, orientation):
		coords = (x, y)
		rect_rect_distance_func = distances.distance_rect_rect
		builder = BasicBuilder.create(BUILDINGS.FISHER, coords, orientation)

		shallow_water_body = area_builder.session.world.shallow_water_body
		fisher_shallow_water_body_ids = set()
		for fisher_coords in builder.position.tuple_iter():
			if fisher_coords in shallow_water_body:
				fisher_shallow_water_body_ids.add(shallow_water_body[fisher_coords])
		fisher_shallow_water_body_ids = list(fisher_shallow_water_body_ids)
		assert fisher_shallow_water_body_ids

		tiles_used = 0
		fish_value = 0.0
		last_usable_tick = Scheduler().cur_tick - 60 * GAME_SPEED.TICKS_PER_SECOND # TODO: use a direct calculation
		for fish in area_builder.session.world.fish_indexer.get_buildings_in_range(coords):
			if shallow_water_body[fish.position.origin.to_tuple()] not in fisher_shallow_water_body_ids:
				continue # not in the same shallow water body as the fisher => unreachable
			if fish.last_usage_tick > last_usable_tick:
				continue # the fish deposit seems to be already in use

			distance = rect_rect_distance_func(builder.position, fish.position) + 1.0
			if tiles_used >= cls.refill_cycle_in_tiles:
				fish_value += min(1.0, (3 * cls.refill_cycle_in_tiles - tiles_used) / distance) / 10.0
			else:
				fish_value += min(1.0, (cls.refill_cycle_in_tiles - tiles_used) / distance)

			tiles_used += distance
			if tiles_used >= 3 * cls.refill_cycle_in_tiles:
				break

		if fish_value < 1.5:
			return None
		return FisherEvaluator(area_builder, builder, fish_value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.FISHER

class FisherSimulator(object):
	# TODO: get these values the right way
	move_time = 12 # in ticks
	fish_respawn_time = 480 # 30 seconds in ticks
	simulation_time = 4800 # 5 minutes in ticks

	@classmethod
	def extra_productivity(cls, session, fishers, coords):
		fish_indexer = session.world.fish_indexer
		old_productivity = cls.simulate(fish_indexer, fishers)
		new_list = copy.copy(fishers)
		new_list.append(coords)
		return cls.simulate(fish_indexer, new_list) - old_productivity

	@classmethod
	def simulate(cls, fish_indexer, fishers):
		if not fishers:
			return 0

		fish_map = {} # (x, y); tick_available
		heap = [] # (tick, fisher_coords)
		for fisher_coords in fishers:
			for fish in fish_indexer.get_buildings_in_range(fisher_coords):
				fish_map[fish.position.origin.to_tuple()] = 0
			heap.append((0, fisher_coords))
		heapq.heapify(heap)

		fish_caught = 0
		while True:
			(tick, fisher_coords) = heapq.heappop(heap)
			if tick > cls.simulation_time:
				break # simulate for 1 minute

			found_fish = False
			for fish in fish_indexer.get_buildings_in_range(fisher_coords):
				fish_coords = fish.position.origin.to_tuple()
				if fish_map[fish_coords] > tick:
					continue
				distance = math.sqrt((fish_coords[0] - fisher_coords[0]) ** 2 + (fish_coords[1] - fisher_coords[1]) ** 2)
				move_time = cls.move_time * int(round(distance))
				fish_map[fish_coords] = tick + move_time + COLLECTORS.DEFAULT_WORK_DURATION + cls.fish_respawn_time
				if tick + 2 * move_time + COLLECTORS.DEFAULT_WORK_DURATION <= cls.simulation_time:
					fish_caught += 1
				next_time = tick + 2 * move_time + COLLECTORS.DEFAULT_WORK_DURATION + COLLECTORS.DEFAULT_WAIT_TICKS
				heapq.heappush(heap, (next_time, fisher_coords))
				found_fish = True
				break

			if not found_fish:
				heapq.heappush(heap, (tick + COLLECTORS.DEFAULT_WAIT_TICKS, fisher_coords))
		return float(fish_caught) / cls.simulation_time

AbstractFisher.register_buildings()

decorators.bind_all(AbstractFisher)
decorators.bind_all(FisherEvaluator)
decorators.bind_all(FisherSimulator)

########NEW FILE########
__FILENAME__ = irondeposit
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fakeresourcedeposit import AbstractFakeResourceDeposit
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class AbstractIronDeposit(AbstractFakeResourceDeposit):
	@classmethod
	def get_higher_level_building_id(cls):
		return BUILDINGS.MINE

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.MOUNTAIN] = cls

AbstractIronDeposit.register_buildings()

decorators.bind_all(AbstractIronDeposit)

########NEW FILE########
__FILENAME__ = ironmine
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS, RES
from horizons.util.python import decorators
from horizons.component.storagecomponent import StorageComponent
from horizons.entities import Entities

class AbstractIronMine(AbstractBuilding):
	def iter_potential_locations(self, settlement_manager):
		building_class = Entities.buildings[BUILDINGS.MOUNTAIN]
		for building in settlement_manager.settlement.buildings_by_id.get(BUILDINGS.MOUNTAIN, []):
			if building.get_component(StorageComponent).inventory[RES.RAW_IRON]:
				coords = building.position.origin.to_tuple()
				if coords in settlement_manager.production_builder.simple_collector_area_cache.cache[building_class.size]:
					yield (coords[0], coords[1], (building.rotation - 45) // 90)

	@property
	def evaluator_class(self):
		return IronMineEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.MINE] = cls

class IronMineEvaluator(BuildingEvaluator):
	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.MINE, (x, y), orientation)
		return IronMineEvaluator(area_builder, builder, 0)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.MINE

AbstractIronMine.register_buildings()

decorators.bind_all(AbstractIronMine)
decorators.bind_all(IronMineEvaluator)

########NEW FILE########
__FILENAME__ = lumberjack
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILD_RESULT, BUILDING_PURPOSE
from horizons.entities import Entities
from horizons.constants import BUILDINGS
from horizons.util.python import decorators
from horizons.util.shapes import Rect

class AbstractLumberjack(AbstractBuilding):
	@property
	def evaluator_class(self):
		return LumberjackEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.LUMBERJACK] = cls

class LumberjackEvaluator(BuildingEvaluator):
	__template_outline = None
	__radius_offsets = None

	@classmethod
	def __init_outline(cls):
		"""Save a template outline that surrounds a lumberjack."""
		position = Rect.init_from_topleft_and_size_tuples((0, 0), Entities.buildings[BUILDINGS.LUMBERJACK].size)
		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		coords_list = set(position.get_radius_coordinates(Entities.buildings[BUILDINGS.LUMBERJACK].radius, True))

		result = set()
		for x, y in coords_list:
			for dx, dy in moves:
				coords = (x + dx, y + dy)
				if coords not in coords_list:
					result.add(coords)
		cls.__template_outline = sorted(list(result))
		cls.__radius_offsets = sorted(position.get_radius_coordinates(Entities.buildings[BUILDINGS.LUMBERJACK].radius))

	@classmethod
	def _get_outline(cls, x, y):
		result = []
		for dx, dy in cls.__template_outline:
			result.append((x + dx, y + dy))
		return result

	@classmethod
	def create(cls, area_builder, x, y, orientation):
		# TODO: create a late initialization phase for this kind of stuff
		if cls.__radius_offsets is None:
			cls.__init_outline()

		area_value = 0
		coastline = area_builder.land_manager.coastline
		personality = area_builder.owner.personality_manager.get('LumberjackEvaluator')
		for dx, dy in cls.__radius_offsets:
			coords = (x + dx, y + dy)
			if coords in area_builder.plan and coords not in coastline:
				purpose = area_builder.plan[coords][0]
				if purpose == BUILDING_PURPOSE.NONE:
					area_value += personality.new_tree
				elif purpose == BUILDING_PURPOSE.TREE:
					area_value += personality.shared_tree
		area_value = min(area_value, personality.max_forest_value) # the lumberjack doesn't actually need all the trees
		if area_value < personality.min_forest_value:
			return None # the area is too bad for a lumberjack

		personality = area_builder.owner.personality_manager.get('LumberjackEvaluator')
		alignment = cls._get_alignment_from_outline(area_builder, cls._get_outline(x, y))
		value = area_value + alignment * personality.alignment_importance
		builder = BasicBuilder.create(BUILDINGS.LUMBERJACK, (x, y), orientation)
		return LumberjackEvaluator(area_builder, builder, value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.LUMBERJACK

	def execute(self):
		# TODO Add a check that figures out if all trees that should be planted are in range of the settlement.
		# If not, return range missing result
		(result, building) = super(LumberjackEvaluator, self).execute()
		if result != BUILD_RESULT.OK:
			return (result, None)

		production_builder = self.area_builder
		coastline = production_builder.land_manager.coastline
		island_ground_map = production_builder.island.ground_map
		forest_coords_list = []
		for coords in building.position.get_radius_coordinates(Entities.buildings[BUILDINGS.LUMBERJACK].radius):
			if coords in production_builder.plan and production_builder.plan[coords][0] == BUILDING_PURPOSE.NONE and coords not in coastline:
				if island_ground_map[coords].object is not None and island_ground_map[coords].object.id == BUILDINGS.TREE:
					forest_coords_list.append(coords)
				elif island_ground_map[coords].settlement is not None and island_ground_map[coords].settlement.owner is self.area_builder.owner:
					builder = BasicBuilder(BUILDINGS.TREE, coords, 0)
					if not builder.have_resources(production_builder.land_manager):
						break
					if builder:
						assert builder.execute(production_builder.land_manager)
						forest_coords_list.append(coords)

		production_builder.register_change_list(forest_coords_list, BUILDING_PURPOSE.TREE, None)

		return (BUILD_RESULT.OK, building)

AbstractLumberjack.register_buildings()

decorators.bind_all(AbstractLumberjack)
decorators.bind_all(LumberjackEvaluator)

########NEW FILE########
__FILENAME__ = saltponds
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class AbstractSaltPonds(AbstractBuilding):
	@property
	def evaluator_class(self):
		return SaltPondsEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.SALT_PONDS] = cls

class SaltPondsEvaluator(BuildingEvaluator):
	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.SALT_PONDS, (x, y), orientation)
		alignment = cls._get_alignment(area_builder, builder.position.tuple_iter())
		return SaltPondsEvaluator(area_builder, builder, alignment)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.SALT_PONDS

AbstractSaltPonds.register_buildings()

decorators.bind_all(AbstractSaltPonds)
decorators.bind_all(SaltPondsEvaluator)

########NEW FILE########
__FILENAME__ = signalfire
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS
from horizons.util.python import decorators
from horizons.entities import Entities

class AbstractSignalFire(AbstractBuilding):
	@classmethod
	def _get_buildability_intersection(cls, settlement_manager, size, terrain_type, need_collector_connection):
		coords_set = super(AbstractSignalFire, cls)._get_buildability_intersection(settlement_manager, size, terrain_type, need_collector_connection)
		radius = Entities.buildings[BUILDINGS.SIGNAL_FIRE].radius
		return coords_set.intersection(set(settlement_manager.settlement.warehouse.position.get_radius_coordinates(radius)))

	@property
	def evaluator_class(self):
		return SignalFireEvaluator

	@property
	def producer_building(self):
		""" signal fires don't produce anything """
		return False

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.SIGNAL_FIRE] = cls

class SignalFireEvaluator(BuildingEvaluator):
	need_collector_connection = False

	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.SIGNAL_FIRE, (x, y), orientation)

		sea_area = 0
		for coords in builder.position.get_radius_coordinates(Entities.buildings[BUILDINGS.SIGNAL_FIRE].radius):
			if coords in area_builder.session.world.water:
				sea_area += 1

		personality = area_builder.owner.personality_manager.get('SignalFireEvaluator')
		alignment = cls._get_alignment(area_builder, builder.position.tuple_iter())
		value = sea_area + alignment * personality.alignment_importance
		return SignalFireEvaluator(area_builder, builder, value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.SIGNAL_FIRE

AbstractSignalFire.register_buildings()

decorators.bind_all(AbstractSignalFire)
decorators.bind_all(SignalFireEvaluator)

########NEW FILE########
__FILENAME__ = smeltery
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS
from horizons.util.python import decorators
from horizons.entities import Entities

class AbstractSmeltery(AbstractBuilding):
	@property
	def evaluator_class(self):
		return SmelteryEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.SMELTERY] = cls

class SmelteryEvaluator(BuildingEvaluator):
	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.SMELTERY, (x, y), orientation)

		distance_to_iron_mine = cls._distance_to_nearest_building(area_builder, builder, BUILDINGS.MINE)
		distance_to_collector = cls._distance_to_nearest_collector(area_builder, builder)
		distance_to_charcoal_burner = cls._distance_to_nearest_building(area_builder, builder, BUILDINGS.CHARCOAL_BURNER)
		if distance_to_collector is None and (distance_to_charcoal_burner is None or distance_to_iron_mine is None):
			return None

		personality = area_builder.owner.personality_manager.get('SmelteryEvaluator')
		distance_penalty = Entities.buildings[BUILDINGS.SMELTERY].radius * personality.distance_penalty

		alignment = cls._get_alignment(area_builder, builder.position.tuple_iter())
		distance = cls._weighted_distance(distance_to_iron_mine, [(personality.collector_distance_importance, distance_to_collector),
			(personality.charcoal_burner_distance_importance, distance_to_charcoal_burner)], distance_penalty)
		value = float(Entities.buildings[BUILDINGS.SMELTERY].radius) / distance + alignment * personality.alignment_importance
		return SmelteryEvaluator(area_builder, builder, value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.SMELTERY

AbstractSmeltery.register_buildings()

decorators.bind_all(AbstractSmeltery)
decorators.bind_all(SmelteryEvaluator)

########NEW FILE########
__FILENAME__ = tobacconist
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS
from horizons.util.python import decorators
from horizons.entities import Entities

class AbstractTobacconist(AbstractBuilding):
	@property
	def evaluator_class(self):
		return TobacconistEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.TOBACCONIST] = cls

class TobacconistEvaluator(BuildingEvaluator):
	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.TOBACCONIST, (x, y), orientation)

		distance_to_farm = None
		for building in area_builder.settlement.buildings_by_id.get(BUILDINGS.FARM, []):
			distance = builder.position.distance(building.position)
			if distance <= Entities.buildings[BUILDINGS.TOBACCONIST].radius:
				tobacco_producer = False
				for provider in building.get_providers():
					if isinstance(provider, Entities.buildings[BUILDINGS.TOBACCO_FIELD]):
						tobacco_producer = True
						break
				if tobacco_producer:
					distance_to_farm = distance if distance_to_farm is None or distance < distance_to_farm else distance_to_farm

		distance_to_collector = cls._distance_to_nearest_collector(area_builder, builder)
		if distance_to_collector is None:
			return None # require tobacconists to have a collector building in range

		personality = area_builder.owner.personality_manager.get('TobacconistEvaluator')
		distance_penalty = Entities.buildings[BUILDINGS.TOBACCONIST].radius * personality.distance_penalty

		alignment = cls._get_alignment(area_builder, builder.position.tuple_iter())
		distance = cls._weighted_distance(distance_to_collector, [(personality.farm_distance_importance, distance_to_farm)], distance_penalty)
		value = float(Entities.buildings[BUILDINGS.TOBACCONIST].radius) / distance + alignment * personality.alignment_importance
		return TobacconistEvaluator(area_builder, builder, value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.TOBACCONIST

AbstractTobacconist.register_buildings()

decorators.bind_all(AbstractTobacconist)
decorators.bind_all(TobacconistEvaluator)

########NEW FILE########
__FILENAME__ = toolmaker
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS
from horizons.util.python import decorators
from horizons.entities import Entities

class AbstractToolmaker(AbstractBuilding):
	@property
	def evaluator_class(self):
		return ToolmakerEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.TOOLMAKER] = cls

class ToolmakerEvaluator(BuildingEvaluator):
	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.TOOLMAKER, (x, y), orientation)
		distance_to_collector = cls._distance_to_nearest_collector(area_builder, builder)
		if distance_to_collector is None:
			return None

		distance_to_smeltery = cls._distance_to_nearest_building(area_builder, builder, BUILDINGS.SMELTERY)
		distance_to_charcoal_burner = cls._distance_to_nearest_building(area_builder, builder, BUILDINGS.CHARCOAL_BURNER)
		distance_to_lumberjack = cls._distance_to_nearest_building(area_builder, builder, BUILDINGS.LUMBERJACK)
		alignment = cls._get_alignment(area_builder, builder.position.tuple_iter())

		personality = area_builder.owner.personality_manager.get('ToolmakerEvaluator')
		distance_penalty = Entities.buildings[BUILDINGS.TOOLMAKER].radius * personality.distance_penalty

		distance = cls._weighted_distance(distance_to_collector, [(personality.smeltery_distance_importance, distance_to_smeltery),
			(personality.charcoal_burner_distance_importance, distance_to_charcoal_burner), (personality.lumberjack_distance_importance, distance_to_lumberjack)],
			distance_penalty)
		value = float(Entities.buildings[BUILDINGS.TOOLMAKER].radius) / distance + alignment * personality.alignment_importance
		return ToolmakerEvaluator(area_builder, builder, value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.BRICKYARD

AbstractToolmaker.register_buildings()

decorators.bind_all(AbstractToolmaker)
decorators.bind_all(ToolmakerEvaluator)

########NEW FILE########
__FILENAME__ = tree
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class AbstractTree(AbstractBuilding):
	@property
	def directly_buildable(self):
		""" trees are built by the lumberjacks """
		return False

	@property
	def ignore_production(self):
		# TODO: improve the code so the actual lumberjack production can be calculated
		return True

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.TREE] = cls

AbstractTree.register_buildings()

decorators.bind_all(AbstractTree)

########NEW FILE########
__FILENAME__ = villagebuilding
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.constants import BUILD_RESULT, BUILDING_PURPOSE
from horizons.constants import RES, BUILDINGS
from horizons.util.python import decorators
from horizons.util.shapes import Rect
from horizons.entities import Entities

class AbstractVillageBuilding(AbstractBuilding):
	@classmethod
	def get_purpose(cls, resource_id):
		return {
			RES.FAITH:        BUILDING_PURPOSE.PAVILION,
			RES.EDUCATION:    BUILDING_PURPOSE.VILLAGE_SCHOOL,
			RES.GET_TOGETHER: BUILDING_PURPOSE.TAVERN,
			RES.COMMUNITY:    BUILDING_PURPOSE.MAIN_SQUARE,
		}.get(resource_id)

	def in_settlement(self, settlement_manager, position):
		for coords in position.tuple_iter():
			if coords not in settlement_manager.settlement.ground_map:
				return False
		return True

	def _need_producer(self, settlement_manager, coords, resource_id):
		if not settlement_manager.settlement.count_buildings(BUILDING_PURPOSE.get_building(self.get_purpose(resource_id))):
			return True # if none exist and we need the resource then build it
		assigned_residences = settlement_manager.village_builder.special_building_assignments[self.get_purpose(resource_id)][coords]
		total = len(assigned_residences)
		not_serviced = 0
		for residence_coords in assigned_residences:
			if settlement_manager.village_builder.plan[residence_coords][0] != BUILDING_PURPOSE.RESIDENCE:
				continue
			not_serviced += 1

		if not_serviced > 0 and not_serviced >= total * settlement_manager.owner.personality_manager.get('AbstractVillageBuilding').fraction_of_assigned_residences_built:
			return True
		return False

	def build(self, settlement_manager, resource_id):
		village_builder = settlement_manager.village_builder
		building_purpose = self.get_purpose(resource_id)
		building_id = BUILDING_PURPOSE.get_building(building_purpose)
		building_class = Entities.buildings[building_id]

		for coords, (purpose, (section, _)) in village_builder.plan.iteritems():
			if section > village_builder.current_section or purpose != building_purpose:
				continue

			object = village_builder.land_manager.island.ground_map[coords].object
			if object is not None and object.id == self.id:
				continue

			if building_purpose != BUILDING_PURPOSE.MAIN_SQUARE:
				if not self._need_producer(settlement_manager, coords, resource_id):
					continue

			if not village_builder.have_resources(building_id):
				return (BUILD_RESULT.NEED_RESOURCES, None)
			if coords not in village_builder.settlement.buildability_cache.cache[building_class.size]:
				position = Rect.init_from_topleft_and_size_tuples(coords, building_class.size)
				return (BUILD_RESULT.OUT_OF_SETTLEMENT, position)

			building = BasicBuilder(building_id, coords, 0).execute(settlement_manager.land_manager)
			assert building
			if self.get_purpose(resource_id) == BUILDING_PURPOSE.MAIN_SQUARE and not village_builder.roads_built:
				village_builder.build_roads()
			return (BUILD_RESULT.OK, building)
		return (BUILD_RESULT.SKIP, None)

	def need_to_build_more_buildings(self, settlement_manager, resource_id):
		village_builder = settlement_manager.village_builder
		building_purpose = self.get_purpose(resource_id)

		for coords, (purpose, (section, _)) in village_builder.plan.iteritems():
			if section > village_builder.current_section:
				continue
			if purpose == building_purpose:
				object = village_builder.land_manager.island.ground_map[coords].object
				if object is None or object.id != self.id:
					if building_purpose != BUILDING_PURPOSE.MAIN_SQUARE:
						if not self._need_producer(settlement_manager, coords, resource_id):
							continue
					return True
		return False

	@property
	def coverage_building(self):
		""" main squares, pavilions, schools, and taverns are buildings that need to be built even if the total production is enough """
		return True

	def _get_producer_building(self):
		# TODO: remove this hack; introduced to battle the community Production moving from main squares to the warehouse
		if self.id == BUILDINGS.MAIN_SQUARE:
			return Entities.buildings[BUILDINGS.WAREHOUSE]
		return super(AbstractVillageBuilding, self)._get_producer_building()

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.MAIN_SQUARE] = cls
		cls._available_buildings[BUILDINGS.PAVILION] = cls
		cls._available_buildings[BUILDINGS.VILLAGE_SCHOOL] = cls
		cls._available_buildings[BUILDINGS.TAVERN] = cls

AbstractVillageBuilding.register_buildings()

decorators.bind_all(AbstractVillageBuilding)

########NEW FILE########
__FILENAME__ = weaver
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.buildingevaluator import BuildingEvaluator
from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.constants import BUILDINGS
from horizons.util.python import decorators
from horizons.entities import Entities

class AbstractWeaver(AbstractBuilding):
	@property
	def evaluator_class(self):
		return WeaverEvaluator

	@classmethod
	def register_buildings(cls):
		cls._available_buildings[BUILDINGS.WEAVER] = cls

class WeaverEvaluator(BuildingEvaluator):
	@classmethod
	def create(cls, area_builder, x, y, orientation):
		builder = BasicBuilder.create(BUILDINGS.WEAVER, (x, y), orientation)

		distance_to_farm = None
		for building in area_builder.settlement.buildings_by_id.get(BUILDINGS.FARM, []):
			distance = builder.position.distance(building.position)
			if distance <= Entities.buildings[BUILDINGS.WEAVER].radius:
				wool_producer = False
				for provider in building.get_providers():
					if isinstance(provider, Entities.buildings[BUILDINGS.PASTURE]):
						wool_producer = True
						break
				if wool_producer:
					distance_to_farm = distance if distance_to_farm is None or distance < distance_to_farm else distance_to_farm

		distance_to_collector = cls._distance_to_nearest_collector(area_builder, builder)
		if distance_to_collector is None:
			return None # require weavers to have a collector building in range

		personality = area_builder.owner.personality_manager.get('WeaverEvaluator')
		distance_penalty = Entities.buildings[BUILDINGS.WEAVER].radius * personality.distance_penalty
		alignment = cls._get_alignment(area_builder, builder.position.tuple_iter())
		distance = cls._weighted_distance(distance_to_collector, [(personality.farm_distance_importance, distance_to_farm)], distance_penalty)
		value = float(Entities.buildings[BUILDINGS.WEAVER].radius) / distance + alignment * personality.alignment_importance
		return WeaverEvaluator(area_builder, builder, value)

	@property
	def purpose(self):
		return BUILDING_PURPOSE.WEAVER

AbstractWeaver.register_buildings()

decorators.bind_all(AbstractWeaver)
decorators.bind_all(WeaverEvaluator)

########NEW FILE########
__FILENAME__ = buildingevaluator
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.ai.aiplayer.constants import BUILD_RESULT, BUILDING_PURPOSE
from horizons.util.python import decorators
from horizons.entities import Entities

class BuildingEvaluator(object):
	"""Class representing a set of instructions for building a building complex along with its value."""

	log = logging.getLogger("ai.aiplayer.buildingevaluator")
	need_collector_connection = True
	record_plan_change = True

	__slots__ = ('area_builder', 'builder', 'value')

	def __init__(self, area_builder, builder, value):
		"""
		@param area_builder: the relevant AreaBuilder instance
		@param builder: Builder instance
		@param value: the value of the evaluator (bigger is better)
		"""

		self.area_builder = area_builder
		self.builder = builder
		self.value = value

	@classmethod
	def _weighted_distance(cls, main_component, other_components, none_value):
		"""
		Return the weights sum of the component distances with the specified weights.

		@param main_component: value of the main component
		@param other_components: list[(weight, value), ...] where weight is a float and value is either None or a float
		@param none_value: the penalty for None in place of a component value
		"""

		others = 0.0
		for weight, value in other_components:
			others += weight
		result = (1 - others) * (main_component if main_component is not None else none_value)
		for weight, value in other_components:
			if value is None:
				result += weight * none_value
			else:
				result += weight * value
		return result

	@classmethod
	def _distance_to_nearest_building(cls, area_builder, builder, building_id):
		"""
		Return the shortest distance to a building of type building_id that is in range of the builder.

		@param area_builder: AreaBuilder instance
		@param builder: Builder instance
		@param building_id: the building type id of the building to which the distance should be measured
		"""

		shortest_distance = None
		for building in area_builder.settlement.buildings_by_id.get(building_id, []):
			distance = builder.position.distance(building.position)
			if distance <= Entities.buildings[builder.building_id].radius:
				shortest_distance = distance if shortest_distance is None or distance < shortest_distance else shortest_distance
		return shortest_distance

	@classmethod
	def _distance_to_nearest_collector(cls, production_builder, builder, must_be_in_range=True):
		"""
		Return the shortest distance to a collector that (usually) has to be in range of the builder.

		@param production_builder: ProductionBuilder instance
		@param builder: Builder instance
		@param must_be_in_range: whether the building has to be in range of the builder
		"""

		shortest_distance = None
		for building in production_builder.collector_buildings:
			distance = builder.position.distance(building.position)
			if not must_be_in_range or distance <= Entities.buildings[builder.building_id].radius:
				shortest_distance = distance if shortest_distance is None or distance < shortest_distance else shortest_distance
		return shortest_distance

	@classmethod
	def _get_outline_coords_list(cls, coords_list):
		"""Return the list of coordinates that share sides the given coordinates list."""
		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		if not isinstance(coords_list, set):
			coords_list = set(coords_list)

		result = set()
		for x, y in coords_list:
			for dx, dy in moves:
				coords = (x + dx, y + dy)
				if coords not in coords_list:
					result.add(coords)
		return result

	@classmethod
	def _get_alignment_from_outline(cls, area_builder, outline_coords_list):
		"""Return an alignment value given the list of coordinates that form the outline of a shape."""
		personality = area_builder.owner.personality_manager.get('BuildingEvaluator')
		alignment = 0
		for coords in outline_coords_list:
			if coords in area_builder.land_manager.roads:
				alignment += personality.alignment_road
			elif coords in area_builder.plan:
				purpose = area_builder.plan[coords][0]
				if purpose != BUILDING_PURPOSE.NONE:
					alignment += personality.alignment_production_building
			elif coords in area_builder.settlement.ground_map:
				object = area_builder.settlement.ground_map[coords].object
				if object is not None and not object.buildable_upon:
					alignment += personality.alignment_other_building
			else:
				alignment += personality.alignment_edge
		return alignment

	@classmethod
	def _get_alignment(cls, area_builder, coords_list):
		"""Return an alignment value based on the outline of the given coordinates list."""
		return cls._get_alignment_from_outline(area_builder, cls._get_outline_coords_list(coords_list))

	def __cmp__(self, other):
		"""Objects of this class should never be compared to ensure deterministic ordering and good performance."""
		raise NotImplementedError()

	@property
	def purpose(self):
		"""Return the BUILDING_PURPOSE constant relevant to the builder."""
		raise NotImplementedError('This function has to be overridden.')

	def have_resources(self):
		"""Return None if the builder is unreachable by road, False if there are not enough resources, and True otherwise."""
		# check without road first because the road is unlikely to be the problem and pathfinding isn't cheap
		if not self.builder.have_resources(self.area_builder.land_manager):
			return False
		if not self.need_collector_connection:
			return True # skip the road cost test for buildings that don't need one
		road_cost = self.area_builder.get_road_connection_cost(self.builder)
		if road_cost is None:
			return None
		return self.builder.have_resources(self.area_builder.land_manager, extra_resources=road_cost)

	def _register_builder_position(self):
		self.area_builder.register_change_list(list(self.builder.position.tuple_iter()), BUILDING_PURPOSE.RESERVED, None)
		self.area_builder.register_change_list([self.builder.position.origin.to_tuple()], self.purpose, None)

	def execute(self):
		"""Build the specified building complex. Return (BUILD_RESULT constant, building object)."""
		resource_check = self.have_resources()
		if resource_check is None:
			self.log.debug('%s, unable to reach by road', self)
			return (BUILD_RESULT.IMPOSSIBLE, None)
		elif not resource_check:
			return (BUILD_RESULT.NEED_RESOURCES, None)
		if self.need_collector_connection:
			assert self.area_builder.build_road_connection(self.builder)

		building = self.builder.execute(self.area_builder.land_manager)
		if not building:
			self.log.debug('%s, unknown error', self)
			return (BUILD_RESULT.UNKNOWN_ERROR, None)

		if self.record_plan_change:
			self._register_builder_position()
		return (BUILD_RESULT.OK, building)

	def __str__(self):
		point = self.builder.position.origin
		return '%s at %d, %d with value %f' % (self.__class__.__name__, point.x, point.y, self.value)

	@classmethod
	def get_best_evaluator(cls, evaluators):
		if not evaluators:
			return None

		best_index = 0
		best_value = evaluators[0].value
		for i in xrange(1, len(evaluators)):
			if evaluators[i].value > best_value:
				best_index = i
				best_value = evaluators[i].value
		return evaluators[best_index]

decorators.bind_all(BuildingEvaluator)

########NEW FILE########
__FILENAME__ = combatmanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from fife import fife
import horizons.globals

from horizons.ai.aiplayer.behavior import BehaviorManager
from horizons.ai.aiplayer.behavior.movecallbacks import BehaviorMoveCallback
from horizons.ai.aiplayer.combat.unitmanager import UnitManager
from horizons.component.namedcomponent import NamedComponent
from horizons.constants import LAYERS, AI
from horizons.ext.enum import Enum
from horizons.util.python.callback import Callback
from horizons.util.python.defaultweakkeydictionary import DefaultWeakKeyDictionary
from horizons.util.worldobject import WorldObject


class CombatManager(object):
	"""
	CombatManager object is responsible for handling close combat in game.
	It scans the environment (lookout) and requests certain actions from behavior
	"""
	log = logging.getLogger("ai.aiplayer.combat.combatmanager")

	# states to keep track of combat movement of each ship.

	shipStates = Enum('idle', 'moving')

	combat_range = 18

	def __init__(self, owner):
		super(CombatManager, self).__init__()
		self.__init(owner)

	def __init(self, owner):
		self.owner = owner
		self.unit_manager = owner.unit_manager
		self.world = owner.world
		self.session = owner.session

		# Dictionary of ship => shipState
		self.ships = DefaultWeakKeyDictionary(lambda ship: self.shipStates.idle)

	@classmethod
	def close_range(cls, ship):
		"""
		Range used when wanting to get close to ships.
		"""
		return (2*ship._max_range + ship._min_range)/3 + 1

	@classmethod
	def fallback_range(cls, ship):
		"""
		Range used when wanting to get away from ships.
		"""
		return cls.combat_range - 1

	def save(self, db):
		for ship, state in self.ships.iteritems():
			db("INSERT INTO ai_combat_ship (owner_id, ship_id, state_id) VALUES (?, ?, ?)", self.owner.worldid, ship.worldid, state.index)

	def set_ship_state(self, ship, state):
		self.ships[ship] = state

	def get_ship_state(self, ship):
		if ship not in self.ships:
			self.ships[ship] = self.shipStates.idle
		return self.ships[ship]

	def add_new_unit(self, ship, state=None):
		if not state:
			state = self.shipStates.idle

		self.set_ship_state(ship, state)

	def remove_unit(self, ship):
		if ship in self.ships:
			del self.ships[ship]

	@classmethod
	def load(cls, db, owner):
		self = cls.__new__(cls)
		self._load(db, owner)
		return self

	def _load(self, db, owner):
		self.__init(owner)

		db_result = db("SELECT ship_id, state_id FROM ai_combat_ship WHERE owner_id = ?", self.owner.worldid)
		for (ship_id, state_id,) in db_result:
			ship = WorldObject.get_object_by_id(ship_id)
			state = self.shipStates[state_id]

			# add move callbacks corresponding to given state
			if state == self.shipStates.moving:
				ship.add_move_callback(Callback(BehaviorMoveCallback._arrived, ship))

			self.add_new_unit(ship, state)

	# DISPLAY-RELATED FUNCTIONS
	def _init_fake_tile(self):
		"""Sets the _fake_tile_obj class variable with a ready to use fife object. To create a new fake tile, use _add_fake_tile()"""
		# use fixed SelectableBuildingComponent here, to make sure subclasses also read the same variable
		if not hasattr(CombatManager, "_fake_range_tile_obj"):
			# create object to create instances from
			CombatManager._fake_range_tile_obj = horizons.globals.fife.engine.getModel().createObject('_fake_range_tile_obj', 'ground')
			fife.ObjectVisual.create(CombatManager._fake_range_tile_obj)

			img_path = 'content/gfx/fake_water.png'
			img = horizons.globals.fife.imagemanager.load(img_path)
			for rotation in [45, 135, 225, 315]:
				CombatManager._fake_range_tile_obj.get2dGfxVisual().addStaticImage(rotation, img.getHandle())
		if not hasattr(self, '_selected_fake_tiles'):
			self._selected_fake_tiles = []
		if not hasattr(self, '_selected_tiles'):
			self._selected_tiles = []

	def _add_fake_tile(self, x, y, layer, renderer, color):
		"""Adds a fake tile to the position. Requires 'self._fake_tile_obj' to be set."""
		inst = layer.createInstance(CombatManager._fake_range_tile_obj, fife.ModelCoordinate(x, y, 0), "")
		fife.InstanceVisual.create(inst)
		self._selected_fake_tiles.append(inst)
		renderer.addColored(inst, *color)

	def _add_tile(self, tile, renderer, color):
		self._selected_tiles.append(tile)
		renderer.addColored(tile._instance, *color)

	def _clear_fake_tiles(self):
		if not hasattr(self, '_selected_fake_tiles'):
			return
		renderer = self.session.view.renderer['InstanceRenderer']
		for tile in self._selected_fake_tiles:
			renderer.removeColored(tile)
			self.session.view.layers[LAYERS.FIELDS].deleteInstance(tile)
		self._selected_fake_tiles = []

		for tile in self._selected_tiles:
			renderer.removeColored(tile._instance)
		self._selected_tiles = []

	def _highlight_points(self, points, color):
		renderer = self.session.view.renderer['InstanceRenderer']
		layer = self.session.world.session.view.layers[LAYERS.FIELDS]
		for point in points:
			tup = (point.x, point.y)
			island_tile = [island for island in self.session.world.islands if island.get_tile_tuple(tup)]
			if island_tile:
				tile = island_tile[0].get_tile_tuple(tup)
				self._add_tile(tile, renderer, color)
			else:
				self._add_fake_tile(tup[0], tup[1], layer, renderer, color)

	def _highlight_circle(self, position, radius, color):
		points = set(self.session.world.get_points_in_radius(position, radius))
		points2 = set(self.session.world.get_points_in_radius(position, radius-1))
		self._highlight_points(list(points-points2), color)

	def display(self):
		"""
		Display combat ranges.
		"""
		if not AI.HIGHLIGHT_COMBAT:
			return

		combat_range_color = (80, 0, 250)
		attack_range_color = (255, 0, 0)
		close_range_color = (0, 0, 100)
		fallback_range_color = (0, 180, 100)
		center_point_color = (0, 200, 0)

		self._clear_fake_tiles()
		self._init_fake_tile()

		for ship, state in self.ships.iteritems():
			range = self.combat_range
			self._highlight_circle(ship.position, range, combat_range_color)
			self._highlight_circle(ship.position, self.close_range(ship), close_range_color)
			self._highlight_circle(ship.position, self.fallback_range(ship), fallback_range_color)
			self._highlight_circle(ship.position, ship._max_range, attack_range_color)
			self._highlight_circle(ship.position, ship._min_range, attack_range_color)
			self._highlight_points([ship.position], center_point_color)

	def handle_mission_combat(self, mission):
		"""
		Routine for handling combat in mission that requests for it.
		"""
		filters = self.unit_manager.filtering_rules
		fleet = mission.fleet

		ship_group = fleet.get_ships()
		ship_group = self.unit_manager.filter_ships(ship_group, (filters.ship_state(self.ships, self.shipStates.idle)))

		if not ship_group:
			mission.abort_mission()

		ships_around = self.unit_manager.find_ships_near_group(ship_group, self.combat_range)
		ships_around = self.unit_manager.filter_ships(ships_around, (filters.hostile(), ))
		pirate_ships = self.unit_manager.filter_ships(ships_around, (filters.pirate, ))
		fighting_ships = self.unit_manager.filter_ships(ships_around, (filters.fighting(), ))
		working_ships = self.unit_manager.filter_ships(ships_around, (filters.working(), ))

		environment = {'ship_group': ship_group}

		# begin combat if it's still unresolved
		if fighting_ships:
			environment['enemies'] = fighting_ships
			environment['power_balance'] = UnitManager.calculate_power_balance(ship_group, fighting_ships)
			self.log.debug("Player: %s vs Player: %s -> power_balance:%s", self.owner.name, fighting_ships[0].owner.name, environment['power_balance'])
			self.owner.behavior_manager.request_action(BehaviorManager.action_types.offensive,
				'fighting_ships_in_sight', **environment)
		elif pirate_ships:
			environment['enemies'] = pirate_ships
			environment['power_balance'] = UnitManager.calculate_power_balance(ship_group, pirate_ships)
			self.log.debug("Player: %s vs Player: %s -> power_balance:%s", self.owner.name, pirate_ships[0].owner.name, environment['power_balance'])
			self.owner.behavior_manager.request_action(BehaviorManager.action_types.offensive,
				'pirate_ships_in_sight', **environment)
		elif working_ships:
			environment['enemies'] = working_ships
			self.owner.behavior_manager.request_action(BehaviorManager.action_types.offensive,
				'working_ships_in_sight', **environment)
		else:
			# no one else is around to fight -> continue mission
			mission.continue_mission()

	def handle_uncertain_combat(self, mission):
		"""
		Handles fleets that may way to be in combat.
		"""
		filters = self.unit_manager.filtering_rules

		# test first whether requesting for combat is of any use (any ships nearby)
		ship_group = mission.fleet.get_ships()

		# filter out ships that are already doing a combat move
		ship_group = self.unit_manager.filter_ships(ship_group, (filters.ship_state(self.ships, self.shipStates.idle)))
		ships_around = self.unit_manager.find_ships_near_group(ship_group, self.combat_range)
		ships_around = self.unit_manager.filter_ships(ships_around, (filters.hostile()))
		pirate_ships = self.unit_manager.filter_ships(ships_around, (filters.pirate, ))
		fighting_ships = self.unit_manager.filter_ships(ships_around, (filters.fighting(), ))
		working_ships = self.unit_manager.filter_ships(ships_around, (filters.working(), ))

		if fighting_ships:
			environment = {'enemies': fighting_ships}
			if self.owner.strategy_manager.request_to_pause_mission(mission, **environment):
				self.handle_mission_combat(mission)
		elif pirate_ships:
			environment = {'enemies': pirate_ships}
			if self.owner.strategy_manager.request_to_pause_mission(mission, **environment):
				self.handle_mission_combat(mission)
		elif working_ships:
			environment = {'enemies': working_ships}
			if self.owner.strategy_manager.request_to_pause_mission(mission, **environment):
				self.handle_mission_combat(mission)

	def handle_casual_combat(self):
		"""
		Handles combat for ships wandering around the map (not assigned to any fleet/mission).
		"""
		filters = self.unit_manager.filtering_rules

		rules = (filters.not_in_fleet, filters.fighting(), filters.ship_state(self.ships, self.shipStates.idle))
		for ship in self.unit_manager.get_ships(rules):
			# Turn into one-ship group, since reasoning is based around groups of ships
			ship_group = [ship, ]
			# TODO: create artificial groups by dividing ships that are nearby into groups based on their distance.
			# This may end up being costly, so postpone until we have more cpu resources to spare.

			ships_around = self.unit_manager.find_ships_near_group(ship_group, self.combat_range)
			pirate_ships = self.unit_manager.filter_ships(ships_around, (filters.pirate, ))
			fighting_ships = self.unit_manager.filter_ships(ships_around, (filters.fighting(), ))
			working_ships = self.unit_manager.filter_ships(ships_around, (filters.working(), ))
			environment = {'ship_group': ship_group}
			if fighting_ships:
				environment['enemies'] = fighting_ships
				environment['power_balance'] = UnitManager.calculate_power_balance(ship_group, fighting_ships)
				self.log.debug("Player: %s vs Player: %s -> power_balance:%s", self.owner.name, fighting_ships[0].owner.name, environment['power_balance'])
				self.owner.behavior_manager.request_action(BehaviorManager.action_types.offensive,
					'fighting_ships_in_sight', **environment)
			elif pirate_ships:
				environment['enemies'] = pirate_ships
				environment['power_balance'] = UnitManager.calculate_power_balance(ship_group, pirate_ships)
				self.log.debug("Player: %s vs Player: %s -> power_balance:%s", self.owner.name, pirate_ships[0].owner.name, environment['power_balance'])
				self.owner.behavior_manager.request_action(BehaviorManager.action_types.offensive,
					'pirate_ships_in_sight', **environment)
			elif working_ships:
				environment['enemies'] = working_ships
				self.owner.behavior_manager.request_action(BehaviorManager.action_types.offensive,
					'working_ships_in_sight', **environment)
			else:
				# execute idle action only if whole fleet is idle
				# we check for AIPlayer state here
				if all((self.owner.ships[ship] == self.owner.shipStates.idle for ship in ship_group)):
					self.owner.behavior_manager.request_action(BehaviorManager.action_types.idle,
						'no_one_in_sight', **environment)

	def lookout(self):
		"""
		Basically do 3 things:
		1. Handle combat for missions that explicitly request for it.
		2. Check whether any of current missions may want to be interrupted to resolve potential
			combat that was not planned (e.g. hostile ships nearby fleet on a mission)
		3. Handle combat for ships currently not used in any mission.
		"""
		# handle fleets that explicitly request to be in combat
		for mission in self.owner.strategy_manager.get_missions(condition=lambda mission: mission.combat_phase):
			self.handle_mission_combat(mission)

		# handle fleets that may way to be in combat, but request for it first
		for mission in self.owner.strategy_manager.get_missions(condition=lambda mission: not mission.combat_phase):
			self.handle_uncertain_combat(mission)

		# handle idle ships that are wandering around the map
		self.handle_casual_combat()

		# Log ship states every tick
		if self.log.isEnabledFor(logging.DEBUG):
			self.log.debug("Player:%s Ships combat states:", self.owner.name)
			for ship, state in self.ships.iteritems():
				self.log.debug(" %s: %s", ship.get_component(NamedComponent).name, state)

	def tick(self):
		self.lookout()
		self.display()


class PirateCombatManager(CombatManager):
	"""
	Pirate player requires slightly different handling of combat, thus it gets his own CombatManager.
	Pirate player is able to use standard BehaviorComponents in it's BehaviorManager.
	"""
	log = logging.getLogger("ai.aiplayer.piratecombatmanager")

	shipStates = Enum.get_extended(CombatManager.shipStates, 'chasing_ship', 'going_home')

	def __init__(self, owner):
		super(PirateCombatManager, self).__init__(owner)

	def handle_mission_combat(self, mission):
		"""
		Routine for handling combat in mission that requests for it.
		"""
		filters = self.unit_manager.filtering_rules
		fleet = mission.fleet

		ship_group = fleet.get_ships()
		ship_group = self.unit_manager.filter_ships(ship_group, (filters.ship_state(self.ships, self.shipStates.idle)))

		if not ship_group:
			mission.abort_mission()

		ships_around = self.unit_manager.find_ships_near_group(ship_group, self.combat_range)
		ships_around = self.unit_manager.filter_ships(ships_around, (filters.hostile(), ))
		fighting_ships = self.unit_manager.filter_ships(ships_around, (filters.fighting(), ))
		working_ships = self.unit_manager.filter_ships(ships_around, (filters.working(), ))

		environment = {'ship_group': ship_group}

		# begin combat if it's still unresolved
		if fighting_ships:
			environment['enemies'] = fighting_ships
			environment['power_balance'] = UnitManager.calculate_power_balance(ship_group, fighting_ships)
			self.log.debug("Player: %s vs Player: %s -> power_balance:%s", self.owner.name, fighting_ships[0].owner.name, environment['power_balance'])
			self.owner.behavior_manager.request_action(BehaviorManager.action_types.offensive,
				'fighting_ships_in_sight', **environment)
		elif working_ships:
			environment['enemies'] = working_ships
			self.owner.behavior_manager.request_action(BehaviorManager.action_types.offensive,
				'working_ships_in_sight', **environment)
		else:
			# no one else is around to fight -> continue mission
			mission.continue_mission()

	def handle_uncertain_combat(self, mission):
		"""
		Handles fleets that may way to be in combat.
		"""
		filters = self.unit_manager.filtering_rules

		# test first whether requesting for combat is of any use (any ships nearby)
		ship_group = mission.fleet.get_ships()
		ship_group = self.unit_manager.filter_ships(ship_group, (filters.ship_state(self.ships, self.shipStates.idle)))
		ships_around = self.unit_manager.find_ships_near_group(ship_group, self.combat_range)
		ships_around = self.unit_manager.filter_ships(ships_around, (filters.hostile()))
		fighting_ships = self.unit_manager.filter_ships(ships_around, (filters.fighting(), ))
		working_ships = self.unit_manager.filter_ships(ships_around, (filters.working(), ))

		if fighting_ships:
			environment = {'enemies': fighting_ships}
			if self.owner.strategy_manager.request_to_pause_mission(mission, **environment):
				self.handle_mission_combat(mission)
		elif working_ships:
			environment = {'enemies': working_ships}
			if self.owner.strategy_manager.request_to_pause_mission(mission, **environment):
				self.handle_mission_combat(mission)

	def handle_casual_combat(self):
		"""
		Combat with idle ships (not assigned to a mission)
		"""
		filters = self.unit_manager.filtering_rules

		rules = (filters.not_in_fleet, filters.pirate, filters.ship_state(self.ships, self.shipStates.idle))
		for ship in self.unit_manager.get_ships(rules):
			# Turn into one-ship group, since reasoning is based around groups of ships
			ship_group = [ship, ]

			ships_around = self.unit_manager.find_ships_near_group(ship_group, self.combat_range)
			fighting_ships = self.unit_manager.filter_ships(ships_around, (filters.fighting(), ))
			working_ships = self.unit_manager.filter_ships(ships_around, (filters.working(), ))
			environment = {'ship_group': ship_group}
			if fighting_ships:
				environment['enemies'] = fighting_ships
				environment['power_balance'] = UnitManager.calculate_power_balance(ship_group, fighting_ships)
				self.log.debug("Player: %s vs Player: %s -> power_balance:%s", self.owner.name, fighting_ships[0].owner.name, environment['power_balance'])
				self.owner.behavior_manager.request_action(BehaviorManager.action_types.offensive,
					'fighting_ships_in_sight', **environment)
			elif working_ships:
				environment['enemies'] = working_ships
				self.owner.behavior_manager.request_action(BehaviorManager.action_types.offensive,
					'working_ships_in_sight', **environment)
			else:
				self.owner.behavior_manager.request_action(BehaviorManager.action_types.idle,
					'no_one_in_sight', **environment)

########NEW FILE########
__FILENAME__ = fleet
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
from collections import defaultdict
from weakref import WeakKeyDictionary

from horizons.component.namedcomponent import NamedComponent
from horizons.ext.enum import Enum
from horizons.scheduler import Scheduler
from horizons.util.python.callback import Callback
from horizons.util.shapes import Circle, Point
from horizons.util.worldobject import WorldObject
from horizons.world.units.movingobject import MoveNotPossible

class Fleet(WorldObject):
	"""
	Fleet object is responsible for moving a group of ship around the map in an ordered manner, that is:
	1. provide a single move callback for a fleet as a whole,
	2. resolve self-blocks in a group of ships
	3. resolve MoveNotPossible exceptions.
	"""

	log = logging.getLogger("ai.aiplayer.fleet")

	# ship states inside a fleet, fleet doesn't care about AIPlayer.shipStates since it doesn't do any reasoning.
	# all fleet cares about is to move ships from A to B.
	shipStates = Enum('idle', 'moving', 'blocked', 'reached')

	RETRY_BLOCKED_TICKS = 16

	# state for a fleet as a whole
	fleetStates = Enum('idle', 'moving')

	def __init__(self, ships, destroy_callback=None):
		super(Fleet, self).__init__()

		assert ships, "request to create a fleet from  %s ships" % (len(ships))
		self.__init(ships, destroy_callback)

	def __init(self, ships, destroy_callback=None):
		self.owner = ships[0].owner

		# dictionary of ship => state
		self._ships = WeakKeyDictionary()
		for ship in ships:
			self._ships[ship] = self.shipStates.idle
			#TODO: @below, this caused errors on one occasion but I was not able to reproduce it.
			ship.add_remove_listener(Callback(self._lost_ship, ship))
		self.state = self.fleetStates.idle
		self.destroy_callback = destroy_callback

	def save(self, db):
		super(Fleet, self).save(db)
		# save the fleet
		# save destination if fleet is moving somewhere
		db("INSERT INTO fleet (fleet_id, owner_id, state_id) VALUES(?, ?, ?)", self.worldid, self.owner.worldid, self.state.index)

		if self.state == self.fleetStates.moving and hasattr(self, 'destination'):
			if isinstance(self.destination, Point):
				x, y = self.destination.x, self.destination.y
				db("UPDATE fleet SET dest_x = ?, dest_y = ? WHERE fleet_id = ?", x, y, self.worldid)
			elif isinstance(self.destination, Circle):
				x, y, radius = self.destination.center.x, self.destination.center.y, self.destination.radius
				db("UPDATE fleet SET dest_x = ?, dest_y = ?, radius = ? WHERE fleet_id = ?", x, y, radius, self.worldid)
			else:
				assert False, "destination is neither a Circle nor a Point: %s" % self.destination.__class__.__name__

		if hasattr(self, "ratio"):
			db("UPDATE fleet SET ratio = ? WHERE fleet_id = ?", self.ratio, self.worldid)

		# save ships
		for ship in self.get_ships():
			db("INSERT INTO fleet_ship (ship_id, fleet_id, state_id) VALUES(?, ?, ?)",
			   ship.worldid, self.worldid, self._ships[ship].index)

	def _load(self, worldid, owner, db, destroy_callback):
		super(Fleet, self).load(db, worldid)
		self.owner = owner
		state_id, dest_x, dest_y, radius, ratio = db("SELECT state_id, dest_x, dest_y, radius, ratio FROM fleet WHERE fleet_id = ?", worldid)[0]

		if radius:  # Circle
			self.destination = Circle(Point(dest_x, dest_y), radius)
		elif dest_x and dest_y:  # Point
			self.destination = Point(dest_x, dest_y)
		else:  # No destination
			pass

		if ratio:
			self.ratio = ratio

		ships_states = [(WorldObject.get_object_by_id(ship_id), self.shipStates[ship_state_id])
		                for ship_id, ship_state_id
		                in db("SELECT ship_id, state_id FROM fleet_ship WHERE fleet_id = ?", worldid)]
		ships = [item[0] for item in ships_states]

		self.__init(ships, destroy_callback)
		self.state = self.fleetStates[state_id]

		for ship, state in ships_states:
			self._ships[ship] = state

		if self.state == self.fleetStates.moving:
			for ship in self.get_ships():
				if self._ships[ship] == self.shipStates.moving:
					ship.add_move_callback(Callback(self._ship_reached, ship))

		if destroy_callback:
			self.destroy_callback = destroy_callback

	@classmethod
	def load(cls, worldid, owner, db, destroy_callback=None):
		self = cls.__new__(cls)
		self._load(worldid, owner, db, destroy_callback)
		return self

	def get_ships(self):
		return self._ships.keys()

	def destroy(self):
		for ship in self._ships.keys():
			ship.remove_remove_listener(self._lost_ship)
		if self.destroy_callback:
			self.destroy_callback()

	def _lost_ship(self, ship):
		"""
		Used when fleet was on the move and one of the ships was killed during that.
		This way fleet has to check whether the target point was reached.
		"""
		if ship in self._ships:
			del self._ships[ship]
		if self.size() == 0:
			self.destroy()
		elif self._was_target_reached():
			self._fleet_reached()

	def _get_ship_states_count(self):
		"""
		Returns Counter about how many ships are in state idle, moving, reached.
		"""
		counter = defaultdict(int)
		for value in self._ships.values():
			counter[value] += 1
		return counter

	def _was_target_reached(self):
		"""
		Checks whether required ratio of ships reached the target.
		"""
		state_counts = self._get_ship_states_count()

		# below: include blocked ships as "reached" as well since there's not much more left to do,
		# and it's better than freezing the whole fleet
		reached = state_counts[self.shipStates.reached] + state_counts[self.shipStates.blocked]
		total = len(self._ships)
		return self.ratio <= float(reached) / total

	def _ship_reached(self, ship):
		"""
		Called when a single ship reaches destination.
		"""
		self.log.debug("Fleet %s, Ship %s reached the destination", self.worldid, ship.get_component(NamedComponent).name)
		self._ships[ship] = self.shipStates.reached
		if self._was_target_reached():
			self._fleet_reached()

	def _fleet_reached(self):
		"""
		Called when whole fleet reaches destination.
		"""
		self.log.debug("Fleet %s reached the destination", self.worldid)
		self.state = self.fleetStates.idle
		for ship in self._ships.keys():
			self._ships[ship] = self.shipStates.idle

		if self.callback:
			self.callback()

	def _move_ship(self, ship, destination, callback):
		# retry ad infinitum. Not the most elegant solution but will do for a while.
		# Idea: mark ship as "blocked" through state and check whether they all are near the destination anyway
		# 1. If they don't make them sail again.
		# 2. If they do, assume they reached the spot.
		try:
			ship.move(destination, callback=callback, blocked_callback=Callback(self._move_ship, ship, destination, callback))
			self._ships[ship] = self.shipStates.moving
		except MoveNotPossible:
			self._ships[ship] = self.shipStates.blocked
			if not self._was_target_reached():
				Scheduler().add_new_object(Callback(self._retry_moving_blocked_ships), self, run_in=self.RETRY_BLOCKED_TICKS)

	def _get_circle_size(self):
		"""
		Destination circle size for movement calls that involve more than one ship.
		"""
		return 10
		#return min(self.size(), 5)

	def _retry_moving_blocked_ships(self):
		if self.state != self.fleetStates.moving:
			return

		for ship in filter(lambda ship: self._ships[ship] == self.shipStates.blocked, self.get_ships()):
			self._move_ship(ship, self.destination, Callback(self._ship_reached, ship))

	def move(self, destination, callback=None, ratio=1.0):
		"""
		Move fleet to a destination.
		@param ratio: what percentage of ships has to reach destination in order for the move to be considered done:
			0.0 - None (not really useful, executes the callback right away)
			0.0001 - effectively ANY ship
			1.0 - ALL of the ships
			0.5 - at least half of the ships
			etc.
		"""
		assert self.size() > 0, "ordered to move a fleet consisting of 0 ships"

		# it's ok to specify single point for a destination only when there's only one ship in a fleet
		if isinstance(destination, Point) and self.size() > 1:
			destination = Circle(destination, self._get_circle_size())

		self.destination = destination
		self.state = self.fleetStates.moving
		self.ratio = ratio

		self.callback = callback

		# This is a good place to do something fancier later like preserving ship formation instead sailing to the same point
		for ship in self._ships.keys():
			self._move_ship(ship, destination, Callback(self._ship_reached, ship))

	def size(self):
		return len(self._ships)

	def __str__(self):
		if hasattr(self, '_ships'):
			ships_str = "\n   " + "\n   ".join(["%s (fleet state:%s)" % (ship.get_component(NamedComponent).name, self._ships[ship]) for ship in self._ships.keys()])
		else:
			ships_str = 'N/A'
		return "Fleet: %s , state: %s, ships:%s" % (self.worldid, (self.state if hasattr(self, 'state') else 'unknown state'), ships_str)

########NEW FILE########
__FILENAME__ = unitmanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import collections
import logging
import weakref
from operator import itemgetter
from horizons.ai.aiplayer.combat.fleet import Fleet
from horizons.component.healthcomponent import HealthComponent
from horizons.component.selectablecomponent import SelectableComponent
from horizons.util.shapes import Circle, Point
from horizons.world.units.fightingship import FightingShip
from horizons.world.units.pirateship import PirateShip


class UnitManager(object):
	"""
	UnitManager objects is responsible for handling units in game.
	1.Grouping combat ships into easy to handle fleets,
	2.Ship filtering.
	3.Distributing ships for missions when requested by other managers.
	"""

	log = logging.getLogger("ai.aiplayer.unitmanager")

	def __init__(self, owner):
		super(UnitManager, self).__init__()
		self.__init(owner)

	def __init(self, owner):
		self.owner = owner
		self.world = owner.world
		self.session = owner.session

		# quickly get fleet assigned to given ship. Ship -> Fleet dictionary
		self.ships = weakref.WeakKeyDictionary()

		# fleets
		self.fleets = set()

		# TODO Convert all filters to not return lambdas, just return the function instead
		self.filtering_rules = collections.namedtuple('FilteringRules', 'not_owned, hostile, ship_type, selectable,'
			'ship_state, not_in_fleet, working, pirate, fighting')(not_owned=self._not_owned_rule, hostile=self._hostile_rule,
			ship_type=self._ship_type_rule, selectable=self._selectable_rule, ship_state=self._ship_state_rule,
			not_in_fleet=self._ship_not_in_fleet, working=self._is_worker, pirate=self._is_pirate, fighting=self._is_fighter)

	def get_ships(self, filtering_rules=None):
		ships = [ship for ship in self.owner.ships]
		if filtering_rules:
			ships = self.filter_ships(ships, filtering_rules)
		return ships

	def remove_unit(self, ship):
		if ship in self.ships:
			del self.ships[ship]

	def save(self, db):
		for fleet in list(self.fleets):
			fleet.save(db)

	def _load(self, db, owner):
		self.__init(owner)
		fleets_id = db("SELECT fleet_id from fleet where owner_id = ?", self.owner.worldid)
		for (fleet_id,) in fleets_id:
			fleet = Fleet.load(fleet_id, owner, db)
			self.fleets.add(fleet)
			for ship in fleet.get_ships():
				self.ships[ship] = fleet

	@classmethod
	def load(cls, db, owner):
		self = cls.__new__(cls)
		self._load(db, owner)
		return self

	def create_fleet(self, ships, destroy_callback=None):
		fleet = Fleet(ships, destroy_callback)
		for ship in ships:
			self.ships[ship] = fleet
		self.fleets.add(fleet)
		return fleet

	def destroy_fleet(self, fleet):
		for ship in fleet.get_ships():
			if ship in self.ships:
				del self.ships[ship]
		if fleet in self.fleets:
			self.fleets.remove(fleet)

	def check_for_dead_fleets(self):
		pass
		#for fleet in self.fleets:
		#	if fleet.size() == 0:
		#		self.destroy_fleet(fleet)

	# Filtering rules
	# Use filter_ships method along with rules defined below:
	# This approach simplifies code (does not aim to make it shorter)
	# Instead having [ship for ship in ships if ... and ... and ... and ...]
	# we have ships = filter_ships(other_ships, [get_hostile_rule(), get_ship_type_rule((PirateShip,)), ... ])
	def _is_fighter(self):
		"""
		Rule stating that ship is a fighting ship, but not a pirate ship.
		"""
		return lambda ship: isinstance(ship, FightingShip) and not isinstance(ship, PirateShip)

	def _is_pirate(self, ship):
		return isinstance(ship, PirateShip)

	def _is_worker(self):
		return lambda ship: ship.name == "Huker"

	def _ship_type_rule(self, ship_types):
		"""
		Rule stating that ship is any of ship_types instances
		"""
		return lambda ship: isinstance(ship, ship_types)

	def _not_owned_rule(self):
		"""
		Rule stating that ship is another player's ship
		"""
		return lambda ship: self.owner != ship.owner

	def _hostile_rule(self):
		"""
		Rule selecting only hostile ships
		"""
		return lambda ship: self.session.world.diplomacy.are_enemies(self.owner, ship.owner)

	def _ship_state_rule(self, state_dict, ship_states):
		"""
		Rule stating that ship has to be in any of given states.
		"""
		if not isinstance(ship_states, collections.Iterable):
			ship_states = (ship_states,)
		return lambda ship: (state_dict[ship] in ship_states)

	def _ship_not_in_fleet(self, ship):
		"""
		Rule stating that ship is not assigned to any of the fleets.
		"""
		return ship not in self.ships

	def _selectable_rule(self):
		"""
		Rule stating that ship has to be selectable.
		"""
		return lambda ship: ship.has_component(SelectableComponent)

	def filter_ships(self, ships, rules):
		"""
		This method allows for flexible ship filtering.
		usage:
		other_ships = unit_manager.filter_ships(other_ships, [_not_owned_rule(), _ship_type_rule([PirateShip])])

		@param ships: iterable of ships to filter
		@type ships: iterable
		@param rules: conditions each ship has to meet (AND)
		@type rules: iterable of lambda(ship) or single lambda(ship)
		"""
		if not isinstance(rules, collections.Iterable):
			rules = (rules,)
		return [ship for ship in ships if all((rule(ship) for rule in rules))]

	@classmethod
	def get_lowest_hp_ship(cls, ship_group):
		return min(ship_group, key=lambda ship: ship.get_component(HealthComponent).health)

	@classmethod
	def get_closest_ships_for_each(cls, ship_group, enemies):
		"""
		For each ship in ship_group return an index of ship from enemies that is the closest to given ship.
		For example ship_group=[A, B, C] , enemies = [X, Y, Z],
		could return [(A,X), (B,Y), (C,Y)] if X was the closest to A and Y was the closest ship to both B and C
		"""
		# TODO: make faster than o(n^2)
		closest = []
		for ship in ship_group:
			distances = ((e, ship.position.distance(e.position)) for e in enemies)
			closest.append((ship, min(distances, key=itemgetter(1))[0]))
		return closest

	@classmethod
	def get_best_targets_for_each(cls, ship_group, enemies):
		"""
		For each ship in ship_group return an index of ship from enemies that is the closest to given ship.
		For example ship_group=[A, B, C] , enemies = [X, Y, Z],
		could return [(A,X), (B,Y), (C,Y)] if X was the closest to A and Y was the closest ship to both B and C
		"""
		pass

	@classmethod
	def calculate_power_balance(cls, ship_group, enemy_ship_group):
		"""
		Calculate power balance between two groups of ships.

		@param ship_group: iterable of ships to be counted as a numerator
		@type ship_group: Iterable
		@param enemy_ship_group: iterable of ships to be counted as denominator
		@type enemy_ship_group: Iterable
		@return: power balance between two ship groups
		@rtype: float
		"""

		assert ship_group, "Request to calculate balance with 0 ships in ship_group"
		assert enemy_ship_group, "Request to calculate balance with 0 ships in enemy_ship_group"

		# dps_multiplier - 4vs2 ships equal 2 times more DPS. Multiply that factor when calculating power balance.
		dps_multiplier = len(ship_group) / float(len(enemy_ship_group))

		self_hp = float(sum((ship.get_component(HealthComponent).health for ship in ship_group)))
		enemy_hp = float(sum((ship.get_component(HealthComponent).health for ship in enemy_ship_group)))

		return (self_hp / enemy_hp) * dps_multiplier

	@classmethod
	def calculate_ship_dispersion(cls, ship_group):
		"""
		There are many solutions to solve the problem of caculating ship_group dispersion efficiently.
		We generally care about computing that in linear time, rather than having accurate numbers in O(n^2).
		We settle for a diagonal of a bounding box for the whole group.
		@return: dispersion factor
		@rtype: float
		"""
		positions = [ship.position for ship in ship_group]
		bottom_left = Point(min(positions, key=lambda position: position.x).x, min(positions, key=lambda position: position.y).y)
		top_right = Point(max(positions, key=lambda position: position.x).x, max(positions, key=lambda position: position.y).y)
		diagonal = bottom_left.distance(top_right)
		return diagonal

	def find_ships_near_group(self, ship_group, radius):
		other_ships_set = set()
		for ship in ship_group:
			nearby_ships = ship.find_nearby_ships(radius)
			# return only other player's ships, since we want that in most cases anyway
			other_ships_set |= set(self.filter_ships(nearby_ships, [self._not_owned_rule(), self._selectable_rule()]))
		return list(other_ships_set)

	def tick(self):
		self.check_for_dead_fleets()

	def get_player_islands(self, player):
		return [settlement.island for settlement in self.session.world.settlements if settlement.owner == player]

	def get_player_ships(self, player):
		return [ship for ship in self.session.world.ships if ship.owner == player and ship.has_component(SelectableComponent)]

	def get_warehouse_point(self, settlement):
		"""
		Return point of given settlement's warehouse.
		Be careful with sailing directly to given warehouse
		"""
		target_point = settlement.warehouse.position
		(x, y) = target_point.get_coordinates()[4]
		return Point(x, y)

	def get_warehouse_area(self, settlement, range=10):
		return Circle(self.get_warehouse_point(settlement), range)

########NEW FILE########
__FILENAME__ = constants
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class BUILD_RESULT:
	OK = 0
	NEED_RESOURCES = 1
	IMPOSSIBLE = 2
	UNKNOWN_ERROR = 3
	ALL_BUILT = 4
	NEED_PARENT_FIRST = 5
	SKIP = 6
	OUT_OF_SETTLEMENT = 7

class GOAL_RESULT:
	SKIP = 0 # just execute the next goal
	BLOCK_SETTLEMENT_RESOURCE_USAGE = 1 # don't execute any goal that uses resources in this settlement
	BLOCK_ALL_BUILDING_ACTIONS = 2 # no more building during this tick

class BUILDING_PURPOSE:
	NONE = 1
	RESERVED = 2
	WAREHOUSE = 3
	ROAD = 4
	FISHER = 5
	LUMBERJACK = 6
	TREE = 7
	STORAGE = 8
	FARM = 9
	POTATO_FIELD = 10
	CLAY_PIT = 11
	BRICKYARD = 12
	PASTURE = 13
	WEAVER = 14
	SUGARCANE_FIELD = 15
	DISTILLERY = 16
	MAIN_SQUARE = 17
	RESIDENCE = 18
	PAVILION = 19
	VILLAGE_SCHOOL = 20
	TAVERN = 21
	MINE = 22
	SMELTERY = 23
	TOOLMAKER = 24
	CHARCOAL_BURNER = 25
	BOAT_BUILDER = 26
	SIGNAL_FIRE = 27
	TOBACCO_FIELD = 28
	TOBACCONIST = 29
	SALT_PONDS = 30
	FIRE_STATION = 31
	DOCTOR = 32
	HERBARY = 33

	purpose_to_building = {}
	building_to_purpose = {}

	@classmethod
	def init_translation(cls):
		cls.purpose_to_building[cls.WAREHOUSE] = BUILDINGS.WAREHOUSE
		cls.purpose_to_building[cls.ROAD] = BUILDINGS.TRAIL
		cls.purpose_to_building[cls.FISHER] = BUILDINGS.FISHER
		cls.purpose_to_building[cls.LUMBERJACK] = BUILDINGS.LUMBERJACK
		cls.purpose_to_building[cls.TREE] = BUILDINGS.TREE
		cls.purpose_to_building[cls.STORAGE] = BUILDINGS.STORAGE
		cls.purpose_to_building[cls.FARM] = BUILDINGS.FARM
		cls.purpose_to_building[cls.POTATO_FIELD] = BUILDINGS.POTATO_FIELD
		cls.purpose_to_building[cls.CLAY_PIT] = BUILDINGS.CLAY_PIT
		cls.purpose_to_building[cls.BRICKYARD] = BUILDINGS.BRICKYARD
		cls.purpose_to_building[cls.PASTURE] = BUILDINGS.PASTURE
		cls.purpose_to_building[cls.WEAVER] = BUILDINGS.WEAVER
		cls.purpose_to_building[cls.SUGARCANE_FIELD] = BUILDINGS.SUGARCANE_FIELD
		cls.purpose_to_building[cls.DISTILLERY] = BUILDINGS.DISTILLERY
		cls.purpose_to_building[cls.MAIN_SQUARE] = BUILDINGS.MAIN_SQUARE
		cls.purpose_to_building[cls.RESIDENCE] = BUILDINGS.RESIDENTIAL
		cls.purpose_to_building[cls.PAVILION] = BUILDINGS.PAVILION
		cls.purpose_to_building[cls.VILLAGE_SCHOOL] = BUILDINGS.VILLAGE_SCHOOL
		cls.purpose_to_building[cls.TAVERN] = BUILDINGS.TAVERN
		cls.purpose_to_building[cls.MINE] = BUILDINGS.MINE
		cls.purpose_to_building[cls.SMELTERY] = BUILDINGS.SMELTERY
		cls.purpose_to_building[cls.TOOLMAKER] = BUILDINGS.TOOLMAKER
		cls.purpose_to_building[cls.CHARCOAL_BURNER] = BUILDINGS.CHARCOAL_BURNER
		cls.purpose_to_building[cls.BOAT_BUILDER] = BUILDINGS.BOAT_BUILDER
		cls.purpose_to_building[cls.SIGNAL_FIRE] = BUILDINGS.SIGNAL_FIRE
		cls.purpose_to_building[cls.TOBACCO_FIELD] = BUILDINGS.TOBACCO_FIELD
		cls.purpose_to_building[cls.TOBACCONIST] = BUILDINGS.TOBACCONIST
		cls.purpose_to_building[cls.SALT_PONDS] = BUILDINGS.SALT_PONDS
		cls.purpose_to_building[cls.FIRE_STATION] = BUILDINGS.FIRE_STATION
		cls.purpose_to_building[cls.DOCTOR] = BUILDINGS.DOCTOR
		cls.purpose_to_building[cls.HERBARY] = BUILDINGS.HERBARY

		for purpose, building_id in cls.purpose_to_building.iteritems():
			cls.building_to_purpose[building_id] = purpose

	@classmethod
	def get_building(cls, purpose):
		return cls.purpose_to_building[purpose]

	@classmethod
	def get_purpose(cls, building_id):
		return cls.purpose_to_building[building_id]

BUILDING_PURPOSE.init_translation()

decorators.bind_all(BUILD_RESULT)
decorators.bind_all(GOAL_RESULT)
decorators.bind_all(BUILDING_PURPOSE)

########NEW FILE########
__FILENAME__ = boatbuilder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class BoatBuilderGoal(SettlementGoal):
	def get_personality_name(self):
		return 'BoatBuilderGoal'

	@property
	def active(self):
		return super(BoatBuilderGoal, self).active and not self.owner.count_buildings(BUILDINGS.BOAT_BUILDER)

	def execute(self):
		result = AbstractBuilding.buildings[BUILDINGS.BOAT_BUILDER].build(self.settlement_manager, None)[0]
		self._log_generic_build_result(result, 'boat builder')
		return self._translate_build_result(result)

decorators.bind_all(BoatBuilderGoal)

########NEW FILE########
__FILENAME__ = combatship
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class CombatShipGoal(SettlementGoal):
	def get_personality_name(self):
		return 'CombatShipGoal'

	@property
	def active(self):
		return super(CombatShipGoal, self).active \
			and self.owner.count_buildings(BUILDINGS.BOAT_BUILDER) \
			and self.owner.need_more_combat_ships \
			and not self.owner.unit_builder.num_ships_being_built

	def execute(self):
		self.settlement_manager.log.info('%s start building frigate', self)
		self.owner.unit_builder.build_combat_ship()

decorators.bind_all(CombatShipGoal)

########NEW FILE########
__FILENAME__ = depositcoverage
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.ai.aiplayer.constants import BUILD_RESULT, BUILDING_PURPOSE
from horizons.constants import BUILDINGS, RES
from horizons.util.python import decorators
from horizons.entities import Entities

class DepositCoverageGoal(SettlementGoal):
	"""Build storage tents to get a resource deposit inside the settlement."""

	_deposit_resource_id = None # the resource that has to be in the resource deposit

	def _have_reachable_deposit(self, resource_id):
		"""Returns True if there is a resource deposit outside the settlement that is not owned by another player."""
		for tile in self.land_manager.resource_deposits[resource_id]:
			if tile.object.settlement is None:
				return True
		return False

	@property
	def active(self):
		return super(DepositCoverageGoal, self).active and not self.production_builder.have_deposit(self._deposit_resource_id) and \
			self._have_reachable_deposit(self._deposit_resource_id)

	def _improve_deposit_coverage(self):
		"""Get closer to having a resource deposit in the settlement."""
		if not self.production_builder.have_resources(BUILDINGS.STORAGE):
			return BUILD_RESULT.NEED_RESOURCES

		available_deposits = []
		for tile in self.land_manager.resource_deposits[self._deposit_resource_id]:
			if tile.object.settlement is None:
				available_deposits.append(tile.object)
		if not available_deposits:
			return BUILD_RESULT.IMPOSSIBLE

		storage_class = Entities.buildings[BUILDINGS.STORAGE]
		storage_spots = self.island.terrain_cache.get_buildability_intersection(storage_class.terrain_type, storage_class.size,
		    self.settlement.buildability_cache, self.production_builder.buildability_cache)

		options = []
		for coords in sorted(storage_spots):
			builder = BasicBuilder.create(BUILDINGS.STORAGE, coords, 0)

			min_distance = None
			for building in available_deposits:
				distance = building.position.distance(builder.position)
				if min_distance is None or min_distance > distance:
					min_distance = distance

			alignment = 0
			for tile in self.production_builder.iter_neighbor_tiles(builder.position):
				if tile is None:
					continue
				coords = (tile.x, tile.y)
				if coords not in self.production_builder.plan or self.production_builder.plan[coords][0] != BUILDING_PURPOSE.NONE:
					alignment += 1

			value = min_distance - alignment * self.personality.alignment_coefficient
			options.append((-value, builder))

		return self.production_builder.build_best_option(options, BUILDING_PURPOSE.STORAGE)

	def execute(self):
		result = self._improve_deposit_coverage()
		self._log_generic_build_result(result, 'deposit coverage storage')
		return self._translate_build_result(result)

class ClayDepositCoverageGoal(DepositCoverageGoal):
	_deposit_resource_id = RES.RAW_CLAY

	def get_personality_name(self):
		return 'ClayDepositCoverageGoal'

class MountainCoverageGoal(DepositCoverageGoal):
	_deposit_resource_id = RES.RAW_IRON

	def get_personality_name(self):
		return 'MountainCoverageGoal'

decorators.bind_all(DepositCoverageGoal)
decorators.bind_all(ClayDepositCoverageGoal)
decorators.bind_all(MountainCoverageGoal)

########NEW FILE########
__FILENAME__ = doctor
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.constants import BUILDINGS, RES
from horizons.util.python import decorators

class DoctorGoal(SettlementGoal):
	def get_personality_name(self):
		return 'DoctorGoal'

	@property
	def can_be_activated(self):
		return super(DoctorGoal, self).can_be_activated and self.settlement_manager.get_resource_production(RES.BRICKS) > 0

	@property
	def active(self):
		return super(DoctorGoal, self).active and self._is_active

	def update(self):
		super(DoctorGoal, self).update()
		if self.can_be_activated:
			self._is_active = any(AbstractBuilding.buildings[BUILDINGS.DOCTOR].iter_potential_locations(self.settlement_manager))
		else:
			self._is_active = False

	def execute(self):
		result = AbstractBuilding.buildings[BUILDINGS.DOCTOR].build(self.settlement_manager, None)[0]
		self._log_generic_build_result(result, 'doctor')
		return self._translate_build_result(result)

decorators.bind_all(DoctorGoal)

########NEW FILE########
__FILENAME__ = donothing
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.goal import Goal
from horizons.ai.aiplayer.constants import GOAL_RESULT
from horizons.util.python import decorators

class DoNothingGoal(Goal):
	"""This goal makes the AI not do anything during a tick."""

	def get_personality_name(self):
		return 'DoNothingGoal'

	@property
	def priority(self):
		return self._priority

	@property
	def active(self):
		return super(DoNothingGoal, self).active and self._is_active

	def update(self):
		""" whether to do nothing and if so then how important it is """
		if self.owner.session.random.random() >= self.personality.likelihood:
			# don't be lazy
			self._is_active = False
			self._priority = 0
		else:
			# be lazy
			self._is_active = True
			self._priority = self.owner.session.random.gauss(self.personality.default_priority, self.personality.priority_variance)

	def execute(self):
		# do nothing
		return GOAL_RESULT.BLOCK_ALL_BUILDING_ACTIONS

decorators.bind_all(DoNothingGoal)

########NEW FILE########
__FILENAME__ = enlargecollectorarea
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from collections import deque, defaultdict

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.constants import BUILD_RESULT, BUILDING_PURPOSE
from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.util.python import decorators
from horizons.constants import BUILDINGS
from horizons.util.shapes import Rect
from horizons.entities import Entities

class EnlargeCollectorAreaGoal(SettlementGoal):
	"""Enlarge the area of the island covered by collectors."""
	_radius_offsets = None

	@classmethod
	def _init_radius_offsets(cls):
		building_class = Entities.buildings[BUILDINGS.STORAGE]
		size = building_class.size
		assert size[0] == size[1]
		rect = Rect.init_from_topleft_and_size(0, 0, size[0], size[1])

		cls._radius_offsets = []
		for coords in rect.get_radius_coordinates(building_class.radius):
			cls._radius_offsets.append(coords)

	def get_personality_name(self):
		return 'EnlargeCollectorAreaGoal'

	@property
	def active(self):
		return super(EnlargeCollectorAreaGoal, self).active and self._is_active

	def update(self):
		available_squares, total_squares = self.settlement_manager.production_builder.count_available_squares(3, self.personality.max_interesting_collector_area)
		self.log.info('%s collector area: %d of %d useable', self, available_squares, total_squares)
		self._is_active = available_squares < min(self.personality.max_interesting_collector_area, total_squares - self.personality.max_collector_area_unreachable)

	def _enlarge_collector_area(self):
		if not self.production_builder.have_resources(BUILDINGS.STORAGE):
			return BUILD_RESULT.NEED_RESOURCES

		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)] # valid moves for collectors
		collector_area = self.production_builder.get_collector_area()
		coastline = self.land_manager.coastline

		# area_label contains free tiles in the production area and all road tiles
		area_label = dict.fromkeys(self.land_manager.roads) # {(x, y): area_number, ...}
		for coords, (purpose, _) in self.production_builder.plan.iteritems():
			if coords not in coastline and purpose == BUILDING_PURPOSE.NONE:
				area_label[coords] = None

		areas = 0
		for coords in collector_area:
			assert coords not in coastline
			if coords in area_label and area_label[coords] is not None:
				continue

			queue = deque([coords])
			while queue:
				x, y = queue.popleft()
				for dx, dy in moves:
					coords2 = (x + dx, y + dy)
					if coords2 in area_label and area_label[coords2] is None:
						area_label[coords2] = areas
						queue.append(coords2)
			areas += 1

		coords_set_by_area = defaultdict(set)
		for coords, area_number in area_label.iteritems():
			if coords in self.production_builder.plan and self.production_builder.plan[coords][0] == BUILDING_PURPOSE.NONE and coords not in collector_area:
				coords_set_by_area[area_number].add(coords)

		storage_class = Entities.buildings[BUILDINGS.STORAGE]
		storage_spots = self.island.terrain_cache.get_buildability_intersection(storage_class.terrain_type,
			storage_class.size, self.settlement.buildability_cache, self.production_builder.buildability_cache)
		storage_surrounding_offsets = Rect.get_surrounding_offsets(storage_class.size)

		options = []
		num_offsets = int(len(self._radius_offsets) * self.personality.overlap_precision)
		radius_offsets = self.session.random.sample(self._radius_offsets, num_offsets)
		for coords in sorted(storage_spots):
			if coords not in area_label:
				continue
			x, y = coords

			area_number = area_label[coords]
			area_coords_set = coords_set_by_area[area_number]
			useful_area = 0
			for dx, dy in radius_offsets:
				coords = (x + dx, y + dy)
				if coords in area_coords_set:
					useful_area += 1
			if not useful_area:
				continue

			alignment = 1
			builder = BasicBuilder.create(BUILDINGS.STORAGE, (x, y), 0)
			for (dx, dy) in storage_surrounding_offsets:
				coords = (x + dx, y + dy)
				if coords in coastline or coords not in self.production_builder.plan or self.production_builder.plan[coords][0] != BUILDING_PURPOSE.NONE:
					alignment += 1

			value = useful_area + alignment * self.personality.alignment_coefficient
			options.append((value, builder))

		if options:
			return self.production_builder.build_best_option(options, BUILDING_PURPOSE.STORAGE)

		# enlarge the settlement area instead since just enlarging the collector area is impossible
		if self.village_builder.tent_queue:
			tent_size = Entities.buildings[BUILDINGS.RESIDENTIAL].size
			tent_radius = Entities.buildings[BUILDINGS.RESIDENTIAL].radius
			best_coords = None
			best_area = 0

			for x, y in self.village_builder.tent_queue:
				new_area = 0
				for coords in Rect.init_from_topleft_and_size(x, y, tent_size[0], tent_size[1]).get_radius_coordinates(tent_radius):
					if coords in area_label and coords not in self.land_manager.roads and coords not in collector_area:
						new_area += 1
				if new_area > best_area:
					best_coords = (x, y)
					best_area = new_area
			if best_coords is not None:
				return self.village_builder.extend_settlement_with_tent(Rect.init_from_topleft_and_size_tuples(best_coords, tent_size))
		return BUILD_RESULT.IMPOSSIBLE

	def execute(self):
		if self._radius_offsets is None:
			self._init_radius_offsets()

		result = self._enlarge_collector_area()
		self._log_generic_build_result(result, 'storage coverage building')
		return self._translate_build_result(result)

decorators.bind_all(EnlargeCollectorAreaGoal)

########NEW FILE########
__FILENAME__ = feederchaingoal
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.goal.productionchaingoal import ProductionChainGoal
from horizons.constants import RES
from horizons.util.python import decorators

class FeederChainGoal(ProductionChainGoal):
	"""
	Objects of this class are used for production chains on feeder islands
	The update call reserved the production for the (non-existent) settlement so it can't be transferred.
	The late_update call declares that the settlement doesn't need it after all thus freeing it.
	TODO: make that a single explicit action: right now import quotas are deleted by the first step which can make it look like less resources can be imported.
	"""

	def __init__(self, settlement_manager, resource_id, name):
		super(FeederChainGoal, self).__init__(settlement_manager, resource_id, name)
		self._may_import = False
		self._feeder_personality = self.owner.personality_manager.get('FeederChainGoal')

	@property
	def priority(self):
		return super(FeederChainGoal, self).priority + self._feeder_personality.extra_priority

	def execute(self):
		self.chain.reserve(self._needed_amount, self._may_import)
		result = super(FeederChainGoal, self).execute()
		self.chain.reserve(0, False)
		return result

	def _update_needed_amount(self):
		self._needed_amount = self.settlement_manager.get_ideal_production_level(self.chain.resource_id)

	def update(self):
		super(FeederChainGoal, self).update()
		self.chain.reserve(0, False)

class FeederFoodGoal(FeederChainGoal):
	def __init__(self, settlement_manager):
		super(FeederFoodGoal, self).__init__(settlement_manager, RES.FOOD, 'food producer')

	def get_personality_name(self):
		return 'FoodGoal'

class FeederTextileGoal(FeederChainGoal):
	def __init__(self, settlement_manager):
		super(FeederTextileGoal, self).__init__(settlement_manager, RES.TEXTILE, 'textile producer')

	def get_personality_name(self):
		return 'TextileGoal'

class FeederLiquorGoal(FeederChainGoal):
	def __init__(self, settlement_manager):
		super(FeederLiquorGoal, self).__init__(settlement_manager, RES.LIQUOR, 'liquor producer')

	def get_personality_name(self):
		return 'LiquorGoal'

	@property
	def can_be_activated(self):
		return super(FeederLiquorGoal, self).can_be_activated and self.settlement_manager.get_resource_production(RES.BRICKS) > 0

class FeederTobaccoProductsGoal(FeederChainGoal):
	def __init__(self, settlement_manager):
		super(FeederTobaccoProductsGoal, self).__init__(settlement_manager, RES.TOBACCO_PRODUCTS, 'tobacco products producer')

	def get_personality_name(self):
		return 'FeederTobaccoProductsGoal'

	@property
	def can_be_activated(self):
		return super(FeederTobaccoProductsGoal, self).can_be_activated and self.settlement_manager.get_resource_production(RES.BRICKS) > 0

class FeederMedicalProductsGoal(FeederChainGoal):
	def __init__(self, settlement_manager):
		super(FeederMedicalProductsGoal, self).__init__(settlement_manager, RES.MEDICAL_HERBS, 'medical herbs producer')

	def get_personality_name(self):
		return 'FeederMedicalProductsGoal'

	@property
	def can_be_activated(self):
		return super(FeederMedicalProductsGoal, self).can_be_activated and self.settlement_manager.get_resource_production(RES.BRICKS) > 0

class FeederSaltGoal(FeederChainGoal):
	def __init__(self, settlement_manager):
		super(FeederSaltGoal, self).__init__(settlement_manager, RES.SALT, 'salt producer')

	def get_personality_name(self):
		return 'FeederSaltGoal'

decorators.bind_all(FeederChainGoal)
decorators.bind_all(FeederFoodGoal)
decorators.bind_all(FeederTextileGoal)
decorators.bind_all(FeederLiquorGoal)
decorators.bind_all(FeederTobaccoProductsGoal)
decorators.bind_all(FeederMedicalProductsGoal)
decorators.bind_all(FeederSaltGoal)

########NEW FILE########
__FILENAME__ = firestation
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.constants import BUILDINGS, RES
from horizons.util.python import decorators

class FireStationGoal(SettlementGoal):
	def get_personality_name(self):
		return 'FireStationGoal'

	@property
	def can_be_activated(self):
		return super(FireStationGoal, self).can_be_activated and self.settlement_manager.get_resource_production(RES.BRICKS) > 0

	@property
	def active(self):
		return super(FireStationGoal, self).active and self._is_active

	def update(self):
		super(FireStationGoal, self).update()
		if self.can_be_activated:
			self._is_active = any(AbstractBuilding.buildings[BUILDINGS.FIRE_STATION].iter_potential_locations(self.settlement_manager))
		else:
			self._is_active = False

	def execute(self):
		result = AbstractBuilding.buildings[BUILDINGS.FIRE_STATION].build(self.settlement_manager, None)[0]
		self._log_generic_build_result(result, 'fire station')
		return self._translate_build_result(result)

decorators.bind_all(FireStationGoal)

########NEW FILE########
__FILENAME__ = foundfeederisland
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.ai.aiplayer.constants import GOAL_RESULT
from horizons.util.python import decorators

class FoundFeederIslandGoal(SettlementGoal):
	def get_personality_name(self):
		return 'FoundFeederIslandGoal'

	def _need_feeder_island(self):
		return self.production_builder.count_available_squares(3, self.personality.feeder_island_requirement_cutoff)[1] < self.personality.feeder_island_requirement_cutoff

	def _have_feeder_island(self):
		for settlement_manager in self.owner.settlement_managers:
			if settlement_manager.feeder_island:
				available_squares = settlement_manager.production_builder.count_available_squares(3, self.personality.usable_feeder_island_cutoff)[1]
				if available_squares >= self.personality.usable_feeder_island_cutoff:
					return True
		return False

	@property
	def active(self):
		return super(FoundFeederIslandGoal, self).active and self._need_feeder_island() and not self._have_feeder_island() and \
			self.owner.settlement_founder.can_found_feeder_island()

	def execute(self):
		self.settlement_manager.log.info('%s waiting for a feeder islands to be founded', self)
		self.owner.settlement_founder.found_feeder_island()
		return GOAL_RESULT.BLOCK_SETTLEMENT_RESOURCE_USAGE

decorators.bind_all(FoundFeederIslandGoal)

########NEW FILE########
__FILENAME__ = improvecollectorcoverage
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from collections import deque

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.roadplanner import RoadPlanner
from horizons.ai.aiplayer.constants import BUILD_RESULT, BUILDING_PURPOSE
from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.util.python import decorators
from horizons.constants import BUILDINGS, RES, PRODUCTION
from horizons.scheduler import Scheduler
from horizons.util.shapes import Rect
from horizons.entities import Entities
from horizons.component.storagecomponent import StorageComponent
from horizons.world.production.producer import Producer

class ImproveCollectorCoverageGoal(SettlementGoal):
	def get_personality_name(self):
		return 'ImproveCollectorCoverageGoal'

	@property
	def active(self):
		return super(ImproveCollectorCoverageGoal, self).active and self._is_active

	def _get_problematic_collector_coverage_buildings(self):
		problematic_buildings = {}
		for building in self.production_builder.production_buildings:
			for production in building.get_component(Producer).get_productions():
				if production.get_age() < 1.5 * PRODUCTION.STATISTICAL_WINDOW:
					continue
				history = production.get_state_history_times(False)
				# take paused time into account because the AI pauses the production when the output storage is full
				amount_paused = history[PRODUCTION.STATES.inventory_full.index] + history[PRODUCTION.STATES.paused.index]
				if amount_paused < self.personality.min_bad_collector_coverage:
					continue
				for resource_id in production.get_produced_resources():
					if self.settlement.get_component(StorageComponent).inventory.get_free_space_for(resource_id) > self.personality.min_free_space:
						# this is actually problematic
						problematic_buildings[building.worldid] = building
		return problematic_buildings.values()

	def update(self):
		if self.production_builder.last_collector_improvement_road + self.personality.collector_improvement_road_expires > Scheduler().cur_tick:
			# skip this goal leave time for the collectors to do their work
			self._problematic_buildings = None
			self._is_active = False
		else:
			self._problematic_buildings = self._get_problematic_collector_coverage_buildings()
			self._is_active = bool(self._problematic_buildings)

	def _build_extra_road_connection(self, building, collector_building):
		collector_coords = set(coords for coords in self.production_builder.iter_possible_road_coords(collector_building.position, collector_building.position))
		destination_coords = set(coords for coords in self.production_builder.iter_possible_road_coords(building.loading_area, building.position))
		pos = building.loading_area
		beacon = Rect.init_from_borders(pos.left - 1, pos.top - 1, pos.right + 1, pos.bottom + 1)

		path = RoadPlanner()(self.owner.personality_manager.get('RoadPlanner'), collector_coords,
			destination_coords, beacon, self.production_builder.get_path_nodes())
		if path is None:
			return BUILD_RESULT.IMPOSSIBLE

		cost = self.production_builder.get_road_cost(path)
		for resource_id, amount in cost.iteritems():
			if resource_id == RES.GOLD:
				if self.owner.get_component(StorageComponent).inventory[resource_id] < amount:
					return BUILD_RESULT.NEED_RESOURCES
			elif self.settlement.get_component(StorageComponent).inventory[resource_id] < amount:
				return BUILD_RESULT.NEED_RESOURCES
		return BUILD_RESULT.OK if self.production_builder.build_road(path) else BUILD_RESULT.UNKNOWN_ERROR

	def _build_extra_road(self):
		"""Build an extra road between a storage building and a producer building."""
		current_tick = Scheduler().cur_tick

		# which collectors could have actual unused capacity?
		usable_collectors = []
		for building in self.production_builder.collector_buildings:
			if building.get_utilization_history_length() < 1000 or building.get_collector_utilization() < self.personality.max_good_collector_utilization:
				usable_collectors.append(building)

		# find possible problematic building to usable collector links
		potential_road_connections = []
		for building in self._problematic_buildings:
			for collector_building in usable_collectors:
				distance = building.loading_area.distance(collector_building.position)
				if distance > collector_building.radius:
					continue # out of range anyway
				# TODO: check whether the link already exists
				potential_road_connections.append((distance * collector_building.get_collector_utilization(), building, collector_building))

		# try the best link from the above list
		for _, building, collector_building in sorted(potential_road_connections):
			result = self._build_extra_road_connection(building, collector_building)
			if result == BUILD_RESULT.OK:
				self.production_builder.last_collector_improvement_road = current_tick
				self.log.info('%s connected %s at %d, %d with %s at %d, %d', self, building.name, building.position.origin.x,
					building.position.origin.y, collector_building.name, collector_building.position.origin.x, collector_building.position.origin.y)
			return result
		self.log.info('%s found no good way to connect buildings that need more collectors to existing collector buildings', self)
		return BUILD_RESULT.IMPOSSIBLE

	def _build_extra_storage(self):
		"""Build an extra storage tent to improve collector coverage."""
		if not self.production_builder.have_resources(BUILDINGS.STORAGE):
			return BUILD_RESULT.NEED_RESOURCES

		reachable = dict.fromkeys(self.land_manager.roads) # {(x, y): [(building worldid, distance), ...], ...}
		for coords, (purpose, _) in self.production_builder.plan.iteritems():
			if purpose == BUILDING_PURPOSE.NONE:
				reachable[coords] = []
		for key in reachable:
			if reachable[key] is None:
				reachable[key] = []

		storage_radius = Entities.buildings[BUILDINGS.STORAGE].radius
		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		for building in self._problematic_buildings:
			distance = dict.fromkeys(reachable)
			queue = deque()
			for coords in self.production_builder.iter_possible_road_coords(building.loading_area, building.position):
				if coords in distance:
					distance[coords] = 0
					queue.append(coords)

			while queue:
				x, y = queue.popleft()
				for dx, dy in moves:
					coords2 = (x + dx, y + dy)
					if coords2 in distance and distance[coords2] is None:
						distance[coords2] = distance[(x, y)] + 1
						queue.append(coords2)

			for coords, dist in distance.iteritems():
				if dist is not None:
					if building.loading_area.distance(coords) <= storage_radius:
						reachable[coords].append((building.worldid, dist))

		options = []
		storage_class = Entities.buildings[BUILDINGS.STORAGE]
		storage_spots = self.island.terrain_cache.get_buildability_intersection(storage_class.terrain_type,
		    storage_class.size, self.settlement.buildability_cache, self.production_builder.buildability_cache)
		for coords, building_distances in reachable.iteritems():
			if coords not in storage_spots:
				continue
			builder = BasicBuilder.create(BUILDINGS.STORAGE, coords, 0)

			actual_distance = {}
			for coords in builder.position.tuple_iter():
				for building_worldid, distance in reachable[coords]:
					if building_worldid not in actual_distance or actual_distance[building_worldid] > distance:
						actual_distance[building_worldid] = distance
			if not actual_distance:
				continue

			usefulness = min(len(actual_distance), self.personality.max_reasonably_served_buildings)
			for distance in actual_distance.itervalues():
				usefulness += 1.0 / (distance + self.personality.collector_extra_distance)

			alignment = 1
			for tile in self.production_builder.iter_neighbor_tiles(builder.position):
				coords = (tile.x, tile.y)
				if coords not in self.production_builder.plan or self.production_builder.plan[coords][0] != BUILDING_PURPOSE.NONE:
					alignment += 1

			value = usefulness + alignment * self.personality.alignment_coefficient
			options.append((value, builder))

		return self.production_builder.build_best_option(options, BUILDING_PURPOSE.STORAGE)

	def execute(self):
		result = self._build_extra_road()
		if result == BUILD_RESULT.IMPOSSIBLE:
			if self.production_builder.last_collector_improvement_storage + self.personality.collector_improvement_storage_expires <= Scheduler().cur_tick:
				result = self._build_extra_storage()
				if result == BUILD_RESULT.OK:
					self.production_builder.last_collector_improvement_storage = Scheduler().cur_tick
		self._log_generic_build_result(result, 'storage')
		return self._translate_build_result(result)

decorators.bind_all(ImproveCollectorCoverageGoal)

########NEW FILE########
__FILENAME__ = productionchaingoal
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.ai.aiplayer.constants import BUILD_RESULT
from horizons.constants import RES
from horizons.util.python import decorators

class ProductionChainGoal(SettlementGoal):
	def __init__(self, settlement_manager, resource_id, name):
		super(ProductionChainGoal, self).__init__(settlement_manager)
		self.chain = settlement_manager.production_chain[resource_id]
		self.name = name
		self._may_import = True

	@property
	def active(self):
		return super(ProductionChainGoal, self).active and self._is_active

	def execute(self):
		result = self.chain.build(self._needed_amount)
		if result != BUILD_RESULT.ALL_BUILT and result != BUILD_RESULT.SKIP:
			self._log_generic_build_result(result, self.name)
		return self._translate_build_result(result)

	def _update_needed_amount(self):
		self._needed_amount = self.settlement_manager.get_resource_production_requirement(self.chain.resource_id) * \
			self.settlement_manager.personality.production_level_multiplier

	def update(self):
		super(ProductionChainGoal, self).update()
		if self.can_be_activated:
			self._update_needed_amount()
			self._current_amount = self.chain.reserve(self._needed_amount, self._may_import)
			self._is_active = self.chain.need_to_build_more_buildings(self._needed_amount)
		else:
			self._is_active = False

class FaithGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(FaithGoal, self).__init__(settlement_manager, RES.FAITH, 'pavilion')

	def get_personality_name(self):
		return 'FaithGoal'

class TextileGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(TextileGoal, self).__init__(settlement_manager, RES.TEXTILE, 'textile producer')

	def get_personality_name(self):
		return 'TextileGoal'

class BricksGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(BricksGoal, self).__init__(settlement_manager, RES.BRICKS, 'bricks producer')

	def get_personality_name(self):
		return 'BricksGoal'

class EducationGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(EducationGoal, self).__init__(settlement_manager, RES.EDUCATION, 'school')

	def get_personality_name(self):
		return 'EducationGoal'

	@property
	def can_be_activated(self):
		return super(EducationGoal, self).can_be_activated and self.settlement_manager.get_resource_production(RES.BRICKS) > 0

class GetTogetherGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(GetTogetherGoal, self).__init__(settlement_manager, RES.GET_TOGETHER, 'get-together producer')

	def get_personality_name(self):
		return 'GetTogetherGoal'

	@property
	def can_be_activated(self):
		return super(GetTogetherGoal, self).can_be_activated and self.settlement_manager.get_resource_production(RES.BRICKS) > 0

class ToolsGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(ToolsGoal, self).__init__(settlement_manager, RES.TOOLS, 'tools producer')

	def get_personality_name(self):
		return 'ToolsGoal'

	@property
	def can_be_activated(self):
		return super(ToolsGoal, self).can_be_activated \
		   and self.production_builder.have_deposit(RES.RAW_IRON) \
		   and self.settlement_manager.get_resource_production(RES.BRICKS) > 0

class BoardsGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(BoardsGoal, self).__init__(settlement_manager, RES.BOARDS, 'boards producer')

	def get_personality_name(self):
		return 'BoardsGoal'

class FoodGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(FoodGoal, self).__init__(settlement_manager, RES.FOOD, 'food producer')

	def get_personality_name(self):
		return 'FoodGoal'

class CommunityGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(CommunityGoal, self).__init__(settlement_manager, RES.COMMUNITY, 'main square')

	def get_personality_name(self):
		return 'CommunityGoal'

class TobaccoProductsGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(TobaccoProductsGoal, self).__init__(settlement_manager, RES.TOBACCO_PRODUCTS, 'tobacco products producer')

	def get_personality_name(self):
		return 'TobaccoProductsGoal'

class MedicalHerbsProductsGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(MedicalHerbsProductsGoal, self).__init__(settlement_manager, RES.MEDICAL_HERBS, 'medical herbs products producer')

	def get_personality_name(self):
		return 'MedicalHerbsProductsGoal'

class SaltGoal(ProductionChainGoal):
	def __init__(self, settlement_manager):
		super(SaltGoal, self).__init__(settlement_manager, RES.SALT, 'salt producer')

	def get_personality_name(self):
		return 'SaltGoal'

decorators.bind_all(ProductionChainGoal)
decorators.bind_all(FaithGoal)
decorators.bind_all(TextileGoal)
decorators.bind_all(BricksGoal)
decorators.bind_all(EducationGoal)
decorators.bind_all(GetTogetherGoal)
decorators.bind_all(ToolsGoal)
decorators.bind_all(BoardsGoal)
decorators.bind_all(FoodGoal)
decorators.bind_all(CommunityGoal)
decorators.bind_all(TobaccoProductsGoal)
decorators.bind_all(SaltGoal)

########NEW FILE########
__FILENAME__ = settlementgoal
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.goal import Goal
from horizons.ai.aiplayer.constants import BUILD_RESULT
from horizons.util.python import decorators
from horizons.constants import BUILDINGS
from horizons.component.namedcomponent import NamedComponent

class SettlementGoal(Goal):
	"""
	An object of this class describes a goal that a settlement of an AI player attempts to fulfil.
	"""

	def __init__(self, settlement_manager):
		super(SettlementGoal, self).__init__(settlement_manager.owner)
		self.settlement_manager = settlement_manager
		self.land_manager = settlement_manager.land_manager
		self.production_builder = settlement_manager.production_builder
		self.village_builder = settlement_manager.village_builder
		self.settlement = settlement_manager.settlement
		self.island = settlement_manager.island
		self.session = settlement_manager.session

	@property
	def can_be_activated(self):
		return super(SettlementGoal, self).can_be_activated and self.personality.residences_required <= self.settlement.count_buildings(BUILDINGS.RESIDENTIAL)

	def __str__(self):
		return super(SettlementGoal, self).__str__() + ', ' + self.settlement_manager.settlement.get_component(NamedComponent).name

	def _log_generic_build_result(self, result, name):
		if result == BUILD_RESULT.OK:
			self.log.info('%s built a %s', self, name)
		elif result == BUILD_RESULT.NEED_RESOURCES:
			self.log.info('%s not enough materials to build a %s', self, name)
		elif result == BUILD_RESULT.SKIP:
			self.log.info('%s skipped building a %s', self, name)
		else:
			self.log.info('%s failed to build a %s (%d)', self, name, result)

decorators.bind_all(SettlementGoal)

########NEW FILE########
__FILENAME__ = signalfire
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class SignalFireGoal(SettlementGoal):
	def get_personality_name(self):
		return 'SignalFireGoal'

	@property
	def active(self):
		return super(SignalFireGoal, self).active and not self.settlement.count_buildings(BUILDINGS.SIGNAL_FIRE)

	def execute(self):
		result = AbstractBuilding.buildings[BUILDINGS.SIGNAL_FIRE].build(self.settlement_manager, None)[0]
		self._log_generic_build_result(result, 'signal fire')
		return self._translate_build_result(result)

decorators.bind_all(SignalFireGoal)

########NEW FILE########
__FILENAME__ = storagespace
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.goal.improvecollectorcoverage import ImproveCollectorCoverageGoal
from horizons.util.python import decorators
from horizons.constants import RES
from horizons.component.storagecomponent import StorageComponent

class StorageSpaceGoal(ImproveCollectorCoverageGoal):
	def get_personality_name(self):
		return 'StorageSpaceGoal'

	def _need_more_storage(self):
		limit = self.settlement.get_component(StorageComponent).inventory.get_limit(RES.FOOD)
		if limit >= self.personality.max_required_storage_space:
			return False
		important_resources = [RES.FOOD, RES.TEXTILE, RES.LIQUOR]
		for resource_id in important_resources:
			if self.settlement.get_component(StorageComponent).inventory[resource_id] + self.personality.full_storage_threshold >= limit:
				return True
		return False

	def update(self):
		if self._need_more_storage():
			super(StorageSpaceGoal, self).update()
			if not self._is_active:
				self._is_active = True
				self._problematic_buildings = self.production_builder.production_buildings
		else:
			self._is_active = False

	def execute(self):
		result = self._build_extra_storage()
		self._log_generic_build_result(result, 'storage space provider')
		return self._translate_build_result(result)

decorators.bind_all(StorageSpaceGoal)

########NEW FILE########
__FILENAME__ = tent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.util.python import decorators

class TentGoal(SettlementGoal):
	def get_personality_name(self):
		return 'TentGoal'

	@property
	def active(self):
		return super(TentGoal, self).active and len(self.settlement_manager.village_builder.tent_queue) > 0

	def execute(self):
		result = self.settlement_manager.village_builder.build_tent()
		self._log_generic_build_result(result, 'tent')
		return self._translate_build_result(result)

decorators.bind_all(TentGoal)

########NEW FILE########
__FILENAME__ = tradingship
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.goal.settlementgoal import SettlementGoal
from horizons.constants import BUILDINGS
from horizons.util.python import decorators

class TradingShipGoal(SettlementGoal):
	def get_personality_name(self):
		return 'TradingShipGoal'

	@property
	def active(self):
		return super(TradingShipGoal, self).active \
			and self.owner.count_buildings(BUILDINGS.BOAT_BUILDER) \
			and self.owner.need_more_ships \
			and not self.owner.unit_builder.num_ships_being_built

	def execute(self):
		self.settlement_manager.log.info('%s start building a ship', self)
		self.owner.unit_builder.build_ship()

decorators.bind_all(TradingShipGoal)

########NEW FILE########
__FILENAME__ = internationaltrademanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from collections import defaultdict

from mission.internationaltrade import InternationalTrade
from horizons.constants import RES, TRADER
from horizons.util.python import decorators
from horizons.component.storagecomponent import StorageComponent
from horizons.component.tradepostcomponent import TradePostComponent

class InternationalTradeManager(object):
	"""
	An object of this class manages the international trade routes of one AI player.

	The current implementation is limited to one active route between each pair of our
	settlement and another player's settlement where each route can have at most one
	bought and one sold resource. The routes are automatically removed when they have
	been used once or when the ship gets destroyed.
	"""

	log = logging.getLogger("ai.aiplayer.internationaltrade")

	def __init__(self, owner):
		super(InternationalTradeManager, self).__init__()
		self.owner = owner
		self.world = owner.world
		self.session = owner.session
		self.personality = owner.personality_manager.get('InternationalTradeManager')

	def _trade_mission_exists(self, settlement, settlement_manager):
		"""Return a boolean showing whether there is a trade route between the settlements."""
		for mission in self.owner.missions:
			if not isinstance(mission, InternationalTrade):
				continue
			if mission.settlement is settlement and mission.settlement_manager is settlement_manager:
				return True
		return False

	def _add_route(self):
		"""Add a new international trade route if possible."""
		ship = None
		for possible_ship, state in self.owner.ships.iteritems():
			if state is self.owner.shipStates.idle:
				ship = possible_ship
				break
		if not ship:
			#self.log.info('%s international trade: no available ships', self)
			return

		# find all possible legal trade route options
		options = defaultdict(list) # {(settlement, settlement_manager): (total value, amount, resource id, bool(selling)), ...}
		for settlement in self.world.settlements:
			if settlement.owner is self.owner:
				continue # don't allow routes of this type between the player's own settlements
			for settlement_manager in self.owner.settlement_managers:
				if self._trade_mission_exists(settlement, settlement_manager):
					continue # allow only one international trade route between a pair of settlements
				my_inventory = settlement_manager.settlement.get_component(StorageComponent).inventory
				resource_manager = settlement_manager.resource_manager

				# add the options where we sell to the other player
				for resource_id, limit in settlement.get_component(TradePostComponent).buy_list.iteritems():
					if resource_id not in resource_manager.resource_requirements:
						continue # not a well-known resource: ignore it
					if limit <= settlement.get_component(StorageComponent).inventory[resource_id]:
						continue # they aren't actually buying the resource
					if my_inventory[resource_id] <= resource_manager.resource_requirements[resource_id]:
						continue # my settlement is unable to sell the resource
					price = int(self.session.db.get_res_value(resource_id) * TRADER.PRICE_MODIFIER_SELL)
					tradable_amount = min(my_inventory[resource_id] - resource_manager.resource_requirements[resource_id],
						limit - settlement.get_component(StorageComponent).inventory[resource_id], ship.get_component(StorageComponent).inventory.get_limit(), settlement.owner.get_component(StorageComponent).inventory[RES.GOLD] // price)
					options[(settlement, settlement_manager)].append((tradable_amount * price, tradable_amount, resource_id, True))

				# add the options where we buy from the other player
				for resource_id, limit in settlement.get_component(TradePostComponent).sell_list.iteritems():
					if resource_id not in resource_manager.resource_requirements:
						continue # not a well-known resource: ignore it
					if limit >= settlement.get_component(StorageComponent).inventory[resource_id]:
						continue # they aren't actually selling the resource
					if my_inventory[resource_id] >= resource_manager.resource_requirements[resource_id]:
						continue # my settlement doesn't want to buy the resource
					price = int(self.session.db.get_res_value(resource_id) * TRADER.PRICE_MODIFIER_BUY)
					tradable_amount = min(resource_manager.resource_requirements[resource_id] - my_inventory[resource_id],
						settlement.get_component(StorageComponent).inventory[resource_id] - limit, ship.get_component(StorageComponent).inventory.get_limit(), self.owner.get_component(StorageComponent).inventory[RES.GOLD] // price)
					options[(settlement, settlement_manager)].append((tradable_amount * price, tradable_amount, resource_id, False))
		if not options:
			#self.log.info('%s international trade: no interesting options', self)
			return

		# make up final options where a route is limited to at most one resource bought and one resource sold
		final_options = [] # [(value, bought resource id or None, sold resource id or None, settlement, settlement_manager), ...]
		for (settlement, settlement_manager), option in sorted(options.iteritems()):
			best_buy = None # largest amount of resources
			best_sale = None # most expensive sale
			for total_price, tradable_amount, resource_id, selling in option:
				if selling:
					if best_sale is None or best_sale[0] < total_price:
						best_sale = (total_price, tradable_amount, resource_id)
				else:
					if best_buy is None or best_buy[1] < tradable_amount:
						best_buy = (total_price, tradable_amount, resource_id)
			buy_coefficient = self.personality.buy_coefficient_rich if self.owner.get_component(StorageComponent).inventory[RES.GOLD] > self.personality.little_money else self.personality.buy_coefficient_poor
			total_value = (best_sale[0] if best_sale else 0) + (best_buy[1] if best_buy else 0) * buy_coefficient
			final_options.append((total_value, best_buy[2] if best_buy else None, best_sale[2] if best_sale else None, settlement, settlement_manager))

		bought_resource, sold_resource, settlement, settlement_manager = max(final_options)[1:]
		self.owner.start_mission(InternationalTrade(settlement_manager, settlement, ship, bought_resource, sold_resource, self.owner.report_success, self.owner.report_failure))

	def tick(self):
		self._add_route()

decorators.bind_all(InternationalTradeManager)

########NEW FILE########
__FILENAME__ = landmanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import math
import logging

from collections import defaultdict

from horizons.constants import AI, BUILDINGS, RES
from horizons.util.python import decorators
from horizons.util.worldobject import WorldObject
from horizons.component.storagecomponent import StorageComponent

class LandManager(WorldObject):
	"""
	Divides and manages the division of the land of one island.

	The idea is that the LandManager object divides the land of the island between
	different purposes (currently the production area and on non-feeder islands the
	village area) and from that point on the different area managers are limited to that
	land unless they decide to give some of it up (currently happens with the village area).
	"""

	log = logging.getLogger("ai.aiplayer.land_manager")

	class purpose:
		production = 0
		village = 1

	def __init__(self, island, owner, feeder_island):
		"""
		@param island: Island instance
		@param owner: AIPlayer instance
		@param feeder_island: boolean showing whether this is a feeder island (no village area)
		"""

		super(LandManager, self).__init__()
		self.__init(island, owner, feeder_island)
		if self.feeder_island:
			self._prepare_feeder_island()
		else:
			self._divide_island()

	def __init(self, island, owner, feeder_island):
		self.island = island
		self.settlement = None
		self.owner = owner
		self.feeder_island = feeder_island
		self.session = self.island.session
		self.production = {}
		self.village = {}
		self.roads = set() # set((x, y), ...) of coordinates where road can be built independent of the area purpose
		self.coastline = self._get_coastline() # set((x, y), ...) of coordinates which coastal buildings could use in the production area
		self.personality = self.owner.personality_manager.get('LandManager')
		self.refresh_resource_deposits()

	def save(self, db):
		super(LandManager, self).save(db)
		db("INSERT INTO ai_land_manager(rowid, owner, island, feeder_island) VALUES(?, ?, ?, ?)", self.worldid,
			self.owner.worldid, self.island.worldid, self.feeder_island)
		for (x, y) in self.production:
			db("INSERT INTO ai_land_manager_coords(land_manager, x, y, purpose) VALUES(?, ?, ?, ?)",
				self.worldid, x, y, self.purpose.production)
		for (x, y) in self.village:
			db("INSERT INTO ai_land_manager_coords(land_manager, x, y, purpose) VALUES(?, ?, ?, ?)",
				self.worldid, x, y, self.purpose.village)

	@classmethod
	def load(cls, db, owner, worldid):
		self = cls.__new__(cls)
		self._load(db, owner, worldid)
		return self

	def _load(self, db, owner, worldid):
		super(LandManager, self).load(db, worldid)
		island_id, feeder_island = db("SELECT island, feeder_island FROM ai_land_manager WHERE rowid = ?", worldid)[0]
		self.__init(WorldObject.get_object_by_id(island_id), owner, feeder_island)

		for x, y, purpose in db("SELECT x, y, purpose FROM ai_land_manager_coords WHERE land_manager = ?", self.worldid):
			coords = (x, y)
			if purpose == self.purpose.production:
				self.production[coords] = self.island.ground_map[coords]
			elif purpose == self.purpose.village:
				self.village[coords] = self.island.ground_map[coords]

	def _get_coastline(self):
		result = set()
		for coords in self.island.ground_map:
			tile = self.island.ground_map[coords]
			if 'coastline' not in tile.classes:
				continue
			if tile.object is not None and not tile.object.buildable_upon:
				continue
			if tile.settlement is not None and tile.settlement.owner is not self.owner:
				continue
			result.add(coords)
		return result

	def refresh_resource_deposits(self):
		self.resource_deposits = defaultdict(list) # {resource_id: [tile, ...]} all resource deposits of a type on the island
		for resource_id, building_ids in {RES.RAW_CLAY: [BUILDINGS.CLAY_DEPOSIT, BUILDINGS.CLAY_PIT], RES.RAW_IRON: [BUILDINGS.MOUNTAIN, BUILDINGS.MINE]}.iteritems():
			for building in self.island.buildings:
				if building.id in building_ids:
					if building.get_component(StorageComponent).inventory[resource_id] > 0:
						self.resource_deposits[resource_id].append(self.island.ground_map[building.position.origin.to_tuple()])

	def _divide_island(self):
		"""Divide the whole island between the purposes. The proportions depend on the personality."""
		min_x, max_x = None, None
		min_y, max_y = None, None
		land = 0
		for x, y in self.island.ground_map:
			if self.coords_usable((x, y)):
				land += 1
				if min_x is None or x < min_x:
					min_x = x
				if max_x is None or x > max_x:
					max_x = x
				if min_y is None or y < min_y:
					min_y = y
				if max_y is None or y > max_y:
					max_y = y
		width = max_x - min_x + 1
		height = max_y - min_y + 1
		self.log.info('%s island width %d, height %d', self, width, height)

		village_area = self.personality.village_area_small
		if land > 60 * 60:
			village_area = self.personality.village_area_60
		elif land > 50 * 50:
			village_area = self.personality.village_area_50
		elif land > 40 * 40:
			village_area = self.personality.village_area_40
		chosen_area = max(self.personality.min_village_size, int(round(land * village_area)))
		min_village_area = int(round(chosen_area * self.personality.min_village_proportion))
		self.log.info('%s land %d, village area %.2f, chosen area %d, minimum preliminary village area %d', self, land, village_area, chosen_area, min_village_area)

		side = int(math.floor(math.sqrt(chosen_area)))
		if side <= self.personality.max_section_side:
			side = min(side, width)
			self._divide(side, chosen_area // side)
		else:
			best_sections = 1000
			best_side1 = None
			best_side2 = None

			for side1 in xrange(9, max(10, chosen_area // 9 + 1)):
				real_side1 = min(side1, width)
				real_side2 = min(chosen_area // real_side1, height)
				if real_side1 * real_side2 < min_village_area:
					continue

				horizontal_sections = int(math.ceil(float(real_side1) / self.personality.max_section_side))
				vertical_sections = int(math.ceil(float(real_side2) / self.personality.max_section_side))
				sections = horizontal_sections * vertical_sections
				if best_sections > sections or (best_sections == sections and abs(real_side1 - real_side2) < abs(best_side1 - best_side2)):
					best_sections = sections
					best_side1 = real_side1
					best_side2 = real_side2
			self._divide(best_side1, best_side2)

	def coords_usable(self, coords, use_coast=False):
		"""Return a boolean showing whether the land on the given coordinate is usable for a normal building."""
		if coords in self.island.ground_map:
			tile = self.island.ground_map[coords]
			if use_coast:
				if 'constructible' not in tile.classes and 'coastline' not in tile.classes:
					return False
			elif 'constructible' not in tile.classes:
				return False
			if tile.object is not None and not tile.object.buildable_upon:
				return False
			return tile.settlement is None or tile.settlement.owner is self.owner
		return False

	def legal_for_production(self, rect):
		"""Return a boolean showing whether every tile in the Rect is either in the production area or on the coast."""
		for coords in rect.tuple_iter():
			if coords in self.village:
				return False
		return True

	def _get_usability_map(self, extra_space):
		"""
		Return a tuple describing the usability of the island.

		The return format is ({x, y): usable, ..}, min_x - extra_space, max_x, min_y - extra_space, max_y)
		where the dict contains ever key for x in [min_x, max_x] and y in [min_y, max_y] and the
		usability value says whether we can use that part of the land for normal buildings.
		"""

		map = {}
		for coords, tile in self.island.ground_map.iteritems():
			if 'constructible' not in tile.classes:
				continue
			if tile.object is not None and not tile.object.buildable_upon:
				continue
			if tile.settlement is None or tile.settlement.owner == self.owner:
				map[coords] = 1

		xs, ys = zip(*map.iterkeys())
		min_x = min(xs) - extra_space
		max_x = max(xs)
		min_y = min(ys) - extra_space
		max_y = max(ys)

		for x in xrange(min_x, max_x + 1):
			for y in xrange(min_y, max_y + 1):
				coords = (x, y)
				if coords not in map:
					map[coords] = 0
		return (map, min_x, max_x, min_y, max_y)

	def _divide(self, side1, side2):
		"""Divide the total land area between different purposes trying to achieve a side1 x side2 rectangle for the village."""
		usability_map, min_x, max_x, min_y, max_y = self._get_usability_map(max(side1, side2))
		self.log.info('%s divide %d x %d', self, side1, side2)

		best_coords = (0, 0)
		best_buildable = 0
		best_sides = (None, None)

		sizes = [(side1, side2)]
		if side1 != side2:
			sizes.append((side2, side1))

		for width, height in sizes:
			horizontal_strip = {} # (x, y): number of usable tiles from (x - width + 1, y) to (x, y)
			usable_area = {} # (x, y): number of usable tiles from (x - width + 1, y - height + 1) to (x, y)
			for x in xrange(min_x, max_x + 1):
				for dy in xrange(height):
					horizontal_strip[(x, min_y + dy)] = 0
					usable_area[(x, min_y + dy)] = 0
			for y in xrange(min_y, max_y + 1):
				for dx in xrange(width):
					horizontal_strip[(min_x +dx, y)] = 0
					usable_area[(min_x + dx, y)] = 0

			for y in xrange(min_y + height, max_y + 1):
				for x in xrange(min_x + width, max_x + 1):
					horizontal_strip[(x, y)] = horizontal_strip[(x - 1, y)] + usability_map[(x, y)] - usability_map[(x - width, y)]

			for x in xrange(min_x + width, max_x + 1):
				for y in xrange(min_y + height, max_y + 1):
					coords = (x, y)
					usable_area[coords] = usable_area[(x, y - 1)] + horizontal_strip[(x, y)] - horizontal_strip[(x, y - height)]

					if usable_area[coords] > best_buildable:
						best_coords = (x - width + 1, y - height + 1)
						best_buildable = usable_area[coords]
						best_sides = (width, height)

		self.production = {}
		self.village = {}

		for dx in xrange(best_sides[0]):
			for dy in xrange(best_sides[1]):
				coords = (best_coords[0] + dx, best_coords[1] + dy)
				if usability_map[coords] == 1:
					self.village[coords] = self.island.ground_map[coords]

		for coords, tile in self.island.ground_map.iteritems():
			if coords not in self.village and self.coords_usable(coords, use_coast=True):
				self.production[coords] = tile

	def _prepare_feeder_island(self):
		"""Assign all the usable land of the island to the production area."""
		self.production = {}
		self.village = {}
		for coords, tile in self.island.ground_map.iteritems():
			if self.coords_usable(coords, use_coast=True):
				self.production[coords] = tile

	def add_to_production(self, coords):
		"""Assign a current village tile to the production area."""
		self.production[coords] = self.village[coords]
		del self.village[coords]

	def handle_lost_area(self, coords_list):
		"""Handle losing the potential land in the given coordinates list."""
		# reduce the areas for the village, production, roads, and coastline
		for coords in coords_list:
			if coords in self.village:
				del self.village[coords]
			elif coords in self.production:
				del self.production[coords]
			self.roads.discard(coords)
			self.coastline.discard(coords)

	def display(self):
		"""Show the plan on the map unless it is disabled in the settings."""
		if not AI.HIGHLIGHT_PLANS:
			return

		village_color = (255, 255, 255)
		production_color = (255, 255, 0)
		coastline_color = (0, 0, 255)
		renderer = self.island.session.view.renderer['InstanceRenderer']

		for tile in self.production.itervalues():
			renderer.addColored(tile._instance, *production_color)

		for tile in self.village.itervalues():
			renderer.addColored(tile._instance, *village_color)

		for coords in self.coastline:
			renderer.addColored(self.island.ground_map[coords]._instance, *coastline_color)

	def __str__(self):
		return '%s LandManager(%s)' % (getattr(self, 'owner', 'unknown player'),
		                               getattr(self, 'worldid', 'none'))

decorators.bind_all(LandManager)

########NEW FILE########
__FILENAME__ = domestictrade
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.mission import ShipMission
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.worldobject import WorldObject
from horizons.ext.enum import Enum

class DomesticTrade(ShipMission):
	"""
	Given a ship and two settlement managers the ship is taken to the first one,
	loaded with resources, and then moved to the other one to unload the resources.
	"""

	missionStates = Enum('created', 'moving_to_source_warehouse', 'moving_to_destination_warehouse')

	def __init__(self, source_settlement_manager, destination_settlement_manager, ship, success_callback, failure_callback):
		super(DomesticTrade, self).__init__(success_callback, failure_callback, ship)
		self.source_settlement_manager = source_settlement_manager
		self.destination_settlement_manager = destination_settlement_manager
		self.state = self.missionStates.created

	def save(self, db):
		super(DomesticTrade, self).save(db)
		db("INSERT INTO ai_mission_domestic_trade(rowid, source_settlement_manager, destination_settlement_manager, ship, state) VALUES(?, ?, ?, ?, ?)",
			self.worldid, self.source_settlement_manager.worldid, self.destination_settlement_manager.worldid, self.ship.worldid, self.state.index)

	@classmethod
	def load(cls, db, worldid, success_callback, failure_callback):
		self = cls.__new__(cls)
		self._load(db, worldid, success_callback, failure_callback)
		return self

	def _load(self, db, worldid, success_callback, failure_callback):
		db_result = db("SELECT source_settlement_manager, destination_settlement_manager, ship, state FROM ai_mission_domestic_trade WHERE rowid = ?", worldid)[0]
		self.source_settlement_manager = WorldObject.get_object_by_id(db_result[0])
		self.destination_settlement_manager = WorldObject.get_object_by_id(db_result[1])
		self.state = self.missionStates[db_result[3]]
		super(DomesticTrade, self).load(db, worldid, success_callback, failure_callback, WorldObject.get_object_by_id(db_result[2]))

		if self.state == self.missionStates.moving_to_source_warehouse:
			self.ship.add_move_callback(Callback(self._reached_source_warehouse_area))
			self.ship.add_blocked_callback(Callback(self._move_to_source_warehouse_area))
		elif self.state == self.missionStates.moving_to_destination_warehouse:
			self.ship.add_move_callback(Callback(self._reached_destination_warehouse_area))
			self.ship.add_blocked_callback(Callback(self._move_to_destination_warehouse_area))
		else:
			assert False, 'invalid state'

	def start(self):
		self.state = self.missionStates.moving_to_source_warehouse
		self._move_to_source_warehouse_area()

	def _move_to_source_warehouse_area(self):
		self._move_to_warehouse_area(self.source_settlement_manager.settlement.warehouse.position, Callback(self._reached_source_warehouse_area),
			Callback(self._move_to_source_warehouse_area), 'First move not possible')

	def _reached_source_warehouse_area(self):
		self.log.info('%s reached the source warehouse area', self)
		if self.source_settlement_manager.trade_manager.load_resources(self):
			self.log.info('%s loaded resources', self)
			self.state = self.missionStates.moving_to_destination_warehouse
			self._move_to_destination_warehouse_area()
		else:
			self.report_failure('No need for the ship at the source warehouse')

	def _move_to_destination_warehouse_area(self):
		self._move_to_warehouse_area(self.destination_settlement_manager.settlement.warehouse.position, Callback(self._reached_destination_warehouse_area),
			Callback(self._move_to_destination_warehouse_area), 'Second move not possible')

	def _reached_destination_warehouse_area(self):
		self.log.info('%s reached destination warehouse area', self)
		self._unload_all_resources(self.destination_settlement_manager.settlement)
		self.report_success('Unloaded resources')

decorators.bind_all(DomesticTrade)

########NEW FILE########
__FILENAME__ = foundsettlement
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.mission import ShipMission
from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.constants import BUILDINGS
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.shapes import Circle, Point
from horizons.util.worldobject import WorldObject
from horizons.ext.enum import Enum
from horizons.entities import Entities

class FoundSettlement(ShipMission):
	"""
	Given a ship with the required resources and the coordinates of the future warehouse
	the ship is taken near the end location and a warehouse is built.
	"""

	missionStates = Enum('created', 'moving')

	def __init__(self, success_callback, failure_callback, land_manager, ship, coords):
		super(FoundSettlement, self).__init__(success_callback, failure_callback, ship)
		self.land_manager = land_manager
		self.coords = coords
		self.warehouse = None
		self.state = self.missionStates.created

	def save(self, db):
		super(FoundSettlement, self).save(db)
		db("INSERT INTO ai_mission_found_settlement(rowid, land_manager, ship, x, y, state) VALUES(?, ?, ?, ?, ?, ?)",
			self.worldid, self.land_manager.worldid, self.ship.worldid, self.coords[0], self.coords[1], self.state.index)

	@classmethod
	def load(cls, db, worldid, success_callback, failure_callback):
		self = cls.__new__(cls)
		self._load(db, worldid, success_callback, failure_callback)
		return self

	def _load(self, db, worldid, success_callback, failure_callback):
		db_result = db("SELECT land_manager, ship, x, y, state FROM ai_mission_found_settlement WHERE rowid = ?", worldid)[0]
		self.land_manager = WorldObject.get_object_by_id(db_result[0])
		self.coords = (int(db_result[2]), int(db_result[3]))
		self.warehouse = None
		self.state = self.missionStates[db_result[4]]
		super(FoundSettlement, self).load(db, worldid, success_callback, failure_callback, WorldObject.get_object_by_id(db_result[1]))

		if self.state == self.missionStates.moving:
			self.ship.add_move_callback(Callback(self._reached_destination_area))
			self.ship.add_blocked_callback(Callback(self._move_to_destination_area))
		else:
			assert False, 'invalid state'

	def start(self):
		self.state = self.missionStates.moving
		self._move_to_destination_area()

	def _move_to_destination_area(self):
		if self.coords is None:
			self.report_failure('No possible warehouse location')
			return

		self._move_to_warehouse_area(Point(*self.coords), Callback(self._reached_destination_area),
			Callback(self._move_to_destination_area), 'Move not possible')

	def _reached_destination_area(self):
		self.log.info('%s reached BO area', self)

		builder = BasicBuilder(BUILDINGS.WAREHOUSE, self.coords, 0)
		if not builder.have_resources(self.land_manager, ship=self.ship):
			self.report_failure('Not enough resources for a warehouse at %s' % str(self.coords))
			return

		self.warehouse = builder.execute(self.land_manager, ship=self.ship)
		assert self.warehouse

		self.land_manager.settlement = self.warehouse.settlement
		self.log.info('%s built the warehouse', self)

		self._unload_all_resources(self.land_manager.settlement)
		self.report_success('Built the warehouse, transferred resources')

	@classmethod
	def find_warehouse_location(cls, ship, land_manager):
		"""Return the coordinates of a location for the warehouse on the given island."""
		warehouse_class = Entities.buildings[BUILDINGS.WAREHOUSE]
		pos_offsets = []
		for dx in xrange(warehouse_class.width):
			for dy in xrange(warehouse_class.height):
				pos_offsets.append((dx, dy))

		island = land_manager.island
		personality = land_manager.owner.personality_manager.get('FoundSettlement')

		available_spots_list = list(sorted(island.terrain_cache.cache[warehouse_class.terrain_type][warehouse_class.size].intersection(island.available_land_cache.cache[warehouse_class.size])))
		if not available_spots_list:
			return None

		options = []
		limited_spots = island.session.random.sample(available_spots_list, min(len(available_spots_list), personality.max_options))
		for (x, y) in limited_spots:
			cost = 0
			for (x2, y2) in land_manager.village:
				dx = x2 - x
				dy = y2 - y
				distance = (dx * dx + dy * dy) ** 0.5
				if distance < personality.too_close_penalty_threshold:
					cost += personality.too_close_constant_penalty + personality.too_close_linear_penalty / (distance + 1.0)
				else:
					cost += distance

			for settlement_manager in land_manager.owner.settlement_managers:
				cost += settlement_manager.settlement.warehouse.position.distance((x, y)) * personality.linear_warehouse_penalty
			options.append((cost, x, y))

		for _, x, y in sorted(options):
			if ship.check_move(Circle(Point(x + warehouse_class.width // 2, y + warehouse_class.height // 2), BUILDINGS.BUILD.MAX_BUILDING_SHIP_DISTANCE)):
				return (x, y)
		return None

	@classmethod
	def create(cls, ship, land_manager, success_callback, failure_callback):
		coords = cls.find_warehouse_location(ship, land_manager)
		return FoundSettlement(success_callback, failure_callback, land_manager, ship, coords)

decorators.bind_all(FoundSettlement)

########NEW FILE########
__FILENAME__ = internationaltrade
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.mission import ShipMission
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.worldobject import WorldObject
from horizons.constants import RES, TRADER
from horizons.command.uioptions import SellResource, BuyResource
from horizons.ext.enum import Enum
from horizons.component.storagecomponent import StorageComponent
from horizons.component.namedcomponent import NamedComponent
from horizons.component.tradepostcomponent import TradePostComponent

class InternationalTrade(ShipMission):
	"""
	Given a ship, a settlement_manager of our settlement, a settlement of another player,
	and either a resource to be bought or sold (or both) the ship will load/unload the
	required resources at our settlement and do the necessary trading at the other player's one.
	"""

	missionStates = Enum('created', 'moving_to_my_settlement', 'moving_to_other_settlement', 'returning_to_my_settlement')

	def __init__(self, settlement_manager, settlement, ship, bought_resource, sold_resource, success_callback, failure_callback):
		super(InternationalTrade, self).__init__(success_callback, failure_callback, ship)
		assert sold_resource is not None or bought_resource is not None
		self.settlement_manager = settlement_manager
		self.settlement = settlement
		self.bought_resource = bought_resource
		self.sold_resource = sold_resource
		self.state = self.missionStates.created

	def save(self, db):
		super(InternationalTrade, self).save(db)
		db("INSERT INTO ai_mission_international_trade(rowid, settlement_manager, settlement, ship, bought_resource, sold_resource, state) VALUES(?, ?, ?, ?, ?, ?, ?)",
			self.worldid, self.settlement_manager.worldid, self.settlement.worldid, self.ship.worldid, self.bought_resource, self.sold_resource, self.state.index)

	@classmethod
	def load(cls, db, worldid, success_callback, failure_callback):
		self = cls.__new__(cls)
		self._load(db, worldid, success_callback, failure_callback)
		return self

	def _load(self, db, worldid, success_callback, failure_callback):
		db_result = db("SELECT settlement_manager, settlement, ship, bought_resource, sold_resource, state FROM ai_mission_international_trade WHERE rowid = ?", worldid)[0]
		self.settlement_manager = WorldObject.get_object_by_id(db_result[0])
		self.settlement = WorldObject.get_object_by_id(db_result[1])
		self.bought_resource = db_result[3]
		self.sold_resource = db_result[4]
		self.state = self.missionStates[db_result[5]]
		super(InternationalTrade, self).load(db, worldid, success_callback, failure_callback, WorldObject.get_object_by_id(db_result[2]))

		if self.state is self.missionStates.moving_to_my_settlement:
			self.ship.add_move_callback(Callback(self._reached_my_settlement))
			self.ship.add_blocked_callback(Callback(self._move_to_my_settlement))
		elif self.state is self.missionStates.moving_to_other_settlement:
			self.ship.add_move_callback(Callback(self._reached_other_settlement))
			self.ship.add_blocked_callback(Callback(self._move_to_other_settlement))
		elif self.state is self.missionStates.returning_to_my_settlement:
			self.ship.add_move_callback(Callback(self._returned_to_my_settlement))
			self.ship.add_blocked_callback(Callback(self._return_to_my_settlement))
		else:
			assert False, 'invalid state'

	def start(self):
		if self.sold_resource is not None:
			self.state = self.missionStates.moving_to_my_settlement
			self._move_to_my_settlement()
		else:
			self.state = self.missionStates.moving_to_other_settlement
			self._move_to_other_settlement()
		self.log.info('%s started an international trade mission between %s and %s to sell %s and buy %s using %s', self,
			self.settlement_manager.settlement.get_component(NamedComponent).name, self.settlement.get_component(NamedComponent).name, self.sold_resource, self.bought_resource, self.ship)

	def _move_to_my_settlement(self):
		self._move_to_warehouse_area(self.settlement_manager.settlement.warehouse.position, Callback(self._reached_my_settlement),
			Callback(self._move_to_my_settlement), 'Unable to move to my settlement (%s)' % self.settlement_manager.settlement.get_component(NamedComponent).name)

	def _get_max_sellable_amount(self, available_amount):
		if self.sold_resource not in self.settlement.get_component(TradePostComponent).buy_list:
			return 0
		if self.settlement.get_component(TradePostComponent).buy_list[self.sold_resource] >= self.settlement.get_component(StorageComponent).inventory[self.sold_resource]:
			return 0
		if available_amount <= 0:
			return 0
		price = int(self.owner.session.db.get_res_value(self.sold_resource) * TRADER.PRICE_MODIFIER_SELL)
		return min(self.settlement.get_component(StorageComponent).inventory[self.sold_resource] - self.settlement.get_component(TradePostComponent).buy_list[self.sold_resource],
			self.settlement.owner.get_component(StorageComponent).inventory[RES.GOLD] // price, available_amount)

	def _reached_my_settlement(self):
		self.log.info('%s reached my warehouse area (%s)', self, self.settlement_manager.settlement.get_component(NamedComponent).name)
		available_amount = max(0, self.settlement_manager.settlement.get_component(StorageComponent).inventory[self.sold_resource] - self.settlement_manager.resource_manager.resource_requirements[self.sold_resource])
		sellable_amount = self._get_max_sellable_amount(available_amount)
		if sellable_amount <= 0:
			self.log.info('%s no resources can be sold', self)
			if self.bought_resource is None:
				self.report_failure('No resources need to be sold nor bought')
				return
		else:
			self.move_resource(self.ship, self.settlement_manager.settlement, self.sold_resource, -sellable_amount)
			self.log.info('%s loaded resources', self)
		self.state = self.missionStates.moving_to_other_settlement
		self._move_to_other_settlement()

	def _move_to_other_settlement(self):
		self._move_to_warehouse_area(self.settlement.warehouse.position, Callback(self._reached_other_settlement),
			Callback(self._move_to_other_settlement), 'Unable to move to the other settlement (%s)' % self.settlement.get_component(NamedComponent).name)

	def _get_max_buyable_amount(self):
		if self.bought_resource is None:
			return 0
		if self.bought_resource not in self.settlement.get_component(TradePostComponent).sell_list:
			return 0
		if self.settlement.get_component(TradePostComponent).sell_list[self.bought_resource] >= self.settlement.get_component(StorageComponent).inventory[self.bought_resource]:
			return 0
		needed_amount = self.settlement_manager.resource_manager.resource_requirements[self.bought_resource] - \
			self.settlement_manager.settlement.get_component(StorageComponent).inventory[self.bought_resource]
		if needed_amount <= 0:
			return 0
		price = int(self.owner.session.db.get_res_value(self.bought_resource) * TRADER.PRICE_MODIFIER_BUY)
		return min(self.settlement.get_component(StorageComponent).inventory[self.bought_resource] - self.settlement.get_component(TradePostComponent).sell_list[self.bought_resource],
			self.settlement_manager.owner.get_component(StorageComponent).inventory[RES.GOLD] // price, needed_amount)

	def _reached_other_settlement(self):
		self.log.info('%s reached the other warehouse area (%s)', self, self.settlement.get_component(NamedComponent).name)
		if self.sold_resource is not None:
			sellable_amount = self._get_max_sellable_amount(self.ship.get_component(StorageComponent).inventory[self.sold_resource])
			if sellable_amount > 0:
				BuyResource(self.settlement.get_component(TradePostComponent), self.ship, self.sold_resource, sellable_amount).execute(self.owner.session)
				if self.bought_resource is None:
					self.report_success('Sold %d of resource %d' % (sellable_amount, self.sold_resource))
					return
				else:
					self.log.info('%s sold %d of resource %d', self, sellable_amount, self.sold_resource)

		buyable_amount = self._get_max_buyable_amount()
		if buyable_amount <= 0:
			self.report_failure('No resources can be bought')
			return

		SellResource(self.settlement.get_component(TradePostComponent), self.ship, self.bought_resource, buyable_amount).execute(self.owner.session)
		self.log.info('%s bought %d of resource %d', self, buyable_amount, self.bought_resource)
		self.state = self.missionStates.returning_to_my_settlement
		self._return_to_my_settlement()

	def _return_to_my_settlement(self):
		self._move_to_warehouse_area(self.settlement_manager.settlement.warehouse.position, Callback(self._returned_to_my_settlement),
			Callback(self._return_to_my_settlement), 'Unable to return to %s' % self.settlement_manager.settlement.get_component(NamedComponent).name)

	def _returned_to_my_settlement(self):
		self._unload_all_resources(self.settlement_manager.settlement)
		self.report_success('Unloaded the bought resources at %s' % self.settlement_manager.settlement.get_component(NamedComponent).name)

decorators.bind_all(InternationalTrade)

########NEW FILE########
__FILENAME__ = preparefoundationship
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.mission import ShipMission
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.worldobject import WorldObject
from horizons.ext.enum import Enum
from horizons.constants import RES
from horizons.component.storagecomponent import StorageComponent

class PrepareFoundationShip(ShipMission):
	"""
	Given a ship and a settlement manager it moves the ship to the warehouse and loads
	it with the resources required to start another settlement.
	"""

	missionStates = Enum('created', 'moving')

	def __init__(self, settlement_manager, ship, feeder_island, success_callback, failure_callback):
		super(PrepareFoundationShip, self).__init__(success_callback, failure_callback, ship)
		self.settlement_manager = settlement_manager
		self.feeder_island = feeder_island
		self.warehouse = self.settlement_manager.settlement.warehouse
		self.state = self.missionStates.created

	def save(self, db):
		super(PrepareFoundationShip, self).save(db)
		db("INSERT INTO ai_mission_prepare_foundation_ship(rowid, settlement_manager, ship, feeder_island, state) VALUES(?, ?, ?, ?, ?)",
			self.worldid, self.settlement_manager.worldid, self.ship.worldid, self.feeder_island, self.state.index)

	@classmethod
	def load(cls, db, worldid, success_callback, failure_callback):
		self = cls.__new__(cls)
		self._load(db, worldid, success_callback, failure_callback)
		return self

	def _load(self, db, worldid, success_callback, failure_callback):
		db_result = db("SELECT settlement_manager, ship, feeder_island, state FROM ai_mission_prepare_foundation_ship WHERE rowid = ?", worldid)[0]
		self.settlement_manager = WorldObject.get_object_by_id(db_result[0])
		self.warehouse = self.settlement_manager.settlement.warehouse
		self.feeder_island = db_result[2]
		self.state = self.missionStates[db_result[3]]
		super(PrepareFoundationShip, self).load(db, worldid, success_callback, failure_callback,
			WorldObject.get_object_by_id(db_result[1]))

		if self.state == self.missionStates.moving:
			self.ship.add_move_callback(Callback(self._reached_destination_area))
			self.ship.add_blocked_callback(Callback(self._move_to_destination_area))
		else:
			assert False, 'invalid state'

	def start(self):
		self.state = self.missionStates.moving
		self._move_to_destination_area()

	def _move_to_destination_area(self):
		self._move_to_warehouse_area(self.warehouse.position, Callback(self._reached_destination_area),
			Callback(self._move_to_destination_area), 'Move not possible')

	def _load_foundation_resources(self):
		personality = self.owner.personality_manager.get('SettlementFounder')
		if self.feeder_island:
			max_amounts = {RES.BOARDS: personality.max_new_feeder_island_boards, RES.TOOLS: personality.max_new_feeder_island_tools}
		else:
			max_amounts = {RES.BOARDS: personality.max_new_island_boards, RES.FOOD: personality.max_new_island_food, RES.TOOLS: personality.max_new_island_tools}

		for resource_id, max_amount in max_amounts.iteritems():
			self.move_resource(self.ship, self.settlement_manager.settlement, resource_id, self.ship.get_component(StorageComponent).inventory[resource_id] - max_amount)

	def _reached_destination_area(self):
		self.log.info('%s reached BO area', self)
		self._load_foundation_resources()

		success = False
		if self.feeder_island:
			success = self.settlement_manager.owner.settlement_founder.have_feeder_island_starting_resources(self.ship, None)
			if success:
				self.report_success('Transferred enough feeder island foundation resources to the ship')
		else:
			success = self.settlement_manager.owner.settlement_founder.have_starting_resources(self.ship, None)
			if success:
				self.report_success('Transferred enough foundation resources to the ship')
		if not success:
			self.report_failure('Not enough foundation resources available')

	def cancel(self):
		self.ship.stop()
		super(PrepareFoundationShip, self).cancel()

decorators.bind_all(PrepareFoundationShip)

########NEW FILE########
__FILENAME__ = specialdomestictrade
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.mission import ShipMission
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.worldobject import WorldObject
from horizons.ext.enum import Enum
from horizons.component.storagecomponent import StorageComponent
from horizons.component.namedcomponent import NamedComponent

class SpecialDomesticTrade(ShipMission):
	"""
	Given a ship and two settlement managers the ship will go to the source destination,
	load the most useful resources for the destination settlement, and then unload at the
	destination settlement.
	"""

	missionStates = Enum('created', 'moving_to_source_settlement', 'moving_to_destination_settlement')

	def __init__(self, source_settlement_manager, destination_settlement_manager, ship, success_callback, failure_callback):
		super(SpecialDomesticTrade, self).__init__(success_callback, failure_callback, ship)
		self.source_settlement_manager = source_settlement_manager
		self.destination_settlement_manager = destination_settlement_manager
		self.state = self.missionStates.created

	def save(self, db):
		super(SpecialDomesticTrade, self).save(db)
		db("INSERT INTO ai_mission_special_domestic_trade(rowid, source_settlement_manager, destination_settlement_manager, ship, state) VALUES(?, ?, ?, ?, ?)",
			self.worldid, self.source_settlement_manager.worldid, self.destination_settlement_manager.worldid, self.ship.worldid, self.state.index)

	@classmethod
	def load(cls, db, worldid, success_callback, failure_callback):
		self = cls.__new__(cls)
		self._load(db, worldid, success_callback, failure_callback)
		return self

	def _load(self, db, worldid, success_callback, failure_callback):
		db_result = db("SELECT source_settlement_manager, destination_settlement_manager, ship, state FROM ai_mission_special_domestic_trade WHERE rowid = ?", worldid)[0]
		self.source_settlement_manager = WorldObject.get_object_by_id(db_result[0])
		self.destination_settlement_manager = WorldObject.get_object_by_id(db_result[1])
		self.state = self.missionStates[db_result[3]]
		super(SpecialDomesticTrade, self).load(db, worldid, success_callback, failure_callback, WorldObject.get_object_by_id(db_result[2]))

		if self.state is self.missionStates.moving_to_source_settlement:
			self.ship.add_move_callback(Callback(self._reached_source_settlement))
			self.ship.add_blocked_callback(Callback(self._move_to_source_settlement))
		elif self.state is self.missionStates.moving_to_destination_settlement:
			self.ship.add_move_callback(Callback(self._reached_destination_settlement))
			self.ship.add_blocked_callback(Callback(self._move_to_destination_settlement))
		else:
			assert False, 'invalid state'

	def start(self):
		self.state = self.missionStates.moving_to_source_settlement
		self._move_to_source_settlement()
		self.log.info('%s started a special domestic trade mission from %s to %s using %s', self,
			self.source_settlement_manager.settlement.get_component(NamedComponent).name, self.destination_settlement_manager.settlement.get_component(NamedComponent).name, self.ship)

	def _move_to_source_settlement(self):
		self._move_to_warehouse_area(self.source_settlement_manager.settlement.warehouse.position, Callback(self._reached_source_settlement),
			Callback(self._move_to_source_settlement), 'Unable to move to the source settlement (%s)' % self.source_settlement_manager.settlement.get_component(NamedComponent).name)

	def _load_resources(self):
		source_resource_manager = self.source_settlement_manager.resource_manager
		source_inventory = self.source_settlement_manager.settlement.get_component(StorageComponent).inventory
		destination_resource_manager = self.destination_settlement_manager.resource_manager
		destination_inventory = self.destination_settlement_manager.settlement.get_component(StorageComponent).inventory

		options = []
		for resource_id, limit in destination_resource_manager.resource_requirements.iteritems():
			if destination_inventory[resource_id] >= limit:
				continue # the destination settlement doesn't need the resource
			if source_inventory[resource_id] <= source_resource_manager.resource_requirements[resource_id]:
				continue # the source settlement doesn't have a surplus of the resource

			price = self.owner.session.db.get_res_value(resource_id)
			tradable_amount = min(self.ship.get_component(StorageComponent).inventory.get_limit(resource_id), limit - destination_inventory[resource_id],
				source_inventory[resource_id] - source_resource_manager.resource_requirements[resource_id])
			options.append((tradable_amount * price, tradable_amount, resource_id))

		if not options:
			return False # no resources to transport

		options.sort(reverse = True)
		for _, amount, resource_id in options:
			self.move_resource(self.source_settlement_manager.settlement, self.ship, resource_id, amount)
		return True

	def _reached_source_settlement(self):
		self.log.info('%s reached the first warehouse area (%s)', self, self.source_settlement_manager.settlement.get_component(NamedComponent).name)
		if self._load_resources():
			self.state = self.missionStates.moving_to_destination_settlement
			self._move_to_destination_settlement()
		else:
			self.report_failure('No resources to transport')

	def _move_to_destination_settlement(self):
		self._move_to_warehouse_area(self.destination_settlement_manager.settlement.warehouse.position, Callback(self._reached_destination_settlement),
			Callback(self._move_to_destination_settlement), 'Unable to move to the destination settlement (%s)' % self.destination_settlement_manager.settlement.get_component(NamedComponent).name)

	def _reached_destination_settlement(self):
		self._unload_all_resources(self.destination_settlement_manager.settlement)
		self.log.info('%s reached the destination warehouse area (%s)', self, self.destination_settlement_manager.settlement.get_component(NamedComponent).name)
		self.report_success('Unloaded resources')

decorators.bind_all(SpecialDomesticTrade)

########NEW FILE########
__FILENAME__ = default
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.constants import TIER

class DefaultPersonality:
	class SettlementFounder:
		min_feeder_island_area = 400 # minimum amount of usable free land on an island to consider turning it into a feeder island

		# found a settlement on a random island that is at least as large as the first element; if it is impossible then try the next size
		island_size_sequence = [500, 300, 150]

		enemy_settlement_penalty = 200 # penalty for every enemy settlement on the island
		compact_empire_importance = 100 # importance of keeping our islands close together
		extra_warehouse_distance = 1 # extra distance to add to the usual warehouse to island distance when choosing an island
		nearby_enemy_penalty = 100 # importance of keeping our islands away from other players' islands
		extra_enemy_island_distance = 1 # extra distance to add to the usual island to other player's island distance when choosing an island

		min_raw_clay = 100 # if the island has less than this much then apply the penalty
		max_raw_clay = 300 # no more than this much will count for the bonus value
		raw_clay_importance = 0.3 # how important is the available resource amount
		no_raw_clay_penalty = 100 # penalty for having less than this much of the resource on the island

		min_raw_iron = 100 # if the island has less than this much then apply the penalty
		max_raw_iron = 300 # no more than this much will count for the bonus value
		raw_iron_importance = 0.05 # how important is the available resource amount
		no_raw_iron_penalty = 30 # penalty for having less than this much of the resource on the island

		# minimum amount of a resource required to found a new settlement
		min_new_island_gold = 8000
		min_new_island_tools = 5
		min_new_island_boards = 17
		min_new_island_food = 10

		# maximum amount of a resource loaded on a ship to found a new settlement
		max_new_island_tools = 30
		max_new_island_boards = 30
		max_new_island_food = 30

		# minimum amount of a resource required to start a new feeder island
		min_new_feeder_island_gold = 4000
		min_new_feeder_island_tools = 10
		min_new_feeder_island_boards = 20

		# maximum amount of a resource loaded on a ship to start a new feeder island
		max_new_feeder_island_tools = 30
		max_new_feeder_island_boards = 30

	class InternationalTradeManager:
		little_money = 3000 # cutoff to decide that we really need to get more money by selling resources on other players' islands
		buy_coefficient_rich = 30 # value coefficient of buying resources when we have more than little_money gold
		buy_coefficient_poor = 10 # value coefficient of buying resources when we have less than or equal to little_money gold

	class AreaBuilder:
		path_road_penalty_threshold = 9
		path_distant_road_penalty = 0.5
		path_near_road_constant_penalty = 0.7
		path_near_road_linear_penalty = 0.15
		path_unreachable_road_penalty = 0.1

		path_boundary_penalty_threshold = 10
		path_near_boundary_constant_penalty = 0.3
		path_near_boundary_linear_penalty = 0.03
		path_unreachable_boundary_penalty = 0.1

	class ProductionBuilder(AreaBuilder):
		pass

	class VillageBuilder(AreaBuilder):
		max_village_section_size = 22 # maximum side length of a village section

		tent_value = 10 # the value of a tent in a village
		bad_road_penalty = 1 # the penalty for an impossible road tile
		double_road_penalty = 30 # the penalty for building two roads right next to each other (per complete road, not segment)

		max_coverage_building_capacity = 22 # maximum number of residences a coverage building can service
		normal_coverage_building_capacity = 20 # the initial plan calls for this number of residences per coverage building (may or may not be optimized away)

		max_fire_station_capacity = 40 # maximum number of residences a fire station can service
		normal_fire_station_capacity = 30 # the initial plan calls for this number of residences per fire station

		max_doctor_capacity = 40 # maximum number of residences a doctor can service
		normal_doctor_capacity = 30 # the initial plan calls for this number of residences per doctor

		min_coverage_building_options = 10 # consider at least this many coverage building options
		coverage_building_option_ratio = 0.4 # consider this * 100% of the possible options

	class LandManager:
		max_section_side = 22 # minimize the number of village sections by considering this to be its maximum side length

		village_area_small = 0.23 # use this fraction of the area for the village if <= 1600 tiles are available for the settlement
		village_area_40 = 0.26 # use this fraction of the area for the village if <= 2500 tiles are available for the settlement
		village_area_50 = 0.28 # use this fraction of the area for the village if <= 3600 tiles are available for the settlement
		village_area_60 = 0.31 # use this fraction of the area for the village if > 3600 tiles are available for the settlement
		min_village_size = 81 # minimum possible village size in tiles
		min_village_proportion = 0.95 # the proportion of the chosen village area size that must be present

	class ResourceManager:
		default_resource_requirement = 30 # try to always have this much tools and boards in settlement inventory
		default_food_requirement = 30 # try to always have this much food in settlement inventory in settlements with a village
		default_feeder_island_brick_requirement = 20 # try to always have this much bricks in feeder island inventory (active on level > 0)
		default_cannon_requirement = 4

		# the following constants affect the way the AI buys and sells resources
		reserve_time = 1000 # number of ticks to pre-reserve resources for
		max_upgraded_houses = 10 # maximum number of houses whose upgrades should be accounted for in the reserve_time
		buy_threshold = 0.66666 # when more than buy_threshold * needed_amount of resource exists then stop buying
		sell_threshold = 1.33333 # when less than sell_threshold * needed_amount of resource exists then stop selling
		low_requirement_threshold = 5 # when we need less than or equal to this amount of resource then disregard buy_threshold

	class RoadPlanner:
		turn_penalty = 1 # penalty for a bend in the road

	class SettlementManager:
		production_level_multiplier = 1.1 # always aim to produce the needed_amount * production_level_multiplier of required resources per tick
		new_settlement_settler_ratio = 0.5 # more than this proportion of residences must have settler status to be able to start a new settlement

		# dummy values to cause various producers to be built (production per tick)
		dummy_bricks_requirement = 0.001
		dummy_boards_requirement = 0.01
		dummy_tools_requirement = 0.001

		# tax rates and upgrade rights in new settlements
		initial_sailor_taxes = 0.5
		initial_pioneer_taxes = 0.8
		initial_settler_taxes = 0.8
		initial_citizen_taxes = 0.8
		initial_sailor_upgrades = False
		initial_pioneer_upgrades = False
		initial_settler_upgrades = False

		# tax rates and upgrade rights in settlements where the first sailors have been given the right to upgrade
		early_sailor_taxes = 0.9
		early_pioneer_taxes = 0.8
		early_settler_taxes = 0.8
		early_citizen_taxes = 0.8
		early_sailor_upgrades = False
		early_pioneer_upgrades = False
		early_settler_upgrades = False

		# tax rates and upgrade rights in settlements where bricks production exists but there is no school
		no_school_sailor_taxes = 0.9
		no_school_pioneer_taxes = 0.8
		no_school_settler_taxes = 0.8
		no_school_citizen_taxes = 0.8
		no_school_sailor_upgrades = True
		no_school_pioneer_upgrades = True
		no_school_settler_upgrades = False

		# tax rates and upgrade rights in settlements where there is a school but not enough resources to build something
		school_sailor_taxes = 0.9
		school_pioneer_taxes = 1.0
		school_settler_taxes = 0.8
		school_citizen_taxes = 0.8
		school_sailor_upgrades = False
		school_pioneer_upgrades = False
		school_settler_upgrades = False

		# tax rates and upgrade rights in settlements with a school and none of the above problems
		final_sailor_taxes = 0.9
		final_pioneer_taxes = 1.0
		final_settler_taxes = 1.0
		final_citizen_taxes = 0.8
		final_sailor_upgrades = True
		final_pioneer_upgrades = True
		final_settler_upgrades = True

	class FoundSettlement:
		# use a penalty for warehouse being too close to the village area
		too_close_penalty_threshold = 3
		too_close_constant_penalty = 100
		too_close_linear_penalty = 0

		linear_warehouse_penalty = 1000 # add a penalty of this constant * distance to a warehouse to the warehouse penalty
		max_options = 10 # maximum number of options to consider

	class FeederChainGoal:
		extra_priority = 1 # extra priority given to goals that are supposed to produce resources for other settlements on feeder islands

	class BoatBuilderGoal:
		enabled = True
		default_priority = 600
		residences_required = 16
		min_tier = TIER.PIONEERS

	class ClayDepositCoverageGoal:
		enabled = True
		default_priority = 450
		residences_required = 0
		min_tier = TIER.PIONEERS

		alignment_coefficient = 0.7 # the importance of alignment when choosing a location for a storage to get closer to a deposit

	class DoNothingGoal:
		enabled = True
		default_priority = 1500 # mean priority; changing this will influence which goals are more important than doing nothing
		min_tier = TIER.SAILORS
		priority_variance = 50
		likelihood = 0.1 # likelihood that it will be active [0, 1]

	class EnlargeCollectorAreaGoal:
		enabled = True
		default_priority = 850
		residences_required = 0
		min_tier = TIER.SAILORS

		alignment_coefficient = 3 # the importance of alignment when choosing a location for a storage to enlarge collector coverage
		max_interesting_collector_area = 100 # maximum collector area (of 3x3 squares) we are interested in when considering whether to enlarge the area
		max_collector_area_unreachable = 10 # maximum collector area (of 3x3 squares) that doesn't have to be reachable when considering whether to enlarge the area
		overlap_precision = 0.2 # probability that a tile in the radius will be checked for match for useful coordinates

	class FoundFeederIslandGoal:
		enabled = True
		default_priority = 650
		residences_required = 16
		min_tier = TIER.SAILORS

		feeder_island_requirement_cutoff = 30 # if there are less than this many free 3x3 squares in a settlement then a feeder island is needed
		usable_feeder_island_cutoff = 30 # if there are less than this many free 3x3 on a feeder island then another feeder island may be needed

	class ImproveCollectorCoverageGoal:
		enabled = True
		default_priority = 1000
		residences_required = 0
		min_tier = TIER.SAILORS

		min_bad_collector_coverage = 0.5 # collector coverage should be improved when a production building is stopped for more than this amount of time
		min_free_space = 20 # if there is less than this much free space for a resource then it doesn't matter that the building in badly covered
		max_good_collector_utilization = 0.7 # if the collector building is used more than this then don't attempt to improve coverage by connecting more production buildings

		max_reasonably_served_buildings = 3 # maximum number of buildings a storage can reasonably serve (not a hard limit)
		collector_extra_distance = 6.0 # constant distance on top of the actual distance a collector has to move (accounts for breaks)
		alignment_coefficient = 0.001 # the importance of alignment when choosing a location for a storage to improve collector coverage

		collector_improvement_road_expires = 1500 # minimum number of ticks between collector improvement road connections
		collector_improvement_storage_expires = 4000 # minimum number of ticks between collector improvement extra storages

	class MountainCoverageGoal:
		enabled = True
		default_priority = 200
		residences_required = 0
		min_tier = TIER.SETTLERS

		alignment_coefficient = 0.7 # the importance of alignment when choosing a location for a storage to get closer to a deposit

	class SignalFireGoal:
		enabled = True
		default_priority = 750
		residences_required = 0
		min_tier = TIER.SAILORS

	class StorageSpaceGoal(ImproveCollectorCoverageGoal):
		enabled = True
		default_priority = 825
		residences_required = 0
		min_tier = TIER.SAILORS

		max_required_storage_space = 60 # maximum storage capacity to go for when the inventory starts to get full
		full_storage_threshold = 5 # when there is less than this amount of free space for a resource then we might need more space

	class TentGoal:
		enabled = True
		default_priority = 480
		residences_required = 0
		min_tier = TIER.SAILORS

	class TradingShipGoal:
		enabled = True
		default_priority = 550
		residences_required = 0
		min_tier = TIER.SAILORS

	class CombatShipGoal:
		enabled = True
		default_priority = 560
		residences_required = 0
		min_tier = TIER.SAILORS

	class FaithGoal:
		enabled = True
		default_priority = 700
		residences_required = 10
		min_tier = TIER.SAILORS

	class TextileGoal:
		enabled = True
		default_priority = 520
		residences_required = 0
		min_tier = TIER.PIONEERS

	class BricksGoal:
		enabled = True
		default_priority = 350
		residences_required = 0
		min_tier = TIER.PIONEERS

	class EducationGoal:
		enabled = True
		default_priority = 300
		residences_required = 10
		min_tier = TIER.PIONEERS

	class GetTogetherGoal:
		enabled = True
		default_priority = 250
		residences_required = 10
		min_tier = TIER.SETTLERS

	class ToolsGoal:
		enabled = True
		default_priority = 150
		residences_required = 0
		min_tier = TIER.SETTLERS

	class BoardsGoal:
		enabled = True
		default_priority = 950
		residences_required = 0
		min_tier = TIER.SAILORS

	class FoodGoal:
		enabled = True
		default_priority = 800
		residences_required = 0
		min_tier = TIER.SAILORS

	class CommunityGoal:
		enabled = True
		default_priority = 900
		residences_required = 0
		min_tier = TIER.SAILORS

	class LiquorGoal:
		# this goal is only used on feeder islands
		enabled = True
		default_priority = 250
		residences_required = 0
		min_tier = TIER.SETTLERS

	class SaltGoal:
		enabled = True
		default_priority = 230
		residences_required = 10
		min_tier = TIER.SETTLERS

	class FeederSaltGoal:
		enabled = True
		default_priority = 230
		residences_required = 0
		min_tier = TIER.SETTLERS

	class TobaccoProductsGoal:
		enabled = True
		default_priority = 220
		residences_required = 13
		min_tier = TIER.SETTLERS

	class FeederTobaccoProductsGoal:
		enabled = True
		default_priority = 220
		residences_required = 0
		min_tier = TIER.SETTLERS

	class MedicalHerbsProductsGoal:
		enabled = True
		default_priority = 230
		residences_required = 13
		min_tier = TIER.SETTLERS

	class FeederMedicalProductsGoal:
		enabled = True
		default_priority = 230
		residences_required = 0
		min_tier = TIER.SETTLERS

	class AbstractVillageBuilding:
		fraction_of_assigned_residences_built = 0.75 # build a coverage building if at least this amount of the assigned residences have been built

	class BuildingEvaluator:
		# the following constants are used to calculate the alignment bonus for buildings
		alignment_road = 3
		alignment_production_building = 1
		alignment_other_building = 1
		alignment_edge = 1

	class BoatBuilderEvaluator:
		alignment_importance = 0.02 # the larger this value, the larger the effect of alignment on the placement

	class BrickyardEvaluator:
		alignment_importance = 0.02 # the larger this value, the larger the effect of alignment on the placement
		collector_distance_importance = 0.1 # importance of the distance to the nearest collector in the range [0, 1]
		distance_penalty = 2 # when no clay pit is in reach then apply a penalty of this times the radius

	class CharcoalBurnerEvaluator:
		alignment_importance = 0.02 # the larger this value, the larger the effect of alignment on the placement
		lumberjack_distance_importance = 0.05 # importance of the distance to the nearest lumberjack in the range [0, 1]
		iron_mine_distance_importance = 0.1 # importance of the distance to the nearest iron mine in the range [0, 1]
		distance_penalty = 2 # when no lumberjack or iron mine is in reach then apply a penalty of this times the radius

	class DistilleryEvaluator:
		alignment_importance = 0.02 # the larger this value, the larger the effect of alignment on the placement
		farm_distance_importance = 0.3 # importance of the distance to the nearest relevant farm in the range [0, 1]
		distance_penalty = 2 # when no relevant farm is in reach then apply a penalty of this times the radius

	class FarmEvaluator:
		alignment_importance = 0.001 # the larger this value, the larger the effect of alignment on the placement
		existing_road_importance = 0.005 # bonus for every reused tile of existing (or planned) road
		wasted_space_penalty = 0.02
		immediate_connection_importance = 0.005 # bonus for road and non-blocked access to the road

		immediate_connection_road = 3 # bonus for a road in an entrance of the farm
		immediate_connection_free = 1 # bonus for an unused tile in an entrance of the farm

		max_options = 100 # maximum number of farm options to consider

	class LumberjackEvaluator:
		alignment_importance = 0.5 # the larger this value, the larger the effect of alignment on the placement
		new_tree = 3 # number of points for a new tree in range
		shared_tree = 1 # number of points for a shared tree in range (at least one lumberjack already using it)
		min_forest_value = 30 # minimum number of points to consider the position
		max_forest_value = 100 # maximum number of relevant points (more than this is ignored)

	class SignalFireEvaluator:
		alignment_importance = 1.5 # the larger this value, the larger the effect of alignment on the placement

	class SmelteryEvaluator:
		alignment_importance = 0.02 # the larger this value, the larger the effect of alignment on the placement
		collector_distance_importance = 0.4 # importance of the distance to the nearest collector in the range [0, 1]
		charcoal_burner_distance_importance = 0.1 # importance of the distance to the nearest charcoal burner in the range [0, 1]
		distance_penalty = 2 # when no collector or charcoal burner is in reach then apply a penalty of this times the radius

	class ToolmakerEvaluator:
		alignment_importance = 0.02 # the larger this value, the larger the effect of alignment on the placement
		smeltery_distance_importance = 0.4 # importance of the distance to the nearest smeltery in the range [0, 1]
		lumberjack_distance_importance = 0.1 # importance of the distance to the nearest lumberjack in the range [0, 1]
		charcoal_burner_distance_importance = 0.4 # importance of the distance to the nearest charcoal burner in the range [0, 1]
		distance_penalty = 2 # when no smeltery, lumberjack, or charcoal burner is in reach then apply a penalty of this times the radius

	class WeaverEvaluator:
		alignment_importance = 0.02 # the larger this value, the larger the effect of alignment on the placement
		farm_distance_importance = 0.3 # importance of the distance to the nearest relevant farm in the range [0, 1]
		distance_penalty = 2 # when no relevant farm is in reach then apply a penalty of this times the radius

	class TobacconistEvaluator:
		alignment_importance = 0.02 # the larger this value, the larger the effect of alignment on the placement
		farm_distance_importance = 0.3 # importance of the distance to the nearest relevant farm in the range [0, 1]
		distance_penalty = 2 # when no relevant farm is in reach then apply a penalty of this times the radius

	class ModifiedFieldEvaluator:
		add_potato_field_value = 1.5 # the value of adding a potato field
		add_pasture_value = 2.5 # the value of adding a pasture
		add_sugarcane_field_value = 3.5 # the value of adding a sugarcane field
		add_tobacco_field_value = 3.5 # the value of adding a tobacco field
		add_herbary_field_value = 3.5 # the value of adding a herbary
		remove_unused_potato_field_penalty = 0 # the penalty for removing an unused potato field
		remove_unused_pasture_penalty = 1 # the penalty for removing an unused pasture
		remove_unused_sugarcane_field_penalty = 1.5 # the penalty for removing an unused sugarcane field
		remove_unused_tobacco_field_penalty = 1.5 # the penalty for removing an unused tobacco field
		remove_unused_herbary_field_penalty = 1.5 # the penalty for removing an unused herbary

	class FireStationGoal:
		enabled = True
		default_priority = 690
		residences_required = 5
		min_tier = TIER.PIONEERS

	class DoctorGoal:
		enabled = True
		default_priority = 650
		residences_required = 5
		min_tier = TIER.SETTLERS

	class AbstractFireStation:
		fraction_of_assigned_residences_built = 0.4 # build a fire station if at least this amount of the assigned residences have been built

	class AbstractDoctor:
		fraction_of_assigned_residences_built = 0.4 # build a doctor if at least this amount of       the assigned residences have been built

	class AbstractFisher:
		max_options = 30 # maximum number of farm options to consider

########NEW FILE########
__FILENAME__ = other
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from default import DefaultPersonality

class OtherPersonality(DefaultPersonality):
	"""This personality makes the AI build larger settlements."""

	class LandManager(DefaultPersonality.LandManager):
		village_area_small = DefaultPersonality.LandManager.village_area_small * 2 # use this fraction of the area for the village if <= 1600 tiles are available for the settlement
		village_area_40 = DefaultPersonality.LandManager.village_area_40 * 2 # use this fraction of the area for the village if <= 2500 tiles are available for the settlement
		village_area_50 = DefaultPersonality.LandManager.village_area_50 * 2 # use this fraction of the area for the village if <= 3600 tiles are available for the settlement
		village_area_60 = DefaultPersonality.LandManager.village_area_60 * 2 # use this fraction of the area for the village if > 3600 tiles are available for the settlement

########NEW FILE########
__FILENAME__ = personalitymanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.ai.aiplayer.personality import DefaultPersonality, OtherPersonality
from horizons.util.python import decorators

class PersonalityManager(object):
	"""This class handles the loading of personality data for the AI players."""

	log = logging.getLogger("ai.aiplayer.personality_manager")

	def __init__(self, player):
		self.player = player
		self._personality = player.session.random.choice(self.available_personalities)
		self.log.info('%s assigned personality %s', player, self._personality.__name__)

	def save(self, db):
		db("INSERT INTO ai_personality_manager(rowid, personality) VALUES(?, ?)", self.player.worldid, self._personality.__module__ + '.' + self._personality.__name__)

	def _load(self, db, player):
		self.player = player
		self._personality = None
		personality = db("SELECT personality FROM ai_personality_manager WHERE rowid = ?", player.worldid)[0][0]
		for personality_class in self.available_personalities:
			if personality == personality_class.__module__ + '.' + personality_class.__name__:
				self._personality = personality_class
		if self._personality is None:
			self.log.debug('%s had invalid personality %s', self.player, personality)
			self._personality = self.player.session.random.choice(self.available_personalities)
		self.log.info('%s loaded with personality %s', self.player, self._personality.__name__)

	@classmethod
	def load(cls, db, player):
		self = cls.__new__(cls)
		self._load(db, player)
		return self

	def get(self, name):
		"""Return a class that contains the relevant personality constants."""
		return getattr(self._personality, name)

	available_personalities = [] # [personality class, ...]

	@classmethod
	def prepare_personalities_list(cls):
		cls.available_personalities.append(DefaultPersonality)
		cls.available_personalities.append(OtherPersonality)

PersonalityManager.prepare_personalities_list()

decorators.bind_all(PersonalityManager)

########NEW FILE########
__FILENAME__ = productionbuilder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import itertools

from collections import deque
from functools import partial

from areabuilder import AreaBuilder
from constants import BUILD_RESULT, BUILDING_PURPOSE

from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.world.building.production import Mine
from horizons.command.building import Tear
from horizons.command.production import ToggleActive
from horizons.constants import AI, BUILDINGS
from horizons.scheduler import Scheduler
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.shapes import distances, Rect
from horizons.entities import Entities
from horizons.world.production.producer import Producer
from horizons.world.buildability.binarycache import BinaryBuildabilityCache
from horizons.world.buildability.simplecollectorareacache import SimpleCollectorAreaCache
from horizons.world.buildability.potentialroadconnectivitycache import PotentialRoadConnectivityCache
from horizons.component.namedcomponent import NamedComponent

class ProductionBuilder(AreaBuilder):
	"""
	An object of this class manages the production area of a settlement.

	Important attributes:
	* plan: a dictionary of the form {(x, y): (purpose, extra data), ...} where purpose is one of the BUILDING_PURPOSE constants.
		Coordinates being in the plan means that the tile doesn't belong to another player.
	* collector_buildings: a list of every building in the settlement that provides general collectors (warehouse, storages)
	* production_buildings: a list of buildings in the settlement where productions should be paused and resumed at appropriate times
	* unused_fields: a dictionary where the key is a BUILDING_PURPOSE constant of a field and the value is a deque that holds the
		coordinates of unused field spots. {building purpose: deque([(x, y), ...]), ...}
	* last_collector_improvement_storage: the last tick when a storage was built to improve collector coverage
	* last_collector_improvement_road: the last tick when a new road connection was built to improve collector coverage
	"""

	coastal_building_classes = [BUILDINGS.FISHER, BUILDINGS.BOAT_BUILDER, BUILDINGS.SALT_PONDS]

	def __init__(self, settlement_manager):
		super(ProductionBuilder, self).__init__(settlement_manager)
		self.plan = dict.fromkeys(self.land_manager.production, (BUILDING_PURPOSE.NONE, None))
		self.__init(settlement_manager, Scheduler().cur_tick, Scheduler().cur_tick)
		self._init_buildability_cache()
		self._init_simple_collector_area_cache()
		self._init_road_connectivity_cache()
		self.register_change_list(list(settlement_manager.settlement.warehouse.position.tuple_iter()),
		                          BUILDING_PURPOSE.WAREHOUSE, None)
		self._refresh_unused_fields()

	def __init(self, settlement_manager, last_collector_improvement_storage, last_collector_improvement_road):
		self._init_cache()
		self.collector_buildings = [] # [building, ...]
		self.production_buildings = [] # [building, ...]
		self.personality = self.owner.personality_manager.get('ProductionBuilder')
		self.last_collector_improvement_storage = last_collector_improvement_storage
		self.last_collector_improvement_road = last_collector_improvement_road

	def _init_buildability_cache(self):
		self.buildability_cache = BinaryBuildabilityCache(self.island.terrain_cache)
		free_coords_set = set()
		for coords, (purpose, _) in self.plan.iteritems():
			if purpose == BUILDING_PURPOSE.NONE:
				free_coords_set.add(coords)
		for coords in self.land_manager.coastline:
			free_coords_set.add(coords)
		self.buildability_cache.add_area(free_coords_set)

	def _init_simple_collector_area_cache(self):
		self.simple_collector_area_cache = SimpleCollectorAreaCache(self.island.terrain_cache)

	def _init_road_connectivity_cache(self):
		self.road_connectivity_cache = PotentialRoadConnectivityCache(self)
		coords_set = set()
		for coords in self.plan:
			coords_set.add(coords)
		for coords in self.land_manager.roads:
			coords_set.add(coords)
		self.road_connectivity_cache.modify_area(list(sorted(coords_set)))

	def save(self, db):
		super(ProductionBuilder, self).save(db)
		translated_last_collector_improvement_storage = self.last_collector_improvement_storage - Scheduler().cur_tick # pre-translate for the loading process
		translated_last_collector_improvement_road = self.last_collector_improvement_road - Scheduler().cur_tick # pre-translate for the loading process
		db("INSERT INTO ai_production_builder(rowid, settlement_manager, last_collector_improvement_storage, last_collector_improvement_road) VALUES(?, ?, ?, ?)",
			self.worldid, self.settlement_manager.worldid, translated_last_collector_improvement_storage, translated_last_collector_improvement_road)
		for (x, y), (purpose, _) in self.plan.iteritems():
			db("INSERT INTO ai_production_builder_plan(production_builder, x, y, purpose) VALUES(?, ?, ?, ?)", self.worldid, x, y, purpose)

	def _load(self, db, settlement_manager):
		worldid, last_storage, last_road = \
			db("SELECT rowid, last_collector_improvement_storage, last_collector_improvement_road FROM ai_production_builder WHERE settlement_manager = ?",
			settlement_manager.worldid)[0]
		super(ProductionBuilder, self)._load(db, settlement_manager, worldid)
		self.__init(settlement_manager, last_storage, last_road)

		db_result = db("SELECT x, y, purpose FROM ai_production_builder_plan WHERE production_builder = ?", worldid)
		for x, y, purpose in db_result:
			self.plan[(x, y)] = (purpose, None)
			if purpose == BUILDING_PURPOSE.ROAD:
				self.land_manager.roads.add((x, y))
		self._init_buildability_cache()
		self._init_simple_collector_area_cache()
		self._init_road_connectivity_cache()
		self._refresh_unused_fields()

	def have_deposit(self, resource_id):
		"""Returns True if there is a resource deposit of the relevant type inside the settlement."""
		for tile in self.land_manager.resource_deposits[resource_id]:
			if tile.object.settlement is None:
				continue
			coords = tile.object.position.origin.to_tuple()
			if coords in self.settlement.ground_map:
				return True
		return False

	def extend_settlement_with_storage(self, target_position):
		"""Build a storage to extend the settlement towards the given position. Return a BUILD_RESULT constant."""
		if not self.have_resources(BUILDINGS.STORAGE):
			return BUILD_RESULT.NEED_RESOURCES

		storage_class = Entities.buildings[BUILDINGS.STORAGE]
		storage_spots = self.island.terrain_cache.get_buildability_intersection(storage_class.terrain_type,
			storage_class.size, self.settlement.buildability_cache, self.buildability_cache)
		storage_surrounding_offsets = Rect.get_surrounding_offsets(storage_class.size)
		coastline = self.land_manager.coastline

		options = []
		for (x, y) in sorted(storage_spots):
			builder = BasicBuilder.create(BUILDINGS.STORAGE, (x, y), 0)

			alignment = 1
			for (dx, dy) in storage_surrounding_offsets:
				coords = (x + dx, y + dy)
				if coords in coastline or coords not in self.plan or self.plan[coords][0] != BUILDING_PURPOSE.NONE:
					alignment += 1

			distance = distances.distance_rect_rect(target_position, builder.position)
			value = distance - alignment * 0.7
			options.append((-value, builder))
		return self.build_best_option(options, BUILDING_PURPOSE.STORAGE)

	def get_collector_area(self):
		"""Return the set of all coordinates that are reachable from at least one collector by road or open space."""
		if self.__collector_area_cache is not None and self.last_change_id == self.__collector_area_cache[0]:
			return self.__collector_area_cache[1]

		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		collector_area = set() # unused tiles that are reachable from at least one collector
		for building in self.collector_buildings:
			coverage_area = set()
			for coords in building.position.get_radius_coordinates(building.radius, True):
				coverage_area.add(coords)

			reachable = set()
			queue = deque()
			for coords in building.position.tuple_iter():
				reachable.add(coords)
				queue.append(coords)

			while queue:
				x, y = queue.popleft()
				for dx, dy in moves:
					coords = (x + dx, y + dy)
					if coords not in reachable and coords in coverage_area:
						if coords in self.land_manager.roads or (coords in self.plan and coords not in self.land_manager.coastline and self.plan[coords][0] == BUILDING_PURPOSE.NONE):
							queue.append(coords)
							reachable.add(coords)
							if coords in self.plan and self.plan[coords][0] == BUILDING_PURPOSE.NONE:
								collector_area.add(coords)
		self.__collector_area_cache = (self.last_change_id, collector_area)
		return collector_area

	def count_available_squares(self, size, max_num=None):
		"""
		Count the number of available and usable (covered by collectors) size x size squares.

		@param size: the square side length
		@param max_num: if non-None then stop counting once the number of total squares is max_num
		@return: (available squares, total squares)
		"""

		key = (size, max_num)
		if key in self.__available_squares_cache and self.last_change_id == self.__available_squares_cache[key][0]:
			return self.__available_squares_cache[key][1]

		offsets = list(itertools.product(xrange(size), xrange(size)))
		collector_area = self.get_collector_area()

		available_squares = 0
		total_squares = 0
		for x, y in self.plan:
			ok = True
			accessible = False
			for dx, dy in offsets:
				coords = (x + dx, y + dy)
				if coords not in self.plan or self.plan[coords][0] != BUILDING_PURPOSE.NONE:
					ok = False
					break
				if coords in collector_area:
					accessible = True
			if ok:
				total_squares += 1
				if max_num is not None and total_squares >= max_num:
					break
				if accessible:
					available_squares += 1
		self.__available_squares_cache[key] = (self.last_change_id, (available_squares, total_squares))
		return self.__available_squares_cache[key][1]

	def _refresh_unused_fields(self):
		"""Refresh the unused_fields object to make sure no impossible fields spots are in the list."""
		self.unused_fields = {
			BUILDING_PURPOSE.POTATO_FIELD: deque(),
			BUILDING_PURPOSE.PASTURE: deque(),
			BUILDING_PURPOSE.SUGARCANE_FIELD: deque(),
			BUILDING_PURPOSE.TOBACCO_FIELD: deque(),
			BUILDING_PURPOSE.HERBARY: deque(),
		}

		for coords, (purpose, _) in sorted(self.plan.iteritems()):
			usable = True # is every tile of the field spot still usable for new normal buildings
			for dx in xrange(3):
				for dy in xrange(3):
					coords2 = (coords[0] + dx, coords[1] + dy)
					if coords2 not in self.island.ground_map:
						usable = False
					else:
						object = self.island.ground_map[coords2].object
						if object is not None and not object.buildable_upon:
							usable = False
							break
			if usable and purpose in self.unused_fields:
				self.unused_fields[purpose].append(coords)

	def display(self):
		"""Show the plan on the map unless it is disabled in the settings."""
		if not AI.HIGHLIGHT_PLANS:
			return

		tile_colors = {
			BUILDING_PURPOSE.ROAD:            ( 30,  30,  30),
			BUILDING_PURPOSE.FISHER:          (128, 128, 128),
			BUILDING_PURPOSE.LUMBERJACK:      ( 30, 255,  30),
			BUILDING_PURPOSE.TREE:            (  0, 255,   0),
			BUILDING_PURPOSE.FARM:            (128,   0, 255),
			BUILDING_PURPOSE.POTATO_FIELD:    (255,   0, 128),
			BUILDING_PURPOSE.PASTURE:         (  0, 192,   0),
			BUILDING_PURPOSE.WEAVER:          (  0,  64,  64),
			BUILDING_PURPOSE.SUGARCANE_FIELD: (192, 192,   0),
			BUILDING_PURPOSE.DISTILLERY:      (255, 128,  40),
			BUILDING_PURPOSE.TOBACCO_FIELD:   ( 64,  64,   0),
			BUILDING_PURPOSE.TOBACCONIST:     (128,  64,  40),
			BUILDING_PURPOSE.CLAY_PIT:        (  0,  64,   0),
			BUILDING_PURPOSE.BRICKYARD:       (  0,  32,   0),
			BUILDING_PURPOSE.BOAT_BUILDER:    (163,  73, 164),
			BUILDING_PURPOSE.SALT_PONDS:      (153, 217, 234),
			BUILDING_PURPOSE.HERBARY:         ( 64, 200,   0),
			BUILDING_PURPOSE.RESERVED:        (  0,   0, 128),
		}

		misc_color = (0, 255, 255)
		unknown_color = (128, 0, 0)
		renderer = self.session.view.renderer['InstanceRenderer']

		for coords, (purpose, _) in self.plan.iteritems():
			tile = self.island.ground_map[coords]
			color = tile_colors.get(purpose, misc_color)
			if purpose == BUILDING_PURPOSE.NONE:
				color = unknown_color
			renderer.addColored(tile._instance, *color)

	def _init_cache(self):
		"""Initialize the cache that knows the last time the buildability of a rectangle may have changed in this area."""
		super(ProductionBuilder, self)._init_cache()
		self.__collector_area_cache = None
		self.__available_squares_cache = {}

	def register_change(self, x, y, purpose, data):
		"""Register the possible buildability change of a rectangle on this island."""
		super(ProductionBuilder, self).register_change(x, y, purpose, data)
		coords = (x, y)
		if coords in self.land_manager.village or (coords not in self.plan and coords not in self.land_manager.coastline):
			return
		self.last_change_id += 1

	def register_change_list(self, coords_list, purpose, data):
		add_list = []
		remove_list = []
		for coords in coords_list:
			if coords in self.land_manager.village or coords not in self.plan:
				continue
			if purpose == BUILDING_PURPOSE.NONE and self.plan[coords][0] != BUILDING_PURPOSE.NONE:
				add_list.append(coords)
			elif purpose != BUILDING_PURPOSE.NONE and self.plan[coords][0] == BUILDING_PURPOSE.NONE:
				remove_list.append(coords)
		if add_list:
			self.buildability_cache.add_area(add_list)
		if remove_list:
			self.buildability_cache.remove_area(remove_list)

		super(ProductionBuilder, self).register_change_list(coords_list, purpose, data)
		self.road_connectivity_cache.modify_area(coords_list)
		self.display()

	def handle_lost_area(self, coords_list):
		"""Handle losing the potential land in the given coordinates list."""
		# remove planned fields that are now impossible
		lost_coords_list = []
		for coords in coords_list:
			if coords in self.plan:
				lost_coords_list.append(coords)
		self.register_change_list(lost_coords_list, BUILDING_PURPOSE.NONE, None)

		field_size = Entities.buildings[BUILDINGS.POTATO_FIELD].size
		removed_list = []
		for coords, (purpose, _) in self.plan.iteritems():
			if purpose in [BUILDING_PURPOSE.POTATO_FIELD, BUILDING_PURPOSE.PASTURE, BUILDING_PURPOSE.SUGARCANE_FIELD, BUILDING_PURPOSE.TOBACCO_FIELD, BUILDING_PURPOSE.HERBARY]:
				rect = Rect.init_from_topleft_and_size_tuples(coords, field_size)
				for field_coords in rect.tuple_iter():
					if field_coords not in self.land_manager.production:
						removed_list.append(coords)
						break

		for coords in removed_list:
			rect = Rect.init_from_topleft_and_size_tuples(coords, field_size)
			self.register_change_list(list(rect.tuple_iter()), BUILDING_PURPOSE.NONE, None)
		self._refresh_unused_fields()
		super(ProductionBuilder, self).handle_lost_area(coords_list)
		self.road_connectivity_cache.modify_area(lost_coords_list)

	def handle_new_area(self):
		"""Handle receiving more land to the production area (this can happen when the village area gives some up)."""
		new_coords_list = []
		for coords in self.land_manager.production:
			if coords not in self.plan:
				new_coords_list.append(coords)
		self.register_change_list(new_coords_list, BUILDING_PURPOSE.NONE, None)

	collector_building_classes = [BUILDINGS.WAREHOUSE, BUILDINGS.STORAGE]
	field_building_classes = [BUILDINGS.POTATO_FIELD, BUILDINGS.PASTURE, BUILDINGS.SUGARCANE_FIELD, BUILDINGS.TOBACCO_FIELD]
	production_building_classes = set([BUILDINGS.FISHER, BUILDINGS.LUMBERJACK, BUILDINGS.FARM, BUILDINGS.CLAY_PIT,
		BUILDINGS.BRICKYARD, BUILDINGS.WEAVER, BUILDINGS.DISTILLERY, BUILDINGS.MINE, BUILDINGS.SMELTERY,
		BUILDINGS.TOOLMAKER, BUILDINGS.CHARCOAL_BURNER, BUILDINGS.TOBACCONIST, BUILDINGS.SALT_PONDS])

	def add_building(self, building):
		"""Called when a new building is added in the area (the building already exists during the call)."""
		if building.id in self.collector_building_classes:
			self.collector_buildings.append(building)
			self.simple_collector_area_cache.add_building(building)
		elif building.id in self.production_building_classes:
			self.production_buildings.append(building)

		super(ProductionBuilder, self).add_building(building)

	def _handle_lumberjack_removal(self, building):
		"""Release the unused trees around the lumberjack building being removed."""
		trees_used_by_others = set()
		for lumberjack_building in self.settlement.buildings_by_id.get(BUILDINGS.LUMBERJACK, []):
			if lumberjack_building.worldid == building.worldid:
				continue
			for coords in lumberjack_building.position.get_radius_coordinates(lumberjack_building.radius):
				if coords in self.plan and self.plan[coords][0] == BUILDING_PURPOSE.TREE:
					trees_used_by_others.add(coords)

		coords_list = []
		for coords in building.position.get_radius_coordinates(building.radius):
			if coords not in trees_used_by_others and coords in self.plan and self.plan[coords][0] == BUILDING_PURPOSE.TREE:
				coords_list.append(coords)
		self.register_change_list(coords_list, BUILDING_PURPOSE.NONE, None)

	def _handle_farm_removal(self, building):
		"""Handle farm removal by removing planned fields and tearing existing ones that can't be serviced by another farm."""
		unused_fields = set()
		farms = self.settlement.buildings_by_id.get(BUILDINGS.FARM, [])
		for coords in building.position.get_radius_coordinates(building.radius):
			if not coords in self.plan:
				continue
			object = self.island.ground_map[coords].object
			if object is None or object.id not in self.field_building_classes:
				continue

			used_by_another_farm = False
			for farm in farms:
				if farm.worldid != building.worldid and object.position.distance(farm.position) <= farm.radius:
					used_by_another_farm = True
					break
			if not used_by_another_farm:
				unused_fields.add(object)

		# tear the finished but no longer used fields down
		for unused_field in unused_fields:
			self.register_change_list(list(unused_field.position.tuple_iter()), BUILDING_PURPOSE.NONE, None)
			Tear(unused_field).execute(self.session)

		# remove the planned but never built fields from the plan
		self._refresh_unused_fields()
		for unused_fields_list in self.unused_fields.itervalues():
			for coords in unused_fields_list:
				position = Rect.init_from_topleft_and_size_tuples(coords, Entities.buildings[BUILDINGS.POTATO_FIELD].size)
				if building.position.distance(position) > building.radius:
					continue # it never belonged to the removed building

				used_by_another_farm = False
				for farm in farms:
					if farm.worldid != building.worldid and position.distance(farm.position) <= farm.radius:
						used_by_another_farm = True
						break
				if not used_by_another_farm:
					self.register_change_list(list(position.tuple_iter()), BUILDING_PURPOSE.NONE, None)
		self._refresh_unused_fields()

	def remove_building(self, building):
		"""Called when a building is removed from the area (the building still exists during the call)."""
		if building.id in self.field_building_classes:
			# this can't be handled right now because the building still exists
			Scheduler().add_new_object(Callback(self._refresh_unused_fields), self, run_in=0)
			Scheduler().add_new_object(Callback(partial(super(ProductionBuilder, self).remove_building, building)), self, run_in=0)
		elif building.buildable_upon or building.id == BUILDINGS.TRAIL:
			pass # don't react to road, trees and ruined tents being destroyed
		else:
			self.register_change_list(list(building.position.tuple_iter()), BUILDING_PURPOSE.NONE, None)

			if building.id in self.collector_building_classes:
				self.collector_buildings.remove(building)
				self.simple_collector_area_cache.remove_building(building)
			elif building.id in self.production_building_classes:
				self.production_buildings.remove(building)

			if building.id == BUILDINGS.LUMBERJACK:
				self._handle_lumberjack_removal(building)
			elif building.id == BUILDINGS.FARM:
				self._handle_farm_removal(building)

			super(ProductionBuilder, self).remove_building(building)

	def manage_production(self):
		"""Pauses and resumes production buildings when they have full input and output inventories."""
		for building in self.production_buildings:
			producer = building.get_component(Producer)
			for production in producer.get_productions():
				if not production.get_produced_resources():
					continue
				all_full = True

				# inventory full of the produced resources?
				for resource_id, min_amount in production.get_produced_resources().iteritems():
					if production.inventory.get_free_space_for(resource_id) >= min_amount:
						all_full = False
						break

				# inventory full of the input resource?
				if all_full and not isinstance(building, Mine):
					for resource_id in production.get_consumed_resources():
						if production.inventory.get_free_space_for(resource_id) > 0:
							all_full = False
							break

				if all_full:
					if not production.is_paused():
						ToggleActive(producer, production).execute(self.land_manager.session)
						self.log.info('%s paused a production at %s/%d', self, building.name, building.worldid)
				else:
					if production.is_paused():
						ToggleActive(producer, production).execute(self.land_manager.session)
						self.log.info('%s resumed a production at %s/%d', self, building.name, building.worldid)

	def handle_mine_empty(self, mine):
		Tear(mine).execute(self.session)
		self.land_manager.refresh_resource_deposits()

	def __str__(self):
		return '%s.PB(%s/%s)' % (self.owner, self.settlement.get_component(NamedComponent).name if hasattr(self, 'settlement') else 'unknown',
			self.worldid if hasattr(self, 'worldid') else 'none')

decorators.bind_all(ProductionBuilder)

########NEW FILE########
__FILENAME__ = productionchain
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.ai.aiplayer.constants import BUILD_RESULT
from horizons.constants import RES
from horizons.util.python import decorators

class ProductionChain(object):
	"""
	A production chain handles the building of buildings required to produce a resource.

	Production chains use the list of production lines and the available AbstractBuilding
	subclasses to figure out all ways of producing a certain resource and finding the
	right ratio of them to produce just enough of the resource. The result is a tree
	that can be used to produce the required resource.

	Each subtree reserves a portion of the total capacity of the buildings of the relevant
	type. This is a logical classification and doesn't affect the actual buildings in any way.
	Some subtrees can import the required resource from other islands using a mechanism
	similar to the previous one but in that case it acts as if the resource was produced
	without any subtrees. The imported amounts are added up over time and saved as an owed
	resource in the exporting settlement's resource manager (these restrictions are again
	just logical without affecting the way the settlements work in any way). That storage
	is realized by organizing DomesticTrade missions that transfer the resources to the
	right settlements.
	"""

	log = logging.getLogger("ai.aiplayer.productionchain")

	def __init__(self, settlement_manager, resource_id, resource_producer):
		super(ProductionChain, self).__init__()
		self.settlement_manager = settlement_manager
		self.resource_id = resource_id
		self.chain = self._get_chain(resource_id, resource_producer, 1.0)
		self.chain.assign_identifier('/%d,%d' % (self.settlement_manager.worldid, self.resource_id))

	def _get_chain(self, resource_id, resource_producer, production_ratio):
		"""Return a ProductionChainSubtreeChoice if it is possible to produce the resource, None otherwise."""
		options = []
		if resource_id in resource_producer:
			for production_line, abstract_building in resource_producer[resource_id]:
				possible = True
				sources = []
				for consumed_resource, amount in production_line.consumed_res.iteritems():
					next_production_ratio = abs(production_ratio * amount / production_line.produced_res[resource_id])
					subtree = self._get_chain(consumed_resource, resource_producer, next_production_ratio)
					if not subtree:
						possible = False
						break
					sources.append(subtree)
				if possible:
					options.append(ProductionChainSubtree(self.settlement_manager, resource_id, production_line, abstract_building, sources, production_ratio))
		if not options:
			return None
		return ProductionChainSubtreeChoice(options)

	@classmethod
	def create(cls, settlement_manager, resource_id):
		"""Create a production chain that can produce the given resource."""
		resource_producer = {}
		for abstract_building in AbstractBuilding.buildings.itervalues():
			for resource, production_line in abstract_building.lines.iteritems():
				if resource not in resource_producer:
					resource_producer[resource] = []
				resource_producer[resource].append((production_line, abstract_building))
		return ProductionChain(settlement_manager, resource_id, resource_producer)

	def __str__(self):
		return 'ProductionChain(%d): %.5f\n%s' % (self.resource_id, self.get_final_production_level(), self.chain)

	def build(self, amount):
		"""Build a building that gets it closer to producing at least the given amount of resource per tick."""
		return self.chain.build(amount)

	def reserve(self, amount, may_import):
		"""Reserve currently available production capacity and import from other islands if allowed."""
		return self.chain.reserve(amount, may_import)

	def need_to_build_more_buildings(self, amount):
		"""Return a boolean showing whether more buildings need to be built in order to produce at least amount of resource per tick."""
		return self.chain.need_to_build_more_buildings(amount)

	def get_final_production_level(self):
		"""Return the production level per tick at the bottleneck."""
		return self.chain.get_final_production_level()

	def get_ratio(self, resource_id):
		"""Return the ratio of the given resource needed given that 1 unit of the root resource is required."""
		return self.chain.get_ratio(resource_id)

class ProductionChainSubtreeChoice(object):
	"""An object of this class represents a choice between N >= 1 ways of producing the required resource."""

	log = logging.getLogger("ai.aiplayer.productionchain")
	coverage_resources = set([RES.COMMUNITY, RES.FAITH, RES.EDUCATION, RES.GET_TOGETHER])

	def __init__(self, options):
		super(ProductionChainSubtreeChoice, self).__init__()
		self.options = options # [ProductionChainSubtree, ...]
		self.resource_id = options[0].resource_id # the required resource
		self.production_ratio = options[0].production_ratio # given that 1 unit has to be produced at the root of the tree, how much has to be produced here?
		self.ignore_production = options[0].ignore_production # whether to try to build more buildings even when the required production capacity has been reached
		self.trade_manager = options[0].trade_manager # TradeManager instance
		self.settlement_manager = options[0].settlement_manager # SettlementManager instance

	def assign_identifier(self, prefix):
		"""Recursively assign an identifier to this subtree to know which subtree owns which resource quota."""
		self.identifier = prefix + ('/choice' if len(self.options) > 1 else '')
		for option in self.options:
			option.assign_identifier(self.identifier)

	def __str__(self, level=0):
		result = '%sChoice between %d options: %.5f\n' % ('  ' * level, len(self.options), self.get_final_production_level())
		for option in self.options:
			result += option.__str__(level + 1)
		if self.get_root_import_level() > 1e-9:
			result += '\n%sImport %.5f' % ('  ' * (level + 1), self.get_root_import_level())
		return result

	def get_root_import_level(self):
		"""Return the amount of the resource imported per tick."""
		return self.trade_manager.get_quota(self.identifier, self.resource_id) / self.production_ratio

	def get_final_production_level(self):
		"""Return the total reserved production capacity of the resource per tick (includes import)."""
		return sum(option.get_final_production_level() for option in self.options) + self.get_root_import_level()

	def get_expected_cost(self, amount):
		"""Return the expected utility cost of building enough buildings to produce a total of the given amount of the resource per tick."""
		return min(option.get_expected_cost(amount) for option in self.options)

	def _get_available_options(self):
		"""Return a list of the currently available options to produce the resource."""
		available_options = []
		for option in self.options:
			if option.available:
				available_options.append(option)
		return available_options

	def build(self, amount):
		"""Try to build a building in the subtree that is currently the cheapest. Return a BUILD_RESULT constant."""
		current_production = self.get_final_production_level()
		if amount < current_production + 1e-7 and self.resource_id not in self.coverage_resources:
			# we are already producing enough
			return BUILD_RESULT.ALL_BUILT

		available_options = self._get_available_options()
		if not available_options:
			self.log.debug('%s: no available options', self)
			return BUILD_RESULT.IMPOSSIBLE
		elif len(available_options) == 1:
			return available_options[0].build(amount)

		# need to increase production: build the cheapest subtree
		expected_costs = []
		for i, option in enumerate(available_options):
			cost = option.get_expected_cost(amount - current_production + option.get_final_production_level())
			if cost is not None:
				expected_costs.append((cost, i, option))

		if not expected_costs:
			self.log.debug('%s: no possible options', self)
			return BUILD_RESULT.IMPOSSIBLE
		else:
			for option in zip(*sorted(expected_costs))[2]:
				result = option.build(amount) # TODO: this amount should not include the part provided by the other options
				if result != BUILD_RESULT.IMPOSSIBLE:
					return result
			return BUILD_RESULT.IMPOSSIBLE

	def reserve(self, amount, may_import):
		"""Reserve currently available production capacity and import from other islands if allowed. Returns the total amount it can reserve or import."""
		total_reserved = 0.0
		for option in self._get_available_options():
			total_reserved += option.reserve(max(0.0, amount - total_reserved), may_import)

		# check how much we can import
		if may_import:
			required_amount = max(0.0, amount - total_reserved)
			self.trade_manager.request_quota_change(self.identifier, self.resource_id, required_amount * self.production_ratio)
			total_reserved += self.get_root_import_level()

		return total_reserved

	def need_to_build_more_buildings(self, amount):
		"""Return a boolean showing whether more buildings need to be built in order to produce at least the given amount of resource per tick."""
		current_production = self.get_final_production_level()
		if self.resource_id not in self.coverage_resources:
			return current_production + 1e-7 <= amount
		for option in self._get_available_options():
			if option.need_to_build_more_buildings(amount):
				return True
		return False

	def get_ratio(self, resource_id):
		"""Return the ratio of the given resource needed given that 1 unit of the root resource is required."""
		return sum(option.get_ratio(resource_id) for option in self.options)

class ProductionChainSubtree(object):
	"""An object of this type represents a subtree of buildings that need to be built in order to produce the given resource."""

	def __init__(self, settlement_manager, resource_id, production_line, abstract_building, children, production_ratio):
		super(ProductionChainSubtree, self).__init__()
		self.settlement_manager = settlement_manager # SettlementManager instance
		self.resource_manager = settlement_manager.resource_manager # ResourceManager instance
		self.trade_manager = settlement_manager.trade_manager # TradeManager instance
		self.resource_id = resource_id # the required resource
		self.production_line = production_line # ProductionLine instance
		self.abstract_building = abstract_building # AbstractBuilding instance
		self.children = children # [ProductionChainSubtreeChoice, ...]
		self.production_ratio = production_ratio # given that 1 unit has to be produced at the root of the tree, how much has to be produced here?
		self.ignore_production = abstract_building.ignore_production # whether to try to build more buildings even when the required production capacity has been reached

	def assign_identifier(self, prefix):
		"""Recursively assign an identifier to this subtree to know which subtree owns which resource quota."""
		self.identifier = '%s/%d,%d' % (prefix, self.resource_id, self.abstract_building.id)
		for child in self.children:
			child.assign_identifier(self.identifier)

	@property
	def available(self):
		"""Return a boolean showing whether this subtree is currently available."""
		return self.settlement_manager.owner.settler_level >= self.abstract_building.settler_level

	def __str__(self, level=0):
		result = '%sProduce %d (ratio %.2f) in %s (%.5f, %.5f)\n' % ('  ' * level, self.resource_id,
			self.production_ratio, self.abstract_building.name, self.get_root_production_level(), self.get_final_production_level())
		for child in self.children:
			result += child.__str__(level + 1)
		return result

	def get_expected_children_cost(self, amount):
		"""Return the expected utility cost of building enough buildings in the subtrees to produce a total of the given amount of the resource per tick."""
		total = 0
		for child in self.children:
			cost = child.get_expected_cost(amount)
			if cost is None:
				return None
			total += cost
		return total

	def get_expected_cost(self, amount):
		"""Return the expected utility cost of building enough buildings to produce a total of the given amount of the resource per tick."""
		children_cost = self.get_expected_children_cost(amount)
		if children_cost is None:
			return None

		production_needed = (amount - self.get_root_production_level()) * self.production_ratio
		root_cost = self.abstract_building.get_expected_cost(self.resource_id, production_needed, self.settlement_manager)
		if root_cost is None:
			return None
		return children_cost + root_cost

	def get_root_production_level(self):
		"""Return the currently reserved production capacity of this subtree at the root."""
		return self.resource_manager.get_quota(self.identifier, self.resource_id, self.abstract_building.id) / self.production_ratio

	def get_final_production_level(self):
		"""Return the currently reserved production capacity at the bottleneck."""
		min_child_production = None
		for child in self.children:
			if child.ignore_production:
				continue
			production_level = child.get_final_production_level()
			if min_child_production is None:
				min_child_production = production_level
			else:
				min_child_production = min(min_child_production, production_level)
		if min_child_production is None:
			return self.get_root_production_level()
		else:
			return min(min_child_production, self.get_root_production_level())

	def need_more_buildings(self, amount):
		"""Return a boolean showing whether more buildings of this specific type need to be built in order to produce at least the given amount of resource per tick."""
		if not self.abstract_building.directly_buildable:
			return False # building must be triggered by children instead
		if self.abstract_building.coverage_building:
			return True
		return amount > self.get_root_production_level() + 1e-7

	def build(self, amount):
		"""Build a building in order to get closer to the goal of producing at least the given amount of resource per tick at the bottleneck."""
		# try to build one of the lower level buildings (results in a depth first order)
		result = None
		for child in self.children:
			result = child.build(amount)
			if result == BUILD_RESULT.ALL_BUILT:
				continue # build another child or build this building
			elif result == BUILD_RESULT.NEED_PARENT_FIRST:
				break # parent building has to be built before child (example: farm before field)
			else:
				return result # an error or successful building

		if result == BUILD_RESULT.NEED_PARENT_FIRST or self.need_more_buildings(amount):
			# build a building
			(result, building) = self.abstract_building.build(self.settlement_manager, self.resource_id)
			if result == BUILD_RESULT.OUT_OF_SETTLEMENT:
				return self.settlement_manager.production_builder.extend_settlement(building)
			return result
		return BUILD_RESULT.ALL_BUILT

	def reserve(self, amount, may_import):
		"""Reserve currently available production capacity and import from other islands if allowed. Returns the total amount it can reserve or import."""
		total_reserved = amount
		for child in self.children:
			total_reserved = min(total_reserved, child.reserve(amount, may_import))

		self.resource_manager.request_quota_change(self.identifier, True, self.resource_id, self.abstract_building.id, amount * self.production_ratio)
		total_reserved = min(total_reserved, self.resource_manager.get_quota(self.identifier, self.resource_id, self.abstract_building.id) / self.production_ratio)
		return total_reserved

	def need_to_build_more_buildings(self, amount):
		"""Return a boolean showing whether more buildings in this subtree need to be built in order to produce at least the given amount of resource per tick."""
		for child in self.children:
			if child.need_to_build_more_buildings(amount):
				return True
		if not self.need_more_buildings(amount):
			return False
		return self.abstract_building.need_to_build_more_buildings(self.settlement_manager, self.resource_id)

	def get_ratio(self, resource_id):
		"""Return the ratio of the given resource needed given that 1 unit of the root resource is required."""
		result = self.production_ratio if self.resource_id == resource_id else 0
		return result + sum(child.get_ratio(resource_id) for child in self.children)

decorators.bind_all(ProductionChain)
decorators.bind_all(ProductionChainSubtreeChoice)
decorators.bind_all(ProductionChainSubtree)

########NEW FILE########
__FILENAME__ = resourcemanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import math

from collections import defaultdict

from horizons.ai.aiplayer.building import AbstractBuilding
from horizons.util.worldobject import WorldObject
from horizons.util.python import decorators
from horizons.constants import BUILDINGS, RES, TRADER
from horizons.command.uioptions import SetTradeSlot, ClearTradeSlot
from horizons.component.storagecomponent import StorageComponent
from horizons.component.tradepostcomponent import TradePostComponent
from horizons.component.namedcomponent import NamedComponent
from horizons.world.settlement import Settlement

class ResourceManager(WorldObject):
	"""
	An object of this class manages production capacity and keeps track of over/under stock.

	The main task of this class is to keep track of the available and used production capacity.
	That knowledge is used to figure out how much of the settlement's production
	capacity is being exported and the relevant data is saved accordingly.

	The other important task of this class is to keep track of how much resources the
	settlement should have in inventory and how much it actually has.
	That data is used by this class to make buy/sell decisions in this settlement,
	by InternationalTradeManager to decide which resources to buy/sell at other players'
	warehouses and by SpecialDomesticTradeManager to decide which resources to transfer
	between the player's settlements in order to make best use of them.

	Currently the quota priority system works by assigning local requests a high priority
	and the export requests a low priority which should minimize the amount of resources
	that have to be transferred.

	The division of resources and production capacities is purely logical and does not
	affect the way the actual game works.
	"""

	def __init__(self, settlement_manager):
		super(ResourceManager, self).__init__()
		self.__init(settlement_manager)

	def __init(self, settlement_manager):
		self.settlement_manager = settlement_manager
		self._data = {} # {(resource_id, building_id): SingleResourceManager, ...}
		self._chain = {} # {resource_id: SimpleProductionChainSubtreeChoice, ...} (cache that doesn't have to be saved)
		self._low_priority_requests = {} # {(quota_holder, resource_id): amount, ...} (only used during 1 tick, doesn't have to be saved)
		self._settlement_manager_id = {} # {quota_holder: settlement_manager_id, ...} (cache that doesn't have to be saved)
		self.trade_storage = defaultdict(lambda: defaultdict(int)) # {settlement_manager_id: {resource_id: float(amount)}, ...} shows how much of a resource is reserved for a particular settlement
		self.resource_requirements = {} # {resource_id: int(amount), ...} the amount of resource the settlement would like to have in inventory (used to make buy/sell decisions)
		self.personality = self.settlement_manager.owner.personality_manager.get('ResourceManager')

	def save(self, db):
		super(ResourceManager, self).save(db)
		db("INSERT INTO ai_resource_manager(rowid, settlement_manager) VALUES(?, ?)", self.worldid, self.settlement_manager.worldid)
		for resource_manager in self._data.itervalues():
			resource_manager.save(db, self.worldid)
		for settlement_manager_id, reserved_storage in self.trade_storage.iteritems():
			for resource_id, amount in reserved_storage.iteritems():
				if amount > 1e-9:
					db("INSERT INTO ai_resource_manager_trade_storage(resource_manager, settlement_manager, resource, amount) VALUES(?, ?, ?, ?)",
					   self.worldid, settlement_manager_id, resource_id, amount)
		for resource_id, amount in self.resource_requirements.iteritems():
			db("INSERT INTO ai_resource_manager_requirement(resource_manager, resource, amount) VALUES(?, ?, ?)", self.worldid, resource_id, amount)

	def _load(self, db, settlement_manager):
		worldid = db("SELECT rowid FROM ai_resource_manager WHERE settlement_manager = ?", settlement_manager.worldid)[0][0]
		super(ResourceManager, self).load(db, worldid)
		self.__init(settlement_manager)
		for db_row in db("SELECT rowid, resource_id, building_id FROM ai_single_resource_manager WHERE resource_manager = ?", worldid):
			self._data[(db_row[1], db_row[2])] = SingleResourceManager.load(db, settlement_manager, db_row[0])
		for db_row in db("SELECT settlement_manager, resource, amount FROM ai_resource_manager_trade_storage WHERE resource_manager = ?", worldid):
			self.trade_storage[db_row[0]][db_row[1]] = db_row[2]
		for db_row in db("SELECT resource, amount FROM ai_resource_manager_requirement WHERE resource_manager = ?", worldid):
			self.resource_requirements[db_row[0]] = db_row[1]

	@classmethod
	def load(cls, db, settlement_manager):
		self = cls.__new__(cls)
		self._load(db, settlement_manager)
		return self

	def _get_chain(self, resource_id, resource_producer, production_ratio):
		"""Return a SimpleProductionChainSubtreeChoice or None if it impossible to produce the resource."""
		options = []
		if resource_id in resource_producer:
			for production_line, abstract_building in resource_producer[resource_id]:
				possible = True
				sources = []
				for consumed_resource, amount in production_line.consumed_res.iteritems():
					next_production_ratio = abs(production_ratio * amount / production_line.produced_res[resource_id])
					subtree = self._get_chain(consumed_resource, resource_producer, next_production_ratio)
					if not subtree:
						possible = False
						break
					sources.append(subtree)
				if possible:
					options.append(SimpleProductionChainSubtree(self, resource_id, production_line, abstract_building, sources, production_ratio))
		if not options:
			return None
		return SimpleProductionChainSubtreeChoice(options)

	def _make_chain(self, resource_id):
		"""Return a SimpleProductionChainSubtreeChoice that knows how to produce the resource."""
		resource_producer = {}
		for abstract_building in AbstractBuilding.buildings.itervalues():
			for resource, production_line in abstract_building.lines.iteritems():
				if resource not in resource_producer:
					resource_producer[resource] = []
				resource_producer[resource].append((production_line, abstract_building))
		chain = self._get_chain(resource_id, resource_producer, 1.0)
		chain.assign_identifier('')
		return chain

	def refresh(self):
		"""Refresh the actual production capacity of the buildings and lower quotas if necessary."""
		for resource_manager in self._data.itervalues():
			resource_manager.refresh()

	def request_quota_change(self, quota_holder, priority, resource_id, building_id, amount):
		"""
		Request that the quota of quota_holder be changed to the given amount for the specific resource/building pair.

		@param quota_holder: a string identifying the quota holder (persistent over save/load cycles)
		@param priority: boolean showing whether this quota has high priority (high priority means that low priority quotas can be lowered if necessary)
		@param resource_id: the required resource
		@param building_id: the type of building where this capacity should be gotten from
		@param amount: the amount of resource per tick that is needed
		"""

		key = (resource_id, building_id)
		if key not in self._data:
			self._data[key] = SingleResourceManager(self.settlement_manager, resource_id, building_id)
		self._data[key].request_quota_change(quota_holder, priority, amount)

	def get_quota(self, quota_holder, resource_id, building_id):
		"""Return the current quota given the resource and the type of building that should produce it."""
		key = (resource_id, building_id)
		if key not in self._data:
			self._data[key] = SingleResourceManager(self.settlement_manager, resource_id, building_id)
		return self._data[key].get_quota(quota_holder)

	def request_deep_quota_change(self, quota_holder, priority, resource_id, amount):
		"""Request that the quota of quota_holder be changed to the given amount recursively."""
		if resource_id not in self._chain:
			self._chain[resource_id] = self._make_chain(resource_id)
		actual_amount = self._chain[resource_id].request_quota_change(quota_holder, amount, priority)
		if not priority:
			self._low_priority_requests[(quota_holder, resource_id)] = actual_amount
		if actual_amount + 1e-9 < amount:
			# release excess production that can't be used
			self._chain[resource_id].request_quota_change(quota_holder, actual_amount, priority)
		return actual_amount

	def get_deep_quota(self, quota_holder, resource_id):
		"""Return the current quota at the bottleneck."""
		if resource_id not in self._chain:
			self._chain[resource_id] = self._make_chain(resource_id)
		return self._chain[resource_id].get_quota(quota_holder)

	def replay_deep_low_priority_requests(self):
		"""Retry adding low priority quota requests. This is required to make the feeder island mechanism work."""
		for (quota_holder, resource_id), amount in self._low_priority_requests.iteritems():
			self.request_deep_quota_change(quota_holder, False, resource_id, amount)

	def record_expected_exportable_production(self, ticks):
		"""Record the amount of production that should be transferred to other islands."""
		for (quota_holder, resource_id), amount in self._low_priority_requests.iteritems():
			if quota_holder not in self._settlement_manager_id:
				self._settlement_manager_id[quota_holder] = WorldObject.get_object_by_id(int(quota_holder[1:].split(',')[0])).settlement_manager.worldid
			self.trade_storage[self._settlement_manager_id[quota_holder]][resource_id] += ticks * amount

	def get_total_export(self, resource_id):
		"""Return the total amount of the given resource being (logically) exported per tick."""
		total = 0
		for resource_manager in self._data.itervalues():
			if resource_manager.resource_id == resource_id:
				total += resource_manager.get_total_export()
		return total

	def get_total_trade_storage(self, resource_id):
		"""Return the amount of the given resource that should be kept aside for other settlements."""
		total = 0
		for settlement_storage in self.trade_storage.itervalues():
			for stored_resource_id, amount in settlement_storage.iteritems():
				if stored_resource_id == resource_id:
					total += amount
		return int(math.ceil(total))

	def get_default_resource_requirement(self, resource_id):
		"""Return the default amount of resource that should be in the settlement inventory."""
		if resource_id in [RES.TOOLS, RES.BOARDS]:
			return self.personality.default_resource_requirement
		elif resource_id == RES.CANNON and self.settlement_manager.settlement.count_buildings(BUILDINGS.BOAT_BUILDER) \
			and self.settlement_manager.settlement.owner.need_more_combat_ships:
			return self.personality.default_cannon_requirement
		elif self.settlement_manager.feeder_island and resource_id == RES.BRICKS:
			return self.personality.default_feeder_island_brick_requirement if self.settlement_manager.owner.settler_level > 0 else 0
		elif not self.settlement_manager.feeder_island and resource_id == RES.FOOD:
			return self.personality.default_food_requirement
		return 0

	def get_unit_building_costs(self, resource_id):
		return 0 # TODO: take into account all the resources that are needed to build units

	def get_required_upgrade_resources(self, resource_id, upgrade_limit):
		"""Return the amount of resource still needed to upgrade at most upgrade_limit residences."""
		limit_left = upgrade_limit
		needed = 0
		for residence in self.settlement_manager.settlement.buildings_by_id.get(BUILDINGS.RESIDENTIAL, []):
			if limit_left <= 0:
				break
			production = residence._upgrade_production
			if production is None or production.is_paused():
				continue
			for res, amount in production.get_consumed_resources().iteritems():
				if res == resource_id and residence.get_component(StorageComponent).inventory[resource_id] < abs(amount):
					# TODO: take into account the residence's collector
					needed += abs(amount) - residence.get_component(StorageComponent).inventory[resource_id]
					limit_left -= 1
		return needed

	def get_required_building_resources(self, resource_id):
		return 0 # TODO

	def get_current_resource_requirement(self, resource_id):
		"""Return the amount of resource that should be in the settlement inventory to provide for all needs."""
		currently_reserved = self.get_total_trade_storage(resource_id)
		future_reserve = int(math.ceil(self.get_total_export(resource_id) * self.personality.reserve_time))
		current_usage = int(math.ceil(self.settlement_manager.get_resource_production_requirement(resource_id) * self.personality.reserve_time))
		unit_building_costs = self.get_unit_building_costs(resource_id)
		upgrade_costs = self.get_required_upgrade_resources(resource_id, self.personality.max_upgraded_houses)
		building_costs = self.get_required_building_resources(resource_id)

		total_needed = currently_reserved + future_reserve + current_usage + unit_building_costs + upgrade_costs + building_costs
		return max(total_needed, self.get_default_resource_requirement(resource_id))

	def manager_buysell(self):
		"""Calculate the required inventory levels and make buy/sell decisions based on that."""
		managed_resources = [RES.TOOLS, RES.BOARDS, RES.BRICKS, RES.FOOD, RES.TEXTILE, RES.LIQUOR, RES.TOBACCO_PRODUCTS, RES.SALT, RES.CANNON, RES.MEDICAL_HERBS]
		settlement = self.settlement_manager.settlement
		assert isinstance(settlement, Settlement)
		inventory = settlement.get_component(StorageComponent).inventory
		session = self.settlement_manager.session
		gold = self.settlement_manager.owner.get_component(StorageComponent).inventory[RES.GOLD]

		buy_sell_list = [] # [(importance (lower is better), resource_id, limit, sell), ...]
		for resource_id in managed_resources:
			current_requirement = self.get_current_resource_requirement(resource_id)
			self.resource_requirements[resource_id] = current_requirement
			max_buy = int(round(current_requirement * self.personality.buy_threshold)) # when to stop buying
			if 0 < current_requirement <= self.personality.low_requirement_threshold: # avoid not buying resources when very little is needed in the first place
				max_buy = current_requirement
			min_sell = int(round(current_requirement * self.personality.sell_threshold)) # when to start selling

			if inventory[resource_id] < max_buy:
				# have 0, need 100, max_buy 67, importance -0.0434
				# have 0, need 30, max_buy 20, importance -0.034
				# have 10, need 30, max_buy 20, importance 0.288
				# have 19, need 30, max_buy 20, importance 0.578
				# have 66, need 100, max_buy 67, importance 0.610
				importance = inventory[resource_id] / float(current_requirement + 1) - math.log(max_buy + 10) / 100
				buy_sell_list.append((importance, resource_id, max_buy, False))
			elif inventory[resource_id] > min_sell:
				price = int(session.db.get_res_value(resource_id) * TRADER.PRICE_MODIFIER_BUY)
				# have 50, need 30, min_sell 40, gold 5000, price 15, importance 0.08625
				# have 100, need 30, min_sell 40, gold 5000, price 15, importance 0.02464
				# have 50, need 30, min_sell 40, gold 0, price 15, importance 0.05341
				# have 50, need 20, min_sell 27, gold 5000, price 15, importance 0.07717
				# have 28, need 20, min_sell 27, gold 5000, price 15, importance 0.23150
				# have 28, need 20, min_sell 27, gold 0, price 15, importance 0.14335
				# have 50, need 30, min_sell 40, gold 10000000, price 15, importance 0.16248
				# have 40, need 30, min_sell 40, gold 5000, price 30, importance 0.04452
				importance = 100.0 / (inventory[resource_id] - min_sell + 10) / (current_requirement + 1) * math.log(gold + 200) / (price + 1)
				buy_sell_list.append((importance, resource_id, min_sell, True))
		if not buy_sell_list:
			return # nothing to buy nor sell

		trade_post = settlement.get_component(TradePostComponent)
		trade_slots = trade_post.slots
		num_slots = len(trade_slots)
		sell_list = trade_post.sell_list
		buy_list = trade_post.buy_list

		# discard the less important buy/sell wishes
		buy_sell_list = sorted(buy_sell_list)[:num_slots]
		bought_sold_resources = zip(*buy_sell_list)[1]

		# clear all slots we will no longer be needing
		for resource_id in managed_resources:
			if resource_id in bought_sold_resources:
				sell = buy_sell_list[bought_sold_resources.index(resource_id)][3]
				if sell and resource_id in buy_list:
					ClearTradeSlot(trade_post, buy_list[resource_id]).execute(session)
				elif not sell and resource_id in sell_list:
					ClearTradeSlot(trade_post, sell_list[resource_id]).execute(session)
			else:
				if resource_id in buy_list:
					ClearTradeSlot(trade_post, buy_list[resource_id]).execute(session)
				elif resource_id in sell_list:
					ClearTradeSlot(trade_post, sell_list[resource_id]).execute(session)

		# add any new offers
		for resource_id in managed_resources:
			if resource_id in bought_sold_resources:
				limit, sell = buy_sell_list[bought_sold_resources.index(resource_id)][2:]
				if sell and (resource_id not in sell_list or trade_slots[sell_list[resource_id]].limit != limit):
					SetTradeSlot(trade_post, trade_post.get_free_slot(resource_id), resource_id, True, limit).execute(session)
				elif not sell and (resource_id not in buy_list or trade_slots[buy_list[resource_id]].limit != limit):
					SetTradeSlot(trade_post, trade_post.get_free_slot(resource_id), resource_id, False, limit).execute(session)

	def finish_tick(self):
		"""Clear data used during a single tick."""
		self._low_priority_requests.clear()

	def __str__(self):
		if not hasattr(self, "settlement_manager"):
			return 'UninitializedResourceManager'
		result = 'ResourceManager(%s, %d)' % (self.settlement_manager.settlement.get_component(NamedComponent).name, self.worldid)
		for resource_manager in self._data.itervalues():
			res = resource_manager.resource_id
			if res not in [RES.FOOD, RES.TEXTILE, RES.BRICKS]:
				continue
			result += '\n' + resource_manager.__str__()
		return result

class SingleResourceManager(WorldObject):
	"""An object of this class keeps track of the production capacity of a single resource/building type pair of a settlement."""

	epsilon = 1e-7 # epsilon for avoiding problems with miniscule values
	virtual_resources = set([RES.FISH, RES.RAW_CLAY, RES.RAW_IRON]) # resources that are not actually produced by player owned buildings
	virtual_production = 9999 # pretend that virtual resources are always produced in this amount (should be larger than actually needed)

	def __init__(self, settlement_manager, resource_id, building_id):
		super(SingleResourceManager, self).__init__()
		self.__init(settlement_manager, resource_id, building_id)
		self.low_priority = 0.0 # used resource production per tick assigned to low priority holders
		self.available = 0.0 # unused resource production per tick
		self.total = 0.0 # total resource production per tick

	def __init(self, settlement_manager, resource_id, building_id):
		self.settlement_manager = settlement_manager
		self.resource_id = resource_id
		self.building_id = building_id
		self.quotas = {} # {quota_holder: (amount, priority), ...}

	def save(self, db, resource_manager_id):
		super(SingleResourceManager, self).save(db)
		db("INSERT INTO ai_single_resource_manager(rowid, resource_manager, resource_id, building_id, low_priority, available, total) VALUES(?, ?, ?, ?, ?, ?, ?)",
		   self.worldid, resource_manager_id, self.resource_id, self.building_id, self.low_priority, self.available, self.total)
		for identifier, (quota, priority) in self.quotas.iteritems():
			db("INSERT INTO ai_single_resource_manager_quota(single_resource_manager, identifier, quota, priority) VALUES(?, ?, ?, ?)", self.worldid, identifier, quota, priority)

	def _load(self, db, settlement_manager, worldid):
		super(SingleResourceManager, self).load(db, worldid)
		(resource_id, building_id, self.low_priority, self.available, self.total) = \
		    db("SELECT resource_id, building_id, low_priority, available, total FROM ai_single_resource_manager WHERE rowid = ?", worldid)[0]
		self.__init(settlement_manager, resource_id, building_id)

		for (identifier, quota, priority) in db("SELECT identifier, quota, priority FROM ai_single_resource_manager_quota WHERE single_resource_manager = ?", worldid):
			self.quotas[identifier] = (quota, priority)

	@classmethod
	def load(cls, db, settlement_manager, worldid):
		self = cls.__new__(cls)
		self._load(db, settlement_manager, worldid)
		return self

	def _get_current_production(self):
		"""Return the current amount of resource per tick being produced at buildings of this type."""
		if self.resource_id in self.virtual_resources:
			return self.virtual_production
		buildings = self.settlement_manager.settlement.buildings_by_id.get(self.building_id, [])
		return sum(AbstractBuilding.buildings[building.id].get_production_level(building, self.resource_id) for building in buildings)

	def refresh(self):
		"""Adjust the quotas to take into account the current production levels."""
		currently_used = sum(zip(*self.quotas.itervalues())[0])
		self.total = self._get_current_production()
		if self.total + self.epsilon >= currently_used:
			self.available = self.total - currently_used
		else:
			# unable to honor current quota assignments
			self.available = 0.0
			if currently_used - self.total <= self.low_priority and self.low_priority > self.epsilon:
				# the problem can be solved by reducing low priority quotas
				new_low_priority = max(0.0, self.low_priority - (currently_used - self.total))
				multiplier = 0.0 if new_low_priority < self.epsilon else new_low_priority / self.low_priority
				assert 0.0 <= multiplier < 1.0
				for quota_holder, (quota, priority) in self.quotas.iteritems():
					if quota > self.epsilon and not priority:
						self.quotas[quota_holder] = (quota * multiplier, priority)
					elif not priority:
						self.quotas[quota_holder] = (0.0, priority)
				self.low_priority = new_low_priority
			elif currently_used > self.total + self.epsilon:
				# decreasing all high priority quotas equally, removing low priority quotas completely
				multiplier = 0.0 if self.total < self.epsilon else self.total / (currently_used - self.low_priority)
				assert 0.0 <= multiplier < 1.0
				for quota_holder, (quota, priority) in self.quotas.iteritems():
					if quota > self.epsilon and priority:
						self.quotas[quota_holder] = (quota * multiplier, priority)
					else:
						self.quotas[quota_holder] = (0.0, priority)
				self.low_priority = 0.0

	def get_quota(self, quota_holder):
		"""Return the current quota of the given quota holder."""
		if quota_holder not in self.quotas:
			self.quotas[quota_holder] = (0.0, False)
		return self.quotas[quota_holder][0]

	def request_quota_change(self, quota_holder, priority, amount):
		"""
		Request that the quota of quota_holder be changed to the given amount.

		The algorithm:
		* if the new amount is less than before: set the new quota to the requested value
		* else if there is enough spare capacity to raise the quota: do it
		* else assign all the spare capacity
			* if this is a high priority request:
				* reduce the low priority quotas to get the maximum possible amount for this quota holder

		@param quota_holder: a string identifying the quota holder (persistent over save/load cycles)
		@param priority: boolean showing whether this quota has high priority (high priority means that low priority quotas can be lowered if necessary)
		@param amount: the amount of resource per tick that is needed
		"""

		if quota_holder not in self.quotas:
			self.quotas[quota_holder] = (0.0, priority)
		amount = max(amount, 0.0)

		if abs(amount - self.quotas[quota_holder][0]) < self.epsilon:
			pass # ignore miniscule change requests
		elif amount < self.quotas[quota_holder][0]:
			# lower the amount of reserved production
			change = self.quotas[quota_holder][0] - amount
			self.available += change
			self.quotas[quota_holder] = (self.quotas[quota_holder][0] - change, priority)
			if not priority:
				self.low_priority -= change
		else:
			if priority and self.available < (amount - self.quotas[quota_holder][0]) and self.low_priority > self.epsilon:
				# can't get the full requested amount but can get more by reusing some of the low priority quotas
				new_low_priority = max(0.0, self.low_priority - (amount - self.quotas[quota_holder][0] - self.available))
				multiplier = 0.0 if new_low_priority < self.epsilon else new_low_priority / self.low_priority
				assert 0.0 <= multiplier < 1.0
				for other_quota_holder, (quota, other_priority) in self.quotas.iteritems():
					if quota > self.epsilon and not other_priority:
						self.quotas[other_quota_holder] = (quota * multiplier, other_priority)
					elif not other_priority:
						self.quotas[other_quota_holder] = (0.0, other_priority)
				self.available += self.low_priority - new_low_priority
				self.low_priority = new_low_priority

			# raise the amount of reserved production as much as possible
			change = min(amount - self.quotas[quota_holder][0], self.available)
			self.available -= change
			self.quotas[quota_holder] = (self.quotas[quota_holder][0] + change, priority)
			if not priority:
				self.low_priority += change

	def get_total_export(self):
		"""Return the total amount of capacity that is reserved by quota holders in other settlements."""
		# this is accurate for now because all trade is set to low priority and nothing else is
		return self.low_priority

	def __str__(self):
		if not hasattr(self, "resource_id"):
			return 'UninitializedSingleResourceManager'
		result = 'Resource %d production %.5f/%.5f (%.5f low priority)' % (self.resource_id, self.available, self.total, self.low_priority)
		for quota_holder, (quota, priority) in self.quotas.iteritems():
			result += '\n  %squota assignment %.5f to %s' % ('priority ' if priority else '', quota, quota_holder)
		return result

class SimpleProductionChainSubtreeChoice(object):
	"""This is a simple version of ProductionChainSubtreeChoice used to make recursive quotas possible."""

	def __init__(self, options):
		super(SimpleProductionChainSubtreeChoice, self).__init__()
		self.options = options # [SimpleProductionChainSubtree, ...]
		self.resource_id = options[0].resource_id

	def assign_identifier(self, prefix):
		"""Recursively assign an identifier to this subtree to know which subtree owns which resource quota."""
		self.identifier = prefix + ('/choice' if len(self.options) > 1 else '')
		for option in self.options:
			option.assign_identifier(self.identifier)

	def request_quota_change(self, quota_holder, amount, priority):
		"""Try to reserve currently available production. Return the total amount that can be reserved."""
		total_reserved = 0.0
		for option in self.options:
			total_reserved += option.request_quota_change(quota_holder, max(0.0, amount - total_reserved), priority)
		return total_reserved

	def get_quota(self, quota_holder):
		return sum(option.get_quota(quota_holder) for option in self.options)

class SimpleProductionChainSubtree(object):
	"""This is a simple version of ProductionChainSubtree used to make recursive quotas possible."""

	def __init__(self, resource_manager, resource_id, production_line, abstract_building, children, production_ratio):
		super(SimpleProductionChainSubtree, self).__init__()
		self.resource_manager = resource_manager
		self.resource_id = resource_id
		self.production_line = production_line
		self.abstract_building = abstract_building
		self.children = children # [SimpleProductionChainSubtreeChoice, ...]
		self.production_ratio = production_ratio

	def assign_identifier(self, prefix):
		"""Recursively assign an identifier to this subtree to know which subtree owns which resource quota."""
		self.identifier = '%s/%d,%d' % (prefix, self.resource_id, self.abstract_building.id)
		for child in self.children:
			child.assign_identifier(self.identifier)

	def request_quota_change(self, quota_holder, amount, priority):
		"""Try to reserve currently available production. Return the total amount that can be reserved."""
		total_reserved = amount
		for child in self.children:
			total_reserved = min(total_reserved, child.request_quota_change(quota_holder, amount, priority))

		self.resource_manager.request_quota_change(quota_holder + self.identifier, priority, self.resource_id, self.abstract_building.id, amount * self.production_ratio)
		return min(total_reserved, self.resource_manager.get_quota(quota_holder + self.identifier, self.resource_id, self.abstract_building.id) / self.production_ratio)

	def get_quota(self, quota_holder):
		"""Return the current quota at the bottleneck."""
		root_quota = self.resource_manager.get_quota(quota_holder + self.identifier, self.resource_id, self.abstract_building.id) / self.production_ratio
		if self.children:
			return min(root_quota, min(child.get_quota(quota_holder) for child in self.children))
		return root_quota

decorators.bind_all(ResourceManager)
decorators.bind_all(SingleResourceManager)
decorators.bind_all(SimpleProductionChainSubtreeChoice)
decorators.bind_all(SimpleProductionChainSubtree)

########NEW FILE########
__FILENAME__ = roadplanner
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import heapq

from horizons.util.python import decorators

class RoadPlanner(object):
	"""
	Finds the most reasonable road between two areas.

	This class uses the A* algorithm to find a path that would look nice as a road.
	Penalties are give for the following:
	* not an existing road
	* close to an existing road
	* not straight
	* not close to boundaries (coast, mountains, etc.)
	"""

	def __call__(self, personality, source, destination, destination_beacon, path_nodes, blocked_coords=None):
		"""
		Return the path from the source to the destination or None if it is impossible.

		@param personality: the personality class that contains the relevant personality bits
		@param source: list of tuples [(x, y), ...]
		@param destination: list of tuples [(x, y), ...]
		@param destination_beacon: object with a defined distance_to_tuple function (must contain all of destination)
		@param path_nodes: dict {(x, y): penalty}
		@param blocked_coords: temporarily blocked coordinates set([(x, y), ...])
		"""
		blocked_coords = blocked_coords or set()
		target_blocked = True
		for coords in destination:
			if coords not in blocked_coords and coords in path_nodes:
				target_blocked = False
				break
		if target_blocked:
			return None

		distance = {}
		beacon_tuple_distance_func = destination_beacon.get_distance_function((0, 0))
		heap = []
		for coords in source:
			if coords not in blocked_coords and coords in path_nodes:
				for dir in xrange(2): # 0 -> changed x, 1 -> changed y
					real_distance = path_nodes[coords]
					expected_distance = beacon_tuple_distance_func(destination_beacon, coords)
					key = (coords[0], coords[1], dir)
					# the value is (real distance so far, previous key)
					distance[key] = (real_distance, None)
					# (expected distance to the destination, current real distance, key)
					heap.append((expected_distance, real_distance, key))
		heapq.heapify(heap)

		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		final_key = None

		# perform A*
		while heap:
			(_, distance_so_far, key) = heapq.heappop(heap)
			if distance[key] < distance_so_far:
				continue
			if (key[0], key[1]) in destination:
				final_key = key
				break

			for dir in xrange(4):
				coords = (key[0] + moves[dir][0], key[1] + moves[dir][1])
				if coords not in path_nodes or coords in blocked_coords:
					continue
				reduced_dir = 0 if moves[dir][0] != 0 else 1
				next_key = (coords[0], coords[1], reduced_dir)
				real_distance = distance_so_far + path_nodes[coords] + (0 if reduced_dir == key[2] else personality.turn_penalty)
				expected_distance = real_distance + beacon_tuple_distance_func(destination_beacon, coords)
				if next_key not in distance or distance[next_key][0] > real_distance:
					distance[next_key] = (real_distance, key)
					heapq.heappush(heap, (expected_distance, real_distance, next_key))

		# save path
		if final_key is not None:
			path = []
			while final_key is not None:
				path.append((final_key[0], final_key[1]))
				final_key = distance[final_key][1]
			return path
		return None

decorators.bind_all(RoadPlanner)

########NEW FILE########
__FILENAME__ = settlementfounder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from collections import defaultdict

from horizons.ai.aiplayer.mission.foundsettlement import FoundSettlement
from horizons.ai.aiplayer.mission.preparefoundationship import PrepareFoundationShip
from horizons.ai.aiplayer.landmanager import LandManager
from horizons.constants import RES
from horizons.util.python import decorators
from horizons.component.storagecomponent import StorageComponent

class SettlementFounder(object):
	"""This class handles the settlement founding activities of an AI player."""

	log = logging.getLogger("ai.aiplayer.settlement_founder")

	def __init__(self, owner):
		super(SettlementFounder, self).__init__()
		self.owner = owner
		self.session = owner.session
		self.world = owner.world
		self.personality = owner.personality_manager.get('SettlementFounder')
		self.__island_value_cache = {} # {island_id: (last_change_id, value), ...}

	def _evaluate_island(self, island):
		"""Return (flat land, utility value) of the given island."""
		resources = defaultdict(int)
		for deposit_dict in island.deposits.itervalues():
			for deposit in deposit_dict.itervalues():
				if deposit.settlement is None:
					for resource_id, amount in deposit.get_component(StorageComponent).inventory.itercontents():
						resources[resource_id] += amount

		# calculate the value of the island by taking into account the available land, resources, and number of enemy settlements
		value = island.available_flat_land
		value += min(resources[RES.RAW_CLAY], self.personality.max_raw_clay) * self.personality.raw_clay_importance
		if resources[RES.RAW_CLAY] < self.personality.min_raw_clay:
			value -= self.personality.no_raw_clay_penalty
		value += min(resources[RES.RAW_IRON], self.personality.max_raw_iron) * self.personality.raw_iron_importance
		if resources[RES.RAW_IRON] < self.personality.min_raw_iron:
			value -= self.personality.no_raw_iron_penalty
		value -= len(island.settlements) * self.personality.enemy_settlement_penalty

		# take into the distance to our old warehouses and the other players' islands
		for settlement in self.world.settlements:
			if settlement.owner is self.owner:
				value += self.personality.compact_empire_importance / float(island.position.distance(settlement.warehouse.position) + self.personality.extra_warehouse_distance)
			else:
				value -= self.personality.nearby_enemy_penalty / float(island.position.distance(settlement.island.position) + self.personality.extra_enemy_island_distance)

		return (island.available_flat_land, max(2, int(value)))

	def _get_available_islands(self, min_land):
		"""Return a list of available islands in the form [(value, island), ...]."""
		options = []
		for island in self.owner.world.islands:
			if island.worldid not in self.owner.islands:
				if island.worldid not in self.__island_value_cache or self.__island_value_cache[island.worldid][0] != island.last_change_id:
					self.__island_value_cache[island.worldid] = (island.last_change_id, self._evaluate_island(island))
				if self.__island_value_cache[island.worldid][1][0] >= min_land:
					options.append((self.__island_value_cache[island.worldid][1][1], island))
		return options

	def _choose_island(self, min_land):
		"""Randomly choose one of the big enough islands. Return the island or None if it is impossible."""
		options = self._get_available_islands(min_land)
		if not options:
			return None
		total_value = sum(zip(*options)[0])

		# choose a random big enough island with probability proportional to its value
		choice = self.session.random.randint(0, total_value - 1)
		for (land, island) in options:
			if choice <= land:
				return island
			choice -= land
		return None

	def _found_settlement(self, island, ship, feeder_island):
		"""Found a settlement on the given island using the given ship."""
		land_manager = LandManager(island, self.owner, feeder_island)
		land_manager.display()
		self.owner.islands[island.worldid] = land_manager
		self.owner.start_mission(FoundSettlement.create(ship, land_manager, self.owner.report_success, self.owner.report_failure))

	def _have_settlement_starting_resources(self, ship, settlement, min_money, min_resources):
		"""Returns a boolean showing whether we have enough resources to found a new settlement."""
		if self.owner.get_component(StorageComponent).inventory[RES.GOLD] < min_money:
			return False

		if ship is not None:
			for res, amount in ship.get_component(StorageComponent).inventory.itercontents():
				if res in min_resources and min_resources[res] > 0:
					min_resources[res] = max(0, min_resources[res] - amount)

		if settlement:
			for res, amount in settlement.get_component(StorageComponent).inventory.itercontents():
				if res in min_resources and min_resources[res] > 0:
					min_resources[res] = max(0, min_resources[res] - amount)

		for missing in min_resources.itervalues():
			if missing > 0:
				return False
		return True

	def have_starting_resources(self, ship, settlement):
		"""Returns a boolean showing whether we have enough resources to found a new normal settlement."""
		return self._have_settlement_starting_resources(ship, settlement, self.personality.min_new_island_gold,
				                                        {RES.BOARDS: self.personality.min_new_island_boards, RES.FOOD: self.personality.min_new_island_food, RES.TOOLS: self.personality.min_new_island_tools})

	def have_feeder_island_starting_resources(self, ship, settlement):
		"""Returns a boolean showing whether we have enough resources to found a new feeder island."""
		return self._have_settlement_starting_resources(ship, settlement, self.personality.min_new_feeder_island_gold,
				                                        {RES.BOARDS: self.personality.min_new_island_boards, RES.TOOLS: self.personality.min_new_island_tools})

	def _prepare_foundation_ship(self, settlement_manager, ship, feeder_island):
		"""Start a mission to load the settlement foundation resources on the given ship from the specified settlement."""
		self.owner.start_mission(PrepareFoundationShip(settlement_manager, ship, feeder_island, self.owner.report_success, self.owner.report_failure))

	def _want_another_village(self):
		"""Return a boolean showing whether we want to start another settlement with a village."""
		# avoid having more than one developing island with a village at a time
		for settlement_manager in self.owner.settlement_managers:
			if not settlement_manager.feeder_island and not settlement_manager.can_provide_resources():
				return False
		return True

	def tick(self):
		"""Found a new settlement or prepare a foundation ship if possible and required."""
		ship = None
		for possible_ship, state in self.owner.ships.iteritems():
			if state is self.owner.shipStates.idle:
				# TODO: make sure the ship is actually usable for founding a settlement
				ship = possible_ship
				break
		if ship is None and self.owner.ships:
			#self.log.info('%s.tick: all ships are in use', self)
			return

		island = None
		for min_size in self.personality.island_size_sequence:
			island = self._choose_island(min_size)
			if island is not None:
				break
		if island is None:
			#self.log.info('%s.tick: no good enough islands', self)
			return

		if self.owner.need_feeder_island:
			if self.have_feeder_island_starting_resources(ship, None):
				if ship is None:
					self.owner.request_ship()
				else:
					self.log.info('%s.tick: send %s on a mission to found a feeder settlement', self, ship)
					self._found_settlement(island, ship, True)
			else:
				for settlement_manager in self.owner.settlement_managers:
					if self.have_feeder_island_starting_resources(ship, settlement_manager.land_manager.settlement):
						if ship is None:
							self.owner.request_ship()
						else:
							self.log.info('%s.tick: send ship %s on a mission to get resources for a new feeder settlement', self, ship)
							self._prepare_foundation_ship(settlement_manager, ship, True)
						return
		elif self._want_another_village():
			if self.have_starting_resources(ship, None):
				if ship is None:
					self.owner.request_ship()
				else:
					self.log.info('%s.tick: send ship %s on a mission to found a settlement', self, ship)
					self._found_settlement(island, ship, False)
			else:
				for settlement_manager in self.owner.settlement_managers:
					if not settlement_manager.can_provide_resources():
						continue
					if self.have_starting_resources(ship, settlement_manager.land_manager.settlement):
						if ship is None:
							self.owner.request_ship()
						else:
							self.log.info('%s.tick: send ship %s on a mission to get resources for a new settlement', self, ship)
							self._prepare_foundation_ship(settlement_manager, ship, False)
						return

	def can_found_feeder_island(self):
		"""Return a boolean showing whether there is an island that could be turned into a feeder island."""
		return bool(self._get_available_islands(self.personality.min_feeder_island_area))

	def found_feeder_island(self):
		"""Call this function to let the player know that a new feeder island is needed."""
		if self.can_found_feeder_island():
			self.owner.need_feeder_island = True

	def __str__(self):
		return '%s SettlementFounder' % (self.owner)

decorators.bind_all(SettlementFounder)
########NEW FILE########
__FILENAME__ = settlementmanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.ai.aiplayer.goal.combatship import CombatShipGoal
from horizons.ai.aiplayer.villagebuilder import VillageBuilder
from horizons.ai.aiplayer.productionbuilder import ProductionBuilder
from horizons.ai.aiplayer.productionchain import ProductionChain
from horizons.ai.aiplayer.resourcemanager import ResourceManager
from horizons.ai.aiplayer.trademanager import TradeManager

from horizons.ai.aiplayer.goal.boatbuilder import BoatBuilderGoal
from horizons.ai.aiplayer.goal.depositcoverage import ClayDepositCoverageGoal, MountainCoverageGoal
from horizons.ai.aiplayer.goal.enlargecollectorarea import EnlargeCollectorAreaGoal
from horizons.ai.aiplayer.goal.feederchaingoal import FeederFoodGoal, FeederTextileGoal, FeederLiquorGoal, \
	FeederTobaccoProductsGoal, FeederSaltGoal, FeederMedicalProductsGoal
from horizons.ai.aiplayer.goal.firestation import FireStationGoal
from horizons.ai.aiplayer.goal.doctor import DoctorGoal
from horizons.ai.aiplayer.goal.foundfeederisland import FoundFeederIslandGoal
from horizons.ai.aiplayer.goal.improvecollectorcoverage import ImproveCollectorCoverageGoal
from horizons.ai.aiplayer.goal.productionchaingoal import FaithGoal, TextileGoal, BricksGoal, \
	EducationGoal, GetTogetherGoal, ToolsGoal, BoardsGoal, FoodGoal, CommunityGoal, TobaccoProductsGoal, \
	SaltGoal, MedicalHerbsProductsGoal
from horizons.ai.aiplayer.goal.signalfire import SignalFireGoal
from horizons.ai.aiplayer.goal.storagespace import StorageSpaceGoal
from horizons.ai.aiplayer.goal.tent import TentGoal
from horizons.ai.aiplayer.goal.tradingship import TradingShipGoal

from horizons.scheduler import Scheduler
from horizons.util.worldobject import WorldObject
from horizons.util.python import decorators
from horizons.command.building import Tear
from horizons.command.uioptions import SetTaxSetting, SetSettlementUpgradePermissions
from horizons.command.production import ToggleActive
from horizons.constants import BUILDINGS, RES, GAME_SPEED, TIER
from horizons.entities import Entities
from horizons.component.storagecomponent import StorageComponent
from horizons.component.namedcomponent import NamedComponent
from horizons.world.disaster.buildinginfluencingdisaster import BuildingInfluencingDisaster
from horizons.world.production.producer import Producer

class SettlementManager(WorldObject):
	"""
	This is the main settlement control class.

	Important attributes:
	* feeder_island: boolean showing whether the island is a feeder island (feeder islands have no village area)
	* island: Island instance
	* settlement: Settlement instance
	* land_manager: LandManager instance
	* production_chain: dictionary where the key is a resource id and the value is the ProductionChain instance
	* production_builder: ProductionBuilder instance
	* village_builder: VillageBuilder instance
	* resource_manager: ResourceManager instance
	* trade_manager: TradeManager instance
	"""

	log = logging.getLogger("ai.aiplayer")

	def __init__(self, owner, land_manager):
		super(SettlementManager, self).__init__()
		self.owner = owner
		self.resource_manager = ResourceManager(self)
		self.trade_manager = TradeManager(self)
		self.__init(land_manager)

		self.village_builder = VillageBuilder(self)
		self.production_builder = ProductionBuilder(self)
		self.village_builder.display()
		self.production_builder.display()

		self.__init_goals()

		if not self.feeder_island:
			self._set_taxes_and_permissions(self.personality.initial_sailor_taxes, self.personality.initial_pioneer_taxes,
				self.personality.initial_citizen_taxes, self.personality.initial_settler_taxes, self.personality.initial_sailor_upgrades,
				self.personality.initial_pioneer_upgrades, self.personality.initial_settler_upgrades)

	def __init(self, land_manager):
		self.owner = land_manager.owner
		self.session = self.owner.session
		self.land_manager = land_manager
		self.island = self.land_manager.island
		self.settlement = self.land_manager.settlement
		self.feeder_island = land_manager.feeder_island
		self.personality = self.owner.personality_manager.get('SettlementManager')

		# create a production chain for every building material, settler consumed resource, and resources that have to be imported from feeder islands
		self.production_chain = {}
		for resource_id in [RES.COMMUNITY, RES.BOARDS, RES.FOOD, RES.TEXTILE, RES.FAITH,
						RES.EDUCATION, RES.GET_TOGETHER, RES.BRICKS, RES.TOOLS, RES.LIQUOR,
						RES.TOBACCO_PRODUCTS, RES.SALT, RES.MEDICAL_HERBS]:
			self.production_chain[resource_id] = ProductionChain.create(self, resource_id)

		# initialize caches
		self.__resident_resource_usage_cache = {}

	def __init_goals(self):
		"""Initialize the list of all the goals the settlement can use."""
		self._goals = [] # [SettlementGoal, ...]
		self._goals.append(BoardsGoal(self))
		self._goals.append(SignalFireGoal(self))
		self._goals.append(EnlargeCollectorAreaGoal(self))
		self._goals.append(ImproveCollectorCoverageGoal(self))
		self._goals.append(BricksGoal(self))
		if self.feeder_island:
			self._goals.append(StorageSpaceGoal(self))
			self._goals.append(FeederFoodGoal(self))
			self._goals.append(FeederTextileGoal(self))
			self._goals.append(FeederLiquorGoal(self))
			self._goals.append(FeederSaltGoal(self))
			self._goals.append(FeederTobaccoProductsGoal(self))
			self._goals.append(FeederMedicalProductsGoal(self))
		else:
			self._goals.append(BoatBuilderGoal(self))
			self._goals.append(ClayDepositCoverageGoal(self))
			self._goals.append(FoundFeederIslandGoal(self))
			self._goals.append(MountainCoverageGoal(self))
			self._goals.append(FoodGoal(self))
			self._goals.append(CommunityGoal(self))
			self._goals.append(FaithGoal(self))
			self._goals.append(TextileGoal(self))
			self._goals.append(EducationGoal(self))
			self._goals.append(GetTogetherGoal(self))
			self._goals.append(SaltGoal(self))
			self._goals.append(TobaccoProductsGoal(self))
			self._goals.append(ToolsGoal(self))
			self._goals.append(TentGoal(self))
			self._goals.append(TradingShipGoal(self))
			self._goals.append(CombatShipGoal(self))
			self._goals.append(FireStationGoal(self))
			self._goals.append(DoctorGoal(self))
			self._goals.append(MedicalHerbsProductsGoal(self))

	def save(self, db):
		super(SettlementManager, self).save(db)
		db("INSERT INTO ai_settlement_manager(rowid, land_manager) VALUES(?, ?)",
			self.worldid, self.land_manager.worldid)

		self.village_builder.save(db)
		self.production_builder.save(db)
		self.resource_manager.save(db)
		self.trade_manager.save(db)

	@classmethod
	def load(cls, db, owner, worldid):
		self = cls.__new__(cls)
		self._load(db, owner, worldid)
		return self

	def _load(self, db, owner, worldid):
		self.owner = owner
		super(SettlementManager, self).load(db, worldid)

		# load the main part
		land_manager_id = db("SELECT land_manager FROM ai_settlement_manager WHERE rowid = ?", worldid)[0][0]
		land_manager = WorldObject.get_object_by_id(land_manager_id)

		# find the settlement
		for settlement in self.owner.session.world.settlements:
			if settlement.owner == self.owner and settlement.island == land_manager.island:
				land_manager.settlement = settlement
				break
		assert land_manager.settlement
		self.resource_manager = ResourceManager.load(db, self)
		self.trade_manager = TradeManager.load(db, self)
		self.__init(land_manager)

		# load the master builders
		self.village_builder = VillageBuilder.load(db, self)
		self.production_builder = ProductionBuilder.load(db, self)
		self.village_builder.display()
		self.production_builder.display()

		self.__init_goals()

		# the add_building events happen before the settlement manager is loaded so they have to be repeated here
		for building in self.settlement.buildings:
			self.add_building(building)

	def _set_taxes_and_permissions(self, sailor_taxes, pioneer_taxes, settler_taxes, citizen_taxes, sailor_upgrades, pioneer_upgrades, settler_upgrades):
		"""Set new tax settings and building permissions."""
		if abs(self.settlement.tax_settings[TIER.SAILORS] - sailor_taxes) > 1e-9:
			self.log.info("%s set sailors' taxes from %.1f to %.1f", self, self.settlement.tax_settings[TIER.SAILORS], sailor_taxes)
			SetTaxSetting(self.settlement, TIER.SAILORS, sailor_taxes).execute(self.land_manager.session)
		if abs(self.settlement.tax_settings[TIER.PIONEERS] - pioneer_taxes) > 1e-9:
			self.log.info("%s set pioneers' taxes from %.1f to %.1f", self, self.settlement.tax_settings[TIER.PIONEERS], pioneer_taxes)
			SetTaxSetting(self.settlement, TIER.PIONEERS, pioneer_taxes).execute(self.land_manager.session)
		if abs(self.settlement.tax_settings[TIER.SETTLERS] - settler_taxes) > 1e-9:
			self.log.info("%s set settlers' taxes from %.1f to %.1f", self, self.settlement.tax_settings[TIER.SETTLERS], settler_taxes)
			SetTaxSetting(self.settlement, TIER.SETTLERS, settler_taxes).execute(self.land_manager.session)
		if abs(self.settlement.tax_settings[TIER.CITIZENS] - citizen_taxes) > 1e-9:
			self.log.info("%s set citizens' taxes from %.1f to %.1f", self, self.settlement.tax_settings[TIER.CITIZENS], citizen_taxes)
			SetTaxSetting(self.settlement, TIER.CITIZENS, citizen_taxes).execute(self.land_manager.session)
		if self.settlement.upgrade_permissions[TIER.SAILORS] != sailor_upgrades:
			self.log.info('%s set sailor upgrade permissions to %s', self, sailor_upgrades)
			SetSettlementUpgradePermissions(self.settlement, TIER.SAILORS, sailor_upgrades).execute(self.land_manager.session)
		if self.settlement.upgrade_permissions[TIER.PIONEERS] != pioneer_upgrades:
			self.log.info('%s set pioneer upgrade permissions to %s', self, pioneer_upgrades)
			SetSettlementUpgradePermissions(self.settlement, TIER.PIONEERS, pioneer_upgrades).execute(self.land_manager.session)
		if self.settlement.upgrade_permissions[TIER.SETTLERS] != settler_upgrades:
			self.log.info('%s set settler upgrade permissions to %s', self, settler_upgrades)
			SetSettlementUpgradePermissions(self.settlement, TIER.SETTLERS, settler_upgrades).execute(self.land_manager.session)

	def _set_taxes_and_permissions_prefix(self, prefix):
		"""Set new tax settings and building permissions according to the prefix used in the personality file."""
		sailor_taxes = getattr(self.personality, '%s_sailor_taxes' % prefix)
		pioneer_taxes = getattr(self.personality, '%s_pioneer_taxes' % prefix)
		settler_taxes = getattr(self.personality, '%s_settler_taxes' % prefix)
		citizen_taxes = getattr(self.personality, '%s_citizen_taxes' % prefix)
		sailor_upgrades = getattr(self.personality, '%s_sailor_upgrades' % prefix)
		pioneer_upgrades = getattr(self.personality, '%s_pioneer_upgrades' % prefix)
		settler_upgrades = getattr(self.personality, '%s_settler_upgrades' % prefix)
		self._set_taxes_and_permissions(sailor_taxes, pioneer_taxes, settler_taxes, citizen_taxes,
			sailor_upgrades, pioneer_upgrades, settler_upgrades)

	def can_provide_resources(self):
		"""Return a boolean showing whether this settlement is complete enough to concentrate on building a new settlement."""
		if self.village_builder.tent_queue:
			return False
		settler_houses = 0
		residences = self.settlement.buildings_by_id.get(BUILDINGS.RESIDENTIAL, [])
		for building in residences:
			if building.level >= TIER.SETTLERS:
				settler_houses += 1
		if settler_houses > len(residences) * self.personality.new_settlement_settler_ratio:
			return True
		return False

	def get_resource_production(self, resource_id):
		"""Return the current production capacity (including import) per tick of the given resource."""
		# as long as there are enough collectors it is correct to calculate it this way
		if resource_id == RES.LIQUOR and not self.feeder_island:
			# normal settlements go straight for get-together so their separate liquor production is zero.
			# feeder islands have to produce liquor because get-together is not tradable
			return self.get_resource_production(RES.GET_TOGETHER) * self.production_chain[RES.GET_TOGETHER].get_ratio(RES.LIQUOR)
		else:
			return self.production_chain[resource_id].get_final_production_level()

	def get_resource_production_requirement(self, resource_id):
		"""Return the amount of resource per tick the settlement needs."""
		if resource_id not in self.__resident_resource_usage_cache or self.__resident_resource_usage_cache[resource_id][0] != Scheduler().cur_tick:
			total = 0
			if resource_id == RES.BRICKS:
				total = self.personality.dummy_bricks_requirement if self.owner.settler_level > 0 else 0 # dummy value to cause bricks production to be built
			elif resource_id == RES.BOARDS:
				total = self.personality.dummy_boards_requirement # dummy value to cause boards production to be built
			elif resource_id == RES.TOOLS:
				total = self.personality.dummy_tools_requirement if self.owner.settler_level > 1 else 0 # dummy value to cause tools production to be built
			elif resource_id == RES.LIQUOR:
				total = self.production_chain[RES.GET_TOGETHER].get_ratio(RES.LIQUOR) * self.get_resource_production_requirement(RES.GET_TOGETHER)
			else:
				for residence in self.settlement.buildings_by_id.get(BUILDINGS.RESIDENTIAL, []):
					for production in residence.get_component(Producer).get_productions():
						production_line = production._prod_line
						if resource_id in production_line.consumed_res:
							# subtract because the amount will be negative
							total -= float(production_line.consumed_res[resource_id]) / production_line.time / GAME_SPEED.TICKS_PER_SECOND

			self.__resident_resource_usage_cache[resource_id] = (Scheduler().cur_tick, total)
		return self.__resident_resource_usage_cache[resource_id][1]

	def _manual_upgrade(self, level, limit):
		"""
		Manually allow settlers to upgrade. If more then the set limit are already upgrading then don't stop them.

		@param level: the initial settler level from which to upgrade
		@param limit: the maximum number of residences of the specified level upgrading at the same time
		@return: boolean showing whether we gave any new residences the right to upgrade
		"""

		num_upgrading = 0
		for building in self.settlement.buildings_by_id.get(BUILDINGS.RESIDENTIAL, []):
			if building.level == level:
				upgrade_production = building._upgrade_production
				if upgrade_production is not None and not upgrade_production.is_paused():
					num_upgrading += 1
					if num_upgrading >= limit:
						return False

		upgraded_any = False
		for building in self.settlement.buildings_by_id.get(BUILDINGS.RESIDENTIAL, []):
			if building.level == level:
				upgrade_production = building._upgrade_production
				if upgrade_production is not None and upgrade_production.is_paused():
					ToggleActive(building.get_component(Producer), upgrade_production).execute(self.land_manager.session)
					num_upgrading += 1
					upgraded_any = True
					if num_upgrading >= limit:
						return True
		return upgraded_any

	def get_ideal_production_level(self, resource_id):
		"""
		Return the amount of resource per tick the settlement should produce.

		This is the amount that should be produced to satisfy the people in this settlement,
		keep up the current export rate, and fix the player's global deficit. This means
		that different (feeder) islands will have different ideal production levels.
		"""

		total = 0.0
		for settlement_manager in self.owner.settlement_managers:
			usage = settlement_manager.get_resource_production_requirement(resource_id) * self.personality.production_level_multiplier
			production = settlement_manager.get_resource_production(resource_id)
			resource_import = settlement_manager.trade_manager.get_total_import(resource_id)
			resource_export = settlement_manager.resource_manager.get_total_export(resource_id)
			total += usage
			if settlement_manager is not self:
				total -= production + resource_export - resource_import
		return max(0.0, total)

	def _start_feeder_tick(self):
		self.log.info('%s food requirement %.5f', self, self.get_ideal_production_level(RES.FOOD))
		self.log.info('%s textile requirement %.5f', self, self.get_ideal_production_level(RES.TEXTILE))
		self.log.info('%s liquor requirement %.5f', self, self.get_ideal_production_level(RES.LIQUOR))
		self.log.info('%s salt requirement %.5f', self, self.get_ideal_production_level(RES.SALT))
		self.log.info('%s tobacco products requirement %.5f', self, self.get_ideal_production_level(RES.TOBACCO_PRODUCTS))
		self.log.info('%s medical herbs requirement %.5f', self, self.get_ideal_production_level(RES.MEDICAL_HERBS))
		self.production_builder.manage_production()
		self.resource_manager.refresh()

	def _end_feeder_tick(self):
		self.resource_manager.replay_deep_low_priority_requests()
		self.resource_manager.record_expected_exportable_production(self.owner.tick_interval)
		self.resource_manager.manager_buysell()
		self.resource_manager.finish_tick()

	def _start_general_tick(self):
		self.log.info('%s food production             %.5f / %.5f', self, self.get_resource_production(RES.FOOD),
			self.get_resource_production_requirement(RES.FOOD))
		self.log.info('%s textile production          %.5f / %.5f', self, self.get_resource_production(RES.TEXTILE),
			self.get_resource_production_requirement(RES.TEXTILE))
		self.log.info('%s get-together production     %.5f / %.5f', self, self.get_resource_production(RES.GET_TOGETHER),
			self.get_resource_production_requirement(RES.GET_TOGETHER))
		self.log.info('%s salt production             %.5f / %.5f', self, self.get_resource_production(RES.SALT),
			self.get_resource_production_requirement(RES.SALT))
		self.log.info('%s tobacco products production %.5f / %.5f', self, self.get_resource_production(RES.TOBACCO_PRODUCTS),
			self.get_resource_production_requirement(RES.TOBACCO_PRODUCTS))
		self.log.info('%s medical herbs production %.5f / %.5f', self, self.get_resource_production(RES.MEDICAL_HERBS),
			self.get_resource_production_requirement(RES.MEDICAL_HERBS))
		self.production_builder.manage_production()
		self.trade_manager.refresh()
		self.resource_manager.refresh()
		self.need_materials = False

	def refresh_taxes_and_upgrade_permissions(self):
		# TODO: use a better system for managing settler upgrades and taxes
		if self.land_manager.owner.settler_level == 0:
			# if we are on level 0 and there is a house that can be upgraded then do it.
			if self._manual_upgrade(0, 1):
				self._set_taxes_and_permissions_prefix('early')
		elif self.get_resource_production(RES.BRICKS) > 1e-9 and not self.settlement.count_buildings(BUILDINGS.VILLAGE_SCHOOL):
			# if we just need the school then upgrade sailors manually
			free_boards = self.settlement.get_component(StorageComponent).inventory[RES.BOARDS]
			free_boards -= Entities.buildings[BUILDINGS.VILLAGE_SCHOOL].costs[RES.BOARDS]
			free_boards /= 2 # TODO: load this from upgrade resources
			if free_boards > 0:
				self._manual_upgrade(0, free_boards)
			self._set_taxes_and_permissions_prefix('no_school')
		elif self.settlement.count_buildings(BUILDINGS.VILLAGE_SCHOOL):
			if self.need_materials:
				self._set_taxes_and_permissions_prefix('school')
			else:
				self._set_taxes_and_permissions_prefix('final')

	def _end_general_tick(self):
		self.trade_manager.finalize_requests()
		self.trade_manager.organize_shipping()
		self.resource_manager.record_expected_exportable_production(self.owner.tick_interval)
		self.resource_manager.manager_buysell()
		self.resource_manager.finish_tick()

	def _add_goals(self, goals):
		"""Add the settlement's goals that can be activated to the goals list."""
		for goal in self._goals:
			if goal.can_be_activated:
				goal.update()
				goals.append(goal)

	def tick(self, goals):
		"""Refresh the settlement info and add its goals to the player's goal list."""
		if self.feeder_island:
			self._start_feeder_tick()
			self._add_goals(goals)
			self._end_feeder_tick()
		else:
			self._start_general_tick()
			self._add_goals(goals)
			self._end_general_tick()

	def add_building(self, building):
		"""Called when a new building is added to the settlement (the building already exists during the call)."""
		coords = building.position.origin.to_tuple()
		if coords in self.village_builder.plan:
			self.village_builder.add_building(building)
		else:
			self.production_builder.add_building(building)

	def remove_building(self, building):
		"""Called when a building is removed from the settlement (the building still exists during the call)."""
		coords = building.position.origin.to_tuple()
		if coords in self.village_builder.plan:
			self.village_builder.remove_building(building)
		else:
			self.production_builder.remove_building(building)

	def handle_lost_area(self, coords_list):
		"""
		Handle losing the potential land in the given coordinates list.

		Take the following actions:
		* remove the lost area from the village, production, and road areas
		* remove village sections with impossible main squares
		* remove all planned buildings that are now impossible from the village area
		* remove planned fields that are now impossible
		* remove fields that can no longer be serviced by a farm
		* TODO: if the village area takes too much of the total area then remove / reduce the remaining sections
		"""

		self.land_manager.handle_lost_area(coords_list)
		self.village_builder.handle_lost_area(coords_list)
		self.production_builder.handle_lost_area(coords_list)
		self.production_builder.handle_new_area() # some of the village area may have been repurposed as production area

		self.village_builder.display()
		self.production_builder.display()

	def handle_disaster(self, message):
		position = message.building.position
		if issubclass(message.disaster_class, BuildingInfluencingDisaster):
			rescue = message.disaster_class.RESCUE_BUILDING_TYPE
		else:
			self.log.info('%s ignoring unknown disaster of type %s', self, message.disaster_class.__name__)
			return

		rescue_radius = Entities.buildings[rescue].radius
		handled = False

		for b in self.settlement.buildings_by_id[rescue]:
			if b.position.distance(position) > rescue_radius:
				continue
			# TODO: check whether the building and the doctor/fire station are connected by road
			self.log.info('%s ignoring %s at %s because %s should be able to handle it',
			              self, message.disaster_class.__name__, message.building, rescue)
			handled = True
			break

		if not handled:
			self.log.info('%s removing %s because of %s', self, message.building, message.disaster_class.__name__)
			Tear(message.building).execute(self.session)

	def __str__(self):
		return '%s.SM(%s/%s)' % (self.owner, self.settlement.get_component(NamedComponent).name if hasattr(self, 'settlement') else 'unknown', self.worldid if hasattr(self, 'worldid') else 'none')

decorators.bind_all(SettlementManager)

########NEW FILE########
__FILENAME__ = specialdomestictrademanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from collections import defaultdict

from mission.specialdomestictrade import SpecialDomesticTrade
from horizons.util.python import decorators
from horizons.component.storagecomponent import StorageComponent

class SpecialDomesticTradeManager(object):
	"""
	An object of this class manages the special domestic trade routes of one AI player.

	These are called the special routes because they transport existing resources while
	the regular routes transport resources that have been produced for other settlements.

	The current implementation is limited to one active route between each (directed)
	pair of settlements. The routes are automatically removed when they have
	been used once or when the ship gets destroyed.
	"""

	log = logging.getLogger("ai.aiplayer.specialdomestictrade")

	def __init__(self, owner):
		super(SpecialDomesticTradeManager, self).__init__()
		self.owner = owner
		self.world = owner.world
		self.session = owner.session

	def _trade_mission_exists(self, source_settlement_manager, destination_settlement_manager):
		for mission in self.owner.missions:
			if not isinstance(mission, SpecialDomesticTrade):
				continue
			if mission.source_settlement_manager is source_settlement_manager and mission.destination_settlement_manager is destination_settlement_manager:
				return True
		return False

	def _add_route(self):
		"""
		Add a new special domestic trade route if possible.

		The route is created between the two settlements that need resources with most
		value transported between them but the actual mission will be unaware of the
		initial reasons for creating it and pick up whatever resources need to be
		transported when it gets to the source warehouse.
		"""

		ship = None
		for possible_ship, state in self.owner.ships.iteritems():
			if state is self.owner.shipStates.idle:
				ship = possible_ship
				break
		if not ship:
			#self.log.info('%s no available ships', self)
			return

		options = defaultdict(list)
		# try to set up a new route where the first settlement gets an extra shipment of a resource from the second settlement
		for source_settlement_manager in self.owner.settlement_managers:
			for destination_settlement_manager in self.owner.settlement_managers:
				if destination_settlement_manager is source_settlement_manager or self._trade_mission_exists(source_settlement_manager, destination_settlement_manager):
					continue

				source_resource_manager = source_settlement_manager.resource_manager
				source_inventory = source_settlement_manager.settlement.get_component(StorageComponent).inventory
				destination_resource_manager = destination_settlement_manager.resource_manager
				destination_inventory = destination_settlement_manager.settlement.get_component(StorageComponent).inventory

				for resource_id, limit in destination_resource_manager.resource_requirements.iteritems():
					if destination_inventory[resource_id] >= limit:
						continue # the destination settlement doesn't need the resource
					if source_inventory[resource_id] <= source_resource_manager.resource_requirements[resource_id]:
						continue # the source settlement doesn't have a surplus of the resource

					price = self.session.db.get_res_value(resource_id)
					tradable_amount = min(ship.get_component(StorageComponent).inventory.get_limit(resource_id), limit - destination_inventory[resource_id],
						source_inventory[resource_id] - source_resource_manager.resource_requirements[resource_id])
					options[(source_settlement_manager, destination_settlement_manager)].append((tradable_amount * price, tradable_amount, price, resource_id))

		if not options:
			#self.log.info('%s no interesting options', self)
			return

		final_options = []
		for (source_settlement_manager, destination_settlement_manager), option in sorted(options.iteritems()):
			total_amount = 0
			total_value = 0
			for _, amount, price, resource_id in option:
				amount = min(amount, ship.get_component(StorageComponent).inventory.get_limit(resource_id) - total_amount)
				total_value += amount * price
				total_amount += amount
			final_options.append((total_value, source_settlement_manager, destination_settlement_manager))

		source_settlement_manager, destination_settlement_manager = max(final_options)[1:]
		self.owner.start_mission(SpecialDomesticTrade(source_settlement_manager, destination_settlement_manager, ship, self.owner.report_success, self.owner.report_failure))

	def tick(self):
		self._add_route()

	def __str__(self):
		return '%s.SpecialDomesticTradeManager' % self.owner

decorators.bind_all(SpecialDomesticTradeManager)

########NEW FILE########
__FILENAME__ = condition
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
from horizons.ai.aiplayer.behavior.profile import BehaviorManager


class Condition(object):
	"""
	Condition's goal is to aid StrategyManager in figuring out what kind of strategy/mission
	is applicable to given state of world, e.g. instead of having a really long method that decides what kind of reasoning
	should be done at given point, we have a collection of Conditions (with priorities) that are easier to handle.
	"""

	log = logging.getLogger("ai.aiplayer.combat.condition")
	default_certainty = 1.0

	def __init__(self, owner):
		self.owner = owner
		self.world = owner.world
		self.session = owner.session
		self.unit_manager = owner.unit_manager

		# States whether given condition can be locked
		self.lockable = True

	def check(self, **environment):
		"""
		Based on information contained in **environment, determine wheter given condition occurs.
		@return: If the condition occurs: dictionary, else: None
		"""
		raise NotImplementedError("This is an abstract class")

	def get_identifier(self, **environment):
		"""
		Based on information contained in **environment return an Unique identifier for given condition.
		User for checking whether given condition is already being resolved by a mission in progress.
		@return: unique identifier
		@rtype: str
		"""
		return self.__class__.__name__


class ConditionSharingSettlement(Condition):
	"""
	States whether given player shares a settlement with AI.
	Raises "attack_enemy_player" strategy
	"""
	def __init__(self, owner):
		super(ConditionSharingSettlement, self).__init__(owner)

	def check(self, **environment):
		other_player = environment['player']

		my_islands = set(self.unit_manager.get_player_islands(self.owner))
		enemy_islands = set(self.unit_manager.get_player_islands(other_player))

		# checks whether player share the same island
		if my_islands & enemy_islands:
			return {'player': other_player, 'certainty': self.default_certainty, 'strategy_name': 'player_shares_island', 'type': BehaviorManager.strategy_types.offensive}
		else:
			return None

	def get_identifier(self, **environment):
		return super(ConditionSharingSettlement, self).get_identifier(**environment) + str(environment['player'].worldid)


class ConditionHostile(Condition):
	"""
	States whether there is a hostile player that can be attacked (i.e. has ships that can be destroyed)
	"""
	def __init__(self, owner):
		super(ConditionHostile, self).__init__(owner)

	def check(self, **environment):
		player = environment['player']

		if not self.session.world.diplomacy.are_enemies(self.owner, player):
			return None

		hostile_ships = self.unit_manager.get_player_ships(player)
		if hostile_ships:
			return {'player': player, 'certainty': self.default_certainty, 'strategy_name': 'hostile_player', 'type': BehaviorManager.strategy_types.offensive}
		else:
			return None

	def get_identifier(self, **environment):
		return super(ConditionHostile, self).get_identifier(**environment) + str(environment['player'].worldid)


class ConditionNeutral(Condition):
	"""
	States whether given player is neutral.
	What it aims to do is not only find if given player is neutral, but also sort them,
	i.e. penalize if given neutral is ally with our enemies etc.
	This way in case of any diplomatic actions it's possible to have a "safe" ally
	"""

	def check(self, **environment):
		player = environment['player']
		if self.session.world.diplomacy.are_neutral(self.owner, player):
			return {'player': player, 'certainty': self.default_certainty, 'strategy_name': 'neutral_player', 'type': BehaviorManager.strategy_types.diplomatic}
		else:
			return None

	def get_identifier(self, **environment):
		return super(ConditionNeutral, self).get_identifier(**environment) + str(environment['player'].worldid)


class ConditionAllied(Condition):
	"""
	States whether given player is ally.
	"""

	def check(self, **environment):
		player = environment['player']
		if self.session.world.diplomacy.are_allies(self.owner, player):
			return {'player': player, 'certainty': self.default_certainty, 'strategy_name': 'allied_player', 'type': BehaviorManager.strategy_types.diplomatic}
		else:
			return None


	def get_identifier(self, **environment):
		return super(ConditionAllied, self).get_identifier(**environment) + str(environment['player'].worldid)


class ConditionDebug(Condition):
	"""
	For testing purposes, always happens
	"""

	def check(self, **environment):
		player = environment['player']
		return {'player': player, 'certainty': self.default_certainty, 'strategy_name': 'debug', 'type': BehaviorManager.strategy_types.diplomatic}
		#return {'player': player, 'certainty': self.default_certainty, 'strategy_name': 'player_shares_island', 'type': BehaviorManager.strategy_types.offensive}

	def get_identifier(self, **environment):
		return super(ConditionDebug, self).get_identifier(**environment) + str(environment['player'].worldid)


class ConditionPirateRoutinePossible(Condition):
	"""
	Currently always occurs, when pirate has more conditions/strategies to work on, this may change.
	"""
	def __init__(self, owner):
		super(ConditionPirateRoutinePossible, self).__init__(owner)
		self.lockable = False

	def check(self, **environment):
		return {'certainty': self.default_certainty, 'strategy_name': 'pirate_routine', 'type': BehaviorManager.strategy_types.idle}

	def get_identifier(self, **environment):
		return super(ConditionPirateRoutinePossible, self).get_identifier(**environment)

########NEW FILE########
__FILENAME__ = chaseshipsandattack
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.strategy.mission import FleetMission
from horizons.component.namedcomponent import NamedComponent
from horizons.ext.enum import Enum
from horizons.messaging import ShipDestroyed
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.shapes import Circle
from horizons.util.worldobject import WorldObject
from horizons.world.units.movingobject import MoveNotPossible

class ChaseShipsAndAttack(FleetMission):
	"""
	This is one of the basic attack missions.
	1. Sail to given ship on the map until the fleet is in close range
	2. Begin combat phase
	3. go to 1 if ship is still alive

	This mission may work the best for 2 ships fleet
	"""

	missionStates = Enum.get_extended(FleetMission.missionStates, 'sailing_to_target', 'in_combat')
	target_range = 5

	def __init__(self, success_callback, failure_callback, ships, target_ship):
		super(ChaseShipsAndAttack, self).__init__(success_callback, failure_callback, ships)
		self.__init(target_ship)

	def __init(self, target_ship):
		self.target_ship = target_ship

		self.combatIntermissions = {
			self.missionStates.sailing_to_target: (self.sail_to_target, self.flee_home),
			self.missionStates.in_combat: (self.check_ship_alive, self.flee_home),
			self.missionStates.fleeing_home: (self.flee_home, self.flee_home),
		}

		self._state_fleet_callbacks = {
			self.missionStates.sailing_to_target: Callback(self.was_reached),
			self.missionStates.fleeing_home: Callback(self.report_failure, "Combat was lost, ships fled home successfully"),
		}

		ShipDestroyed.subscribe(self._on_ship_destroyed)

	def save(self, db):
		super(ChaseShipsAndAttack, self).save(db)
		db("INSERT INTO ai_mission_chase_ships_and_attack (rowid, target_ship_id) VALUES(?, ?)", self.worldid, self.target_ship.worldid)

	def _load(self, worldid, owner, db, success_callback, failure_callback):
		super(ChaseShipsAndAttack, self)._load(db, worldid, success_callback, failure_callback, owner)
		(target_ship_id,) = db("SELECT target_ship_id FROM ai_mission_chase_ships_and_attack WHERE rowid = ?", worldid)[0]

		target_ship = WorldObject.get_object_by_id(target_ship_id)
		self.__init(target_ship)

	def start(self):
		self.sail_to_target()

	def sail_to_target(self):
		self.log.debug("Player %s, Mission %s, 1/2 set off to ship %s at %s", self.owner.name, self.__class__.__name__,
			self.target_ship.get_component(NamedComponent).name, self.target_ship.position)
		try:
			self.fleet.move(Circle(self.target_ship.position, self.target_range), self._state_fleet_callbacks[self.missionStates.sailing_to_target])
			self.state = self.missionStates.sailing_to_target
		except MoveNotPossible:
			self.report_failure("Move was not possible when moving to target")

	def was_reached(self):
		if self.target_ship.in_ship_map:
			if any((ship.position.distance(self.target_ship.position) <= self.target_range + 1 for ship in self.fleet.get_ships())):
				# target ship reached: execute combat
				self.state = self.missionStates.in_combat
				self.in_combat()
			else:
				# target ship was not reached: sail again
				self.state = self.missionStates.sailing_to_target
				self.sail_to_target()
		else:
			# ship was destroyed
			self.report_success("Ship was destroyed")

	def check_ship_alive(self):
		if self.target_ship.in_ship_map:
			self.was_reached()
		else:
			self.report_success("Target ship was eliminated")

	def in_combat(self):
		if not self.session.world.diplomacy.are_enemies(self.owner, self.target_ship.owner):
			self.report_failure("Target ship was not hostile. Aborting mission.")
			return
		self.combat_phase = True
		self.log.debug("Player %s, Mission %s, 2/2 in combat", self.owner.name, self.__class__.__name__)
		self.state = self.missionStates.in_combat

	def flee_home(self):
		# check if fleet still exists
		if self.fleet.size() > 0:
			try:
				home_settlement = self.owner.settlements[0]
				return_point = self.unit_manager.get_warehouse_area(home_settlement, 10)
				self.fleet.move(return_point, self._state_fleet_callbacks[self.missionStates.fleeing_home])
				self.state = self.missionStates.fleeing_home
			except MoveNotPossible:
				self.report_failure("Combat was lost, ships couldn't flee home")
		else:
			self.report_failure("Combat was lost, all ships were wiped out")

	@classmethod
	def create(cls, success_callback, failure_callback, fleet, target_ship):
		return ChaseShipsAndAttack(success_callback, failure_callback, fleet, target_ship)

	def _on_ship_destroyed(self, msg):
		if msg.sender is self.target_ship:
			self.check_ship_alive()
			assert not self.target_ship.in_ship_map
			ShipDestroyed.unsubscribe(self._on_ship_destroyed)

	def end(self):
		if self.target_ship.in_ship_map:
			ShipDestroyed.unsubscribe(self._on_ship_destroyed)
		super(ChaseShipsAndAttack, self).end()

decorators.bind_all(ChaseShipsAndAttack)

########NEW FILE########
__FILENAME__ = pirateroutine
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.strategy.mission import FleetMission
from horizons.ext.enum import Enum
from horizons.util.python.callback import Callback
from horizons.util.shapes import Point

from horizons.world.units.movingobject import MoveNotPossible
from horizons.util.python import decorators


class PirateRoutine(FleetMission):
	"""
	Never ending mission of:
	1. Start moving to random places.
	2. Chase nearby ships along the way.
	3. Go back home
	"""

	missionStates = Enum.get_extended(FleetMission.missionStates, 'sailing_to_target', 'chasing_ship', 'going_home')

	# range at which the ship is considered "caught"
	caught_range = 5

	def __init__(self, success_callback, failure_callback, ships):
		super(PirateRoutine, self).__init__(success_callback, failure_callback, ships)
		self.target_point = self.owner.session.world.get_random_possible_ship_position()

	def _setup_state_callbacks(self):
		self.combatIntermissions = {
			self.missionStates.sailing_to_target: (self.sail_to_target, self.flee_home),
			self.missionStates.chasing_ship: (self.chase_ship, self.flee_home),
			self.missionStates.going_home: (self.go_home, self.flee_home),
			self.missionStates.fleeing_home: (self.flee_home, self.flee_home),
		}

		self._state_fleet_callbacks = {
			self.missionStates.sailing_to_target: Callback(self.go_home),
			self.missionStates.chasing_ship: Callback(self.chase_ship),
			self.missionStates.going_home: Callback(self.report_success, "Pirate routine ended successfully"),
			self.missionStates.fleeing_home: Callback(self.report_failure, "Mission was a failure, ships fled home successfully"),
		}

	def save(self, db):
		super(PirateRoutine, self).save(db)
		db("INSERT INTO ai_mission_pirate_routine (rowid, target_point_x, target_point_y) VALUES(?, ?, ?)", self.worldid,
			self.target_point.x, self.target_point.y)

	def _load(self, worldid, owner, db, success_callback, failure_callback):
		super(PirateRoutine, self)._load(db, worldid, success_callback, failure_callback, owner)
		db_result = db("SELECT target_point_x, target_point_y FROM ai_mission_pirate_routine WHERE rowid = ?", worldid)[0]

		self.target_point = Point(*db_result)

	def start(self):
		self.sail_to_target()

	def sail_to_target(self):
		self.log.debug("Pirate %s, Mission %s, 1/2 set off to random point at %s", self.owner.name, self.__class__.__name__, self.target_point)
		try:
			self.fleet.move(self.target_point, self._state_fleet_callbacks[self.missionStates.sailing_to_target])
			self.state = self.missionStates.sailing_to_target
		except MoveNotPossible:
			self.report_failure("Move was not possible when moving to target")

	def go_home(self):
		self.log.debug("Pirate %s, Mission %s, 2/2 going home at point %s", self.owner.name, self.__class__.__name__, self.owner.home_point)
		try:
			self.fleet.move(self.owner.home_point, self._state_fleet_callbacks[self.missionStates.going_home])
			self.state = self.missionStates.going_home
		except MoveNotPossible:
			self.report_failure("Pirate: %s, Mission: %s, Pirate ship couldn't go home." % (self.owner.name, self.__class__.__name__))

	def chase_ship(self):
		pass

	def flee_home(self):
		# check if fleet still exists
		if self.fleet.size() > 0:
			try:
				self.fleet.move(self.owner.home_point, self._state_fleet_callbacks[self.missionStates.fleeing_home])
				self.state = self.missionStates.fleeing_home
			except MoveNotPossible:
				self.report_failure("Pirate: %s, Mission: %s, Pirate ship couldn't flee home after combat" % (self.owner.name, self.__class__.__name__))
		else:
			self.report_failure("Combat was lost, all ships were wiped out")

	@classmethod
	def create(cls, success_callback, failure_callback, ships):
		return PirateRoutine(success_callback, failure_callback, ships)

decorators.bind_all(PirateRoutine)

########NEW FILE########
__FILENAME__ = scouting
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.strategy.mission import FleetMission
from horizons.ext.enum import Enum
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.shapes import Point
from horizons.world.units.movingobject import MoveNotPossible


class ScoutingMission(FleetMission):
	"""
	This is an example of a scouting mission.
	Send ship from point A to point B, and then to point A again.
	1. Send fleet to a point on the map
	2. Fleet returns to starting position of ships[0] (first ship)
	"""
	missionStates = Enum.get_extended(FleetMission.missionStates, 'sailing_to_target', 'going_back')

	def __init__(self, success_callback, failure_callback, ships, target_point):
		super(ScoutingMission, self).__init__(success_callback, failure_callback, ships)
		self.__init(target_point, ships[0].position.copy())

	def __init(self, target_point, starting_point):
		self.target_point = target_point
		self.starting_point = starting_point

		self.combatIntermissions = {
			self.missionStates.sailing_to_target: (self.sail_to_target, self.flee_home),
			self.missionStates.going_back: (self.go_back, self.flee_home),
			self.missionStates.fleeing_home: (self.flee_home, self.flee_home),
		}

		self._state_fleet_callbacks = {
			self.missionStates.sailing_to_target: Callback(self.go_back),
			self.missionStates.going_back: Callback(self.report_success, "Ships arrived at the target"),
			self.missionStates.fleeing_home: Callback(self.report_failure, "Combat was lost, ships fled home successfully"),
		}

	def start(self):
		self.sail_to_target()

	def save(self, db):
		super(ScoutingMission, self).save(db)
		db("INSERT INTO ai_scouting_mission (rowid, starting_point_x, starting_point_y, target_point_x, target_point_y) VALUES(?, ?, ?, ?, ?)",
			self.worldid, self.starting_point.x, self.starting_point.y, self.target_point.x, self.target_point.y)

	def _load(self, worldid, owner, db, success_callback, failure_callback):
		super(ScoutingMission, self)._load(db, worldid, success_callback, failure_callback, owner)
		db_result = db("SELECT target_point_x, target_point_y, starting_point_x, starting_point_y FROM ai_scouting_mission WHERE rowid = ?", worldid)[0]
		self.__init(Point(*db_result[:2]), Point(*db_result[2:]))

	def go_back(self):
		"""
		Going back home after successfully reaching the target point.
		"""
		try:
			self.fleet.move(self.starting_point, self._state_fleet_callbacks[self.missionStates.going_back])
			self.state = self.missionStates.going_back
		except MoveNotPossible:
			self.report_failure("Move was not possible when going back")

	def flee_home(self):
		"""
		Fleeing home after severe casualties.
		"""
		if self.fleet.size() > 0:
			try:
				self.fleet.move(self.starting_point, self._state_fleet_callbacks[self.missionStates.fleeing_home])
				self.state = self.missionStates.fleeing_home
			except MoveNotPossible:
				self.report_failure("Combat was lost, ships couldn't flee home")
		else:
			self.report_failure("Combat was lost, all ships were wiped out")

	def sail_to_target(self):
		if not self.target_point:
			self.target_point = self.owner.session.world.get_random_possible_ship_position()
		try:
			self.fleet.move(self.target_point, self._state_fleet_callbacks[self.missionStates.sailing_to_target])
			self.state = self.missionStates.sailing_to_target
		except MoveNotPossible:
			self.report_failure("Move was not possible when moving to target")

	@classmethod
	def create(cls, success_callback, failure_callback, ships, target_point=None):
		return ScoutingMission(success_callback, failure_callback, ships, target_point)

decorators.bind_all(ScoutingMission)

########NEW FILE########
__FILENAME__ = surpriseattack
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.strategy.mission import FleetMission
from horizons.command.diplomacy import AddEnemyPair
from horizons.ext.enum import Enum
from horizons.util.python.callback import Callback
from horizons.util.shapes import Circle, Point
from horizons.util.worldobject import WorldObject

from horizons.world.units.movingobject import MoveNotPossible
from horizons.util.python import decorators


class SurpriseAttack(FleetMission):
	"""
	This is a basic attack mission.
	1. Send fleet to a Point (or Circle) A
	2. Break diplomacy with enemy player P if he is not hostile,
	3. Begin combat phase
	4. Return home (point B).
	"""

	missionStates = Enum.get_extended(FleetMission.missionStates, 'sailing_to_target', 'in_combat', 'breaking_diplomacy', 'going_back')

	def __init__(self, success_callback, failure_callback, ships, target_point, return_point, enemy_player):
		super(SurpriseAttack, self).__init__(success_callback, failure_callback, ships)
		self.__init(target_point, return_point, enemy_player)

	def __init(self, target_point, return_point, enemy_player):
		self.target_point = target_point
		self.return_point = return_point
		self.enemy_player = enemy_player

		self.combatIntermissions = {
			self.missionStates.sailing_to_target: (self.sail_to_target, self.flee_home),
			self.missionStates.in_combat: (self.go_back, self.flee_home),
			self.missionStates.going_back: (self.go_back, self.flee_home),
			self.missionStates.breaking_diplomacy: (self.break_diplomacy, self.flee_home),
			self.missionStates.fleeing_home: (self.flee_home, self.flee_home),
		}

		# Fleet callbacks corresponding to given state
		self._state_fleet_callbacks = {
			self.missionStates.sailing_to_target: Callback(self.break_diplomacy),
			self.missionStates.going_back: Callback(self.report_success, "Ships arrived at return point"),
			self.missionStates.fleeing_home: Callback(self.report_failure, "Combat was lost, ships fled home successfully"),
		}

	def save(self, db):
		super(SurpriseAttack, self).save(db)
		db("INSERT INTO ai_mission_surprise_attack (rowid, enemy_player_id, target_point_x, target_point_y, target_point_radius, "
			"return_point_x, return_point_y) VALUES(?, ?, ?, ?, ?, ?, ?)", self.worldid, self.enemy_player.worldid, self.target_point.center.x,
			self.target_point.center.y, self.target_point.radius, self.return_point.x, self.return_point.y)

	def _load(self, worldid, owner, db, success_callback, failure_callback):
		super(SurpriseAttack, self)._load(db, worldid, success_callback, failure_callback, owner)
		db_result = db("SELECT enemy_player_id, target_point_x, target_point_y, target_point_radius, return_point_x, return_point_y "
						"FROM ai_mission_surprise_attack WHERE rowid = ?", worldid)[0]
		enemy_player_id, target_point_x, target_point_y, target_point_radius, return_point_x, return_point_y = db_result

		target_point = Circle(Point(target_point_x, target_point_y), target_point_radius)
		return_point = Point(return_point_x, return_point_y)
		enemy_player = WorldObject.get_object_by_id(enemy_player_id)
		self.__init(target_point, return_point, enemy_player)

	def start(self):
		self.sail_to_target()

	def sail_to_target(self):
		self.log.debug("Player %s, Mission %s, 1/4 set off from point %s to point %s", self.owner.name, self.__class__.__name__, self.return_point, self.target_point)
		try:
			self.fleet.move(self.target_point, self._state_fleet_callbacks[self.missionStates.sailing_to_target])
			self.state = self.missionStates.sailing_to_target
		except MoveNotPossible:
			self.report_failure("Move was not possible when moving to target")

	def break_diplomacy(self):
		self.state = self.missionStates.breaking_diplomacy
		self.log.debug("Player %s, Mission %s, 2/4 breaking diplomacy with Player %s", self.owner.name, self.__class__.__name__, self.enemy_player.name)
		if not self.session.world.diplomacy.are_enemies(self.owner, self.enemy_player):
			AddEnemyPair(self.owner, self.enemy_player).execute(self.session)
		self.in_combat()

	def in_combat(self):
		self.combat_phase = True
		self.log.debug("Player %s, Mission %s, 3/4 in combat", self.owner.name, self.__class__.__name__)
		self.state = self.missionStates.in_combat

	def go_back(self):
		self.log.debug("Player %s, Mission %s, 4/4 going back after combat to point %s", self.owner.name, self.__class__.__name__, self.return_point)
		try:
			self.fleet.move(self.return_point, self._state_fleet_callbacks[self.missionStates.going_back])
			self.state = self.missionStates.going_back
		except MoveNotPossible:
			self.report_failure("Move was not possible when going back")

	def flee_home(self):
		if self.fleet.size() > 0:
			try:
				self.fleet.move(self.return_point, self._state_fleet_callbacks[self.missionStates.fleeing_home])
				self.state = self.missionStates.fleeing_home
			except MoveNotPossible:
				self.report_failure("Combat was lost, ships couldn't flee home")
		else:
			self.report_failure("Combat was lost, all ships were wiped out")

	@classmethod
	def create(cls, success_callback, failure_callback, fleet, target_point, return_point, enemy_player):
		return SurpriseAttack(success_callback, failure_callback, fleet, target_point, return_point, enemy_player)

decorators.bind_all(SurpriseAttack)

########NEW FILE########
__FILENAME__ = strategymanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import collections
import logging

from horizons.ai.aiplayer.combat.unitmanager import UnitManager

from horizons.ai.aiplayer.strategy.mission.chaseshipsandattack import ChaseShipsAndAttack
from horizons.ai.aiplayer.strategy.mission.pirateroutine import PirateRoutine
from horizons.ai.aiplayer.strategy.mission.scouting import ScoutingMission
from horizons.ai.aiplayer.strategy.mission.surpriseattack import SurpriseAttack
from horizons.component.storagecomponent import StorageComponent
from horizons.constants import RES
from horizons.util.python import trim_value, map_balance
from horizons.util.worldobject import WorldObject


class StrategyManager(object):
	"""
	StrategyManager object is responsible for handling major decisions in game such as
	sending fleets to battle, keeping track of diplomacy between players, declare wars.
	"""
	log = logging.getLogger("ai.aiplayer.fleetmission")

	def __init__(self, owner):
		super(StrategyManager, self).__init__()
		self.__init(owner)

	def __init(self, owner):
		self.owner = owner
		self.world = owner.world
		self.session = owner.session
		self.unit_manager = owner.unit_manager
		self.missions = set()

		# Dictionary of Condition_hash => FleetMission. Condition_hash is a key since it's searched for more often. Values are
		# unique because of WorldObject's inheritance, but it makes removing items from it in O(n).
		self.conditions_being_resolved = {}

		self.missions_to_load = {
			ScoutingMission: "ai_scouting_mission",
			SurpriseAttack: "ai_mission_surprise_attack",
			ChaseShipsAndAttack: "ai_mission_chase_ships_and_attack",
		}

	@property
	def conditions(self):
		# conditions are held in behavior manager since they are a part of behavior profile (just like actions and strategies)
		return self.owner.behavior_manager.get_conditions()

	def calculate_player_wealth_balance(self, other_player):
		"""
		Calculates wealth balance between two players.
		Wealth balance of 1.2 means that self.owner is 1.2 times wealthier than other_player.
		@param other_player: other player matched against self.owner
		@type other_player: Player
		"""

		gold_weight = 0.25 # we don't value gold that much
		resources_weight = 0.75

		resource_values = []
		for player in [self.owner, other_player]:
			resources_value = 0.0
			for settlement in player.settlements:
				resources_value += sum((self.session.db.get_res_value(resource) * amount for resource, amount
					in settlement.get_component(StorageComponent).inventory.itercontents() if self.session.db.get_res_value(resource)))
			resource_values.append(resources_value)
		ai_resources, enemy_resources = resource_values

		ai_gold = self.owner.get_component(StorageComponent).inventory[RES.GOLD]
		enemy_gold = other_player.get_component(StorageComponent).inventory[RES.GOLD]
		return (ai_resources * resources_weight + ai_gold * gold_weight) / (enemy_resources * resources_weight + enemy_gold * gold_weight)

	def calculate_player_power_balance(self, other_player):
		"""
		Calculates power balance between two players.
		Power balance of 1.2 means that self.owner is 1.2 times stronger than other_player

		@param other_player: other player who is matched against self.owner
		@type other_player: Player
		@return: power balance between self.owner and other_player
		@rtype: float
		"""

		min_balance = 10e-7
		max_balance = 1000.0

		ships = self.owner.ships.keys()
		ships = self.unit_manager.filter_ships(ships, (self.unit_manager.filtering_rules.fighting(),))
		enemy_ships = self.unit_manager.get_player_ships(other_player)
		enemy_ships = self.unit_manager.filter_ships(enemy_ships, (self.unit_manager.filtering_rules.fighting(),))

		# infinitely more powerful
		if ships and not enemy_ships:
			return max_balance

		# infinitely less powerful
		elif not ships and enemy_ships:
			return min_balance
		elif not ships and not enemy_ships:
			return 1.0

		return UnitManager.calculate_power_balance(ships, enemy_ships)

	def calculate_player_terrain_balance(self, other_player):
		"""
		Calculates balance between sizes of terrain, i.e. size on map.
		Terrain balance of 1.2 means that self.owner has 1.2 times larger terrain than other_player
		"""

		min_balance = 10e-7
		max_balance = 1000.0

		terrains = []
		island_counts = []
		for player in [self.owner, other_player]:
			terrain_total = 0
			islands = set()
			for settlement in player.settlements:
				terrain_total += len(settlement.ground_map)
				islands.add(settlement.island)
			terrains.append(terrain_total)
			island_counts.append(len(islands))

		ai_terrain, enemy_terrain = terrains
		ai_islands, enemy_islands = island_counts

		# if not
		if ai_islands and not enemy_islands:
			return max_balance
		if not ai_islands and enemy_islands:
			return min_balance
		if not ai_islands and not enemy_islands:
			return 1.0

		island_count_balance = float(ai_islands) / float(enemy_islands)

		# it favors having 3 islands of total size X, than 2 of total size X (or bigger)
		return (float(ai_terrain) / float(enemy_terrain)) * island_count_balance

	def calculate_player_balance(self, player, trimming_factor=10.0, linear_boundary=10.0):
		"""
		Calculate power balance between self.owner and other player.

		trimming_factor: Since any balance returns values of (0, inf) we agree to assume if x < 0.1 -> x = 0.1 and if x > 10.0 -> x=10.0
		linear_boundary: boundary of [-10.0, 10.0] for new balance scale

		@param player: player to calculate balance against
		@type player: Player
		@param trimming_factor: trim actual balance values to range [1./trimming_factor, trimming_factor] e.g. [0.1, 10.0]
		@type trimming_factor: float
		@param linear_boundary: boundaries of new balance scale [-linear_boundary, linear_boundary], e.g. [-10.0, 10.0]
		@type linear_boundary: float
		@return: unified balance for various variables
		@rtype: collections.namedtuple
		"""
		wealth_balance = self.owner.strategy_manager.calculate_player_wealth_balance(player)
		power_balance = self.owner.strategy_manager.calculate_player_power_balance(player)
		terrain_balance = self.owner.strategy_manager.calculate_player_terrain_balance(player)
		balance = {
			'wealth':wealth_balance,
			'power':power_balance,
			'terrain':terrain_balance,
		}
		balance = dict(( (key, trim_value(value, 1./trimming_factor, trimming_factor)) for key, value in balance.iteritems()))
		balance = dict(( (key, map_balance(value, trimming_factor, linear_boundary)) for key, value in balance.iteritems()))

		return collections.namedtuple('Balance', 'wealth, power, terrain')(**balance)

	def save(self, db):
		for mission in list(self.missions):
			mission.save(db)

		for condition, mission in self.conditions_being_resolved.iteritems():
			db("INSERT INTO ai_condition_lock (owner_id, condition, mission_id) VALUES(?, ?, ?)", self.owner.worldid, condition, mission.worldid)

	@classmethod
	def load(cls, db, owner):
		self = cls.__new__(cls)
		super(StrategyManager, self).__init__()
		self.__init(owner)
		self._load(db)
		return self

	def _load(self, db):
		for class_name, db_table in self.missions_to_load.iteritems():
			db_result = db("SELECT m.rowid FROM %s m, ai_fleet_mission f WHERE f.owner_id = ? and m.rowid = f.rowid" % db_table, self.owner.worldid)
			for (mission_id,) in db_result:
				self.missions.add(class_name.load(mission_id, self.owner, db, self.report_success, self.report_failure))

		# load condition locks
		db_result = db("SELECT condition, mission_id FROM ai_condition_lock WHERE owner_id = ?", self.owner.worldid)
		for (condition, mission_id) in db_result:
			self.conditions_being_resolved[condition] = WorldObject.get_object_by_id(mission_id)

	def report_success(self, mission, msg):
		self.log.info("Player: %s|StrategyManager|Mission %s was a success: %s", self.owner.worldid, mission, msg)
		self.end_mission(mission)

	def report_failure(self, mission, msg):
		self.log.info("Player: %s|StrategyManager|Mission %s was a failure: %s", self.owner.worldid, mission, msg)
		self.end_mission(mission)

	def end_mission(self, mission):
		self.log.info("Player: %s|StrategyManager|Mission %s ended", self.owner.worldid, mission)
		if mission in self.missions:
			self.missions.remove(mission)

		# remove condition lock (if condition was lockable) after mission ends
		self.unlock_condition(mission)
		mission.end()

	def start_mission(self, mission):
		self.log.info("Player: %s|StrategyManager|Mission %s started", self.owner.worldid, mission)
		self.missions.add(mission)
		mission.start()

	def lock_condition(self, condition, mission):
		self.conditions_being_resolved[condition] = mission

	def unlock_condition(self, mission):
		# values (FleetMission) are unique so it's possible to remove them this way:
		for condition, value in self.conditions_being_resolved.iteritems():
			if mission == value:
				del self.conditions_being_resolved[condition]
				return

	def get_missions(self, condition=None):
		"""
		Get missions filtered by certain condition (by default return all missions)
		"""
		if condition:
			return [mission for mission in self.missions if condition(mission)]
		else:
			return self.missions

	def request_to_pause_mission(self, mission, **environment):
		"""
		@return: returns True if mission is allowed to pause, False otherwise
		@rtype: bool
		"""
		# TODO: make that decision based on environment (**environment as argument)
		mission.pause_mission()
		return True

	def get_ships_for_mission(self):
		filters = self.unit_manager.filtering_rules
		rules = (filters.ship_state(self.owner.ships, (self.owner.shipStates.idle,)), filters.fighting(), filters.not_in_fleet)
		idle_ships = self.unit_manager.get_ships(rules)

		return idle_ships

	def handle_strategy(self):

		# Get all available ships that can take part in a mission
		idle_ships = self.get_ships_for_mission()

		# Get all other players
		other_players = [player for player in self.session.world.players if player != self.owner]

		# Check which conditions occur
		occuring_conditions = []

		environment = {'idle_ships': idle_ships}

		for player in other_players:
			# Prepare environment
			self.log.debug("Conditions occurring against player %s", player.name)
			environment['player'] = player

			for condition in self.conditions.keys():

				# Check whether given condition is already being resolved
				if condition.get_identifier(**environment) in self.conditions_being_resolved:
					self.log.debug("  %s: Locked", condition.__class__.__name__)
					continue

				condition_outcome = condition.check(**environment)
				self.log.debug("  %s: %s", condition.__class__.__name__, ("Yes" if condition_outcome else "No"))
				if condition_outcome:
					occuring_conditions.append((condition, condition_outcome))

			# Revert environment to previous state
			del environment['player']

		# Nothing to do when none of the conditions occur
		if occuring_conditions:
			# Choose the most important one

			selected_condition, selected_outcome = max(occuring_conditions,
				key=lambda (condition, outcome): self.conditions[condition] * outcome['certainty'])

			self.log.debug("Selected condition: %s", selected_condition.__class__.__name__)
			for key, value in selected_outcome.iteritems():
				# Insert condition-gathered info into environment
				environment[key] = value
				self.log.debug(" %s: %s", key, value)

			# Try to execute a mission that resolves given condition the best
			mission = self.owner.behavior_manager.request_strategy(**environment)
			if mission:
				self.start_mission(mission)
				if selected_condition.lockable:
					self.lock_condition(selected_condition.get_identifier(**environment), mission)

		self.log.debug("Missions:")
		for mission in list(self.missions):
			self.log.debug("%s", mission)

		self.log.debug("Fleets:")
		for fleet in list(self.unit_manager.fleets):
			self.log.debug("%s", fleet)

	def tick(self):
		self.handle_strategy()

	def end(self):
		for mission in self.missions:
			mission.end()

class PirateStrategyManager(StrategyManager):

	def __init__(self, owner):
		super(PirateStrategyManager, self).__init__(owner)
		self.__init(owner)

	def get_ships_for_mission(self):
		filters = self.unit_manager.filtering_rules
		rules = (filters.ship_state(self.owner.ships, (self.owner.shipStates.idle,)), filters.pirate, filters.not_in_fleet)
		idle_ships = self.unit_manager.get_ships(rules)
		return idle_ships

	@classmethod
	def load(cls, db, owner):
		self = cls.__new__(cls)
		super(PirateStrategyManager, self).__init__(owner)
		self.__init(owner)
		self._load(db)
		return self

	def __init(self, owner):
		self.missions_to_load = {
			PirateRoutine: "ai_mission_pirate_routine",
		}

########NEW FILE########
__FILENAME__ = trademanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import math
import logging

from collections import defaultdict

from mission.domestictrade import DomesticTrade

from building import AbstractBuilding
from horizons.util.worldobject import WorldObject
from horizons.util.worldobject import WorldObjectNotFound
from horizons.util.python import decorators
from horizons.constants import RES, STORAGE
from horizons.component.storagecomponent import StorageComponent
from horizons.component.namedcomponent import NamedComponent

class TradeManager(WorldObject):
	"""
	An object of this class manages the continuous domestic resource import process of one settlement.

	This class keeps track of how much of each resource it is importing, what the purpose
	of each import request is, and organizes the missions to transport the resources
	from the producing settlements to the one it is managing.

	The process for determining how much can be imported:
	* find out how much of each resource every other settlement can export, reserve all of it
	* run the settlement's production capacity reserve process which tries to use the local
		capacity as much as possible and if that isn't enough then ask this object for
		more: these requests get approved if we can import the required amount
	* finalize the amount and source of the imported resources, release the remaining
		amount to let the trade managers of other settlements do their work

	The process for actually getting the resources
	For this example settlement A imports from settlement B
	* TradeManager of A reserves production at the ResourceManager of B as described above
	* ResourceManager of B keeps track of how much resources it is producing for A
	* TradeManager of A sends a ship to B to pick up some resources (a DomesticTrade mission)
	* the ship arrives at the warehouse of B and calls A's TradeManager.load_resources
		which loads the ship and adjusts the data of B's ResourceManager
	* the ship arrives at the warehouse of A and unloads the resources
	"""

	log = logging.getLogger("ai.aiplayer.trademanager")

	# resources that can be produced on another island and transported to where they are needed
	legal_resources = [RES.FOOD, RES.TEXTILE, RES.LIQUOR, RES.BRICKS, RES.TOBACCO_PRODUCTS, RES.SALT, RES.MEDICAL_HERBS]

	def __init__(self, settlement_manager):
		super(TradeManager, self).__init__()
		self.__init(settlement_manager)

	def __init(self, settlement_manager):
		self.settlement_manager = settlement_manager
		self.owner = settlement_manager.owner
		self.data = {} # resource_id: SingleResourceTradeManager
		self.ships_sent = defaultdict(int) # {settlement_manager_id: num_sent, ...}

	def save(self, db):
		super(TradeManager, self).save(db)
		db("INSERT INTO ai_trade_manager(rowid, settlement_manager) VALUES(?, ?)", self.worldid, self.settlement_manager.worldid)
		for resource_manager in self.data.itervalues():
			resource_manager.save(db, self.worldid)

	def _load(self, db, settlement_manager):
		worldid = db("SELECT rowid FROM ai_trade_manager WHERE settlement_manager = ?", settlement_manager.worldid)[0][0]
		self.__init(settlement_manager)
		for db_row in db("SELECT rowid, resource_id FROM ai_single_resource_trade_manager WHERE trade_manager = ?", worldid):
			self.data[db_row[1]] = SingleResourceTradeManager.load(db, settlement_manager, db_row[0])
		super(TradeManager, self).load(db, worldid)

	@classmethod
	def load(cls, db, settlement_manager):
		self = cls.__new__(cls)
		self._load(db, settlement_manager)
		return self

	def refresh(self):
		"""Reserve the total remaining production in every other settlement and adjust quotas if necessary."""
		for resource_manager in self.data.itervalues():
			resource_manager.refresh()

	def finalize_requests(self):
		"""Release the unnecessarily reserved production capacity and decide which settlements will be providing the resources."""
		for resource_manager in self.data.itervalues():
			resource_manager.finalize_requests()

	def request_quota_change(self, quota_holder, resource_id, amount):
		"""Request that the quota of quota_holder be changed to the given amount."""
		if resource_id not in self.legal_resources:
			return
		if resource_id not in self.data:
			self.data[resource_id] = SingleResourceTradeManager(self.settlement_manager, resource_id)
		self.data[resource_id].request_quota_change(quota_holder, amount)

	def get_quota(self, quota_holder, resource_id):
		"""Return the current quota in units per tick."""
		if resource_id not in self.legal_resources:
			return 0.0
		if resource_id not in self.data:
			self.data[resource_id] = SingleResourceTradeManager(self.settlement_manager, resource_id)
		return self.data[resource_id].get_quota(quota_holder)

	def get_total_import(self, resource_id):
		"""Return the total amount of the given resource imported per tick."""
		if resource_id not in self.legal_resources:
			return 0.0
		if resource_id not in self.data:
			self.data[resource_id] = SingleResourceTradeManager(self.settlement_manager, resource_id)
		return self.data[resource_id].get_total_import()

	def load_resources(self, mission):
		"""A ship we sent out to retrieve our resources has reached the source settlement so load the resources."""
		destination_settlement_manager = mission.destination_settlement_manager
		ship = mission.ship

		total_amount = defaultdict(int)
		resource_manager = self.settlement_manager.resource_manager
		for resource_id, amount in resource_manager.trade_storage[destination_settlement_manager.worldid].iteritems():
			available_amount = int(min(math.floor(amount), self.settlement_manager.settlement.get_component(StorageComponent).inventory[resource_id]))
			if available_amount > 0:
				total_amount[resource_id] += available_amount

		destination_inventory = destination_settlement_manager.settlement.get_component(StorageComponent).inventory
		any_transferred = False
		for resource_id, amount in total_amount.iteritems():
			actual_amount = amount - ship.get_component(StorageComponent).inventory[resource_id]
			actual_amount = min(actual_amount, destination_inventory.get_limit(resource_id) - destination_inventory[resource_id])
			if actual_amount <= 0:
				continue # TODO: consider unloading the resources if there is more than needed
			any_transferred = True
			self.log.info('Transfer %d of %d to %s for a journey from %s to %s, total amount %d', actual_amount,
				resource_id, ship, self.settlement_manager.settlement.get_component(NamedComponent).name, destination_settlement_manager.settlement.get_component(NamedComponent).name, amount)
			old_amount = self.settlement_manager.settlement.get_component(StorageComponent).inventory[resource_id]
			mission.move_resource(ship, self.settlement_manager.settlement, resource_id, -actual_amount)
			actually_transferred = old_amount - self.settlement_manager.settlement.get_component(StorageComponent).inventory[resource_id]
			resource_manager.trade_storage[destination_settlement_manager.worldid][resource_id] -= actually_transferred

		destination_settlement_manager.trade_manager.ships_sent[self.settlement_manager.worldid] -= 1
		return any_transferred

	def _get_source_settlement_manager(self):
		"""Return the settlement manager of the settlement from which we should pick up resources next or None if none are needed."""
		# TODO: find a better way of getting the following constants
		ship_capacity = STORAGE.SHIP_TOTAL_STORAGE
		ship_resource_slots = STORAGE.SHIP_TOTAL_SLOTS_NUMBER

		options = [] # [(available resource amount, available number of resources, settlement_manager_id), ...]
		for settlement_manager in self.owner.settlement_managers:
			if settlement_manager is self.settlement_manager:
				continue
			resource_manager = settlement_manager.resource_manager
			num_resources = 0
			total_amount = 0
			for resource_id, amount in resource_manager.trade_storage[self.settlement_manager.worldid].iteritems():
				available_amount = int(min(math.floor(amount), settlement_manager.settlement.get_component(StorageComponent).inventory[resource_id]))
				if available_amount > 0:
					num_resources += 1
					total_amount += available_amount
			ships_needed = int(max(math.ceil(num_resources / float(ship_resource_slots)), math.ceil(total_amount / float(ship_capacity))))
			if ships_needed > self.ships_sent[settlement_manager.worldid]:
				self.log.info('have %d ships, need %d ships, %d resource types, %d total amount',
					self.ships_sent[settlement_manager.worldid], ships_needed, num_resources, total_amount)
				options.append((total_amount - ship_capacity * self.ships_sent[settlement_manager.worldid],
					num_resources - ship_resource_slots * self.ships_sent[settlement_manager.worldid], settlement_manager.worldid))
		return None if not options else WorldObject.get_object_by_id(max(options)[2])

	def organize_shipping(self):
		"""Try to send another ship to retrieve resources from one of the settlements we import from."""
		source_settlement_manager = self._get_source_settlement_manager()
		if source_settlement_manager is None:
			return # no trade ships needed

		# need to get a ship
		chosen_ship = None
		for ship, ship_state in sorted(self.owner.ships.iteritems()):
			if ship_state is self.owner.shipStates.idle:
				chosen_ship = ship
		if chosen_ship is None:
			self.owner.request_ship()
			return # no available ships

		self.owner.start_mission(DomesticTrade(source_settlement_manager, self.settlement_manager, chosen_ship, self.owner.report_success, self.owner.report_failure))
		self.ships_sent[source_settlement_manager.worldid] += 1

	def __str__(self):
		result = 'TradeManager(%s, %s)' % (self.settlement_manager.settlement.get_component(NamedComponent).name if hasattr(self.settlement_manager, 'settlement') else 'unknown',
			self.worldid if hasattr(self, 'worldid') else 'none')
		for resource_manager in self.data.itervalues():
			result += '\n' + resource_manager.__str__()
		return result

class SingleResourceTradeManager(WorldObject):
	"""An object of this class keeps track of both parties of the resource import/export deal for one resource."""

	def __init__(self, settlement_manager, resource_id):
		super(SingleResourceTradeManager, self).__init__()
		self.__init(settlement_manager, resource_id)
		self.available = 0.0 # unused resource production available per tick
		self.total = 0.0 # total resource production imported per tick

	def __init(self, settlement_manager, resource_id):
		self.settlement_manager = settlement_manager
		self.resource_id = resource_id
		self.quotas = {} # {quota_holder: amount, ...}
		self.partners = {} # {settlement_manager_id: amount, ...}
		self.identifier = '/%d,%d/trade' % (self.worldid, self.resource_id)
		self.building_ids = []
		for abstract_building in AbstractBuilding.buildings.itervalues():
			if self.resource_id in abstract_building.lines:
				self.building_ids.append(abstract_building.id)

	def save(self, db, trade_manager_id):
		super(SingleResourceTradeManager, self).save(db)
		db("INSERT INTO ai_single_resource_trade_manager(rowid, trade_manager, resource_id, available, total) VALUES(?, ?, ?, ?, ?)",
			self.worldid, trade_manager_id, self.resource_id, self.available, self.total)
		for identifier, quota in self.quotas.iteritems():
			db("INSERT INTO ai_single_resource_trade_manager_quota(single_resource_trade_manager, identifier, quota) VALUES(?, ?, ?)",
				self.worldid, identifier, quota)
		for settlement_manager_id, amount in self.partners.iteritems():
			db("INSERT INTO ai_single_resource_trade_manager_partner(single_resource_trade_manager, settlement_manager, amount) VALUES(?, ?, ?)",
				self.worldid, settlement_manager_id, amount)

	def _load(self, db, settlement_manager, worldid):
		super(SingleResourceTradeManager, self).load(db, worldid)
		resource_id, self.available, self.total = \
			db("SELECT resource_id, available, total FROM ai_single_resource_trade_manager WHERE rowid = ?", worldid)[0]
		self.__init(settlement_manager, resource_id)

		for identifier, quota in db("SELECT identifier, quota FROM ai_single_resource_trade_manager_quota WHERE single_resource_trade_manager = ?", worldid):
			self.quotas[identifier] = quota

		db_result = db("SELECT settlement_manager, amount FROM ai_single_resource_trade_manager_partner WHERE single_resource_trade_manager = ?", worldid)
		for settlement_manager_id, amount in db_result:
			self.partners[settlement_manager_id] = amount

	@classmethod
	def load(cls, db, settlement_manager, worldid):
		self = cls.__new__(cls)
		self._load(db, settlement_manager, worldid)
		return self

	def _get_current_spare_production(self):
		"""Return the total spare production including the import rate of this settlement (also reserves that amount)."""
		total = 0.0
		for settlement_manager in self.settlement_manager.owner.settlement_managers:
			if self.settlement_manager is not settlement_manager:
				resource_manager = settlement_manager.resource_manager
				resource_manager.request_deep_quota_change(self.identifier, False, self.resource_id, 100)
				total += resource_manager.get_deep_quota(self.identifier, self.resource_id)
		return total

	def refresh(self):
		"""Reserve the total remaining production in every other settlement and adjust quotas if necessary."""
		currently_used = sum(self.quotas.itervalues())
		self.total = self._get_current_spare_production()
		if self.total >= currently_used:
			self.available = self.total - currently_used
		else:
			self.available = 0.0
			# unable to honor current quota assignments, decreasing all equally
			multiplier = 0.0 if abs(self.total) < 1e-7 else self.total / currently_used
			for quota_holder in self.quotas:
				if self.quotas[quota_holder] > 1e-7:
					self.quotas[quota_holder] *= multiplier
				else:
					self.quotas[quota_holder] = 0

	def finalize_requests(self):
		"""Release the unnecessarily reserved production capacity and decide which settlements will be providing the resources."""
		options = []
		for settlement_manager in self.settlement_manager.owner.settlement_managers:
			if self.settlement_manager != settlement_manager:
				resource_manager = settlement_manager.resource_manager
				amount = resource_manager.get_deep_quota(self.identifier, self.resource_id)
				options.append((amount, resource_manager.worldid, resource_manager, settlement_manager))
		options.sort(reverse = True)

		self.partners = defaultdict(float)
		needed_amount = self.total - self.available
		for amount, _, resource_manager, settlement_manager in options:
			if needed_amount < 1e-9:
				break
			if amount > needed_amount:
				resource_manager.request_deep_quota_change(self.identifier, False, self.resource_id, needed_amount)
				self.partners[settlement_manager.worldid] += needed_amount
				needed_amount = 0
			else:
				self.partners[settlement_manager.worldid] += amount
				needed_amount -= amount
		self.total -= self.available
		self.available = 0.0

	def get_quota(self, quota_holder):
		"""Return the current quota in units per tick."""
		if quota_holder not in self.quotas:
			self.quotas[quota_holder] = 0.0
		return self.quotas[quota_holder]

	def get_total_import(self):
		"""Return the total amount of resource imported per tick."""
		return self.total - self.available

	def request_quota_change(self, quota_holder, amount):
		"""Request that the quota of quota_holder be changed to the given amount."""
		if quota_holder not in self.quotas:
			self.quotas[quota_holder] = 0.0
		amount = max(amount, 0.0)

		if abs(amount - self.quotas[quota_holder]) < 1e-7:
			pass
		elif amount < self.quotas[quota_holder]:
			# lower the amount of reserved import
			change = self.quotas[quota_holder] - amount
			self.available += change
			self.quotas[quota_holder] -= change
		else:
			# raise the amount of reserved import
			change = min(amount - self.quotas[quota_holder], self.available)
			self.available -= change
			self.quotas[quota_holder] += change

	def __str__(self):
		if not hasattr(self, "resource_id"):
			return "UninitializedSingleResourceTradeManager"
		result = 'Resource %d import %.5f/%.5f' % (self.resource_id, self.available, self.total)
		for quota_holder, quota in self.quotas.iteritems():
			result += '\n  quota assignment %.5f to %s' % (quota, quota_holder)
		for settlement_manager_id, amount in self.partners.iteritems():
			try:
				settlement = WorldObject.get_object_by_id(settlement_manager_id).settlement
				settlement_name = settlement.get_component(NamedComponent).name
			except WorldObjectNotFound:
				settlement_name = 'unknown'
			result += '\n  import %.5f from %s' % (amount, settlement_name)
		return result

decorators.bind_all(TradeManager)
decorators.bind_all(SingleResourceTradeManager)

########NEW FILE########
__FILENAME__ = unitbuilder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.util.python import decorators
from horizons.constants import BUILDINGS, PRODUCTIONLINES
from horizons.command.production import AddProduction
from horizons.world.production.producer import Producer

class UnitBuilder(object):
	"""An object of this class builds the units of one player."""

	log = logging.getLogger("ai.aiplayer.unit_builder")

	def __init__(self, owner):
		super(UnitBuilder, self).__init__()
		self.owner = owner

	def _get_boat_builders(self):
		"""Return a list of all boat builders owned by the player."""
		result = [] # [building, ...]
		for settlement_manager in self.owner.settlement_managers:
			result.extend(settlement_manager.settlement.buildings_by_id.get(BUILDINGS.BOAT_BUILDER, []))
		return result

	def build_ship(self):
		"""Build a new usable fishing boat."""
		boat_builder = self._get_boat_builders()[0]
		AddProduction(boat_builder.get_component(Producer), PRODUCTIONLINES.HUKER).execute(self.owner.session)
		production = boat_builder.get_component(Producer)._get_production(PRODUCTIONLINES.HUKER)
		production.add_production_finished_listener(self._ship_built)
		self.log.info('%s started building trading ship', self)

	def build_combat_ship(self):
		"""Build a new frigate ship"""
		boat_builder = self._get_boat_builders()[0]
		AddProduction(boat_builder.get_component(Producer), PRODUCTIONLINES.FRIGATE).execute(self.owner.session)
		production = boat_builder.get_component(Producer)._get_production(PRODUCTIONLINES.FRIGATE)
		production.add_production_finished_listener(self._ship_built)
		self.log.info('%s started building combat ship', self)

	def _ship_built(self, production):
		"""Called when a new ship has been built."""
		self.log.info('%s ship building finished', self)
		self.owner.refresh_ships()

	@property
	def num_ships_being_built(self):
		"""Return the number of ships being built by all the boat builders of the player."""
		return sum(len(boat_builder.get_component(Producer).get_production_lines()) for boat_builder in self._get_boat_builders())

	def __str__(self):
		return '%s UnitBuilder' % self.owner

decorators.bind_all(UnitBuilder)

########NEW FILE########
__FILENAME__ = villagebuilder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import copy
import math
import logging

from collections import defaultdict, deque

from horizons.ai.aiplayer.areabuilder import AreaBuilder
from horizons.ai.aiplayer.basicbuilder import BasicBuilder
from horizons.ai.aiplayer.constants import BUILD_RESULT, BUILDING_PURPOSE
from horizons.constants import AI, BUILDINGS
from horizons.util.shapes import distances, Rect
from horizons.util.python import decorators
from horizons.entities import Entities

class VillageBuilder(AreaBuilder):
	"""
	An object of this class manages the village area of a settlement.

	Important attributes:
	* plan: a dictionary of the form {(x, y): (purpose, (section, seq_no)), ...} where
		purpose is one of the BUILDING_PURPOSE constants, section is the sequence number
		of the village section and seq_no is the sequence number of a residence or None
		if it is another type of building. The plan is created in the beginning and
		changed only when land is lost.
	* special_building_assignments: {BUILDING_PURPOSE constant: {village producer coordinates: [residence coordinates, ...]}}
	* tent_queue: deque([(x, y), ...]) of remaining residence spots in the right order
	* num_sections: number of sections in the area
	* current_section: 1-based number of the section that is being filled with residences
	* roads_built: boolean showing whether all planned roads in the area have been built
	"""

	log = logging.getLogger("ai.aiplayer")

	def __init__(self, settlement_manager):
		super(VillageBuilder, self).__init__(settlement_manager)
		self.__init(settlement_manager)
		if not self.land_manager.feeder_island:
			self._create_plan()

	def __init(self, settlement_manager):
		self.land_manager = settlement_manager.land_manager
		self.tent_queue = deque()
		self._init_cache()
		self.roads_built = False
		self.personality = self.owner.personality_manager.get('VillageBuilder')

		if self.land_manager.feeder_island:
			self.num_sections = 0
			self.current_section = 0

	def save(self, db):
		super(VillageBuilder, self).save(db)
		db("INSERT INTO ai_village_builder(rowid, settlement_manager, num_sections, current_section) VALUES(?, ?, ?, ?)",
			self.worldid, self.settlement_manager.worldid, self.num_sections, self.current_section)

		db_query = 'INSERT INTO ai_village_builder_plan(village_builder, x, y, purpose, section, seq_no) VALUES(?, ?, ?, ?, ?, ?)'
		for (x, y), (purpose, (section, seq_no)) in self.plan.iteritems():
			db(db_query, self.worldid, x, y, purpose, section, seq_no)

	def _load(self, db, settlement_manager):
		db_result = db("SELECT rowid, num_sections, current_section FROM ai_village_builder WHERE settlement_manager = ?", settlement_manager.worldid)
		worldid, self.num_sections, self.current_section = db_result[0]
		super(VillageBuilder, self)._load(db, settlement_manager, worldid)
		self.__init(settlement_manager)

		db_result = db("SELECT x, y, purpose, section, seq_no FROM ai_village_builder_plan WHERE village_builder = ?", worldid)
		for x, y, purpose, section, seq_no in db_result:
			self.plan[(x, y)] = (purpose, (section, seq_no))
			if purpose == BUILDING_PURPOSE.ROAD:
				self.land_manager.roads.add((x, y))

		self._recreate_tent_queue()
		self._create_special_village_building_assignments()

	def _get_village_section_coordinates(self, start_x, start_y, width, height):
		"""Return set([(x, y), ...]) of usable coordinates in the rectangle defined by the parameters."""
		warehouse_coords_set = set(self.land_manager.settlement.warehouse.position.tuple_iter())
		result = set()
		for dx in xrange(width):
			for dy in xrange(height):
				coords = (start_x + dx, start_y + dy)
				if coords in self.land_manager.village and self.land_manager.coords_usable(coords) and coords not in warehouse_coords_set:
					result.add(coords)
		return result

	def _create_plan(self):
		"""
		Create the area plan.

		The algorithm:
		* find a way to cut the village area into rectangular section_plans
		* each section gets a plan with a main square, roads, and residence locations
		* the plan is stitched together and other village buildings are by replacing some
			of the residences
		"""

		xs = set([x for (x, _) in self.land_manager.village])
		ys = set([y for (_, y) in self.land_manager.village])

		width = max(xs) - min(xs) + 1
		height = max(ys) - min(ys) + 1
		horizontal_sections = int(math.ceil(float(width) / self.personality.max_village_section_size))
		vertical_sections = int(math.ceil(float(height) / self.personality.max_village_section_size))

		section_plans = [] # [{(x, y): BUILDING_PURPOSE constant, ...}, ...]
		vertical_roads = set() # set([x, ...])
		horizontal_roads = set() # set([y, ...])

		# partition with roads between the sections
		start_y = min(ys)
		section_width = width // horizontal_sections
		section_height = height // vertical_sections
		section_coords_set_list = []
		for i in xrange(vertical_sections):
			bottom_road = i + 1 < vertical_sections
			max_y = min(max(ys), start_y + section_height)
			current_height = max_y - start_y + 1
			start_x = min(xs)

			for j in xrange(horizontal_sections):
				right_road = j + 1 < horizontal_sections
				max_x = min(max(xs), start_x + section_width)
				current_width = max_x - start_x + 1
				section_coords_set_list.append(self._get_village_section_coordinates(start_x, start_y, current_width - right_road, current_height - bottom_road))
				start_x += current_width
				if i == 0 and right_road:
					vertical_roads.add(start_x - 1)

			start_y += current_height
			if bottom_road:
				horizontal_roads.add(start_y - 1)

		for section_coords_set in section_coords_set_list:
			section_plan = self._create_section_plan(section_coords_set, vertical_roads, horizontal_roads)
			section_plans.append(section_plan[1])

		self._stitch_sections_together(section_plans, vertical_roads, horizontal_roads)
		self._return_unused_space()

	def _stitch_sections_together(self, section_plans, vertical_roads, horizontal_roads):
		"""
		Complete creating the plan by stitching the sections together and creating the tent queue.

		@param section_plans: list of section plans in the format [{(x, y): BUILDING_PURPOSE constant, ...}, ...]
		@param vertical_roads: vertical roads between the sections in the form set([x, ...])
		@param horizontal_roads: horizontal roads between the sections in the form set([y, ...])
		"""

		self.plan = {}
		ys = set(zip(*self.land_manager.village.keys())[1])
		set([y for (_, y) in self.land_manager.village])
		for road_x in vertical_roads:
			for road_y in ys:
				coords = (road_x, road_y)
				if self.land_manager.coords_usable(coords):
					self.plan[coords] = (BUILDING_PURPOSE.ROAD, (0, None))

		xs = set(zip(*self.land_manager.village.keys())[0])
		for road_y in horizontal_roads:
			for road_x in xs:
				coords = (road_x, road_y)
				if self.land_manager.coords_usable(coords):
					self.plan[coords] = (BUILDING_PURPOSE.ROAD, (0, None))

		for i, section_plan in enumerate(section_plans):
			self._optimize_section_plan(section_plan)
			tent_lookup = self._create_tent_queue(section_plan)
			for coords, purpose in section_plan.iteritems():
				self.plan[coords] = (purpose, (i, tent_lookup[coords]))
		self.num_sections = len(section_plans)
		self.current_section = 0
		self._reserve_special_village_building_spots()
		self._recreate_tent_queue()

		# add potential roads to the island's network
		for coords, (purpose, _) in self.plan.iteritems():
			if purpose == BUILDING_PURPOSE.ROAD:
				self.land_manager.roads.add(coords)

	@classmethod
	def _remove_unreachable_roads(cls, section_plan, main_square):
		"""
		Remove the roads that can't be reached by starting from the main square.

		@param section_plan: {(x, y): BUILDING_PURPOSE constant, ...}
		@param main_square: Rect representing the position of the main square
		"""

		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		reachable = set()
		queue = deque()
		for (x, y) in main_square.tuple_iter():
			for (dx, dy) in moves:
				coords = (x + dx, y + dy)
				if coords in section_plan and section_plan[coords] == BUILDING_PURPOSE.ROAD:
					queue.append(coords)
					reachable.add(coords)

		while queue:
			(x, y) = queue.popleft()
			for dx, dy in moves:
				coords = (x + dx, y + dy)
				if coords in section_plan and section_plan[coords] == BUILDING_PURPOSE.ROAD and coords not in reachable:
					reachable.add(coords)
					queue.append(coords)

		to_remove = []
		for coords, purpose in section_plan.iteritems():
			if purpose == BUILDING_PURPOSE.ROAD and coords not in reachable:
				to_remove.append(coords)
		for coords in to_remove:
			section_plan[coords] = BUILDING_PURPOSE.NONE

	def _get_possible_building_positions(self, section_coords_set, size):
		"""Return {(x, y): Rect, ...} that contains every size x size potential building location where only the provided coordinates are legal."""
		result = {}
		for (x, y) in sorted(section_coords_set):
			ok = True
			for dx in xrange(size[0]):
				for dy in xrange(size[1]):
					coords = (x + dx, y + dy)
					if coords not in section_coords_set or not self.land_manager.coords_usable(coords):
						ok = False
						break
				if not ok:
					break
			if ok:
				result[(x, y)] = Rect.init_from_topleft_and_size_tuples((x, y), size)
		return result

	def _create_section_plan(self, section_coords_set, vertical_roads, horizontal_roads):
		"""
		Create the section plan that contains the main square, roads, and residence positions.

		The algorithm is as follows:
		* place the main square
		* form a road grid to support the tents
		* choose the best one by preferring the one with more residence locations and less
			unreachable / blocked / parallel side by side roads.

		@param section_plans: list of section plans in the format [{(x, y): BUILDING_PURPOSE constant, ...}, ...]
		@param vertical_roads: vertical roads between the sections in the form set([x, ...])
		@param horizontal_roads: horizontal roads between the sections in the form set([y, ...])
		@return: (number of residences in the plan, the plan in the form {(x, y): BUILDING_PURPOSE constant}
		"""

		best_plan = {}
		best_tents = 0
		best_value = -1
		tent_squares = [(0, 0), (0, 1), (1, 0), (1, 1)]
		road_connections = [(-1, 0), (-1, 1), (0, -1), (0, 2), (1, -1), (1, 2), (2, 0), (2, 1)]
		tent_radius_sq = Entities.buildings[BUILDINGS.RESIDENTIAL].radius ** 2

		xs = set(x for (x, _) in section_coords_set)
		for x in vertical_roads:
			if x - 1 in xs or x + 1 in xs:
				xs.add(x)
		xs = sorted(xs)

		ys = set(y for (_, y) in section_coords_set)
		for y in horizontal_roads:
			if y - 1 in ys or y + 1 in ys:
				ys.add(y)
		ys = sorted(ys)

		distance_rect_rect_sq = distances.distance_rect_rect_sq
		possible_road_positions = self._get_possible_building_positions(section_coords_set, (1, 1))
		possible_residence_positions = self._get_possible_building_positions(section_coords_set, Entities.buildings[BUILDINGS.RESIDENTIAL].size)
		possible_main_square_positions = self._get_possible_building_positions(section_coords_set, Entities.buildings[BUILDINGS.MAIN_SQUARE].size)

		for (x, y), main_square in sorted(possible_main_square_positions.iteritems()):
			section_plan = dict.fromkeys(section_coords_set, BUILDING_PURPOSE.NONE)
			bad_roads = 0
			good_tents = 0
			double_roads = 0

			# place the main square
			for coords in main_square.tuple_iter():
				section_plan[coords] = BUILDING_PURPOSE.RESERVED
			section_plan[(x, y)] = BUILDING_PURPOSE.MAIN_SQUARE

			# place the roads running parallel to the y-axis
			last_road_y = None
			for road_y in ys:
				if road_y not in horizontal_roads:
					if road_y < y:
						if (y - road_y) % 5 != 1:
							continue
					else:
						if road_y < y + 6 or (road_y - y) % 5 != 1:
							continue

				if last_road_y == road_y - 1:
					double_roads += 1
				last_road_y = road_y

				for road_x in xs:
					if road_x not in vertical_roads:
						coords = (road_x, road_y)
						if coords in possible_road_positions:
							section_plan[coords] = BUILDING_PURPOSE.ROAD
						else:
							bad_roads += 1

			# place the roads running parallel to the x-axis
			last_road_x = None
			for road_x in xs:
				if road_x not in vertical_roads:
					if road_x < x:
						if (x - road_x) % 5 != 1:
							continue
					else:
						if road_x < x + 6 or (road_x - x) % 5 != 1:
							continue

				if last_road_x == road_x - 1:
					double_roads += 1
				last_road_x = road_x

				for road_y in ys:
					if road_y not in horizontal_roads:
						coords = (road_x, road_y)
						if coords in possible_road_positions:
							section_plan[coords] = BUILDING_PURPOSE.ROAD
						else:
							bad_roads += 1

			if bad_roads > 0:
				self._remove_unreachable_roads(section_plan, main_square)

			# place the tents
			for coords, position in sorted(possible_residence_positions.iteritems()):
				ok = True
				for dx, dy in tent_squares:
					coords2 = (coords[0] + dx, coords[1] + dy)
					if section_plan[coords2] != BUILDING_PURPOSE.NONE:
						ok = False
						break
				if not ok:
					continue
				if distance_rect_rect_sq(main_square, position) > tent_radius_sq:
					continue # unable to build or out of main square range

				# is there a road connection?
				ok = False
				for dx, dy in road_connections:
					coords2 = (coords[0] + dx, coords[1] + dy)
					if coords2 in section_plan and section_plan[coords2] == BUILDING_PURPOSE.ROAD:
						ok = True
						break

				# connection to a road tile exists, build the tent
				if ok:
					for dx, dy in tent_squares:
						section_plan[(coords[0] + dx, coords[1] + dy)] = BUILDING_PURPOSE.RESERVED
					section_plan[coords] = BUILDING_PURPOSE.RESIDENCE
					good_tents += 1

			value = self.personality.tent_value * good_tents - self.personality.bad_road_penalty * bad_roads - self.personality.double_road_penalty * double_roads
			if best_value < value:
				best_plan = section_plan
				best_tents = good_tents
				best_value = value
		return (best_tents, best_plan)

	def _optimize_section_plan(self, section_plan):
		"""Try to fit more residences into the grid."""
		# calculate distance from the main square to every tile
		road_connections = [(-1, 0), (-1, 1), (0, -1), (0, 2), (1, -1), (1, 2), (2, 0), (2, 1)]
		tent_squares = [(0, 0), (0, 1), (1, 0), (1, 1)]
		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		distance = {}
		queue = deque()

		for coords, purpose in sorted(section_plan.iteritems()):
			if purpose == BUILDING_PURPOSE.MAIN_SQUARE:
				for coords in self._get_position(coords, BUILDINGS.MAIN_SQUARE).tuple_iter():
					distance[coords] = 0
					queue.append(coords)

		while queue:
			(x, y) = queue.popleft()
			for dx, dy in moves:
				coords = (x + dx, y + dy)
				if coords in section_plan and coords not in distance:
					distance[coords] = distance[(x, y)] + 1
					queue.append(coords)

		# remove planned tents from the section plan
		for (x, y) in section_plan:
			coords = (x, y)
			if section_plan[coords] == BUILDING_PURPOSE.RESIDENCE:
				for dx, dy in tent_squares:
					section_plan[(x + dx, y + dy)] = BUILDING_PURPOSE.NONE

		# create new possible tent position list
		possible_tents = []
		for coords in sorted(section_plan):
			if coords in distance and section_plan[coords] == BUILDING_PURPOSE.NONE:
				possible_tents.append((distance[coords], coords))
		possible_tents.sort()

		# place the tents
		for _, (x, y) in possible_tents:
			ok = True
			for dx, dy in tent_squares:
				coords = (x + dx, y + dy)
				if coords not in section_plan or section_plan[coords] != BUILDING_PURPOSE.NONE:
					ok = False
					break
			if not ok:
				continue

			# is there a road connection?
			ok = False
			for dx, dy in road_connections:
				coords = (x + dx, y + dy)
				if coords in section_plan and section_plan[coords] == BUILDING_PURPOSE.ROAD:
					ok = True
					break

			# connection to a road tile exists, build the tent
			if ok:
				for dx, dy in tent_squares:
					section_plan[(x + dx, y + dy)] = BUILDING_PURPOSE.RESERVED
				section_plan[(x, y)] = BUILDING_PURPOSE.RESIDENCE

	def _return_unused_space(self):
		"""Return the area that remains unused after creating the plan."""
		not_needed = []
		for coords in self.land_manager.village:
			if coords not in self.plan or self.plan[coords][0] == BUILDING_PURPOSE.NONE:
				not_needed.append(coords)
		for coords in not_needed:
			# if the warehouse is (partly) in the village area then it needs to be handed over but it won't be in the plan at all
			if coords in self.plan:
				del self.plan[coords]
			self.land_manager.add_to_production(coords)

	@classmethod
	def _get_position(cls, coords, building_id):
		"""Return the position Rect of a building of the given type at the given position."""
		return Rect.init_from_topleft_and_size_tuples(coords, Entities.buildings[building_id].size)

	def _get_sorted_building_positions(self, building_purpose):
		"""Return a list of sorted building positions in the form [Rect, ...]."""
		building_id = BUILDING_PURPOSE.purpose_to_building[building_purpose]
		return sorted(self._get_position(coords, building_id) for coords, (purpose, _) in self.plan.iteritems() if purpose == building_purpose)

	def _replace_planned_residence(self, new_purpose, max_buildings, capacity):
		"""
		Replace up to max_buildings residence spots with buildings of purpose new_purpose.

		This function is used to amend the existing plan with village producers such as
		pavilions, schools, and taverns. The goal is to place as few of them as needed
		while still covering the maximum number of residences.

		@param new_purpose: the BUILDING_PURPOSE constant of the new buildings
		@param max_buildings: maximum number of residences to replace
		@param capacity: maximum number of residences one of the new buildings can service
		"""

		distance_rect_rect_sq = distances.distance_rect_rect_sq
		distance_rect_tuple = distances.distance_rect_tuple
		tent_range_sq = Entities.buildings[BUILDINGS.RESIDENTIAL].radius ** 2
		planned_tents = self._get_sorted_building_positions(BUILDING_PURPOSE.RESIDENCE)

		possible_positions = copy.copy(planned_tents)
		if new_purpose == BUILDING_PURPOSE.TAVERN:
			# filter out the positions that are too far from the main squares and the warehouse
			tavern_radius_sq = Entities.buildings[BUILDINGS.TAVERN].radius ** 2
			storage_positions = self._get_sorted_building_positions(BUILDING_PURPOSE.MAIN_SQUARE)
			storage_positions.append(self.settlement_manager.settlement.warehouse.position)
			possible_positions = [rect for rect in possible_positions if any(distance_rect_rect_sq(rect, storage_rect) <= tavern_radius_sq for storage_rect in storage_positions)]

		num_kept = int(min(len(possible_positions), max(self.personality.min_coverage_building_options, len(possible_positions) * self.personality.coverage_building_option_ratio)))
		possible_positions = self.session.random.sample(possible_positions, num_kept)

		def get_centroid(planned, blocked):
			total_x, total_y = 0, 0
			for position in planned_tents:
				if position not in blocked:
					total_x += position.left
					total_y += position.top
			mid_x = total_x / float(len(planned) - len(blocked))
			mid_y = total_y / float(len(planned) - len(blocked))
			return (mid_x, mid_y)

		def get_centroid_distance_pairs(planned, blocked):
			centroid = get_centroid(planned_tents, blocked)
			positions = []
			for position in planned_tents:
				if position not in blocked:
					positions.append((distance_rect_tuple(position, centroid), position))
			positions.sort(reverse = True)
			return positions

		for _ in xrange(max_buildings):
			if len(planned_tents) <= 1:
				break
			best_score = None
			best_pos = None

			for replaced_pos in possible_positions:
				positions = get_centroid_distance_pairs(planned_tents, set([replaced_pos]))
				score = 0
				in_range = 0
				for distance_to_centroid, position in positions:
					if in_range < capacity and distance_rect_rect_sq(replaced_pos, position) <= tent_range_sq:
						in_range += 1
					else:
						score += distance_to_centroid
				if best_score is None or best_score > score:
					best_score = score
					best_pos = replaced_pos

			in_range = 0
			positions = zip(*get_centroid_distance_pairs(planned_tents, set([best_pos])))[1]
			for position in positions:
				if in_range < capacity and distance_rect_rect_sq(best_pos, position) <= tent_range_sq:
					planned_tents.remove(position)
					in_range += 1
			if not in_range:
				continue

			possible_positions.remove(best_pos)
			coords = best_pos.origin.to_tuple()
			self.register_change_list([coords], new_purpose, (self.plan[coords][1][0], None))

	def _reserve_special_village_building_spots(self):
		"""Replace residence spots with special village buildings such as pavilions, schools, taverns, doctors and fire stations."""
		num_other_buildings = 0 # the maximum number of each village producer that should be placed
		residences = len(self.tent_queue)
		while residences > 0:
			num_other_buildings += 3
			residences -= 3 + self.personality.normal_coverage_building_capacity

		self._replace_planned_residence(BUILDING_PURPOSE.PAVILION, num_other_buildings, self.personality.max_coverage_building_capacity)
		self._replace_planned_residence(BUILDING_PURPOSE.VILLAGE_SCHOOL, num_other_buildings, self.personality.max_coverage_building_capacity)
		self._replace_planned_residence(BUILDING_PURPOSE.TAVERN, num_other_buildings, self.personality.max_coverage_building_capacity)

		num_fire_stations = max(0, int(round(0.5 + (len(self.tent_queue) - 3 * num_other_buildings) // self.personality.normal_fire_station_capacity)))
		self._replace_planned_residence(BUILDING_PURPOSE.FIRE_STATION, num_fire_stations, self.personality.max_fire_station_capacity)

		num_doctors = max(0, int(round(0.5 + (len(self.tent_queue) - 3 * num_other_buildings) // self.personality.normal_doctor_capacity)))
		self._replace_planned_residence(BUILDING_PURPOSE.DOCTOR, num_doctors, self.personality.max_doctor_capacity)


		self._create_special_village_building_assignments()

	def _create_special_village_building_assignments(self):
		"""
		Create an assignment of residence spots to special village building spots.

		This is useful for deciding which of the special village buildings would be most useful.
		"""

		distance_rect_rect = distances.distance_rect_rect
		self.special_building_assignments = {} # {BUILDING_PURPOSE constant: {village producer coordinates: [residence coordinates, ...]}}
		residence_positions = self._get_sorted_building_positions(BUILDING_PURPOSE.RESIDENCE)

		building_types = []
		for purpose in [BUILDING_PURPOSE.PAVILION, BUILDING_PURPOSE.VILLAGE_SCHOOL, BUILDING_PURPOSE.TAVERN]:
			building_types.append((purpose, Entities.buildings[BUILDINGS.RESIDENTIAL].radius, self.personality.max_coverage_building_capacity))
		building_types.append((BUILDING_PURPOSE.FIRE_STATION, Entities.buildings[BUILDINGS.FIRE_STATION].radius, self.personality.max_fire_station_capacity))
		building_types.append((BUILDING_PURPOSE.DOCTOR, Entities.buildings[BUILDINGS.DOCTOR].radius, self.personality.max_doctor_capacity))

		for purpose, range, max_capacity in building_types:
			producer_positions = sorted(self._get_position(coords, BUILDING_PURPOSE.get_building(purpose)) for coords, (pos_purpose, _) in self.plan.iteritems() if pos_purpose == purpose)
			self.special_building_assignments[purpose] = {}
			for producer_position in producer_positions:
				self.special_building_assignments[purpose][producer_position.origin.to_tuple()] = []

			options = []
			for producer_position in producer_positions:
				for position in residence_positions:
					distance = distance_rect_rect(producer_position, position)
					if distance <= range:
						options.append((distance, producer_position.origin.to_tuple(), position.origin.to_tuple()))
			options.sort(reverse = True)

			assigned_residence_coords = set()
			for _, producer_coords, residence_coords in options:
				if residence_coords in assigned_residence_coords:
					continue
				if len(self.special_building_assignments[purpose][producer_coords]) >= max_capacity:
					continue
				assigned_residence_coords.add(residence_coords)
				self.special_building_assignments[purpose][producer_coords].append(residence_coords)

	def _create_tent_queue(self, section_plan):
		"""
		Place the residences of a section in a visually appealing order; save the result in the tent queue.

		The algorithm:
		* split the residences of the section into blocks where a block is formed of all
			residence spots that share sides
		* calculate the distance from the main square to the block
		* form the final sequence by sorting the blocks by distance to the main square and
			by sorting the residences of a block by their coordinates

		@return: {(x, y): residence sequence number}
		"""
		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		blocks = []
		block = {}

		# form blocks of tents
		main_square = None
		for coords, purpose in sorted(section_plan.iteritems()):
			if purpose == BUILDING_PURPOSE.MAIN_SQUARE:
				main_square = self._get_position(coords, BUILDINGS.MAIN_SQUARE)
			if purpose != BUILDING_PURPOSE.RESIDENCE or coords in block:
				continue
			block[coords] = len(blocks)

			block_list = [coords]
			queue = deque()
			explored = set([coords])
			queue.append(coords)
			while queue:
				(x, y) = queue.popleft()
				for dx, dy in moves:
					coords = (x + dx, y + dy)
					if coords not in section_plan or coords in explored:
						continue
					if section_plan[coords] == BUILDING_PURPOSE.RESIDENCE or section_plan[coords] == BUILDING_PURPOSE.RESERVED:
						explored.add(coords)
						queue.append(coords)
						if section_plan[coords] == BUILDING_PURPOSE.RESIDENCE:
							block[coords] = len(blocks)
							block_list.append(coords)
			blocks.append(block_list)

		# calculate distance from the main square to the block
		distance_rect_tuple = distances.distance_rect_tuple
		block_distances = []
		for coords_list in blocks:
			distance = 0
			for coords in coords_list:
				distance += distance_rect_tuple(main_square, coords)
			block_distances.append((distance / len(coords_list), coords_list))

		# form the sorted tent queue
		result = defaultdict(lambda: None)
		if block_distances:
			for block in zip(*sorted(block_distances))[1]:
				for coords in sorted(block):
					result[coords] = len(self.tent_queue)
					self.tent_queue.append(coords)
		return result

	def _recreate_tent_queue(self, removal_location=None):
		"""Recreate the tent queue making sure that the possibly removed location is missing."""
		queue = []
		for coords, (purpose, (_, seq_no)) in self.plan.iteritems():
			if purpose == BUILDING_PURPOSE.RESIDENCE:
				object = self.island.ground_map[coords].object
				if object is None or object.id != BUILDINGS.RESIDENTIAL or removal_location == coords:
					queue.append((seq_no, coords))
		if queue:
			self.tent_queue = deque(zip(*sorted(queue))[1])
		else:
			self.tent_queue = deque()

	def build_roads(self):
		"""Try to build all roads in the village area, record the result in the field roads_built."""
		all_built = True
		for coords, (purpose, (section, _)) in sorted(self.plan.iteritems()):
			if section > self.current_section or coords not in self.settlement.ground_map:
				all_built = False
				continue
			if purpose != BUILDING_PURPOSE.ROAD:
				continue
			object = self.settlement.ground_map[coords].object
			if object is not None and not object.buildable_upon:
				continue
			if not self.have_resources(BUILDINGS.TRAIL):
				all_built = False
				break
			assert BasicBuilder(BUILDINGS.TRAIL, coords, 0).execute(self.land_manager)
		self.roads_built = all_built

	def build_tent(self, coords=None):
		"""Build the next tent (or the specified one if coords is not None)."""
		if not self.tent_queue:
			return BUILD_RESULT.IMPOSSIBLE

		# can_trigger_next_section is used to start building the next section when the old one is done
		# if a tent is built just to extend the area then that can't trigger the next section
		# TODO: handle extension tents nicer than just letting them die
		can_trigger_next_section = False
		if coords is None:
			coords = self.tent_queue[0]
			can_trigger_next_section = True

		ok = True
		x, y = coords
		owned_by_other = False
		size = Entities.buildings[BUILDINGS.RESIDENTIAL].size
		for dx in xrange(size[0]):
			for dy in xrange(size[1]):
				coords2 = (x + dx, y + dy)
				if coords2 not in self.settlement.ground_map:
					ok = False
					if self.island.ground_map[coords2].settlement is not None:
						owned_by_other = True

		if ok and not owned_by_other:
			if not self.have_resources(BUILDINGS.RESIDENTIAL):
				return BUILD_RESULT.NEED_RESOURCES
			assert BasicBuilder(BUILDINGS.RESIDENTIAL, (x, y), 0).execute(self.land_manager)

		if ok or owned_by_other:
			if self.tent_queue[0] == coords:
				self.tent_queue.popleft()
			else:
				for i in xrange(len(self.tent_queue)):
					if self.tent_queue[i] == coords:
						del self.tent_queue[i]
						break
			if owned_by_other:
				self.log.debug('%s tent position owned by other player at (%d, %d)', self, x, y)
				return BUILD_RESULT.IMPOSSIBLE

		if not ok:
			# need to extends the area, it is not owned by another player
			self.log.debug('%s tent position not owned by the player at (%d, %d), extending settlement area instead', self, x, y)
			return self.extend_settlement(Rect.init_from_topleft_and_size(x, y, size[0], size[1]))

		if not self.roads_built:
			self.build_roads()
		if can_trigger_next_section and self.plan[coords][1][0] > self.current_section:
			self.current_section = self.plan[coords][1][0]
		return BUILD_RESULT.OK

	def handle_lost_area(self, coords_list):
		"""
		Handle losing the potential land in the given coordinates list.

		Take the following actions:
		* remove the lost area from the village and road areas
		* remove village sections with impossible main squares
		* remove all planned buildings that are now impossible
		* TODO: if the village area takes too much of the total area then remove / reduce the remaining sections
		"""

		# remove village sections with impossible main squares
		removed_sections = set()
		for coords, (purpose, (section, _)) in self.plan.iteritems():
			if purpose != BUILDING_PURPOSE.MAIN_SQUARE:
				continue
			possible = True
			for main_square_coords in self._get_position(coords, BUILDINGS.MAIN_SQUARE).tuple_iter():
				if main_square_coords not in self.land_manager.village:
					possible = False
					break
			if not possible:
				# impossible to build the main square because a part of the area is owned by another player: remove the whole section
				removed_sections.add(section)

		removed_coords_list = []
		for coords, (purpose, (section, _)) in self.plan.iteritems():
			if purpose == BUILDING_PURPOSE.RESERVED or purpose == BUILDING_PURPOSE.NONE:
				continue
			position = self._get_position(coords, BUILDING_PURPOSE.get_building(purpose))
			building = self.settlement.ground_map[coords].object if coords in self.settlement.ground_map else None

			if section in removed_sections:
				if purpose == BUILDING_PURPOSE.ROAD:
					if building is None or building.id != BUILDINGS.TRAIL:
						removed_coords_list.append(coords)
					continue # leave existing roads behind
				elif building is not None and not building.buildable_upon:
					# TODO: remove the actual building
					pass

				for building_coords in position.tuple_iter():
					removed_coords_list.append(building_coords)
			else:
				# remove the planned village buildings that are no longer possible
				if purpose == BUILDING_PURPOSE.ROAD:
					if coords not in self.land_manager.village:
						removed_coords_list.append(coords)
					continue

				possible = True
				for building_coords in position.tuple_iter():
					if building_coords not in self.land_manager.village:
						possible = False
				if possible:
					continue

				for building_coords in position.tuple_iter():
					removed_coords_list.append(building_coords)

		for coords in removed_coords_list:
			del self.plan[coords]
		self._recreate_tent_queue()
		# TODO: renumber the sections
		# TODO: create a new plan with village producers
		self._return_unused_space()
		self._create_special_village_building_assignments()
		super(VillageBuilder, self).handle_lost_area(coords_list)

	def remove_building(self, building):
		"""Called when a building is removed from the area (the building still exists during the call)."""
		if building.id == BUILDINGS.RESIDENTIAL:
			self._recreate_tent_queue(building.position.origin.to_tuple())

		super(VillageBuilder, self).remove_building(building)

	def display(self):
		"""Show the plan on the map unless it is disabled in the settings."""
		if not AI.HIGHLIGHT_PLANS:
			return

		unknown_color = (255, 0, 0)
		renderer = self.session.view.renderer['InstanceRenderer']

		tile_colors = {
			BUILDING_PURPOSE.MAIN_SQUARE:    (255,   0, 255),
			BUILDING_PURPOSE.RESIDENCE:      (255, 255, 255),
			BUILDING_PURPOSE.ROAD:           ( 30,  30,  30),
			BUILDING_PURPOSE.VILLAGE_SCHOOL: (128, 128, 255),
			BUILDING_PURPOSE.PAVILION:       (255, 128, 128),
			BUILDING_PURPOSE.TAVERN:         (255, 255,   0),
			BUILDING_PURPOSE.FIRE_STATION:   (255,  64,  64),
			BUILDING_PURPOSE.DOCTOR:         (255, 128,  64),
			BUILDING_PURPOSE.RESERVED:       (  0,   0, 255),
		}
		for coords, (purpose, _) in self.plan.iteritems():
			tile = self.island.ground_map[coords]
			color = tile_colors.get(purpose, unknown_color)
			renderer.addColored(tile._instance, *color)

	def __str__(self):
		return '%s VillageBuilder(%s)' % (self.settlement_manager, self.worldid if hasattr(self, 'worldid') else 'none')

decorators.bind_all(VillageBuilder)

########NEW FILE########
__FILENAME__ = generic
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import weakref

from horizons.world.player import Player
from horizons.scheduler import Scheduler
from horizons.ext.enum import Enum
from horizons.world.units.movingobject import MoveNotPossible
from horizons.util.python.callback import Callback
from horizons.constants import GAME_SPEED

class GenericAI(Player):
	"""Class for AI players implementing generic stuff."""

	shipStates = Enum('idle', 'moving_random')

	def __init__(self, *args, **kwargs):
		super(GenericAI, self).__init__(*args, **kwargs)
		self.__init()

	def __init(self):
		self.ships = weakref.WeakValueDictionary() # {ship : state}. used as list of ships and structure to know their state

	def _load(self, db, worldid):
		super(GenericAI, self)._load(db, worldid)
		self.__init()

	def send_ship(self, ship):
		self.send_ship_random(ship)

	def send_ship_random(self, ship):
		"""Sends a ship to a random position on the map.
		@param ship: Ship instance that is to be used."""
		# find random position
		point = self.session.world.get_random_possible_ship_position()
		self.log.debug("%s %s: moving to random location %d, %d", self.__class__.__name__, self.worldid, point.x, point.y)
		# move ship there:
		try:
			ship.move(point, Callback(self.ship_idle, ship))
		except MoveNotPossible:
			self.log.info("%s %s: ship blocked", self.__class__.__name__, self.worldid)
			# retry moving ship in 2 secs
			Scheduler().add_new_object(Callback(self.ship_idle, ship), self,
			                           GAME_SPEED.TICKS_PER_SECOND * 2)
			return
		self.ships[ship] = self.shipStates.moving_random

	def ship_idle(self, ship):
		"""Called if a ship is idle. Sends ship to a random place.
		@param ship: ship instance"""
		self.log.debug("%s %s: idle, moving to random location", self.__class__.__name__, self.worldid)
		Scheduler().add_new_object(Callback(self.send_ship, ship), self)

	def end(self):
		self.ships = None
		super(GenericAI, self).end()

########NEW FILE########
__FILENAME__ = pirate
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
from horizons.ai.aiplayer.behavior import BehaviorManager
from horizons.ai.aiplayer.behavior.profile import BehaviorProfileManager
from horizons.ai.aiplayer.combat.combatmanager import PirateCombatManager
from horizons.ai.aiplayer.combat.unitmanager import UnitManager
from horizons.ai.aiplayer.strategy.strategymanager import PirateStrategyManager
from horizons.scheduler import Scheduler
from horizons.util.python.callback import Callback
from horizons.util.shapes import Point
from horizons.util.worldobject import WorldObject
from horizons.constants import UNITS
from horizons.ext.enum import Enum
from horizons.ai.generic import GenericAI
from horizons.command.unit import CreateUnit
from horizons.world.units.ship import TradeShip
from horizons.world.units.pirateship import PirateShip
from horizons.component.selectablecomponent import SelectableComponent


class Pirate(GenericAI):
	"""A pirate ship moving randomly around. If another ship comes into the reach
	of it, it will be followed for a short time."""

	# TODO: Move on_a_mission to GenericAI
	shipStates = Enum.get_extended(GenericAI.shipStates, 'on_a_mission', 'chasing_ship', 'going_home')

	log = logging.getLogger("ai.pirate")
	regular_player = False

	caught_ship_radius = 5
	home_radius = 2

	ship_count = 1

	tick_interval = 32
	tick_long_interval = 128

	def __init__(self, session, id, name, color, **kwargs):
		super(Pirate, self).__init__(session, id, name, color, **kwargs)

		# choose a random water tile on the coast and call it home
		self.home_point = self.session.world.get_random_possible_coastal_ship_position()
		# random sea tile if costal tile not found. Empty map?
		if not self.home_point:
			self.home_point = self.session.world.get_random_possible_ship_position()
		self.log.debug("Pirate: home at (%d, %d), radius %d", self.home_point.x, self.home_point.y, self.home_radius)
		self.__init()

		# create a ship and place it randomly (temporary hack)
		for i in xrange(self.ship_count):
			self.create_ship_at_random_position()

		Scheduler().add_new_object(Callback(self.tick), self, 1, -1, self.tick_interval)
		Scheduler().add_new_object(Callback(self.tick_long), self, 1, -1, self.tick_long_interval)

	def __init(self):
		self.world = self.session.world
		self.unit_manager = UnitManager(self)
		self.combat_manager = PirateCombatManager(self)
		self.strategy_manager = PirateStrategyManager(self)
		self.behavior_manager = BehaviorManager(self)

	@staticmethod
	def get_nearest_player_ship(base_ship):
		lowest_distance = None
		nearest_ship = None
		for ship in base_ship.find_nearby_ships():
			if isinstance(ship, (PirateShip, TradeShip)) or not ship.has_component(SelectableComponent):
				continue  # don't attack these ships
			distance = base_ship.position.distance(ship.position)
			if lowest_distance is None or distance < lowest_distance:
				lowest_distance = distance
				nearest_ship = ship
		return nearest_ship

	def tick(self):
		self.combat_manager.tick()

		# Temporary function for pirates respawn
		self.maintain_ship_count()

	def tick_long(self):
		self.strategy_manager.tick()

	def get_random_profile(self, token):
		return BehaviorProfileManager.get_random_pirate_profile(self, token)

	def create_ship_at_random_position(self):
		point = self.session.world.get_random_possible_ship_position()
		ship = CreateUnit(self.worldid, UNITS.PIRATE_SHIP, point.x, point.y)(issuer=self.session.world.player)
		self.ships[ship] = self.shipStates.idle
		self.combat_manager.add_new_unit(ship)

	def maintain_ship_count(self):
		if len(self.ships.keys()) < self.ship_count:
			self.create_ship_at_random_position()

	def save(self, db):
		super(Pirate, self).save(db)
		db("UPDATE player SET is_pirate = 1 WHERE rowid = ?", self.worldid)
		db("INSERT INTO pirate_home_point(x, y) VALUES(?, ?)", self.home_point.x, self.home_point.y)

		current_callback = Callback(self.tick)
		calls = Scheduler().get_classinst_calls(self, current_callback)
		assert len(calls) == 1, "got %s calls for saving %s: %s" % (len(calls), current_callback, calls)
		remaining_ticks = max(calls.values()[0], 1)

		current_callback_long = Callback(self.tick_long)
		calls = Scheduler().get_classinst_calls(self, current_callback_long)
		assert len(calls) == 1, "got %s calls for saving %s: %s" % (len(calls), current_callback_long, calls)
		remaining_ticks_long = max(calls.values()[0], 1)

		db("INSERT INTO ai_pirate(rowid, remaining_ticks, remaining_ticks_long) VALUES(?, ?, ?)", self.worldid,
			remaining_ticks, remaining_ticks_long)

		for ship in self.ships:
			ship_state = self.ships[ship]
			db("INSERT INTO pirate_ships(rowid, state) VALUES(?, ?)",
				ship.worldid, ship_state.index)

		# save unit manager
		self.unit_manager.save(db)

		# save combat manager
		self.combat_manager.save(db)

		# save strategy manager
		self.strategy_manager.save(db)

		# save behavior manager
		self.behavior_manager.save(db)

	def _load(self, db, worldid):
		super(Pirate, self)._load(db, worldid)
		self.__init()

		remaining_ticks, = db("SELECT remaining_ticks FROM ai_pirate WHERE rowid = ?", worldid)[0]
		Scheduler().add_new_object(Callback(self.tick), self, remaining_ticks, -1, self.tick_interval)

		remaining_ticks_long, = db("SELECT remaining_ticks_long FROM ai_pirate WHERE rowid = ?", worldid)[0]
		Scheduler().add_new_object(Callback(self.tick_long), self, remaining_ticks_long, -1, self.tick_interval)

		home = db("SELECT x, y FROM pirate_home_point")[0]
		self.home_point = Point(home[0], home[1])

		self.log.debug("Pirate: home at (%d, %d), radius %d", self.home_point.x, self.home_point.y, self.home_radius)

	def finish_loading(self, db):
		# load ships one by one from db (ship instances themselves are loaded already, but
		# we have to use them here)

		for ship_id, state_id in db("SELECT rowid, state FROM pirate_ships"):
			state = self.shipStates[state_id]
			ship = WorldObject.get_object_by_id(ship_id)
			self.ships[ship] = state

		# load unit manager
		self.unit_manager = UnitManager.load(db, self)

		# load combat manager
		self.combat_manager = PirateCombatManager.load(db, self)

		# load strategy manager
		self.strategy_manager = PirateStrategyManager.load(db, self)

		# load BehaviorManager
		self.behavior_manager = BehaviorManager.load(db, self)

	def remove_unit(self, unit):
		"""Called when a ship which is owned by the pirate is removed or killed."""
		del self.ships[unit]
		self.combat_manager.remove_unit(unit)
		self.unit_manager.remove_unit(unit)

	def end(self):
		self.strategy_manager.end()
		super(Pirate, self).end()

########NEW FILE########
__FILENAME__ = trader
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.ai.generic import GenericAI
from horizons.constants import UNITS, BUILDINGS, TRADER
from horizons.command.unit import CreateUnit
from horizons.component.tradepostcomponent import TradePostComponent
from horizons.ext.enum import Enum
from horizons.messaging import NewSettlement
from horizons.scheduler import Scheduler
from horizons.util.python.callback import Callback
from horizons.util.shapes import Circle
from horizons.util.worldobject import WorldObject
from horizons.world.disaster.blackdeathdisaster import BlackDeathDisaster
from horizons.world.units.movingobject import MoveNotPossible


class Trader(GenericAI):
	"""A trader represents the free trader that travels around the map with its trading ship(s) and
	sells resources to players and buys resources from them. This is a very simple form of AI, as it
	doesn't do any more then drive to a place on water or a warehouse randomly and then buys and
	sells resources. A game should not have more then one free trader (it could though)
	@param id: int - player id, every Player needs a unique id, as the free trader is a Player instance, it also does.
	@param name: Traders name, also needed for the Player class.
	@param color: util.Color instance with the traders banner color, also needed for the Player class"""

	shipStates = Enum.get_extended(GenericAI.shipStates, 'moving_to_warehouse', 'reached_warehouse')

	log = logging.getLogger("ai.trader")
	regular_player = False

	def __init__(self, session, id, name, color, **kwargs):
		super(Trader, self).__init__(session, id, name, color, **kwargs)
		self.__init()
		self.create_ship()

	def create_ship(self):
		"""Create a ship and place it randomly"""
		self.log.debug("Trader %s: creating new ship", self.worldid)
		point = self.session.world.get_random_possible_ship_position()
		ship = CreateUnit(self.worldid, UNITS.TRADER_SHIP, point.x, point.y)(issuer=self)
		self.ships[ship] = self.shipStates.reached_warehouse
		Scheduler().add_new_object(Callback(self.ship_idle, ship), self, run_in=0)

	def __init(self):
		self.office = {} # { ship.worldid : warehouse }. stores the warehouse the ship is currently heading to
		self.allured_by_signal_fire = {} # bool, used to get away from a signal fire (and not be allured again immediately)

		NewSettlement.subscribe(self._on_new_settlement)

	def _on_new_settlement(self, msg):
		# make sure there's a trader ship for 2 settlements
		if len(self.session.world.settlements) > self.get_ship_count() * 2:
			self.create_ship()

	def save(self, db):
		super(Trader, self).save(db)

		# mark self as a trader
		db("UPDATE player SET is_trader = 1 WHERE rowid = ?", self.worldid)

		for ship in self.ships:
			# prepare values
			ship_state = self.ships[ship]

			remaining_ticks = None
			# get current callback in scheduler, according to ship state, to retrieve
			# the number of ticks, when the call will actually be done
			current_callback = None
			if ship_state == self.shipStates.reached_warehouse:
				current_callback = Callback(self.ship_idle, ship)
			if current_callback is not None:
				# current state has a callback
				calls = Scheduler().get_classinst_calls(self, current_callback)
				assert len(calls) == 1, "got %s calls for saving %s: %s" %(len(calls), current_callback, calls)
				remaining_ticks = max(calls.values()[0], 1)

			targeted_warehouse = None if ship.worldid not in self.office else self.office[ship.worldid].worldid

			# put them in the database
			db("INSERT INTO trader_ships(rowid, state, remaining_ticks, targeted_warehouse) \
			   VALUES(?, ?, ?, ?)", ship.worldid, ship_state.index, remaining_ticks, targeted_warehouse)

	def _load(self, db, worldid):
		super(Trader, self)._load(db, worldid)
		self.__init()

	def load_ship_states(self, db):
		# load ships one by one from db (ship instances themselves are loaded already, but
		# we have to use them here)
		for ship_id, state_id, remaining_ticks, targeted_warehouse in \
				db("SELECT rowid, state, remaining_ticks, targeted_warehouse FROM trader_ships"):
			state = self.shipStates[state_id]
			ship = WorldObject.get_object_by_id(ship_id)

			self.ships[ship] = state

			if state == self.shipStates.moving_random:
				ship.add_move_callback(Callback(self.ship_idle, ship))
			elif state == self.shipStates.moving_to_warehouse:
				ship.add_move_callback(Callback(self.reached_warehouse, ship))
				assert targeted_warehouse is not None
				self.office[ship.worldid] = WorldObject.get_object_by_id(targeted_warehouse)
			elif state == self.shipStates.reached_warehouse:
				assert remaining_ticks is not None
				Scheduler().add_new_object(
					Callback(self.ship_idle, ship), self, remaining_ticks)

	def get_ship_count(self):
		"""Returns number of ships"""
		return len(self.ships)

	def send_ship_random(self, ship):
		"""Sends a ship to a random position on the map.
		@param ship: Ship instance that is to be used"""
		super(Trader, self).send_ship_random(ship)
		ship.add_conditional_callback(Callback(self._check_for_signal_fire_in_ship_range, ship),
		                              callback=Callback(self._ship_found_signal_fire, ship))

	def _check_for_signal_fire_in_ship_range(self, ship):
		"""Returns the signal fire instance, if there is one in the ships range, else False"""
		if ship in self.allured_by_signal_fire and self.allured_by_signal_fire[ship]:
			return False # don't visit signal fire again
		for tile in self.session.world.get_tiles_in_radius(ship.position, ship.radius):
			try:
				if tile.object.id == BUILDINGS.SIGNAL_FIRE:
					return tile.object
			except AttributeError:
				pass # tile has no object or object has no id
		return False

	def _ship_found_signal_fire(self, ship):
		signal_fire = self._check_for_signal_fire_in_ship_range(ship)
		self.log.debug("Trader %s ship %s found signal fire %s", self.worldid, ship.worldid, signal_fire)
		# search a warehouse in the range of the signal fire and move to it
		warehouses = self.session.world.get_warehouses()
		for house in warehouses:
			if house.position.distance(signal_fire.position) <= signal_fire.radius and \
			   house.owner == signal_fire.owner:
				self.log.debug("Trader %s moving to house %s", self.worldid, house)
				self.allured_by_signal_fire[ship] = True
				# HACK: remove allured flag in a few ticks
				def rem_allured(self, ship):
					self.allured_by_signal_fire[ship] = False
				Scheduler().add_new_object(Callback(rem_allured, self, ship), self, Scheduler().get_ticks(60))
				self.send_ship_random_warehouse(ship, house)
				return
		self.log.debug("Trader can't find warehouse in range of signal fire")

	def send_ship_random_warehouse(self, ship, warehouse=None):
		"""Sends a ship to a random warehouse on the map
		@param ship: Ship instance that is to be used
		@param warehouse: warehouse instance to move to. Random one is selected on None."""
		self.log.debug("Trader %s ship %s moving to warehouse (random=%s)", self.worldid, ship.worldid,
		               (warehouse is None))
		#TODO maybe this kind of list should be saved somewhere, as this is pretty performance intense
		warehouses = self.session.world.get_warehouses()
		# Remove all warehouses that are not safe to visit
		warehouses = filter(self.is_warehouse_safe, warehouses)
		if not warehouses: # there aren't any warehouses, move randomly
			self.send_ship_random(ship)
		else: # select a warehouse
			if warehouse is None:
				self.office[ship.worldid] = self.session.random.choice(warehouses)
			else:
				self.office[ship.worldid] = warehouse
			try: # try to find a possible position near the warehouse
				ship.move(Circle(self.office[ship.worldid].position.center, ship.radius), Callback(self.reached_warehouse, ship))
				self.ships[ship] = self.shipStates.moving_to_warehouse
			except MoveNotPossible:
				self.send_ship_random(ship)

	def is_warehouse_safe(self, warehouse):
		"""Checkes whether a warehouse is safe to visit"""
		return not isinstance(self.session.world.disaster_manager.get_disaster(warehouse.settlement), BlackDeathDisaster)

	def reached_warehouse(self, ship):
		"""Actions that need to be taken when reaching a warehouse:
		Sell demanded res, buy offered res, simulate load/unload, continue route.
		@param ship: ship instance"""
		self.log.debug("Trader %s ship %s: reached warehouse", self.worldid, ship.worldid)
		settlement = self.office[ship.worldid].settlement
		# NOTE: must be sorted for mp games (same order everywhere)
		trade_comp = settlement.get_component(TradePostComponent)
		for res in sorted(trade_comp.buy_list.iterkeys()): # check for resources that the settlement wants to buy
			# select a random amount to sell
			amount = self.session.random.randint(TRADER.SELL_AMOUNT_MIN, TRADER.SELL_AMOUNT_MAX)
			# try to sell all, else try smaller pieces
			for try_amount in xrange(amount, 0, -1):
				price = int(self.session.db.get_res_value(res) * TRADER.PRICE_MODIFIER_SELL * try_amount)
				trade_successful = trade_comp.buy(res, try_amount, price, self.worldid)
				self.log.debug("Trader %s: offered sell %s tons of res %s, success: %s", self.worldid, try_amount, res, trade_successful)
				if trade_successful:
					break

		# NOTE: must be sorted for mp games (same order everywhere)
		for res in sorted(trade_comp.sell_list.iterkeys()):
			# select a random amount to buy from the settlement
			amount = self.session.random.randint(TRADER.BUY_AMOUNT_MIN, TRADER.BUY_AMOUNT_MAX)
			# try to buy all, else try smaller pieces
			for try_amount in xrange(amount, 0, -1):
				price = int(self.session.db.get_res_value(res) * TRADER.PRICE_MODIFIER_BUY * try_amount)
				trade_successful = trade_comp.sell(res, try_amount, price, self.worldid)
				self.log.debug("Trader %s: offered buy %s tons of res %s, success: %s", self.worldid, try_amount, res, trade_successful)
				if trade_successful:
					break

		del self.office[ship.worldid]
		# wait a few seconds before going on to simulate loading/unloading process
		Scheduler().add_new_object(Callback(self.ship_idle, ship), self,
		                           Scheduler().get_ticks(TRADER.TRADING_DURATION))
		self.ships[ship] = self.shipStates.reached_warehouse

	def ship_idle(self, ship):
		"""Called if a ship is idle. Sends ship to either a random place or warehouse.
		Probability for 'random warehouse' in percent: TRADER.BUSINESS_SENSE.
		@param ship: ship instance"""
		if self.session.random.randint(0, 100) < TRADER.BUSINESS_SENSE:
			# delay one tick, to allow old movement calls to completely finish
			self.log.debug("Trader %s ship %s: idle, moving to random warehouse", self.worldid, ship.worldid)
			Scheduler().add_new_object(Callback(self.send_ship_random_warehouse, ship), self, run_in=0)
		else:
			self.log.debug("Trader %s ship %s: idle, moving to random location", self.worldid, ship.worldid)
			Scheduler().add_new_object(Callback(self.send_ship_random, ship), self, run_in=0)

	def end(self):
		super(Trader, self).end()
		NewSettlement.unsubscribe(self._on_new_settlement)

########NEW FILE########
__FILENAME__ = building
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from collections import defaultdict

import horizons.globals

from horizons.entities import Entities
from horizons.command import Command
from horizons.command.uioptions import TransferResource
from horizons.util.shapes import Point
from horizons.util.worldobject import WorldObject, WorldObjectNotFound
from horizons.scenario import CONDITIONS
from horizons.constants import BUILDINGS, RES
from horizons.component.storagecomponent import StorageComponent

class Build(Command):
	"""Command class that builds an object."""
	def __init__(self, building, x, y, island, rotation=45, ship=None, ownerless=False,
	             settlement=None, tearset=None, data=None, action_set_id=None):
		"""Create the command
		@param building: building class that is to be built or the id of the building class.
		@param x, y: int coordinates where the object is to be built.
		@param ship: ship instance
		@param island: BuildingOwner instance. Might be Island or World.
		@param settlement: settlement worldid or None
		@param tearset: set of worldids of objs to tear before building
		@param data: data required for building construction
		@param action_set_id: use this particular action set, don't choose at random
		"""
		if hasattr(building, 'id'):
			self.building_class = building.id
		else:
			assert isinstance(building, int)
			self.building_class = building
		self.ship = None if ship is None else ship.worldid
		self.x = int(x)
		self.y = int(y)
		self.rotation = int(rotation)
		self.ownerless = ownerless
		self.island = island.worldid
		self.settlement = settlement.worldid if settlement is not None else None
		self.tearset = tearset or set()
		self.data = data or {}
		self.action_set_id = action_set_id

	def __call__(self, issuer=None):
		"""Execute the command
		@param issuer: the issuer (player, owner of building) of the command
		"""
		self.log.debug("Build: building type %s at (%s,%s)", self.building_class, self.x, self.y)

		island = WorldObject.get_object_by_id(self.island)
		# slightly ugly workaround to retrieve world and session instance via pseudo-singleton
		session = island.session

		# check once agaion. needed for MP because of the execution delay.
		buildable_class = Entities.buildings[self.building_class]
		build_position = buildable_class.check_build(session, Point(self.x, self.y),
		                                             rotation=self.rotation,
		                                             check_settlement=issuer is not None,
		                                             ship=WorldObject.get_object_by_id(self.ship) if self.ship is not None else None,
		                                             issuer=issuer)

		# it's possible that the build check requires different actions now,
		# so update our data
		self.x, self.y = build_position.position.origin.to_tuple()
		self.rotation = build_position.rotation
		self.tearset = build_position.tearset

		if build_position.buildable and issuer:
			# building seems to buildable, check res too now
			res_sources = [None if self.ship is None else WorldObject.get_object_by_id(self.ship),
			               None if self.settlement is None else WorldObject.get_object_by_id(self.settlement)]

			build_position.buildable, missing_res = self.check_resources(
			    {}, buildable_class.costs, issuer, res_sources)
		if not build_position.buildable:
			self.log.debug("Build aborted. Seems like circumstances changed during EXECUTIONDELAY.")
			# TODO: maybe show message to user
			return

		# collect data before objs are torn
		# required by e.g. the mines to find out about the status of the resource deposit
		if hasattr(Entities.buildings[self.building_class], "get_prebuild_data"):
			bclass = Entities.buildings[self.building_class]
			self.data.update(bclass.get_prebuild_data(session, Point(self.x, self.y)))

		for worldid in sorted(self.tearset): # make sure iteration is the same order everywhere
			try:
				obj = WorldObject.get_object_by_id(worldid)
				Tear(obj)(issuer=None) # execute right now, not via manager
			except WorldObjectNotFound: # obj might have been removed already
				pass

		building = Entities.buildings[self.building_class](
		    session=session, x=self.x, y=self.y, rotation=self.rotation,
		    island=island, action_set_id=self.action_set_id, instance=None,
		    owner=issuer if not self.ownerless else None,
		    **self.data
		)
		building.initialize(**self.data)
		# initialize must be called immediately after the construction
		# the building is not usable before this call

		island.add_building(building, issuer)

		if self.settlement is not None:
			secondary_resource_source = WorldObject.get_object_by_id(self.settlement)
		elif self.ship is not None:
			secondary_resource_source = WorldObject.get_object_by_id(self.ship)
		elif island is not None:
			secondary_resource_source = island.get_settlement(Point(self.x, self.y))

		if issuer: # issuer is None if it's a global game command, e.g. on world setup
			for (resource, value) in building.costs.iteritems():
				# remove from issuer, and remove rest from secondary source (settlement or ship)
				inventory = issuer.get_component(StorageComponent).inventory
				first_source_remnant = inventory.alter(resource, -value)
				if first_source_remnant != 0 and secondary_resource_source is not None:
					inventory = secondary_resource_source.get_component(StorageComponent).inventory
					second_source_remnant = inventory.alter(resource, first_source_remnant)
					assert second_source_remnant == 0
				else: # first source must have covered everything
					assert first_source_remnant == 0

		# building is now officially built and existent
		building.start()

		# unload the remaining resources on the human player ship if we just founded a new settlement
		from horizons.world.player import HumanPlayer
		if (building.id == BUILDINGS.WAREHOUSE
		    and isinstance(building.owner, HumanPlayer)
		    and horizons.globals.fife.get_uh_setting("AutoUnload")):
			ship = WorldObject.get_object_by_id(self.ship)
			ship_inv = ship.get_component(StorageComponent).inventory
			settlement_inv = building.settlement.get_component(StorageComponent).inventory
			# copy the inventory first because otherwise we would modify it while iterating
			for res, amount in ship_inv.get_dump().iteritems():
				amount = min(amount, settlement_inv.get_free_space_for(res))
				# execute directly, we are already in a command
				TransferResource(amount, res, ship, building.settlement)(issuer=issuer)

		# NOTE: conditions are not MP-safe! no problem as long as there are no MP-scenarios
		session.scenario_eventhandler.schedule_check(CONDITIONS.building_num_of_type_greater)

		return building

	@staticmethod
	def check_resources(needed_res, costs, issuer, res_sources):
		"""Check if there are enough resources available to cover the costs
		@param needed_res: awkward dict from BuildingTool.preview_build, use {} everywhere else
		@param costs: building costs (as in buildingclass.costs)
		@param issuer: player that builds the building
		@param res_sources: list of objects with inventory attribute. None values are discarded.
		@return tuple(bool, missing_resource), True means buildable"""
		for resource in costs:
			needed_res[resource] = needed_res.get(resource, 0) + costs[resource]

		reserved_res = defaultdict(int) # res needed for sth else but still present
		if hasattr(issuer.session.manager, "get_builds_in_construction"):
			# mp game, consider res still to be subtracted
			builds = issuer.session.manager.get_builds_in_construction()
			for build in builds:
				reserved_res.update(Entities.buildings[build.building_class].costs)

		for resource in needed_res:
			# check player, ship and settlement inventory
			available_res = 0
			# player
			if resource == RES.GOLD:
				player_inventory = issuer.get_component(StorageComponent).inventory
				available_res += player_inventory[resource]
			# ship or settlement
			for res_source in res_sources:
				if res_source is not None:
					inventory = res_source.get_component(StorageComponent).inventory
					available_res += inventory[resource]

			if (available_res - reserved_res[resource]) < needed_res[resource]:
				return (False, resource)
		return (True, None)

Command.allow_network(Build)
Command.allow_network(set)

class Tear(Command):
	"""Command class that tears an object."""
	def __init__(self, building):
		"""Create the command
		@param building: building that is to be teared.
		"""
		self.building = building.worldid

	@classmethod
	def additional_removals_after_tear(cls, building_to_remove):
		"""
		Calculate which buildings need to be removed when removing the building from its settlement
		@return tupel(buildings_to_remove, obsolete_settlement_coords)
		"""
		settlement = building_to_remove.settlement
		position = building_to_remove.position
		# Find all range affecting buildings.
		other_range_buildings = []
		for building in settlement.buildings:
			if building.id in BUILDINGS.EXPAND_RANGE:
				other_range_buildings.append(building)
		other_range_buildings.remove(building_to_remove)

		# Calculate which coordinates are in the new settlement and which are not
		new_settlement_coords = set()
		for building in other_range_buildings:
			range_coords = list(building.position.get_radius_coordinates(building.radius, include_self=True))
			new_settlement_coords.update(range_coords)
		obsolete_settlement_coords = set(settlement.ground_map.keys()).difference(new_settlement_coords)

		# Find the buildings that need to be destroyed 
		buildings_to_destroy = []
		for building in settlement.buildings:
			if building.id in (BUILDINGS.FISH_DEPOSIT, BUILDINGS.CLAY_DEPOSIT, BUILDINGS.TREE, BUILDINGS.MOUNTAIN):
				continue
			if building.position == position:
				continue
			for coord in building.position:
				if coord in obsolete_settlement_coords:
					buildings_to_destroy.append(building)
					break

		return (buildings_to_destroy, obsolete_settlement_coords)

	def __call__(self, issuer):
		"""Execute the command
		@param issuer: the issuer of the command
		"""
		try:
			building = WorldObject.get_object_by_id(self.building)
		except WorldObjectNotFound:
			self.log.debug("Tear: building %s already gone, not tearing it again.", self.building)
			return # invalid command, possibly caused by mp delay
		if building is None or building.fife_instance is None:
			self.log.error("Tear: attempting to tear down a building that shouldn't exist %s", building)
		else:
			self.log.debug("Tear: tearing down %s", building)
			building.remove()

Command.allow_network(Tear)
########NEW FILE########
__FILENAME__ = diplomacy
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.worldobject import WorldObject
from horizons.command import Command

class GenericDiplomacyCommand(Command):
	def __init__(self, a, b):
		self.player1_id = a.worldid
		self.player2_id = b.worldid

class AddAllyPair(GenericDiplomacyCommand):
	def __call__(self, issuer):
		player1 = WorldObject.get_object_by_id(self.player1_id)
		player2 = WorldObject.get_object_by_id(self.player2_id)
		player1.session.world.diplomacy.add_ally_pair(player1, player2)

Command.allow_network(AddAllyPair)

class AddEnemyPair(GenericDiplomacyCommand):
	def __call__(self, issuer):
		player1 = WorldObject.get_object_by_id(self.player1_id)
		player2 = WorldObject.get_object_by_id(self.player2_id)
		player1.session.world.diplomacy.add_enemy_pair(player1, player2)

Command.allow_network(AddEnemyPair)

class AddNeutralPair(GenericDiplomacyCommand):
	def __call__(self, issuer):
		player1 = WorldObject.get_object_by_id(self.player1_id)
		player2 = WorldObject.get_object_by_id(self.player2_id)
		player1.session.world.diplomacy.add_neutral_pair(player1, player2)

Command.allow_network(AddNeutralPair)


########NEW FILE########
__FILENAME__ = game
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.command import Command
from horizons.savegamemanager import SavegameManager

class SaveCommand(Command):
	"""Used to init a save, which will happen at all network machines.
	Only reasonable in multiplayer games."""
	def __init__(self, name):
		self.name = name

	def __call__(self, issuer):
		session = issuer.session
		try:
			path = SavegameManager.create_multiplayersave_filename(self.name)
		except RuntimeError as e:
			headline = _("Invalid filename")
			msg = _("Received an invalid filename for a save command.")
			session.ingame_gui.open_error_popup(headline, msg, unicode(e))
			return

		self.log.debug("SaveCommand: save to %s", path)

		success = session._do_save(path)
		if success:
			# TODO: distinguish auto/quick/normal
			session.ingame_gui.message_widget.add('SAVED_GAME')
		else:
			session.ingame_gui.open_popup(_('Error'), _('Failed to save.'))

Command.allow_network(SaveCommand)



class SpeedUpCommand(Command):
	"""Used to change the game speed"""

	def __call__(self, issuer):
		session = issuer.session
		session.speed_up()

Command.allow_network(SpeedUpCommand)

class SpeedDownCommand(Command):
	"""Used to change the game speed"""

	def __call__(self, issuer):
		session = issuer.session
		session.speed_down()

Command.allow_network(SpeedDownCommand)

class TogglePauseCommand(Command):
	"""Used to change the game speed"""

	def __call__(self, issuer):
		session = issuer.session
		session.ingame_gui.toggle_pause()

Command.allow_network(TogglePauseCommand)

class _SpeedCommand(Command):

	def __init__(self, suggestion=False):
		self.suggestion = suggestion

class UnPauseCommand(_SpeedCommand):
	"""Used to change the game speed"""

	def __call__(self, issuer):
		session = issuer.session
		session.speed_unpause(self.suggestion)

Command.allow_network(UnPauseCommand)

class PauseCommand(_SpeedCommand):
	"""Used to change the game speed"""

	def __call__(self, issuer):
		session = issuer.session
		session.speed_pause(self.suggestion)

Command.allow_network(PauseCommand)

########NEW FILE########
__FILENAME__ = misc
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.command import Command

class Chat(Command):
	def __init__(self, message):
		self.message = unicode(message)

	def __call__(self, issuer):
		issuer.session.ingame_gui.message_widget.add_chat(player=issuer.name, messagetext=self.message)

Command.allow_network(Chat)

########NEW FILE########
__FILENAME__ = production
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.command import GenericCommand, GenericComponentCommand

class ToggleActive(GenericComponentCommand):
	"""Sets a production to active/inactive."""
	def __init__(self, producer, production=None):
		super(ToggleActive, self).__init__(producer, "toggle_active")
		self._production = None if production is None else production.prod_id

	def __call__(self, issuer):
		# NOTE: special call method, cause production must be saved as id, not as Production obj
		obj = self._get_object().get_component_by_name(self.component_name)

		if self._production is not None:
			production = obj._get_production(self._production)
			assert production is not None, "%s does not have a production %s" % (obj, self._production)
		else:
			production = None

		return getattr(obj, self.method)( production )

GenericComponentCommand.allow_network(ToggleActive)


class AddProduction(GenericComponentCommand):
	"""Add a production to a producer"""
	def __init__(self, producer, production_line_id):
		super(AddProduction, self).__init__(producer, "add_production_by_id", production_line_id)

GenericComponentCommand.allow_network(AddProduction)


class RemoveFromQueue(GenericComponentCommand):
	"""Remove a production line id from a queueproducer's queue"""
	def __init__(self, producer, production_line_id):
		super(RemoveFromQueue, self).__init__(producer, "remove_from_queue", production_line_id)

GenericComponentCommand.allow_network(RemoveFromQueue)


class CancelCurrentProduction(GenericComponentCommand):
	"""Cancel the current production of a queueproducer.
	Makes it proceed to the next one."""
	def __init__(self, producer):
		super(CancelCurrentProduction, self).__init__(producer, "cancel_current_production")

GenericCommand.allow_network(CancelCurrentProduction)

########NEW FILE########
__FILENAME__ = sounds
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.util.shapes import Point
from horizons.command import Command

class PlaySound(Command):
	"""Command class that plays the build sound. This has been moved to a separate
	class, in order to be able to play only one sound for 20 buildings(like a group of
	trees)
	@param sound: sound id that is to be played
	@param position: tuple of int coordinates where the sound is to be played."""

	def __init__(self, sound, position=None, **trash):
		self.sound = sound
		self.position = position

	def __call__(self, issuer):
		"""Execute the command
		@param issuer: the issuer of the command
		"""
		if self.position is None:
			AmbientSoundComponent.play_special(self.sound)
		else:
			AmbientSoundComponent.play_special(self.sound, Point(self.position[0], self.position[1]))

Command.allow_network(PlaySound)

########NEW FILE########
__FILENAME__ = uioptions
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.command import GenericCommand, GenericComponentCommand

class SetTaxSetting(GenericCommand):
	"""Sets the taxes for a settlement."""
	def __init__(self, settlement, level, new_taxes):
		super(SetTaxSetting, self).__init__(settlement, 'set_tax_setting', level, new_taxes)

GenericCommand.allow_network(SetTaxSetting)

class SetSettlementUpgradePermissions(GenericCommand):
	"""Sets the new upgrade permissions for a level in a settlement."""
	def __init__(self, settlement, level, allowed):
		super(SetSettlementUpgradePermissions, self).__init__(settlement, 'set_upgrade_permissions', level, allowed)

GenericCommand.allow_network(SetSettlementUpgradePermissions)

class SetTradeSlot(GenericComponentCommand):
	"""Set status of a trade post's buy/sell slot."""
	def __init__(self, trade_post, slot_id, resource_id, selling, limit):
		super(SetTradeSlot, self).__init__(trade_post, 'set_slot', slot_id, resource_id, selling, limit)

GenericComponentCommand.allow_network(SetTradeSlot)

class ClearTradeSlot(GenericComponentCommand):
	"""Clear a trade post's buy/sell slot."""
	def __init__(self, trade_post, slot_id):
		super(ClearTradeSlot, self).__init__(trade_post, 'clear_slot', slot_id, True)

GenericComponentCommand.allow_network(ClearTradeSlot)

class TransferResource(GenericCommand):
	"""Transfers an amount of a resource from one Storage to another"""
	def __init__(self, amount, res_id, transfer_from, transfer_to, signal_errors=False):
		super(TransferResource, self).__init__(transfer_from, 'transfer_to_storageholder', amount, res_id, transfer_to.worldid, signal_errors=signal_errors)

GenericCommand.allow_network(TransferResource)

class SellResource(GenericComponentCommand):
	"""The given trade post attempts to sell the given amount of resource to the ship"""
	def __init__(self, trade_post, ship, resource_id, amount):
		super(SellResource, self).__init__(trade_post, 'sell_resource', ship.worldid, resource_id, amount)

GenericComponentCommand.allow_network(SellResource)

class BuyResource(GenericComponentCommand):
	"""The given trade post attempts to buy the given amount of resource from the ship"""
	def __init__(self, trade_post, ship, resource_id, amount):
		super(BuyResource, self).__init__(trade_post, 'buy_resource', ship.worldid, resource_id, amount)

GenericComponentCommand.allow_network(BuyResource)

class RenameObject(GenericComponentCommand):
	"""Rename a NamedComponent"""
	def __init__(self, namedcomponent, new_name):
		super(RenameObject, self).__init__(namedcomponent, "set_name", new_name)

GenericComponentCommand.allow_network(RenameObject)

class EquipWeaponFromInventory(GenericCommand):
	"""Equips a weapon to weapon storage from resource inventory"""
	def __init__(self, obj, weapon_id, number):
		super(EquipWeaponFromInventory, self).__init__(obj, "equip_from_inventory", weapon_id, number)

GenericCommand.allow_network(EquipWeaponFromInventory)

class UnequipWeaponToInventory(GenericCommand):
	"""Equips a weapon to weapon storage from resource inventory"""
	def __init__(self, obj, weapon_id, number):
		super(UnequipWeaponToInventory, self).__init__(obj, "unequip_to_inventory", weapon_id, number)

GenericCommand.allow_network(UnequipWeaponToInventory)

class RouteConfigCommand(GenericCommand):
	"""Use this for routeconfig actions.
	There are too many small methods to use single commands.
	"""
	def __init__(self, obj, method, *args, **kwargs):
		super(RouteConfigCommand, self).__init__(obj, method, *args, **kwargs)

	def _get_object(self):
		obj = super(RouteConfigCommand, self)._get_object()
		return obj.route


GenericCommand.allow_network(RouteConfigCommand)

########NEW FILE########
__FILENAME__ = unit
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.entities import Entities
from horizons.util.worldobject import WorldObject
from horizons.command import GenericCommand, Command
from horizons.util.worldobject import WorldObjectNotFound

class GenericUnitCommand(GenericCommand):
	"""Same as GenericCommand, but checks if issuer == owner in __call__"""
	def __call__(self, issuer):
		try:
			unit = self._get_object()
		except WorldObjectNotFound as e:
			self.log.warning("Tried to call a unit command on an inexistent unit. It could have been killed: %s", e)
			return
		if unit.owner.worldid != issuer.worldid:
			return # don't move enemy units
		else:
			return super(GenericUnitCommand, self).__call__(issuer)

class Act(GenericUnitCommand):
	"""Command class that moves a unit.
	@param unit: Instance of Unit
	@param x, y: float coordinates where the unit is to be moved.
	"""
	def __init__(self, unit, x, y):
		super(Act, self).__init__(unit, "go", x, y)

GenericCommand.allow_network(Act)

class Attack(GenericUnitCommand):
	"""Command class that triggers attack
	@param unit: Instance of Unit
	@param target: Instance of Target
	"""
	def __init__(self, unit, target):
		super(Attack, self).__init__(unit, "user_attack", target.worldid)

GenericCommand.allow_network(Attack)

class RemoveUnit(GenericUnitCommand):
	"""
	Command class that removes the unit. Not to be used if .remove() is going to be called through an indirect command anyway.
	@param unit: Instance of Unit
	"""
	def __init__(self, unit):
		super(RemoveUnit, self).__init__(unit, "remove")

GenericCommand.allow_network(RemoveUnit)

class CreateUnit(Command):
	"""Command class that creates a unit.
	TODO: remove this command and put the code in a method in e.g. world.
	Commands are there for user interactions, and there is no user interaction, that creates a unit
	You always only add a production that creates then units, but that is simulated on every machine

	"""
	def __init__(self, owner_id, unit_id, x, y, **kwargs):
		"""
		@param session: Session instance
		@param id: Unit id that is to be created.
		@param x, y: Unit's initial position
		@param kwargs: Additional parameters for unit creation
		"""
		self.owner_id = owner_id
		self.unit_id = unit_id
		self.x = x
		self.y = y
		self.kwargs = kwargs

	def __call__(self, issuer):
		"""__call__() gets called by the manager.
		@param issuer: the issuer of the command
		"""
		owner = WorldObject.get_object_by_id(self.owner_id)
		unit = Entities.units[self.unit_id](session=owner.session, owner=owner,
		                                    x=self.x, y=self.y, **self.kwargs)
		unit.initialize()
		return unit

GenericCommand.allow_network(CreateUnit)


class SetStance(GenericUnitCommand):
	"""Command class that moves a unit.
	@param unit: Instance of Unit
	@param stance: stance as string representation
	"""
	def __init__(self, unit, stance):
		super(SetStance, self).__init__(unit, "set_stance", stance.NAME)

	def __call__(self, issuer):
		# we need the stance component, so resolve the name
		self.args = (self._get_object().get_component_by_name(self.args[0]), )
		return super(SetStance, self).__call__(issuer)

GenericCommand.allow_network(SetStance)

########NEW FILE########
__FILENAME__ = ambientsoundcomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import random

import horizons.globals

from horizons.component import Component
from horizons.extscheduler import ExtScheduler


class AmbientSoundComponent(Component):
	"""Support for playing ambient sounds, such as animal noise or collector sounds.
	"""
	AMBIENT_SOUND_INTERVAL = 20 # interval between two plays
	AMBIENT_SOUND_INTERVAL_VARIANCE = [0, 15] # a number of this interval is added to the one above

	NAME = "ambientsound"

	def __init__(self, soundfiles=None):
		"""
		@param soundfiles: list of paths
		"""
		super(AmbientSoundComponent, self).__init__()
		self.soundfiles = soundfiles or []
		self.__init()

	def __init(self):
		self.__emitter = None # only create it when really needed

	def __create_emitter(self):
		if horizons.globals.fife.get_fife_setting("PlaySounds"):
			self.__emitter = horizons.globals.fife.sound.soundmanager.createEmitter()
			self.__emitter.setGain(horizons.globals.fife.get_uh_setting("VolumeEffects")*10)
			horizons.globals.fife.sound.emitter['ambient'].append(self.__emitter)

	def _init_playing(self):
		if hasattr(self.instance.owner, "is_local_player") and self.instance.owner.is_local_player:
			# don't use session random, this is player dependent
			play_every = self.__class__.AMBIENT_SOUND_INTERVAL + \
												random.randint( * self.__class__.AMBIENT_SOUND_INTERVAL_VARIANCE )
			for soundfile in self.soundfiles:
				#TODO remove str() -- http://github.com/fifengine/fifengine/issues/701
				self.play_ambient(str(soundfile), loop_interval=play_every,
				                  position=self.instance.position.center)

	def load(self, db, worldid):
		super(AmbientSoundComponent, self).load(db, worldid)
		self.__init()
		# don't start playing all at once

		interval = (0, self.__class__.AMBIENT_SOUND_INTERVAL +
		            self.__class__.AMBIENT_SOUND_INTERVAL_VARIANCE[1])
		run_in = random.randint( *interval )
		ExtScheduler().add_new_object(self._init_playing, self, run_in=run_in)

	def remove(self):
		super(AmbientSoundComponent, self).remove()
		self.stop_sound()
		self.__emitter = None

	def play_ambient(self, soundfile, loop_interval=None, position=None):
		"""Starts playing an ambient sound. On looping, it will also play right now.
		Default: play sound once
		@param soundfile: path to audio file
		@param loop_interval: delay between two plays, None means no looping, 0 is no pause between looping
		@param position: Point
		"""
		if horizons.globals.fife.get_fife_setting("PlaySounds"):
			if self.__emitter is None:
				self.__create_emitter()

			if position is not None:
				self.__emitter.setRolloff(1.9)
				# set to current position
				self.__emitter.setPosition(position.x, position.y, 1)
			else:
				self.__emitter.setRolloff(0) # reset to default

			#TODO remove str() -- http://github.com/fifengine/fifengine/issues/701
			self.__emitter.setSoundClip(horizons.globals.fife.sound.soundclipmanager.load(str(soundfile)))

			if loop_interval == 0:
				self.__emitter.setLooping(True)
			elif loop_interval is not None:
				duration = loop_interval + (float(self.__emitter.getDuration()) / 1000) # from millisec
				ExtScheduler().add_new_object(self.__emitter.play, self, duration, -1)

			self.__emitter.play()

	def stop_sound(self):
		"""Stops playing an ambient sound"""
		if self.__emitter:
			self.__emitter.stop()
		ExtScheduler().rem_all_classinst_calls(self)

	@classmethod
	def play_special(cls, sound, position=None):
		"""Plays a special sound listed in the db table sounds_special
		from anywhere in the code and without an instance of AmbientSound.
		@param sound: string, key in table sounds_special
		@param position: optional, source of sound on map
		"""
		if horizons.globals.fife.get_fife_setting("PlaySounds"):
			a = AmbientSoundComponent()
			#TODO remove str() -- http://github.com/fifengine/fifengine/issues/701
			soundfile = horizons.globals.db.get_sound_file(str(sound))
			a.play_ambient(soundfile, position=position)
			horizons.globals.fife.sound.emitter['ambient'].remove(a.__emitter)

########NEW FILE########
__FILENAME__ = collectingcomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from horizons.util.pathfinding.pathnodes import ConsumerBuildingPathNodes
from horizons import entities
from horizons.component import Component

class CollectingComponent(Component):
	"""The CollectingBuilding class represents a object that uses collectors
	to collect resources from other ResourceHolder objects. It is used to
	organize Collector instances.
	NOTE: Anything inheriting from this class must also inherit from the
	Building class.

	Base class for most producing/collecting buildings.
	"""

	NAME = 'CollectingComponent'

	## INIT/DESTRUCT
	def __init__(self, collectors):
		super(CollectingComponent, self).__init__()
		self.__collector_templates = collectors

	def initialize(self):
		self.__init()
		self.create_collector(self.__collector_templates)

	def __init(self):
		"""Part of initiation that __init__() and load() share"""
		# list that holds the collectors that belong to this building.
		self.__collectors = []

		self.path_nodes = ConsumerBuildingPathNodes(self.instance)

	def create_collector(self, collectors):
		"""Creates collectors for building according to db."""
		for collector_class, count in collectors.iteritems():
			for i in xrange(0, count):
				self.add_collector(collector_class)

	def add_collector(self, collector_class):
		"""Creates a collector and adds it to this building.
		@param collector_class: unit class of collector to create
		"""
		collector = entities.Entities.units[collector_class](self.instance, session=self.session, owner=self.instance.owner)
		collector.initialize()


	def remove(self):
		# remove every non-ship collectors (those are independent)
		for collector in self.__collectors[:]:
			if not collector.is_ship:
				collector.remove()
			else:
				collector.decouple_from_home_building()
				#TODO remove the remove call() #2123
				collector.remove()
		assert not [c for c in self.__collectors]
		super(CollectingComponent, self).remove()
		self.__collectors = None
		self.path_nodes = None

	def save(self, db):
		super(CollectingComponent, self).save(db)
		for collector in self.__collectors:
			# collectors, that are ship (e.g. fisher ship) are viewed as independent
			# units, and therefore managed by world. This is justified, since they survive
			# the removal of their assigned fisher hut, and therefore require their own
			# saving mechanism
			if not collector.is_ship:
				collector.save(db)


	def load(self, db, worldid):
		super(CollectingComponent, self).load(db, worldid)
		self.__init()


	## INTERFACE
	def add_local_collector(self, collector):
		assert collector not in self.__collectors
		self.__collectors.append(collector)

	def remove_local_collector(self, collector):
		self.__collectors.remove(collector)

	def get_local_collectors(self):
		return self.__collectors

########NEW FILE########
__FILENAME__ = coloroverlaycomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
from collections import defaultdict
from operator import attrgetter

from fife import fife

import horizons.globals

from horizons.component import Component
from horizons.messaging import ActionChanged
from horizons.scheduler import Scheduler
from horizons.util.color import Color as UtilColor
from horizons.util.loaders.actionsetloader import ActionSetLoader


class ColorOverlayComponent(Component):
	"""Change parts of graphics dynamically on runtime ("color overlays" in FIFE terminology).

	Supports multiple overlay sets for the same instance, and also
	supports changing more than one color in the same overlay set.

	While technically possible, it is not recommended to use the former:
	You will need to make sure animation overlays exist for that z_order,
	else a color overlay cannot be visible.

	Because there usually is no way to guarantee this, it is **very much**
	recommended to use one overlay on z_order `0` featuring multiple areas
	with different colors instead, and to then replace those colors one by one.
	We can guarantee that z_order of 0 works because `convertToOverlays` is
	called when adding new color overlays, which converts the base image of
	the current action to an animation overlay at precisely depth 0.

	Directives to change colors look like this (for every action):
	- [z_order, overlay action name, color to be replaced, target color to draw]

	When in doubt, use 0 as z_order.
	The overlay action name is the folder located next to other actions (e.g. idle).
	Color to be replaced: List with three (rgb) or four (rgba) int elements.
		In particular, [80, 0, 0] and [80, 0, 0, 128] are different colors!
	Target color to draw: As above, or string interpreted as attribute of instance.
		To access player colors, you can usually employ "owner.color".

	All in all, a multi-color replacement could look like this example:

		idle:
		# color_idle: action set with three differently colored areas
			# color red area in player color (alpha is set to 128 here)
			- [0, color_idle, [255, 0, 0], [owner.color, 128]]
			# also color green area *in the same images* in blue
			- [0, color_idle, [0, 255, 0], [0, 0, 255, 128]]
			# hide third (blue) area by setting alpha value to 0
			- [0, color_idle, [0, 0, 255], [0, 0, 0, 0]]

	# multiple single-overlay example (usually not what you want):
	#	idle:
	#		# color magenta area in player color (needs animation overlay at order 1)
	#		- [1, color1_idle, [255, 0, 255], [owner.color, 64]]
	#		# also color some other teal area in blue (needs animation overlay at order 2)
	#		- [2, color2_idle, [0, 255, 255], [0, 0, 255, 128]]
	"""
	NAME = "coloroverlay"
	log = logging.getLogger('component.overlays')

	def __init__(self, overlays=None):
		super(ColorOverlayComponent, self).__init__()
		self.overlays = overlays or {}
		self.current_overlays = defaultdict(dict)

	@property
	def action_set(self):
		"""E.g. 'as_lumberjack_barrack0' """
		return self.instance._action_set_id

	@property
	def fife_instance(self):
		return self.instance._instance

	@property
	def identifier(self):
		"""E.g. 'idle_as_lumberjack_barrack0' """
		return self.fife_instance.getCurrentAction().getId()

	def initialize(self):
		super(ColorOverlayComponent, self).initialize()
		ActionChanged.subscribe(self.update_overlay, self.instance)
		ActionChanged.broadcast(self.instance, self.instance._action)

	def update_overlay(self, message):
		#TODO Tracking is broken: remove all data stored for old action
		# Ultimately it would be great to have current_overlays working...
		self.current_overlays.clear()
		try:
			overlays = self.overlays[self.action_set][message.action]
		except KeyError:
			self.log.warning(
				'No color overlay defined for action set `%s` and action `%s`. '
				'Consider using `null` overlays for this action.',
				self.action_set, message.action)
			return

		for (z_order, overlay_name, from_color, to_color) in overlays:
			if not self.current_overlays[z_order]:
				self.add_overlay(overlay_name, z_order)
			fife_from = fife.Color(*from_color)
			try:
				fife_to = fife.Color(*to_color)
			except (TypeError, NotImplementedError):
				color_attribute, alpha = to_color
				color = attrgetter(color_attribute)(self.instance)
				if isinstance(color, UtilColor) or isinstance(color, fife.Color):
					fife_to = fife.Color(color.r, color.g, color.b, alpha)
				else:
					raise TypeError('Unknown color `%s` as attribute `%s`: '
						'Expected either fife.Color or horizons.util.Color.'
						% (color, to_color))
			self.change_color(z_order, fife_from, fife_to)

	def add_overlay(self, overlay_name, z_order):
		"""Creates color overlay recoloring the area defined in *overlay_set*

		and adds it to fife instance. Note that a color overlay on *z_order*
		can only be visible if an animation overlay with that specific order
		exists as well. For order 0, `convertToOverlays()` makes sure they do.
		"""
		if not self.fife_instance.isAnimationOverlay(self.identifier):
			# parameter False: do not convert color overlays attached to base
			self.fife_instance.convertToOverlays(self.identifier, False)

		all_action_sets = ActionSetLoader.get_sets()
		try:
			overlay_set = all_action_sets[self.action_set][overlay_name]
		except KeyError:
			self.log.warning(
				'Could not find overlay action set `%s` defined for object '
				'`%s` with id `%s`. Not adding overlay for this action.',
				overlay_name, self.instance, self.identifier)
			return

		self.current_overlays[z_order] = overlay_set
		for rotation, frames in overlay_set.iteritems():
			ov_anim = fife.Animation.createAnimation()
			for frame_img, frame_data in frames.iteritems():
				try:
					frame_length = frame_data[0]
				except TypeError:
					# not using atlases
					frame_length = frame_data
				pic = horizons.globals.fife.imagemanager.load(frame_img)
				frame_milliseconds = int(frame_length * 1000)
				ov_anim.addFrame(pic, frame_milliseconds)
			overlay = fife.OverlayColors(ov_anim)
			self.fife_instance.addColorOverlay(self.identifier, rotation, z_order, overlay)

	def change_color(self, z_order, from_color, to_color):
		"""Changes color of *from_color*ed area to *to_color*.

		color parameters: fife.Color objects
		"""
		for rotation in self.current_overlays[z_order]:
			overlay = self.fife_instance.getColorOverlay(self.identifier, rotation, z_order)
			overlay.changeColor(from_color, to_color)

	def remove_overlay(self):
		"""Removes color overlay recoloring the *color*-colored area from fife instance.
		"""
		for z_order, overlay_set in self.current_overlays.iteritems():
			for rotation in overlay_set:
				self.fife_instance.removeColorOverlay(self.identifier, rotation, z_order)

	def load(self, db, worldid):
		super(ColorOverlayComponent, self).load(db, worldid)
		Scheduler().add_new_object(self.initialize, self, run_in=0)

	def remove(self):
		"""Removes all color overlays from the fife instance. """
		self.remove_overlay()
		super(ColorOverlayComponent, self).remove()


# If "old" FIFE version is detected (i.e. one without overlay support), silently disable.
if not hasattr(fife, 'OverlayColors'):
	class ColorOverlayComponent(Component):

		def __init__(self, overlays=None):
			super(ColorOverlayComponent, self).__init__()

########NEW FILE########
__FILENAME__ = commandablecomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.component import Component
from horizons.util.shapes import Circle, Point

class CommandableComponent(Component):
	"""
	Class that handles the Commandable component of units
	"""
	log = logging.getLogger("component.commandable")

	# Store the name of this component
	NAME = 'commandable'

	def __init__(self):
		super(CommandableComponent, self).__init__()

	def go(self, x, y):
		from horizons.world.units.movingobject import MoveNotPossible
		"""Moves the unit.
		This is called when a unit is selected and the right mouse button is pressed outside the unit"""
		x = int(round(x))
		y = int(round(y))
		move_target = Point(x, y)

		try:
			self.instance.move(move_target)
		except MoveNotPossible:
			# find a near tile to move to
			surrounding = Circle(move_target, radius=1)
			move_target = None
			# try with smaller circles, increase radius if smaller circle isn't reachable
			while surrounding.radius < 5:
				try:
					self.instance.move(surrounding)
				except MoveNotPossible:
					surrounding.radius += 1
					continue
				# update actual target coord
				move_target = self.instance.get_move_target()
				break
		if self.instance.owner.is_local_player:
			self.instance.session.ingame_gui.minimap.show_unit_path(self.instance)
		if move_target is None: # can't move
			if not self.instance.owner.is_local_player:
				return
			if self.session.world.get_tile(Point(x, y)) is None: # not even in world
				string_id = "MOVE_OUTSIDE_OF_WORLD"
			else: # in world, but still unreachable
				string_id = "MOVE_INVALID_LOCATION"
			self.session.ingame_gui.message_widget.add(point=Point(x, y), string_id=string_id)

########NEW FILE########
__FILENAME__ = componentholder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.component import Component

from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.component.collectingcomponent import CollectingComponent
from horizons.component.coloroverlaycomponent import ColorOverlayComponent
from horizons.component.commandablecomponent import CommandableComponent
from horizons.component.depositcomponent import DepositComponent
from horizons.component.healthcomponent import HealthComponent
from horizons.component.inventoryoverlaycomponent import InventoryOverlayComponent
from horizons.component.namedcomponent import NamedComponent, SettlementNameComponent, ShipNameComponent, PirateShipNameComponent
from horizons.component.restrictedpickup import RestrictedPickup
from horizons.component.selectablecomponent import SelectableComponent
from horizons.component.storagecomponent import StorageComponent
from horizons.component.tradepostcomponent import TradePostComponent

from horizons.world.production.producer import Producer, QueueProducer, UnitProducer


class ComponentHolder(object):
	"""
	Class that manages Component plug-ins
	It can be inherited by all objects that can hold components

	TUTORIAL:
	I can't explain component-oriented architecture to you here, but I can give you
	an overview of how we use it:
	Instead of putting all different features of entities into single classes,
	as is common in OOP, each feature is put into a component. This should
	increase the encapsulation, and it's easier if an object consists of 15 independent
	building blocks than if it were 15 classes, where many override the same function call
	and fight about who gets called first.
	Check class_mapping for a complete list of the different components we use.

	The components are stored in a dict, where the key is their name (a string).
	This is necessary so objects can be defined as a collection of their components in
	human readable format. This is done via yaml files in content/objects in our case.
	You could check out e.g. content/objects/buildings/lumberjackcamp.yaml to see what
	it looks like.

	This class manages the components; it stores them and makes them accessible.
	Check out the actual component class in horizons/component/__init__.py.
	"""

	class_mapping = {
	    'AmbientSoundComponent': AmbientSoundComponent,
	    'CommandableComponent': CommandableComponent,
	    'CollectingComponent': CollectingComponent,
	    'ColorOverlayComponent': ColorOverlayComponent,
	    'DepositComponent': DepositComponent,
	    'HealthComponent': HealthComponent,
	    'InventoryOverlayComponent': InventoryOverlayComponent,
	    'NamedComponent': NamedComponent,
	    'PirateShipNameComponent': PirateShipNameComponent,
	    'ProducerComponent': Producer,
	    'SettlementNameComponent': SettlementNameComponent,
	    'ShipNameComponent': ShipNameComponent,
	    'StorageComponent': StorageComponent,
	    'QueueProducerComponent': QueueProducer,
	    'RestrictedPickup': RestrictedPickup,
	    'SelectableComponent': SelectableComponent,
	    'TradePostComponent': TradePostComponent,
	    'UnitProducerComponent': UnitProducer,
	}

	def __init__(self, *args, **kwargs):
		super(ComponentHolder, self).__init__(*args, **kwargs)
		self.components = {}

	def initialize(self, **kwargs):
		"""Has to be called every time a componentholder is created. This is not
		in __init__() because we need to make sure that all other sub/parent classes
		have been inited, for example the ConcreteObject class. This is to ensure
		that all member variables of sub/parent classes are correctly set when we
		init the components. If someday all code is moved to components, this will
		not be necessary any more."""
		for component in self.__create_components():
			self.add_component(component)

	def __create_components(self):
		tmp_comp = []
		if hasattr(self, 'component_templates'):
			for entry in self.component_templates:
				if isinstance(entry, dict):
					for key, value in entry.iteritems():
						# TODO: try to pass read-only data to get_instance, since it's usually
						# cached and changes would apply to all instances
						# dict views of python2.7 could be a start.
						component = self.class_mapping[key].get_instance(value)
						tmp_comp.append(component)
				else:
					component = self.class_mapping[entry].get_instance()
					tmp_comp.append(component)
		# 'Resolve' dependencies by utilizing overloaded gt/lt
		tmp_comp.sort()
		return tmp_comp

	def remove(self):
		for component in self.components.values():
			component.remove()
		super(ComponentHolder, self).remove()

	def load(self, db, worldid):
		super(ComponentHolder, self).load(db, worldid)
		self.components = {}
		for component in self.__create_components():
			component.instance = self
			component.load(db, worldid)
			self.components[component.NAME] = component

	def save(self, db):
		super(ComponentHolder, self).save(db)
		for component in self.components.itervalues():
			component.save(db)

	def add_component(self, component):
		"""
		Adds new component to holder and sets the instance attribute on the component
		@param component: a component instance that is to be added
			all components will have the init only with instance attribute
		"""
		if not isinstance(component, Component):
			print component, type(component), component.__class__
		assert isinstance(component, Component)
		component.instance = self
		self.components[component.NAME] = component
		component.initialize()

	def remove_component(self, component_class):
		"""
		Removes component from holder.
		"""
		if self.has_component(component_class):
			self.components[component_class.NAME].remove()
			del self.components[component_class.NAME]

	def has_component(self, component_class):
		"""
		Check if holder has component with component name
		"""
		return component_class.NAME in self.components

	def get_component(self, component):
		return self.components.get(component.NAME)

	def get_component_by_name(self, name):
		return self.components.get(name)

	@classmethod
	def get_component_template(cls, component):
		"""Returns the component template data given a component NAME"""
		for entry in cls.component_templates:
			if isinstance(entry, dict):
				for key, value in entry.iteritems():
					if cls.class_mapping[key] == component or key == component:
						return value
		raise KeyError("This class does not contain a component with name: " + component.NAME)

########NEW FILE########
__FILENAME__ = depositcomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.component import Component
from horizons.component.storagecomponent import StorageComponent
from horizons.util.python.decorators import cachedmethod

class DepositComponent(Component):
	NAME = 'resource_deposit'
	DEPENDENCIES = ['StorageComponent']

	def __init__(self, resources):
		super(DepositComponent, self).__init__()
		self.resources = resources

	def initialize(self, inventory=None):
		if inventory:
			iterator = inventory.itercontents
		else:
			iterator = self.get_random_res_amounts
		for res, amount in iterator():
			self.instance.get_component(StorageComponent).inventory.alter(res, amount)

	@cachedmethod
	def get_res_ranges(self):
		"""Generator for tuples (res_id, min, max) for each resource that the deposit
		can contain (as defined in the object file)."""
		return ( (res, data.get('min_amount', 0), data['max_amount'])
		         for res, data in self.resources.iteritems() )

	def get_random_res_amounts(self):
		"""Generator for tuples (res_id, rand_amount) for each resource that the deposit
		can contain (as defined in the object file)."""
		return ( (res, self.session.random.randint(min_amount, max_amount))
		         for res, min_amount, max_amount in self.get_res_ranges() )

########NEW FILE########
__FILENAME__ = healthcomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.util.changelistener import metaChangeListenerDecorator
from horizons.component import Component

@metaChangeListenerDecorator("damage_dealt")
class HealthComponent(Component):
	"""
	Class that handles the health component
	"""
	log = logging.getLogger("component.health")

	# Store the name of this component
	NAME = 'health'

	def __init__(self, maxhealth):
		super(HealthComponent, self).__init__()
		assert maxhealth is not None, "Can not add HealthComponent without maxhealth!"
		self.max_health = float(maxhealth) if maxhealth is not None else None

	def initialize(self):
		self.health = float(self.max_health)
		self._add_listeners()

	def _add_listeners(self):
		self.add_damage_dealt_listener(self.check_if_alive)
		self.add_damage_dealt_listener(self.redraw_health)

	def save(self, db):
		db("INSERT INTO unit_health(owner_id, health) VALUES(?, ?)", self.instance.worldid, self.health)

	def load(self, db, worldid):
		self.health = db.get_health(worldid)
		self._add_listeners()

	def deal_damage(self, weapon_id, damage):
		#TODO retrieve modifiers from database by owner_id/weapon_id
		#scaling factor multiplies the damage taken by the unit
		scaling_factor = 1
		self.health -= scaling_factor * damage
		self.health = max(self.health, 0.0) # don't go below 0
		self.log.debug("dealing damage %s to %s; new health: %s", scaling_factor*damage, self.instance, self.health)
		self.on_damage_dealt()

	def check_if_alive(self, caller=None):
		if self.health <= 0:
			self.log.debug("Unit %s dies, health: %s", self.instance, self.health)
			self.instance.remove()

	def redraw_health(self, caller=None):
		if not self.instance:
			return
		if self.instance in self.session.selected_instances:
			if hasattr(self.instance, 'draw_health'):
				self.instance.draw_health()


########NEW FILE########
__FILENAME__ = inventoryoverlaycomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
from collections import defaultdict

from fife import fife

import horizons.globals

from horizons.component import Component
from horizons.messaging import InstanceInventoryUpdated
from horizons.scheduler import Scheduler
from horizons.util.loaders.actionsetloader import ActionSetLoader


class InventoryOverlayComponent(Component):
	"""Display different additional graphics ("animation overlays" in FIFE terminology)
	depending on inventory status of a building or unit.
	"""
	NAME = "inventoryoverlay"
	DEPENDENCIES = ['StorageComponent']
	log = logging.getLogger('component.overlays')

	def __init__(self, overlays=None):
		super(InventoryOverlayComponent, self).__init__()
		self.overlays = overlays or {}

		# Stores {resource_id: amount that is currently used as overlay, or None if no overlay}
		self.current_overlays = defaultdict(lambda: None)

	@property
	def action_set(self):
		"""E.g. 'as_lumberjack_barrack0' """
		return self.instance._action_set_id

	@property
	def fife_instance(self):
		return self.instance._instance

	@property
	def identifier(self):
		"""E.g. 'idle_as_lumberjack_barrack0' """
		return self.fife_instance.getCurrentAction().getId()

	def initialize(self):
		super(InventoryOverlayComponent, self).initialize()
		InstanceInventoryUpdated.subscribe(self.inventory_changed, sender=self.instance)


	def add_overlay(self, overlay_set, z_order=10):
		"""Creates animation overlay from action set *overlay_set* and adds it to fife instance.

		@param overlay_set: action set with images to be used as animation overlay
		@param z_order: the (numerical) drawing order identifier. Usually res_id.
		"""
		if not self.fife_instance.isAnimationOverlay(self.identifier):
			# parameter True: also convert color overlays attached to base frame(s) into animation
			self.fife_instance.convertToOverlays(self.identifier, True)

		for rotation, frames in overlay_set.iteritems():
			ov_anim = fife.Animation.createAnimation()
			for frame_img, frame_data in frames.iteritems():
				try:
					frame_length = frame_data[0]
				except TypeError:
					# not using atlases
					frame_length = frame_data
				pic = horizons.globals.fife.imagemanager.load(frame_img)
				frame_milliseconds = int(frame_length * 1000)
				ov_anim.addFrame(pic, frame_milliseconds)
			self.fife_instance.addAnimationOverlay(self.identifier, rotation, z_order, ov_anim)


	def remove_overlay(self, res_id):
		"""Removes animation overlay associated with resource *res_id* from fife instance.

		We use *res_id* as z-order identifier, which removeAnimationOverlay actually asks for.
		"""
		self.current_overlays[res_id] = None
		#TODO remove hardcoded rotations, use action set keys (of which set?)
		for rotation in range(45, 360, 90):
			self.fife_instance.removeAnimationOverlay(self.identifier, rotation, res_id)


	def inventory_changed(self, message):
		"""A changelistener notified the StorageComponent of this instance.

		Because it did not tell us which resources were added or removed, we
		need to check everything in the inventory for possible updates.
		"""
		for res_id, new_amount in message.inventory.iteritems():
			self.update_overlay(res_id, new_amount)


	def update_overlay(self, res_id, new_amount):
		"""Called when inventory amount of one resource changes.

		Looks for a fitting animation overlay based on the new inventory amount for that resource.
		If that overlay is different from the currently displayed one, removes the old overlay for
		that resource and adds a new one based on what fits *new_amount* best.
		"""
		try:
			overlay_order = self.overlays[self.action_set][self.instance._action][res_id]
		except KeyError:
			self.log.warning(
				'No overlays defined for resource `%s`, action `%s` and action set `%s`. '
				'Consider using `null` overlays for amount 0 in this action set.',
				res_id, self.instance._action, self.action_set)
			self.current_overlays[res_id] = None
			return

		all_action_sets = ActionSetLoader.get_sets()

		# We use max(0, new_amount) restricted to what exists in overlay_order.
		# E.g. for
		#   new_amount = 3
		#   overlay_order = [[0, None],  [2, 'as_2'],  [5, 'as_full']]
		# we drop 5 (because it is defined but too large),
		# ignore 4 and 3 (because they are not defined in overlay_order),
		# and find 'as_2' as our new overlay for the amount 2.

		for (amount, overlay_name) in sorted(overlay_order, reverse=True):

			if amount > new_amount:
				# This `if` drops defined-but-too-large candidates (i.e. case `5` in above example).
				continue

			if amount == self.current_overlays[res_id]:
				# Nothing to do, continue using the same overlay
				return

			if overlay_name is None:
				# Empty overlay, only display base action set (i.e. case `0` in above example)
				self.remove_overlay(res_id)
				return

			try:
				overlay_set = all_action_sets[self.action_set][overlay_name]
			except KeyError:
				self.log.warning(
					'Could not find overlay action set defined for object '
					'`%s` with id `%s` for resource `%s` and amount `%s`. '
					'Falling back to next lower overlay.',
					self.instance, self.identifier, res_id, amount)
				continue
			self.remove_overlay(res_id)
			self.add_overlay(overlay_set, z_order=res_id)
			self.current_overlays[res_id] = amount
			return


	def load(self, db, worldid):
		super(InventoryOverlayComponent, self).load(db, worldid)
		Scheduler().add_new_object(self.initialize, self, run_in=0)


	def remove(self):
		"""Removes all animation overlays from the fife instance.

		Also converts the animation overlay on drawing order 0 (i.e. the old base image)
		back to a plain "action set" in UH terminology.
		"""
		InstanceInventoryUpdated.unsubscribe(self.inventory_changed, sender=self.instance)

		for (res_id, overlay) in self.current_overlays.iteritems():
			if overlay is not None:
				self.remove_overlay(res_id)

		# remove base image "overlay" that we did `convertToOverlays` in `initialize`
		# Note that this gets us back the actual base image as not-an-overlay.
		# In particular, no animation overlays can be added unless `convertToOverlays`
		# is called again.
		self.remove_overlay(0)

		super(InventoryOverlayComponent, self).remove()


# If "old" FIFE version is detected (i.e. one without overlay support), silently disable.
if not hasattr(fife, 'AnimationOverlayMap'):
	class InventoryOverlayComponent(Component):

		def __init__(self, overlays=None):
			super(InventoryOverlayComponent, self).__init__()

########NEW FILE########
__FILENAME__ = namedcomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.component import Component
from horizons.util.changelistener import ChangeListener


class NamedComponent(Component):
	"""An object that has a special name. "Special" means, that it's not (only) autogenerated."""

	NAME = "namedcomponent"

	names_used = []

	def __init__(self, name=None):
		super(NamedComponent, self).__init__()
		self.name = name

	def initialize(self):
		self.set_name(self.name)

	def set_name(self, name=None):
		"""Actually sets the name."""
		if self.name is not None and self.name in NamedComponent.names_used:
			NamedComponent.names_used.remove(self.name)
		if name is None:
			name = self.get_default_name()
		self.name = name
		NamedComponent.names_used.append(self.name)
		if isinstance(self.instance, ChangeListener):
			self.instance._changed()

	def _possible_names(self):
		return [u'object_%s' % self.instance.worldid]

	def get_default_name(self):
		available_names = [name for name in self._possible_names() if name not in NamedComponent.names_used]

		if available_names != []:
			return self.session.random.choice(available_names)
		else:
			newname = self.session.random.choice(self._possible_names())
			index = 2
			while u"{newname} {index}".format(newname=newname, index=index) in NamedComponent.names_used:
				index += 1
			return u"{newname} {index}".format(newname=newname, index=index)

	def save(self, db):
		super(NamedComponent, self).save(db)
		db("INSERT INTO name (rowid, name) VALUES(?, ?)", self.instance.worldid, self.name)

	def load(self, db, worldid):
		super(NamedComponent, self).load(db, worldid)
		self.name = None
		name = db("SELECT name FROM name WHERE rowid = ?", worldid)[0][0]
		# We need unicode strings as the name is displayed on screen.
		self.set_name(name)

	@classmethod
	def reset(cls):
		cls.names_used = []

class ShipNameComponent(NamedComponent):

	def _possible_names(self):
		names = self.session.db("SELECT name FROM shipnames WHERE for_player = 1")
		return [x[0] for x in names]

class PirateShipNameComponent(NamedComponent):

	def _possible_names(self):
		names = self.session.db("SELECT name FROM shipnames WHERE for_pirate = 1")
		return [x[0] for x in names]

class SettlementNameComponent(NamedComponent):

	def _possible_names(self):
		names = self.session.db("SELECT name FROM citynames WHERE for_player = 1")
		return [x[0] for x in names]

########NEW FILE########
__FILENAME__ = restrictedpickup
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.component import Component

class RestrictedPickup(Component):
	""" Handles pickup location restrictions per whitelist.
	Treats something as allowed (not restricted) if contained
	in the whitelist *allowed*. If this is specified but empty,
	everything is considered forbidden.
	"""
	NAME = 'restricted'

	def __init__(self, allowed=None):
		super(RestrictedPickup, self).__init__()
		self.allowed = allowed or []

	def pickup_allowed_at(self, target_class):
		return target_class in self.allowed

########NEW FILE########
__FILENAME__ = selectablecomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife
import copy
import itertools
import operator

import horizons.globals

from horizons.component import Component
from horizons.constants import GFX, LAYERS, RES
from horizons.util.python import decorators
from horizons.util.shapes import RadiusRect


class SelectableComponent(Component):
	"""Stuff you can select.
	Has to be subdivided in buildings and units, which is further specialized to ships.

	Provides:
	show_menu(): shows tabs
	select(): highlight instance visually
	deselect(): inverse of select

	show_menu() and select() are frequently used in combination.

	The definitions must contain type, tabs and enemy_tabs.
	"""

	NAME = "selectablecomponent"

	@classmethod
	def get_instance(cls, arguments):
		# this can't be class variable because the classes aren't defined when
		# it would be parsed
		TYPES = { 'building' : SelectableBuildingComponent,
		          'unit'     : SelectableUnitComponent,
		          'ship'     : SelectableShipComponent,
		          'fisher' 	 : SelectableFisherComponent, }
		arguments = copy.copy(arguments)
		t = arguments.pop('type')
		return TYPES[ t ]( **arguments )

	def __init__(self, tabs, enemy_tabs, active_tab=None):
		super(SelectableComponent, self).__init__()
		# resolve tab
		from horizons.gui.tabs import resolve_tab
		self.tabs = map(resolve_tab, tabs)
		self.enemy_tabs = map(resolve_tab, enemy_tabs)
		self.active_tab = resolve_tab(active_tab) if active_tab is not None else None
		self._selected = False

	def show_menu(self, jump_to_tabclass=None):
		"""Shows tabwidget tabs of this instance.

		Opens the first such tab unless jump_to_tabclass specifies otherwise.
		@param jump_to_tabclass: open the first tab that is a subclass to this parameter
		"""
		from horizons.gui.tabs import TabWidget
		tablist = None
		if self.instance.owner is not None and self.instance.owner.is_local_player:
			tablist = self.tabs
		else: # this is an enemy instance with respect to the local player
			tablist = self.enemy_tabs

		if not tablist:
			return

		tabclasses = [tabclass for tabclass in tablist if tabclass.shown_for(self.instance)]
		try:
			active_tab_index = tabclasses.index(self.active_tab)
		except ValueError:
			active_tab_index = None
		tabs = [tabclass(self.instance) for tabclass in tabclasses]
		tabwidget = TabWidget(self.session.ingame_gui, tabs=tabs, active_tab=active_tab_index)

		if jump_to_tabclass:
			for i, tab in enumerate(tabs):
				if isinstance(tab, jump_to_tabclass):
					tabwidget.show_tab(i)
					break
		self.session.ingame_gui.show_menu(tabwidget)

	def select(self, reset_cam=False):
		self._selected = True
		if reset_cam:
			self.session.view.center(*self.instance.position.center.to_tuple())

	def deselect(self):
		self._selected = False

	@property
	def selected(self):
		return self._selected

	def remove(self):
		if self.instance in self.session.selected_instances:
			self.session.selected_instances.remove(self.instance)
		for group in self.session.selection_groups:
			group.discard(self)
		if self._selected:
			self.deselect()
		super(SelectableComponent, self).remove()


class SelectableBuildingComponent(SelectableComponent):

	selection_color = (255, 255, 32, 192)

	# these smell like instance attributes, but sometimes have to be used in non-instance
	# contexts (e.g. building tool).
	class ListHolder(object):
		def __init__(self):
			self.l = []

	# read/write on class variables is somewhat borked in python, so
	_selected_tiles = ListHolder() # tiles that are selected. used for clean deselect.
	_selected_fake_tiles = ListHolder() # fake tiles create over ocean to select (can't select ocean directly)

	@classmethod
	def reset(cls):
		"""Called on session end to get rid of static data and init variables"""
		cls._selected_tiles.l = []
		cls._selected_fake_tiles.l = []

	def __init__(self, tabs, enemy_tabs, active_tab=None, range_applies_only_on_island=True):
		super(SelectableBuildingComponent, self).__init__(tabs, enemy_tabs, active_tab=active_tab)
		self.range_applies_only_on_island = range_applies_only_on_island

	def initialize(self):
		# check for related buildings (defined in db, not yaml)
		related_buildings = self.session.db.get_related_building_ids_for_menu(self.instance.id)
		if related_buildings:
			from horizons.gui.tabs import BuildRelatedTab
			self.tabs += (BuildRelatedTab,)

	def load(self, db, worldid):
		self.initialize()

	def select(self, reset_cam=False):
		"""Runs necessary steps to select the building."""
		super(SelectableBuildingComponent, self).select(reset_cam)
		self.set_selection_outline()
		if self.instance.owner is None or not self.instance.owner.is_local_player:
			return # don't show enemy ranges
		renderer = self.session.view.renderer['InstanceRenderer']
		self._do_select(renderer, self.instance.position, self.session.world,
		                self.instance.settlement, self.instance.radius, self.range_applies_only_on_island)

	def set_selection_outline(self):
		"""Only set the selection outline.
		Useful when it has been removed by some kind of interference"""
		renderer = self.session.view.renderer['InstanceRenderer']
		renderer.addOutlined(self.instance._instance, self.selection_color[0], self.selection_color[1],
		                     self.selection_color[2], GFX.BUILDING_OUTLINE_WIDTH,
		                     GFX.BUILDING_OUTLINE_THRESHOLD)

	def deselect(self):
		"""Runs neccassary steps to deselect the building.
		Only deselects if this building has been selected."""
		if self._selected:
			super(SelectableBuildingComponent, self).deselect()
			renderer = self.session.view.renderer['InstanceRenderer']
			renderer.removeOutlined(self.instance._instance)
			renderer.removeAllColored()
			for fake_tile in self.__class__._selected_fake_tiles.l:
				self.session.view.layers[LAYERS.FIELDS].deleteInstance(fake_tile)
			self.__class__._selected_fake_tiles.l = []

	@classmethod
	def select_building(cls, session, position, settlement,
	                    radius, range_applies_only_on_island):
		"""Select a hypothecial instance of this class. Use Case: Buildingtool.
		Only works on a subclass of BuildingClass, since it requires certain class attributes.
		@param session: Session instance
		@param position: Position of building, usually Rect
		@param settlement: Settlement instance the building belongs to"""
		renderer = session.view.renderer['InstanceRenderer']

		cls._do_select(renderer, position, session.world, settlement,
		               radius, range_applies_only_on_island)

	@classmethod
	def deselect_building(cls, session):
		"""@see select_building
		Used by building tool, allows incremental updates
		@return list of tiles that were deselected (only normal tiles, no fake tiles)"""
		remove_colored = session.view.renderer['InstanceRenderer'].removeColored
		for tile in cls._selected_tiles.l:
			remove_colored(tile._instance)
			if tile.object is not None:
				remove_colored(tile.object._instance)
		selected_tiles = cls._selected_tiles.l
		cls._selected_tiles.l = []
		for fake_tile in cls._selected_fake_tiles.l:
			session.view.layers[LAYERS.FIELDS].deleteInstance(fake_tile)
		cls._selected_fake_tiles.l = []
		return selected_tiles

	@classmethod
	def select_many(cls, buildings, renderer):
		"""Same as calling select() on many instances, but way faster.
		Limited functionality, only use on real buildings of a settlement."""
		if not buildings:
			return [] # that is not many

		selected_tiles = []

		# group buildings per settlement and treat them separately
		# they cannot share tiles, and we can then just access the settlements ground map
		buildings_sorted = sorted(buildings, key=operator.attrgetter('settlement'))
		for settlement, buildings in itertools.groupby( buildings_sorted, operator.attrgetter('settlement') ):
			# resolve operator
			buildings = list(buildings)

			for building in buildings:
				building.get_component(SelectableComponent).set_selection_outline()

			coords = set( coord for
			              building in buildings for
			              coord in building.position.get_radius_coordinates(building.radius, include_self=True) )

			for coord in coords:
				tile = settlement.ground_map.get(coord)
				if tile:
					if ( 'constructible' in tile.classes or 'coastline' in tile.classes ):
						cls._add_selected_tile(tile, renderer)
						selected_tiles.append(tile)
		return selected_tiles

	@classmethod
	def _do_select(cls, renderer, position, world, settlement,
	               radius, range_applies_only_on_island):
		island = world.get_island(position.origin)
		if island is None:
			return # preview isn't on island, and therefore invalid

		if range_applies_only_on_island:
			ground_holder = None # use settlement or island as tile provider (prefer settlement, since it contains fewer tiles)
			if settlement is None:
				ground_holder = island
			else:
				ground_holder = settlement

			for tile in ground_holder.get_tiles_in_radius(position, radius, include_self=False):
				if 'constructible' in tile.classes or 'coastline' in tile.classes:
					if settlement is None and tile.settlement is not None:
						# trying to build a warehouse and the tile is already owned by another player.
						continue
					cls._add_selected_tile(tile, renderer)
		else:
			# we have to color water too
			# since water tiles are huge, create fake tiles and color them
			cls._init_fake_tile()

			layer = world.session.view.layers[LAYERS.FIELDS]
			# color island or fake tile
			for tup in position.get_radius_coordinates(radius):
				tile = island.get_tile_tuple(tup)
				if tile is not None:
					cls._add_selected_tile(tile, renderer)
				else: # need extra tile
					cls._add_fake_tile(tup[0], tup[1], layer, renderer)

	@classmethod
	def _init_fake_tile(cls):
		"""Sets the _fake_tile_obj class variable with a ready to use fife object.

		To create a new fake tile, use _add_fake_tile()."""
		# use fixed SelectableBuildingComponent here, to make sure subclasses also read the same variable
		if not hasattr(SelectableBuildingComponent, "_fake_tile_obj"):
			# create object to create instances from
			fake_tile_obj = horizons.globals.fife.engine.getModel().createObject('fake_tile_obj', 'ground')
			SelectableBuildingComponent._fake_tile_obj = fake_tile_obj
			fife.ObjectVisual.create(SelectableBuildingComponent._fake_tile_obj)

			img_path = 'content/gfx/fake_water.png'
			img = horizons.globals.fife.imagemanager.load(img_path)
			for rotation in [45, 135, 225, 315]:
				SelectableBuildingComponent._fake_tile_obj.get2dGfxVisual().addStaticImage(rotation, img.getHandle())

	@classmethod
	def _add_fake_tile(cls, x, y, layer, renderer):
		"""Adds a fake tile to the position. Requires 'cls._fake_tile_obj' to be set."""
		inst = layer.createInstance(SelectableBuildingComponent._fake_tile_obj,
	                                fife.ModelCoordinate(x, y, 0), "")
		fife.InstanceVisual.create(inst)
		cls._selected_fake_tiles.l.append(inst)
		renderer.addColored(inst, *cls.selection_color)


	@classmethod
	def _add_selected_tile(cls, tile, renderer, remember=True):
		"""
		@param remember: whether to keep track of this tile. Set to False on recolorings.
		"""
		if remember:
			cls._selected_tiles.l.append(tile)
		renderer.addColored(tile._instance, *cls.selection_color)
		# Add color to objects on the tiles
		obj = tile.object
		if obj is not None:
			renderer.addColored(obj._instance, *cls.selection_color)


class SelectableUnitComponent(SelectableComponent):

	def select(self, reset_cam=False):
		"""Runs necessary steps to select the unit."""
		super(SelectableUnitComponent, self).select(reset_cam)
		self.session.view.renderer['InstanceRenderer'].addOutlined(self.instance._instance, 255, 255, 255, GFX.UNIT_OUTLINE_WIDTH, GFX.UNIT_OUTLINE_THRESHOLD)
		self.instance.draw_health()
		self.session.view.add_change_listener(self.instance.draw_health)

	def deselect(self):
		"""Runs necessary steps to deselect the unit."""
		if not self._selected:
			return
		super(SelectableUnitComponent, self).deselect()
		self.session.view.renderer['InstanceRenderer'].removeOutlined(self.instance._instance)
		self.instance.draw_health(remove_only=True)
		# this is necessary to make deselect idempotent
		self.session.view.discard_change_listener(self.instance.draw_health)


class SelectableShipComponent(SelectableUnitComponent):

	def select(self, reset_cam=False):
		"""Runs necessary steps to select the ship."""
		super(SelectableShipComponent, self).select(reset_cam=reset_cam)

		# add a buoy at the ship's target if the player owns the ship
		if self.instance.owner.is_local_player:
			self.instance._update_buoy()
			self.session.ingame_gui.minimap.show_unit_path(self.instance)

	def deselect(self):
		"""Runs necessary steps to deselect the ship."""
		if self._selected:
			super(SelectableShipComponent, self).deselect()
			self.instance._update_buoy(remove_only=True)


class SelectableFisherComponent(SelectableBuildingComponent):
	"""Class used to highlight the radius of a fisher. Highlights only the fishing
	grounds."""

	@classmethod
	def _do_select(cls, renderer, position, world, settlement, radius,
	               range_applies_only_on_island):
		# No super, we don't want to color the ground
		cls._init_fake_tile()
		layer = world.session.view.layers[LAYERS.FIELDS]
		for fish_deposit in world.get_providers_in_range(RadiusRect(position, radius), res=RES.FISH):
			#renderer.addColored(fish_deposit._instance, *cls.selection_color)
			#cls._selected_tiles.l.append(fish_deposit)
			for pos in fish_deposit.position:
				cls._add_fake_tile(pos.x, pos.y, layer, renderer)

decorators.bind_all(SelectableFisherComponent)
decorators.bind_all(SelectableBuildingComponent)
decorators.bind_all(SelectableShipComponent)
decorators.bind_all(SelectableUnitComponent)

########NEW FILE########
__FILENAME__ = stancecomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.component import Component
from horizons.util.shapes import Annulus, Circle
from horizons.util.python.callback import Callback
from horizons.scheduler import Scheduler
from horizons.world.units.movingobject import MoveNotPossible

class StanceComponent(Component):
	"""
	Class to be inherited for all unit stances
	It has methods defined for specific instance states
	The default methods are defined that the instance only listens to user commands
	If a state different from user_attack or user_move is passed, it stops any action
	and switches to idle.

	NOTE:
	This does not use stance inheritance as intended, but multiple stance
	components are present at the same time, while only one is used at a time.
	"""

	# Store the name of this component
	NAME = 'stance'

	def __init__(self):
		super(StanceComponent, self).__init__()
		self.state = 'idle'
		self.action = {
		    'idle' : self.act_idle,
		    'user_attack' : self.act_user_attack,
		    'user_move' : self.act_user_move,
		    'move_back' : self.act_move_back,
		    'auto_attack' : self.act_auto_attack,
		    'flee' : self.act_flee,
		}

	def initialize(self):
		# change state to 'user_attack' when the user issues attack via right click
		self.instance.add_user_attack_issued_listener(Callback(self.set_state, 'user_attack'))
		# change state to 'user_move' when the user issues movement via right click
		try:
			self.instance.add_user_move_issued_listener(Callback(self.set_state, 'user_move'))
		except AttributeError:
			pass # temporary workaround to make it work for towers

	def remove(self):
		self.instance.remove_user_attack_issued_listener(Callback(self.set_state, 'user_attack'))
		try:
			self.instance.remove_user_move_issued_listener(Callback(self.set_state, 'user_move'))
		except AttributeError:
			pass # temporary workaround to make it work for towers
		super(StanceComponent, self).remove()

	def set_state(self, state):
		self.state = state

	def get_state(self):
		return self.state

	def act(self):
		"""
		Act according to current state
		This is called every few second in the instance code
		"""
		self.action[self.state]()

	def act_idle(self):
		"""
		Method executed when the instance is idle
		"""
		pass

	def act_user_attack(self):
		"""
		Method executed when the instance is trying to attack a target selected by the user
		"""
		if not self.instance.is_attacking():
			self.state = 'idle'

	def act_user_move(self):
		"""
		Method executed when the instance is moving to a location selected by the user
		"""
		if not self.instance.is_moving():
			self.state = 'idle'

	def act_move_back(self):
		"""
		Method executed when the instance is moving back to it's default location
		"""
		self.instance.stop()
		self.state = 'idle'

	def act_auto_attack(self):
		"""
		Method executed when the instance has auto acquired target
		"""
		self.instance.stop_attack()
		self.state = 'idle'

	def act_flee(self):
		"""
		Method executed when the instance is trying to evade an attack
		"""
		self.instance.stop()
		self.state = 'idle'


class LimitedMoveStance(StanceComponent):
	"""
	Stance that attacks any unit in stance range and follows it with limited move space
	This is inherited by Aggressive and Hold Ground stances
	In adition to StanceComponent it has the following attributes:
		stance_radius - int with the radius in which instance shold look for target
		move_range - int with the radius in which instance shold move when attacking it
	It also keeps track of the return position in which the unit should return when stopped attacking
	"""

	def __init__(self):
		super(LimitedMoveStance, self).__init__()
		#TODO get range from db
		self.stance_radius = 0
		self.move_range = 0
		# get instance data after it was inited
		Scheduler().add_new_object(self.get_instance_data, self, run_in=0)

	def get_instance_data(self):
		# get a copy of the center Point object
		self.return_position = self.instance.position.center.copy()

	def act_idle(self):
		"""
		Find target in range then attack it
		"""
		target = self.get_target(self.stance_radius + self.instance._max_range)
		if target:
			self.instance.attack(target)
			self.state = 'auto_attack'

	def act_user_move(self):
		"""
		At the end of user move change the returning position
		"""
		if not self.instance.is_moving():
			self.state = 'idle'
			self.return_position = self.instance.position.center.copy()

	def act_user_attack(self):
		"""
		If attack ends, update the returning position
		"""
		if not self.instance.is_attacking():
			self.state = 'idle'
			self.return_position = self.instance.position.center.copy()

	def act_move_back(self):
		"""
		When moving back try to find target. If found, attack it and drop movement
		"""
		target = self.get_target(self.stance_radius + self.instance._max_range)
		if target:
			self.instance.attack(target)
			self.state = 'auto_attack'
		elif self.instance.position.center == self.return_position:
			self.state = 'idle'

	def act_auto_attack(self):
		"""
		Check if target still exists or if unit exited the hold ground area
		"""
		if not Circle(self.return_position, self.move_range).contains(self.instance.position.center) or \
			not self.instance.is_attacking():
			try:
				self.instance.move(self.return_position)
			except MoveNotPossible:
				self.instance.move(Circle(self.return_position, self.stance_radius))
			self.state = 'move_back'

	def get_target(self, radius):
		"""
		Returns closest attackable unit in radius
		"""
		enemies = [u for u in self.session.world.get_health_instances(self.instance.position.center, radius)
		           if self.session.world.diplomacy.are_enemies(u.owner, self.instance.owner)]

		if not enemies:
			return None

		return min(enemies, key = lambda e: self.instance.position.distance(e.position))

class AggressiveStance(LimitedMoveStance):
	"""
	Stance that attacks units in close range when doing movement
	"""

	NAME = 'aggressive_stance'

	def __init__(self):
		super(AggressiveStance, self).__init__()
		#TODO get range from db
		self.stance_radius = 15
		self.move_range = 25

	def act_user_move(self):
		"""
		Check if it can attack while moving
		"""
		super(AggressiveStance, self).act_user_move()
		target = self.get_target(self.instance._max_range)
		if target:
			self.instance.fire_all_weapons(target.position.center)

	def act_user_attack(self):
		"""
		Check if can attack while moving to another attack
		"""
		super(AggressiveStance, self).act_user_attack()
		target = self.get_target(self.instance._max_range)
		if target:
			self.instance.fire_all_weapons(target.position.center)

class HoldGroundStance(LimitedMoveStance):

	NAME = 'hold_ground_stance'

	def __init__(self):
		super(HoldGroundStance, self).__init__()
		self.stance_radius = 5
		self.move_range = 15

class NoneStance(StanceComponent):

	NAME = 'none_stance'

	pass

class FleeStance(StanceComponent):
	"""
	Move away from any approaching units
	"""

	NAME = 'flee_stance'

	def __init__(self):
		super(FleeStance, self).__init__()
		self.lookout_distance = 20

	def act_idle(self):
		"""
		If an enemy unit approaches move away from it
		"""
		unit = self.get_approaching_unit()
		if unit:
			try:
				distance = unit._max_range + self.lookout_distance
				self.instance.move(Annulus(unit.position.center, distance, distance + 2))
				self.state = 'flee'
			except MoveNotPossible:
				pass

	def act_flee(self):
		"""
		If movemen stops, switch to idle
		"""
		if not self.instance.is_moving():
			self.state = 'idle'
			# check again for target and move
			self.act_idle()

	def get_approaching_unit(self):
		"""
		Gets the closest unit that can fire to instance
		"""
		enemies = [u for u in self.session.world.get_health_instances(self.instance.position.center, self.lookout_distance)
		           if self.session.world.diplomacy.are_enemies(u.owner, self.instance.owner) and hasattr(u, '_max_range')]

		if not enemies:
			return None

		sort_order = lambda e: self.instance.position.distance(e.position) + e._max_range
		return min(enemies, key=sort_order)


DEFAULT_STANCES = [ HoldGroundStance, AggressiveStance, NoneStance, FleeStance ]

########NEW FILE########
__FILENAME__ = storagecomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.component import Component
from horizons.messaging import InstanceInventoryUpdated
from horizons.scheduler import Scheduler
from horizons.world.storage import (
	PositiveSizedSlotStorage, PositiveStorage, PositiveSizedSpecializedStorage,
	SettlementStorage, PositiveTotalNumSlotsStorage,
)


class StorageComponent(Component):
	"""The StorageComponent class is used for everything that has an inventory.
	
	Examples for these classes are ships, settlements, buildings, etc.
	Basically it just adds an inventory, nothing more, nothing less.
	"""

	NAME = 'storagecomponent'

	storage_mapping = {
	    'PositiveStorage': PositiveStorage,
	    'PositiveSizedSlotStorage': PositiveSizedSlotStorage,
	    'PositiveTotalNumSlotsStorage': PositiveTotalNumSlotsStorage,
	    'SlotsStorage': PositiveSizedSpecializedStorage,
	    'SettlementStorage': SettlementStorage # pseudo storage meaning to share settlement storage
	    }

	def __init__(self, inventory):
		super(StorageComponent, self).__init__()
		self.inventory = inventory

		# SettlementStorage is used as flag to signal using another inventory
		self.has_own_inventory = not isinstance(self.inventory, SettlementStorage)

	def initialize(self):
		# NOTE: also called on load (initialize usually isn't)
		if not self.has_own_inventory:
			self.inventory = self.instance.settlement.get_component(StorageComponent).inventory
		self.inventory.add_change_listener(self.something_changed)

	def remove(self):
		super(StorageComponent, self).remove()
		if self.has_own_inventory:
			# no changelister calls on remove
			self.inventory.clear_change_listeners()
			# remove inventory to prevent any action here in subclass remove
			self.inventory.reset_all()

	def save(self, db):
		super(StorageComponent, self).save(db)
		if self.has_own_inventory:
			self.inventory.save(db, self.instance.worldid)

	def load(self, db, worldid):
		super(StorageComponent, self).load(db, worldid)
		self.initialize()
		if self.has_own_inventory:
			self.inventory.load(db, worldid)
		# This allows other components to instantly update on load
		Scheduler().add_new_object(self.something_changed, self, run_in=0)

	def something_changed(self):
		"""Used as proxy to send messages when a changelistener notifies us.

		Masks the message sender to be `self.instance` rather than self because
		that is what we are interested in, usually.
		"""
		InstanceInventoryUpdated.broadcast(self.instance, self.inventory._storage)

	@classmethod
	def get_instance(cls, arguments):
		key, value = arguments.iteritems().next()
		storage = cls.storage_mapping[key]
		inventory = storage(**value)
		return cls(inventory=inventory)

########NEW FILE########
__FILENAME__ = tradepostcomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.changelistener import ChangeListener
from horizons.util.worldobject import WorldObject
from horizons.constants import RES, TRADER
from horizons.scheduler import Scheduler
from horizons.component.storagecomponent import StorageComponent
from horizons.component import Component

class TRADE_ERROR_TYPE(object):
	"""Machine controlled entities need to know the difference. On this basis, they decide
	whether to retry the trade in a few seconds.
	"""
	NO_ERROR, TEMPORARY, PERMANENT = range(3)

class TradeSlotInfo(object):
	def __init__(self, resource_id, selling, limit):
		self.resource_id = resource_id
		self.selling = selling
		self.limit = limit

class TradePostComponent(ChangeListener, Component):
	"""This Class has to be inherited by every class that wishes to use BuySellTab and trade with
	the free trader.
	"""
	NAME = 'tradepostcomponent'
	yaml_tag = u'!TradePostComponent'

	def __init__(self):
		super(TradePostComponent, self).__init__()

	def initialize(self):
		self.slots = [None, None, None] # [TradeSlotInfo, ...]
		self.buy_list = {} # dict of resources that are to be bought. {resource_id: slot_id, ...}
		self.sell_list = {} # dict of resources that are to be sold.  {resource_id: slot_id, ...}
		self.trade_history = [] # [(tick, player_id, resource_id, amount, gold), ...] ordered by tick, player_id
		self.buy_history = {} # {tick_id: (res, amount, price), ...}
		self.sell_history = {} # {tick_id: (res, amount, price), ...}
		self.total_income = 0
		self.total_expenses = 0

	def set_slot(self, slot_id, resource_id, selling, limit):
		self.clear_slot(slot_id, False)
		self.slots[slot_id] = TradeSlotInfo(resource_id, selling, limit)
		if selling:
			self.sell_list[resource_id] = slot_id
		else:
			self.buy_list[resource_id] = slot_id
		self._changed()

	def clear_slot(self, slot_id, trigger_changed):
		if self.slots[slot_id] is not None:
			old_resource_id = self.slots[slot_id].resource_id
			if self.slots[slot_id].selling:
				del self.sell_list[old_resource_id]
			else:
				del self.buy_list[old_resource_id]

		self.slots[slot_id] = None
		if trigger_changed:
			self._changed()

	def get_free_slot(self, resource_id):
		if resource_id in self.buy_list:
			return self.buy_list[resource_id]
		if resource_id in self.sell_list:
			return self.sell_list[resource_id]
		for i in xrange(len(self.slots)):
			if self.slots[i] is None:
				return i
		return None

	def save(self, db):
		super(TradePostComponent, self).save(db)

		for slot_id in xrange(len(self.slots)):
			if self.slots[slot_id] is not None:
				db("INSERT INTO trade_slots(trade_post, slot_id, resource_id, selling, trade_limit) VALUES(?, ?, ?, ?, ?)",
				   self.instance.worldid, slot_id, self.slots[slot_id].resource_id, self.slots[slot_id].selling, self.slots[slot_id].limit)

		db("INSERT INTO trade_values(object, total_income, total_expenses) VALUES (?, ?, ?)",
		   self.instance.worldid, self.total_income, self.total_expenses)

		for row in self.trade_history:
			translated_tick = row[0] - Scheduler().cur_tick # pre-translate for the loading process
			db("INSERT INTO trade_history(settlement, tick, player, resource_id, amount, gold) VALUES(?, ?, ?, ?, ?, ?)",
				self.instance.worldid, translated_tick, row[1], row[2], row[3], row[4])

	def load(self, db, worldid):
		super(TradePostComponent, self).load(db, worldid)
		self.initialize()

		for (slot_id, resource_id, selling, limit) in db("SELECT slot_id, resource_id, selling, trade_limit FROM trade_slots WHERE trade_post = ?", worldid):
			self.set_slot(slot_id, resource_id, selling, limit)

		self.total_income, self.total_expenses = db("SELECT total_income, total_expenses FROM trade_values WHERE object = ?", worldid)[0]

		for row in db("SELECT tick, player, resource_id, amount, gold FROM trade_history WHERE settlement = ? ORDER BY tick, player", worldid):
			self.trade_history.append(row)

	def get_owner_inventory(self):
		return self.instance.owner.get_component(StorageComponent).inventory

	def get_inventory(self):
		return self.instance.get_component(StorageComponent).inventory

	def buy(self, res, amount, price, player_id):
		"""Buy from the free trader.
		@param res:
		@param amount:
		@param price: cumulative price for whole amount of res
		@param player_id: the worldid of the trade partner
		@return bool, whether we did buy it"""
		assert price >= 0 and amount >= 0
		if not res in self.buy_list or \
				self.get_owner_inventory()[RES.GOLD] < price or \
				self.get_inventory().get_free_space_for(res) < amount or \
				amount + self.get_inventory()[res] > self.slots[self.buy_list[res]].limit:
			self._changed()
			return False

		else:
			remnant = self.get_owner_inventory().alter(RES.GOLD, -price)
			assert remnant == 0
			remnant = self.get_inventory().alter(res, amount)
			assert remnant == 0
			self.trade_history.append((Scheduler().cur_tick, player_id, res, amount, -price))
			self.buy_history[ Scheduler().cur_tick ] = (res, amount, price)
			self.total_expenses += amount*price
			self._changed()
			return True
		assert False

	def sell(self, res, amount, price, player_id):
		"""Sell to the free trader.
		@param res:
		@param amount:
		@param price: cumulative price for whole amount of res
		@param player_id: the worldid of the trade partner
		@return bool, whether we did sell it"""
		assert price >= 0 and amount >= 0
		if not res in self.sell_list or \
				self.get_inventory()[res] < amount or \
				self.get_inventory()[res] - amount < self.slots[self.sell_list[res]].limit:
			self._changed()
			return False

		else:
			remnant = self.get_owner_inventory().alter(RES.GOLD, price)
			assert remnant == 0
			remnant = self.get_inventory().alter(res, -amount)
			assert remnant == 0
			self.trade_history.append((Scheduler().cur_tick, player_id, res, -amount, price))
			self.sell_history[ Scheduler().cur_tick ] = (res, amount, price)
			self.total_income += amount*price
			self._changed()
			return True
		assert False

	def sell_resource(self, ship_worldid, resource_id, amount, add_error_type=False, suppress_messages=False):
		""" Attempt to sell the given amount of resource to the ship, returns the amount sold.
		@param add_error_type: if True, return tuple where second item is ERROR_TYPE"""
		ship = WorldObject.get_object_by_id(ship_worldid)

		def err(string, err_type):
			if not suppress_messages and ship.owner.is_local_player:
				self.session.ingame_gui.message_widget.add_custom(string, point=ship.position)
			return 0 if not add_error_type else (0, err_type)

		if resource_id not in self.sell_list:
			return err(_("The trade partner does not sell this."), TRADE_ERROR_TYPE.PERMANENT)

		price = int(self.session.db.get_res_value(resource_id) * TRADER.PRICE_MODIFIER_BUY) # price per ton of resource
		assert price > 0

		# can't sell more than the ship can fit in its inventory
		amount = min(amount, ship.get_component(StorageComponent).inventory.get_free_space_for(resource_id))
		if amount <= 0:
			return err(_("You can not store this."), TRADE_ERROR_TYPE.PERMANENT)
		# can't sell more than the ship's owner can afford
		amount = min(amount, ship.owner.get_component(StorageComponent).inventory[RES.GOLD] // price)
		if amount <= 0:
			return err(_("You can not afford to buy this."), TRADE_ERROR_TYPE.TEMPORARY)
		# can't sell more than what we have
		amount = min(amount, self.get_inventory()[resource_id])
		# can't sell more than we are trying to sell according to the settings
		amount = min(amount, self.get_inventory()[resource_id] - self.slots[self.sell_list[resource_id]].limit)
		if amount <= 0:
			return err(_("The trade partner does not sell more of this."), TRADE_ERROR_TYPE.TEMPORARY)

		total_price = price * amount
		assert self.get_owner_inventory().alter(RES.GOLD, total_price) == 0
		assert ship.owner.get_component(StorageComponent).inventory.alter(RES.GOLD, -total_price) == 0
		assert self.get_inventory().alter(resource_id, -amount) == 0
		assert ship.get_component(StorageComponent).inventory.alter(resource_id, amount) == 0
		self.trade_history.append((Scheduler().cur_tick, ship.owner.worldid, resource_id, -amount, total_price))
		self.sell_history[Scheduler().cur_tick] = (resource_id, amount, total_price)
		self.total_income += total_price
		self._changed()
		return amount if not add_error_type else amount, TRADE_ERROR_TYPE.NO_ERROR

	def buy_resource(self, ship_worldid, resource_id, amount, add_error_type=False, suppress_messages=False):
		""" Attempt to buy the given amount of resource from the ship, return the amount bought
		@param add_error_type: if True, return tuple where second item is ERROR_TYPE"""
		ship = WorldObject.get_object_by_id(ship_worldid)

		def err(string, err_type):
			if not suppress_messages and ship.owner.is_local_player:
				self.session.ingame_gui.message_widget.add_custom(string, point=ship.position)
			return 0 if not add_error_type else 0, err_type

		if resource_id not in self.buy_list:
			return err(_("The trade partner does not buy this."), TRADE_ERROR_TYPE.PERMANENT)

		price = int(self.session.db.get_res_value(resource_id) * TRADER.PRICE_MODIFIER_SELL) # price per ton of resource
		assert price > 0

		# can't buy more than the ship has
		amount = min(amount, ship.get_component(StorageComponent).inventory[resource_id])
		if amount <= 0:
			return err(_("You do not possess this."), TRADE_ERROR_TYPE.PERMANENT)
		# can't buy more than we can fit in the inventory
		amount = min(amount, self.get_inventory().get_free_space_for(resource_id))
		if amount <= 0:
			return err(_("The trade partner can not store more of this."), TRADE_ERROR_TYPE.TEMPORARY)
		# can't buy more than we can afford
		amount = min(amount, self.get_owner_inventory()[RES.GOLD] // price)
		if amount <= 0:
			return err(_("The trade partner can not afford to buy this."), TRADE_ERROR_TYPE.TEMPORARY)

		# can't buy more than we are trying to buy according to the settings
		amount = min(amount, self.slots[self.buy_list[resource_id]].limit - self.get_inventory()[resource_id])
		if amount <= 0:
			return err(_("The trade partner does not buy more of this."), TRADE_ERROR_TYPE.TEMPORARY)

		total_price = price * amount
		assert self.get_owner_inventory().alter(RES.GOLD, -total_price) == 0
		assert ship.owner.get_component(StorageComponent).inventory.alter(RES.GOLD, total_price) == 0
		assert self.get_inventory().alter(resource_id, amount) == 0
		assert ship.get_component(StorageComponent).inventory.alter(resource_id, -amount) == 0
		self.trade_history.append((Scheduler().cur_tick, ship.owner.worldid, resource_id, amount, -total_price))
		self.buy_history[Scheduler().cur_tick] = (resource_id, amount, total_price)
		self.total_expenses += total_price
		self._changed()
		return amount if not add_error_type else amount, TRADE_ERROR_TYPE.TEMPORARY

	@property
	def sell_income(self):
		"""Returns sell income of last month.
		Deletes older entries of the sell list."""
		income = 0
		last_month_start = Scheduler().cur_tick - Scheduler().get_ticks_of_month()
		keys_to_delete = []
		for key, values in self.sell_history.iteritems():
			if key < last_month_start:
				keys_to_delete.append(key)
			else:
				income += values[2]
		# remove old keys
		for key in keys_to_delete:
			del self.sell_history[key]
		return income

	@property
	def buy_expenses(self):
		"""Returns last months buy expenses.
		Deletes older entries of the buy list."""
		expenses = 0
		last_month_start = Scheduler().cur_tick - Scheduler().get_ticks_of_month()
		keys_to_delete = []
		for key, values in self.buy_history.iteritems():
			if key < last_month_start:
				keys_to_delete.append(key)
			else:
				expenses += values[2]
		# remove old keys
		for key in keys_to_delete:
			del self.buy_history[key]
		return expenses

	@property
	def total_earnings(self):
		"""Returns the entire earning of this settlement
		total_earnings = sell_income - buy_expenses"""
		return self.total_income - self.total_expenses

########NEW FILE########
__FILENAME__ = constants
# -.- coding: utf-8 -.-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import ctypes
import platform
import os
import os.path

from horizons.ext.enum import Enum

"""This file keeps track of the constants that are used in Unknown Horizons.
NOTE: Using magic constants in code is generally a bad style, so avoid where
possible and instead import the proper classes of this file.
"""

##Versioning
class VERSION:
	def _get_git_version():
		"""Function gets latest revision of the working copy.
		It only works in git repositories, and is actually a hack.
		"""
		try:
			from run_uh import get_content_dir_parent_path
			uh_path = get_content_dir_parent_path()
			git_head_path = os.path.join(uh_path, '.git', 'HEAD')
			if os.path.exists(git_head_path):
				head = open(git_head_path).readline().strip().partition(' ')
				if head[2]:
					head_file = os.path.join(uh_path, '.git', head[2])
				else:
					head_file = git_head_path
				if os.path.exists(head_file):
					return unicode(open(head_file).readline().strip()[0:7])
		#if there is no .git directory then check for gitversion.txt
		except ImportError:
			try:
				return unicode(open(os.path.join("content", "packages", "gitversion.txt")).read())
			except IOError:
				return u"<unknown>"

		return u"<unknown>"

	RELEASE_NAME    = "Unknown Horizons %s"
	RELEASE_VERSION = _get_git_version()
	# change for release:
	IS_DEV_VERSION = True
	#RELEASE_VERSION = u'2013.3'

	REQUIRED_FIFE_MAJOR_VERSION = 0
	REQUIRED_FIFE_MINOR_VERSION = 3
	REQUIRED_FIFE_PATCH_VERSION = 4

	REQUIRED_FIFE_VERSION = (REQUIRED_FIFE_MAJOR_VERSION, REQUIRED_FIFE_MINOR_VERSION, REQUIRED_FIFE_PATCH_VERSION)

	## +=1 this if you changed the savegame "api"
	SAVEGAMEREVISION = 74

	@staticmethod
	def string():
		return VERSION.RELEASE_NAME % VERSION.RELEASE_VERSION

## WORLD
class UNITS:
	# ./development/print_db_data.py unit
	HUKER_SHIP           = 1000001
	BUILDING_COLLECTOR   = 1000002

	FISHER_BOAT          = 1000004
	PIRATE_SHIP          = 1000005
	TRADER_SHIP          = 1000006
	ANIMAL_COLLECTOR     = 1000007
	STORAGE_COLLECTOR    = 1000008
	FIELD_COLLECTOR      = 1000009
	LUMBERJACK_COLLECTOR = 1000010
	SETTLER_COLLECTOR    = 1000011

	WILD_ANIMAL          = 1000013
	HUNTER_COLLECTOR     = 1000014
	FARM_ANIMAL_COLLECTOR= 1000015
	USABLE_FISHER_BOAT   = 1000016

	FRIGATE              = 1000020

	DISASTER_RECOVERY_COLLECTOR = 1000022
	
	SWORDSMAN            = 1000023

	# players will be spawned with an instance of this
	PLAYER_SHIP          = HUKER_SHIP

	DIFFERENCE_BUILDING_UNIT_ID = 1000000

class BUILDINGS:
	# ./development/print_db_data.py building
	WAREHOUSE        =  1
	STORAGE          =  2
	RESIDENTIAL      =  3
	MAIN_SQUARE      =  4
	PAVILION         =  5
	SIGNAL_FIRE      =  6
	WEAVER           =  7
	LUMBERJACK       =  8
	HUNTER           =  9
	SETTLER_RUIN     = 10
	FISHER           = 11
	BOAT_BUILDER     = 12
	LOOKOUT          = 13

	TRAIL            = 15

	TREE             = 17
	PASTURE          = 18
	POTATO_FIELD     = 19
	FARM             = 20
	VILLAGE_SCHOOL   = 21
	SUGARCANE_FIELD  = 22
	CLAY_DEPOSIT     = 23
	BRICKYARD        = 24
	CLAY_PIT         = 25
	DISTILLERY       = 26

	MINE             = 28
	SMELTERY         = 29
	TOOLMAKER        = 30
	CHARCOAL_BURNER  = 31
	TAVERN           = 32
	FISH_DEPOSIT     = 33
	MOUNTAIN         = 34
	SALT_PONDS       = 35
	TOBACCO_FIELD    = 36
	TOBACCONIST      = 37
	CATTLE_RUN       = 38
	PIGSTY           = 39
	HERBARY          = 40
	BUTCHERY         = 41
	DOCTOR           = 42
	GRAVEL_PATH      = 43
	WOODEN_TOWER     = 44
	FIRE_STATION     = 45
	CORN_FIELD       = 46
	WINDMILL         = 47
	BAKERY           = 48
	SPICE_FIELD      = 49
	BLENDER          = 50

	BARRACKS         = 53
	STONE_PIT        = 54
	STONEMASON       = 55

	COCOA_FIELD      = 60
	VINEYARD         = 61
	ALVEARIES        = 62
	PASTRY_SHOP      = 63

	VINTNER          = 65

	WEAPONSMITH      = 66

	EXPAND_RANGE = (WAREHOUSE, STORAGE, LOOKOUT)

	TRANSPARENCY_VALUE = 180

	class ACTION:
		# data for calculating gfx for paths.
		# think: animation contains key, if there is a path at offset value
		# you need to sort this before iterating via sorted, since order is important here.
		action_offset_dict = {
		# Direct connections
		  'a' : ( 0, -1),
		  'b' : (+1,  0),
		  'c' : ( 0, +1),
		  'd' : (-1,  0),
		# Remote connections
		  'e' : (+1, -1),
		  'f' : (+1, +1),
		  'g' : (-1, +1),
		  'h' : (-1, -1),
		}

	class BUILD:
		MAX_BUILDING_SHIP_DISTANCE = 5 # max distance ship-building when building from ship

class RES:
	# ./development/print_db_data.py res
	GOLD             =  1
	LAMB_WOOL        =  2
	TEXTILE          =  3
	BOARDS           =  4
	FOOD             =  5
	TOOLS            =  6
	BRICKS           =  7
	TREES            =  8
	GRASS            =  9
	WOOL             = 10
	FAITH            = 11
	WILDANIMALFOOD   = 12
	DEER_MEAT        = 13
	HAPPINESS        = 14
	POTATOES         = 15
	EDUCATION        = 16
	RAW_SUGAR        = 17
	SUGAR            = 18
	COMMUNITY        = 19
	RAW_CLAY         = 20
	CLAY             = 21
	LIQUOR           = 22
	CHARCOAL         = 23
	RAW_IRON         = 24
	IRON_ORE         = 25
	IRON_INGOTS      = 26
	GET_TOGETHER     = 27
	FISH             = 28
	SALT             = 29
	TOBACCO_PLANTS   = 30
	TOBACCO_LEAVES   = 31
	TOBACCO_PRODUCTS = 32
	CATTLE           = 33
	PIGS             = 34
	CATTLE_SLAUGHTER = 35
	PIGS_SLAUGHTER   = 36
	HERBS            = 37
	MEDICAL_HERBS    = 38
	ACORNS           = 39
	CANNON           = 40
	SWORD            = 41
	GRAIN            = 42
	CORN             = 43
	FLOUR            = 44
	SPICE_PLANTS     = 45
	SPICES           = 46
	CONDIMENTS       = 47
	MARBLE_DEPOSIT   = GOLD # 48
	MARBLE_TOPS      = GOLD # 49
	COAL_DEPOSIT     = GOLD # 50
	STONE_DEPOSIT    = 51
	STONE_TOPS       = 52
	COCOA_BEANS      = 53
	COCOA            = 54
	CONFECTIONERY    = 55
	CANDLES          = 56
	VINES            = 57
	GRAPES           = 58
	ALVEARIES        = 59
	HONEYCOMBS       = 60
	GOLD_DEPOSIT     = GOLD # 61
	GOLD_ORE         = GOLD # 62
	GOLD_INGOTS      = GOLD # 63
	GEM_DEPOSIT      = GOLD # 64
	ROUGH_GEMS       = GOLD # 65
	GEMS             = GOLD # 66
	SILVER_DEPOSIT   = GOLD # 67
	SILVER_ORE       = GOLD # 68
	SILVER_INGOTS    = GOLD # 69
	COFFEE_PLANTS    = GOLD # 70
	COFFEE_BEANS     = GOLD # 71
	COFFEE           = GOLD # 72
	TEA_PLANTS       = GOLD # 73
	TEA_LEAVES       = GOLD # 74
	TEA              = GOLD # 75
	FLOWER_MEADOWS   = GOLD # 76
	BLOSSOMS         = GOLD # 77
	BRINE            = GOLD # 78
	BRINE_DEPOSIT    = GOLD # 79
	WHALES           = GOLD # 80
	AMBERGRIS        = GOLD # 81
	LAMP_OIL         = GOLD # 82
	COTTON_PLANTS    = GOLD # 83
	COTTON           = GOLD # 84
	INDIGO_PLANTS    = GOLD # 85
	INDIGO           = GOLD # 86
	GARMENTS         = GOLD # 87
	PERFUME          = GOLD # 88
	HOP_PLANTS       = GOLD # 89
	HOPS             = GOLD # 90
	# 91-99 reserved for services
	REPRESENTATION   = GOLD # 92
	SOCIETY          = GOLD # 93
	FAITH_2          = GOLD # 94
	EDUCATION_2      = GOLD # 95
	HYGIENE          = GOLD # 96
	RECREATION       = GOLD # 97
	BLACKDEATH       = 98
	FIRE             = 99
	# 91-99 reserved for services

class WEAPONS:
	CANNON = RES.CANNON
	SWORD  = RES.SWORD

	DEFAULT_FIGHTING_SHIP_WEAPONS_NUM = 7

class GROUND:
	DEFAULT_LAND = (3, "straight", 45)
	SAND = (6, "straight", 45)
	SHALLOW_WATER = (1, "straight", 45)
	WATER = (0, "straight", 45)

	# sand to shallow water tiles
	COAST_SOUTH = (5, "straight", 45)
	COAST_EAST = (5, "straight", 135)
	COAST_NORTH = (5, "straight", 225)
	COAST_WEST = (5, "straight", 315)
	COAST_SOUTHWEST3 = (5, "curve_in", 135)
	COAST_NORTHWEST3 = (5, "curve_in", 225)
	COAST_NORTHEAST3 = (5, "curve_in", 315)
	COAST_SOUTHEAST3 = (5, "curve_in", 45)
	COAST_NORTHEAST1 = (5, "curve_out", 225)
	COAST_SOUTHEAST1 = (5, "curve_out", 135)
	COAST_SOUTHWEST1 = (5, "curve_out", 45)
	COAST_NORTHWEST1 = (5, "curve_out", 315)

	# grass to sand tiles
	SAND_SOUTH = (4, "straight", 45)
	SAND_EAST =  (4, "straight", 135)
	SAND_NORTH = (4, "straight", 225)
	SAND_WEST =  (4, "straight", 315)
	SAND_SOUTHWEST3 = (4, "curve_in", 135)
	SAND_NORTHWEST3 = (4, "curve_in", 225)
	SAND_NORTHEAST3 = (4, "curve_in", 315)
	SAND_SOUTHEAST3 = (4, "curve_in", 45)
	SAND_NORTHEAST1 = (4, "curve_out", 225)
	SAND_SOUTHEAST1 = (4, "curve_out", 135)
	SAND_SOUTHWEST1 = (4, "curve_out", 45)
	SAND_NORTHWEST1 = (4, "curve_out", 315)

	# shallow water to deep water tiles
	DEEP_WATER_SOUTH = (2, "straight", 45)
	DEEP_WATER_EAST =  (2, "straight", 135)
	DEEP_WATER_NORTH = (2, "straight", 225)
	DEEP_WATER_WEST =  (2, "straight", 315)
	DEEP_WATER_SOUTHWEST3 = (2, "curve_in", 135)
	DEEP_WATER_NORTHWEST3 = (2, "curve_in", 225)
	DEEP_WATER_NORTHEAST3 = (2, "curve_in", 315)
	DEEP_WATER_SOUTHEAST3 = (2, "curve_in", 45)
	DEEP_WATER_NORTHEAST1 = (2, "curve_out", 225)
	DEEP_WATER_SOUTHEAST1 = (2, "curve_out", 135)
	DEEP_WATER_SOUTHWEST1 = (2, "curve_out", 45)
	DEEP_WATER_NORTHWEST1 = (2, "curve_out", 315)

class ACTION_SETS:
	DEFAULT_ANIMATION_LENGTH = 500
	DEFAULT_WEIGHT = 10

class GAME_SPEED:
	TICKS_PER_SECOND = 16
	TICK_RATES = [int(i * TICKS_PER_SECOND)
	              for i in (0.5, 1, 2, 3, 4, 6, 8, 11, 20)]

class COLORS:
	BLACK = 9

class VIEW:
	ZOOM_MAX = 1
	ZOOM_MIN = 0.25
	ZOOM_DEFAULT = 1
	ZOOM_LEVELS_FACTOR = 0.875
	CELL_IMAGE_DIMENSIONS = (64, 32)
	ROTATION = 45.0
	TILT = -60
	AUTOSCROLL_WIDTH = 10

## The Production States available in the game sorted by importance from least
## to most important
class PRODUCTION:
	# ./development/print_db_data.py lines
	STATES = Enum('none', 'waiting_for_res', 'inventory_full', 'producing', 'paused', 'done')
	# NOTE: 'done' is only for SingleUseProductions
	# NOTE: 'none' is not used by an actual production, just for a producer
	STATISTICAL_WINDOW = 1000 # How many latest ticks are relevant for keeping track of how busy a production is

class PRODUCTIONLINES:
	HUKER = 15
	FISHING_BOAT = None # will get added later
	FRIGATE = 58
	TREES = 256812226
	WOOL = 1654557398


## GAME-RELATED, BALANCING VALUES
class GAME:
	# seconds: duration of a "month" (running costs and taxes are paid in this interval)
	INGAME_TICK_INTERVAL = 30

	WORLD_WORLDID = 0 # worldid of World object
	MAX_TICKS = None # exit after on tick MAX_TICKS (disabled by setting to None)

# Map related constants
class MAP:
	PADDING = 10 # extra usable water around the map edges
	BORDER = 30 # extra unusable water around the padding (to keep the black void at bay)

class GUI:
	CITYINFO_UPDATE_DELAY = 2 # seconds
	DEFAULT_EXCHANGE_AMOUNT = 50  # tons

# Messagewidget and Logbook
class MESSAGES:
	CUSTOM_MSG_SHOW_DELAY = 6 # delay between messages when passing more than one
	CUSTOM_MSG_VISIBLE_FOR = 90 # after this time the msg gets removed from screen
	LOGBOOK_DEFAULT_DELAY = 1 # delay between condition fulfilled and logbook popping up

# AI values read from the command line; use the values below unless overridden by the CLI or the GUI
class AI:
	HIGHLIGHT_PLANS = False # whether to show the AI players' plans on the map
	HIGHLIGHT_COMBAT = False # whether to show the AI players' combat ranges around each unit
	HUMAN_AI = False # whether the human player is controlled by the AI

class TRADER: # check resource values: ./development/print_db_data.py res
	PRICE_MODIFIER_BUY = 1.0  # buy for x times the resource value
	PRICE_MODIFIER_SELL = 1.0 # sell for x times the resource value
	TRADING_DURATION = 4 # seconds that trader stays at warehouse to simulate (un)loading

	BUSINESS_SENSE = 50 # chance in percent to be sent to a warehouse instead of random spot

	BUY_AMOUNT_MIN = 2  # amount range to buy/sell from settlement per resource
	BUY_AMOUNT_MAX = 10
	SELL_AMOUNT_MIN = 2
	SELL_AMOUNT_MAX = 10

# Taxes and Restrictions
class TIER:
	NATURE = 0
	SAILORS = 0
	PIONEERS = 1
	SETTLERS = 2
	CITIZENS = 3
	MERCHANTS = 4
	ARISTOCRATS = 5

	LOWEST = SAILORS
	HIGHEST = ARISTOCRATS
	CURRENT_MAX = CITIZENS

class SETTLER:
	TAX_SETTINGS_MIN = 0.5
	TAX_SETTINGS_MAX = 1.5
	TAX_SETTINGS_STEP = 0.1

class WILD_ANIMAL:
	HEALTH_INIT_VALUE = 50 # animals start with this value
	HEALTH_INCREASE_ON_FEEDING = 8 # health increases by this value on feeding
	HEALTH_DECREASE_ON_NO_JOB = 20 # health decreases by this value when they have no food
	HEALTH_LEVEL_TO_REPRODUCE = 75 # this level has to be reached for reproducing
	POPULATION_LIMIT = 15 # minimum number of trees per animal to allow reproducing
	FOOD_AVAILABLE_ON_START = 0.5 # probability that a tree has wild animal food in the beginning
	POPULATION_INIT_RATIO = 15 # every N-th tree gets an animal in the beginning

class COLLECTORS:
	DEFAULT_WORK_DURATION = 16 # how many ticks collectors pretend to work at target
	DEFAULT_WAIT_TICKS = 32 # how long collectors wait before again looking for a job
	DEFAULT_STORAGE_SIZE = 8
	STATISTICAL_WINDOW = 1000 # How many latest ticks are relevant for calculating how busy a collector is

class STORAGE:
	DEFAULT_STORAGE_SIZE = 30 # Our usual inventorys are 30 tons big

	# Distributing overall delimiter, if one slot is "full" with respect to
	# this value, you can't load further in any of the slots even if empty.
	SHIP_TOTAL_STORAGE = 120
	SHIP_TOTAL_SLOTS_NUMBER = 4

## ENGINE
class LAYERS:
	WATER = 0
	GROUND = 1
	FIELDS = 2
	OBJECTS = 3

	NUM = 4 # number of layers

## PATHS
# workaround, so it can be used to create paths within PATHS
if 'UH_USER_DIR' in os.environ:
	# Prefer the value from the environment. Used to override user dir when
	# running GUI tests.
	_user_dir = unicode(os.environ['UH_USER_DIR'], encoding='utf-8')
elif platform.system() != "Windows":
	_user_dir = os.path.join(os.path.expanduser('~'), '.unknown-horizons')
else:
	import ctypes.wintypes
	buf = ctypes.create_unicode_buffer(ctypes.wintypes.MAX_PATH)
	# get the My Documents folder into buf.value
	ctypes.windll.shell32.SHGetFolderPathW(0, 5, 0, 0, buf)
	my_games = os.path.join(buf.value, 'My Games')
	if not os.path.exists(my_games):
		os.makedirs(my_games)
	_user_dir = os.path.join(my_games, 'unknown-horizons')


class GFX:
	BUILDING_OUTLINE_THRESHOLD = 96
	BUILDING_OUTLINE_WIDTH = 2

	UNIT_OUTLINE_THRESHOLD = 96
	UNIT_OUTLINE_WIDTH = 2

	SHIP_OUTLINE_THRESHOLD = 96
	SHIP_OUTLINE_WIDTH = 2

	# this is modified by the game starting process.
	USE_ATLASES = False

class PATHS:
	# paths in user dir
	USER_DIR = _user_dir
	LOG_DIR = os.path.join(USER_DIR, "log")
	USER_MAPS_DIR = os.path.join(USER_DIR, "maps")
	USER_CONFIG_FILE = os.path.join(USER_DIR, "settings.xml")
	SCREENSHOT_DIR = os.path.join(USER_DIR, "screenshots")
	DEFAULT_WINDOW_ICON_PATH = os.path.join("content", "gui", "images", "logos", "uh_32.png")
	MAC_WINDOW_ICON_PATH = os.path.join("content", "gui", "icons", "Icon.icns")
	ATLAS_METADATA_PATH = os.path.join(USER_DIR, "atlas-metadata.cache")

	# paths relative to uh dir
	ACTION_SETS_DIRECTORY = os.path.join("content", "gfx")
	TILE_SETS_DIRECTORY = os.path.join("content", "gfx", "base")
	SAVEGAME_TEMPLATE = os.path.join("content", "savegame_template.sql")

	ATLAS_FILES_DIR = os.path.join("content", "gfx", "atlas")
	ATLAS_DB_PATH = os.path.join("content", "atlas.sql")
	ACTION_SETS_JSON_FILE = os.path.join("content", "actionsets.json")
	TILE_SETS_JSON_FILE = os.path.join("content", "tilesets.json")

	SETTINGS_TEMPLATE_FILE = os.path.join("content", "settings-template.xml")
	CONFIG_TEMPLATE_FILE = os.path.join("content", "settings-template.xml")


	DB_FILES = tuple(os.path.join("content", i) for i in
	                 ("game.sql", "balance.sql", "names.sql"))

	ATLAS_SOURCE_DIRECTORIES = tuple(os.path.join("content/gfx", d)
	                                 for d in (
	                                 "/base",
	                                 "/buildings",
	                                 "/misc",
	                                 "/terrain",
	                                 "/units",
	                                ))

	#voice paths
	VOICE_DIR = os.path.join("content", "audio", "voice")

class SETTINGS:
	UH_MODULE = "unknownhorizons"
	FIFE_MODULE = "FIFE"
	KEY_MODULE = "keys"
	META_MODULE = "meta"

class PLAYER:
	STATS_UPDATE_FREQUENCY = GAME_SPEED.TICKS_PER_SECOND

## SINGLEPLAYER
class SINGLEPLAYER:
	FREEZE_PROTECTION = True
	SEED = None

## MULTIPLAYER
class MULTIPLAYER:
	MAX_PLAYER_COUNT = 8

class NETWORK:
	SERVER_ADDRESS = "master.unknown-horizons.org"
	# change port to 2022 for development server updated after UH commits
	SERVER_PORT = 2002
	CLIENT_ADDRESS = None
	UPDATE_FILE_URL = "http://updates.unknown-horizons.org/current_version.php"


## TRANSLATIONS
class _LanguageNameDict(dict):
	def __getitem__(self, key):
		return self.get(key, [key])[0]

	def get_english(self, key):
		return self.get(key, [key])[1]

	def get_by_value(self, value, english=False):
		for code, (own, eng) in self.iteritems():
			if english and eng == value:
				return code
			elif not english and own == value:
				return code
		return "" # meaning default key


LANGUAGENAMES = _LanguageNameDict({
	""      : (u'System default', u''),
	"af"    : (u'Afrikaans', u'Afrikaans'),
	"bg"    : (u'Български', u'Bulgarian'),
	"ca"    : (u'Català', u'Catalan'),
	'ca@valencia' : (u'Català de València', u'Catalan (Valencia)'),
	"cs"    : (u'Čeština', u'Czech'),
	"da"    : (u'Danske', u'Danish'),
	"de"    : (u'Deutsch', u'German'),
	"en"    : (u'English', u'English'),
	"es"    : (u'Español', u'Spanish'),
	"et"    : (u'Eesti', u'Estonian'),
	"el"    : (u'Ελληνικά', u'Greek'),
	"fi"    : (u'Suomi', u'Finnish'),
	"fr"    : (u'Français', u'French'),
	"ga"    : (u'Gaeilge', u'Irish'),
	"gl"    : (u'Galego', u'Galician'),
	"hi"    : (u'मानक हिन्दी', u'Hindi'),
	"hr"    : (u'Hrvatski', u'Croatian'),
	"hu"    : (u'Magyar', u'Hungarian'),
	"id"    : (u'Bahasa Indonesia', u'Indonesian'),
	"it"    : (u'Italiano', u'Italian'),
	"ja"    : (u'日本語', u'Japanese'),
	"lt"    : (u'Lietuvių', u'Lithuanian'),
	"lv"    : (u'Latviešu', u'Latvian'),
	"ko"    : (u'한국말/조선말', u'Korean'),
	"nb"    : (u'Bokmål', u'Norwegian'),
	"nl"    : (u'Nederlands', u'Dutch'),
	"pl"    : (u'Polski', u'Polish'),
	"pt_BR" : (u'Português Br.', u'Brazilian Portuguese'),
	"pt"    : (u'Português', u'Portuguese'),
	"ro"    : (u'Română', u'Romanian'),
	"ru"    : (u'Русский', u'Russian'),
	"sl"    : (u'Slovenski', u'Slovenian'),
	"sr"    : (u'Cрпски', u'Serbian'),
	"sv"    : (u'Svenska', u'Swedish'),
	"th"    : (u'ภาษาไทย', u'Thai'),
	"tr"    : (u'Türkçe', u'Turkish'),
	"uk"    : (u'Українська', u'Ukrainian'),
	"vi"    : (u'Tiếng Việt', u'Vietnamese'),
	"zh_CN" : (u'简化字', u'Simplified Chinese'),
	"zh_TW" : (u'繁體字', u'Traditional Chinese'),
	"zu"    : (u'IsiZulu', u'Zulu'),
})

FONTDEFS = {
	# "af"
	"bg"    : 'libertine',
	# "ca"
	"ca@valencia" : 'libertine',
	"cs"    : 'libertine',
	"da"    : 'libertine',
	"de"    : 'libertine',
	"en"    : 'libertine',
	"es"    : 'libertine',
	"et"    : 'libertine',
	"el"    : 'libertine',
	"fi"    : 'libertine',
	"fr"    : 'libertine',
	"ga"    : 'libertine',
	"gl"    : 'libertine',
	# "hi"
	"hr"    : 'libertine',
	"hu"    : 'libertine',
	"id"    : 'libertine',
	"it"    : 'libertine',
	# "ja"
	"lt"    : 'libertine',
	"lv"    : 'libertine',
	# "ko"
	"nb"    : 'libertine',
	"nl"    : 'libertine',
	"pl"    : 'libertine',
	"pt_BR" : 'libertine',
	"pt"    : 'libertine',
	"ro"    : 'libertine',
	"ru"    : 'libertine',
	"sl"    : 'libertine',
	"sr"    : 'libertine',
	"sv"    : 'libertine',
	# "th"
	"tr"    : 'libertine',
	"uk"    : 'libertine',
	# "vi"
	# "zh_CN"
	"zu"    : 'libertine',
}

class HOTKEYS:
	DISPLAY_KEY = {
		'MINUS': '-',
		'PLUS': '+',
		'COMMA': ',',
		'PERIOD': '.',
		'EXCLAIM': '!',
		'AT': '@',
		'HASH': '#',
		'DOLLAR': '$',
	# XXX Fife does not recognize percent key?
	#	'PERCENT': '%',
		'CARET': '^',
		'AMPERSAND': '&',
		'ASTERISK': '*',
		'LEFTPAREN': '(',
		'RIGHTPAREN': ')',
		'UNDERSCORE': '_',
		'LEFTBRACKET': '[',
		'RIGHTBRACKET': ']',
		'SLASH': '/',
		'COLON': ':',
		'SEMICOLON': ';',
		'LESS': '<',
		'EQUALS': '=',
		'GREATER': '>',
		'QUESTION': '?',
		'BACKSLASH': '\\',
		'BACKQUOTE': '`',
		'QUOTE': "'",
		'QUOTEDBL': '"',
		'ESCAPE': 'Esc',
		'DELETE': 'Del',
		'INSERT': 'Ins',
		'PAGE_UP': 'PgUp',
		'PAGE_DOWN': 'PgDn',
		'PRINT_SCREEN': 'PrtSc',
	}

########NEW FILE########
__FILENAME__ = gui
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import horizons.globals

from horizons.constants import GROUND, VIEW
from horizons.ext.dummy import Dummy
from horizons.gui.keylisteners import IngameKeyListener, KeyConfig
from horizons.gui.modules import PauseMenu, HelpDialog, SelectSavegameDialog
from horizons.gui.mousetools import SelectionTool, TileLayingTool
from horizons.gui.tabs import TabWidget
from horizons.gui.tabs.tabinterface import TabInterface
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.messagewidget import MessageWidget
from horizons.gui.widgets.minimap import Minimap
from horizons.gui.windows import WindowManager
from horizons.messaging import ZoomChanged
from horizons.util.lastactiveplayersettlementmanager import LastActivePlayerSettlementManager
from horizons.util.living import LivingObject, livingProperty
from horizons.util.loaders.tilesetloader import TileSetLoader
from horizons.util.python.callback import Callback


class IngameGui(LivingObject):
	minimap = livingProperty()
	keylistener = livingProperty()
	message_widget = livingProperty()

	def __init__(self, session):
		self.session = session

		self.cursor = None
		self.coordinates_tooltip = None
		self.keylistener = IngameKeyListener(self.session)
		# used by NavigationTool
		LastActivePlayerSettlementManager.create_instance(self.session)

		# Mocks needed to act like the real IngameGui
		self.show_menu = Dummy
		self.hide_menu = Dummy
		# a logbook Dummy is necessary for message_widget to work
		self.logbook = Dummy

		self.mainhud = load_uh_widget('minimap.xml')
		self.mainhud.position_technique = "right+0:top+0"

		icon = self.mainhud.findChild(name="minimap")
		self.minimap = Minimap(icon,
		                       targetrenderer=horizons.globals.fife.targetrenderer,
		                       imagemanager=horizons.globals.fife.imagemanager,
		                       session=self.session,
		                       view=self.session.view)

		self.mainhud.mapEvents({
			'zoomIn': self.session.view.zoom_in,
			'zoomOut': self.session.view.zoom_out,
			'rotateRight': Callback.ChainedCallbacks(self.session.view.rotate_right, self.minimap.rotate_right),
			'rotateLeft': Callback.ChainedCallbacks(self.session.view.rotate_left, self.minimap.rotate_left),
			'gameMenuButton': self.toggle_pause,
		})

		self.mainhud.show()
		ZoomChanged.subscribe(self._update_zoom)

		# Hide unnecessary buttons in hud
		for widget in ("build", "speedUp", "speedDown", "destroy_tool", "diplomacyButton", "logbook"):
			self.mainhud.findChild(name=widget).hide()

		self.windows = WindowManager()
		self.message_widget = MessageWidget(self.session)
		self.pausemenu = PauseMenu(self.session, self, self.windows, in_editor_mode=True)
		self.help_dialog = HelpDialog(self.windows)

	def end(self):
		self.mainhud.mapEvents({
			'zoomIn': None,
			'zoomOut': None,
			'rotateRight': None,
			'rotateLeft': None,
			'gameMenuButton': None
		})
		self.mainhud.hide()
		self.mainhud = None
		self._settings_tab.hide()
		self._settings_tab = None

		self.windows.close_all()
		self.minimap = None
		self.keylistener = None
		LastActivePlayerSettlementManager().remove()
		LastActivePlayerSettlementManager.destroy_instance()
		ZoomChanged.unsubscribe(self._update_zoom)

		if self.cursor:
			self.cursor.remove()
			self.cursor.end()
			self.cursor = None

		super(IngameGui, self).end()

	def handle_selection_group(self, num, ctrl_pressed):
		# Someday, maybe cool stuff will be possible here.
		# That day is not today, I'm afraid.
		pass

	def toggle_pause(self):
		self.windows.toggle(self.pausemenu)

	def toggle_help(self):
		self.windows.toggle(self.help_dialog)

	def load(self, savegame):
		self.minimap.draw()

		self.cursor = SelectionTool(self.session)

	def setup(self):
		"""Called after the world editor was initialized."""
		self._settings_tab = TabWidget(self, tabs=[SettingsTab(self.session.world_editor, self)])
		self._settings_tab.show()

	def minimap_to_front(self):
		"""Make sure the full right top gui is visible and not covered by some dialog"""
		self.mainhud.hide()
		self.mainhud.show()

	def show_save_map_dialog(self):
		"""Shows a dialog where the user can set the name of the saved map."""
		window = SelectSavegameDialog('editor-save', self.windows)
		savegamename = self.windows.open(window)
		if savegamename is None:
			return False # user aborted dialog
		success = self.session.save(savegamename)
		if success:
				self.message_widget.add('SAVED_GAME')

	def on_escape(self):
		pass

	def on_key_press(self, action, evt):
		_Actions = KeyConfig._Actions
		if action == _Actions.QUICKSAVE:
			self.session.quicksave()
		if action == _Actions.ESCAPE:
			if self.windows.visible:
				self.windows.on_escape()
			elif hasattr(self.cursor, 'on_escape'):
				self.cursor.on_escape()
			else:
				self.toggle_pause()
		elif action == _Actions.HELP:
			self.toggle_help()
		else:
			return False
		return True

	def set_cursor(self, which='default', *args, **kwargs):
		"""Sets the mousetool (i.e. cursor).
		This is done here for encapsulation and control over destructors.
		Further arguments are passed to the mouse tool constructor.
		"""
		self.cursor.remove()
		klass = {
			'default': SelectionTool,
			'tile_layer': TileLayingTool
		}[which]
		self.cursor = klass(self.session, *args, **kwargs)

	def _update_zoom(self, message):
		"""Enable/disable zoom buttons"""
		in_icon = self.mainhud.findChild(name='zoomIn')
		out_icon = self.mainhud.findChild(name='zoomOut')
		if message.zoom == VIEW.ZOOM_MIN:
			out_icon.set_inactive()
		else:
			out_icon.set_active()
		if message.zoom == VIEW.ZOOM_MAX:
			in_icon.set_inactive()
		else:
			in_icon.set_active()


class SettingsTab(TabInterface):
	widget = 'editor_settings.xml'

	def __init__(self, world_editor, ingame_gui):
		super(SettingsTab, self).__init__(widget=self.widget)

		self._world_editor = world_editor

		# Brush size
		for i in range(1, 6):
			b = self.widget.findChild(name='size_%d' % i)
			b.capture(Callback(self._change_brush_size, i))

		# Activate radio button for default brush size
		self._change_brush_size(self._world_editor.brush_size)

		# Tile selection
		for tile_type in ('default_land', 'sand', 'shallow_water', 'water'):
			image = self.widget.findChild(name=tile_type)
			tile = getattr(GROUND, tile_type.upper())
			image.up_image = self._get_tile_image(tile)
			image.size = image.min_size = image.max_size = (64, 32)
			image.capture(Callback(ingame_gui.set_cursor, 'tile_layer', tile))

	def _get_tile_image(self, tile):
		# TODO TileLayingTool does almost the same thing, perhaps put this in a better place
		tile_sets = TileSetLoader.get_sets()

		ground_id, action_id, rotation = tile
		set_id = horizons.globals.db.get_random_tile_set(ground_id)
		return tile_sets[set_id][action_id][rotation].keys()[0]

	def _change_brush_size(self, size):
		"""Change the brush size and update the gui."""
		images = {
		  'box_highlighted': 'content/gui/icons/ship/smallbutton_a.png',
		  'box': 'content/gui/icons/ship/smallbutton.png',
		}

		b = self.widget.findChild(name='size_%d' % self._world_editor.brush_size)
		b.up_image = images['box']

		self._world_editor.brush_size = size
		b = self.widget.findChild(name='size_%d' % self._world_editor.brush_size)
		b.up_image = images['box_highlighted']

########NEW FILE########
__FILENAME__ = intermediatemap
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.constants import GROUND

DEEP_WATER = 0
SHALLOW_WATER = 1
SAND = 2
GRASS = 3

class IntermediateMap(object):
	
	def __init__(self, world):
		self.world = world
		self.session = world.session
		self._init_map()

	def _get_tile_repr(self, coords):
		if coords not in self.world.full_map:
			return 0

		tile = self.world.full_map[coords]
		if tile.id <= 0:
			return DEEP_WATER
		elif tile.id == 1:
			return SHALLOW_WATER
		elif tile.id == 6:
			return SAND
		elif tile.id == 3:
			return GRASS
		else:
			offset = 0 if tile.id == 2 else (1 if tile.id == 5 else 2)
			rotation = tile.rotation // 90
			if tile.shape == 'straight':
				return offset + (1, 0, 0, 1)[rotation] # 2 low, 2 high
			elif tile.shape == 'curve_in':
				return offset + (1, 1, 0, 1)[rotation] # 1 low, 3 high
			else:
				return offset + (1, 0, 0, 0)[rotation] # 3 low, 1 high

	def _init_map(self):
		self._map = {}
		width = self.world.max_x - self.world.min_x + 1
		height = self.world.max_y - self.world.min_y + 1
		for y in xrange(height + 2):
			orig_y = y + self.world.min_y - 1
			for x in xrange(width + 2):
				orig_x = x + self.world.min_x - 1
				self._map[(x, y)] = self._get_tile_repr((orig_x, orig_y))

		self.max_x = width - 1
		self.max_y = height - 1

	def _get_intermediate_coords(self, coords):
		return (coords[0] - self.world.min_x, coords[1] - self.world.min_y)

	def distance_from_edge(self, (x, y)):
		return min(min(x, self.max_x - x), min(y, self.max_y - y))

	def _update_intermediate_coords(self, coords, new_type):
		if self._map[coords] == new_type:
			return
		self._map[coords] = min(new_type, self.distance_from_edge(coords))

	def _fix_map(self, coords_list, new_type):
		changes = True
		while changes:
			changes = False
			for x, y in coords_list:
				top_left = (x, y)
				if top_left not in self._map:
					continue
				bottom_right = (x + 1, y + 1)
				if bottom_right not in self._map:
					continue
				if self._map[top_left] != self._map[bottom_right]:
					continue
				bottom_left = (x, y + 1)
				top_right = (x + 1, y)
				if self._map[bottom_left] != self._map[top_right]:
					continue
				diff = self._map[top_left] - self._map[top_right]
				if diff == 0:
					continue

				lower_corner = top_right if diff == 1 else top_left
				higher_corner = top_left if diff == 1 else top_right
				mi = self._map[lower_corner]
				if new_type <= mi:
					self._set_tiles([higher_corner], mi)
				else:
					self._set_tiles([lower_corner], mi + 1)
				changes = True

	def set_south_east_corner(self, raw_coords_list, tile_details):
		new_type = tile_details[0] if tile_details[0] != 6 else 2
		coords_list = []
		for coords in raw_coords_list:
			if coords not in self.world.fake_tile_map:
				continue

			coords2 = self._get_intermediate_coords(coords)
			assert coords2 in self._map
			if self._map[coords2] != new_type:
				coords_list.append(coords2)

		if coords_list:
			self._set_tiles(coords_list, new_type)

	def _get_surrounding_coords(self, current_coords_list):
		all_neighbors = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
		current_coords_set = set(current_coords_list)
		result = set()
		for x, y in current_coords_list:
			for dx, dy in all_neighbors:
				coords2 = (x + dx, y + dy)
				if coords2 in self._map and coords2 not in current_coords_set:
					result.add(coords2)
		return sorted(result)

	def _set_tiles(self, initial_coords_list, new_type):
		last_coords_list = []
		for coords in initial_coords_list:
			last_coords_list.append(coords)
			self._update_intermediate_coords(coords, new_type)

		for _ in xrange(3):
			surrounding_coords_list = self._get_surrounding_coords(last_coords_list)
			for coords2 in surrounding_coords_list:
				if coords2 not in self._map:
					continue

				cur_type = self._map[coords2]
				best_new_type = cur_type
				best_dist = 10
				for new_type2 in xrange(4):
					if best_dist <= abs(new_type2 - cur_type):
						continue

					suitable = True
					for updated_coords in last_coords_list:
						if abs(updated_coords[0] - coords2[0]) > 1 or abs(updated_coords[1] - coords2[1]) > 1:
							continue
						if abs(self._map[updated_coords] - new_type2) > 1:
							suitable = False
							break
					if not suitable:
						continue

					best_new_type = new_type2
					best_dist = abs(new_type2 - cur_type)
				self._update_intermediate_coords(coords2, best_new_type)
				last_coords_list.append(coords2)

		self._fix_map(last_coords_list, new_type)
		for coords in last_coords_list:
			self._update_tile(*coords)

	def _update_tile(self, x, y):
		if (x, y) not in self._map:
			return
		if (x + 1, y + 1) not in self._map:
			return

		data = []
		for dy in xrange(2):
			for dx in xrange(2):
				data.append(self._map[(x + dx, y + dy)])
		coords = (x + self.world.min_x, y + self.world.min_y)

		minimum = min(data)
		for i in xrange(4):
			data[i] -= minimum

		if max(data) == 0:
			ground_class = {
				DEEP_WATER: GROUND.WATER,
				SHALLOW_WATER: GROUND.SHALLOW_WATER,
				SAND: GROUND.SAND,
				GRASS: GROUND.DEFAULT_LAND,
			}[minimum]
			self.session.world_editor.set_tile(coords, ground_class)
		else:
			assert max(data) == 1, 'This should never happen'
			tile_type = 2 if minimum == 0 else (5 if minimum == 1 else 4)
			tile_def = {
				(0, 1, 0, 1): (tile_type, 'straight', 45),
				(1, 1, 0, 0): (tile_type, 'straight', 135),
				(1, 0, 1, 0): (tile_type, 'straight', 225),
				(0, 0, 1, 1): (tile_type, 'straight', 315),
				(0, 1, 1, 1): (tile_type, 'curve_in', 45),
				(1, 1, 0, 1): (tile_type, 'curve_in', 135),
				(1, 1, 1, 0): (tile_type, 'curve_in', 225),
				(1, 0, 1, 1): (tile_type, 'curve_in', 315),
				(0, 0, 0, 1): (tile_type, 'curve_out', 45),
				(0, 1, 0, 0): (tile_type, 'curve_out', 135),
				(1, 0, 0, 0): (tile_type, 'curve_out', 225),
				(0, 0, 1, 0): (tile_type, 'curve_out', 315),
			}[tuple(data)]
			self.session.world_editor.set_tile(coords, tile_def)

	def __str__(self):
		res = ''
		width = self.world.max_x - self.world.min_x + 1
		height = self.world.max_y - self.world.min_y + 1
		for y in xrange(height + 2):
			for x in xrange(width + 2):
				res += str(self._map[(x, y)])
			res += '\n'
		return res

########NEW FILE########
__FILENAME__ = session
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import random

from horizons.constants import PATHS
from horizons.editor.gui import IngameGui
from horizons.editor.worldeditor import WorldEditor
from horizons.session import Session
from horizons.manager import SPManager
from horizons.timer import Timer


class EditorSession(Session):

	def __init__(self, *args, **kwargs):
		kwargs['ingame_gui_class'] = IngameGui
		super(EditorSession, self).__init__(*args, **kwargs)
		self.world_editor = None

	def create_manager(self):
		return SPManager(self)

	def create_rng(self, seed=None):
		return random.Random()

	def create_timer(self):
		return Timer()

	def load(self, *args, **kwargs):
		super(EditorSession, self).load(*args, **kwargs)
		self.world_editor = WorldEditor(self.world)
		self.ingame_gui.setup()
		# editor "games" start right away
		self.start()

	def autosave(self):
		"""Called automatically in an interval"""
		self.log.debug("Session: autosaving map")
		success = self.world_editor.save_map(PATHS.USER_MAPS_DIR, 'autosave')
		if success:
			self.ingame_gui.message_widget.add('AUTOSAVE')

	def quicksave(self):
		"""Called when user presses the quicksave hotkey"""
		self.log.debug("Session: quicksaving map")
		success = self.world_editor.save_map(PATHS.USER_MAPS_DIR, 'quicksave')
		if success:
			self.ingame_gui.message_widget.add('QUICKSAVE')
		else:
			headline = _("Failed to quicksave.")
			descr = _("An error happened during quicksave.") + u"\n" + _("Your map has not been saved.")
			advice = _("If this error happens again, please contact the development team: "
				   "{website}").format(website="http://unknown-horizons.org/support/")
			self.ingame_gui.open_error_popup(headline, descr, advice)

	def save(self, savegamename):
		success = self.world_editor.save_map(PATHS.USER_MAPS_DIR, savegamename)
		return success

########NEW FILE########
__FILENAME__ = worldeditor
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os
import os.path
import sqlite3
import logging

from collections import deque

from horizons.command.unit import RemoveUnit
from horizons.editor.intermediatemap import IntermediateMap
from horizons.entities import Entities
from horizons.gui.widgets.minimap import Minimap
from horizons.scheduler import Scheduler
from horizons.util.dbreader import DbReader
from horizons.util.python.callback import Callback

class WorldEditor(object):
	def __init__(self, world):
		super(WorldEditor, self).__init__()
		self.world = world
		self.session = world.session
		self.intermediate_map = IntermediateMap(world)
		self._remove_unnecessary_objects()
		self._center_view()

		self.brush_size = 1

		self._tile_delete_set = set()

		self.log = logging.getLogger("gui")

	def _remove_unnecessary_objects(self):
		# Delete all ships.
		for ship in (ship for ship in self.world.ships):
			RemoveUnit(ship).execute(self.session)

	def _center_view(self):
		min_x = min(zip(*self.world.full_map.keys())[0])
		max_x = max(zip(*self.world.full_map.keys())[0])
		min_y = min(zip(*self.world.full_map.keys())[1])
		max_y = max(zip(*self.world.full_map.keys())[1])
		self.session.view.center((min_x + max_x) // 2, (min_y + max_y) // 2)

	def _iter_islands(self):
		ground = {}
		for coords, tile in self.world.full_map.iteritems():
			if tile.id <= 0:
				continue
			ground[coords] = None

		moves = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]

		n = 0
		for coords in sorted(ground.iterkeys()):
			if ground[coords] is not None:
				continue

			coords_list = [coords]
			ground[coords] = n
			queue = deque([coords])
			while queue:
				x, y = queue.popleft()
				for dx, dy in moves:
					coords2 = (x + dx, y + dy)
					if coords2 in ground and ground[coords2] is None:
						ground[coords2] = n
						queue.append(coords2)
						coords_list.append(coords2)
			yield (n, coords_list)
			n += 1

	def save_map(self, path, prefix):
		map_file = os.path.join(path, prefix + '.sqlite')
		if os.path.exists(map_file):
			os.unlink(map_file) # the process relies on having an empty file

		db = DbReader(map_file)
		with open('content/map-template.sql') as map_template:
			db.execute_script(map_template.read())

		save_successful = True
		try:
			db('BEGIN')
			for island_id, coords_list in self._iter_islands():
				for x, y in coords_list:
					tile = self.world.full_map[(x, y)]
					db('INSERT INTO ground VALUES(?, ?, ?, ?, ?, ?)', island_id, x, y, tile.id, tile.shape, tile.rotation + 45)
			db('COMMIT')
		except sqlite3.Error as e:
			self.log.debug('Error: {error}'.format(error=e.args[0]))
			save_successful = False
		finally:
			db.close()

		return save_successful

	def _delete_tile_instance(self, old_tile):
		self._tile_delete_set.remove(old_tile)
		instance = old_tile._instance
		layer = instance.getLocation().getLayer()
		layer.deleteInstance(instance)
		old_tile._instance = None

	def set_tile(self, coords, tile_details):
		if coords not in self.world.full_map:
			return

		old_tile = self.world.full_map[coords]
		if old_tile and old_tile.id != -1 and old_tile._instance and old_tile not in self._tile_delete_set:
			if (old_tile.id, old_tile.shape, old_tile.rotation + 45) == tile_details:
				return
			self._tile_delete_set.add(old_tile)
			Scheduler().add_new_object(Callback(self._delete_tile_instance, old_tile), self, run_in=0)

		(ground_id, shape, rotation) = tile_details
		if ground_id != 0:
			ground = Entities.grounds['%d-%s' % (ground_id, shape)](self.session, *coords)
			ground.act(rotation)
			self.world.full_map[coords] = ground
		else:
			self.world.full_map[coords] = self.world.fake_tile_map[coords]
		Minimap.update(coords)

		# update cam, that's necessary because of the static layer WATER
		self.session.view.cam.refresh()

########NEW FILE########
__FILENAME__ = engine
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import locale
import logging

from fife import fife
from fife.extensions import pychan, fifelog

from horizons.constants import LANGUAGENAMES, PATHS, SETTINGS
from horizons.engine.pychan_util import init_pychan
from horizons.engine.settings import Settings
from horizons.engine.sound import Sound
from horizons.util.loaders.sqliteanimationloader import SQLiteAnimationLoader
from horizons.util.loaders.sqliteatlasloader import SQLiteAtlasLoader


class Fife(object):
	"""
	Basic initiation of engine. Followed later by init().
	"""
	log = logging.getLogger('engine.engine')

	def __init__(self):
		self.pump = []

		self._setting = Settings(PATHS.USER_CONFIG_FILE, PATHS.SETTINGS_TEMPLATE_FILE)
		self.engine = fife.Engine()
		self.engine_settings = self.engine.getSettings()

		self.init_logging()
		self.load_settings()

		self.pychan = pychan

		self.quit_requested = False
		self.break_requested = False
		self.return_values = None
		self._got_inited = False

	def load_settings(self):
		"""
		Load the settings from a python file and load them into the engine.
		Called in the ApplicationBase constructor.
		"""
		# get finalSetting (from the xml file, or if absent the default value)
		self._finalSetting = self._setting.get_module_settings("FIFE")

		self.engine_settings = self.engine.getSettings()

		self.engine_settings.setDefaultFontPath(self._finalSetting['Font'])
		self.engine_settings.setBitsPerPixel(self._finalSetting['BitsPerPixel'])
		self.engine_settings.setInitialVolume(self._finalSetting['InitialVolume'])
		self.engine_settings.setSDLRemoveFakeAlpha(self._finalSetting['SDLRemoveFakeAlpha'])
		self.engine_settings.setGLCompressImages(self._finalSetting['GLCompressImages'])
		self.engine_settings.setGLUseFramebuffer(self._finalSetting['GLUseFramebuffer'])
		self.engine_settings.setGLUseNPOT(self._finalSetting['GLUseNPOT'])

		# introduced in fife 0.4.0
		if self.getVersion >= (0,4,0):
			self.engine_settings.setGLUseMonochrome(self._finalSetting['GLUseMonochrome'])
			self.engine_settings.setGLUseMipmapping(self._finalSetting['GLUseMipmapping'])
			if self._finalSetting['GLTextureFiltering'] == 'None':
				self.engine_settings.setGLTextureFiltering(fife.TEXTURE_FILTER_NONE)
			elif self._finalSetting['GLTextureFiltering'] == 'Bilinear':
				self.engine_settings.setGLTextureFiltering(fife.TEXTURE_FILTER_BILINEAR)
			elif self._finalSetting['GLTextureFiltering'] == 'Trilinear':
				self.engine_settings.setGLTextureFiltering(fife.TEXTURE_FILTER_TRILINEAR)
			elif self._finalSetting['GLTextureFiltering'] == 'Anisotropic':
				self.engine_settings.setGLTextureFiltering(fife.TEXTURE_FILTER_ANISOTROPIC)
			self.engine_settings.setGLUseDepthBuffer(self._finalSetting['GLUseDepthBuffer'])
			self.engine_settings.setGLAlphaTestValue(self._finalSetting['GLAlphaTestValue'])

		(width, height) = self._finalSetting['ScreenResolution'].split('x')
		self.engine_settings.setScreenWidth(int(width))
		self.engine_settings.setScreenHeight(int(height))
		self.engine_settings.setRenderBackend(self._finalSetting['RenderBackend'])
		self.engine_settings.setFullScreen(self._finalSetting['FullScreen'])
		self.engine_settings.setLightingModel(self._finalSetting['Lighting'])

		try:
			self.engine_settings.setColorKeyEnabled(self._finalSetting['ColorKeyEnabled'])
		except:
			pass

		try:
			self.engine_settings.setColorKey(self._finalSetting['ColorKey'][0],self._finalSetting['ColorKey'][1],self._finalSetting['ColorKey'][2])
		except:
			pass

		try:
			self.engine_settings.setWindowTitle(self._finalSetting['WindowTitle'])
			self.engine_settings.setWindowIcon(self._finalSetting['WindowIcon'])
		except:
			pass

		try:
			self.engine_settings.setFrameLimitEnabled(self._finalSetting['FrameLimitEnabled'])
			self.engine_settings.setFrameLimit(self._finalSetting['FrameLimit'])
		except:
			pass

		try:
			self.engine_settings.setMouseSensitivity(self._finalSetting['MouseSensitivity'])
		except:
			pass

		try:
			self.engine_settings.setMouseAccelerationEnabled(self._finalSetting['MouseAcceleration'])
		except:
			pass

	def init_logging(self):
		"""Initialize the LogManager."""

		# If desired, log to the console and/or the log file.
		log_to_prompt = self._setting.get(SETTINGS.FIFE_MODULE, "LogToPrompt", False)
		log_to_file = self._setting.get(SETTINGS.FIFE_MODULE, "LogToFile", False)
		self._log = fifelog.LogManager(self.engine, log_to_prompt, log_to_file)

		log_level = self._setting.get(SETTINGS.FIFE_MODULE, "LogLevelFilter",
		                              fife.LogManager.LEVEL_DEBUG)
		self._log.setLevelFilter(log_level)

		logmodules = self._setting.get(SETTINGS.FIFE_MODULE, "LogModules", ["controller"])
		if logmodules:
			self._log.setVisibleModules(*logmodules)

	def init(self):
		"""Second initialization stage of engine"""
		self.engine.init()

		# Init stuff.
		self.eventmanager = self.engine.getEventManager()
		self.sound = Sound(self)
		self.imagemanager = self.engine.getImageManager()
		self.targetrenderer = self.engine.getTargetRenderer()
		self.animationloader = None

		# Set game cursor.
		self.cursor = self.engine.getCursor()
		cursor_images = {
			'default':   'content/gui/images/cursors/cursor.png',
			'tearing':   'content/gui/images/cursors/cursor_tear.png',
			'attacking': 'content/gui/images/cursors/cursor_attack.png',
			'pipette':   'content/gui/images/cursors/cursor_pipette.png',
			'rename':    'content/gui/images/cursors/cursor_rename.png',
		}
		self.cursor_images = dict( (k, self.imagemanager.load(v)) for k, v in  cursor_images.iteritems() )
		self.cursor.set(self.cursor_images['default'])

		# Init pychan.
		# Enabling pychan's debug mode may have performance impacts.
		# Because of this, the default PychanDebug value is False.
		debug_pychan = self.get_fife_setting('PychanDebug')
		self.pychan.init(self.engine, debug_pychan)

		init_pychan()
		self._setting.apply()

		self._got_inited = True

	def init_animation_loader(self, use_atlases):
		# this method should not be called from init to catch any bugs caused by the loader changing after it.
		self.use_atlases = use_atlases
		if self.use_atlases:
			self.animationloader = SQLiteAtlasLoader()
		else:
			self.animationloader = SQLiteAnimationLoader()

	def set_cursor_image(self, which="default"):
		"""Sets a certain cursor image.
		See definition of cursor_images for reference."""
		self.cursor.set(self.cursor_images[which])

	def get_fife_setting(self, settingname):
		return self._setting.get(SETTINGS.FIFE_MODULE, settingname)

	def set_fife_setting(self, settingname, value):
		"""Probably saves setting in memory. Call save_settings() later"""
		return self._setting.set(SETTINGS.FIFE_MODULE, settingname, value)

	def get_uh_setting(self, settingname):
		return self._setting.get(SETTINGS.UH_MODULE, settingname)

	def set_uh_setting(self, settingname, value):
		"""Probably saves setting in memory. Call save_settings() later"""
		self._setting.set(SETTINGS.UH_MODULE, settingname, value)

	def get_hotkey_settings(self):
		return self._setting.get_module_settings(SETTINGS.KEY_MODULE)

	def get_keys_for_action(self, action, default=False):
		"""Returns list of current hotkeys for *action* or its default hotkeys."""
		if default:
			keys = self._setting.get_module_template_settings(SETTINGS.KEY_MODULE).get(action)
		else:
			keys = self._setting.get(SETTINGS.KEY_MODULE, action)
		return keys

	def set_key_for_action(self, action, newkey):
		"""Replaces all existing hotkeys for *action* with *newkey*."""
		self._setting.set(SETTINGS.KEY_MODULE, action, newkey)

	def add_key_for_action(self, action, addkey):
		"""Adds hotkey *addkey* to list of hotkeys for action *action*."""
		old_keys = self._setting.get(SETTINGS.KEY_MODULE, action, [])
		new_keys = set(old_keys + [addkey])
		self.set_key_for_action(action, list(new_keys))

	def remove_key_for_action(self, action, remkey):
		"""Removes hotkey *remkey* from list of hotkeys for action *action*."""
		old_keys = self._setting.get(SETTINGS.KEY_MODULE, action, [])
		if remkey in old_keys:
				old_keys.remove(remkey)
		if len(old_keys) == 0:
				print 'Cannot have no binding for action'
				return
		self.set_key_for_action(action, old_keys)

	def replace_key_for_action(self, action, oldkey, newkey):
		"""Replaces key *oldkey* with key *newkey* for action *action*"""
		old_keys = self._setting.get(SETTINGS.KEY_MODULE, action, [])
		if not oldkey in old_keys:
			return
		index = old_keys.index(oldkey)
		old_keys[index] = newkey
		self.set_key_for_action(action, old_keys)

	def save_settings(self):
		self._setting.save()

	def play_sound(self, emitter, soundfile):
		"""Plays a soundfile on the given emitter.
		@param emitter: string with the emitters name in horizons.globals.fife.sound.emitter that is to play the  sound
		@param soundfile: string containing the path to the soundfile"""
		self.sound.play_sound(emitter, soundfile)

	def get_locale(self):
		langname = self.get_uh_setting('Language')
		locale_code = LANGUAGENAMES.get_by_value(langname)
		if not langname == 'System default':
				return locale_code
		try:
			default_locale, default_encoding = locale.getdefaultlocale()
			return default_locale.split('_')[0]
		except (ValueError, AttributeError):
			# OS X sometimes returns 'UTF-8' as locale, which is a ValueError.
			# If no locale is set at all, the split will fail, which is an AttributeError.
			# Use 'EN' as fallback in both cases since we cannot reasonably detect the locale.
			return "en"

	def run(self):
		assert self._got_inited

		self.engine.initializePumping()
		self.loop()
		self.engine.finalizePumping()
		self.__kill_engine()

	def loop(self):
		while not self.quit_requested:
			try:
				self.engine.pump()
			except fife.Exception as e:
				print e.getMessage()
				break
			for f in self.pump:
				f()
			if self.break_requested:
				self.break_requested = False
				return self.return_values

	def __kill_engine(self):
		"""Called when the engine is quit"""
		# A hack to get the system cursor back:
		self.cursor.set(fife.CURSOR_NATIVE)
		self.engine.destroy()

	def breakLoop(self, returnValue=None):
		self.return_values = returnValue
		self.break_requested = True

	def quit(self):
		"""Quits the engine."""
		self.quit_requested = True

	@classmethod
	def getVersion(cls):
		"""Returns a tuple (Major, Minor, Patch) version of the current running Fife."""
		try:
			return (fife.getMajor(), fife.getMinor(), fife.getPatch())
		except AttributeError:
			return (0, 0, 0)

########NEW FILE########
__FILENAME__ = generate_atlases
#!/usr/bin/env python2

# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import glob
import json
import logging
import math
import multiprocessing
import os
import os.path
import sys
import traceback

try:
	import cPickle as pickle
except:
	import pickle

# add paths for Mac Os X app container (Unknown Horizons.app)
app_python_lib_path = os.path.join(os.getcwd(), 'lib', 'python2.7')
if os.path.exists(app_python_lib_path):
	# horizons path: Unknown Horizons.app/Contents/Resources/lib/python2.7/horizons
	sys.path.append(app_python_lib_path)
	# PIL path: Unknown Horizons.app/Contents/Resources/lib/python2.7/lib-dynload/PIL
	sys.path.append(os.path.join(app_python_lib_path, 'lib-dynload'))

try:
	from PIL import Image
except ImportError:
	# Logging is not set up at this point.
	print('The Python Imaging Library (PIL / Pillow) package'
	      ' is needed to run the atlas generator.')
	sys.exit(1)

# make sure os.path.getmtime returns ints
os.stat_float_times(False)

# make this script work both when started inside development and in the uh root dir
if not os.path.exists('content'):
	os.chdir('..')
assert os.path.exists('content'), 'Content dir not found.'

sys.path.append('.')
from run_uh import init_environment
init_environment(False)

class DummyFife:
	use_atlases = False
import horizons.globals
horizons.globals.fife = DummyFife()

from horizons.constants import PATHS
from horizons.util.dbreader import DbReader
from horizons.util.loaders.actionsetloader import ActionSetLoader
from horizons.util.loaders.tilesetloader import TileSetLoader


class AtlasEntry(object):
	def __init__(self, x, y, width, height, last_modified):
		self.x = x
		self.y = y
		self.width = width
		self.height = height
		self.last_modified = last_modified

class AtlasBook(object):
	log = logging.getLogger("generate_atlases")

	def __init__(self, id, max_size):
		self.id = id
		self.path = os.path.join(PATHS.ATLAS_FILES_DIR, '%03d.png' % id)
		self.max_size = max_size
		self._clear()

	def _clear(self):
		self.location = {}
		self.cur_x = 0
		self.cur_y = 0
		self.cur_h = 0

	def add(self, w, h, path):
		"""Return true if and only if the image was added."""
		if self.cur_x + w <= self.max_size and self.cur_y + h <= self.max_size:
			# add to the end of the current row
			self.location[path] = AtlasEntry(self.cur_x, self.cur_y, w, h, os.path.getmtime(path))
			self.cur_x += w
			self.cur_h = max(self.cur_h, h)
			return True

		if w <= self.max_size and self.cur_y + self.cur_h + h <= self.max_size:
			# add to the beginning of the next row
			self.cur_x = w
			self.cur_y += self.cur_h
			self.cur_h = h
			self.location[path] = AtlasEntry(0, self.cur_y, w, h, os.path.getmtime(path))
			return True

		# unable to fit in the given space with the current algorithm
		return False

	def save(self):
		"""Write the entire image to a file with the given path."""
		if not os.path.exists(PATHS.ATLAS_FILES_DIR):
			# Make sure atlas directory is available
			os.mkdir(PATHS.ATLAS_FILES_DIR)

		im = Image.new('RGBA', (self.max_size, self.max_size), (255, 0, 255, 255))

		# place the sub-images in the right places
		for path, entry in self.location.iteritems():
			with open(path, 'rb') as png_file:
				sub_image = Image.open(png_file)
				im.paste(sub_image, (entry.x, entry.y))

		# write the entire image to the file
		with open(self.path, 'wb') as out_file:
			im.save(out_file, 'png')


def save_atlas_book(book):
	book.save()


class ImageSetManager(object):
	def __init__(self, initial_data, path):
		self._data = {}
		self._path = path
		self._initial_data = initial_data

		self.files = []
		for set_id in initial_data:
			for action_id in initial_data[set_id]:
				for rotation in sorted(initial_data[set_id][action_id]):
					for path in sorted(initial_data[set_id][action_id][rotation]):
						self.files.append(path)

	def _add_entry(self, set_id, action_id, rotation, path, row):
		if set_id not in self._data:
			self._data[set_id] = {}
		if action_id not in self._data[set_id]:
			self._data[set_id][action_id] = {}
		if rotation not in self._data[set_id][action_id]:
			self._data[set_id][action_id][rotation] = {}
		self._data[set_id][action_id][rotation][path.replace(os.sep, '/')] = row

	def save(self, generator):
		for set_id in self._initial_data:
			for action_id in self._initial_data[set_id]:
				for rotation in sorted(self._initial_data[set_id][action_id]):
					for path in sorted(self._initial_data[set_id][action_id][rotation]):
						book = generator.atlas_book_lookup[path]
						book_entry = book.location[path]

						row = []
						row.append(self._initial_data[set_id][action_id][rotation][path])
						row.append(book.id)
						row.append(book_entry.x)
						row.append(book_entry.y)
						row.append(book_entry.width)
						row.append(book_entry.height)
						self._add_entry(set_id, action_id, rotation, path, row)

		with open(self._path, 'wb') as json_file:
			json.dump(self._data, json_file, indent=1)


class AtlasGenerator(object):
	log = logging.getLogger("generate_atlases")
	# increment this when the structure of the atlases changes
	current_version = 1

	def __init__(self, max_size):
		self.version = self.current_version
		self.max_size = max_size
		self.books = []
		self.num_books = 0
		self.atlas_book_lookup = {}

	def _init_sets(self):
		self.sets = []
		self.sets.append(ImageSetManager(TileSetLoader.get_sets(), PATHS.TILE_SETS_JSON_FILE))
		self.sets.append(ImageSetManager(ActionSetLoader.get_sets(), PATHS.ACTION_SETS_JSON_FILE))

	def _save_sets(self):
		for set in self.sets:
			set.save(self)

	@classmethod
	def _save_books(cls, books):
		processes = max(1, min(len(books), multiprocessing.cpu_count() - 1))
		pool = multiprocessing.Pool(processes=processes)
		for book in books:
			pool.apply_async(save_atlas_book, [book])
		pool.close()
		pool.join()

	def save(self):
		with open(PATHS.ATLAS_DB_PATH, 'wb') as atlas_db_file:
			atlas_db_file.write("CREATE TABLE atlas('atlas_id' INTEGER NOT NULL PRIMARY KEY, 'atlas_path' TEXT NOT NULL);\n")
			for book in self.books:
				atlas_db_file.write("INSERT INTO atlas VALUES(%d, '%s');\n" % (book.id, book.path))

		self._save_sets()
		self._save_books(self.books)
		self._save_metadata()

	def _add_atlas_book(self):
		self.books.append(AtlasBook(len(self.books), self.max_size))

	def _add_image(self, w, h, path):
		if not self.books:
			self._add_atlas_book()

		if not self.books[-1].add(w, h, path):
			self._add_atlas_book()
			assert self.books[-1].add(w, h, path)

		self.atlas_book_lookup[path] = self.books[-1]

	@classmethod
	def _get_dimensions(cls, path):
		with open(path, 'rb') as png_file:
			return Image.open(png_file).size

	def _get_paths(self):
		paths = []
		for set in self.sets:
			for path in set.files:
				paths.append(path)
		return paths

	def recreate(self):
		print 'Recreating all atlases'

		self._init_sets()
		paths = self._get_paths()
		data = []
		for path in paths:
			w, h = self._get_dimensions(path)
			data.append((w * h, h, w, path))

		assert data, 'No files found.'
		assert (data[0][1] <= self.max_size and data[0][2] <= self.max_size), 'Image too large: ' + str(data[0][1:])

		for _, h, w, path in data:
			self._add_image(w, h, path)
		self.save()

	def _update_selected_books(self, update_books):
		print 'Updating some of the atlases:'
		for book in sorted(update_books, key=lambda book: int(book.id)):
			print book.path
		print

		self._save_sets()
		self._save_books(update_books)

	def update(self):
		self._init_sets()
		paths = self._get_paths()

		# if the sizes don't match then something has been deleted or added
		recreate_all = False
		if len(set(paths)) != len(self.atlas_book_lookup):
			recreate_all = True
			self.log.info("The old number of images (%d) doesn't match the new (%d)",
			              len(self.atlas_book_lookup), len(set(paths)))

		recreate_books = set()
		if not recreate_all:
			for path in paths:
				if path not in self.atlas_book_lookup:
					self.log.info('A new image has been added: %s', path)
					recreate_all = True
					break

				last_modified = os.path.getmtime(path)
				book = self.atlas_book_lookup[path]
				entry = book.location[path]
				if last_modified == entry.last_modified:
					continue

				self.log.info('An image has been modified: %s', path)
				w, h = self._get_dimensions(path)
				if w > entry.width or h > entry.height:
					self.log.info('An image is larger than before: %s', path)
					recreate_all = True
					break

				if book not in recreate_books:
					self.log.info('Need to recreate %s', book.path)
					recreate_books.add(book)

				# update the entry
				entry.width = w
				entry.height = h
				entry.last_modified = last_modified

		if recreate_all:
			self.log.info('Forced to recreate the entire atlas.')
			return False

		if recreate_books:
			self.log.info('Updated selected books')
			self._update_selected_books(recreate_books)
			self._save_metadata()
		else:
			# the sets have to always be saved because the tm_N files are not otherwise taken into account
			self._save_sets()
		return True

	def __getstate__(self):
		# avoid saving self.sets
		return {'version': self.version, 'max_size': self.max_size, 'books': self.books,
		        'num_books': self.num_books, 'atlas_book_lookup': self.atlas_book_lookup}

	def _save_metadata(self):
		self.log.info('Saving metadata')
		with open(PATHS.ATLAS_METADATA_PATH, 'wb') as file:
			pickle.dump(self, file)
		self.log.info('Finished saving metadata')

	@classmethod
	def check_files(cls):
		"""Check that the required atlas files exist."""
		paths = [
			'content' + os.sep + 'actionsets.json',
			'content' + os.sep + 'atlas.sql',
			'content' + os.sep + 'tilesets.json',
		]
		for path in paths:
			if not os.path.exists(path):
				return False

		# verify that the combined images exist
		db = DbReader(':memory:')
		db.execute_script(open('content' + os.sep + 'atlas.sql').read())
		for db_row in db("SELECT atlas_path FROM atlas"):
			if not os.path.exists(db_row[0]):
				return False
		return True

	@classmethod
	def load(cls, max_size):
		if not cls.check_files():
			cls.log.info('Some required atlas file missing.')
			return None

		if not os.path.exists(PATHS.ATLAS_METADATA_PATH):
			cls.log.info('Old atlas metadata cache not found.')
			return None

		cls.log.info('Loading the metadata cache')
		with open(PATHS.ATLAS_METADATA_PATH, 'rb') as file:
			data = pickle.load(file)

			if data.version != cls.current_version:
				cls.log.info('Old metadata version %d (current %d)', data.version, cls.current_version)
				return None

			if data.max_size != max_size:
				cls.log.info('The desired max_size has changed from %d to %d', data.max_size, max_size)
				return None

			cls.log.info('Successfully loaded the metadata cache')
			return data

	@classmethod
	def clear_everything(cls):
		"""Delete all known atlas-related files."""
		paths = []
		paths.append(PATHS.ATLAS_METADATA_PATH)
		paths.append(PATHS.ATLAS_DB_PATH)
		paths.append(PATHS.ACTION_SETS_JSON_FILE)
		paths.append(PATHS.TILE_SETS_JSON_FILE)
		paths.extend(glob.glob('content/gfx/atlas/*.png'))

		# delete everything
		for path in paths:
			if not os.path.exists(path):
				continue
			cls.log.info('Deleting %s', path)
			os.unlink(path)


if __name__ == '__main__':
	args = sys.argv[1:]
	if len(args) != 1:
		print 'Usage: python2 generate_atlases.py max_size'
		exit(1)

	max_size = int(math.pow(2, int(math.log(int(args[0]), 2))))

	updated = False
	try:
		generator = AtlasGenerator.load(max_size)
		if generator is not None:
			updated = generator.update()
	except Exception:
		traceback.print_exc()

	if not updated:
		AtlasGenerator.clear_everything()
		generator = AtlasGenerator(max_size)
		generator.recreate()

########NEW FILE########
__FILENAME__ = pychan_util
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import functools
import traceback

from fife.extensions import pychan

from horizons.gui.style import STYLES
from horizons.messaging import GuiAction
from horizons.util.python.callback import Callback
from horizons.gui.widgets.imagebutton import ImageButton

import horizons.globals

class RenameLabel(pychan.widgets.Label):
	"""A regular label that signals that it will display a rename dialog when clicked upon (by changing the cursor)"""
	pass # implementation added dynamically below
class RenameImageButton(ImageButton):
	pass # as above

def handle_gcn_exception(e, msg=None):
	"""Called for RuntimeErrors after gcn::exceptions that smell like guichan bugs.
	@param e: RuntimeError (python, not pychan)
	@param msg: additional info as string
	"""
	traceback.print_stack()
	print 'Caught RuntimeError on gui interaction, assuming irrelevant gcn::exception.'
	if msg:
		print msg

def init_pychan():
	"""General pychan initiation for uh"""
	global STYLES

	# quick hack to allow up_image/down_image values to be unicode
	# TODO solve this problem in a better way (e.g. passing str explicitly)
	# or waiting for a fix of http://github.com/fifengine/fifengine/issues/701
	from fife.extensions.pychan.properties import ImageProperty

	def patch_imageproperty(func):
		def wrapper(self, obj, image):
			if isinstance(image, unicode):
				image = str(image)
			return func(self, obj, image)
		return wrapper

	ImageProperty.__set__ = patch_imageproperty(ImageProperty.__set__)

	# register custom widgets
	from horizons.gui.widgets.inventory import Inventory
	from horizons.gui.widgets.buysellinventory import BuySellInventory
	from horizons.gui.widgets.imagefillstatusbutton import ImageFillStatusButton
	from horizons.gui.widgets.progressbar import ProgressBar, TilingProgressBar
	# additionally, ImageButton is imported from widgets.imagebutton above
	from horizons.gui.widgets.imagebutton import CancelButton, DeleteButton, MainmenuButton, OkButton
	from horizons.gui.widgets.icongroup import TabBG, TilingHBox, hr
	from horizons.gui.widgets.stepslider import StepSlider
	from horizons.gui.widgets.unitoverview import HealthWidget, StanceWidget, WeaponStorageWidget
	from horizons.gui.widgets.container import AutoResizeContainer
	from horizons.gui.widgets.tooltip import _Tooltip

	widgets = [OkButton, CancelButton, DeleteButton, MainmenuButton,
	           Inventory, BuySellInventory, ImageFillStatusButton,
	           ProgressBar, StepSlider, TabBG,
	           HealthWidget, StanceWidget, WeaponStorageWidget,
	           AutoResizeContainer, RenameLabel, RenameImageButton,
	           TilingHBox, TilingProgressBar, hr,
			 # This overwrites the ImageButton provided by FIFE!
	           ImageButton,
	           ]

	for widget in widgets:
		pychan.widgets.registerWidget(widget)

	# add uh styles
	for name, stylepart in STYLES.iteritems():
		pychan.manager.addStyle(name, stylepart)

	# patch default widgets
	for name, widget in pychan.widgets.WIDGETS.items():

		def catch_gcn_exception_decorator(func):
			@functools.wraps(func)
			def wrapper(*args, **kwargs):
				try:
					# only apply usable args, else it would crash when called through fife timers
					pychan.tools.applyOnlySuitable(func, *args, **kwargs)
				except RuntimeError as e:
					handle_gcn_exception(e)
			return wrapper

		widget.hide = catch_gcn_exception_decorator(widget.hide)

	from fife.extensions.pychan import Label, Icon, VBox, HBox
	# this is white list of widgets with tooltip.
	widgets_with_tooltip = [Label, Icon, HBox, VBox,
	                        ImageButton, AutoResizeContainer]

	for widget in widgets_with_tooltip:
		# Copy everything we need from the tooltip class (manual mixin).
		# TODO: Figure out if it is safe to use this instead:
		# widget.__bases__ += (_Tooltip, )
		for key, value in _Tooltip.__dict__.iteritems():
			if not key.startswith("__"):
				setattr(widget, key, value)

		def add_tooltip_init(func):
			@functools.wraps(func)
			def wrapper(self, *args, **kwargs):
				func(self, *args, **kwargs)
				self.init_tooltip()
			return wrapper

		widget.__init__ = add_tooltip_init(widget.__init__)

		# these sometimes fail with "No focushandler set (did you add the widget to the gui?)."
		# see #1597 and #1647
		widget.requestFocus = catch_gcn_exception_decorator(widget.requestFocus)

	# FIXME hack pychan's text2gui function, it does an isinstance check that breaks
	# the lazy string from horizons.i18n. we should be passing unicode to
	# widgets all the time, therefore we don't need the additional check.
	def text2gui(text):
		unicodePolicy = horizons.globals.fife.pychan.manager.unicodePolicy
		return text.encode("utf8",*unicodePolicy).replace("\t"," "*4).replace("[br]","\n")

	pychan.widgets.textfield.text2gui = text2gui
	pychan.widgets.basictextwidget.text2gui = text2gui


	setup_cursor_change_on_hover()

	setup_trigger_signals_on_action()


def setup_cursor_change_on_hover():

	# set cursor to rename on hover for certain widgets
	def set_cursor():
		horizons.globals.fife.set_cursor_image("rename")
	def unset_cursor():
		horizons.globals.fife.set_cursor_image("default")

	def make_cursor_change_on_hover_class(cls):
		# this can't be a regular class since vanilla TextFields should have it by default
		def disable_cursor_change_on_hover(self):
			self.mapEvents({
				self.name+'/mouseEntered/cursor' : None,
				self.name+'/mouseExited/cursor' : None,
				})

		def enable_cursor_change_on_hover(self):
			self.mapEvents({
				self.name+'/mouseEntered/cursor' : set_cursor,
				self.name+'/mouseExited/cursor' : unset_cursor,
				})

		def add_cursor_change_on_hover_init(func):
			@functools.wraps(func)
			def wrapper(self, *args, **kwargs):
				func(self, *args, **kwargs)
				enable_cursor_change_on_hover(self)
			return wrapper

		cls.__init__ = add_cursor_change_on_hover_init(cls.__init__)
		cls.disable_cursor_change_on_hover = disable_cursor_change_on_hover
		cls.enable_cursor_change_on_hover = enable_cursor_change_on_hover

	make_cursor_change_on_hover_class( pychan.widgets.WIDGETS['TextField'] )
	make_cursor_change_on_hover_class( RenameLabel )
	make_cursor_change_on_hover_class( RenameImageButton )


	# TODO: if the widget is hidden while the cursor is above it,
	# there is no exited event. A possible workaround would be to check
	# in short intervals whether the widget is still visible, possible also
	# whether the mouse is still above it (the later would be necessary in
	# case another widget is drawn above the original widget)
	# Since that would be quite ugly, it should only be done when consulting
	# pychan-savvy people yields no success.


def setup_trigger_signals_on_action():
	"""Make sure that every widget sends a signal when an action event occurs"""
	def make_action_trigger_a_signal(cls):
		def add_action_triggers_a_signal(func):
			@functools.wraps(func)
			def wrapper(self, *args, **kwargs):
				func(self, *args, **kwargs)
				self.capture(Callback(GuiAction.broadcast, self), "action", "action_listener")
			return wrapper

		cls.__init__ = add_action_triggers_a_signal( cls.__init__ )

	make_action_trigger_a_signal(pychan.widgets.Widget)

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2013 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.serializers.simplexml import SimpleXMLSerializer

from horizons.constants import LANGUAGENAMES, SETTINGS
from horizons.i18n import change_language

class Settings(object):

	# Settings key storing the SettingsVersion used to upgrade settings
	SETTINGS_VERSION = "SettingsVersion"

	def __init__(self, settings_file, settings_template_file):
		self._module_settings = {}
		self._module_settings_template = {}
		self._settings_file = settings_file
		self._settings_template_file = settings_template_file
		self._settings_serializer = SimpleXMLSerializer()
		self._settings_serializer.load(settings_file)
		self._settings_template_serializer = SimpleXMLSerializer()
		self._settings_template_serializer.load(settings_template_file)
		if not hasattr (self._settings_template_serializer, 'getModuleName'):
			# Renamed after 0.3.5: https://github.com/fifengine/fifengine/issues/819.
			new_api = self._settings_template_serializer.getModuleNameList
			self._settings_template_serializer.getModuleName = new_api
		self.upgrade_settings()

	def get(self, module, name, default=None):
		if default is None:
			default = self._settings_template_serializer.get(module, name)

		v = self._settings_serializer.get(module, name, default)
		getter = getattr(self, 'get_' + module + '_' + name, None)
		if getter:
			return getter(v)
		else:
			return v

	def set(self, module, name, value):
		setter = getattr(self, 'set_' + module + '_' + name, None)
		if setter:
			value = setter(value)

		# This is necessary, as empty fields return None, but saving
		# None will result in the String 'None' being stored
		if value is None:
			value = ''

		if module in self._module_settings:
			self._module_settings[module][name] = value

		self._settings_serializer.set(module, name, value, {})

	def get_module_settings(self, module):
		self._module_settings[module] = self._settings_serializer.getAllSettings(module)
		self._module_settings_template[module] = self._settings_template_serializer.getAllSettings(module)
		for name, value in self._module_settings_template[module].iteritems():
			if name not in self._module_settings[module]:
				self._module_settings[module][name] = value
		return self._module_settings[module]

	def get_module_template_settings(self, module):
		return self._settings_template_serializer.getAllSettings(module)

	def save(self):
		self._settings_serializer.save(self._settings_file)

	def apply(self):
		data = self.get(SETTINGS.UH_MODULE, "Language")
		language = LANGUAGENAMES.get_by_value(data)
		change_language(language)

	def set_defaults(self):
		for module in self._settings_template_serializer.getModuleName():
			for setting_name in self._settings_template_serializer.getAllSettings(module):
				value = self._settings_template_serializer.get(module, setting_name)
				self.set(module, setting_name, value)
		self.save()

	def upgrade_settings(self):
		"""Upgrades the settings to a newer version necessary."""
		# if the settings file doesn't exist, force an update with
		# settings version 1 as default value
		current_version = self.get(SETTINGS.META_MODULE, self.SETTINGS_VERSION, 1)
		template_version = self._settings_template_serializer.get(SETTINGS.META_MODULE, self.SETTINGS_VERSION)
		if current_version != template_version:
			print 'Discovered old settings file, auto-upgrading: %s -> %s' % \
		          (current_version, template_version)
			for module in self._settings_template_serializer.getModuleName():
				for setting_name in self._settings_template_serializer.getAllSettings(module):
					default_value = self._settings_template_serializer.get(module, setting_name)
					if self.get(module, setting_name, default=default_value) is default_value:
						self.set(module, setting_name, default_value)
			self.set(SETTINGS.META_MODULE, self.SETTINGS_VERSION, template_version)
			self.save()

	# settings

	def get_unknownhorizons_Language(self, value):
		if value is None: # the entry is None for empty strings
			value = ""
		return LANGUAGENAMES[value]

	def set_unknownhorizons_Language(self, value):
		return LANGUAGENAMES.get_by_value(value)

########NEW FILE########
__FILENAME__ = sound
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import glob
import random
from collections import deque

from fife import fife

from horizons.extscheduler import ExtScheduler


class Sound(object):
	"""Stuff related to engine & sound"""

	def __init__(self, engine):
		"""
		@param engine: Fife from horizons.engine.engine
		"""
		self.engine = engine
		self.emitter = {}
		self.emitter['bgsound'] = None
		self.emitter['effects'] = None
		self.emitter['speech'] = None
		self.emitter['ambient'] = []

		# Temporarily select a random music file to play.
		# TODO: Replace with proper playlist.
		self.ingame_music = glob.glob('content/audio/music/*.ogg')
		self.menu_music = glob.glob('content/audio/music/menu/*.ogg')

		# Store the three most recently played files to avoid repetition.
		# If we don't have three files available, reduce accordingly:
		# At least one track not in last_tracks always needs to exist.
		available = max(0, len(self.ingame_music) - 1)
		sample_size = min(3, available)
		self.last_tracks = deque(maxlen=sample_size)
		if len(self.menu_music) <= 1:
			# Sad stuff: we only have few menu tracks available right now.
			# Also play some ingame_tracks after the dedicated menu music
			# is exhausted, but make sure to start with these menu tracks.
			ingame_tracks = random.sample(self.ingame_music, sample_size)
			self.menu_music.extend(ingame_tracks)
			self.last_tracks.extend(ingame_tracks)

		self.setup_sound()

	def end(self):
		if self.engine.get_fife_setting("PlaySounds"):
			for emitter in self.emitter['ambient'][:]:
				emitter.stop()
				self.emitter['ambient'].remove(emitter)
			self.emitter['effects'].stop()
			self.emitter['speech'].stop()

	def setup_sound(self):
		if self.engine.get_fife_setting("PlaySounds"):
			self.enable_sound()
		else:
			self.disable_sound()

	def enable_sound(self):
		"""Enable all sound and start playing music."""
		# Set up sound if it is enabled
		self.soundmanager = self.engine.engine.getSoundManager()
		self.soundmanager.init()

		self.soundclipmanager = self.engine.engine.getSoundClipManager()
		self.emitter['bgsound'] = self.soundmanager.createEmitter()
		self.emitter['bgsound'].setGain(self.engine.get_uh_setting("VolumeMusic"))
		self.emitter['bgsound'].setLooping(False)
		self.emitter['effects'] = self.soundmanager.createEmitter()
		self.emitter['effects'].setGain(self.engine.get_uh_setting("VolumeEffects"))
		self.emitter['effects'].setLooping(False)
		self.emitter['speech'] = self.soundmanager.createEmitter()
		self.emitter['speech'].setGain(self.engine.get_uh_setting("VolumeEffects"))
		self.emitter['speech'].setLooping(False)

		# Start background music:
		self._old_byte_pos = 0.0
		self._old_smpl_pos = 0.0
		self.check_music(refresh_playlist=True, play_menu_tracks=True)
		ExtScheduler().add_new_object(self.check_music, self, loops=-1)

	def disable_sound(self):
		"""Disable all sound outputs."""
		if self.emitter['bgsound'] is not None:
			self.emitter['bgsound'].reset()
		if self.emitter['effects'] is not None:
			self.emitter['effects'].reset()
		if self.emitter['speech'] is not None:
			self.emitter['speech'].reset()
		ExtScheduler().rem_call(self, self.check_music)

	def check_music(self, refresh_playlist=False, play_menu_tracks=False):
		"""Used as callback to check if music is still running or if we have
		to load the next song.
		@param refresh_playlist: Whether to update the playlist type (menu, ingame).
		refresh_playlist should e.g. be set when loading happens, after which we no longer want to play menu music.
		The current track, however, will still finish playing before choosing a new track.
		@param play_menu_tracks: Whether to start the playlist with menu music. Only works with refresh_playlist=True.
		"""
		if refresh_playlist:
			if play_menu_tracks and self.menu_music:
				self.music = self.menu_music
			elif self.ingame_music:
				self.music = self.ingame_music
			else:
				self.music = None  # Cannot play any tracks if there are none

		self._new_byte_pos = self.emitter['bgsound'].getCursor(fife.SD_BYTE_POS)
		self._new_smpl_pos = self.emitter['bgsound'].getCursor(fife.SD_SAMPLE_POS)
		#TODO find cleaner way to check for this:
		# check whether last track has finished:
		if (self.music is not None
		    and self._new_byte_pos == self._old_byte_pos
		    and self._new_smpl_pos == self._old_smpl_pos):
			# choose random new track, but not one we played very recently
			track = random.choice([m for m in self.music if m not in self.last_tracks])
			self.play_sound('bgsound', track)
			self.last_tracks.append(track)

		self._old_byte_pos = self.emitter['bgsound'].getCursor(fife.SD_BYTE_POS)
		self._old_smpl_pos = self.emitter['bgsound'].getCursor(fife.SD_SAMPLE_POS)

	def play_sound(self, emitter, soundfile):
		"""Plays a soundfile on the given emitter.
		@param emitter: string: name of emitter that is to play the sound
		@param soundfile: string: path to the sound file we want to play
		"""
		if not self.engine.get_fife_setting("PlaySounds"):
			return
		emitter = self.emitter[emitter]
		#TODO what do we need those two asserts for...
		assert emitter is not None, "You need to supply an initialized emitter"
		assert soundfile is not None, "You need to supply a soundfile"
		emitter.reset()
		#TODO remove str() -- http://github.com/fifengine/fifengine/issues/449
		emitter.setSoundClip(self.soundclipmanager.load(str(soundfile)))
		emitter.play()

	def set_volume_emitter(self, emitter, volume):
		"""Sets the volume on the emitter specified by emitter_name.
		@param emitter: string with the emitters name, used as key for the self.emitter dict
		@param volume: double which volume the emitter is to be set to range[0, 1]
		"""
		if self.engine.get_fife_setting("PlaySounds"):
			self.emitter[emitter].setGain(volume)

	def set_volume_bgmusic(self, volume):
		"""Sets the volume for the backgroundmusic.
		@param volume: double which volume the emitter is to be set to range[0, 1]
		"""
		self.set_volume_emitter('bgsound', volume)

	def set_volume_effects(self, volume):
		"""Sets the volume for the effects, speech and ambient sounds.
		@param volume: double which volume the emitter is to be set to range[0, 1]
		"""
		self.set_volume_emitter('effects', volume)
		self.set_volume_emitter('speech', volume)
		for emitter in self.emitter['ambient']:
			emitter.setGain(volume * 2)

########NEW FILE########
__FILENAME__ = entities
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import fnmatch
import os

from horizons.util.loaders.tilesetloader import TileSetLoader
from horizons.util.python.callback import Callback
from horizons.util.yamlcache import YamlCache

class _EntitiesLazyDict(dict):
	def __init__(self):
		self._future_entries = {}

	def create_on_access(self, key, construction_function):
		self._future_entries[key] = construction_function

	def __getitem__(self, key):
		try:
			return super(_EntitiesLazyDict, self).__getitem__(key)
		except KeyError:
			fun = self._future_entries.pop(key)
			elem = fun()
			self[key] = elem
			return elem


class Entities(object):
	"""Class that stores all the special classes for buildings, grounds etc.
	Stores class objects, not instances.
	Loads everything from the db."""
	loaded = False

	log = logging.getLogger('entities')

	@classmethod
	def load(cls, db, load_now=False):
		if cls.loaded:
			return

		cls.load_grounds(db, load_now)
		cls.load_buildings(db, load_now)
		cls.load_units(load_now)
		cls.loaded = True

	@classmethod
	def load_grounds(cls, db, load_now=False):
		cls.log.debug("Entities: loading grounds")
		if hasattr(cls, "grounds"):
			cls.log.debug("Entities: grounds already loaded")
			return

		from horizons.world.ground import GroundClass
		tile_sets = TileSetLoader.get_sets()
		cls.grounds = _EntitiesLazyDict()
		for (ground_id,) in db("SELECT ground_id FROM tile_set"):
			tile_set_id = db("SELECT set_id FROM tile_set WHERE ground_id=?", ground_id)[0][0]
			for shape in tile_sets[tile_set_id].iterkeys():
				cls_name = '%d-%s' % (ground_id, shape)
				cls.grounds.create_on_access(cls_name, Callback(GroundClass, db, ground_id, shape))
				if load_now:
					cls.grounds[cls_name]
		cls.grounds['-1-special'] = GroundClass(db, -1, 'special')

	@classmethod
	def load_buildings(cls, db, load_now=False):
		cls.log.debug("Entities: loading buildings")
		if hasattr(cls, 'buildings'):
			cls.log.debug("Entities: buildings already loaded")
			return
		cls.buildings = _EntitiesLazyDict()
		from horizons.world.building import BuildingClass
		for root, dirnames, filenames in os.walk('content/objects/buildings'):
			for filename in fnmatch.filter(filenames, '*.yaml'):
				cls.log.debug("Loading: " + filename)
				# This is needed for dict lookups! Do not convert to os.join!
				full_file = root + "/" + filename
				result = YamlCache.get_file(full_file, game_data=True)
				if result is None: # discard empty yaml files
					print "Empty yaml file {file} found, not loading!".format(file=full_file)
					continue

				result['yaml_file'] = full_file

				building_id = int(result['id'])
				cls.buildings.create_on_access(building_id, Callback(BuildingClass, db=db, id=building_id, yaml_data=result))
				# NOTE: The current system now requires all building data to be loaded
				if load_now or True:
					cls.buildings[building_id]

	@classmethod
	def load_units(cls, load_now=False):
		cls.log.debug("Entities: loading units")
		if hasattr(cls, 'units'):
			cls.log.debug("Entities: units already loaded")
			return
		cls.units = _EntitiesLazyDict()

		from horizons.world.units import UnitClass
		for root, dirnames, filenames in os.walk('content/objects/units'):
			for filename in fnmatch.filter(filenames, '*.yaml'):
				full_file = os.path.join(root, filename)
				result = YamlCache.get_file(full_file, game_data=True)
				unit_id = int(result['id'])
				cls.units.create_on_access(unit_id, Callback(UnitClass, id=unit_id, yaml_data=result))
				if load_now:
					cls.units[unit_id]

########NEW FILE########
__FILENAME__ = dummy
"""
Copyright (c) 2008 nosklo

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

# http://code.activestate.com/recipes/576447-dummy-object/
# with some modifications

class Dummy(object):
	def __getattr__(self, attr):
		try:
			return super(self.__class__, self).__getattr__(attr)
		except AttributeError:
			if attr in ('__base__', '__bases__', '__basicsize__', '__cmp__',
				'__dictoffset__', '__flags__', '__itemsize__',
				'__members__', '__methods__', '__mro__', '__name__',
				'__subclasses__', '__weakrefoffset__',
				'_getAttributeNames', 'mro'):
				raise
			else:
				return self
	def next(self):
		raise StopIteration
	def __repr__(self):
		return 'Dummy()'
	def __init__(self, *args, **kwargs):
		pass
	def __len__(self):
		return 0
	def __eq__(self, other):
		return self is other
	def __hash__(self):
		return hash(None)
	def __call__(self, *args, **kwargs):
		return self
	def __trunc__(self):
		return 0
	__sub__ = __div__ = __mul__ = __floordiv__ = __mod__ = __and__ = __or__ = \
	__xor__ = __rsub__ = __rdiv__ = __rmul__ = __rfloordiv__ = __rmod__ = \
	__rand__ = __rxor__ = __ror__ = __radd__ = __pow__ = __rpow__ = \
	__rshift__ = __lshift__ = __rrshift__ = __rlshift__ = __truediv__ = \
	__rtruediv__ = __add__ = __getitem__ = __neg__ = __pos__ = __abs__ = \
	__invert__ = __setattr__ = __delattr__ = __delitem__ = __setitem__ = \
	__iter__ = __call__

Dummy = Dummy()


########NEW FILE########
__FILENAME__ = enum
# -*- coding: utf-8 -*-

# enum.py
# Part of enum, a package providing enumerated types for Python.
#
# Copyright © 2007–2009 Ben Finney <ben+python@benfinney.id.au>
# This is free software; you may copy, modify and/or distribute this work
# under the terms of the GNU General Public License, version 2 or later
# or, at your option, the terms of the Python license.

""" Robust enumerated type support in Python.

This package provides a module for robust enumerations in Python.

An enumeration object is created with a sequence of string arguments
to the Enum() constructor::

    >>> from enum import Enum
    >>> Colors = Enum('red', 'blue', 'green')
    >>> Weekdays = Enum('mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun')

The return value is an immutable sequence object with a value for each
of the string arguments. Each value is also available as an attribute
named from the corresponding string argument::

    >>> pizza_night = Weekdays[4]
    >>> shirt_color = Colors.green

The values are constants that can be compared only with values from
the same enumeration; comparison with other values will invoke
Python's fallback comparisons::

    >>> pizza_night == Weekdays.fri
    True
    >>> shirt_color > Colors.red
    True
    >>> shirt_color == "green"
    False

Each value from an enumeration exports its sequence index
as an integer, and can be coerced to a simple string matching the
original arguments used to create the enumeration::

    >>> str(pizza_night)
    'fri'
    >>> shirt_color.index
    2
"""

__author_name__ = "Ben Finney"
__author_email__ = "ben+python@benfinney.id.au"
__author__ = "%(__author_name__)s <%(__author_email__)s>" % vars()

_copyright_year_begin = "2007"
__date__ = "2009-08-26"
_copyright_year_latest = __date__.split('-')[0]
_copyright_year_range = _copyright_year_begin
if _copyright_year_latest > _copyright_year_begin:
	_copyright_year_range += "–%(_copyright_year_latest)s" % vars()
__copyright__ = (
	"Copyright © %(_copyright_year_range)s"
	" %(__author_name__)s") % vars()
__license__ = "Choice of GPL or Python license"

__url__ = "http://pypi.python.org/pypi/enum/"
__version__ = "0.4.4"


class EnumException(Exception):
	""" Base class for all exceptions in this module. """

	def __init__(self, *args, **kwargs):
		if self.__class__ is EnumException:
			class_name = self.__class__.__name__
			raise NotImplementedError(
				"%(class_name)s is an abstract base class" % vars())
		super(EnumException, self).__init__(*args, **kwargs)


class EnumEmptyError(AssertionError, EnumException):
	""" Raised when attempting to create an empty enumeration. """

	def __str__(self):
		return "Enumerations cannot be empty"


class EnumBadKeyError(TypeError, EnumException):
	""" Raised when creating an Enum with non-string keys. """

	def __init__(self, key):
		self.key = key

	def __str__(self):
		return "Enumeration keys must be strings: %(key)r" % vars(self)


class EnumImmutableError(TypeError, EnumException):
	""" Raised when attempting to modify an Enum. """

	def __init__(self, *args):
		self.args = args

	def __str__(self):
		return "Enumeration does not allow modification"


def _comparator(func):
	""" Decorator for EnumValue rich comparison methods. """
	def comparator_wrapper(self, other):
		try:
			assert self.enumtype == other.enumtype
			result = func(self.index, other.index)
		except (AssertionError, AttributeError):
			result = NotImplemented

		return result
	comparator_wrapper.__name__ = func.__name__
	comparator_wrapper.__doc__ = getattr(float, func.__name__).__doc__
	return comparator_wrapper


class EnumValue(object):
	""" A specific value of an enumerated type. """

	def __init__(self, enumtype, index, key):
		""" Set up a new instance. """
		self._enumtype = enumtype
		self._index = index
		self._key = key

	@property
	def enumtype(self):
		return self._enumtype

	@property
	def key(self):
		return self._key

	def __str__(self):
		return str(self.key)

	@property
	def index(self):
		return self._index

	def __repr__(self):
		return "EnumValue(%(_enumtype)r, %(_index)r, %(_key)r)" % vars(self)

	def __hash__(self):
		return hash(self._index)

	@_comparator
	def __eq__(self, other):
		return (self == other)

	@_comparator
	def __ne__(self, other):
		return (self != other)

	@_comparator
	def __lt__(self, other):
		return (self < other)

	@_comparator
	def __le__(self, other):
		return (self <= other)

	@_comparator
	def __gt__(self, other):
		return (self > other)

	@_comparator
	def __ge__(self, other):
		return (self >= other)


class Enum(object):
	""" Enumerated type. """

	def __init__(self, *keys, **kwargs):
		""" Create an enumeration instance. """

		value_type = kwargs.get('value_type', EnumValue)

		if not keys:
			raise EnumEmptyError()

		keys = tuple(keys)
		values = [None] * len(keys)

		for i, key in enumerate(keys):
			value = value_type(self, i, key)
			values[i] = value
			try:
				super(Enum, self).__setattr__(key, value)
			except TypeError:
				raise EnumBadKeyError(key)

		self.__dict__['_keys'] = keys
		self.__dict__['_values'] = values

	@classmethod
	def get_extended(cls, base_enum, *keys, **kwargs):
		keys = base_enum._keys + keys
		return cls(*keys, **kwargs)

	def __setattr__(self, name, value):
		raise EnumImmutableError(name)

	def __delattr__(self, name):
		raise EnumImmutableError(name)

	def __len__(self):
		return len(self._values)

	def __getitem__(self, index):
		return self._values[index]

	def __setitem__(self, index, value):
		raise EnumImmutableError(index)

	def __delitem__(self, index):
		raise EnumImmutableError(index)

	def __iter__(self):
		return iter(self._values)

	def __contains__(self, value):
		is_member = False
		if isinstance(value, basestring):
			is_member = (value in self._keys)
		else:
			is_member = (value in self._values)
		return is_member

	def get_item_for_string(self, key):
		"""Get an enum value for a string
		@throws KeyError on key not found"""
		try:
			index = self._keys.index(key)
		except ValueError:
			raise KeyError # keyerror is more natural here, since the value is a key
		return self[index]

########NEW FILE########
__FILENAME__ = polib
# -* coding: utf-8 -*-
#
# License: MIT (see LICENSE file provided)
# vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4:

"""
**polib** allows you to manipulate, create, modify gettext files (pot, po and
mo files).  You can load existing files, iterate through it's entries, add,
modify entries, comments or metadata, etc. or create new po files from scratch.

**polib** provides a simple and pythonic API via the :func:`~polib.pofile` and
:func:`~polib.mofile` convenience functions.
"""

__author__ = 'David Jean Louis <izimobil@gmail.com>'
__version__ = '1.0.3'
__all__ = ['pofile', 'POFile', 'POEntry', 'mofile', 'MOFile', 'MOEntry',
           'default_encoding', 'escape', 'unescape', 'detect_encoding', ]

import array
import codecs
import os
import re
import struct
import sys
import textwrap


# the default encoding to use when encoding cannot be detected
default_encoding = 'utf-8'

# python 2/3 compatibility helpers {{{


if sys.version_info[:2] < (3, 0):
    PY3 = False
    text_type = unicode

    def b(s):
        return s

    def u(s):
        return unicode(s, "unicode_escape")

else:
    PY3 = True
    text_type = str

    def b(s):
        return s.encode("latin-1")

    def u(s):
        return s
# }}}
# _pofile_or_mofile {{{


def _pofile_or_mofile(f, type, **kwargs):
    """
    Internal function used by :func:`polib.pofile` and :func:`polib.mofile` to
    honor the DRY concept.
    """
    # get the file encoding
    enc = kwargs.get('encoding')
    if enc is None:
        enc = detect_encoding(f, type == 'mofile')

    # parse the file
    kls = type == 'pofile' and _POFileParser or _MOFileParser
    parser = kls(
        f,
        encoding=enc,
        check_for_duplicates=kwargs.get('check_for_duplicates', False),
        klass=kwargs.get('klass')
    )
    instance = parser.parse()
    instance.wrapwidth = kwargs.get('wrapwidth', 78)
    return instance
# }}}
# function pofile() {{{


def pofile(pofile, **kwargs):
    """
    Convenience function that parses the po or pot file ``pofile`` and returns
    a :class:`~polib.POFile` instance.

    Arguments:

    ``pofile``
        string, full or relative path to the po/pot file or its content (data).

    ``wrapwidth``
        integer, the wrap width, only useful when the ``-w`` option was passed
        to xgettext (optional, default: ``78``).

    ``encoding``
        string, the encoding to use (e.g. "utf-8") (default: ``None``, the
        encoding will be auto-detected).

    ``check_for_duplicates``
        whether to check for duplicate entries when adding entries to the
        file (optional, default: ``False``).

    ``klass``
        class which is used to instantiate the return value (optional,
        default: ``None``, the return value with be a :class:`~polib.POFile`
        instance).
    """
    return _pofile_or_mofile(pofile, 'pofile', **kwargs)
# }}}
# function mofile() {{{


def mofile(mofile, **kwargs):
    """
    Convenience function that parses the mo file ``mofile`` and returns a
    :class:`~polib.MOFile` instance.

    Arguments:

    ``mofile``
        string, full or relative path to the mo file or its content (data).

    ``wrapwidth``
        integer, the wrap width, only useful when the ``-w`` option was passed
        to xgettext to generate the po file that was used to format the mo file
        (optional, default: ``78``).

    ``encoding``
        string, the encoding to use (e.g. "utf-8") (default: ``None``, the
        encoding will be auto-detected).

    ``check_for_duplicates``
        whether to check for duplicate entries when adding entries to the
        file (optional, default: ``False``).

    ``klass``
        class which is used to instantiate the return value (optional,
        default: ``None``, the return value with be a :class:`~polib.POFile`
        instance).
    """
    return _pofile_or_mofile(mofile, 'mofile', **kwargs)
# }}}
# function detect_encoding() {{{


def detect_encoding(file, binary_mode=False):
    """
    Try to detect the encoding used by the ``file``. The ``file`` argument can
    be a PO or MO file path or a string containing the contents of the file.
    If the encoding cannot be detected, the function will return the value of
    ``default_encoding``.

    Arguments:

    ``file``
        string, full or relative path to the po/mo file or its content.

    ``binary_mode``
        boolean, set this to True if ``file`` is a mo file.
    """
    PATTERN = r'"?Content-Type:.+? charset=([\w_\-:\.]+)'
    rxt = re.compile(u(PATTERN))
    rxb = re.compile(b(PATTERN))

    def charset_exists(charset):
        """Check whether ``charset`` is valid or not."""
        try:
            codecs.lookup(charset)
        except LookupError:
            return False
        return True

    try:
        is_file = os.path.exists(file)
    except (ValueError, UnicodeEncodeError):
        is_file = False

    if not is_file:
        match = rxt.search(file)
        if match:
            enc = match.group(1).strip()
            if charset_exists(enc):
                return enc
    else:
        # For PY3, always treat as binary
        if binary_mode or PY3:
            mode = 'rb'
            rx = rxb
        else:
            mode = 'r'
            rx = rxt
        f = open(file, mode)
        for l in f.readlines():
            match = rx.search(l)
            if match:
                f.close()
                enc = match.group(1).strip()
                if not isinstance(enc, text_type):
                    enc = enc.decode('utf-8')
                if charset_exists(enc):
                    return enc
        f.close()
    return default_encoding
# }}}
# function escape() {{{


def escape(st):
    """
    Escapes the characters ``\\\\``, ``\\t``, ``\\n``, ``\\r`` and ``"`` in
    the given string ``st`` and returns it.
    """
    return st.replace('\\', r'\\')\
             .replace('\t', r'\t')\
             .replace('\r', r'\r')\
             .replace('\n', r'\n')\
             .replace('\"', r'\"')
# }}}
# function unescape() {{{


def unescape(st):
    """
    Unescapes the characters ``\\\\``, ``\\t``, ``\\n``, ``\\r`` and ``"`` in
    the given string ``st`` and returns it.
    """
    def unescape_repl(m):
        m = m.group(1)
        if m == 'n':
            return '\n'
        if m == 't':
            return '\t'
        if m == 'r':
            return '\r'
        if m == '\\':
            return '\\'
        return m  # handles escaped double quote
    return re.sub(r'\\(\\|n|t|r|")', unescape_repl, st)
# }}}
# class _BaseFile {{{


class _BaseFile(list):
    """
    Common base class for the :class:`~polib.POFile` and :class:`~polib.MOFile`
    classes. This class should **not** be instanciated directly.
    """

    def __init__(self, *args, **kwargs):
        """
        Constructor, accepts the following keyword arguments:

        ``pofile``
            string, the path to the po or mo file, or its content as a string.

        ``wrapwidth``
            integer, the wrap width, only useful when the ``-w`` option was
            passed to xgettext (optional, default: ``78``).

        ``encoding``
            string, the encoding to use, defaults to ``default_encoding``
            global variable (optional).

        ``check_for_duplicates``
            whether to check for duplicate entries when adding entries to the
            file, (optional, default: ``False``).
        """
        list.__init__(self)
        # the opened file handle
        pofile = kwargs.get('pofile', None)
        if pofile and os.path.exists(pofile):
            self.fpath = pofile
        else:
            self.fpath = kwargs.get('fpath')
        # the width at which lines should be wrapped
        self.wrapwidth = kwargs.get('wrapwidth', 78)
        # the file encoding
        self.encoding = kwargs.get('encoding', default_encoding)
        # whether to check for duplicate entries or not
        self.check_for_duplicates = kwargs.get('check_for_duplicates', False)
        # header
        self.header = ''
        # both po and mo files have metadata
        self.metadata = {}
        self.metadata_is_fuzzy = 0

    def __unicode__(self):
        """
        Returns the unicode representation of the file.
        """
        ret = []
        entries = [self.metadata_as_entry()] + \
                  [e for e in self if not e.obsolete]
        for entry in entries:
            ret.append(entry.__unicode__(self.wrapwidth))
        for entry in self.obsolete_entries():
            ret.append(entry.__unicode__(self.wrapwidth))
        ret = u('\n').join(ret)

        assert isinstance(ret, text_type)
        #if type(ret) != text_type:
        #    return unicode(ret, self.encoding)
        return ret

    if PY3:
        def __str__(self):
            return self.__unicode__()
    else:
        def __str__(self):
            """
            Returns the string representation of the file.
            """
            return unicode(self).encode(self.encoding)

    def __contains__(self, entry):
        """
        Overriden ``list`` method to implement the membership test (in and
        not in).
        The method considers that an entry is in the file if it finds an entry
        that has the same msgid (the test is **case sensitive**) and the same
        msgctxt (or none for both entries).

        Argument:

        ``entry``
            an instance of :class:`~polib._BaseEntry`.
        """
        return self.find(entry.msgid, by='msgid', msgctxt=entry.msgctxt) \
            is not None

    def __eq__(self, other):
        return str(self) == str(other)

    def append(self, entry):
        """
        Overriden method to check for duplicates entries, if a user tries to
        add an entry that is already in the file, the method will raise a
        ``ValueError`` exception.

        Argument:

        ``entry``
            an instance of :class:`~polib._BaseEntry`.
        """
        if self.check_for_duplicates and entry in self:
            raise ValueError('Entry "%s" already exists' % entry.msgid)
        super(_BaseFile, self).append(entry)

    def insert(self, index, entry):
        """
        Overriden method to check for duplicates entries, if a user tries to
        add an entry that is already in the file, the method will raise a
        ``ValueError`` exception.

        Arguments:

        ``index``
            index at which the entry should be inserted.

        ``entry``
            an instance of :class:`~polib._BaseEntry`.
        """
        if self.check_for_duplicates and entry in self:
            raise ValueError('Entry "%s" already exists' % entry.msgid)
        super(_BaseFile, self).insert(index, entry)

    def metadata_as_entry(self):
        """
        Returns the file metadata as a :class:`~polib.POFile` instance.
        """
        e = POEntry(msgid='')
        mdata = self.ordered_metadata()
        if mdata:
            strs = []
            for name, value in mdata:
                # Strip whitespace off each line in a multi-line entry
                strs.append('%s: %s' % (name, value))
            e.msgstr = '\n'.join(strs) + '\n'
        if self.metadata_is_fuzzy:
            e.flags.append('fuzzy')
        return e

    def save(self, fpath=None, repr_method='__unicode__'):
        """
        Saves the po file to ``fpath``.
        If it is an existing file and no ``fpath`` is provided, then the
        existing file is rewritten with the modified data.

        Keyword arguments:

        ``fpath``
            string, full or relative path to the file.

        ``repr_method``
            string, the method to use for output.
        """
        if self.fpath is None and fpath is None:
            raise IOError('You must provide a file path to save() method')
        contents = getattr(self, repr_method)()
        if fpath is None:
            fpath = self.fpath
        if repr_method == 'to_binary':
            fhandle = open(fpath, 'wb')
        else:
            fhandle = codecs.open(fpath, 'w', self.encoding)
            if not isinstance(contents, text_type):
                contents = contents.decode(self.encoding)
        fhandle.write(contents)
        fhandle.close()
        # set the file path if not set
        if self.fpath is None and fpath:
            self.fpath = fpath

    def find(self, st, by='msgid', include_obsolete_entries=False,
             msgctxt=False):
        """
        Find the entry which msgid (or property identified by the ``by``
        argument) matches the string ``st``.

        Keyword arguments:

        ``st``
            string, the string to search for.

        ``by``
            string, the property to use for comparison (default: ``msgid``).

        ``include_obsolete_entries``
            boolean, whether to also search in entries that are obsolete.

        ``msgctxt``
            string, allows to specify a specific message context for the
            search.
        """
        if include_obsolete_entries:
            entries = self[:]
        else:
            entries = [e for e in self if not e.obsolete]
        for e in entries:
            if getattr(e, by) == st:
                if msgctxt is not False and e.msgctxt != msgctxt:
                    continue
                return e
        return None

    def ordered_metadata(self):
        """
        Convenience method that returns an ordered version of the metadata
        dictionary. The return value is list of tuples (metadata name,
        metadata_value).
        """
        # copy the dict first
        metadata = self.metadata.copy()
        data_order = [
            'Project-Id-Version',
            'Report-Msgid-Bugs-To',
            'POT-Creation-Date',
            'PO-Revision-Date',
            'Last-Translator',
            'Language-Team',
            'MIME-Version',
            'Content-Type',
            'Content-Transfer-Encoding'
        ]
        ordered_data = []
        for data in data_order:
            try:
                value = metadata.pop(data)
                ordered_data.append((data, value))
            except KeyError:
                pass
        # the rest of the metadata will be alphabetically ordered since there
        # are no specs for this AFAIK
        for data in sorted(metadata.keys()):
            value = metadata[data]
            ordered_data.append((data, value))
        return ordered_data

    def to_binary(self):
        """
        Return the binary representation of the file.
        """
        offsets = []
        entries = self.translated_entries()

        # the keys are sorted in the .mo file
        def cmp(_self, other):
            # msgfmt compares entries with msgctxt if it exists
            self_msgid = _self.msgctxt and _self.msgctxt or _self.msgid
            other_msgid = other.msgctxt and other.msgctxt or other.msgid
            if self_msgid > other_msgid:
                return 1
            elif self_msgid < other_msgid:
                return -1
            else:
                return 0
        # add metadata entry
        entries.sort(key=lambda o: o.msgctxt or o.msgid)
        mentry = self.metadata_as_entry()
        #mentry.msgstr = mentry.msgstr.replace('\\n', '').lstrip()
        entries = [mentry] + entries
        entries_len = len(entries)
        ids, strs = b(''), b('')
        for e in entries:
            # For each string, we need size and file offset.  Each string is
            # NUL terminated; the NUL does not count into the size.
            msgid = b('')
            if e.msgctxt:
                # Contexts are stored by storing the concatenation of the
                # context, a <EOT> byte, and the original string
                msgid = self._encode(e.msgctxt + '\4')
            if e.msgid_plural:
                msgstr = []
                for index in sorted(e.msgstr_plural.keys()):
                    msgstr.append(e.msgstr_plural[index])
                msgid += self._encode(e.msgid + '\0' + e.msgid_plural)
                msgstr = self._encode('\0'.join(msgstr))
            else:
                msgid += self._encode(e.msgid)
                msgstr = self._encode(e.msgstr)
            offsets.append((len(ids), len(msgid), len(strs), len(msgstr)))
            ids += msgid + b('\0')
            strs += msgstr + b('\0')

        # The header is 7 32-bit unsigned integers.
        keystart = 7 * 4 + 16 * entries_len
        # and the values start after the keys
        valuestart = keystart + len(ids)
        koffsets = []
        voffsets = []
        # The string table first has the list of keys, then the list of values.
        # Each entry has first the size of the string, then the file offset.
        for o1, l1, o2, l2 in offsets:
            koffsets += [l1, o1 + keystart]
            voffsets += [l2, o2 + valuestart]
        offsets = koffsets + voffsets
        # check endianness for magic number
        if struct.pack('@h', 1) == struct.pack('<h', 1):
            magic_number = MOFile.LITTLE_ENDIAN
        else:
            magic_number = MOFile.BIG_ENDIAN

        output = struct.pack(
            "Iiiiiii",
            # Magic number
            magic_number,
            # Version
            0,
            # number of entries
            entries_len,
            # start of key index
            7 * 4,
            # start of value index
            7 * 4 + entries_len * 8,
            # size and offset of hash table, we don't use hash tables
            0, keystart

        )
        if PY3 and sys.version_info.minor > 1:  # python 3.2 or superior
            output += array.array("i", offsets).tobytes()
        else:
            output += array.array("i", offsets).tostring()
        output += ids
        output += strs
        return output

    def _encode(self, mixed):
        """
        Encodes the given ``mixed`` argument with the file encoding if and
        only if it's an unicode string and returns the encoded string.
        """
        if isinstance(mixed, text_type):
            mixed = mixed.encode(self.encoding)
        return mixed
# }}}
# class POFile {{{


class POFile(_BaseFile):
    """
    Po (or Pot) file reader/writer.
    This class inherits the :class:`~polib._BaseFile` class and, by extension,
    the python ``list`` type.
    """

    def __unicode__(self):
        """
        Returns the unicode representation of the po file.
        """
        ret, headers = '', self.header.split('\n')
        for header in headers:
            if header[:1] in [',', ':']:
                ret += '#%s\n' % header
            else:
                ret += '# %s\n' % header

        if not isinstance(ret, text_type):
            ret = ret.decode(self.encoding)

        return ret + _BaseFile.__unicode__(self)

    def save_as_mofile(self, fpath):
        """
        Saves the binary representation of the file to given ``fpath``.

        Keyword argument:

        ``fpath``
            string, full or relative path to the mo file.
        """
        _BaseFile.save(self, fpath, 'to_binary')

    def percent_translated(self):
        """
        Convenience method that returns the percentage of translated
        messages.
        """
        total = len([e for e in self if not e.obsolete])
        if total == 0:
            return 100
        translated = len(self.translated_entries())
        return int((100.00 / float(total)) * translated)

    def translated_entries(self):
        """
        Convenience method that returns the list of translated entries.
        """
        return [e for e in self if e.translated()]

    def untranslated_entries(self):
        """
        Convenience method that returns the list of untranslated entries.
        """
        return [e for e in self if not e.translated() and not e.obsolete
                and not 'fuzzy' in e.flags]

    def fuzzy_entries(self):
        """
        Convenience method that returns the list of fuzzy entries.
        """
        return [e for e in self if 'fuzzy' in e.flags]

    def obsolete_entries(self):
        """
        Convenience method that returns the list of obsolete entries.
        """
        return [e for e in self if e.obsolete]

    def merge(self, refpot):
        """
        Convenience method that merges the current pofile with the pot file
        provided. It behaves exactly as the gettext msgmerge utility:

        * comments of this file will be preserved, but extracted comments and
          occurrences will be discarded;
        * any translations or comments in the file will be discarded, however,
          dot comments and file positions will be preserved;
        * the fuzzy flags are preserved.

        Keyword argument:

        ``refpot``
            object POFile, the reference catalog.
        """
        # Store entries in dict/set for faster access
        self_entries = dict((entry.msgid, entry) for entry in self)
        refpot_msgids = set(entry.msgid for entry in refpot)
        # Merge entries that are in the refpot
        for entry in refpot:
            e = self_entries.get(entry.msgid)
            if e is None:
                e = POEntry()
                self.append(e)
            e.merge(entry)
        # ok, now we must "obsolete" entries that are not in the refpot anymore
        for entry in self:
            if entry.msgid not in refpot_msgids:
                entry.obsolete = True
# }}}
# class MOFile {{{


class MOFile(_BaseFile):
    """
    Mo file reader/writer.
    This class inherits the :class:`~polib._BaseFile` class and, by
    extension, the python ``list`` type.
    """
    BIG_ENDIAN = 0xde120495
    LITTLE_ENDIAN = 0x950412de

    def __init__(self, *args, **kwargs):
        """
        Constructor, accepts all keywords arguments accepted by
        :class:`~polib._BaseFile` class.
        """
        _BaseFile.__init__(self, *args, **kwargs)
        self.magic_number = None
        self.version = 0

    def save_as_pofile(self, fpath):
        """
        Saves the mofile as a pofile to ``fpath``.

        Keyword argument:

        ``fpath``
            string, full or relative path to the file.
        """
        _BaseFile.save(self, fpath)

    def save(self, fpath=None):
        """
        Saves the mofile to ``fpath``.

        Keyword argument:

        ``fpath``
            string, full or relative path to the file.
        """
        _BaseFile.save(self, fpath, 'to_binary')

    def percent_translated(self):
        """
        Convenience method to keep the same interface with POFile instances.
        """
        return 100

    def translated_entries(self):
        """
        Convenience method to keep the same interface with POFile instances.
        """
        return self

    def untranslated_entries(self):
        """
        Convenience method to keep the same interface with POFile instances.
        """
        return []

    def fuzzy_entries(self):
        """
        Convenience method to keep the same interface with POFile instances.
        """
        return []

    def obsolete_entries(self):
        """
        Convenience method to keep the same interface with POFile instances.
        """
        return []
# }}}
# class _BaseEntry {{{


class _BaseEntry(object):
    """
    Base class for :class:`~polib.POEntry` and :class:`~polib.MOEntry` classes.
    This class should **not** be instanciated directly.
    """

    def __init__(self, *args, **kwargs):
        """
        Constructor, accepts the following keyword arguments:

        ``msgid``
            string, the entry msgid.

        ``msgstr``
            string, the entry msgstr.

        ``msgid_plural``
            string, the entry msgid_plural.

        ``msgstr_plural``
            list, the entry msgstr_plural lines.

        ``msgctxt``
            string, the entry context (msgctxt).

        ``obsolete``
            bool, whether the entry is "obsolete" or not.

        ``encoding``
            string, the encoding to use, defaults to ``default_encoding``
            global variable (optional).
        """
        self.msgid = kwargs.get('msgid', '')
        self.msgstr = kwargs.get('msgstr', '')
        self.msgid_plural = kwargs.get('msgid_plural', '')
        self.msgstr_plural = kwargs.get('msgstr_plural', {})
        self.msgctxt = kwargs.get('msgctxt', None)
        self.obsolete = kwargs.get('obsolete', False)
        self.encoding = kwargs.get('encoding', default_encoding)

    def __unicode__(self, wrapwidth=78):
        """
        Returns the unicode representation of the entry.
        """
        if self.obsolete:
            delflag = '#~ '
        else:
            delflag = ''
        ret = []
        # write the msgctxt if any
        if self.msgctxt is not None:
            ret += self._str_field("msgctxt", delflag, "", self.msgctxt,
                                   wrapwidth)
        # write the msgid
        ret += self._str_field("msgid", delflag, "", self.msgid, wrapwidth)
        # write the msgid_plural if any
        if self.msgid_plural:
            ret += self._str_field("msgid_plural", delflag, "",
                                   self.msgid_plural, wrapwidth)
        if self.msgstr_plural:
            # write the msgstr_plural if any
            msgstrs = self.msgstr_plural
            keys = list(msgstrs)
            keys.sort()
            for index in keys:
                msgstr = msgstrs[index]
                plural_index = '[%s]' % index
                ret += self._str_field("msgstr", delflag, plural_index, msgstr,
                                       wrapwidth)
        else:
            # otherwise write the msgstr
            ret += self._str_field("msgstr", delflag, "", self.msgstr,
                                   wrapwidth)
        ret.append('')
        ret = u('\n').join(ret)
        return ret

    if PY3:
        def __str__(self):
            return self.__unicode__()
    else:
        def __str__(self):
            """
            Returns the string representation of the entry.
            """
            return unicode(self).encode(self.encoding)

    def __eq__(self, other):
        return str(self) == str(other)

    def _str_field(self, fieldname, delflag, plural_index, field,
                   wrapwidth=78):
        lines = field.splitlines(True)
        if len(lines) > 1:
            lines = [''] + lines  # start with initial empty line
        else:
            escaped_field = escape(field)
            specialchars_count = 0
            for c in ['\\', '\n', '\r', '\t', '"']:
                specialchars_count += field.count(c)
            # comparison must take into account fieldname length + one space
            # + 2 quotes (eg. msgid "<string>")
            flength = len(fieldname) + 3
            if plural_index:
                flength += len(plural_index)
            real_wrapwidth = wrapwidth - flength + specialchars_count
            if wrapwidth > 0 and len(field) > real_wrapwidth:
                # Wrap the line but take field name into account
                lines = [''] + [unescape(item) for item in wrap(
                    escaped_field,
                    wrapwidth - 2,  # 2 for quotes ""
                    drop_whitespace=False,
                    break_long_words=False
                )]
            else:
                lines = [field]
        if fieldname.startswith('previous_'):
            # quick and dirty trick to get the real field name
            fieldname = fieldname[9:]

        ret = ['%s%s%s "%s"' % (delflag, fieldname, plural_index,
                                escape(lines.pop(0)))]
        for mstr in lines:
            #import pdb; pdb.set_trace()
            ret.append('%s"%s"' % (delflag, escape(mstr)))
        return ret
# }}}
# class POEntry {{{


class POEntry(_BaseEntry):
    """
    Represents a po file entry.
    """

    def __init__(self, *args, **kwargs):
        """
        Constructor, accepts the following keyword arguments:

        ``comment``
            string, the entry comment.

        ``tcomment``
            string, the entry translator comment.

        ``occurrences``
            list, the entry occurrences.

        ``flags``
            list, the entry flags.

        ``previous_msgctxt``
            string, the entry previous context.

        ``previous_msgid``
            string, the entry previous msgid.

        ``previous_msgid_plural``
            string, the entry previous msgid_plural.
        """
        _BaseEntry.__init__(self, *args, **kwargs)
        self.comment = kwargs.get('comment', '')
        self.tcomment = kwargs.get('tcomment', '')
        self.occurrences = kwargs.get('occurrences', [])
        self.flags = kwargs.get('flags', [])
        self.previous_msgctxt = kwargs.get('previous_msgctxt', None)
        self.previous_msgid = kwargs.get('previous_msgid', None)
        self.previous_msgid_plural = kwargs.get('previous_msgid_plural', None)

    def __unicode__(self, wrapwidth=78):
        """
        Returns the unicode representation of the entry.
        """
        if self.obsolete:
            return _BaseEntry.__unicode__(self, wrapwidth)

        ret = []
        # comments first, if any (with text wrapping as xgettext does)
        comments = [('comment', '#. '), ('tcomment', '# ')]
        for c in comments:
            val = getattr(self, c[0])
            if val:
                for comment in val.split('\n'):
                    if wrapwidth > 0 and len(comment) + len(c[1]) > wrapwidth:
                        ret += wrap(
                            comment,
                            wrapwidth,
                            initial_indent=c[1],
                            subsequent_indent=c[1],
                            break_long_words=False
                        )
                    else:
                        ret.append('%s%s' % (c[1], comment))

        # occurrences (with text wrapping as xgettext does)
        if self.occurrences:
            filelist = []
            for fpath, lineno in self.occurrences:
                if lineno:
                    filelist.append('%s:%s' % (fpath, lineno))
                else:
                    filelist.append(fpath)
            filestr = ' '.join(filelist)
            if wrapwidth > 0 and len(filestr) + 3 > wrapwidth:
                # textwrap split words that contain hyphen, this is not
                # what we want for filenames, so the dirty hack is to
                # temporally replace hyphens with a char that a file cannot
                # contain, like "*"
                ret += [l.replace('*', '-') for l in wrap(
                    filestr.replace('-', '*'),
                    wrapwidth,
                    initial_indent='#: ',
                    subsequent_indent='#: ',
                    break_long_words=False
                )]
            else:
                ret.append('#: ' + filestr)

        # flags (TODO: wrapping ?)
        if self.flags:
            ret.append('#, %s' % ', '.join(self.flags))

        # previous context and previous msgid/msgid_plural
        fields = ['previous_msgctxt', 'previous_msgid',
                  'previous_msgid_plural']
        for f in fields:
            val = getattr(self, f)
            if val:
                ret += self._str_field(f, "#| ", "", val, wrapwidth)

        ret.append(_BaseEntry.__unicode__(self, wrapwidth))
        ret = u('\n').join(ret)

        assert isinstance(ret, text_type)
        #if type(ret) != types.UnicodeType:
        #    return unicode(ret, self.encoding)
        return ret

    def __cmp__(self, other):
        """
        Called by comparison operations if rich comparison is not defined.
        """

        # First: Obsolete test
        if self.obsolete != other.obsolete:
            if self.obsolete:
                return -1
            else:
                return 1
        # Work on a copy to protect original
        occ1 = sorted(self.occurrences[:])
        occ2 = sorted(other.occurrences[:])
        pos = 0
        for entry1 in occ1:
            try:
                entry2 = occ2[pos]
            except IndexError:
                return 1
            pos = pos + 1
            if entry1[0] != entry2[0]:
                if entry1[0] > entry2[0]:
                    return 1
                else:
                    return -1
            if entry1[1] != entry2[1]:
                if entry1[1] > entry2[1]:
                    return 1
                else:
                    return -1
        # Finally: Compare message ID
        if self.msgid > other.msgid:
            return 1
        elif self.msgid < other.msgid:
            return -1
        return 0

    def __gt__(self, other):
        return self.__cmp__(other) > 0

    def __lt__(self, other):
        return self.__cmp__(other) < 0

    def __ge__(self, other):
        return self.__cmp__(other) >= 0

    def __le__(self, other):
        return self.__cmp__(other) <= 0

    def __eq__(self, other):
        return self.__cmp__(other) == 0

    def __ne__(self, other):
        return self.__cmp__(other) != 0

    def translated(self):
        """
        Returns ``True`` if the entry has been translated or ``False``
        otherwise.
        """
        if self.obsolete or 'fuzzy' in self.flags:
            return False
        if self.msgstr != '':
            return True
        if self.msgstr_plural:
            for pos in self.msgstr_plural:
                if self.msgstr_plural[pos] == '':
                    return False
            return True
        return False

    def merge(self, other):
        """
        Merge the current entry with the given pot entry.
        """
        self.msgid = other.msgid
        self.msgctxt = other.msgctxt
        self.occurrences = other.occurrences
        self.comment = other.comment
        fuzzy = 'fuzzy' in self.flags
        self.flags = other.flags[:]  # clone flags
        if fuzzy:
            self.flags.append('fuzzy')
        self.msgid_plural = other.msgid_plural
        self.obsolete = other.obsolete
        self.previous_msgctxt = other.previous_msgctxt
        self.previous_msgid = other.previous_msgid
        self.previous_msgid_plural = other.previous_msgid_plural
        if other.msgstr_plural:
            for pos in other.msgstr_plural:
                try:
                    # keep existing translation at pos if any
                    self.msgstr_plural[pos]
                except KeyError:
                    self.msgstr_plural[pos] = ''
# }}}
# class MOEntry {{{


class MOEntry(_BaseEntry):
    """
    Represents a mo file entry.
    """
    pass
# }}}
# class _POFileParser {{{


class _POFileParser(object):
    """
    A finite state machine to parse efficiently and correctly po
    file format.
    """

    def __init__(self, pofile, *args, **kwargs):
        """
        Constructor.

        Keyword arguments:

        ``pofile``
            string, path to the po file or its content

        ``encoding``
            string, the encoding to use, defaults to ``default_encoding``
            global variable (optional).

        ``check_for_duplicates``
            whether to check for duplicate entries when adding entries to the
            file (optional, default: ``False``).
        """
        enc = kwargs.get('encoding', default_encoding)
        if os.path.exists(pofile):
            try:
                self.fhandle = codecs.open(pofile, 'rU', enc)
            except LookupError:
                enc = default_encoding
                self.fhandle = codecs.open(pofile, 'rU', enc)
        else:
            self.fhandle = pofile.splitlines()

        klass = kwargs.get('klass')
        if klass is None:
            klass = POFile
        self.instance = klass(
            pofile=pofile,
            encoding=enc,
            check_for_duplicates=kwargs.get('check_for_duplicates', False)
        )
        self.transitions = {}
        self.current_entry = POEntry()
        self.current_state = 'ST'
        self.current_token = None
        # two memo flags used in handlers
        self.msgstr_index = 0
        self.entry_obsolete = 0
        # Configure the state machine, by adding transitions.
        # Signification of symbols:
        #     * ST: Beginning of the file (start)
        #     * HE: Header
        #     * TC: a translation comment
        #     * GC: a generated comment
        #     * OC: a file/line occurence
        #     * FL: a flags line
        #     * CT: a message context
        #     * PC: a previous msgctxt
        #     * PM: a previous msgid
        #     * PP: a previous msgid_plural
        #     * MI: a msgid
        #     * MP: a msgid plural
        #     * MS: a msgstr
        #     * MX: a msgstr plural
        #     * MC: a msgid or msgstr continuation line
        all = ['ST', 'HE', 'GC', 'OC', 'FL', 'CT', 'PC', 'PM', 'PP', 'TC',
               'MS', 'MP', 'MX', 'MI']

        self.add('TC', ['ST', 'HE'],                                     'HE')
        self.add('TC', ['GC', 'OC', 'FL', 'TC', 'PC', 'PM', 'PP', 'MS',
                        'MP', 'MX', 'MI'],                               'TC')
        self.add('GC', all,                                              'GC')
        self.add('OC', all,                                              'OC')
        self.add('FL', all,                                              'FL')
        self.add('PC', all,                                              'PC')
        self.add('PM', all,                                              'PM')
        self.add('PP', all,                                              'PP')
        self.add('CT', ['ST', 'HE', 'GC', 'OC', 'FL', 'TC', 'PC', 'PM',
                        'PP', 'MS', 'MX'],                               'CT')
        self.add('MI', ['ST', 'HE', 'GC', 'OC', 'FL', 'CT', 'TC', 'PC',
                 'PM', 'PP', 'MS', 'MX'],                                'MI')
        self.add('MP', ['TC', 'GC', 'PC', 'PM', 'PP', 'MI'],             'MP')
        self.add('MS', ['MI', 'MP', 'TC'],                               'MS')
        self.add('MX', ['MI', 'MX', 'MP', 'TC'],                         'MX')
        self.add('MC', ['CT', 'MI', 'MP', 'MS', 'MX', 'PM', 'PP', 'PC'], 'MC')

    def parse(self):
        """
        Run the state machine, parse the file line by line and call process()
        with the current matched symbol.
        """
        i = 0

        keywords = {
            'msgctxt': 'CT',
            'msgid': 'MI',
            'msgstr': 'MS',
            'msgid_plural': 'MP',
        }
        prev_keywords = {
            'msgid_plural': 'PP',
            'msgid': 'PM',
            'msgctxt': 'PC',
        }

        for line in self.fhandle:
            i += 1
            line = line.strip()
            if line == '':
                continue

            tokens = line.split(None, 2)
            nb_tokens = len(tokens)

            if tokens[0] == '#~|':
                continue

            if tokens[0] == '#~' and nb_tokens > 1:
                line = line[3:].strip()
                tokens = tokens[1:]
                nb_tokens -= 1
                self.entry_obsolete = 1
            else:
                self.entry_obsolete = 0

            # Take care of keywords like
            # msgid, msgid_plural, msgctxt & msgstr.
            if tokens[0] in keywords and nb_tokens > 1:
                line = line[len(tokens[0]):].lstrip()
                if re.search(r'([^\\]|^)"', line[1:-1]):
                    raise IOError('Syntax error in po file %s (line %s): '
                                  'unescaped double quote found' %
                                  (self.instance.fpath, i))
                self.current_token = line
                self.process(keywords[tokens[0]], i)
                continue

            self.current_token = line

            if tokens[0] == '#:':
                if nb_tokens <= 1:
                    continue
                # we are on a occurrences line
                self.process('OC', i)

            elif line[:1] == '"':
                # we are on a continuation line
                if re.search(r'([^\\]|^)"', line[1:-1]):
                    raise IOError('Syntax error in po file %s (line %s): '
                                  'unescaped double quote found' %
                                  (self.instance.fpath, i))
                self.process('MC', i)

            elif line[:7] == 'msgstr[':
                # we are on a msgstr plural
                self.process('MX', i)

            elif tokens[0] == '#,':
                if nb_tokens <= 1:
                    continue
                # we are on a flags line
                self.process('FL', i)

            elif tokens[0] == '#' or tokens[0].startswith('##'):
                if line == '#':
                    line += ' '
                # we are on a translator comment line
                self.process('TC', i)

            elif tokens[0] == '#.':
                if nb_tokens <= 1:
                    continue
                # we are on a generated comment line
                self.process('GC', i)

            elif tokens[0] == '#|':
                if nb_tokens <= 1:
                    raise IOError('Syntax error in po file %s (line %s)' %
                                  (self.instance.fpath, i))

                # Remove the marker and any whitespace right after that.
                line = line[2:].lstrip()
                self.current_token = line

                if tokens[1].startswith('"'):
                    # Continuation of previous metadata.
                    self.process('MC', i)
                    continue

                if nb_tokens == 2:
                    # Invalid continuation line.
                    raise IOError('Syntax error in po file %s (line %s): '
                                  'invalid continuation line' %
                                  (self.instance.fpath, i))

                # we are on a "previous translation" comment line,
                if tokens[1] not in prev_keywords:
                    # Unknown keyword in previous translation comment.
                    raise IOError('Syntax error in po file %s (line %s): '
                                  'unknown keyword %s' %
                                  (self.instance.fpath, i, tokens[1]))

                # Remove the keyword and any whitespace
                # between it and the starting quote.
                line = line[len(tokens[1]):].lstrip()
                self.current_token = line
                self.process(prev_keywords[tokens[1]], i)

            else:
                raise IOError('Syntax error in po file %s (line %s)' %
                              (self.instance.fpath, i))

        if self.current_entry:
            # since entries are added when another entry is found, we must add
            # the last entry here (only if there are lines)
            self.instance.append(self.current_entry)
        # before returning the instance, check if there's metadata and if
        # so extract it in a dict
        metadataentry = self.instance.find('')
        if metadataentry:  # metadata found
            # remove the entry
            self.instance.remove(metadataentry)
            self.instance.metadata_is_fuzzy = metadataentry.flags
            key = None
            for msg in metadataentry.msgstr.splitlines():
                try:
                    key, val = msg.split(':', 1)
                    self.instance.metadata[key] = val.strip()
                except (ValueError, KeyError):
                    if key is not None:
                        self.instance.metadata[key] += '\n' + msg.strip()
        # close opened file
        if not isinstance(self.fhandle, list):  # must be file
            self.fhandle.close()
        return self.instance

    def add(self, symbol, states, next_state):
        """
        Add a transition to the state machine.

        Keywords arguments:

        ``symbol``
            string, the matched token (two chars symbol).

        ``states``
            list, a list of states (two chars symbols).

        ``next_state``
            the next state the fsm will have after the action.
        """
        for state in states:
            action = getattr(self, 'handle_%s' % next_state.lower())
            self.transitions[(symbol, state)] = (action, next_state)

    def process(self, symbol, linenum):
        """
        Process the transition corresponding to the current state and the
        symbol provided.

        Keywords arguments:

        ``symbol``
            string, the matched token (two chars symbol).

        ``linenum``
            integer, the current line number of the parsed file.
        """
        try:
            (action, state) = self.transitions[(symbol, self.current_state)]
            if action():
                self.current_state = state
        except Exception:
            raise IOError('Syntax error in po file (line %s)' % linenum)

    # state handlers

    def handle_he(self):
        """Handle a header comment."""
        if self.instance.header != '':
            self.instance.header += '\n'
        self.instance.header += self.current_token[2:]
        return 1

    def handle_tc(self):
        """Handle a translator comment."""
        if self.current_state in ['MC', 'MS', 'MX']:
            self.instance.append(self.current_entry)
            self.current_entry = POEntry()
        if self.current_entry.tcomment != '':
            self.current_entry.tcomment += '\n'
        tcomment = self.current_token.lstrip('#')
        if tcomment.startswith(' '):
            tcomment = tcomment[1:]
        self.current_entry.tcomment += tcomment
        return True

    def handle_gc(self):
        """Handle a generated comment."""
        if self.current_state in ['MC', 'MS', 'MX']:
            self.instance.append(self.current_entry)
            self.current_entry = POEntry()
        if self.current_entry.comment != '':
            self.current_entry.comment += '\n'
        self.current_entry.comment += self.current_token[3:]
        return True

    def handle_oc(self):
        """Handle a file:num occurence."""
        if self.current_state in ['MC', 'MS', 'MX']:
            self.instance.append(self.current_entry)
            self.current_entry = POEntry()
        occurrences = self.current_token[3:].split()
        for occurrence in occurrences:
            if occurrence != '':
                try:
                    fil, line = occurrence.split(':')
                    if not line.isdigit():
                        fil = fil + line
                        line = ''
                    self.current_entry.occurrences.append((fil, line))
                except (ValueError, AttributeError):
                    self.current_entry.occurrences.append((occurrence, ''))
        return True

    def handle_fl(self):
        """Handle a flags line."""
        if self.current_state in ['MC', 'MS', 'MX']:
            self.instance.append(self.current_entry)
            self.current_entry = POEntry()
        self.current_entry.flags += self.current_token[3:].split(', ')
        return True

    def handle_pp(self):
        """Handle a previous msgid_plural line."""
        if self.current_state in ['MC', 'MS', 'MX']:
            self.instance.append(self.current_entry)
            self.current_entry = POEntry()
        self.current_entry.previous_msgid_plural = \
            unescape(self.current_token[1:-1])
        return True

    def handle_pm(self):
        """Handle a previous msgid line."""
        if self.current_state in ['MC', 'MS', 'MX']:
            self.instance.append(self.current_entry)
            self.current_entry = POEntry()
        self.current_entry.previous_msgid = \
            unescape(self.current_token[1:-1])
        return True

    def handle_pc(self):
        """Handle a previous msgctxt line."""
        if self.current_state in ['MC', 'MS', 'MX']:
            self.instance.append(self.current_entry)
            self.current_entry = POEntry()
        self.current_entry.previous_msgctxt = \
            unescape(self.current_token[1:-1])
        return True

    def handle_ct(self):
        """Handle a msgctxt."""
        if self.current_state in ['MC', 'MS', 'MX']:
            self.instance.append(self.current_entry)
            self.current_entry = POEntry()
        self.current_entry.msgctxt = unescape(self.current_token[1:-1])
        return True

    def handle_mi(self):
        """Handle a msgid."""
        if self.current_state in ['MC', 'MS', 'MX']:
            self.instance.append(self.current_entry)
            self.current_entry = POEntry()
        self.current_entry.obsolete = self.entry_obsolete
        self.current_entry.msgid = unescape(self.current_token[1:-1])
        return True

    def handle_mp(self):
        """Handle a msgid plural."""
        self.current_entry.msgid_plural = unescape(self.current_token[1:-1])
        return True

    def handle_ms(self):
        """Handle a msgstr."""
        self.current_entry.msgstr = unescape(self.current_token[1:-1])
        return True

    def handle_mx(self):
        """Handle a msgstr plural."""
        index, value = self.current_token[7], self.current_token[11:-1]
        self.current_entry.msgstr_plural[index] = unescape(value)
        self.msgstr_index = index
        return True

    def handle_mc(self):
        """Handle a msgid or msgstr continuation line."""
        token = unescape(self.current_token[1:-1])
        if self.current_state == 'CT':
            self.current_entry.msgctxt += token
        elif self.current_state == 'MI':
            self.current_entry.msgid += token
        elif self.current_state == 'MP':
            self.current_entry.msgid_plural += token
        elif self.current_state == 'MS':
            self.current_entry.msgstr += token
        elif self.current_state == 'MX':
            self.current_entry.msgstr_plural[self.msgstr_index] += token
        elif self.current_state == 'PP':
            token = token[3:]
            self.current_entry.previous_msgid_plural += token
        elif self.current_state == 'PM':
            token = token[3:]
            self.current_entry.previous_msgid += token
        elif self.current_state == 'PC':
            token = token[3:]
            self.current_entry.previous_msgctxt += token
        # don't change the current state
        return False
# }}}
# class _MOFileParser {{{


class _MOFileParser(object):
    """
    A class to parse binary mo files.
    """

    def __init__(self, mofile, *args, **kwargs):
        """
        Constructor.

        Keyword arguments:

        ``mofile``
            string, path to the mo file or its content

        ``encoding``
            string, the encoding to use, defaults to ``default_encoding``
            global variable (optional).

        ``check_for_duplicates``
            whether to check for duplicate entries when adding entries to the
            file (optional, default: ``False``).
        """
        self.fhandle = open(mofile, 'rb')

        klass = kwargs.get('klass')
        if klass is None:
            klass = MOFile
        self.instance = klass(
            fpath=mofile,
            encoding=kwargs.get('encoding', default_encoding),
            check_for_duplicates=kwargs.get('check_for_duplicates', False)
        )

    def parse(self):
        """
        Build the instance with the file handle provided in the
        constructor.
        """
        # parse magic number
        magic_number = self._readbinary('<I', 4)
        if magic_number == MOFile.LITTLE_ENDIAN:
            ii = '<II'
        elif magic_number == MOFile.BIG_ENDIAN:
            ii = '>II'
        else:
            raise IOError('Invalid mo file, magic number is incorrect !')
        self.instance.magic_number = magic_number
        # parse the version number and the number of strings
        self.instance.version, numofstrings = self._readbinary(ii, 8)
        # original strings and translation strings hash table offset
        msgids_hash_offset, msgstrs_hash_offset = self._readbinary(ii, 8)
        # move to msgid hash table and read length and offset of msgids
        self.fhandle.seek(msgids_hash_offset)
        msgids_index = []
        for i in range(numofstrings):
            msgids_index.append(self._readbinary(ii, 8))
        # move to msgstr hash table and read length and offset of msgstrs
        self.fhandle.seek(msgstrs_hash_offset)
        msgstrs_index = []
        for i in range(numofstrings):
            msgstrs_index.append(self._readbinary(ii, 8))
        # build entries
        encoding = self.instance.encoding
        for i in range(numofstrings):
            self.fhandle.seek(msgids_index[i][1])
            msgid = self.fhandle.read(msgids_index[i][0])

            self.fhandle.seek(msgstrs_index[i][1])
            msgstr = self.fhandle.read(msgstrs_index[i][0])
            if i == 0:  # metadata
                raw_metadata, metadata = msgstr.split(b('\n')), {}
                for line in raw_metadata:
                    tokens = line.split(b(':'), 1)
                    if tokens[0] != b(''):
                        try:
                            k = tokens[0].decode(encoding)
                            v = tokens[1].decode(encoding)
                            metadata[k] = v.strip()
                        except IndexError:
                            metadata[k] = u('')
                self.instance.metadata = metadata
                continue
            # test if we have a plural entry
            msgid_tokens = msgid.split(b('\0'))
            if len(msgid_tokens) > 1:
                entry = self._build_entry(
                    msgid=msgid_tokens[0],
                    msgid_plural=msgid_tokens[1],
                    msgstr_plural=dict((k, v) for k, v in
                                       enumerate(msgstr.split(b('\0'))))
                )
            else:
                entry = self._build_entry(msgid=msgid, msgstr=msgstr)
            self.instance.append(entry)
        # close opened file
        self.fhandle.close()
        return self.instance

    def _build_entry(self, msgid, msgstr=None, msgid_plural=None,
                     msgstr_plural=None):
        msgctxt_msgid = msgid.split(b('\x04'))
        encoding = self.instance.encoding
        if len(msgctxt_msgid) > 1:
            kwargs = {
                'msgctxt': msgctxt_msgid[0].decode(encoding),
                'msgid': msgctxt_msgid[1].decode(encoding),
            }
        else:
            kwargs = {'msgid': msgid.decode(encoding)}
        if msgstr:
            kwargs['msgstr'] = msgstr.decode(encoding)
        if msgid_plural:
            kwargs['msgid_plural'] = msgid_plural.decode(encoding)
        if msgstr_plural:
            for k in msgstr_plural:
                msgstr_plural[k] = msgstr_plural[k].decode(encoding)
            kwargs['msgstr_plural'] = msgstr_plural
        return MOEntry(**kwargs)

    def _readbinary(self, fmt, numbytes):
        """
        Private method that unpack n bytes of data using format <fmt>.
        It returns a tuple or a mixed value if the tuple length is 1.
        """
        bytes = self.fhandle.read(numbytes)
        tup = struct.unpack(fmt, bytes)
        if len(tup) == 1:
            return tup[0]
        return tup
# }}}
# class TextWrapper {{{


class TextWrapper(textwrap.TextWrapper):
    """
    Subclass of textwrap.TextWrapper that backport the
    drop_whitespace option.
    """
    def __init__(self, *args, **kwargs):
        drop_whitespace = kwargs.pop('drop_whitespace', True)
        textwrap.TextWrapper.__init__(self, *args, **kwargs)
        self.drop_whitespace = drop_whitespace

    def _wrap_chunks(self, chunks):
        """_wrap_chunks(chunks : [string]) -> [string]

        Wrap a sequence of text chunks and return a list of lines of
        length 'self.width' or less.  (If 'break_long_words' is false,
        some lines may be longer than this.)  Chunks correspond roughly
        to words and the whitespace between them: each chunk is
        indivisible (modulo 'break_long_words'), but a line break can
        come between any two chunks.  Chunks should not have internal
        whitespace; ie. a chunk is either all whitespace or a "word".
        Whitespace chunks will be removed from the beginning and end of
        lines, but apart from that whitespace is preserved.
        """
        lines = []
        if self.width <= 0:
            raise ValueError("invalid width %r (must be > 0)" % self.width)

        # Arrange in reverse order so items can be efficiently popped
        # from a stack of chucks.
        chunks.reverse()

        while chunks:

            # Start the list of chunks that will make up the current line.
            # cur_len is just the length of all the chunks in cur_line.
            cur_line = []
            cur_len = 0

            # Figure out which static string will prefix this line.
            if lines:
                indent = self.subsequent_indent
            else:
                indent = self.initial_indent

            # Maximum width for this line.
            width = self.width - len(indent)

            # First chunk on line is whitespace -- drop it, unless this
            # is the very beginning of the text (ie. no lines started yet).
            if self.drop_whitespace and chunks[-1].strip() == '' and lines:
                del chunks[-1]

            while chunks:
                l = len(chunks[-1])

                # Can at least squeeze this chunk onto the current line.
                if cur_len + l <= width:
                    cur_line.append(chunks.pop())
                    cur_len += l

                # Nope, this line is full.
                else:
                    break

            # The current line is full, and the next chunk is too big to
            # fit on *any* line (not just this one).
            if chunks and len(chunks[-1]) > width:
                self._handle_long_word(chunks, cur_line, cur_len, width)

            # If the last chunk on this line is all whitespace, drop it.
            if self.drop_whitespace and cur_line and not cur_line[-1].strip():
                del cur_line[-1]

            # Convert current line back to a string and store it in list
            # of all lines (return value).
            if cur_line:
                lines.append(indent + ''.join(cur_line))

        return lines
# }}}
# function wrap() {{{


def wrap(text, width=70, **kwargs):
    """
    Wrap a single paragraph of text, returning a list of wrapped lines.
    """
    if sys.version_info < (2, 6):
        return TextWrapper(width=width, **kwargs).wrap(text)
    return textwrap.wrap(text, width=width, **kwargs)

# }}}

########NEW FILE########
__FILENAME__ = speaklater
# -*- coding: utf-8 -*-
r"""
    speaklater
    ~~~~~~~~~~

    A module that provides lazy strings for translations.  Basically you
    get an object that appears to be a string but changes the value every
    time the value is evaluated based on a callable you provide.

    For example you can have a global `lazy_gettext` function that returns
    a lazy string with the value of the current set language.

    Example:

    >>> from speaklater import make_lazy_string
    >>> sval = u'Hello World'
    >>> string = make_lazy_string(lambda: sval)

    This lazy string will evaluate to the value of the `sval` variable.

    >>> string
    lu'Hello World'
    >>> unicode(string)
    u'Hello World'
    >>> string.upper()
    u'HELLO WORLD'

    If you change the value, the lazy string will change as well:

    >>> sval = u'Hallo Welt'
    >>> string.upper()
    u'HALLO WELT'

    This is especially handy when combined with a thread local and gettext
    translations or dicts of translatable strings:

    >>> from speaklater import make_lazy_gettext
    >>> from threading import local
    >>> l = local()
    >>> l.translations = {u'Yes': 'Ja'}
    >>> lazy_gettext = make_lazy_gettext(lambda: l.translations.get)
    >>> yes = lazy_gettext(u'Yes')
    >>> print yes
    Ja
    >>> l.translations[u'Yes'] = u'Si'
    >>> print yes
    Si

    Lazy strings are no real strings so if you pass this sort of string to
    a function that performs an instance check, it will fail.  In that case
    you have to explicitly convert it with `unicode` and/or `string` depending
    on what string type the lazy string encapsulates.

    To check if a string is lazy, you can use the `is_lazy_string` function:

    >>> from speaklater import is_lazy_string
    >>> is_lazy_string(u'yes')
    False
    >>> is_lazy_string(yes)
    True

    New in version 1.2: It's now also possible to pass keyword arguments to
    the callback used with `make_lazy_string`.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
"""


def is_lazy_string(obj):
    """Checks if the given object is a lazy string."""
    return isinstance(obj, _LazyString)


def make_lazy_string(__func, *args, **kwargs):
    """Creates a lazy string by invoking func with args."""
    return _LazyString(__func, args, kwargs)


def make_lazy_gettext(lookup_func):
    """Creates a lazy gettext function dispatches to a gettext
    function as returned by `lookup_func`.

    Example:

    >>> translations = {u'Yes': u'Ja'}
    >>> lazy_gettext = make_lazy_gettext(lambda: translations.get)
    >>> x = lazy_gettext(u'Yes')
    >>> x
    lu'Ja'
    >>> translations[u'Yes'] = u'Si'
    >>> x
    lu'Si'
    """
    def lazy_gettext(string):
        if is_lazy_string(string):
            return string
        return make_lazy_string(lookup_func(), string)
    return lazy_gettext


class _LazyString(object):
    """Class for strings created by a function call.

    The proxy implementation attempts to be as complete as possible, so that
    the lazy objects should mostly work as expected, for example for sorting.
    """
    __slots__ = ('_func', '_args', '_kwargs')

    def __init__(self, func, args, kwargs):
        self._func = func
        self._args = args
        self._kwargs = kwargs

    value = property(lambda x: x._func(*x._args, **x._kwargs))

    def __contains__(self, key):
        return key in self.value

    def __nonzero__(self):
        return bool(self.value)

    def __dir__(self):
        return dir(unicode)

    def __iter__(self):
        return iter(self.value)

    def __len__(self):
        return len(self.value)

    def __str__(self):
        return str(self.value)

    def __unicode__(self):
        return unicode(self.value)

    def __add__(self, other):
        return self.value + other

    def __radd__(self, other):
        return other + self.value

    def __mod__(self, other):
        return self.value % other

    def __rmod__(self, other):
        return other % self.value

    def __mul__(self, other):
        return self.value * other

    def __rmul__(self, other):
        return other * self.value

    def __lt__(self, other):
        return self.value < other

    def __le__(self, other):
        return self.value <= other

    def __eq__(self, other):
        return self.value == other

    def __ne__(self, other):
        return self.value != other

    def __gt__(self, other):
        return self.value > other

    def __ge__(self, other):
        return self.value >= other

    def __hash__(self):
        return hash(self.value)

    def __getattr__(self, name):
        if name == '__members__':
            return self.__dir__()
        return getattr(self.value, name)

    def __getstate__(self):
        return self._func, self._args, self._kwargs

    def __setstate__(self, tup):
        self._func, self._args, self._kwargs = tup

    def __getitem__(self, key):
        return self.value[key]

    def __copy__(self):
        return self

    def __repr__(self):
        try:
            return 'l' + repr(self.value)
        except Exception:
            return '<%s broken>' % self.__class__.__name__


if __name__ == '__main__':
    import doctest
    doctest.testmod()

########NEW FILE########
__FILENAME__ = extscheduler
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import time
import heapq

from horizons.util.python.singleton import ManualConstructionSingleton


class _ExtCallbackObject(object):
	"""Class used by the ExtScheduler Class to organize callbacks."""

	def __init__(self, callback, class_instance, run_in=1, loops=1):
		"""Creates the CallbackObject instance.
		@param callback: lambda function callback, which is called run_in ticks.
		@param class_instance: class instance the original function(not the lambda function!) belongs to.
		@param run_in: int number of ticks after which the callback is called. Standard is 1, run next tick.
		@param loops: How often the callback is called. -1 = infinite times. Standard is 1, run once.
		"""
		self.callback = callback
		self.class_instance = class_instance
		self.run_in = run_in
		self.loops = loops

	def __str__(self):
		return "ExtSchedCb(%s on %s)" % (self.callback, self.class_instance)


class ExtScheduler(object):
	"""The ExtScheduler is used for time based events that are not part of the simulation(gui, menu, scrolling).
	To start a timed callback, call add_new_object() to make the TimingThread Class create a CallbackObject for you.
	@param pump: pump list the scheduler registers itself with.
	"""
	__metaclass__ = ManualConstructionSingleton

	NOOP = _ExtCallbackObject(lambda : 42*1337-3.14, None)

	def __init__(self, pump):
		super(ExtScheduler, self).__init__()
		self.schedule = []
		self.pump = pump
		self.pump.append(self.tick)

	def tick(self):
		"""Threads main loop
		@param tick_id: int id of the tick.
		"""
		while self.schedule:
			elem = self.schedule[0] # heap, first elem is smallest
			if elem[0] <= time.time():
				dont_use = heapq.heappop(self.schedule)
				assert dont_use is elem
				obj = elem[1]
				obj.callback()
				if obj.loops > 0 or obj.loops is -1:
					self.add_object(obj) # re-add object
			else:
				break

	def add_object(self, obj):
		"""Adds a new CallbackObject instance to the callbacks list
		@param object: CallbackObject type object, containing all necessary information
		"""
		if obj.loops > 0:
			obj.loops -= 1
		# sort by first entry, which is execution time
		heapq.heappush(self.schedule, [(time.time() + obj.run_in), obj])

	def add_new_object(self, callback, class_instance, run_in=1, loops=1):
		"""Creates a new CallbackObject instance and calls the self.add_object() function.
		@param callback: function callback, which is called run_in time.
		@param class_instance: class instance the function belongs to.
		@param run_in: float number of seconds after which the callback is called. Standard is 1, run next second.
		@param loops: How often the callback is called. -1 = infinite times. Standard is 1, run once."""
		obj = _ExtCallbackObject(callback, class_instance, run_in, loops)
		self.add_object(obj)

	def rem_all_classinst_calls(self, class_instance):
		"""Removes all callbacks from the scheduler that belong to the class instance class_inst.
		@return: number of removed callbacks"""
		for tup in self.schedule:
			if tup[1].class_instance is class_instance:
				# don't destroy heap
				tup[1] = self.__class__.NOOP

	def rem_call(self, instance, callback):
		"""Removes all callbacks of 'instance' that are 'callback'
		@param instance: the instance that would execute the call
		@param callback: the function to remove
		"""
		for tup in self.schedule:
			if tup[1].class_instance is instance and tup[1].callback == callback:
				# don't destroy heap
				tup[1] = self.__class__.NOOP

	def __del__(self):
		self.schedule = []
		self.pump.remove(self.tick)
		self.pump = None

########NEW FILE########
__FILENAME__ = globals
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

# The global Fife instance. This is used both inside a game session and in the menus.
fife = None

# The global read-only data database (includes most content/*.sql)
db = None

########NEW FILE########
__FILENAME__ = gui
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import glob
import logging
from collections import deque

from fife.extensions.pychan.widgets import Icon

import horizons.globals
import horizons.main
from horizons.gui.keylisteners import MainListener
from horizons.gui.widgets.pickbeltwidget import CreditsPickbeltWidget
from horizons.util.startgameoptions import StartGameOptions
from horizons.messaging import GuiAction
from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.gui.util import load_uh_widget
from horizons.gui.modules.editorstartmenu import EditorStartMenu
from horizons.gui.modules import (HelpDialog, SingleplayerMenu, MultiplayerMenu,
                                  SelectSavegameDialog, LoadingScreen, SettingsDialog)
from horizons.gui.widgets.fpsdisplay import FPSDisplay
from horizons.gui.windows import WindowManager, Window


class MainMenu(Window):

	def __init__(self, gui, windows):
		super(MainMenu, self).__init__(windows)

		self._gui = load_uh_widget('mainmenu.xml', 'menu')
		self._gui.mapEvents({
			'single_button': lambda: self._windows.open(gui.singleplayermenu),
			'single_label' : lambda: self._windows.open(gui.singleplayermenu),
			'multi_button': lambda: self._windows.open(gui.multiplayermenu),
			'multi_label' : lambda: self._windows.open(gui.multiplayermenu),
			'settings_button': lambda: self._windows.open(gui.settings_dialog),
			'settings_label' : lambda: self._windows.open(gui.settings_dialog),
			'help_button': gui.on_help,
			'help_label' : gui.on_help,
			'quit_button': self.on_escape,
			'quit_label' : self.on_escape,
			'editor_button': gui.show_editor_start_menu,
			'editor_label' : gui.show_editor_start_menu,
			'credits_button': gui.show_credits,
			'credits_label' : gui.show_credits,
			'load_button': gui.load_game,
			'load_label' : gui.load_game,
			'changeBackground' : gui.rotate_background,
		})

	def show(self):
		self._gui.show()

	def hide(self):
		self._gui.hide()

	def on_escape(self):
		"""Shows the quit dialog. Closes the game unless the dialog is cancelled."""
		message = _("Are you sure you want to quit Unknown Horizons?")
		if self._windows.open_popup(_("Quit Game"), message, show_cancel_button=True):
			horizons.main.quit()


class Gui(object):
	"""This class handles all the out of game menu, like the main and pause menu, etc.
	"""
	log = logging.getLogger("gui")

	def __init__(self):
		self.mainlistener = MainListener(self)

		self.windows = WindowManager()
		# temporary aliases for compatibility with rest of the code
		self.open_popup = self.windows.open_popup
		self.open_error_popup = self.windows.open_error_popup

		# Main menu background image setup.
		available_images = glob.glob('content/gui/images/background/mainmenu/bg_*.png')
		self.bg_images = deque(available_images)

		latest_bg = horizons.globals.fife.get_uh_setting("LatestBackground")
		try:
			# If we know the current background from an earlier session,
			# show all other available ones before picking that one again.
			self.bg_images.remove(latest_bg)
			self.bg_images.append(latest_bg)
		except ValueError:
			pass
		self._background = Icon(position_technique='center:center')
		self.rotate_background()
		self._background.show()

		# Initialize menu dialogs and widgets that are accessed from `gui`.
		self.singleplayermenu = SingleplayerMenu(self.windows)
		self.multiplayermenu = MultiplayerMenu(self, self.windows)
		self.help_dialog = HelpDialog(self.windows)
		self.loadingscreen = LoadingScreen()
		self.settings_dialog = SettingsDialog(self.windows)
		self.mainmenu = MainMenu(self, self.windows)
		self.fps_display = FPSDisplay()

	def show_main(self):
		"""Shows the main menu """
		GuiAction.subscribe(self._on_gui_action)

		if not self._background.isVisible():
			self._background.show()

		self.windows.open(self.mainmenu)

	def show_select_savegame(self, mode):
		window = SelectSavegameDialog(mode, self.windows)
		return self.windows.open(window)

	def load_game(self):
		saved_game = self.show_select_savegame(mode='load')
		if saved_game is None:
			return False # user aborted dialog

		options = StartGameOptions(saved_game)
		horizons.main.start_singleplayer(options)
		return True

	def on_help(self):
		self.windows.toggle(self.help_dialog)

	def show_credits(self):
		"""Shows the credits dialog. """
		window = CreditsPickbeltWidget(self.windows)
		self.windows.open(window)

	def on_escape(self):
		self.windows.on_escape()

	def on_return(self):
		self.windows.on_return()

	def close_all(self):
		GuiAction.discard(self._on_gui_action)
		self.windows.close_all()
		self._background.hide()

	def show_loading_screen(self):
		if not self._background.isVisible():
			self._background.show()
		self.windows.open(self.loadingscreen)

	def rotate_background(self):
		"""Select next background image to use in the game menu.

		Triggered by the "Change background" main menu button.
		"""
		# Note: bg_images is a deque.
		self.bg_images.rotate(1)
		self._background.image = self.bg_images[0]
		# Save current background choice to settings.
		# This keeps the background image consistent between sessions.
		horizons.globals.fife.set_uh_setting("LatestBackground", self.bg_images[0])
		horizons.globals.fife.save_settings()

	def _on_gui_action(self, msg):
		AmbientSoundComponent.play_special('click')

	def show_editor_start_menu(self):
		editor_start_menu = EditorStartMenu(self.windows)
		self.windows.open(editor_start_menu)

########NEW FILE########
__FILENAME__ = i18n
# ###################################################
# Copyright (C) 2013 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import weakref

from horizons.gui import translations
from horizons.messaging import LanguageChanged

log = logging.getLogger("i18n")

# save translated widgets
translated_widgets = {}

def translate_widget(untranslated, filename):
	"""
	Load widget translations from guitranslations.py file.
	Its entries look like {element_name: (attribute, translation)}.
	The translation is not applied to inactive widgets.
	Check update_all_translations for the application.
	"""
	global translated_widgets
	if filename in translations.text_translations:
		for entry in translations.text_translations[filename].iteritems():
			widget = untranslated.findChild(name=entry[0][0])
			if widget is not None:
				replace_attribute(widget, entry[0][1], entry[1])
				widget.adaptLayout()
	else:
		log.debug('No translation key in i18n.guitranslations for file %s', filename)

	# save as weakref for updates to translations
	translated_widgets[filename] = weakref.ref(untranslated)

	return untranslated


def replace_attribute(widget, attribute, text):
	if hasattr(widget, attribute):
		setattr(widget, attribute, text)
	else:
		log.warning("Could not replace attribute %s in widget %s", attribute, widget)


def update_translations(message):
	global translated_widgets
	translations.set_translations()

	for (filename, widget) in translated_widgets.iteritems():
		widget = widget() # resolve weakref
		if not widget:
			continue
		all_widgets = translations.text_translations.get(filename, {})
		for (element_name, attribute), translation in all_widgets.iteritems():
			element = widget.findChild(name=element_name)
			if element is None:
				# something hidden by pychan currently, we cannot find it
				log.debug('Could not find element `%s` in widget `%s` - '
				          'assuming it is hidden', element_name, widget)
				continue
			replace_attribute(element, attribute, translation)
			#NOTE pychan + reloading font = ???
			element.font = element.font
		widget.adaptLayout()


LanguageChanged.subscribe(update_translations)

########NEW FILE########
__FILENAME__ = ingamegui
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife

import horizons.globals
from horizons.command.game import SpeedDownCommand, SpeedUpCommand, TogglePauseCommand
from horizons.component.selectablecomponent import SelectableComponent
from horizons.constants import BUILDINGS, GAME_SPEED, HOTKEYS, VERSION, LAYERS, VIEW
from horizons.entities import Entities
from horizons.gui import mousetools
from horizons.gui.keylisteners import IngameKeyListener, KeyConfig
from horizons.gui.modules import PauseMenu, HelpDialog, SelectSavegameDialog
from horizons.gui.modules.ingame import ChatDialog, ChangeNameDialog, CityInfo
from horizons.gui.tabs import TabWidget, BuildTab, DiplomacyTab, SelectMultiTab
from horizons.gui.tabs import resolve_tab
from horizons.gui.tabs.tabinterface import TabInterface
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.logbook import LogBook
from horizons.gui.widgets.messagewidget import MessageWidget
from horizons.gui.widgets.minimap import Minimap
from horizons.gui.widgets.playersoverview import PlayersOverview
from horizons.gui.widgets.playerssettlements import PlayersSettlements
from horizons.gui.widgets.playersships import PlayersShips
from horizons.gui.widgets.resourceoverviewbar import ResourceOverviewBar
from horizons.gui.windows import WindowManager
from horizons.messaging import (TabWidgetChanged, SpeedChanged, NewDisaster, MineEmpty,
                                NewSettlement, PlayerLevelUpgrade, ZoomChanged)
from horizons.util.lastactiveplayersettlementmanager import LastActivePlayerSettlementManager
from horizons.util.living import livingProperty, LivingObject
from horizons.util.python.callback import Callback
from horizons.util.worldobject import WorldObject
from horizons.world.managers.productionfinishediconmanager import ProductionFinishedIconManager
from horizons.world.managers.statusiconmanager import StatusIconManager


class IngameGui(LivingObject):
	"""Class handling all the ingame gui events.
	Assumes that only 1 instance is used (class variables)"""

	message_widget = livingProperty()
	minimap = livingProperty()
	keylistener = livingProperty()

	def __init__(self, session):
		super(IngameGui, self).__init__()
		self.session = session
		assert isinstance(self.session, horizons.session.Session)
		self.settlement = None
		self._old_menu = None

		self.cursor = None
		self.coordinates_tooltip = None

		self.keylistener = IngameKeyListener(self.session)

		self.cityinfo = CityInfo(self)
		LastActivePlayerSettlementManager.create_instance(self.session)

		self.message_widget = MessageWidget(self.session)

		# Windows
		self.windows = WindowManager()
		self.open_popup = self.windows.open_popup
		self.open_error_popup = self.windows.open_error_popup

		self.logbook = LogBook(self.session, self.windows)
		self.players_overview = PlayersOverview(self.session)
		self.players_settlements = PlayersSettlements(self.session)
		self.players_ships = PlayersShips(self.session)

		self.chat_dialog = ChatDialog(self.windows, self.session)
		self.change_name_dialog = ChangeNameDialog(self.windows, self.session)
		self.pausemenu = PauseMenu(self.session, self, self.windows, in_editor_mode=False)
		self.help_dialog = HelpDialog(self.windows)

		# Icon manager
		self.status_icon_manager = StatusIconManager(
			renderer=self.session.view.renderer['GenericRenderer'],
			layer=self.session.view.layers[LAYERS.OBJECTS]
		)
		self.production_finished_icon_manager = ProductionFinishedIconManager(
			renderer=self.session.view.renderer['GenericRenderer'],
			layer=self.session.view.layers[LAYERS.OBJECTS]
		)

		# 'minimap' is the guichan gui around the actual minimap, which is saved
		# in self.minimap
		self.mainhud = load_uh_widget('minimap.xml')
		self.mainhud.position_technique = "right:top"

		icon = self.mainhud.findChild(name="minimap")
		self.minimap = Minimap(icon,
		                       targetrenderer=horizons.globals.fife.targetrenderer,
		                       imagemanager=horizons.globals.fife.imagemanager,
		                       session=self.session,
		                       view=self.session.view)

		def speed_up():
			SpeedUpCommand().execute(self.session)

		def speed_down():
			SpeedDownCommand().execute(self.session)

		self.mainhud.mapEvents({
			'zoomIn' : self.session.view.zoom_in,
			'zoomOut' : self.session.view.zoom_out,
			'rotateRight' : Callback.ChainedCallbacks(self.session.view.rotate_right, self.minimap.rotate_right),
			'rotateLeft' : Callback.ChainedCallbacks(self.session.view.rotate_left, self.minimap.rotate_left),
			'speedUp' : speed_up,
			'speedDown' : speed_down,
			'destroy_tool' : self.toggle_destroy_tool,
			'build' : self.show_build_menu,
			'diplomacyButton' : self.show_diplomacy_menu,
			'gameMenuButton' : self.toggle_pause,
			'logbook' : lambda: self.windows.toggle(self.logbook)
		})
		self.mainhud.show()

		hotkey_replacements = {
			'rotateRight': 'ROTATE_RIGHT',
			'rotateLeft': 'ROTATE_LEFT',
			'speedUp': 'SPEED_UP',
			'speedDown': 'SPEED_DOWN',
			'destroy_tool': 'DESTROY_TOOL',
			'build': 'BUILD_TOOL',
			'gameMenuButton': 'ESCAPE',
			'logbook': 'LOGBOOK',
		}
		for (widgetname, action) in hotkey_replacements.iteritems():
			widget = self.mainhud.findChild(name=widgetname)
			keys = horizons.globals.fife.get_keys_for_action(action)
			# No `.upper()` here: "Pause" looks better than "PAUSE".
			keyname = HOTKEYS.DISPLAY_KEY.get(keys[0], keys[0].capitalize())
			widget.helptext = widget.helptext.format(key=keyname)

		self.resource_overview = ResourceOverviewBar(self.session)

		# Register for messages
		SpeedChanged.subscribe(self._on_speed_changed)
		NewDisaster.subscribe(self._on_new_disaster)
		NewSettlement.subscribe(self._on_new_settlement)
		PlayerLevelUpgrade.subscribe(self._on_player_level_upgrade)
		MineEmpty.subscribe(self._on_mine_empty)
		ZoomChanged.subscribe(self._update_zoom)

		self._display_speed(self.session.timer.ticks_per_second)

	def end(self):
		# unsubscribe early, to avoid messages coming in while we're shutting down
		SpeedChanged.unsubscribe(self._on_speed_changed)
		NewDisaster.unsubscribe(self._on_new_disaster)
		NewSettlement.unsubscribe(self._on_new_settlement)
		PlayerLevelUpgrade.unsubscribe(self._on_player_level_upgrade)
		MineEmpty.unsubscribe(self._on_mine_empty)
		ZoomChanged.unsubscribe(self._update_zoom)

		self.mainhud.mapEvents({
			'zoomIn' : None,
			'zoomOut' : None,
			'rotateRight' : None,
			'rotateLeft': None,

			'destroy_tool' : None,
			'build' : None,
			'diplomacyButton' : None,
			'gameMenuButton' : None
		})
		self.mainhud.hide()
		self.mainhud = None

		self.windows.close_all()
		self.message_widget = None
		self.minimap = None
		self.resource_overview.end()
		self.resource_overview = None
		self.keylistener = None
		self.cityinfo.end()
		self.cityinfo = None
		self.hide_menu()

		if self.cursor:
			self.cursor.remove()
			self.cursor.end()
			self.cursor = None

		LastActivePlayerSettlementManager().remove()
		LastActivePlayerSettlementManager.destroy_instance()

		self.production_finished_icon_manager.end()
		self.production_finished_icon_manager = None
		self.status_icon_manager.end()
		self.status_icon_manager = None

		super(IngameGui, self).end()

	def show_select_savegame(self, mode):
		window = SelectSavegameDialog(mode, self.windows)
		return self.windows.open(window)

	def toggle_pause(self):
		self.windows.toggle(self.pausemenu)

	def toggle_help(self):
		self.windows.toggle(self.help_dialog)

	def minimap_to_front(self):
		"""Make sure the full right top gui is visible and not covered by some dialog"""
		self.mainhud.hide()
		self.mainhud.show()

	def show_diplomacy_menu(self):
		# check if the menu is already shown
		if getattr(self.get_cur_menu(), 'name', None) == "diplomacy_widget":
			self.hide_menu()
			return

		if not DiplomacyTab.is_useable(self.session.world):
			self.windows.open_popup(_("No diplomacy possible"),
			                        _("Cannot do diplomacy as there are no other players."))
			return

		tab = DiplomacyTab(self, self.session.world)
		self.show_menu(tab)

	def show_multi_select_tab(self, instances):
		tab = TabWidget(self, tabs=[SelectMultiTab(instances)], name='select_multi')
		self.show_menu(tab)

	def show_build_menu(self, update=False):
		"""
		@param update: set when build possibilities change (e.g. after inhabitant tier upgrade)
		"""
		# check if build menu is already shown
		if hasattr(self.get_cur_menu(), 'name') and self.get_cur_menu().name == "build_menu_tab_widget":
			self.hide_menu()

			if not update: # this was only a toggle call, don't reshow
				return

		self.set_cursor() # set default cursor for build menu
		self.deselect_all()

		if not any( settlement.owner.is_local_player for settlement in self.session.world.settlements):
			# player has not built any settlements yet. Accessing the build menu at such a point
			# indicates a mistake in the mental model of the user. Display a hint.
			tab = TabWidget(self, tabs=[ TabInterface(widget="buildtab_no_settlement.xml") ])
		else:
			btabs = BuildTab.create_tabs(self.session, self._build)
			tab = TabWidget(self, tabs=btabs, name="build_menu_tab_widget",
											active_tab=BuildTab.last_active_build_tab)
		self.show_menu(tab)

	def deselect_all(self):
		for instance in self.session.selected_instances:
			instance.get_component(SelectableComponent).deselect()
		self.session.selected_instances.clear()

	def _build(self, building_id, unit=None):
		"""Calls the games buildingtool class for the building_id.
		@param building_id: int with the building id that is to be built.
		@param unit: weakref to the unit, that builds (e.g. ship for warehouse)"""
		self.hide_menu()
		self.deselect_all()
		cls = Entities.buildings[building_id]
		if hasattr(cls, 'show_build_menu'):
			cls.show_build_menu()
		self.set_cursor('building', cls, None if unit is None else unit())

	def toggle_road_tool(self):
		if not isinstance(self.cursor, mousetools.BuildingTool) or self.cursor._class.id != BUILDINGS.TRAIL:
			self._build(BUILDINGS.TRAIL)
		else:
			self.set_cursor()

	def get_cur_menu(self):
		"""Returns menu that is currently displayed"""
		return self._old_menu

	def show_menu(self, menu):
		"""Shows a menu
		@param menu: str with the guiname or pychan object.
		"""
		if self._old_menu is not None:
			if hasattr(self._old_menu, "remove_remove_listener"):
				self._old_menu.remove_remove_listener( Callback(self.show_menu, None) )
			self._old_menu.hide()

		self._old_menu = menu
		if self._old_menu is not None:
			if hasattr(self._old_menu, "add_remove_listener"):
				self._old_menu.add_remove_listener( Callback(self.show_menu, None) )
			self._old_menu.show()
			self.minimap_to_front()

		TabWidgetChanged.broadcast(self)

	def hide_menu(self):
		self.show_menu(None)

	def save(self, db):
		self.message_widget.save(db)
		self.logbook.save(db)
		self.resource_overview.save(db)
		LastActivePlayerSettlementManager().save(db)
		self.save_selection(db)

	def save_selection(self, db):
		# Store instances that are selected right now.
		for instance in self.session.selected_instances:
			db("INSERT INTO selected (`group`, id) VALUES (NULL, ?)", instance.worldid)

		# If a single instance is selected, also store the currently displayed tab.
		# (Else, upon restoring, we display a multi-selection tab.)
		tabname = None
		if len(self.session.selected_instances) == 1:
			tabclass = self.get_cur_menu().current_tab
			tabname = tabclass.__class__.__name__
		db("INSERT INTO metadata (name, value) VALUES (?, ?)", 'selected_tab', tabname)

		# Store user defined unit selection groups (Ctrl+number)
		for (number, group) in enumerate(self.session.selection_groups):
			for instance in group:
				db("INSERT INTO selected (`group`, id) VALUES (?, ?)", number, instance.worldid)

	def load(self, db):
		self.message_widget.load(db)
		self.logbook.load(db)
		self.resource_overview.load(db)

		if self.session.is_game_loaded():
			LastActivePlayerSettlementManager().load(db)
			cur_settlement = LastActivePlayerSettlementManager().get_current_settlement()
			self.cityinfo.set_settlement(cur_settlement)

		self.minimap.draw() # update minimap to new world

		self.current_cursor = 'default'
		self.cursor = mousetools.SelectionTool(self.session)
		# Set cursor correctly, menus might need to be opened.
		# Open menus later; they may need unit data not yet inited
		self.cursor.apply_select()

		self.load_selection(db)

		if not self.session.is_game_loaded():
			# Fire a message for new world creation
			self.message_widget.add('NEW_WORLD')

		# Show message when the relationship between players changed
		def notify_change(caller, old_state, new_state, a, b):
			player1 = u"%s" % a.name
			player2 = u"%s" % b.name

			data = {'player1' : player1, 'player2' : player2}

			string_id = 'DIPLOMACY_STATUS_{old}_{new}'.format(old=old_state.upper(),
			                                                  new=new_state.upper())
			self.message_widget.add(string_id=string_id, message_dict=data)

		self.session.world.diplomacy.add_diplomacy_status_changed_listener(notify_change)

	def load_selection(self, db):
		# Re-select old selected instance
		for (instance_id, ) in db("SELECT id FROM selected WHERE `group` IS NULL"):
			obj = WorldObject.get_object_by_id(instance_id)
			self.session.selected_instances.add(obj)
			obj.get_component(SelectableComponent).select()

		# Re-show old tab (if there was one) or multiselection
		if len(self.session.selected_instances) == 1:
			tabname = db("SELECT value FROM metadata WHERE name = ?",
			             'selected_tab')[0][0]
			# This can still be None due to old savegames not storing the information
			tabclass = None if tabname is None else resolve_tab(tabname)
			obj.get_component(SelectableComponent).show_menu(jump_to_tabclass=tabclass)
		elif self.session.selected_instances:
			self.show_multi_select_tab(self.session.selected_instances)

		# Load user defined unit selection groups (Ctrl+number)
		for (num, group) in enumerate(self.session.selection_groups):
			for (instance_id, ) in db("SELECT id FROM selected WHERE `group` = ?", num):
				obj = WorldObject.get_object_by_id(instance_id)
				group.add(obj)

	def show_change_name_dialog(self, instance):
		"""Shows a dialog where the user can change the name of an object."""
		self.windows.open(self.change_name_dialog, instance=instance)

	def on_escape(self):
		if self.windows.visible:
			self.windows.on_escape()
		elif hasattr(self.cursor, 'on_escape'):
			self.cursor.on_escape()
		else:
			self.toggle_pause()

		return True

	def on_return(self):
		if self.windows.visible:
			self.windows.on_return()

		return True

	def _on_speed_changed(self, message):
		self._display_speed(message.new)

	def _display_speed(self, tps):
		text = u''
		up_icon = self.mainhud.findChild(name='speedUp')
		down_icon = self.mainhud.findChild(name='speedDown')
		if tps == 0: # pause
			text = u'0x'
			up_icon.set_inactive()
			down_icon.set_inactive()
		else:
			if tps != GAME_SPEED.TICKS_PER_SECOND:
				text = u"%1gx" % (tps * 1.0/GAME_SPEED.TICKS_PER_SECOND)
				#%1g: displays 0.5x, but 2x instead of 2.0x
			index = GAME_SPEED.TICK_RATES.index(tps)
			if index + 1 >= len(GAME_SPEED.TICK_RATES):
				up_icon.set_inactive()
			else:
				up_icon.set_active()
			if index > 0:
				down_icon.set_active()
			else:
				down_icon.set_inactive()

		wdg = self.mainhud.findChild(name="speed_text")
		wdg.text = text
		wdg.resizeToContent()
		self.mainhud.show()

	def on_key_press(self, action, evt):
		"""Handle a key press in-game.

		Returns True if the key was acted upon.
		"""
		_Actions = KeyConfig._Actions
		keyval = evt.getKey().getValue()

		if action == _Actions.ESCAPE:
			return self.on_escape()		
		elif keyval == fife.Key.ENTER:
			return self.on_return()

		if action == _Actions.GRID:
			gridrenderer = self.session.view.renderer['GridRenderer']
			gridrenderer.setEnabled( not gridrenderer.isEnabled() )
		elif action == _Actions.COORD_TOOLTIP:
			self.coordinates_tooltip.toggle()
		elif action == _Actions.DESTROY_TOOL:
			self.toggle_destroy_tool()
		elif action == _Actions.REMOVE_SELECTED:
			message = _(u"Are you sure you want to delete these objects?")
			if self.windows.open_popup(_(u"Delete"), message, show_cancel_button=True):
				self.session.remove_selected()
			else:
				self.deselect_all()
		elif action == _Actions.ROAD_TOOL:
			self.toggle_road_tool()
		elif action == _Actions.SPEED_UP:
			SpeedUpCommand().execute(self.session)
		elif action == _Actions.SPEED_DOWN:
			SpeedDownCommand().execute(self.session)
		elif action == _Actions.ZOOM_IN:
			self.session.view.zoom_in()
		elif action == _Actions.ZOOM_OUT:
			self.session.view.zoom_out()
		elif action == _Actions.PAUSE:
			TogglePauseCommand().execute(self.session)
		elif action == _Actions.PLAYERS_OVERVIEW:
			self.logbook.toggle_stats_visibility(widget='players')
		elif action == _Actions.SETTLEMENTS_OVERVIEW:
			self.logbook.toggle_stats_visibility(widget='settlements')
		elif action == _Actions.SHIPS_OVERVIEW:
			self.logbook.toggle_stats_visibility(widget='ships')
		elif action == _Actions.LOGBOOK:
			self.windows.toggle(self.logbook)
		elif action == _Actions.DEBUG and VERSION.IS_DEV_VERSION:
			import pdb; pdb.set_trace()
		elif action == _Actions.BUILD_TOOL:
			self.show_build_menu()
		elif action == _Actions.ROTATE_RIGHT:
			if hasattr(self.cursor, "rotate_right"):
				# used in e.g. build preview to rotate building instead of map
				self.cursor.rotate_right()
			else:
				self.session.view.rotate_right()
				self.minimap.rotate_right()
		elif action == _Actions.ROTATE_LEFT:
			if hasattr(self.cursor, "rotate_left"):
				self.cursor.rotate_left()
			else:
				self.session.view.rotate_left()
				self.minimap.rotate_left()
		elif action == _Actions.CHAT:
			self.windows.open(self.chat_dialog)
		elif action == _Actions.TRANSLUCENCY:
			self.session.world.toggle_translucency()
		elif action == _Actions.TILE_OWNER_HIGHLIGHT:
			self.session.world.toggle_owner_highlight()
		elif fife.Key.NUM_0 <= keyval <= fife.Key.NUM_9:
			num = int(keyval - fife.Key.NUM_0)
			self.handle_selection_group(num, evt.isControlPressed())
		elif action == _Actions.QUICKSAVE:
			self.session.quicksave()
		# Quickload is only handled by the MainListener.
		elif action == _Actions.PIPETTE:
			# Mode that allows copying buildings.
			self.toggle_cursor('pipette')
		elif action == _Actions.HEALTH_BAR:
			# Show health bar of every instance with a health component.
			self.session.world.toggle_health_for_all_health_instances()
		elif action == _Actions.SHOW_SELECTED:
			if self.session.selected_instances:
				# Scroll to first one, we can never guarantee to display all selected units.
				instance = iter(self.session.selected_instances).next()
				self.session.view.center( * instance.position.center.to_tuple())
				for instance in self.session.selected_instances:
					if hasattr(instance, "path") and instance.owner.is_local_player:
						self.minimap.show_unit_path(instance)
		elif action == _Actions.HELP:
			self.toggle_help()
		else:
			return False

		return True

	def handle_selection_group(self, num, ctrl_pressed):
		"""Select existing or assign new unit selection group.

		Ctrl+number creates or overwrites the group of number `num`
		with the currently selected units.
		Pressing the associated key selects a group and centers the
		camera around these units.
		"""
		if ctrl_pressed:
			# Only consider units owned by the player.
			units = set(u for u in self.session.selected_instances
			            if u.owner.is_local_player)
			self.session.selection_groups[num] = units
			# Drop units of the new group from all other groups.
			for group in self.session.selection_groups:
				current_group = self.session.selection_groups[num]
				if group != current_group:
					group -= current_group
		else:
			# We need to make sure to have a cursor capable of selection
			# for apply_select() to work.
			# This handles deselection implicitly in the destructor.
			self.set_cursor('selection')
			# Apply new selection.
			for instance in self.session.selection_groups[num]:
				instance.get_component(SelectableComponent).select(reset_cam=True)
			# Assign copy since it will be randomly changed in selection code.
			# The unit group itself should only be changed on Ctrl events.
			self.session.selected_instances = self.session.selection_groups[num].copy()
			# Show correct tabs depending on what's selected.
			if self.session.selected_instances:
				self.cursor.apply_select()
			else:
				# Nothing is selected here. Hide the menu since apply_select
				# doesn't handle that case.
				self.show_menu(None)

	def toggle_cursor(self, which):
		"""Alternate between the cursor *which* and the default cursor."""
		if which == self.current_cursor:
			self.set_cursor()
		else:
			self.set_cursor(which)

	def set_cursor(self, which='default', *args, **kwargs):
		"""Sets the mousetool (i.e. cursor).
		This is done here for encapsulation and control over destructors.
		Further arguments are passed to the mouse tool constructor."""
		self.cursor.remove()
		self.current_cursor = which
		klass = {
			'default'        : mousetools.SelectionTool,
			'selection'      : mousetools.SelectionTool,
			'tearing'        : mousetools.TearingTool,
			'pipette'        : mousetools.PipetteTool,
			'attacking'      : mousetools.AttackingTool,
			'building'       : mousetools.BuildingTool,
		}[which]
		self.cursor = klass(self.session, *args, **kwargs)

	def toggle_destroy_tool(self):
		"""Initiate the destroy tool"""
		self.toggle_cursor('tearing')

	def _update_zoom(self, message):
		"""Enable/disable zoom buttons"""
		in_icon = self.mainhud.findChild(name='zoomIn')
		out_icon = self.mainhud.findChild(name='zoomOut')
		if message.zoom == VIEW.ZOOM_MIN:
			out_icon.set_inactive()
		else:
			out_icon.set_active()
		if message.zoom == VIEW.ZOOM_MAX:
			in_icon.set_inactive()
		else:
			in_icon.set_active()

	def _on_new_disaster(self, message):
		"""Called when a building is 'infected' with a disaster."""
		if message.building.owner.is_local_player and len(message.disaster._affected_buildings) == 1:
			pos = message.building.position.center
			self.message_widget.add(point=pos, string_id=message.disaster_class.NOTIFICATION_TYPE)

	def _on_new_settlement(self, message):
		player = message.settlement.owner
		self.message_widget.add(
			string_id='NEW_SETTLEMENT',
			point=message.warehouse_position,
			message_dict={'player': player.name},
			play_sound=player.is_local_player
		)

	def _on_player_level_upgrade(self, message):
		"""Called when a player's population reaches a new level."""
		if not message.sender.is_local_player:
			return

		# show notification
		self.message_widget.add(
			point=message.building.position.center,
			string_id='SETTLER_LEVEL_UP',
			message_dict={'level': message.level + 1}
		)

		# update build menu to show new buildings
		menu = self.get_cur_menu()
		if hasattr(menu, "name") and menu.name == "build_menu_tab_widget":
			self.show_build_menu(update=True)

	def _on_mine_empty(self, message):
		self.message_widget.add(point=message.mine.position.center, string_id='MINE_EMPTY')

########NEW FILE########
__FILENAME__ = ingamekeylistener
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife
import horizons.globals

from horizons.util.living import LivingObject
from horizons.gui.keylisteners import KeyConfig

class IngameKeyListener(fife.IKeyListener, LivingObject):
	"""KeyListener Class to process key presses ingame"""

	def __init__(self, session):
		super(IngameKeyListener, self).__init__()
		from horizons.session import Session
		assert isinstance(session, Session)
		self.session = session
		horizons.globals.fife.eventmanager.addKeyListenerFront(self)
		self.keys_pressed = []
		# Used to sum up the keyboard autoscrolling
		self.key_scroll = [0, 0]

	def end(self):
		horizons.globals.fife.eventmanager.removeKeyListener(self)
		self.session = None
		super(IngameKeyListener, self).end()

	def keyPressed(self, evt):
		keyval = evt.getKey().getValue()
		action = KeyConfig().translate(evt)

		_Actions = KeyConfig._Actions

		was_pressed = keyval in self.keys_pressed
		if not was_pressed:
			self.keys_pressed.append(keyval)
			if action == _Actions.LEFT:
				self.key_scroll[0] -= 25
			if action == _Actions.RIGHT:
				self.key_scroll[0] += 25
			if action == _Actions.UP:
				self.key_scroll[1] -= 25
			if action == _Actions.DOWN:
				self.key_scroll[1] += 25

		# We scrolled, do autoscroll
		if self.key_scroll[0] != 0 or self.key_scroll[1] != 0:
			self.session.view.autoscroll_keys(*self.key_scroll)

		if self.session.ingame_gui.on_key_press(action, evt):
			evt.consume() # prevent other listeners from being called

	def keyReleased(self, evt):
		keyval = evt.getKey().getValue()
		_Actions = KeyConfig._Actions
		action = KeyConfig().translate(evt)
		try:
			self.keys_pressed.remove(keyval)
		except Exception:
			return
		stop_horizontal = action in (_Actions.LEFT, _Actions.RIGHT)
		stop_vertical = action in (_Actions.UP, _Actions.DOWN)
		if stop_horizontal:
			self.key_scroll[0] = 0
		elif stop_vertical:
			self.key_scroll[1] = 0
		self.session.view.autoscroll_keys(*self.key_scroll)

########NEW FILE########
__FILENAME__ = keyconfig
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
from string import ascii_uppercase

from fife import fife

import horizons.globals
from horizons.ext.enum import Enum
from horizons.util.python.singleton import Singleton

class KeyConfig(object):
	"""Class for storing key bindings.
	The central function is translate().
	"""
	__metaclass__ = Singleton

	_Actions = Enum('LEFT', 'RIGHT', 'UP', 'DOWN',
	                'ROTATE_LEFT', 'ROTATE_RIGHT', 'SPEED_UP', 'SPEED_DOWN', 'PAUSE',
	                'ZOOM_IN', 'ZOOM_OUT',
	                'BUILD_TOOL', 'DESTROY_TOOL', 'ROAD_TOOL', 'PIPETTE',
	                'PLAYERS_OVERVIEW', 'SETTLEMENTS_OVERVIEW', 'SHIPS_OVERVIEW',
	                'LOGBOOK', 'CHAT',
	                'QUICKSAVE', 'QUICKLOAD', 'ESCAPE',
	                'TRANSLUCENCY', 'TILE_OWNER_HIGHLIGHT',
	                'HEALTH_BAR', 'SHOW_SELECTED', 'REMOVE_SELECTED',
	                'HELP', 'SCREENSHOT',
	                'DEBUG', 'CONSOLE', 'GRID', 'COORD_TOOLTIP')

	def __init__(self):
		_Actions = self._Actions
		self.log = logging.getLogger("gui.keys")

		self.all_keys = self.get_keys_by_name()
		# map key ID (int) to action it triggers (int)
		self.keyval_action_mappings = {}
		self.loadKeyConfiguration()

		self.requires_shift = set([_Actions.DEBUG])

	def loadKeyConfiguration(self):
		self.keyval_action_mappings = {}
		custom_key_actions = horizons.globals.fife.get_hotkey_settings()
		for action in custom_key_actions:
			action_id = getattr(self._Actions, action, None)
			if action_id is None:
				self.log.warning('Unknown hotkey in settings: %s', action)
				continue

			keys_for_action = horizons.globals.fife.get_keys_for_action(action)
			for key in keys_for_action:
				key_id = self.get_key_by_name(key.upper())
				self.keyval_action_mappings[key_id] = action_id

	def translate(self, evt):
		"""
		@param evt: fife.Event
		@return pseudo-enum _Action
		"""
		keyval = evt.getKey().getValue()

		if keyval in self.keyval_action_mappings:
			action = self.keyval_action_mappings[keyval]
		else:
			return None

		if action in self.requires_shift and not evt.isShiftPressed():
			return None
		else:
			return action # all checks passed

	def get_key_by_name(self, keyname):
		return self.all_keys.get(keyname)

	def get_keys_by_name(self):
		def is_available(key):
			special_keys = ('WORLD_', 'ENTER', 'ALT', 'COMPOSE',
			                'LEFT_', 'RIGHT_', 'POWER', 'INVALID_KEY')
			return (key.startswith(tuple(ascii_uppercase)) and
			        not key.startswith(special_keys))
		return dict((k, v) for k, v in fife.Key.__dict__.iteritems()
		                   if is_available(k))

	def get_keys_by_value(self):
		def is_available(key):
			special_keys = ('WORLD_', 'ENTER', 'ALT', 'COMPOSE',
			                'LEFT_', 'RIGHT_', 'POWER', 'INVALID_KEY')
			return (key.startswith(tuple(ascii_uppercase)) and
			        not key.startswith(special_keys))
		return dict((v, k) for k, v in fife.Key.__dict__.iteritems()
		                   if is_available(k))

	def get_keyval_to_actionid_map(self):
		return self.keyval_action_mappings

	def get_current_keys(self, action):
		return horizons.globals.fife.get_keys_for_action(action)

	def get_default_keys(self, action):
		return horizons.globals.fife.get_keys_for_action(action, default=True)

	def get_actions_by_name(self):
		"""Returns a list of the names of all the actions"""
		return [str(x) for x in self._Actions]

	def get_bindable_actions_by_name(self):
		"""Returns a list of the names of the actions which can be binded in the hotkeys interface"""
		actions = [str(x) for x in self._Actions]
		unbindable_actions = ['DEBUG', 'ESCAPE']
		for action in unbindable_actions:
			actions.remove(action)
		return actions

########NEW FILE########
__FILENAME__ = mainlistener
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife
import datetime
import shutil
import os
import os.path
import tempfile

import horizons.globals
import horizons.main

from horizons.gui.keylisteners import KeyConfig
from horizons.util.living import LivingObject
from horizons.constants import PATHS

class MainListener(fife.IKeyListener, fife.ICommandListener, LivingObject):
	"""MainListener Class to process events of main window"""

	def __init__(self, gui):
		super(MainListener, self).__init__()
		self.gui = gui
		fife.IKeyListener.__init__(self)
		horizons.globals.fife.eventmanager.addKeyListener(self)
		fife.ICommandListener.__init__(self)
		horizons.globals.fife.eventmanager.addCommandListener(self)

	def end(self):
		horizons.globals.fife.eventmanager.removeKeyListener(self)
		super(MainListener, self).end()

	def keyPressed(self, evt):
		if evt.isConsumed():
			return

		action = KeyConfig().translate(evt)
		_Actions = KeyConfig._Actions
		keyval = evt.getKey().getValue()

		key_event_handled = True

		if action == _Actions.ESCAPE:
			self.gui.on_escape()
		elif keyval == fife.Key.ENTER:
			self.gui.on_return()
		elif action == _Actions.CONSOLE:
			self.gui.fps_display.toggle()
		elif action == _Actions.HELP:
			self.gui.on_help()
		elif action == _Actions.SCREENSHOT:
			# save the screenshot into a temporary file because fife doesn't support unicode paths
			temp_handle, temp_path = tempfile.mkstemp()
			os.close(temp_handle)
			horizons.globals.fife.engine.getRenderBackend().captureScreen(temp_path)

			# move the screenshot into the final location
			filename = datetime.datetime.now().isoformat('.').replace(":", "-") + ".png"
			final_path = os.path.join(PATHS.SCREENSHOT_DIR, filename)
			shutil.move(temp_path, final_path)

			# ingame message if there is a session and it is fully initialized:
			# pressing S on loading screen finds a session but no gui usually.
			session = horizons.main._modules.session
			if session and hasattr(session, 'ingame_gui'):
				session.ingame_gui.message_widget.add('SCREENSHOT',
				                                      message_dict={'file': final_path})
		elif action == _Actions.QUICKLOAD:
			horizons.main._load_last_quicksave()
		else:
			key_event_handled = False # nope, nothing triggered

		if key_event_handled:
			evt.consume() # prevent other listeners from being called

	def keyReleased(self, evt):
		pass

	def onCommand(self, command):
		if command.getCommandType() == fife.CMD_QUIT_GAME:
			horizons.main.quit()
			command.consume()

########NEW FILE########
__FILENAME__ = aidataselection
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import horizons.globals

from horizons.constants import MULTIPLAYER
from horizons.gui.util import load_uh_widget


class AIDataSelection(object):
	"""Subwidget for selecting AI settings."""

	def __init__(self):
		self.gui = load_uh_widget('aidataselection.xml')

		self.gui.distributeInitialData({'ai_players': [unicode(n) for n in xrange(MULTIPLAYER.MAX_PLAYER_COUNT)]})
		self.gui.distributeData({
			'ai_players': int(horizons.globals.fife.get_uh_setting("AIPlayers"))
		})

		# FIXME
		# pychan raises an RuntimeError if you attempt to hide a child in a container
		# that is already hidden (or does not exist). Work around by tracking the
		# state of the widget. The initial state depends on the parent widget.
		self.hidden = False

	def get_ai_players(self):
		"""Returns the number that was entered by the user"""
		return self.gui.collectData('ai_players')

	def show(self):
		self.gui.parent.showChild(self.gui)
		self.hidden = False

	def hide(self):
		if not self.hidden:
			self.gui.parent.hideChild(self.gui)
			self.hidden = True

	def get_widget(self):
		return self.gui

########NEW FILE########
__FILENAME__ = editorstartmenu
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import horizons.main

from horizons.gui.util import load_uh_widget
from horizons.gui.windows import Window
from horizons.savegamemanager import SavegameManager
from horizons.util.python.callback import Callback
from horizons.util.startgameoptions import StartGameOptions

class EditorStartMenu(Window):
	def __init__(self, windows):
		super(EditorStartMenu, self).__init__(windows)

		self._gui = load_uh_widget('editor_start_menu.xml')
		self._gui.position_technique = "center:center"
		self._right_side = None
		self._select_mode('create_new_map')

	def show(self):
		self._right_side.show()
		self._gui.show()

		events = {}
		events['okay'] = self.act
		events['cancel'] = self._windows.close
		events['create_new_map'] = Callback(self._select_mode, 'create_new_map')
		events['load_existing_map'] = Callback(self._select_mode, 'load_existing_map')
		events['load_saved_game_map'] = Callback(self._select_mode, 'load_saved_game_map')
		self._gui.mapEvents(events)

	def _select_mode(self, mode):
		modes = {
			'create_new_map': EditorCreateMapWidget,
			'load_existing_map': EditorSelectMapWidget,
			'load_saved_game_map': EditorSelectSavedGameWidget,
		}
		if modes[mode] is None:
			return

		if isinstance(self._right_side, modes[mode]):
			return

		self._gui.hide()
		self._gui.findChild(name=mode).marked = True
		self._right_side = modes[mode](self._windows, self._gui.findChild(name='right_side'))
		self._right_side.show()
		self._gui.show()

	def on_return(self):
		self.act()

	def hide(self):
		self._gui.hide()

	def act(self):
		self._right_side.act()


class EditorCreateMapWidget(object):
	sizes = [50, 100, 150, 200, 250]

	def __init__(self, windows, parent_widget):
		self._windows = windows
		self._parent_widget = parent_widget
		self._gui = load_uh_widget('editor_create_map.xml')
		self._gui.findChild(name='size_150').marked = True

		for size in self.sizes:
			option_name = 'size_%d' % size
			# size of empty map in map editor
			self._gui.findChild(name=option_name).text = _('{size}x{size} tiles').format(size=size)

	def show(self):
		self._parent_widget.removeAllChildren()
		self._parent_widget.addChild(self._gui)

	def act(self):
		for size in self.sizes:
			option_name = 'size_%d' % size
			if self._gui.findChild(name=option_name).marked:
				self._windows.close()

				# the empty list is interpreted as the empty list of random map island strings
				options = StartGameOptions.create_editor_load([])
				options.map_padding = size // 2
				horizons.main.start_singleplayer(options)
				return


class EditorSelectMapWidget(object):
	def __init__(self, windows, parent_widget):
		self._windows = windows
		self._parent_widget = parent_widget
		self._gui = load_uh_widget('editor_select_map.xml')
		self._map_data = None

	def show(self):
		self._map_data = SavegameManager.get_maps()
		self._gui.distributeInitialData({'map_list': self._map_data[1]})
		self._parent_widget.removeAllChildren()
		self._parent_widget.addChild(self._gui)

	def act(self):
		selected_map_index = self._gui.collectData('map_list')
		if selected_map_index == -1:
			# No map selected yet => select first available one
			self._gui.distributeData({'map_list': 0})

		self._windows.close()
		horizons.main.edit_map(self._map_data[0][selected_map_index])


class EditorSelectSavedGameWidget(object):
	def __init__(self, windows, parent_widget):
		self._windows = windows
		self._parent_widget = parent_widget
		self._gui = load_uh_widget('editor_select_saved_game.xml')
		self._saved_game_data = None

	def show(self):
		self._saved_game_data = SavegameManager.get_saves()
		self._gui.distributeInitialData({'saved_game_list': self._saved_game_data[1]})
		self._parent_widget.removeAllChildren()
		self._parent_widget.addChild(self._gui)

	def act(self):
		if not self._saved_game_data[0]:
			# there are no saved games: do nothing
			# TODO: play a related sound effect and/or do something else to make the user understand what is wrong
			return

		selection_index = self._gui.collectData('saved_game_list')
		if selection_index == -1:
			# No map selected yet => select first available one
			self._gui.distributeData({'saved_game_list': 0})

		self._windows.close()
		horizons.main.edit_game_map(self._saved_game_data[0][selection_index])

########NEW FILE########
__FILENAME__ = help
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import Label

from horizons.gui.modules.loadingscreen import GAMEPLAY_TIPS
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.imagebutton import OkButton
from horizons.gui.windows import Window


class HelpDialog(Window):

	def __init__(self, windows):
		super(HelpDialog, self).__init__(windows)

		self.widget = load_uh_widget('help.xml')
		self.widget.findChild(name=OkButton.DEFAULT_NAME).capture(self._windows.close)
		self.widget.findChild(name='headline').text = GAMEPLAY_TIPS['name']
		tip_box = self.widget.findChild(name='tip_box')
		size = {'max_size': (300, 60), 'min_size': (300, 20)}
		for tip in GAMEPLAY_TIPS['items']:
			tip_label = Label(text=unicode(tip), wrap_text=True, **size)
			tip_box.addChild(tip_label)

	def show(self):
		self.widget.show()

	def hide(self):
		self.widget.hide()

########NEW FILE########
__FILENAME__ = hotkeys_settings
# Encoding: utf-8
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife
from fife.extensions.pychan.widgets import Button

import horizons.globals

from horizons.gui.keylisteners.ingamekeylistener import KeyConfig
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.imagebutton import OkButton
from horizons.util.python.callback import Callback


class HotkeyConfiguration(object):

	def __init__(self):
		super(HotkeyConfiguration, self).__init__()

		self.widget = load_uh_widget('hotkeys.xml')
		self.buttons = []
		self.secondary_buttons = []

		self.keyconf = KeyConfig()
		self.actions = self.keyconf.get_bindable_actions_by_name()
		self.keys = self.keyconf.get_keys_by_value()

		self.HELPSTRING_LAYOUT = None
		self._is_displayed = False
		self._build_interface()

		# When detecing is True, the interface detects keypresses and binds them to actions
		self.detecting = False
		self.current_button = None
		self.current_index = None
		self.last_combination = []
		# Stores whether the last button pressed was for a primary or secondary binding (1 or 2)
		self.last_column = 1

		# There are some keys which are not detected by the event widget/keyPressed
		# In that case, the key presses are detected by the listener, which calls _detect_keypress
		self.listener = HotkeysListener(self._detect_keypress)

		self.widget.mapEvents({self.widget.name + '/keyPressed' : self._detect_keypress})
		self.widget.findChild(name=OkButton.DEFAULT_NAME).capture(self.save_settings)
		self.widget.mapEvents({OkButton.DEFAULT_NAME : self.save_settings})
		self.widget.findChild(name="reset_to_default").capture(self.reset_to_default)

	def _build_interface(self):
		button_container = self.widget.findChild(name='button_container')
		sec_button_container = self.widget.findChild(name='sec_button_container')
		for i, action in enumerate(self.actions):
			button = self._create_button(action, i)
			sec_button = self._create_button(action, i)
			button.mapEvents({button.name + '/mouseClicked' : Callback(self._detect_click_on_button, button, 1)})
			sec_button.mapEvents({button.name + '/mouseClicked' : Callback(self._detect_click_on_button, sec_button, 2)})
			button_container.addChild(button)
			sec_button_container.addChild(sec_button)
			self.buttons.append(button)
			self.secondary_buttons.append(sec_button)
			self.update_buttons_text()

	def _create_button(self, action, index):
		"""Important! The button name is set to index so that when a button is pressed, we know its index"""
		button = Button()
		button.name = str(index)
		button.max_size = button.min_size = (100, 18)
		return button

	def _detect_click_on_button(self, button, column):
		"""Starts the listener and remembers the position and index of the pressed button"""
		self.detecting = True
		self.current_button = button
		self.current_index = int(button.name)
		self.current_column = column
		self.listener.activate()
		self.update_buttons_text()
		button.font = 'default'
		button.text = _(u"Press key…")

	def _detect_keypress(self, event):
		if not self.detecting:
			return
		key = event.getKey()
		# if the key is not supported, act as if it was not detected
		if not self.key_name(key):
			return
		self.last_combination.append(key)
		self.detecting = False
		self.listener.deactivate()
		self.apply_change()

	def update_buttons_text(self):
		for i, button in enumerate(self.buttons):
			button.font = 'default_bold'
			action = self.actions[i]
			bindings = self.keyconf.get_current_keys(action)
			for j in range(len(bindings)):
				if bindings[j] == 'UNASSIGNED':
					bindings[j] = ''
			secondary_button = self.secondary_buttons[i]
			button.text = unicode(bindings[0])
			if len(bindings) > 1:
				secondary_button.font = 'default_bold'
				secondary_button.text = unicode(bindings[1])
			else:
				secondary_button.text = u''

	def apply_change(self):
		"""Binds the last keypress to the corresponding action and resets the interface to the state where it is listening for clicks on buttons"""
		key = self.last_combination[0]
		key_name = self.key_name(key)
		action = self.actions[self.current_index]
		column = self.current_column

		# Escape is used to unassign bindings
		if key_name == 'ESCAPE':
			key_name = 'UNASSIGNED'

		# If *key* is already set, replace the entry for *key* with UNASSIGNED for the last action.
		# This is done to avoid binding one key for two actions.
		elif self.key_is_set(key):
			oldaction = self.get_action_name(key)

			message = _("{key} is already set to {action}.").format(key=key_name, action=oldaction)
			message += u" " + _("Would you like to overwrite it?")
			confirmed = horizons.main._modules.gui.open_popup(_("Confirmation for overwriting"), message, show_cancel_button=True)
			if confirmed:
				horizons.globals.fife.replace_key_for_action(oldaction, key_name, "UNASSIGNED")
			else:
				self.update_buttons_text()
				self.last_combination = []
				return

		bindings = self.keyconf.get_current_keys(action)
		if column == 1:
			bindings[0] = key_name
		elif column == 2:
			if len(bindings) < 2:
				bindings.append(key_name)
			else:
				bindings[1] = key_name

		horizons.globals.fife.set_key_for_action(action, bindings)

		self.update_buttons_text()
		self.last_combination = []

	def key_name(self, key):
		value = key.getValue()
		return self.keys.get(value)

	def key_is_set(self, key):
		key_name = self.key_name(key)
		custom_key_actions = horizons.globals.fife.get_hotkey_settings()
		for k in custom_key_actions.itervalues():
			if key_name in k:
				return True
		return False

	def get_current_bindings(self):
		""" Returns a dict mapping action -> list of keys """
		bindings = {}
		for action in self.actions:
			keys = self.keyconf.get_current_keys(action)
			bindings[action] = keys
		return bindings

	def get_action_name(self, key):
		key_name = self.key_name(key)
		custom_key_actions = horizons.globals.fife.get_hotkey_settings()
		for action in custom_key_actions:
			k = custom_key_actions[action]
			if key_name in k:
				return action
		print "Action name not found. Key name must be wrong. This is not supposed to ever happen"

	def reset_to_default(self):
		"""Resets all bindings to default"""
		for action in self.actions:
			default_key = horizons.globals.fife.get_keys_for_action(action, default=True)
			horizons.globals.fife.set_key_for_action(action, default_key)

		self.update_buttons_text()

	def save_settings(self):
		"""Saves the settings and reloads the keyConfiguration so that the settings take effect without a restart"""
		horizons.globals.fife.save_settings()
		self.keyconf.loadKeyConfiguration()

	def show(self):
		self.widget.show()

	def hide(self):
		self.widget.hide()


class HotkeysListener(fife.IKeyListener):
	"""HotkeysListener Class to process events of hotkeys binding interface"""

	def __init__(self, detect_keypress):
		super(HotkeysListener, self).__init__()
		fife.IKeyListener.__init__(self)

		self.detect = detect_keypress

	def activate(self):
		horizons.globals.fife.eventmanager.addKeyListenerFront(self)

	def deactivate(self):
		horizons.globals.fife.eventmanager.removeKeyListener(self)

	def end(self):
		horizons.globals.fife.eventmanager.removeKeyListener(self)
		super(HotkeysListener, self).end()

	def keyPressed(self, evt):
		self.detect(evt)
		evt.consume()

	def keyReleased(self, evt):
		pass

########NEW FILE########
__FILENAME__ = ingame
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


import horizons.globals

from horizons.command.misc import Chat
from horizons.command.uioptions import RenameObject
from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.component.namedcomponent import NamedComponent, SettlementNameComponent
from horizons.constants import GUI
from horizons.extscheduler import ExtScheduler
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.imagebutton import OkButton, CancelButton
from horizons.gui.windows import Dialog
from horizons.messaging import SettlerInhabitantsChanged, HoverSettlementChanged, ResourceBarResize
from horizons.util.pychanchildfinder import PychanChildFinder
from horizons.util.python.callback import Callback


class ChatDialog(Dialog):
	"""Allow player to send messages to other players."""
	focus = 'msg'

	def __init__(self, windows, session):
		super(ChatDialog, self).__init__(windows)
		self._session = session

	def prepare(self):
		self._gui = load_uh_widget('chat.xml')
		self.return_events = {
			OkButton.DEFAULT_NAME: True,
			CancelButton.DEFAULT_NAME: False,
		}

	def act(self, send_message):
		"""Actually initiates chatting and hides the dialog"""
		if not send_message:
			return
		msg = self._gui.findChild(name="msg").text
		Chat(msg).execute(self._session)


class ChangeNameDialog(Dialog):
	"""Shows a dialog where the user can change the name of a NamedComponent."""
	modal = True
	focus = 'new_name'

	def __init__(self, windows, session):
		super(ChangeNameDialog, self).__init__(windows)
		self._session = session

	def prepare(self, instance):
		self._gui = load_uh_widget('change_name.xml')
		self.return_events = {
			OkButton.DEFAULT_NAME: instance,
			CancelButton.DEFAULT_NAME: False,
		}
		oldname = self._gui.findChild(name='old_name')
		oldname.text = instance.get_component(NamedComponent).name

	def act(self, named_instance):
		"""Renames the instance that is returned by the dialog, if confirmed.

		Hitting Esc or the Cancel button will not trigger a rename.
		if no name was entered or the new name only consists of spaces, abort
		the renaming as well.
		"""
		if not named_instance:
			return

		new_name = self._gui.collectData('new_name')

		if new_name and not new_name.isspace():
			# different namedcomponent classes share the name
			namedcomp = named_instance.get_component_by_name(NamedComponent.NAME)
			RenameObject(namedcomp, new_name).execute(self._session)


class CityInfo(object):
	"""Display city name and inhabitant count at top of the screen."""
	# FIXME updating the position of this widget should be the responsibility of the
	# FIXME ingamegui, as it needs to take the resource overview bar into account as
	# FIXME well. However, an update to the settlement's name triggers repositioning
	# FIXME too, and we'd need a clean way to pass that info the ingamegui.

	def __init__(self, ingame_gui):
		self._ingame_gui = ingame_gui
		self._widget = load_uh_widget('city_info.xml', 'resource_bar')
		self._widget.adaptLayout()
		self._child_finder = PychanChildFinder(self._widget)

		self._settlement = None
		HoverSettlementChanged.subscribe(self._on_hover_settlement_change)
		SettlerInhabitantsChanged.subscribe(self._on_settler_inhabitant_change)
		ResourceBarResize.subscribe(self._on_resourcebar_resize)

	def end(self):
		HoverSettlementChanged.unsubscribe(self._on_hover_settlement_change)
		SettlerInhabitantsChanged.unsubscribe(self._on_settler_inhabitant_change)
		ResourceBarResize.unsubscribe(self._on_resourcebar_resize)

	def _on_hover_settlement_change(self, message):
		self.set_settlement(message.settlement)

	def set_settlement(self, settlement):
		"""Sets the city name at top center of screen.

		Show/Hide is handled automatically
		"""
		if self._settlement:
			self._settlement.remove_change_listener(self._update_settlement)

		self._settlement = settlement

		if not settlement:
			# Hide the widget (after some seconds).
			# Delayed to allow players scrolling away to click on the widget.
			# This often happens when moving mouse up from island to reach it.
			ExtScheduler().add_new_object(self.hide, self, run_in=GUI.CITYINFO_UPDATE_DELAY)
		else:
			# Cancel previously scheduled hide if a settlement is hovered again.
			ExtScheduler().rem_call(self, self.hide)

			self._update_settlement()  # This calls show()!
			settlement.add_change_listener(self._update_settlement)

	def _on_settler_inhabitant_change(self, message):
		"""Update display of inhabitants count."""
		foundlabel = self._child_finder('city_inhabitants')
		old_amount = int(foundlabel.text) if foundlabel.text else 0
		foundlabel.text = u' {amount:>4d}'.format(amount=old_amount + message.change)
		foundlabel.resizeToContent()

	def _update_settlement(self):
		city_name_label = self._child_finder('city_name')
		if self._settlement.owner.is_local_player: # allow name changes
			# Update settlement on the resource overview to make sure it
			# is setup correctly for the coming calculations
			self._ingame_gui.resource_overview.set_inventory_instance(self._settlement)
			cb = Callback(self._ingame_gui.show_change_name_dialog, self._settlement)
			helptext = _("Click to change the name of your settlement")
			city_name_label.enable_cursor_change_on_hover()
		else: # no name changes
			cb = lambda: AmbientSoundComponent.play_special('error')
			helptext = u""
			city_name_label.disable_cursor_change_on_hover()

		self._widget.mapEvents({
			'city_name': cb
		})
		city_name_label.helptext = helptext

		foundlabel = self._child_finder('owner_emblem')
		foundlabel.image = 'content/gui/icons/widgets/cityinfo/settlement_%s.png' % (self._settlement.owner.color.name)
		foundlabel.helptext = self._settlement.owner.name

		foundlabel = self._child_finder('city_name')
		foundlabel.text = self._settlement.get_component(SettlementNameComponent).name
		foundlabel.resizeToContent()

		foundlabel = self._child_finder('city_inhabitants')
		foundlabel.text = u' {amount:>4d}'.format(amount=self._settlement.inhabitants)
		foundlabel.resizeToContent()

		self._update_position()

	def _update_position(self):
		"""Places cityinfo widget depending on resource bar dimensions.

		For a normal-sized resource bar and reasonably large resolution:
		* determine resource bar length (includes gold)
		* determine empty horizontal space between resbar end and minimap start
		* display cityinfo centered in that area if it is sufficiently large

		If too close to the minimap (cityinfo larger than length of this empty space)
		move cityinfo centered to very upper screen edge. Looks bad, works usually.
		In this case, the resbar is redrawn to put the cityinfo "behind" it visually.
		"""
		width = horizons.globals.fife.engine_settings.getScreenWidth()
		resbar = self._ingame_gui.resource_overview.get_size()
		is_foreign = (self._settlement.owner != self._ingame_gui.session.world.player)
		blocked = self._widget.size[0] + int(1.5 * self._ingame_gui.minimap.get_size()[1])
		# minimap[1] returns width! Use 1.5*width because of the GUI around it

		if is_foreign: # other player, no resbar exists
			self._widget.pos = ('center', 'top')
			xoff = 0
			yoff = 10
		elif blocked < width < resbar[0] + blocked: # large resbar / small resolution
			self._widget.pos = ('center', 'top')
			xoff = 0
			yoff = resbar[1] # below resbar
		else:
			self._widget.pos = ('left', 'top')
			xoff = resbar[0] + (width - blocked - resbar[0]) // 2
			yoff = 15

		self._widget.offset = (xoff, yoff)
		self._widget.position_technique = "{pos[0]}{off[0]:+d}:{pos[1]}{off[1]:+d}".format(
				pos=self._widget.pos,
				off=self._widget.offset)
		self._widget.hide()
		self._widget.show()

	def _on_resourcebar_resize(self, message):
		self._update_position()

	def hide(self):
		self._widget.hide()

########NEW FILE########
__FILENAME__ = loadingscreen
# Encoding: utf-8
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import random

import horizons.globals
from horizons.constants import TIER
from horizons.i18n import _lazy
from horizons.gui.util import load_uh_widget
from horizons.gui.windows import Window
from horizons.messaging import LoadingProgress


# list of quotes and gameplay tips that are displayed while loading a game
# NOTE: Try to use not more than 4 lines in a quote/gameplay tip !

FUN_QUOTES = {
	'name': _lazy("Quotes"),
	# Fun Quotes should not be translated...
	'items': [
		"beer, the cause and solution to all problems of humanity",
		"trying is the first step t'wards failing. ",
		"# nobody actually knows how the code below works. ",
		"here be dragons",
		"procrastination is the first step towards getting stuff done",
		"patience is a virtue \n(barra)",
		"you must really, really love to test \n(portal 2)",
		"here be bugs",
		"strength is the capacity to break a chocolate bar into four pieces with your bare hands - and then eat just one of the pieces",
		"If one does not know to which port one is sailing, no wind is favorable",
		"The pessimist complains about the wind; \nthe optimist expects it to change; \nthe realist adjusts the sails",
		"Travel beyond the horizon and discover unknown worlds!",
		u"War… war never changes",
		"Support Unknown Horizons with Cookies!",
		"wow, looks nearly completed \n(Neomex)"
    ]
}


GAMEPLAY_TIPS = {
	'name': _lazy("Gameplay Tips"),
	'items': [
		_lazy("Press 'ESC' to access Game Menu."),
		_lazy("Use 'SHIFT' to place multiple buildings."),
		#TODO: This tip should be removed when all tiers are playable!!
		_lazy("Currently only the first {tier} tiers are playable.").format(
				tier=TIER.CURRENT_MAX + 1),
		_lazy("You can pause the game with 'P'."),
		_lazy("You can drag roads by holding the left mouse button."),
		_lazy("You can build multiple buildings by holding the 'SHIFT' key."),
		_lazy("You can increase the happiness of your inhabitants by lowering the taxes."),
		_lazy("Build fire stations and doctors to protect your inhabitants from fire and disease."),
		_lazy("Build storage tents to increase your storage capacity."),
		_lazy("Make sure every house is in range of a marketplace."),
		_lazy("Press 'T' to make trees transparent.")
	]
}

# This are the options you can select in the Settings what type of quotes should be
# displayed during load
QUOTES_SETTINGS = (GAMEPLAY_TIPS['name'], FUN_QUOTES['name'], _lazy("Mixed"))


def get_random_quote():
	quote_type = int(horizons.globals.fife.get_uh_setting("QuotesType"))
	if quote_type == 2:
		quote_type = random.randint(0, 1) # choose a random type

	if quote_type == 0:
		name = GAMEPLAY_TIPS["name"]
		items = GAMEPLAY_TIPS["items"]
	elif quote_type == 1:
		name = FUN_QUOTES["name"]
		items = FUN_QUOTES["items"]

	return name, random.choice(items)


stage_text = {
	# translators: these are descriptions of the current task while loading a game
	'session_create_world': _lazy(u'Starting engine…'),
	'session_index_fish': _lazy(u'Catching fish…'),
	'session_load_gui': _lazy(u'Drawing user interface…'),
	'session_finish': _lazy(u'Activating timer…'),
	'load_objects': _lazy(u'Chomping game data…'),
	'world_load_map': _lazy(u'Shaping islands…'),
	'world_load_buildings': _lazy(u'Preparing blueprints…'),
	'world_init_water': _lazy(u'Filling world with water…'),
	'world_load_units': _lazy(u'Raising animals…'),
	'world_setup_ai': _lazy(u'Convincing AI…'),
	'world_load_stuff': _lazy(u'Burying treasures…'),
}


class LoadingScreen(Window):
	"""Show quotes/gameplay tips while loading the game"""

	# how often the LoadingProgress message is send when loading a game,
	# used to update the progress bar
	total_steps = len(stage_text)

	def __init__(self):
		self._widget = load_uh_widget('loadingscreen.xml')
		self._widget.position_technique = "center:center"

		self._current_step = 0

	def show(self):
		qotl_type_label = self._widget.findChild(name='qotl_type_label')
		qotl_label = self._widget.findChild(name='qotl_label')

		name, quote = get_random_quote()
		qotl_type_label.text = name
		qotl_label.text = quote

		self._widget.show()
		LoadingProgress.subscribe(self._update)

	def hide(self):
		self._current_step = 0
		LoadingProgress.discard(self._update)
		self._widget.hide()

	def on_escape(self):
		"""Hitting Esc should not attempt to close the loading screen.

		See #2018 for what happens else."""
		pass

	def _update(self, message):
		self._current_step += 1

		label = self._widget.findChild(name='loading_stage')
		label.text = stage_text.get(message.stage, message.stage)
		label.adaptLayout()

		self._widget.findChild(name='loading_progress').progress = (100 * self._current_step) // self.total_steps

		horizons.globals.fife.engine.pump()

########NEW FILE########
__FILENAME__ = multiplayermenu
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import hashlib
import textwrap

from fife.extensions.pychan.widgets import HBox, Label, TextField

import horizons.main
from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.constants import MULTIPLAYER
from horizons.gui.modules import PlayerDataSelection
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.icongroup import hr as HRule
from horizons.gui.widgets.imagebutton import OkButton, CancelButton
from horizons.gui.widgets.minimap import Minimap
from horizons.gui.windows import Popup, Window
from horizons.network import enet
from horizons.network.networkinterface import NetworkInterface
from horizons.savegamemanager import SavegameManager
from horizons.util.color import Color
from horizons.util.python.callback import Callback
from horizons.world import load_raw_world
from horizons.extscheduler import ExtScheduler


class MultiplayerMenu(Window):

	def __init__(self, mainmenu, windows):
		super(MultiplayerMenu, self).__init__(windows)
		self._mainmenu = mainmenu
		self._gui = load_uh_widget('multiplayermenu.xml')
		self._gui.mapEvents({
			'cancel' : self._windows.close,
			'join'   : self._join_game,
			'create' : self._create_game,
			'refresh': Callback(self._refresh, play_sound=True)
		})

		self._gui.findChild(name='gamelist').capture(self._update_game_details)
		self._playerdata = PlayerDataSelection()
		self._gui.findChild(name="playerdataselectioncontainer").addChild(self._playerdata.get_widget())

		# to track if the menu window is opened or not.
		self._is_open = False

	def hide(self):
		# Save the player-data on hide so that other menus gets updated data
		self._playerdata.save_settings()
		self._gui.hide()
		ExtScheduler().rem_all_classinst_calls(self)

	def show(self):		
		if not self._check_connection():
			return

		if not self._refresh():
			self._windows.close()
			return

		if not self._is_open:
			self._is_open = True
			# subscribe "error" when this menu window is firstly opened
			# only unsubscribe if this menu window is closed
			NetworkInterface().subscribe("error", self._on_error)

		# get updated player data
		self._playerdata.update_data()

		self._gui.show()

		# TODO: Remove once loading a game is implemented again
		self._gui.findChild(name='load').parent.hide()

		ExtScheduler().add_new_object(self._refresh, self, run_in=5, loops=-1)

	def close(self):
		# if the window is not open (due to connection errors), just do nothing
		if not self._is_open:
			return

		self.hide()

		NetworkInterface().unsubscribe("error", self._on_error)
		self._is_open = False

		# the window is also closed when a game starts, don't disconnect in that case
		if NetworkInterface().is_connected and not NetworkInterface().is_joined:
			NetworkInterface().disconnect()

	def on_return(self):
		self._join_game()

	def _check_connection(self):
		"""
		Check if all dependencies for multiplayer games are met and we can connect to
		the master server. If any dependency is not met, the window is closed.
		"""
		# It is important to close this window before showing the error popup.
		# Otherwise closing the popup will trigger `show` again, a new attempt
		# to connect is made, which ends up in an endless loop.

		if enet is None:
			self._windows.close()
			headline = _("Unable to find pyenet")
			descr = _('The multiplayer feature requires the library "pyenet", '
			          "which could not be found on your system.")
			advice = _("Linux users: Try to install pyenet through your package manager.")
			self._windows.open_error_popup(headline, descr, advice)
			return False

		if NetworkInterface() is None:
			try:
				NetworkInterface.create_instance()
			except RuntimeError as e:
				self._windows.close()
				headline = _("Failed to initialize networking.")
				descr = _("Network features could not be initialized with the current configuration.")
				advice = _("Check the settings you specified in the network section.")
				self._windows.open_error_popup(headline, descr, advice, unicode(e))
				return False

		if not NetworkInterface().is_connected:
			try:
				NetworkInterface().connect()
			except Exception as err:
				self._windows.close()
				headline = _("Fatal Network Error")
				descr = _("Could not connect to master server.")
				advice = _("Please check your Internet connection. If it is fine, "
				           "it means our master server is temporarily down.")
				self._windows.open_error_popup(headline, descr, advice, unicode(err))
				return False

		if NetworkInterface().is_joined:
			if not NetworkInterface().leavegame():
				self._windows.close()
				return False

		return True

	def _on_error(self, exception, fatal=True):
		"""Error callback"""
		if not fatal:
			self._windows.open_popup(_("Error"), unicode(exception))
		else:
			self._windows.open_popup(_("Fatal Network Error"),
		                             _("Something went wrong with the network:") + u'\n' +
		                             unicode(exception) )
			# FIXME: this shouldn't be necessary, the main menu window is still somewhere
			# in the stack and we just need to get rid of all MP related windows
			self._mainmenu.show_main()

	def _display_game_name(self, game):
		same_version = game.version == NetworkInterface().get_clientversion()
		template = u"{password}{gamename}: {name} ({players}, {limit}){version}"
		return template.format(
			password="(Password!) " if game.has_password else "",
			name=game.map_name,
			gamename=game.name,
			players=game.player_count,
			limit=game.player_limit,
			version=u" " + _("Version differs!") if not same_version else u"")

	def _refresh(self, play_sound=False):
		"""Refresh list of games.

		@param play_sound: whether to play the refresh sound
		@return bool, whether refresh worked
		"""
		if play_sound:
			AmbientSoundComponent.play_special('refresh')

		self._games = NetworkInterface().get_active_games()
		if self._games is None:
			return False

		gamelist = [self._display_game_name(g) for g in self._games]
		self._gui.distributeInitialData({'gamelist': gamelist})
		self._gui.distributeData({'gamelist': 0})
		self._update_game_details()
		return True

	def _update_game_details(self):
		"""Set map name and other misc data in a widget."""
		try:
			index = self._gui.collectData('gamelist')
			game = self._games[index]
		except IndexError:
			return

		self._gui.findChild(name="game_map").text = _("Map: {map_name}").format(map_name=game.map_name)
		self._gui.findChild(name="game_name").text = _("Name: {game_name}").format(game_name=game.name)
		self._gui.findChild(name="game_creator").text = _("Creator: {game_creator}").format(game_creator=game.creator)
		self._gui.findChild(name="game_playersnum").text = _("Players: {player_amount}/{player_limit}").format(
		                           player_amount=game.player_count,
		                           player_limit=game.player_limit)

		vbox_inner = self._gui.findChild(name="game_info")
		vbox_inner.adaptLayout()

	def _join_game(self):
		"""Joins a multiplayer game. Displays lobby for that specific game"""
		try:
			index = self._gui.collectData('gamelist')
			game = self._games[index]
		except IndexError:
			return

		if game.uuid == -1: # -1 signals no game
			AmbientSoundComponent.play_special('error')
			return

		if game.version != NetworkInterface().get_clientversion():
			self._windows.open_popup(_("Wrong version"),
			                          _("The game's version differs from your version. "
			                            "Every player in a multiplayer game must use the same version. "
			                            "This can be fixed by every player updating to the latest version. "
			                            "Game version: {game_version} Your version: {own_version}").format(
			                            game_version=game.version,
			                            own_version=NetworkInterface().get_clientversion()))
			return

		NetworkInterface().change_name(self._playerdata.get_player_name())
		NetworkInterface().change_color(self._playerdata.get_player_color().id)

		if game.password:
			# ask the player for the password
			popup = PasswordInput(self._windows)
			password = self._windows.open(popup)
			if password is None:
				return
			password = hashlib.sha1(password).hexdigest()
			success = NetworkInterface().joingame(game.uuid, password)
			if not success:
				return
		elif not NetworkInterface().joingame(game.uuid, ''):
			return

		window = GameLobby(self._windows)
		self._windows.open(window)

	def _create_game(self):
		NetworkInterface().change_name(self._playerdata.get_player_name())
		NetworkInterface().change_color(self._playerdata.get_player_color().id)
		self._windows.open(CreateGame(self._windows))


class PasswordInput(Popup):
	"""Popup where players enter a password to join multiplayer games."""
	focus = 'password'

	def __init__(self, windows):
		title = _('Password of the game')
		text = _('Enter password:')
		super(PasswordInput, self).__init__(windows, title, text, show_cancel_button=True)

	def prepare(self, **kwargs):
		super(PasswordInput, self).prepare(**kwargs)
		pw = TextField(name='password', max_size=(320, 20), min_size=(320, 20))
		box = self._gui.findChild(name='message_box')
		box.addChild(pw)

	def act(self, send_password):
		if not send_password:
			return
		return self._gui.collectData("password")


class CreateGame(Window):
	"""Interface for creating a multiplayer game"""

	def __init__(self, windows):
		super(CreateGame, self).__init__(windows)

		self._gui = load_uh_widget('multiplayer_creategame.xml')
		self._gui.mapEvents({
			'cancel': self._windows.close,
			'create': self.act,
		})

		self._files = []
		self._maps_display = []
		self._map_preview = None

	def hide(self):
		self._gui.hide()

	def show(self):
		self._files, self._maps_display = SavegameManager.get_maps()

		self._gui.distributeInitialData({
			'maplist': self._maps_display,
			'playerlimit': range(2, MULTIPLAYER.MAX_PLAYER_COUNT)
		})

		if self._maps_display: # select first entry
			self._gui.distributeData({
				'maplist': 0,
				'playerlimit': 0
			})
			self._update_infos()

		self._gui.findChild(name="maplist").mapEvents({
			'maplist/action': self._update_infos
		})
		
		gamenametextfield = self._gui.findChild(name='gamename')
		def gamename_clicked():
			if gamenametextfield.text == 'Unnamed Game':
				gamenametextfield.text = ""
		gamenametextfield.capture(gamename_clicked, event_name='mouseClicked')
		self._gui.show()

	def act(self):
		mapindex = self._gui.collectData('maplist')
		mapname = self._maps_display[mapindex]
		maxplayers = self._gui.collectData('playerlimit') + 2 # 1 is the first entry
		gamename = self._gui.collectData('gamename')
		password = self._gui.collectData('password')
		maphash = ""

		password = hashlib.sha1(password).hexdigest() if password != "" else ""
		game = NetworkInterface().creategame(mapname, maxplayers, gamename, maphash, password)
		if game:
			# FIXME When canceling the lobby, I'd like the player to return to the main mp
			# menu, and not see the 'create game' again. We need to close this window, however,
			# this will trigger the display of the main gui, which will part the game in
			# `MultiplayerMenu._check_connection`
			#self._windows.close()
			window = GameLobby(self._windows)
			self._windows.open(window)

	def _update_infos(self):
		index = self._gui.collectData('maplist')
		mapfile = self._files[index]
		number_of_players = SavegameManager.get_recommended_number_of_players(mapfile)

		lbl = self._gui.findChild(name="recommended_number_of_players_lbl")
		lbl.text = _("Recommended number of players: {number}").format(number=number_of_players)

		self._update_map_preview(mapfile)

	def _update_map_preview(self, map_file):
		if self._map_preview:
			self._map_preview.end()

		world = load_raw_world(map_file)
		self._map_preview = Minimap(
			self._gui.findChild(name='map_preview_minimap'),
			session=None,
			view=None,
			world=world,
			targetrenderer=horizons.globals.fife.targetrenderer,
			imagemanager=horizons.globals.fife.imagemanager,
			cam_border=False,
			use_rotation=False,
			tooltip=None,
			on_click=None,
			preview=True)

		self._map_preview.draw()


class GameLobby(Window):
	"""Chat with other players, change name, wait for the game to begin."""

	def __init__(self, windows):
		super(GameLobby, self).__init__(windows)

		self._gui = load_uh_widget('multiplayer_gamelobby.xml')


		self._gui.mapEvents({
			'cancel': self._cancel,
			'ready_btn': self._on_ready_button_pressed,
		})

		NetworkInterface().subscribe("game_prepare", self._prepare_game)

	def _on_ready_button_pressed(self):
		ready_button = self._gui.findChild(name="ready_btn")
		ready_button.toggle()
		ready_label = self._gui.findChild(name="ready_lbl")
		if ready_button.is_active:
			ready_label.text = _("Ready") + ":"
		else:
			ready_label.text = _("Not ready") + ":"
		ready_label.adaptLayout()
		NetworkInterface().toggle_ready()

	def hide(self):
		self._gui.hide()

	def _cancel(self):
		"""When the lobby is cancelled, close the window and leave the game.

		We can't do this in `close`, because the window will be closed when a game starts
		as well, and we don't want to leave the game then.
		"""
		self._windows.close()
		NetworkInterface().leavegame()

	def on_escape(self):
		self._cancel()

	def close(self):
		self.hide()

		NetworkInterface().unsubscribe("lobbygame_chat", self._on_chat_message)
		NetworkInterface().unsubscribe("lobbygame_join", self._on_player_joined)
		NetworkInterface().unsubscribe("lobbygame_leave", self._on_player_left)
		NetworkInterface().unsubscribe("lobbygame_kick", self._on_player_kicked)
		NetworkInterface().unsubscribe("lobbygame_changename", self._on_player_changed_name)
		NetworkInterface().unsubscribe("lobbygame_changecolor", self._on_player_changed_color)
		NetworkInterface().unsubscribe("lobbygame_toggleready", self._on_player_toggled_ready)
		NetworkInterface().unsubscribe("game_details_changed", self._update_game_details)
		NetworkInterface().unsubscribe("game_prepare", self._prepare_game)

	def show(self):
		textfield = self._gui.findChild(name="chatTextField")
		textfield.capture(self._send_chat_message)
		welcome_string = _("Enter your message")
		def chatfield_clicked():
			if textfield.text == welcome_string:
				textfield.text = ""
		textfield.text = welcome_string
		textfield.capture(chatfield_clicked, event_name="mouseClicked")

		self._update_game_details()

		NetworkInterface().subscribe("lobbygame_chat", self._on_chat_message)
		NetworkInterface().subscribe("lobbygame_join", self._on_player_joined)
		NetworkInterface().subscribe("lobbygame_leave", self._on_player_left)
		NetworkInterface().subscribe("lobbygame_kick", self._on_player_kicked)
		NetworkInterface().subscribe("lobbygame_changename", self._on_player_changed_name)
		NetworkInterface().subscribe("lobbygame_changecolor", self._on_player_changed_color)
		NetworkInterface().subscribe("lobbygame_toggleready", self._on_player_toggled_ready)
		NetworkInterface().subscribe("game_details_changed", self._update_game_details)

		self._gui.show()

	def _prepare_game(self, game):
		horizons.main.prepare_multiplayer(game)

	def _update_game_details(self):
		"""Set map name and other misc data"""
		game = NetworkInterface().get_game()

		self._gui.findChild(name="game_map").text = _("Map: {map_name}").format(map_name=game.map_name)
		self._gui.findChild(name="game_name").text = _("Name: {game_name}").format(game_name=game.name)
		self._gui.findChild(name="game_creator").text = _("Creator: {game_creator}").format(game_creator=game.creator)
		self._gui.findChild(name="game_playersnum").text = _("Players: {player_amount}/{player_limit}").format(
		                           player_amount=game.player_count,
		                           player_limit=game.player_limit)

		self._update_players_box(game)
		self._gui.findChild(name="game_info").adaptLayout()

	def _update_players_box(self, game):
		"""Updates player list."""
		players_vbox = self._gui.findChild(name="players_vbox")
		players_vbox.removeAllChildren()

		hr = HRule()
		players_vbox.addChild(hr)

		def _add_player_line(player):
			name = player['name']
			pname = Label(name="pname_%s" % name)
			pname.helptext = _("Click here to change your name and/or color")
			pname.text = name
			pname.min_size = pname.max_size = (130, 15)

			if name == NetworkInterface().get_client_name():
				pname.capture(Callback(self._show_change_player_details_popup, game))

			pcolor = Label(name="pcolor_%s" % name, text=u"   ")
			pcolor.helptext = _("Click here to change your name and/or color")
			pcolor.background_color = player['color']
			pcolor.min_size = pcolor.max_size = (15, 15)

			if name == NetworkInterface().get_client_name():
				pcolor.capture(Callback(self._show_change_player_details_popup, game))

			pstatus = Label(name="pstatus_%s" % name)
			pstatus.text = "\t\t\t" + player['status']
			pstatus.min_size = pstatus.max_size = (120, 15)

			picon = HRule(name="picon_%s" % name)

			hbox = HBox()
			hbox.addChildren(pname, pcolor, pstatus)

			if NetworkInterface().get_client_name() == game.creator and name != game.creator:
				pkick = CancelButton(name="pkick_%s" % name)
				pkick.helptext = _("Kick {player}").format(player=name)
				pkick.capture(Callback(NetworkInterface().kick, player['sid']))
				pkick.path = "images/buttons/delete_small"
				pkick.min_size = pkick.max_size = (20, 15)
				hbox.addChild(pkick)

			players_vbox.addChildren(hbox, picon)

		for player in game.get_player_list():
			_add_player_line(player)

		players_vbox.adaptLayout()

	def _show_change_player_details_popup(self, game):
		"""Shows a dialog where the player can change its name and/or color"""

		assigned = [p["color"] for p in NetworkInterface().get_game().get_player_list()
		            if p["name"] != NetworkInterface().get_client_name()]
		unused_colors = set(Color) - set(assigned)

		playerdata = PlayerDataSelection(color_palette=unused_colors)
		playerdata.set_player_name(NetworkInterface().get_client_name())
		playerdata.set_color(NetworkInterface().get_client_color())

		dialog = load_uh_widget('set_player_details.xml')
		dialog.findChild(name="playerdataselectioncontainer").addChild(playerdata.get_widget())

		def _change_playerdata():
			NetworkInterface().change_name(playerdata.get_player_name())
			NetworkInterface().change_color(playerdata.get_player_color().id)
			dialog.hide()
			self._update_game_details()

		def _cancel():
			dialog.hide()

		dialog.mapEvents({
			OkButton.DEFAULT_NAME: _change_playerdata,
			CancelButton.DEFAULT_NAME: _cancel
		})

		dialog.show()

	# Functions for handling events on the left side (chat)

	def _send_chat_message(self):
		"""Sends a chat message. Called when user presses enter in the input field"""
		msg = self._gui.findChild(name="chatTextField").text
		if msg:
			self._gui.findChild(name="chatTextField").text = u""
			NetworkInterface().chat(msg)

	def _print_event(self, msg, wrap="*"):
		line_max_length = 40
		if wrap:
			msg = "%s %s %s" % (wrap, msg, wrap)

		lines = textwrap.wrap(msg, line_max_length)

		chatbox = self._gui.findChild(name="chatbox")
		chatbox.items.extend(lines)
		chatbox.selected = len(chatbox.items) - 1

	def _on_chat_message(self, game, player, msg):
		self._print_event(player + ": " + msg, wrap="")

	def _on_player_joined(self, game, player):
		self._print_event(_("{player} has joined the game").format(player=player.name))

	def _on_player_left(self, game, player):
		self._print_event(_("{player} has left the game").format(player=player.name))

	def _on_player_toggled_ready(self, game, plold, plnew, myself):
		self._update_players_box(NetworkInterface().get_game())
		if myself:
			if plnew.ready:
				self._print_event(_("You are now ready"))
			else:
				self._print_event(_("You are not ready anymore"))
		else:
			if plnew.ready:
				self._print_event(_("{player} is now ready").format(player=plnew.name))
			else:
				self._print_event(_("{player} not ready anymore").format(player=plnew.name))

	def _on_player_changed_name(self, game, plold, plnew, myself):
		if myself:
			self._print_event(_("You are now known as {new_name}").format(new_name=plnew.name))
		else:
			self._print_event(_("{player} is now known as {new_name}").format(player=plold.name, new_name=plnew.name))

	def _on_player_changed_color(self, game, plold, plnew, myself):
		if myself:
			self._print_event(_("You changed your color"))
		else:
			self._print_event(_("{player} changed their color").format(player=plnew.name))

	def _on_player_kicked(self, game, player, myself):
		if myself:
			self._windows.open_popup(_("Kicked"), _("You have been kicked from the game by creator"))
			self._windows.close()
		else:
			self._print_event(_("{player} got kicked by creator").format(player=player.name))

########NEW FILE########
__FILENAME__ = pausemenu
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import horizons.main
from horizons.command.game import PauseCommand, UnPauseCommand
from horizons.gui.modules.editorstartmenu import EditorStartMenu
from horizons.gui.modules.settings import SettingsDialog
from horizons.gui.modules.select_savegame import SelectSavegameDialog
from horizons.gui.util import load_uh_widget
from horizons.gui.windows import Window
from horizons.util.startgameoptions import StartGameOptions


class PauseMenu(Window):

	def __init__(self, session, ingame_gui, windows, in_editor_mode=False):
		super(PauseMenu, self).__init__(windows)

		self._session = session
		self._ingame_gui = ingame_gui
		self._in_editor_mode = in_editor_mode

		self.settings_dialog = SettingsDialog(self._windows)

		name = 'editor_pause_menu.xml' if in_editor_mode else 'ingamemenu.xml'
		self._gui = load_uh_widget(name)
		self._gui.position_technique = 'center:center'

		events = {
			'load' : self._load_game,
			'save' : self._save_game,
			'sett' : lambda: self._windows.open(self.settings_dialog),
			'help' : ingame_gui.toggle_help,
			'start': self._windows.close,
			'quit' : self._do_quit,
		}

		self._gui.mapEvents({
			# icons
			'loadgameButton': events['load'],
			'savegameButton': events['save'],
			'settingsLink'  : events['sett'],
			'helpLink'      : events['help'],
			'startGame'     : events['start'],
			'closeButton'   : events['quit'],
			# labels
			'loadgame': events['load'],
			'savegame': events['save'],
			'settings': events['sett'],
			'help'    : events['help'],
			'start'   : events['start'],
			'quit'    : events['quit'],
		})

	def open(self):
		super(PauseMenu, self).open()
		PauseCommand(suggestion=True).execute(self._session)

	def show(self):
		self._gui.show()

	def hide(self):
		self._gui.hide()

	def close(self):
		super(PauseMenu, self).close()
		UnPauseCommand(suggestion=True).execute(self._session)

	def _do_quit(self):
		message = _("Are you sure you want to abort the running session?")
		if self._windows.open_popup(_("Quit Session"), message, show_cancel_button=True):
			self._session.quit()

	def _save_game(self):
		if self._in_editor_mode:
			self._ingame_gui.show_save_map_dialog()
		else:
			success = self._session.save()
			if not success:
				# There was a problem during the 'save game' procedure.
				self._windows.open_popup(_('Error'), _('Failed to save.'))

	def _load_game(self):
		if self._in_editor_mode:
			editor_start_menu = EditorStartMenu(self._windows)
			self._windows.open(editor_start_menu)
		else:
			window = SelectSavegameDialog('load', self._windows)
			saved_game = self._windows.open(window)
			if saved_game is None:
				return

			options = StartGameOptions(saved_game)
			horizons.main.start_singleplayer(options)
			return True

########NEW FILE########
__FILENAME__ = playerdataselection
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import HBox, Label

import horizons.globals
from horizons.gui.util import load_uh_widget
from horizons.util.color import Color
from horizons.util.python.callback import Callback


class PlayerDataSelection(object):
	"""Subwidget for selecting player name and color.
	Used by Multiplayer and Singleplayer menu."""

	def __init__(self, color_palette=None):
		"""
		@param widgets: WidgetsDict
		"""
		self.gui = load_uh_widget('playerdataselection.xml')

		self.colors = self.gui.findChild(name='playercolor')

		colorlabels = []
		events = {}

		# need the id to save it as int in settings file.
		for color in (Color if color_palette is None else color_palette):
			label = Label(name = u'{color}'.format(color=color.name),
			              text = u"    ",
			              max_size = (20, 20),
			              min_size = (20, 20),
			              background_color = color)
			events['{label}/mouseClicked'.format(label=color.name)] = \
			                             Callback(self.set_color, color.id)
			colorlabels.append(label)

		# split into three rows with at max 5 entries in each row
		# right now there are 14 different colors to choose from.
		for i in xrange(0, len(colorlabels), 5):
			hbox = HBox(name='line_{index}'.format(index=i))
			hbox.addChildren(colorlabels[i:i+5])
			self.colors.addChild(hbox)
		
		playertextfield = self.gui.findChild(name='playername')
		def playertextfield_clicked():
			if playertextfield.text == 'Unnamed Traveler':
				playertextfield.text = "";
		playertextfield.capture(playertextfield_clicked, event_name='mouseClicked')
		
		self.gui.mapEvents(events)
		self.update_data()

	def set_color(self, color_id):
		"""Updates the background color of large label where players
		see their currently chosen color.
		@param color_id: int. Gets converted to util.Color object.
		"""
		try:
			self.selected_color = Color[color_id]
		except KeyError:
			# For some reason, color_id can be 0 apparently:
			# http://forum.unknown-horizons.org/viewtopic.php?t=6927
			# Reset that setting to 1 if the problem occurs.
			self.selected_color = Color[1]
		self.gui.findChild(name='selectedcolor').background_color = self.selected_color

	def set_player_name(self, playername):
		"""Updates the player name"""
		self.gui.distributeData({
			'playername': unicode(playername),
			})

	def get_player_name(self):
		"""Returns the name that was entered by the user"""
		return self.gui.collectData('playername')

	def get_player_color(self):
		"""Returns the color that the player selected as Color obj"""
		return self.selected_color

	def get_widget(self):
		return self.gui
	
	def update_data(self):
		"""Update the player's name and color from the settings"""
		self.set_color(horizons.globals.fife.get_uh_setting("ColorID"))
		self.set_player_name(horizons.globals.fife.get_uh_setting("Nickname"))
		
	def save_settings(self):
		"""Stores the current player_name and color into settings"""
		horizons.globals.fife.set_uh_setting("Nickname", self.get_player_name())
		horizons.globals.fife.set_uh_setting("ColorID", self.get_player_color().id)
		horizons.globals.fife.save_settings()
		
		

########NEW FILE########
__FILENAME__ = select_savegame
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife
import os
import os.path
import tempfile
import time

from horizons.engine import Fife
from horizons.extscheduler import ExtScheduler
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.imagebutton import OkButton, CancelButton, DeleteButton
from horizons.gui.windows import Dialog
from horizons.savegamemanager import SavegameManager
from horizons.util.python.callback import Callback
from horizons.util.savegameupgrader import SavegameUpgrader


class SelectSavegameDialog(Dialog):

	def __init__(self, mode, windows):
		super(SelectSavegameDialog, self).__init__(windows)

		assert mode in ('load', 'save', 'editor-save')
		self._mode = mode

		self._gui = load_uh_widget('select_savegame.xml')

		if self._mode == 'save':
			helptext = _('Save game')
		elif self._mode == 'load':
			helptext = _('Load game')
		elif self._mode == 'editor-save':
			helptext = _('Save map')
		self._gui.findChild(name='headline').text = helptext
		self._gui.findChild(name=OkButton.DEFAULT_NAME).helptext = helptext

		w = self._gui.findChild(name="gamename_box")
		if (Fife.getVersion() >= (0, 4, 0)):
			w.parent.hideChild(w)
		else:
			if w not in w.parent.hidden_children:
				w.parent.hideChild(w)
				
		w = self._gui.findChild(name="gamepassword_box")
		if (Fife.getVersion() >= (0, 4, 0)):
			w.parent.hideChild(w)
		else:		
			if w not in w.parent.hidden_children:
				w.parent.hideChild(w)

		w = self._gui.findChild(name='enter_filename')
		if self._mode in ('save', 'editor-save'): # only show enter_filename on save
			w.parent.showChild(w)
		else:
			if (Fife.getVersion() >= (0, 4, 0)):
				w.parent.hideChild(w)
			else:
				if w not in w.parent.hidden_children:
					w.parent.hideChild(w)

		self.last_click_event = None

	def prepare(self):
		if self._mode == 'load':
			self._map_files, self._map_file_display = SavegameManager.get_saves()
			if not self._map_files:
				self._windows.open_popup(_("No saved games"), _("There are no saved games to load."))
				return False
		elif self._mode == 'save':
			self._map_files, self._map_file_display = SavegameManager.get_regular_saves()
		elif self._mode == 'editor-save':
			self._map_files, self._map_file_display = SavegameManager.get_maps()

		self._gui.distributeInitialData({'savegamelist': self._map_file_display})
		if self._mode == 'load':
			self._gui.distributeData({'savegamelist': 0})

		self._cb = self._create_show_savegame_details(self._gui, self._map_files, 'savegamelist')
		if self._mode in ('save', 'editor-save'):
			def selected_changed():
				"""Fills in the name of the savegame in the textbox when selected in the list"""
				if self._gui.collectData('savegamelist') == -1: # set blank if nothing is selected
					self._gui.findChild(name="savegamefile").text = u""
				else:
					savegamefile = self._map_file_display[self._gui.collectData('savegamelist')]
					self._gui.distributeData({'savegamefile': savegamefile})

			self._cb = Callback.ChainedCallbacks(self._cb, selected_changed)

		self._cb()  # Refresh data on start
		self._gui.mapEvents({'savegamelist/action': self._cb})
		self._gui.findChild(name="savegamelist").capture(self._cb, event_name="keyPressed")
		self._gui.findChild(name="savegamelist").capture(self.check_double_click, event_name="mousePressed")

		self.return_events = {
			OkButton.DEFAULT_NAME    : True,
			CancelButton.DEFAULT_NAME: False,
			DeleteButton.DEFAULT_NAME: 'delete'
		}
		if self._mode in ('save', 'editor-save'):
			self.return_events['savegamefile'] = True

	def check_double_click(self, event):
		"""Apply OK button if there was a left double click"""
		if event.getButton() != fife.MouseEvent.LEFT:
			return
		if self.last_click_event == (event.getX(), event.getY()) and self.clicked:
			self.clicked = False
			ExtScheduler().rem_call(self, self.reset_click_status)
			self.trigger_close(OkButton.DEFAULT_NAME)
		else:
			self.clicked = True
			ExtScheduler().add_new_object(self.reset_click_status, self, run_in=0.3, loops=0)
			self.last_click_event = (event.getX(), event.getY())

	def reset_click_status(self):
		"""Callback function to reset the click status by Scheduler"""
		self.clicked = False

	def act(self, retval):
		if not retval:  # cancelled
			return

		if retval == 'delete':
			# delete button was pressed. Apply delete and reshow dialog, delegating the return value
			delete_retval = self._delete_savegame(self._map_files)
			if delete_retval:
				self._gui.distributeData({'savegamelist' : -1})
				self._cb()
			return self._windows.open(self)

		selected_savegame = None
		if self._mode in ('save', 'editor-save'):  # return from textfield
			selected_savegame = self._gui.collectData('savegamefile')
			if selected_savegame == "":
				self._windows.open_error_popup(windowtitle=_("No filename given"),
				                               description=_("Please enter a valid filename."))
				return self._windows.open(self)
			elif selected_savegame in self._map_file_display: # savegamename already exists
				if self._mode == 'save':
					message = _("A savegame with the name {name} already exists.")
				elif self._mode == 'editor-save':
					message = _("A map with the name {name} already exists.")
				message = message.format(name=selected_savegame)
				message += u"\n" + _('Overwrite it?')
				# keep the pop-up non-modal because otherwise it is double-modal (#1876)
				if not self._windows.open_popup(_("Confirmation for overwriting"), message, show_cancel_button=True):
					return self._windows.open(self)

		elif self._mode == 'load':  # return selected item from list
			selected_savegame = self._gui.collectData('savegamelist')
			assert selected_savegame != -1, "No savegame selected in savegamelist"
			selected_savegame = self._map_files[selected_savegame]

		return selected_savegame

	def _create_show_savegame_details(self, gui, map_files, savegamelist):
		"""Creates a function that displays details of a savegame in gui"""

		def tmp_show_details():
			"""Fetches details of selected savegame and displays it"""
			gui.findChild(name="screenshot").image = None
			map_file = None
			map_file_index = gui.collectData(savegamelist)

			savegame_details_box = gui.findChild(name="savegame_details")
			savegame_details_parent = savegame_details_box.parent
			if map_file_index == -1:
				if (Fife.getVersion() >= (0, 4, 0)):
					savegame_details_parent.hideChild(savegame_details_box)
				else:
					if savegame_details_box not in savegame_details_parent.hidden_children:
						savegame_details_parent.hideChild(savegame_details_box)
				return
			else:
				savegame_details_parent.showChild(savegame_details_box)
			try:
				map_file = map_files[map_file_index]
			except IndexError:
				# this was a click in the savegame list, but not on an element
				# it happens when the savegame list is empty
				return
			savegame_info = SavegameManager.get_metadata(map_file)

			if savegame_info.get('screenshot'):
				# try to find a writable location, that is accessible via relative paths
				# (required by fife)
				fd, filename = tempfile.mkstemp()
				try:
					path_rel = os.path.relpath(filename)
				except ValueError: # the relative path sometimes doesn't exist on win
					os.close(fd)
					os.unlink(filename)
					# try again in the current dir, it's often writable
					fd, filename = tempfile.mkstemp(dir=os.curdir)
					try:
						path_rel = os.path.relpath(filename)
					except ValueError:
						fd, filename = None, None

				if fd:
					with os.fdopen(fd, "w") as f:
						f.write(savegame_info['screenshot'])
					# fife only supports relative paths
					gui.findChild(name="screenshot").image = path_rel
					os.unlink(filename)

			# savegamedetails
			details_label = gui.findChild(name="savegamedetails_lbl")
			details_label.text = u""
			if savegame_info['timestamp'] == -1:
				details_label.text += _("Unknown savedate")
			else:
				savetime = time.strftime("%c", time.localtime(savegame_info['timestamp']))
				details_label.text += _("Saved at {time}").format(time=savetime.decode('utf-8'))
			details_label.text += u'\n'
			counter = savegame_info['savecounter']
			# N_ takes care of plural forms for different languages
			details_label.text += N_("Saved {amount} time",
			                         "Saved {amount} times",
			                         counter).format(amount=counter)
			details_label.text += u'\n'

			from horizons.constants import VERSION
			try:
				details_label.text += _("Savegame version {version}").format(
				                         version=savegame_info['savegamerev'])
				if savegame_info['savegamerev'] != VERSION.SAVEGAMEREVISION:
					if not SavegameUpgrader.can_upgrade(savegame_info['savegamerev']):
						details_label.text += u" " + _("(probably incompatible)")
			except KeyError:
				# this should only happen for very old savegames, so having this unfriendly
				# error is ok (savegame is quite certainly fully unusable).
				details_label.text += u" " + _("Incompatible version")

			gui.adaptLayout()
		return tmp_show_details

	def _delete_savegame(self, map_files):
		"""Deletes the selected savegame if the user confirms
		self._gui has to contain the widget "savegamelist"
		@param map_files: list of files that corresponds to the entries of 'savegamelist'
		@return: True if something was deleted, else False
		"""
		selected_item = self._gui.collectData("savegamelist")
		if selected_item == -1 or selected_item >= len(map_files):
			self._windows.open_popup(_("No file selected"), _("You need to select a savegame to delete."))
			return False
		selected_file = map_files[selected_item]
		message = _("Do you really want to delete the savegame '{name}'?").format(
		             name=SavegameManager.get_savegamename_from_filename(selected_file))
		if self._windows.open_popup(_("Confirm deletion"), message, show_cancel_button=True):
			try:
				os.unlink(selected_file)
				return True
			except:
				self._windows.open_popup(_("Error!"), _("Failed to delete savefile!"))
				return False
		else: # player cancelled deletion
			return False

########NEW FILE########
__FILENAME__ = settings
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import collections

from fife import fife

import horizons.globals

from horizons.constants import LANGUAGENAMES, SETTINGS
from horizons.i18n import change_language, _lazy, find_available_languages
from horizons.gui.modules.hotkeys_settings import HotkeyConfiguration
from horizons.gui.modules.loadingscreen import QUOTES_SETTINGS
from horizons.gui.widgets.pickbeltwidget import PickBeltWidget
from horizons.gui.windows import Window
from horizons.network.networkinterface import NetworkInterface
from horizons.util.python import parse_port
from horizons.util.python.callback import Callback


class Setting(object):
	def __init__(self, module, name, widget_name, initial_data=None, restart=False, callback=None):
		self.module = module
		self.name = name
		self.widget_name = widget_name
		self.initial_data = initial_data
		self.restart = restart
		self.callback = callback


class SettingsDialog(PickBeltWidget, Window):
	"""Widget for Options dialog with pickbelt style pages"""

	widget_xml = 'settings.xml'
	sections = (('graphics_settings', _lazy('Graphics')),
	            ('hotkeys_settings', _lazy('Hotkeys')),
			    ('game_settings', _lazy('Game')))

	def __init__(self, windows):
		Window.__init__(self, windows)
		PickBeltWidget.__init__(self)

		self._settings = horizons.globals.fife._setting

		self.widget.mapEvents({
			'okButton': self.apply_settings,
			'defaultButton': self.set_defaults,
			'cancelButton': self._windows.close,
		})

		languages = find_available_languages().keys()
		language_names = [LANGUAGENAMES[x] for x in sorted(languages)]

		fps = {0: _lazy("Disabled"), 30: 30, 45: 45, 60: 60, 90: 90, 120: 120}

		FIFE = SETTINGS.FIFE_MODULE
		UH = SETTINGS.UH_MODULE

		def get_resolutions():
			return get_screen_resolutions(self._settings.get(FIFE, 'ScreenResolution'))

		self._options = [
			# Graphics/Sound/Input
			Setting(FIFE, 'ScreenResolution', 'screen_resolution', get_resolutions, restart=True),
			Setting(FIFE, 'FullScreen', 'enable_fullscreen', restart=True),
			Setting(FIFE, 'FrameLimit', 'fps_rate', fps, restart=True, callback=self._on_FrameLimit_changed),

			Setting(UH, 'VolumeMusic', 'volume_music', callback=self._on_VolumeMusic_changed),
			Setting(UH, 'VolumeEffects', 'volume_effects', callback=self._on_VolumeEffects_changed),
			Setting(FIFE, 'PlaySounds', 'enable_sound', callback=self._on_PlaySounds_changed),
			Setting(UH, 'EdgeScrolling', 'edgescrolling'),
			Setting(UH, 'CursorCenteredZoom', 'cursor_centered_zoom'),
			Setting(UH, 'MiddleMousePan', 'middle_mouse_pan'),
			Setting(FIFE, 'MouseSensitivity', 'mousesensitivity', restart=True),

			# Game
			Setting(UH, 'AutosaveInterval', 'autosaveinterval'),
			Setting(UH, 'AutosaveMaxCount', 'autosavemaxcount'),
			Setting(UH, 'QuicksaveMaxCount', 'quicksavemaxcount'),
			Setting(UH, 'Language', 'uni_language', language_names, callback=self._on_Language_changed),

			Setting(UH, 'MinimapRotation', 'minimaprotation'),
			Setting(UH, 'UninterruptedBuilding', 'uninterrupted_building'),
			Setting(UH, 'AutoUnload', 'auto_unload'),
			Setting(UH, 'DebugLog', 'debug_log', callback=self._on_DebugLog_changed),
			Setting(UH, 'ShowResourceIcons', 'show_resource_icons'),
			Setting(UH, 'ScrollSpeed', 'scrollspeed'),
			Setting(UH, 'QuotesType', 'quotestype', QUOTES_SETTINGS),
			Setting(UH, 'NetworkPort', 'network_port', callback=self._on_NetworkPort_changed),
		]

		self._fill_widgets()

		# key configuration
		hk = HotkeyConfiguration()
		number = self.sections.index(('hotkeys_settings', _('Hotkeys')))
		self.page_widgets[number].addChild(hk.widget)
		self.hotkey_interface = hk

	def show(self):
		self.widget.show()

	def hide(self):
		self.widget.hide()

	def show_restart_popup(self):
		headline = _("Restart required")
		message = _("Some of your changes require a restart of Unknown Horizons.")
		self._windows.open_popup(headline, message)

	def set_defaults(self):
		title = _("Restore default settings")
		msg = _("Restoring the default settings will delete all changes to the settings you made so far.") + \
				u" " + _("Do you want to continue?")

		if self._windows.open_popup(title, msg, show_cancel_button=True):
			self.hotkey_interface.reset_to_default()
			self._settings.set_defaults()
			self.show_restart_popup()
			self._windows.close()

	def apply_settings(self):
		restart_required = False

		for entry in self._options:
			widget = self.widget.findChild(name=entry.widget_name)
			new_value = widget.getData()

			if isinstance(entry.initial_data, collections.Callable):
				initial_data = entry.initial_data()
			else:
				initial_data = entry.initial_data

			if isinstance(initial_data, list):
				new_value = initial_data[new_value]
			elif isinstance(initial_data, dict):
				new_value = initial_data.keys()[new_value]

			old_value = self._settings.get(entry.module, entry.name)

			# Store new setting
			self._settings.set(entry.module, entry.name, new_value)

			# If setting changed, allow applying of new value and sanity checks
			if new_value != old_value:
				if entry.restart:
					restart_required = True

				if entry.callback:
					entry.callback(old_value, new_value)

		if restart_required:
			self.show_restart_popup()

		self.hotkey_interface.save_settings()
		self._settings.apply()
		self._settings.save()
		self._windows.close()

	def _fill_widgets(self):
		for entry in self._options:
			value = self._settings.get(entry.module, entry.name)
			widget = self.widget.findChild(name=entry.widget_name)

			if entry.initial_data:
				if isinstance(entry.initial_data, collections.Callable):
					initial_data = entry.initial_data()
				else:
					initial_data = entry.initial_data

				if isinstance(initial_data, dict):
					widget.setInitialData(initial_data.values())
					value = initial_data.keys().index(value)
				elif isinstance(initial_data, list):
					widget.setInitialData(initial_data)
					value = initial_data.index(value)
				else:
					widget.setInitialData(initial_data)

			widget.setData(value)

			# For sliders, there also is a label showing the current value
			if isinstance(widget, horizons.globals.fife.pychan.widgets.Slider):
				cb = Callback(self.slider_change, widget)
				cb()
				widget.capture(cb)

	def slider_change(self, widget):
		"""Callback for updating value label of a slider after dragging it.

		As the numeric values under the hood often do not represent mental
		models of what the setting achieves very well, depending on the
		setting in question we display a modified value, sometimes with
		a '%' suffix."""
		value_label = self.widget.findChild(name=widget.name + '_value')
		value = {
			'volume_music':      lambda x: u'%s%%' % int(500 * x),
			'volume_effects':    lambda x: u'%s%%' % int(200 * x),
			'mousesensitivity':  lambda x: u'%+.1f%%' % (200 * x),
			'autosaveinterval':  lambda x: u'%d' % x,
			'autosavemaxcount':  lambda x: u'%d' % x,
			'quicksavemaxcount': lambda x: u'%d' % x,
			'scrollspeed':       lambda x: u'%.1f' % x,
		}[widget.name](widget.value)
		value_label.text = value

	# callbacks for changes of settings

	def _on_PlaySounds_changed(self, old, new):
		horizons.globals.fife.sound.setup_sound()

	def _on_VolumeMusic_changed(self, old, new):
		horizons.globals.fife.sound.set_volume_bgmusic(new)

	def _on_VolumeEffects_changed(self, old, new):
		horizons.globals.fife.sound.set_volume_effects(new)

	def _on_FrameLimit_changed(self, old, new):
		# handling value 0 for framelimit to disable limiter
		if new == 0:
			self._settings.set(SETTINGS.FIFE_MODULE, 'FrameLimitEnabled', False)
		else:
			self._settings.set(SETTINGS.FIFE_MODULE, 'FrameLimitEnabled', True)

	def _on_NetworkPort_changed(self, old, new):
		"""Sets a new value for client network port"""
		# port is saved as string due to pychan limitations
		try:
			# 0 is not a valid port, but a valid value here (used for default)
			parse_port(new)
		except ValueError:
			headline = _("Invalid network port")
			descr = _("The port you specified is not valid. It must be a number between 1 and 65535.")
			advice = _("Please check the port you entered and make sure it is in the specified range.")
			self._windows.open_error_popup(headline, descr, advice)
			# reset value and reshow settings dlg
			self._settings.set(SETTINGS.UH_MODULE, 'NetworkPort', u"0")
		else:
			# port is valid
			try:
				if NetworkInterface() is None:
					NetworkInterface.create_instance()
				NetworkInterface().network_data_changed()
			except Exception as e:
				headline = _("Failed to apply new network settings.")
				descr = _("Network features could not be initialized with the current configuration.")
				advice = _("Check the settings you specified in the network section.")
				if 0 < parse_port(new) < 1024:
					#i18n This is advice for players seeing a network error with the current config
					advice += u" " + \
						_("Low port numbers sometimes require special access privileges, try 0 or a number greater than 1024.")
				details = unicode(e)
				self._windows.open_error_popup(headline, descr, advice, details)

	def _on_Language_changed(self, old, new):
		language = LANGUAGENAMES.get_by_value(new)
		change_language(language)

	def _on_DebugLog_changed(self, old, new):
		horizons.main.set_debug_log(new)

def get_screen_resolutions(selected_default):
	"""Create an instance of fife.DeviceCaps and compile a list of possible resolutions.

	NOTE: This call only works if the engine is inited.
	"""
	possible_resolutions = set([selected_default])

	MIN_X = 800
	MIN_Y = 600

	devicecaps = fife.DeviceCaps()
	devicecaps.fillDeviceCaps()

	for screenmode in devicecaps.getSupportedScreenModes():
		x = screenmode.getWidth()
		y = screenmode.getHeight()
		if x < MIN_X or y < MIN_Y:
			continue
		res = str(x) + 'x' + str(y)
		possible_resolutions.add(res)

	by_width = lambda res: int(res.split('x')[0])
	return sorted(possible_resolutions, key=by_width)

########NEW FILE########
__FILENAME__ = singleplayermenu
# Encoding: utf-8
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import json
import locale
import logging
import os
import subprocess
import sys
import tempfile

import horizons.globals
import horizons.main

from horizons.world import load_raw_world  # FIXME placing this import at the end results in a cycle
from horizons.constants import LANGUAGENAMES, PATHS, VERSION
from horizons.extscheduler import ExtScheduler
from horizons.gui.modules import AIDataSelection, PlayerDataSelection
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.minimap import Minimap
from horizons.gui.windows import Window
from horizons.savegamemanager import SavegameManager
from horizons.scenario import ScenarioEventHandler, InvalidScenarioFileFormat
from horizons.util.python.callback import Callback
from horizons.util.random_map import generate_random_map, generate_random_seed
from horizons.util.shapes import Rect
from horizons.util.startgameoptions import StartGameOptions


class SingleplayerMenu(Window):

	def __init__(self, windows):
		super(SingleplayerMenu, self).__init__(windows)

		self._mode = None

		self._gui = load_uh_widget('singleplayermenu.xml')
		self._gui.mapEvents({
			'cancel'   : self._windows.close,
			'okay'     : self.act,
			'scenario' : Callback(self._select_mode, 'scenario'),
			'random'   : Callback(self._select_mode, 'random'),
			'free_maps': Callback(self._select_mode, 'free_maps')
		})

		self._playerdata = PlayerDataSelection()
		self._aidata = AIDataSelection()
		self._gui.findChild(name="playerdataselectioncontainer").addChild(self._playerdata.get_widget())
		self._gui.findChild(name="aidataselectioncontainer").addChild(self._aidata.get_widget())

	def hide(self):
		# Save the player-data on hide so that other menus gets updated data
		self._playerdata.save_settings()
		self._gui.hide()

	def show(self):
		self._playerdata.update_data()
		self._gui.findChild(name='scenario').marked = True
		self._select_mode('scenario')

	def on_return(self):
		self.act()

	def _select_mode(self, mode):
		self._gui.hide()

		modes = {
			'random': RandomMapWidget,
			'free_maps': FreeMapsWidget,
			'scenario': ScenarioMapWidget,
		}

		# remove old widget
		if self._mode:
			self._mode.end()
			self._gui.findChild(name="right_side_box").removeChild(self._mode.get_widget())

		self._mode = modes[mode](self._windows, self, self._aidata)
		self._mode.show()

		self._gui.findChild(name="right_side_box").addChild(self._mode.get_widget())
		self._gui.show()

	def act(self):
		"""Start the game. Called when OK button is pressed."""
		player_color = self._playerdata.get_player_color()
		player_name = self._playerdata.get_player_name()

		if not player_name:
			self._windows.open_popup(_("Invalid player name"), _("You entered an invalid playername."))
			return

		horizons.globals.fife.set_uh_setting("Nickname", player_name)

		self._windows.close()
		self._mode.act(player_name, player_color)


class GameSettingsWidget(object):
	"""Toggle trader/pirates/disasters and change resource density."""

	resource_densities = [0.5, 0.7, 1, 1.4, 2]

	def __init__(self):
		self._gui = load_uh_widget('game_settings.xml')

	def get_widget(self):
		return self._gui

	def show(self):
		# make click on labels change the respective checkboxes
		checkboxes = [('free_trader', 'MapSettingsFreeTraderEnabled'),
		              ('pirates', 'MapSettingsPirateEnabled'),
		              ('disasters', 'MapSettingsDisastersEnabled')]

		for (setting, setting_save_name) in checkboxes:
			def on_box_toggle(setting, setting_save_name):
				"""Called whenever the checkbox is toggled"""
				box = self._gui.findChild(name=setting)
				horizons.globals.fife.set_uh_setting(setting_save_name, box.marked)
				horizons.globals.fife.save_settings()
			def toggle(setting, setting_save_name):
				"""Called by the label to toggle the checkbox"""
				box = self._gui.findChild(name=setting)
				box.marked = not box.marked

			self._gui.findChild(name=setting).capture(Callback(on_box_toggle, setting, setting_save_name))
			self._gui.findChild(name=setting).marked = horizons.globals.fife.get_uh_setting(setting_save_name)
			self._gui.findChild(name=u'lbl_' + setting).capture(Callback(toggle, setting, setting_save_name))

		resource_density_slider = self._gui.findChild(name='resource_density_slider')
		def on_resource_density_slider_change():
			self._gui.findChild(name='resource_density_lbl').text = _('Resource density:') + u' ' + \
				unicode(self.resource_densities[int(resource_density_slider.value)]) + u'x'
			horizons.globals.fife.set_uh_setting("MapResourceDensity", resource_density_slider.value)
			horizons.globals.fife.save_settings()
		resource_density_slider.capture(on_resource_density_slider_change)
		resource_density_slider.value = horizons.globals.fife.get_uh_setting("MapResourceDensity")

		on_resource_density_slider_change()

	@property
	def natural_resource_multiplier(self):
		return self.resource_densities[int(self._gui.findChild(name='resource_density_slider').value)]

	@property
	def free_trader(self):
		return self._gui.findChild(name='free_trader').marked

	@property
	def pirates(self):
		return self._gui.findChild(name='pirates').marked

	@property
	def disasters(self):
		return self._gui.findChild(name='disasters').marked


class RandomMapWidget(object):
	"""Create a random map, influence map generation with multiple sliders."""

	map_sizes = [50, 100, 150, 200, 250]
	water_percents = [20, 30, 40, 50, 60, 70, 80]
	island_sizes = [30, 40, 50, 60, 70]
	island_size_deviations = [5, 10, 20, 30, 40]

	def __init__(self, windows, singleplayer_menu, aidata):
		self._windows = windows
		self._singleplayer_menu = singleplayer_menu
		self._aidata = aidata

		self._gui = load_uh_widget('sp_random.xml')
		self._map_parameters = {}  # stores the current values from the sliders
		self._game_settings = GameSettingsWidget()

		# Map preview
		self._last_map_parameters = None
		self._preview_process = None
		self._preview_output = None
		self._map_preview = None

	def end(self):
		if self._preview_process:
			self._preview_process.kill()
			self._preview_process = None
		ExtScheduler().rem_all_classinst_calls(self)

	def get_widget(self):
		return self._gui

	def act(self, player_name, player_color):
		self.end()

		map_file = generate_random_map(*self._get_map_parameters())

		options = StartGameOptions.create_start_map(map_file)
		options.set_human_data(player_name, player_color)
		options.ai_players = self._aidata.get_ai_players()
		options.trader_enabled = self._game_settings.free_trader
		options.pirate_enabled = self._game_settings.pirates
		options.disasters_enabled = self._game_settings.disasters
		options.natural_resource_multiplier = self._game_settings.natural_resource_multiplier
		horizons.main.start_singleplayer(options)

	def show(self):
		seed_string_field = self._gui.findChild(name='seed_string_field')
		seed_string_field.capture(self._on_random_parameter_changed)
		seed_string_field.text = generate_random_seed(seed_string_field.text)

		parameters = (
			('map_size', self.map_sizes, _('Map size:'), 'RandomMapSize'),
			('water_percent', self.water_percents, _('Water:'), 'RandomMapWaterPercent'),
			('max_island_size', self.island_sizes, _('Max island size:'), 'RandomMapMaxIslandSize'),
			('preferred_island_size', self.island_sizes, _('Preferred island size:'), 'RandomMapPreferredIslandSize'),
			('island_size_deviation', self.island_size_deviations, _('Island size deviation:'), 'RandomMapIslandSizeDeviation'),
		)

		for param, __, __, setting_name in parameters:
			self._map_parameters[param] = horizons.globals.fife.get_uh_setting(setting_name)

		def make_on_change(param, values, text, setting_name):
			# When a slider is changed, update the value displayed in the label, save the value
			# in the settings and store the value in self._map_parameters
			def on_change():
				slider = self._gui.findChild(name=param + '_slider')
				self._gui.findChild(name=param + '_lbl').text = text + u' ' + unicode(values[int(slider.value)])
				horizons.globals.fife.set_uh_setting(setting_name, slider.value)
				horizons.globals.fife.save_settings()
				self._on_random_parameter_changed()
				self._map_parameters[param] = values[int(slider.value)]
			return on_change

		for param, values, text, setting_name in parameters:
			slider = self._gui.findChild(name=param + '_slider')
			on_change = make_on_change(param, values, text, setting_name)
			slider.capture(on_change)
			slider.value = horizons.globals.fife.get_uh_setting(setting_name)
			on_change()

		self._gui.findChild(name='game_settings_box').addChild(self._game_settings.get_widget())
		self._game_settings.show()
		self._aidata.show()

	def _get_map_parameters(self):
		return (
			self._gui.findChild(name='seed_string_field').text,
			self._map_parameters['map_size'],
			self._map_parameters['water_percent'],
			self._map_parameters['max_island_size'],
			self._map_parameters['preferred_island_size'],
			self._map_parameters['island_size_deviation']
		)

	def _on_random_parameter_changed(self):
		self._update_map_preview()

	# Map preview

	def _on_preview_click(self, event, drag):
		seed_string_field = self._gui.findChild(name='seed_string_field')
		seed_string_field.text = generate_random_seed(seed_string_field.text)
		self._on_random_parameter_changed()

	def _update_map_preview(self):
		"""Start a new process to generate a map preview."""
		current_parameters = self._get_map_parameters()
		if self._last_map_parameters == current_parameters:
			# nothing changed, don't generate a new preview
			return

		self._last_map_parameters = current_parameters

		if self._preview_process:
			self._preview_process.kill() # process exists, therefore up is scheduled already

		# launch process in background to calculate minimap data
		minimap_icon = self._gui.findChild(name='map_preview_minimap')
		params = json.dumps(((minimap_icon.width, minimap_icon.height), current_parameters))

		args = [sys.executable, sys.argv[0], "--generate-minimap", params]
		# We're running UH in a new process, make sure fife is setup correctly
		if horizons.main.command_line_arguments.fife_path:
			args.extend(["--fife-path", horizons.main.command_line_arguments.fife_path])

		handle, self._preview_output = tempfile.mkstemp()
		os.close(handle)
		self._preview_process = subprocess.Popen(args=args, stdout=open(self._preview_output, "w"))
		self._set_map_preview_status(u"Generating preview…")

		ExtScheduler().add_new_object(self._poll_preview_process, self, 0.5)

	def _poll_preview_process(self):
		"""This will be called regularly to see if the process ended.

		If the process has not yet finished, schedule a new callback to this function.
		Otherwise use the data to update the minimap.
		"""
		if not self._preview_process:
			return

		self._preview_process.poll()

		if self._preview_process.returncode is None: # not finished
			ExtScheduler().add_new_object(self._poll_preview_process, self, 0.1)
			return
		elif self._preview_process.returncode != 0:
			self._preview_process = None
			self._set_map_preview_status(u"An unknown error occurred while generating the map preview")
			return

		with open(self._preview_output, 'r') as f:
			data = f.read()

		os.unlink(self._preview_output)
		self._preview_process = None

		if self._map_preview:
			self._map_preview.end()

		self._map_preview = Minimap(
			self._gui.findChild(name='map_preview_minimap'),
			session=None,
			view=None,
			world=None,
			targetrenderer=horizons.globals.fife.targetrenderer,
			imagemanager=horizons.globals.fife.imagemanager,
			cam_border=False,
			use_rotation=False,
			tooltip=_("Click to generate a different random map"),
			on_click=self._on_preview_click,
			preview=True)

		self._map_preview.draw_data(data)
		self._set_map_preview_status(u"")

	def _set_map_preview_status(self, text):
		self._gui.findChild(name="map_preview_status_label").text = text


class FreeMapsWidget(object):
	"""Start a game by selecting an existing map."""

	def __init__(self, windows, singleplayer_menu, aidata):
		self._windows = windows
		self._singleplayer_menu = singleplayer_menu
		self._aidata = aidata

		self._gui = load_uh_widget('sp_free_maps.xml')
		self._game_settings = GameSettingsWidget()

		self._map_preview = None

	def end(self):
		pass

	def get_widget(self):
		return self._gui

	def act(self, player_name, player_color):
		map_file = self._get_selected_map()

		options = StartGameOptions.create_start_map(map_file)
		options.set_human_data(player_name, player_color)
		options.ai_players = self._aidata.get_ai_players()
		options.trader_enabled = self._game_settings.free_trader
		options.pirate_enabled = self._game_settings.pirates
		options.disasters_enabled = self._game_settings.disasters
		options.natural_resource_multiplier = self._game_settings.natural_resource_multiplier
		horizons.main.start_singleplayer(options)

	def show(self):
		self._files, maps_display = SavegameManager.get_maps()

		self._gui.distributeInitialData({'maplist': maps_display})
		self._gui.mapEvents({
			'maplist/action': self._update_map_infos,
		})
		if maps_display: # select first entry
			self._gui.distributeData({'maplist': 0})
			self._update_map_infos()

		self._gui.findChild(name='game_settings_box').addChild(self._game_settings.get_widget())
		self._game_settings.show()
		self._aidata.show()

	def _update_map_infos(self):
		map_file = self._get_selected_map()

		number_of_players = SavegameManager.get_recommended_number_of_players(map_file)
		lbl = self._gui.findChild(name="recommended_number_of_players_lbl")
		lbl.text = _("Recommended number of players: {number}").format(number=number_of_players)

		self._update_map_preview(map_file)

	def _get_selected_map(self):
		selection_index = self._gui.collectData('maplist')
		assert selection_index != -1

		return self._files[self._gui.collectData('maplist')]

	def _update_map_preview(self, map_file):
		if self._map_preview:
			self._map_preview.end()

		world = load_raw_world(map_file)
		self._map_preview = Minimap(
			self._gui.findChild(name='map_preview_minimap'),
			session=None,
			view=None,
			world=world,
			targetrenderer=horizons.globals.fife.targetrenderer,
			imagemanager=horizons.globals.fife.imagemanager,
			cam_border=False,
			use_rotation=False,
			tooltip=None,
			on_click=None,
			preview=True)

		self._map_preview.draw()


class ScenarioMapWidget(object):
	"""Start a scenario (with a specific language)."""

	def __init__(self, windows, singleplayer_menu, aidata):
		self._windows = windows
		self._singleplayer_menu = singleplayer_menu
		self._aidata = aidata
		self._scenarios = {}

		self._gui = load_uh_widget('sp_scenario.xml')

	def end(self):
		pass

	def get_widget(self):
		return self._gui

	def act(self, player_name, player_color):
		map_file = self._get_selected_map()

		try:
			options = StartGameOptions.create_start_scenario(map_file)
			options.set_human_data(player_name, player_color)
			horizons.main.start_singleplayer(options)
		except InvalidScenarioFileFormat as e:
			self._show_invalid_scenario_file_popup(e)

	def show(self):
		self._aidata.hide()

		self._scenarios = SavegameManager.get_available_scenarios()

		# get the map files and their display names. display tutorials on top.
		self.maps_display = self._scenarios.keys()
		if not self.maps_display:
			return

		prefer_tutorial = lambda x: ('tutorial' not in x, x)
		self.maps_display.sort(key=prefer_tutorial)

		self._gui.distributeInitialData({'maplist' : self.maps_display})
		self._gui.distributeData({'maplist': 0})

		# add all locales to lang list, select current locale as default and sort
		scenario_langs = list(set(l for s in self._scenarios.values() for l, filename in s))
		lang_list = self._gui.findChild(name="uni_langlist")
		lang_list.items = sorted([LANGUAGENAMES[l] for l in scenario_langs])

		cur_locale = horizons.globals.fife.get_locale()
		if LANGUAGENAMES[cur_locale] in lang_list.items:
			lang_list.selected = lang_list.items.index(LANGUAGENAMES[cur_locale])
		else:
			lang_list.selected = 0

		self._gui.mapEvents({
			'maplist/action': self._update_infos,
			'uni_langlist/action': self._update_infos,
		})
		self._update_infos()

	def _show_invalid_scenario_file_popup(self, exception):
		"""Shows a popup complaining about invalid scenario file.

		@param exception: Something that str() will convert to an error message
		"""
		logging.getLogger('gui.windows').error(u"Error: %s", exception)
		self._windows.open_error_popup(
			_("Invalid scenario file"),
			description=_("The selected file is not a valid scenario file."),
			details=_("Error message:") + u' ' + unicode(str(exception)),
			advice=_("Please report this to the author."))

	def _update_infos(self):
		"""Fill in infos of selected scenario to label

		TODO document the 100 side effects"""
		scenario = self._gui.findChild(name="maplist").selected_item
		lang_list = self._gui.findChild(name="uni_langlist")
		selected_language = lang_list.selected_item

		lang_list.items = self._get_available_languages(scenario)
		lang_list.selected = 0
		if selected_language in lang_list.items:
			lang_list.selected = lang_list.items.index(selected_language)

		cur_locale = LANGUAGENAMES.get_by_value(lang_list.selected_item)
		translated_scenario = self._find_map_filename(scenario, cur_locale)

		if translated_scenario is None:
			translated_scenario = self._guess_suitable_default_locale(scenario)
			if translated_scenario is None:
				return
		self._update_scenario_translation_infos(translated_scenario)

	def _guess_suitable_default_locale(self, scenario):
		"""Attempts to guess a reasonable localized scenario to preselect in SP menu.

		If no filename was found so far for our scenario:
		 1. Try harder to find locale of user
		 2. Try to find a file for the system locale
		 3. Fall back to English
		"""
		try:
			default_locale, default_encoding = locale.getdefaultlocale()
		except ValueError: # OS X sometimes returns 'UTF-8' as locale, which is a ValueError
			default_locale = 'en'

		possibilities = [
			default_locale,
			default_locale.split('@')[0],
			default_locale.split('_')[0],
			'en',
		]
		lang_list = self._gui.findChild(name="uni_langlist")
		for lang in possibilities:
			if LANGUAGENAMES[lang] in lang_list.items:
				lang_list.selected = lang_list.items.index(LANGUAGENAMES[lang])
				return self._find_map_filename(scenario, lang)

	def _update_scenario_translation_infos(self, scenario):
		"""Fill in translation infos of selected scenario to translation label."""
		try:
			metadata = ScenarioEventHandler.get_metadata_from_file(scenario)
		except InvalidScenarioFileFormat as e:
			self._show_invalid_scenario_file_popup(e)
			return

		translation_status = metadata.get('translation_status', u'')
		lbl = self._gui.findChild(name="translation_status")
		lbl.text = translation_status

		lbl = self._gui.findChild(name="uni_map_difficulty")
		lbl.text = _("Difficulty: {difficulty}").format(difficulty=metadata['difficulty'])

		lbl = self._gui.findChild(name="uni_map_author")
		lbl.text = _("Author: {author}").format(author=metadata['author'])

		lbl = self._gui.findChild(name="uni_map_desc")
		lbl.text = _("Description: {desc}").format(desc=metadata['description'])

	def _find_map_filename(self, scenario_name, target_locale):
		"""Finds the given map's filename with its locale."""
		for language, mapfile in self._scenarios[scenario_name]:
			if language == target_locale and os.path.exists(mapfile):
				return mapfile

	def _get_available_languages(self, scenario):
		sc = self._scenarios[scenario]
		scenario_langs = list(set(language for language, filename in sc))
		return [LANGUAGENAMES[l] for l in sorted(scenario_langs)]

	def _get_selected_map(self):
		selection_index = self._gui.collectData('maplist')
		assert selection_index != -1
		scenario = self._scenarios[self.maps_display[selection_index]]
		language_index = self._gui.collectData('uni_langlist')
		return scenario[language_index][1]


def generate_random_minimap(size, parameters):
	"""Called as subprocess, calculates minimap data and passes it via string via stdout"""
	# called as standalone basically, so init everything we need
	from horizons.entities import Entities
	from horizons.ext.dummy import Dummy
	from horizons.main import _create_main_db

	if not VERSION.IS_DEV_VERSION:
		# Hack enable atlases.
		# Usually the minimap generator uses single tile files, but in release
		# mode these are not available. Therefor we have to hackenable atlases
		# for the minimap generation in this case. This forces the game to use
		# the correct imageloader
		# In normal dev mode + enabled atlases we ignore this and just continue
		# to use single tile files instead of atlases for the minimap generation.
		# These are always available in dev checkouts
		PATHS.DB_FILES = PATHS.DB_FILES + (PATHS.ATLAS_DB_PATH, )

	db = _create_main_db()
	horizons.globals.db = db
	horizons.globals.fife.init_animation_loader(not VERSION.IS_DEV_VERSION)
	Entities.load_grounds(db, load_now=False) # create all references

	map_file = generate_random_map(*parameters)
	world = load_raw_world(map_file)
	location = Rect.init_from_topleft_and_size_tuples((0, 0), size)
	minimap = Minimap(
		location,
		session=None,
		view=None,
		world=world,
		targetrenderer=Dummy(),
		imagemanager=Dummy(),
		cam_border=False,
		use_rotation=False,
		preview=True)

	# communicate via stdout
	print minimap.dump_data()

########NEW FILE########
__FILENAME__ = attackingtool
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife

import horizons.globals
from horizons.command.unit import Act, Attack
from horizons.command.diplomacy import AddEnemyPair
from horizons.component.healthcomponent import HealthComponent
from horizons.gui.mousetools.selectiontool import SelectionTool

class AttackingTool(SelectionTool):
	"""
		This will be used when attacking units are selected
		it will have to respond on right click and change cursor image when hovering enemy units
	"""

	send_hover_instances_update = False

	def __init__(self, session):
		super(AttackingTool, self).__init__(session)

	def mousePressed(self, evt):
		if evt.getButton() == fife.MouseEvent.RIGHT:
			target_mapcoord = self.session.view.cam.toMapCoordinates(
				fife.ScreenPoint(evt.getX(), evt.getY()), False)

			target = self._get_attackable_instance(evt)

			if target:
				if not self.session.world.diplomacy.are_enemies(self.session.world.player, target.owner):
					AddEnemyPair(self.session.world.player, target.owner).execute(self.session)
				for i in self.session.selected_instances:
					if hasattr(i, 'attack'):
						Attack(i, target).execute(self.session)
			else:
				for i in self.session.selected_instances:
					if i.movable:
						Act(i, target_mapcoord.x, target_mapcoord.y).execute(self.session)
			evt.consume()
		else:
			self.deselect_at_end = False
			super(AttackingTool, self).mousePressed(evt)

	def mouseMoved(self, evt):
		super(AttackingTool, self).mouseMoved(evt)
		target = self._get_attackable_instance(evt)
		if target:
			horizons.globals.fife.set_cursor_image("attacking")
		else:
			horizons.globals.fife.set_cursor_image("default")

	def _get_attackable_instance(self, evt):
		"""
		Returns target instance if mouse is over an attackable instance
		Returns None if mouse is not over an attackable instance
		"""
		instances = self.get_hover_instances(evt)

		target = None
		local_player = self.session.world.player
		for instance in instances:
			if not instance.owner:
				continue

			if instance.owner is local_player:
				continue

			# Check diplomacy state between local player and instance owner.
			if not self.session.world.diplomacy.are_enemies(local_player, instance.owner) \
				and not evt.isShiftPressed():
				continue
			if instance.has_component(HealthComponent):
				target = instance
		return target

########NEW FILE########
__FILENAME__ = buildingtool
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife
import logging
import random
import weakref

import horizons.globals

from horizons.entities import Entities
from horizons.util.loaders.actionsetloader import ActionSetLoader
from horizons.util.python import decorators
from horizons.util.shapes import Point
from horizons.util.worldobject import WorldObject
from horizons.command.building import Build
from horizons.component.selectablecomponent import SelectableBuildingComponent, SelectableComponent
from horizons.gui.mousetools.navigationtool import NavigationTool
from horizons.command.sounds import PlaySound
from horizons.gui.util import load_uh_widget
from horizons.constants import BUILDINGS, GFX
from horizons.extscheduler import ExtScheduler
from horizons.messaging import SettlementRangeChanged, WorldObjectDeleted, SettlementInventoryUpdated, PlayerInventoryUpdated

class BuildingTool(NavigationTool):
	"""Represents a dangling tool after a building was selected from the list.
	Builder visualizes if and why a building can not be built under the cursor position.
	@param building: selected building type"
	@param ship: If building from a ship, restrict to range of ship

	The building tool has been under heavy development for several years, it's a collection
	of random artifacts that used to have a purpose once.

	Terminology:
	- Related buildings: Buildings lower in the hierarchy, needed by current building to operate (tree when building lumberjack)
	- Inversely related building: lumberjack for tree. Need to show its range to place building, it must be in range.
	- Building instances/fife instances: the image of a building, that is dragged around.

	Main features:
	- Display tab to the right, showing build preview icon and rotation button (draw_gui(), load_gui())
	- Show buildable ground (highlight buildable) as well as ranges of inversely related buildings
		- This also is called for tiles that need to be recolored, other highlights sometimes draw over
		  tiles, then this is called again to redo the original coloring.
	- Catch mouse events and handle preview on map:
		- Get tentative fife instances for buildings, draw them colored according to buildability
		- Check for resources missing for build
		- Making surrounding of preview transparent, so you see where you are building in a forest
		- Highlight related buildings, that are in range
		- Draw building range and highlight related buildings that are in range in this position (_color_preview_building)
	- Initiate actual build (do_build)
		- Clean up coloring, possibly end build mode
	- Several buildability logics, strategy pattern via self._build_logic.

	Interaction sequence:
	- Init, comprises mainly of gui init and highlight_buildable
	- Update, which is mainly controlled by preview_build
		- Update highlights related to build
			- Transparency
			- Inversely related buildings in range (highlight_related_buildings)
			- Related buildings in range (_color_preview_build)
		- Set new instances
		- During this time, don't touch anything set by highlight_buildable, or restore it later
	- End, possibly do_build and on_escape
	"""
	log = logging.getLogger("gui.buildingtool")

	buildable_color = (255, 255, 255)
	not_buildable_color = (255, 0, 0, 160)
	related_building_color = (0, 192, 0, 160)
	related_building_outline = (32, 192, 32, 3)
	nearby_objects_radius = 4

	# archive the last roads built, for possible user notification
	_last_road_built = []

	send_hover_instances_update = False

	gui = None # share gui between instances

	def __init__(self, session, building, ship=None, build_related=None):
		super(BuildingTool, self).__init__(session)
		assert not (ship and build_related)
		self.renderer = self.session.view.renderer['InstanceRenderer']
		self.ship = ship
		self._class = building
		self.__init_selectable_component()
		self.buildings = [] # list of PossibleBuild objs
		self.buildings_action_set_ids = [] # list action set ids of list above
		self.buildings_fife_instances = {} # fife instances of possible builds
		self.buildings_missing_resources = {} # missing resources for possible builds
		self.rotation = 45 + random.randint(0, 3) * 90
		self.start_point, self.end_point = None, None
		self.last_change_listener = None
		self._transparencified_instances = set() # fife instances modified for transparency
		self._buildable_tiles = set() # tiles marked as buildable
		self._related_buildings = set() # buildings highlighted as related
		self._highlighted_buildings = set() # related buildings highlighted when preview is near it
		self._build_logic = None
		self._related_buildings_selected_tiles = frozenset() # highlights w.r.t. related buildings
		if self.ship is not None:
			self._build_logic = ShipBuildingToolLogic(ship)
		elif build_related is not None:
			self._build_logic = BuildRelatedBuildingToolLogic(self, weakref.ref(build_related) )
		else:
			self._build_logic = SettlementBuildingToolLogic(self)

		self.load_gui()
		self.__class__.gui.show()
		self.session.ingame_gui.minimap_to_front()

		self.highlight_buildable()
		WorldObjectDeleted.subscribe(self._on_worldobject_deleted)

		SettlementInventoryUpdated.subscribe(self.update_preview)
		PlayerInventoryUpdated.subscribe(self.update_preview)


	def __init_selectable_component(self):
		self.selectable_comp = SelectableBuildingComponent
		try:
			template = self._class.get_component_template(SelectableComponent)
			self.selectable_comp = SelectableComponent.get_instance(template)
		except KeyError:
			pass

	def highlight_buildable(self, tiles_to_check=None, new_buildings=True):
		"""Highlights all buildable tiles and select buildings that are inversely related in order to show their range.
		@param tiles_to_check: list of tiles to check for coloring.
		@param new_buildings: Set to True if you have set tiles_to_check and there are new buildings. An internal structure for optimization will be amended."""
		self._build_logic.highlight_buildable(self, tiles_to_check)

		# Also distinguish inversely related buildings (lumberjack for tree).
		# Highlight their range at all times.
		# (There is another similar highlight, but it only marks building when
		# the current build preview is in its range)
		related = self.session.db.get_inverse_related_building_ids(self._class.id)

		# If the current buildings has related buildings, also show other buildings
		# of this class. You usually don't want overlapping ranges of e.g. lumberjacks.
		if self._class.id in self.session.db.get_buildings_with_related_buildings() and \
		   self._class.id != BUILDINGS.RESIDENTIAL:
			# TODO: generalize settler class exclusion, e.g. when refactoring it into components

			related = related + [self._class.id] # don't += on retrieved data from db

		related = frozenset(related)

		renderer = self.session.view.renderer['InstanceRenderer']
		if tiles_to_check is None or new_buildings: # first run, check all
			buildings_to_select = [ buildings_to_select
			                        for settlement in self.session.world.settlements
			                        if settlement.owner.is_local_player
			                        for bid in related
			                        for buildings_to_select in settlement.buildings_by_id[bid] ]

			tiles = self.selectable_comp.select_many(buildings_to_select, renderer)
			self._related_buildings_selected_tiles = frozenset(tiles)
		else: # we don't need to check all
			# duplicates filtered later
			buildings_to_select = [ tile.object for tile in tiles_to_check if
			                        tile.object is not None and tile.object.id in related ]
			for tile in tiles_to_check:
				# check if we need to recolor the tiles
				if tile in self._related_buildings_selected_tiles:
					self.selectable_comp._add_selected_tile(tile, renderer, remember=False)

		for building in buildings_to_select:
			self._related_buildings.add(building)

	def _color_buildable_tile(self, tile):
		self._buildable_tiles.add(tile) # it's a set, so duplicates are handled
		self.renderer.addColored(tile._instance, *self.buildable_color)

	def remove(self):
		self.session.ingame_gui.resource_overview.close_construction_mode()
		WorldObjectDeleted.unsubscribe(self._on_worldobject_deleted)
		self._remove_listeners()
		self._remove_building_instances()
		self._remove_coloring()
		self._build_logic.remove(self.session)
		self._buildable_tiles = None
		self._transparencified_instances = None
		self._related_buildings_selected_tiles = None
		self._related_buildings = None
		self._highlighted_buildings = None
		self._build_logic = None
		self.buildings = None
		if self.__class__.gui is not None:
			self.__class__.gui.hide()
		ExtScheduler().rem_all_classinst_calls(self)
		SettlementInventoryUpdated.discard(self.update_preview)
		PlayerInventoryUpdated.discard(self.update_preview)
		super(BuildingTool, self).remove()

	def _on_worldobject_deleted(self, message):
		# remove references to this object
		self._related_buildings.discard(message.sender)
		self._transparencified_instances = \
		  set( i for i in self._transparencified_instances if
		       i() is not None and int(i().getId()) != message.worldid )
		check_building = lambda b : b.worldid != message.worldid
		self._highlighted_buildings = set( tup for tup in self._highlighted_buildings if check_building(tup[0]) )
		self._related_buildings = set( filter(check_building, self._related_buildings) )

	def load_gui(self):
		if self.__class__.gui is None:
			self.__class__.gui = load_uh_widget("place_building.xml")
			self.__class__.gui.position_technique = "right-1:top+157"
		self.__class__.gui.mapEvents( { "rotate_left" : self.rotate_left,
		                                "rotate_right": self.rotate_right } )
		# set translated building name in gui
		self.__class__.gui.findChild(name='headline').text = _('Build {building}').format(building=_(self._class.name))
		self.__class__.gui.findChild(name='running_costs').text = unicode(self._class.running_costs)
		head_box = self.__class__.gui.findChild(name='head_box')
		head_box.adaptLayout() # recalculates size of new content
		# calculate and set new center
		new_x = max(25, (self.__class__.gui.size[0] // 2) - (head_box.size[0] // 2))
		head_box.position = (new_x, head_box.position[1])
		head_box.adaptLayout()
		self.draw_gui()

	def draw_gui(self):
		if not hasattr(self, "action_set"):
			try:
				level = self._class.default_level_on_build
			except AttributeError:
				level = self.session.world.player.settler_level
			action_set = self._class.get_random_action_set(level=level)
		action_sets = ActionSetLoader.get_sets()
		for action_option in ['idle', 'idle_full', 'abcd']:
			if action_option in action_sets[action_set]:
				action = action_option
				break
		else: # If no idle, idle_full or abcd animation found, use the first you find
			action = action_sets[action_set].keys()[0]
		rotation = (self.rotation + int(self.session.view.cam.getRotation()) - 45) % 360
		image = sorted(action_sets[action_set][action][rotation].keys())[0]
		if GFX.USE_ATLASES:
			# Make sure the preview is loaded
			horizons.globals.fife.animationloader.load_image(image, action_set, action, rotation)
		building_icon = self.gui.findChild(name='building')
		loaded_image = horizons.globals.fife.imagemanager.load(image)
		building_icon.image = fife.GuiImage(loaded_image)
		width = loaded_image.getWidth()
		# TODO: Remove hardcoded 220
		max_width = 220
		if width > max_width:
			height = loaded_image.getHeight()
			size = (max_width, (height * max_width) // width)
			building_icon.max_size = building_icon.min_size = building_icon.size = size
		# TODO: Remove hardcoded 70
		gui_x, gui_y = self.__class__.gui.size
		icon_x, icon_y = building_icon.size
		building_icon.position = (gui_x // 2 - icon_x // 2,
		                          gui_y // 2 - icon_y // 2 - 70)
		self.__class__.gui.adaptLayout()

	def preview_build(self, point1, point2, force=False):
		"""Display buildings as preview if build requirements are met"""
		#self.session.view.renderer['InstanceRenderer'].removeAllColored()
		self.log.debug("BuildingTool: preview build at %s, %s", point1, point2)
		new_buildings = self._class.check_build_line(self.session, point1, point2,
		                                             rotation=self.rotation, ship=self.ship)
		# optimization: If only one building is in the preview and the position hasn't changed
		# => don't preview. Otherwise the preview is redrawn on every mouse move
		if not force and len(new_buildings) == len(self.buildings) == 1 and \
		   new_buildings[0] == self.buildings[0]:
			return # we don't want to redo the preview

		# remove old fife instances and coloring
		self._remove_building_instances()

		# get new ones
		self.buildings = new_buildings
		# resize list of action set ids to new buildings
		self.buildings_action_set_ids = self.buildings_action_set_ids + ([None] * (len(self.buildings) - len(self.buildings_action_set_ids)))
		self.buildings_action_set_ids = self.buildings_action_set_ids[ : len(self.buildings) ]
		# delete old infos
		self.buildings_fife_instances.clear()
		self.buildings_missing_resources.clear()

		settlement = None # init here so we can access it below loop
		needed_resources = {}
		# check if the buildings are buildable and color them appropriately
		for i, building in enumerate(self.buildings):
			# get gfx for the building
			# workaround for buildings like settler, that don't use the current level of
			# the player, but always start at a certain lvl
			level = self._class.get_initial_level(self.session.world.player)

			if self._class.id == BUILDINGS.TREE and not building.buildable:
				continue # Tree/ironmine that is not buildable, don't preview
			else:
				fife_instance, action_set_id = \
					self._class.getInstance(self.session, building.position.origin.x,
								            building.position.origin.y, rotation=building.rotation,
								            action=building.action, level=level,
								            action_set_id=self.buildings_action_set_ids[i])
				self.buildings_fife_instances[building] = fife_instance
				# remember action sets per order of occurrence
				# (this is far from good when building lines, but suffices for our purposes, which is mostly single build)
				self.buildings_action_set_ids[i] = action_set_id

			settlement = self.session.world.get_settlement(building.position.origin)
			if settlement is not None and settlement.owner != self.session.world.player:
				settlement = None # no fraternizing with the enemy, else there would be peace

			if self._class.id != BUILDINGS.WAREHOUSE:
				# Player shouldn't be allowed to build in this case, else it can trigger
				# a new_settlement notification
				if settlement is None:
					building.buildable = False


			# check required resources
			(enough_res, missing_res) = Build.check_resources(needed_resources, self._class.costs,
			                                                  self.session.world.player, [settlement, self.ship])
			if building.buildable and not enough_res:
				# make building red
				self.renderer.addColored(self.buildings_fife_instances[building],
				                         *self.not_buildable_color)
				building.buildable = False
				# set missing info for gui
				self.buildings_missing_resources[building] = missing_res

			# color this instance with fancy stuff according to buildability

			# this order determines highlight priority
			# draw ordinary ranges first, then later color related buildings (they are more important)
			self._make_surrounding_transparent(building)
			self._color_preview_building(building)
			if building.buildable:
				self._draw_preview_building_range(building, settlement)
			self._highlight_related_buildings_in_range(building, settlement)
			self._highlight_inversely_related_buildings(building, settlement)

		self.session.ingame_gui.resource_overview.set_construction_mode(
			self.ship if self.ship is not None else settlement,
		  needed_resources
		)
		self._add_listeners(self.ship if self.ship is not None else settlement)

	def _color_preview_building(self, building):
		"""Draw fancy stuff for build preview
		@param building: return value from buildable, _BuildPosition
		"""
		if building.buildable:
			# Tile might still have not buildable color -> remove it
			self.renderer.removeColored(self.buildings_fife_instances[building])
			self.renderer.addOutlined(self.buildings_fife_instances[building],
			                          self.buildable_color[0], self.buildable_color[1],
			                          self.buildable_color[2], GFX.BUILDING_OUTLINE_WIDTH,
			                          GFX.BUILDING_OUTLINE_THRESHOLD)

		else: # not buildable
			# must remove other highlight, fife does not support both
			self.renderer.removeOutlined(self.buildings_fife_instances[building])
			self.renderer.addColored(self.buildings_fife_instances[building],
			                         *self.not_buildable_color)

	def _draw_preview_building_range(self, building, settlement):
		"""Color the range as if the building was selected"""
		radius_only_on_island = True
		if hasattr(self.selectable_comp, 'range_applies_only_on_island'):
			radius_only_on_island = self.selectable_comp.range_applies_only_on_island

		self.selectable_comp.select_building(self.session, building.position, settlement,
		                                     self._class.radius, radius_only_on_island)

	def _highlight_related_buildings_in_range(self, building, settlement):
		"""Highlight directly related buildings (tree for lumberjacks) that are in range of the build preview"""
		if settlement is not None:
			related = frozenset(self.session.db.get_related_building_ids(self._class.id))
			for tile in settlement.get_tiles_in_radius(building.position, self._class.radius, include_self=True):
				obj = tile.object
				if (obj is not None) and (obj.id in related) and (obj not in self._highlighted_buildings):
					self._highlighted_buildings.add( (obj, False) ) # False: was_selected, see _restore_highlighted_buildings
					# currently same code as highlight_related_buildings
					inst = obj.fife_instance
					self.renderer.addOutlined(inst, *self.related_building_outline)
					self.renderer.addColored(inst, *self.related_building_color)


	def _make_surrounding_transparent(self, building):
		"""Makes the surrounding of building_position transparent and hide buildings
		that are built upon (tearset)"""
		world_contains = self.session.world.map_dimensions.contains_without_border
		get_tile = self.session.world.get_tile
		for coord in building.position.get_radius_coordinates(self.nearby_objects_radius, include_self=True):
			p = Point(*coord)
			if not world_contains(p):
				continue
			tile = get_tile(p)
			if tile.object is not None and tile.object.buildable_upon:
				inst = tile.object.fife_instance
				inst.get2dGfxVisual().setTransparency(BUILDINGS.TRANSPARENCY_VALUE)
				self._transparencified_instances.add(weakref.ref(inst))

		for to_tear_worldid in building.tearset:
			inst = WorldObject.get_object_by_id(to_tear_worldid).fife_instance
			inst.get2dGfxVisual().setTransparency(255) # full transparency = hidden
			self._transparencified_instances.add(weakref.ref(inst))

	def _highlight_inversely_related_buildings(self, building, settlement):
		"""Point out buildings that are inversely related (e.g. lumberjacks when building trees)
		This is triggered on each preview change and highlights only those in range"""
		# tuple for fast lookup with few elements
		ids = tuple(self.session.db.get_inverse_related_building_ids(self._class.id))
		if settlement is None or not ids: # nothing is related
			return

		radii = dict( [ (bid, Entities.buildings[bid].radius) for bid in ids ] )
		max_radius = max(radii.itervalues())

		for tile in settlement.get_tiles_in_radius(building.position, max_radius, include_self=True):
			if tile.object is not None and tile.object.id in ids:
				related_building = tile.object
				# check if it was actually this one's radius
				if building.position.distance( (tile.x, tile.y) ) <= \
				   Entities.buildings[related_building.id].radius:
					# found one
					if related_building in self._highlighted_buildings:
						continue

					self._highlighted_buildings.add( (related_building, True) ) # True: was_selected, see _restore_highlighted_buildings
					# currently same code as coloring normal related buildings (_color_preview_build())
					inst = related_building.fife_instance
					self.renderer.addOutlined(inst, *self.related_building_outline)
					self.renderer.addColored(inst, *self.related_building_color)

	def _restore_highlighted_buildings(self):
		"""Inverse of highlight_related_buildings"""
		# assemble list of all tiles that have are occupied by now restored buildings
		# (if but one of them is in the range of something, the whole building
		# might need to be colored as "in range")
		modified_tiles = []
		for (building, was_selected) in self._highlighted_buildings:
			inst = building.fife_instance
			self.renderer.removeColored(inst)
			# related buildings are highlighted, restore it
			if was_selected:
				self.renderer.addColored(inst, *self.selectable_comp.selection_color)
			self.renderer.removeOutlined(inst)
			modified_tiles.extend(
			  ( self.session.world.get_tile(point) for point in building.position )
			)
		self._highlighted_buildings.clear()
		self.highlight_buildable(modified_tiles)

	def on_escape(self):
		self._build_logic.on_escape(self.session)
		if self.__class__.gui is not None:
			self.__class__.gui.hide()
		self.session.ingame_gui.set_cursor() # will call remove()

	def mouseMoved(self, evt):
		self.log.debug("BuildingTool mouseMoved")
		super(BuildingTool, self).mouseMoved(evt)
		point = self.get_world_location(evt)
		if self.start_point != point:
			self.start_point = point
		self._check_update_preview(point)
		evt.consume()

	def mousePressed(self, evt):
		self.log.debug("BuildingTool mousePressed")
		if evt.isConsumedByWidgets():
			super(BuildingTool, self).mousePressed(evt)
			return
		if evt.getButton() == fife.MouseEvent.RIGHT:
			self.on_escape()
		elif evt.getButton() == fife.MouseEvent.LEFT:
			pass
		else:
			super(BuildingTool, self).mousePressed(evt)
			return
		evt.consume()

	def mouseDragged(self, evt):
		self.log.debug("BuildingTool mouseDragged")
		super(BuildingTool, self).mouseDragged(evt)
		point = self.get_world_location(evt)
		if self.start_point is not None:
			self._check_update_preview(point)
		evt.consume()

	def mouseReleased(self, evt):
		"""Actually build."""
		self.log.debug("BuildingTool mouseReleased")
		if evt.isConsumedByWidgets():
			super(BuildingTool, self).mouseReleased(evt)
		elif evt.getButton() == fife.MouseEvent.LEFT:
			point = self.get_world_location(evt)

			# check if position has changed with this event and update everything
			self._check_update_preview(point)

			# actually do the build
			changed_tiles = self.do_build()
			found_buildable = bool(changed_tiles)
			if found_buildable:
				PlaySound("build").execute(self.session, local=True)

			# HACK: users sometimes don't realize that roads can be dragged
			# check if 3 roads have been built within 1.2 seconds, and display
			# a hint in case
			if self._class.class_package == 'path':
				import time
				now = time.time()
				BuildingTool._last_road_built.append(now)
				if len(BuildingTool._last_road_built) > 2:
					if (now - BuildingTool._last_road_built[-3]) < 1.2:
						self.session.ingame_gui.message_widget.add('DRAG_ROADS_HINT')
						# don't display hint multiple times at the same build situation
						BuildingTool._last_road_built = []
					BuildingTool._last_road_built = BuildingTool._last_road_built[-3:]

			# check how to continue: either build again or escape
			shift = evt.isShiftPressed() or horizons.globals.fife.get_uh_setting('UninterruptedBuilding')
			if ((shift and not self._class.id == BUILDINGS.WAREHOUSE)
			    or not found_buildable
			    or self._class.class_package == 'path'):
				# build once more
				self._restore_transparencified_instances()
				self.highlight_buildable(changed_tiles)
				self.start_point = point
				self._build_logic.continue_build()
				self.preview_build(point, point)
			else:
				self.on_escape()
			evt.consume()
		elif evt.getButton() != fife.MouseEvent.RIGHT:
			super(BuildingTool, self).mouseReleased(evt)

	def do_build(self):
		"""Actually builds the previews
		@return a set of tiles where buildings have really been built"""
		changed_tiles = set()

		# actually do the build and build preparations
		for i, building in enumerate(self.buildings):
			# remove fife instance, the building will create a new one.
			# Check if there is a matching fife instance, could be missing
			# in case of trees, which are hidden if not buildable
			if building in self.buildings_fife_instances:
				fife_instance = self.buildings_fife_instances.pop(building)
				self.renderer.removeColored(fife_instance)
				self.renderer.removeOutlined(fife_instance)
				fife_instance.getLocationRef().getLayer().deleteInstance(fife_instance)

			if building.buildable:
				island = self.session.world.get_island(building.position.origin)
				for position in building.position:
					tile = island.get_tile(position)
					if tile in self._buildable_tiles:
						# for some kind of buildabilities, not every coord of the
						# building is buildable (e.g. fisher: only coastline is marked
						# as buildable). For those tiles, that are not buildable,
						# we don't need to do anything.
						self._buildable_tiles.remove(tile)
						self.renderer.removeColored(tile._instance)
						changed_tiles.add(tile)
				self._remove_listeners() # Remove changelisteners for update_preview
				# create the command and execute it
				cmd = Build(building=self._class,
							x=building.position.origin.x,
							y=building.position.origin.y,
							rotation=building.rotation,
							island=island,
							settlement=self.session.world.get_settlement(building.position.origin),
							ship=self.ship,
							tearset=building.tearset,
							action_set_id=self.buildings_action_set_ids[i],
							)
				cmd.execute(self.session)
			else:
				if len(self.buildings) == 1: # only give messages for single bulds
					# first, buildable reasons such as grounds
					# second, resources

					if building.problem is not None:
						msg = building.problem[1]
						self.session.ingame_gui.message_widget.add_custom(
						  point=building.position.origin, messagetext=msg)

					# check whether to issue a missing res notification
					# we need the localized resource name here
					elif building in self.buildings_missing_resources:
						res_name = self.session.db.get_res_name( self.buildings_missing_resources[building] )
						self.session.ingame_gui.message_widget.add(
						  point=building.position.origin,
						  string_id='NEED_MORE_RES', message_dict={'resource' : res_name})

		self.buildings = []
		self.buildings_action_set_ids = []
		return changed_tiles

	def _check_update_preview(self, end_point):
		"""Used internally if the end_point changes"""
		if self.end_point != end_point:
			self.end_point = end_point
			self.update_preview()

	def _remove_listeners(self):
		"""Resets the ChangeListener for update_preview."""
		if self.last_change_listener is not None:
			self.last_change_listener.discard_change_listener(self.force_update)
			self.last_change_listener.discard_change_listener(self.highlight_buildable)
			self._build_logic.remove_change_listener(self.last_change_listener, self)

		self.last_change_listener = None

	def _add_listeners(self, instance):
		if self.last_change_listener != instance:
			self._remove_listeners()
			self.last_change_listener = instance
			if self.last_change_listener is not None:
				self._build_logic.add_change_listener(self.last_change_listener, self)

	def force_update(self):
		self.update_preview(force=True)

	def update_preview(self, force=False):
		"""Used as callback method"""
		if self.start_point is not None:
			end_point = self.end_point or self.start_point
			self.preview_build(self.start_point, end_point, force=force)

	def _rotate(self, degrees):
		self.rotation = (self.rotation + degrees) % 360
		self.log.debug("BuildingTool: Building rotation now: %s", self.rotation)
		self.update_preview()
		self.draw_gui()

	def rotate_left(self):
		self._rotate(degrees=90)

	def rotate_right(self):
		self._rotate(degrees=270)

	def _remove_building_instances(self):
		"""Deletes fife instances of buildings"""

		try:
			self._class.get_component_template(SelectableComponent)
		except KeyError:
			pass
		else:
			deselected_tiles = self.selectable_comp.deselect_building(self.session)
			# redraw buildables (removal of selection might have tampered with it)
			self.highlight_buildable(deselected_tiles)

		self._restore_transparencified_instances()
		self._restore_highlighted_buildings()
		for building in self._related_buildings:
			# restore selection, removeOutline can destroy it
			building.get_component(SelectableComponent).set_selection_outline()
		for fife_instance in self.buildings_fife_instances.itervalues():
			layer = fife_instance.getLocationRef().getLayer()
			# layer might not exist, happens for some reason after a build
			if layer is not None:
				layer.deleteInstance(fife_instance)
		self.buildings_fife_instances = {}

	def _restore_transparencified_instances(self):
		"""Removes transparency"""
		for inst_weakref in self._transparencified_instances:
			fife_instance = inst_weakref()
			if fife_instance:
				# remove transparency only if trees aren't supposed to be transparent as default
				if not hasattr(fife_instance, "keep_translucency") or not fife_instance.keep_translucency:
					fife_instance.get2dGfxVisual().setTransparency(0)
				else:
					# restore regular translucency value, can also be different
					fife_instance.get2dGfxVisual().setTransparency( BUILDINGS.TRANSPARENCY_VALUE )
		self._transparencified_instances.clear()

	def _remove_coloring(self):
		"""Removes coloring from tiles, that indicate that the tile is buildable
		as well as all highlights. Called when building mode is finished."""
		for building in self._related_buildings:
			building.get_component(SelectableComponent).deselect()
		self.renderer.removeAllOutlines()
		self.renderer.removeAllColored()


class ShipBuildingToolLogic(object):
	"""Helper class to separate the logic needed when building from a ship from
	the main building tool."""

	def __init__(self, ship):
		self.ship = ship

	def highlight_buildable(self, building_tool, tiles_to_check=None):
		"""Highlights all buildable tiles.
		@param tiles_to_check: list of tiles to check for coloring."""
		# resolved variables from inner loops
		is_tile_buildable = building_tool._class.is_tile_buildable
		session = building_tool.session
		player = session.world.player
		buildable_tiles_add = building_tool._buildable_tiles.add

		if tiles_to_check is not None: # only check these tiles (build from ship)
			for tile in tiles_to_check:
				if is_tile_buildable(session, tile, self.ship):
					building_tool._color_buildable_tile(tile)
		else: # build from ship
			building_tool.renderer.removeAllColored()
			for island in session.world.get_islands_in_radius(self.ship.position, self.ship.radius):
				for tile in island.get_surrounding_tiles(self.ship.position, self.ship.radius):
					if is_tile_buildable(session, tile, self.ship):
						buildable_tiles_add(tile)
						# check that there is no other player's settlement
						if tile.settlement is None or tile.settlement.owner == player:
							building_tool._color_buildable_tile(tile)

	def on_escape(self, session):
		for selected in session.selected_instances:
			selected.get_component(SelectableComponent).deselect()
		session.selected_instances = set([self.ship])
		self.ship.get_component(SelectableComponent).select()
		self.ship.get_component(SelectableComponent).show_menu()

	def remove(self, session):
		self.on_escape(session)

	def add_change_listener(self, instance, building_tool):
		# instance is self.ship here
		instance.add_change_listener(building_tool.highlight_buildable)
		instance.add_change_listener(building_tool.force_update)

	def remove_change_listener(self, instance, building_tool):
		# be idempotent
		instance.discard_change_listener(building_tool.highlight_buildable)
		instance.discard_change_listener(building_tool.force_update)

	# Using messages now.
	def continue_build(self):
		pass


class SettlementBuildingToolLogic(object):
	"""Helper class to separate the logic needed when building from a settlement
	from the main building tool"""

	def __init__(self, building_tool):
		self.building_tool = weakref.ref(building_tool)
		self.subscribed = False

	def highlight_buildable(self, building_tool, tiles_to_check=None):
		"""Highlights all buildable tiles.
		@param tiles_to_check: list of tiles to check for coloring."""

		# resolved variables from inner loops
		is_tile_buildable = building_tool._class.is_tile_buildable
		session = building_tool.session
		player = session.world.player

		if not self.subscribed:
			self.subscribed = True
			SettlementRangeChanged.subscribe(self._on_update)

		if tiles_to_check is not None:
			# Only check these tiles.
			for tile in tiles_to_check:
				if is_tile_buildable(session, tile, None):
					building_tool._color_buildable_tile(tile)
		else:
			# Default build on island.
			for settlement in session.world.settlements:
				if settlement.owner == player:
					island = session.world.get_island(Point(*settlement.ground_map.iterkeys().next()))
					for tile in settlement.ground_map.itervalues():
						if is_tile_buildable(session, tile, None, island, check_settlement=False):
							building_tool._color_buildable_tile(tile)

	def _on_update(self, message):
		if self.building_tool() and message.sender.owner.is_local_player:
			# this is generally caused by adding new buildings, therefore new_buildings=True
			self.building_tool().highlight_buildable(message.changed_tiles, new_buildings=True)

	def on_escape(self, session):
		session.ingame_gui.show_build_menu()  # This will call remove().
		if self.subscribed:
			self.subscribed = False
			SettlementRangeChanged.unsubscribe(self._on_update)

	def remove(self, session):
		if self.subscribed:
			self.subscribed = False
			SettlementRangeChanged.unsubscribe(self._on_update)

	# Using messages now.
	def add_change_listener(self, instance, building_tool):
		pass
	def remove_change_listener(self, instance, building_tool):
		pass
	def continue_build(self):
		pass


class BuildRelatedBuildingToolLogic(SettlementBuildingToolLogic):
	"""Same as normal build, except quitting it drops to the build related tab."""
	def __init__(self, building_tool, instance):
		super(BuildRelatedBuildingToolLogic, self).__init__(building_tool)
		# instance must be weakref
		self.instance = instance

	def _reshow_tab(self):
		from horizons.gui.tabs import BuildRelatedTab
		self.instance().get_component(SelectableComponent).show_menu(jump_to_tabclass=BuildRelatedTab)

	def on_escape(self, session):
		super(BuildRelatedBuildingToolLogic, self).on_escape(session)
		self._reshow_tab()

	def continue_build(self):
		self._reshow_tab()


decorators.bind_all(BuildingTool)
decorators.bind_all(SettlementBuildingToolLogic)
decorators.bind_all(ShipBuildingToolLogic)
decorators.bind_all(BuildRelatedBuildingToolLogic)

########NEW FILE########
__FILENAME__ = cursortool
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import math
import logging

from fife import fife
import horizons.globals

from horizons.util.shapes import Point


# round half towards plus infinity
# http://en.wikipedia.org/wiki/Rounding#Round_half_up
roundhalfplus = lambda x: int(round(math.floor(x + x) / 2.0 + 0.25))


class CursorTool(fife.IMouseListener):
	"""Basic tool for cursors."""
	log = logging.getLogger("gui.mousetools")

	def __init__(self, session):
		super(CursorTool, self).__init__()
		assert isinstance(session, horizons.session.Session)
		self.session = session
		self.enable()

	def enable(self):
		"""Call this to get events."""
		horizons.globals.fife.eventmanager.addMouseListener(self)

	def disable(self):
		"""Call this to not get events."""
		horizons.globals.fife.eventmanager.removeMouseListener(self)

	def remove(self):
		self.disable()

	def mousePressed(self, evt):
		pass
	def mouseReleased(self, evt):
		pass
	def mouseEntered(self, evt):
		pass
	def mouseExited(self, evt):
		pass
	def mouseClicked(self, evt):
		pass
	def mouseWheelMovedUp(self, evt):
		pass
	def mouseWheelMovedDown(self, evt):
		pass
	def mouseMoved(self, evt):
		pass
	def mouseDragged(self, evt):
		pass

	def _round_map_coords(self, map_x, map_y):
		"""Returns the coordinates of an event at the map.

		Why roundhalfplus?

		        a      b     a-b   round(a)-round(b)  roundplus(a)-roundplus(b)

		       1.50   0.50   1.00       1.00               1.0
		       0.50  -0.49   0.99       1.00               1.0
		      -0.49  -1.49   1.00       1.00               1.0
		Error: 0.50  -0.50   1.00       2.00               1.0

		This error would result in fields at position 0 to be smaller than the others,
		because both sides (-0.5 and 0.5) would be wrongly assigned to the other fields.

		@return Point with int coordinates"""
		return Point(roundhalfplus(map_x), roundhalfplus(map_y))

	def get_world_location(self, evt):
		screenpoint = self._get_screenpoint(evt)
		mapcoords = self.session.view.cam.toMapCoordinates(screenpoint, False)
		return self._round_map_coords(mapcoords.x, mapcoords.y)

	def get_exact_world_location(self, evt):
		"""Returns the coordinates of an event at the map.
		@return FifePoint with float coordinates or something with getX/getY"""
		screenpoint = self._get_screenpoint(evt)
		return self.session.view.cam.toMapCoordinates(screenpoint, False)

	def _get_screenpoint(self, arg):
		"""Python lacks polymorphism."""
		if isinstance(arg, fife.ScreenPoint):
			return arg
		else:
			return fife.ScreenPoint(arg.getX(), arg.getY())

	def end(self):
		self.session = None
		self.helptext = None

########NEW FILE########
__FILENAME__ = navigationtool
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife
import horizons.globals

from horizons.gui.mousetools.cursortool import CursorTool
from horizons.util.python.weaklist import WeakList
from horizons.util.worldobject import WorldObject
from horizons.util.lastactiveplayersettlementmanager import LastActivePlayerSettlementManager
from horizons.constants import LAYERS, VIEW
from horizons.messaging import HoverInstancesChanged
from horizons.extscheduler import ExtScheduler

from fife.extensions.pychan.widgets import Icon

class NavigationTool(CursorTool):
	"""Navigation Class to process mouse actions ingame"""


	last_event_pos = fife.ScreenPoint(0, 0) # last received mouse event position, fife.ScreenPoint

	send_hover_instances_update = True
	HOVER_INSTANCES_UPDATE_DELAY = 1 # sec
	last_hover_instances = WeakList()

	def __init__(self, session):
		super(NavigationTool, self).__init__(session)
		self._last_mmb_scroll_point = [0, 0]
		# coordinates of last mouse positions
		self.last_exact_world_location = fife.ExactModelCoordinate()
		self._hover_instances_update_scheduled = False
		self.middle_scroll_active = False

		class CmdListener(fife.ICommandListener):
			pass
		self.cmdlist = CmdListener()
		horizons.globals.fife.eventmanager.addCommandListener(self.cmdlist)
		self.cmdlist.onCommand = self.onCommand

		if not self.__class__.send_hover_instances_update:
			# clear
			HoverInstancesChanged.broadcast(self, set())
			self.__class__.last_hover_instances = WeakList()
		else:
			# need updates about scrolling here
			self.session.view.add_change_listener(self._schedule_hover_instance_update)
			self._schedule_hover_instance_update()

		class CoordsTooltip(object):
			@classmethod
			def get_instance(cls, cursor_tool):
				if cursor_tool.session.ingame_gui.coordinates_tooltip is not None:
					inst = cursor_tool.session.ingame_gui.coordinates_tooltip
					inst.cursor_tool = cursor_tool
					return inst
				else:
					return CoordsTooltip(cursor_tool)

			def __init__(self, cursor_tool, **kwargs):
				super(CoordsTooltip, self).__init__(**kwargs)
				cursor_tool.session.ingame_gui.coordinates_tooltip = self
				self.cursor_tool = cursor_tool
				self.enabled = False

				self.icon = Icon(position=(1, 1)) # 0, 0 is currently not supported by tooltips

			def toggle(self):
				self.enabled = not self.enabled
				if not self.enabled and self.icon.tooltip_shown:
					self.icon.hide_tooltip()

			def show_evt(self, evt):
				if self.enabled:
					x, y = self.cursor_tool.get_world_location(evt).to_tuple()
					self.icon.helptext = u'%d, %d ' % (x, y) + _("Press H to remove this hint")
					self.icon.position_tooltip(evt)
					self.icon.show_tooltip()

		self.tooltip = CoordsTooltip.get_instance(self)

	def remove(self):
		if self.__class__.send_hover_instances_update:
			self.session.view.remove_change_listener(self._schedule_hover_instance_update)
		horizons.globals.fife.eventmanager.removeCommandListener(self.cmdlist)
		super(NavigationTool, self).remove()

	def mousePressed(self, evt):
		if evt.getButton() == fife.MouseEvent.MIDDLE:
			if horizons.globals.fife.get_uh_setting("MiddleMousePan"):
				self._last_mmb_scroll_point = (evt.getX(), evt.getY())
				self.middle_scroll_active = True

	def mouseReleased(self, evt):
		if evt.getButton() == fife.MouseEvent.MIDDLE:
			if horizons.globals.fife.get_uh_setting("MiddleMousePan"):
				self.middle_scroll_active = False

	def mouseDragged(self, evt):
		if evt.getButton() == fife.MouseEvent.MIDDLE:
			if horizons.globals.fife.get_uh_setting("MiddleMousePan"):
				if self.middle_scroll_active:
					scroll_by = ( self._last_mmb_scroll_point[0] - evt.getX(),
					              self._last_mmb_scroll_point[1] - evt.getY() )
					self.session.view.scroll( *scroll_by )
					self._last_mmb_scroll_point = (evt.getX(), evt.getY())
		else:
			# Else the event will mistakenly be delegated if the left mouse button is hit while
			# scrolling using the middle mouse button
			if not self.middle_scroll_active:
				NavigationTool.mouseMoved(self, evt)

	# return new mouse position after moving
	def mouseMoved(self, evt):
		if not self.session.world.inited:
			return

		self.tooltip.show_evt(evt)
		# don't overwrite this last_event_pos instance. Due to class
		# hierarchy, it would write to the lowest class (e.g. SelectionTool)
		# and the attribute in NavigationTool would be left unchanged.
		self.__class__.last_event_pos.set(evt.getX(), evt.getY(), 0)
		mousepoint = self.__class__.last_event_pos

		# Status menu update
		current = self.get_exact_world_location(evt)

		distance_ge = lambda a, b, epsilon : abs((a.x-b.x)**2 + (a.y-b.y)**2) >= epsilon**2

		if distance_ge(current, self.last_exact_world_location, 4): # update every 4 tiles for settlement info
			self.last_exact_world_location = current
			# update res bar with settlement-related info
			LastActivePlayerSettlementManager().update(current)

		# check if instance update is scheduled
		if self.__class__.send_hover_instances_update:
			self._schedule_hover_instance_update()

		# Mouse scrolling
		x, y = 0, 0
		if mousepoint.x < VIEW.AUTOSCROLL_WIDTH:
			x -= VIEW.AUTOSCROLL_WIDTH - mousepoint.x
		elif mousepoint.x > (self.session.view.cam.getViewPort().right()-VIEW.AUTOSCROLL_WIDTH):
			x += VIEW.AUTOSCROLL_WIDTH + mousepoint.x - self.session.view.cam.getViewPort().right()
		if mousepoint.y < VIEW.AUTOSCROLL_WIDTH:
			y -= VIEW.AUTOSCROLL_WIDTH - mousepoint.y
		elif mousepoint.y > (self.session.view.cam.getViewPort().bottom()-VIEW.AUTOSCROLL_WIDTH):
			y += VIEW.AUTOSCROLL_WIDTH + mousepoint.y - self.session.view.cam.getViewPort().bottom()
		x *= 10
		y *= 10
		self.session.view.autoscroll(x, y)

	# move up mouse wheel = zoom in
	def mouseWheelMovedUp(self, evt):
		track_cursor = horizons.globals.fife.get_uh_setting("CursorCenteredZoom")
		self.session.view.zoom_in(track_cursor)
		evt.consume()

	# move down mouse wheel = zoom out
	def mouseWheelMovedDown(self, evt):
		track_cursor = horizons.globals.fife.get_uh_setting("CursorCenteredZoom")
		self.session.view.zoom_out(track_cursor)
		evt.consume()

	def onCommand(self, command):
		"""Called when some kind of command-event happens.
		For "documentation", see:
		engine/core/eventchannel/command/ec_commandids.h
		engine/core/eventchannel/eventmanager.cpp
		in fife.
		It's usually about mouse/keyboard focus or window being iconified/restored.
		"""
		stop_scrolling_on = (fife.CMD_APP_ICONIFIED,
		                     fife.CMD_MOUSE_FOCUS_LOST,
		                     fife.CMD_INPUT_FOCUS_LOST)
		if command.getCommandType() in stop_scrolling_on:
			# it has been randomly observed twice that this code is reached with session being None or
			# partly deinitialized. Since it is unknown how fife handles this and why
			# removeCommandListener in remove() doesn't prevent further calls, we have to catch and ignore the error
			try:
				self.session.view.autoscroll(0, 0) # stop autoscroll
			except AttributeError:
				pass

	def get_hover_instances(self, where, layers=None):
		"""
		Utility method, returns the instances under the cursor
		@param where: anything supporting getX/getY
		@param layers: list of layer ids to search for. Default to OBJECTS
		"""
		if layers is None:
			layers = [LAYERS.OBJECTS]

		all_instances = []
		for layer in layers:
			x = where.getX()
			y = where.getY()
			instances = self.session.view.cam.getMatchingInstances(
				fife.ScreenPoint(x, y),
				self.session.view.layers[layer], False) # False for accurate

			# if no instances found, try again and search within a 8px radius
			if not instances:
				selection_radius = 8
				radius = fife.Rect(x - selection_radius, y - selection_radius,
				                   selection_radius * 2, selection_radius * 2)

				instances = self.session.view.cam.getMatchingInstances(radius,
									self.session.view.layers[layer])

			all_instances.extend(instances)

		hover_instances = []
		for i in all_instances:
			id = i.getId()
			# Check id, can be '' if instance is created and clicked on before
			# actual game representation class is created (network play)
			if id == '':
				continue
			instance = WorldObject.get_object_by_id(int(id))
			hover_instances.append(instance)
		return hover_instances

	def end(self):
		super(NavigationTool, self).end()
		if self._hover_instances_update_scheduled:
			ExtScheduler().rem_all_classinst_calls(self)
		self.helptext = None

	def _schedule_hover_instance_update(self):
		"""Hover instances have potentially changed, do an update in a timely fashion (but not right away)"""
		if not self._hover_instances_update_scheduled:
			self._hover_instances_update_scheduled = True
			ExtScheduler().add_new_object(self._send_hover_instance_upate, self,
			                              run_in=self.__class__.HOVER_INSTANCES_UPDATE_DELAY)

	def _send_hover_instance_upate(self):
		"""Broadcast update with new instances below mouse (hovered).
		At most called in a certain interval, not after every mouse move in
		order to prevent delays."""
		self._hover_instances_update_scheduled = False
		where = fife.Point(self.__class__.last_event_pos.x, self.__class__.last_event_pos.y)

		instances = set(self.get_hover_instances(where))
		# only send when there were actual changes
		if instances != set(self.__class__.last_hover_instances):
			self.__class__.last_hover_instances = WeakList(instances)
			HoverInstancesChanged.broadcast(self, instances)

########NEW FILE########
__FILENAME__ = pipettetool
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife

import horizons.globals

from horizons.entities import Entities
from horizons.constants import LAYERS
from horizons.gui.mousetools import NavigationTool
from horizons.gui.tabs.buildtabs import BuildTab
from horizons.component.ambientsoundcomponent import AmbientSoundComponent


class PipetteTool(NavigationTool):
	"""Tool to select buildings in order to build another building of
	the type of the selected building"""
	HIGHLIGHT_COLOR = (0, 200, 90)
	HIGHLIGHT_NOT_POSSIBLE_COLOR = (200, 90, 90)

	def __init__(self, session):
		super(PipetteTool, self).__init__(session)
		self.renderer = session.view.renderer['InstanceRenderer']
		horizons.globals.fife.set_cursor_image('pipette')

	def remove(self):
		self._remove_coloring()
		horizons.globals.fife.set_cursor_image('default')
		super(PipetteTool, self).remove()

	def on_escape(self):
		self.session.ingame_gui.set_cursor()

	def mouseMoved(self, evt):
		self.update_coloring(evt)

	def mousePressed(self, evt):
		if evt.getButton() == fife.MouseEvent.LEFT:
			obj = self._get_object(evt)
			if obj and self._is_buildable(obj.id):
				self.session.ingame_gui.set_cursor('building', Entities.buildings[obj.id])
			elif obj: # object that is not buildable
				AmbientSoundComponent.play_special('error')
				self.on_escape()
			else:
				self.on_escape()
			evt.consume()
		elif evt.getButton() == fife.MouseEvent.RIGHT:
			self.on_escape()
			evt.consume()
		else:
			super(PipetteTool, self).mouseClicked(evt)

	def _get_object(self, evt):
		for obj in self.get_hover_instances(evt, layers=[LAYERS.FIELDS, LAYERS.OBJECTS]):
			if obj.id in Entities.buildings:
				return obj
		return None

	def update_coloring(self, evt):
		obj = self._get_object(evt)
		self._remove_coloring()
		if obj:
			self._add_coloring(obj)

	def _is_buildable(self, building_id):
		building_tiers = BuildTab.get_building_tiers()
		return building_id in building_tiers and \
		       building_tiers[ building_id ] <= self.session.world.player.settler_level

	def _add_coloring(self, obj):
		if self._is_buildable(obj.id):
			self.renderer.addColored(obj.fife_instance,
			                         *self.__class__.HIGHLIGHT_COLOR)
		else:
			self.renderer.addColored(obj.fife_instance,
			                         *self.__class__.HIGHLIGHT_NOT_POSSIBLE_COLOR)

	def _remove_coloring(self):
		self.renderer.removeAllColored()

########NEW FILE########
__FILENAME__ = selectiontool
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import traceback

from fife import fife

from horizons.command.unit import Act
from horizons.util.worldobject import WorldObject
from horizons.util.worldobject import WorldObjectNotFound
from horizons.gui.mousetools.navigationtool import NavigationTool
from horizons.component.selectablecomponent import SelectableComponent
from horizons.constants import LAYERS

class SelectionTool(NavigationTool):
	_SELECTION_RECTANGLE_NAME = "_select" # GenericRenderer objects are sorted by name, so first char is important

	def __init__(self, session):
		super(SelectionTool, self).__init__(session)
		self.deselect_at_end = True # Set this to deselect selections while exiting SelectionTool

	def remove(self):
		# Deselect if needed while exiting
		if self.deselect_at_end:
			selectables = self.filter_selectable( self.session.selected_instances )
			for i in self.filter_component(SelectableComponent, selectables):
				i.deselect()
		super(SelectionTool, self).remove()

	def is_selectable(self, entity):
		# also enemy entities are selectable, but the selection representation will differ
		return entity.has_component(SelectableComponent)

	def filter_component(self, component, instances):
		"""Only get specific component from a list of world objects"""
		return [instance.get_component(component) for instance in instances]

	def filter_selectable(self, instances):
		"""Only keeps selectables from a list of world objects"""
		return filter(self.is_selectable, instances)

	def is_owned_by_player(self, instance):
		"""Returns boolean if single world object is owned by local player"""
		return instance.owner is not None and \
			hasattr(instance.owner, "is_local_player") and \
			instance.owner.is_local_player

	def filter_owner(self, instances):
		"""Only keep instances belonging to the user. This is used for multiselection"""
		return [ i for i in instances if self.is_owned_by_player(i) ]

	def fife_instance_to_uh_instance(self, instance):
		"""Visual fife instance to uh game logic object or None"""
		i_id = instance.getId()
		if i_id == '':
			return None
		try:
			return WorldObject.get_object_by_id(int(i_id))
		except WorldObjectNotFound:
			return None

	def mouseDragged(self, evt):
		if evt.getButton() == fife.MouseEvent.LEFT and hasattr(self, 'select_begin'):
			x, y = self.select_begin
			xx, yy = evt.getX(), evt.getY()
			do_multi = ( (x - xx) ** 2 + (y - yy) ** 2 ) >= 10 # from 3px (3*3 + 1)
			self.session.view.renderer['GenericRenderer'].removeAll(self.__class__._SELECTION_RECTANGLE_NAME)
			if do_multi:
				# draw a rectangle
				xmin, xmax = min(x, xx), max(x, xx)
				ymin, ymax = min(y, yy), max(y, yy)
				a = fife.Point(xmin, ymin)
				b = fife.Point(xmax, ymin)
				c = fife.Point(xmax, ymax)
				d = fife.Point(xmin, ymax)
				self._draw_rect_line(a, b)
				self._draw_rect_line(b, c)
				self._draw_rect_line(d, c)
				self._draw_rect_line(d, a)
				area = fife.Rect(xmin, ymin, xmax - xmin, ymax - ymin)
			else:
				area = fife.ScreenPoint(xx, yy)
			instances = self.session.view.cam.getMatchingInstances(
				area,
				self.session.view.layers[LAYERS.OBJECTS],
				False) # False for accurate

			# get selection components
			instances = ( self.fife_instance_to_uh_instance(i) for i in instances )
			instances = [ i for i in instances if i is not None ]

			# We only consider selectable items when dragging a selection box.
			instances = self.filter_selectable(instances)

			# If there is at least one player unit, we don't select any enemies.
			# This applies to both buildings and ships.
			if any((self.is_owned_by_player(instance) for instance in instances)):
				instances = self.filter_owner(instances)

			self._update_selection( instances, do_multi )

		elif evt.getButton() == fife.MouseEvent.RIGHT:
			pass
		else:
			super(SelectionTool, self).mouseDragged(evt)
			return
		evt.consume()

	def mouseReleased(self, evt):
		if evt.getButton() == fife.MouseEvent.LEFT and hasattr(self, 'select_begin'):
			self.apply_select()
			del self.select_begin, self.select_old
			self.session.view.renderer['GenericRenderer'].removeAll(self.__class__._SELECTION_RECTANGLE_NAME)
		elif evt.getButton() == fife.MouseEvent.RIGHT:
			pass
		else:
			super(SelectionTool, self).mouseReleased(evt)
			return
		evt.consume()

	def apply_select(self):
		"""
		Called when selected instances changes. (Shows their menu)
		Does not do anything when nothing is selected, i.e. doesn't hide their menu.
		If one of the selected instances can attack, switch mousetool to AttackingTool.
		"""
		if self.session.world.health_visible_for_all_health_instances:
			self.session.world.toggle_health_for_all_health_instances()
		selected = self.session.selected_instances
		if len(selected) == 0:
			return
		if len(selected) == 1:
			iter(selected).next().get_component(SelectableComponent).show_menu()
		else:
			self.session.ingame_gui.show_multi_select_tab(selected)

		# local import to prevent cycle
		from horizons.gui.mousetools.attackingtool import AttackingTool
		# change session cursor to attacking tool if selected instances can attack
		found_military = any(hasattr(i, 'attack') and i.owner.is_local_player
		                     for i in selected)
		# Handover to AttackingTool without deselecting
		self.deselect_at_end = not found_military

		if found_military and not isinstance(self.session.ingame_gui.cursor, AttackingTool):
			self.session.ingame_gui.set_cursor('attacking')
		if not found_military and isinstance(self.session.ingame_gui.cursor, AttackingTool):
			self.session.ingame_gui.set_cursor('default')

	def mousePressed(self, evt):
		if evt.isConsumedByWidgets():
			super(SelectionTool, self).mousePressed(evt)
			return
		elif evt.getButton() == fife.MouseEvent.LEFT:
			if self.session.selected_instances is None:
				# this is a very odd corner case, it should only happen after the session has been ended
				# we can't allow to just let it crash however
				self.log.error('Error: selected_instances is None. Please report this!')
				traceback.print_stack()
				self.log.error('Error: selected_instances is None. Please report this!')
				return
			instances = self.get_hover_instances(evt)
			self.select_old = frozenset(self.session.selected_instances) if evt.isControlPressed() else frozenset()

			instances = filter(self.is_selectable, instances)
			# On single click, only one building should be selected from the hover_instances.
			# The if is for [] and [single_item] cases (they crashed).
			# It acts as user would expect: instances[0] selects buildings in front first.
			instances = instances if len(instances) <= 1 else [instances[0]]

			self._update_selection(instances)

			self.select_begin = (evt.getX(), evt.getY())
			self.session.ingame_gui.hide_menu()
		elif evt.getButton() == fife.MouseEvent.RIGHT:
			target_mapcoord = self.get_exact_world_location(evt)
			for i in self.session.selected_instances:
				if i.movable:
					Act(i, target_mapcoord.x, target_mapcoord.y).execute(self.session)
		else:
			super(SelectionTool, self).mousePressed(evt)
			return
		evt.consume()

	def _draw_rect_line(self, start, end):
		renderer = self.session.view.renderer['GenericRenderer']
		renderer.addLine(self.__class__._SELECTION_RECTANGLE_NAME,
		                 fife.RendererNode(start), fife.RendererNode(end),
		                 200, 200, 200)

	def _update_selection(self, instances, do_multi=False):
		"""
		self.select_old are old instances still relevant now (esp. on ctrl)
		@param instances: uh instances
		@param do_multi: True if selection rectangle on drag is used
		"""
		self.log.debug("update selection %s", [unicode(i) for i in instances])

		if do_multi: # add to selection
			instances = self.select_old.union(instances)
		else: # this is for deselecting among a selection with ctrl
			instances = self.select_old.symmetric_difference(instances)

		# sanity:
		# - no multiple entities from enemy selected
		if len(instances) > 1:
			user_instances = self.filter_owner(instances)
			if user_instances: # check at least one remaining
				instances = user_instances
			else:
				instances = [iter(instances).next()]
		selectable = frozenset( self.filter_component(SelectableComponent, instances))

		# apply changes
		selected_components = set(self.filter_component(SelectableComponent,
		                          self.filter_selectable(self.session.selected_instances)))
		for sel_comp in selected_components - selectable:
			sel_comp.deselect()
		for sel_comp in selectable - selected_components:
			sel_comp.select()

		self.session.selected_instances = set( i.instance for i in selectable )

########NEW FILE########
__FILENAME__ = tearingtool
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife

import horizons.globals
import weakref

from horizons.gui.mousetools.navigationtool import NavigationTool
from horizons.command.building import Tear
from horizons.util.python.weaklist import WeakList
from horizons.util.shapes import Point
from horizons.constants import BUILDINGS
from horizons.messaging import WorldObjectDeleted

class TearingTool(NavigationTool):
	"""
	Represents a dangling tool to remove (tear) buildings.
	"""
	tear_selection_color = (255, 255, 255)
	nearby_objects_radius = 4

	def __init__(self, session):
		super(TearingTool, self).__init__(session)
		self._transparent_instances = set() # fife instances modified for transparency
		self.coords = None
		self.selected = WeakList()
		self.oldedges = None
		self.tear_tool_active = True
		self.session.ingame_gui.hide_menu()
		self.session.selected_instances.clear()
		horizons.globals.fife.set_cursor_image("tearing")
		self._hovering_over = WeakList()
		WorldObjectDeleted.subscribe(self._on_object_deleted)

	def remove(self):
		self._mark()
		self.tear_tool_active = False
		horizons.globals.fife.set_cursor_image("default")
		WorldObjectDeleted.unsubscribe(self._on_object_deleted)
		super(TearingTool, self).remove()

	def mouseDragged(self, evt):
		coords = self.get_world_location(evt).to_tuple()
		if self.coords is None:
			self.coords = coords
		self._mark(self.coords, coords)
		evt.consume()

	def mouseMoved(self, evt):
		super(TearingTool, self).mouseMoved(evt)
		coords = self.get_world_location(evt).to_tuple()
		self._mark(coords)
		evt.consume()

	def on_escape(self):
		self.session.ingame_gui.set_cursor()

	def mouseReleased(self, evt):
		"""Tear selected instances and set selection tool as cursor"""
		self.log.debug("TearingTool: mouseReleased")
		if evt.getButton() == fife.MouseEvent.LEFT:
			coords = self.get_world_location(evt).to_tuple()
			if self.coords is None:
				self.coords = coords
			self._mark(self.coords, coords)
			selection_list_copy = [building for building in self.selected]
			for building in selection_list_copy:
				self.session.view.renderer['InstanceRenderer'].removeColored(building._instance)
				if (not building.id in BUILDINGS.EXPAND_RANGE) or self.confirm_ranged_delete(building):
					Tear(building).execute(self.session)
			else:
				if self._hovering_over:
					# we're hovering over a building, but none is selected, so this tear action isn't allowed
					warehouses = [ b for b in self._hovering_over if
					               b.id == BUILDINGS.WAREHOUSE and b.owner.is_local_player]
					if warehouses:
						# tried to tear a warehouse, this is especially non-tearable
						pos = warehouses[0].position.origin
						self.session.ingame_gui.message_widget.add(point=pos, string_id="WAREHOUSE_NOT_TEARABLE" )

			self.selected = WeakList()
			self._hovering_over = WeakList()
			if not evt.isShiftPressed() and not horizons.globals.fife.get_uh_setting('UninterruptedBuilding'):
				self.tear_tool_active = False
				self.on_escape()
			evt.consume()
			
	def confirm_ranged_delete(self, building):
			buildings_to_destroy = len(Tear.additional_removals_after_tear(building)[0])
			if buildings_to_destroy == 0:
				return True
			
			title = _("Destroy all buildings")
			msg = _("This will destroy all the buildings that fall outside of"
		            " the settlement range.")
			msg += u"\n\n"
			msg += N_("%s additional building will be destroyed.",
		              "%s additional buildings will be destroyed",
		              buildings_to_destroy) % buildings_to_destroy
			return building.session.ingame_gui.open_popup(title, msg, show_cancel_button=True)

	def mousePressed(self, evt):
		if evt.getButton() == fife.MouseEvent.RIGHT:
			self.on_escape()
		elif evt.getButton() == fife.MouseEvent.LEFT:
			self.coords = self.get_world_location(evt).to_tuple()
			self._mark(self.coords)
		else:
			return
		self.tear_tool_active = False
		evt.consume()

	def _mark(self, *edges):
		"""Highights building instances and keeps self.selected up to date."""
		self._restore_transparent_instances()
		self.log.debug("TearingTool: mark")
		if len(edges) == 1:
			edges = (edges[0], edges[0])
		elif len(edges) == 2:
			edges = ((min(edges[0][0], edges[1][0]), min(edges[0][1], edges[1][1])),
					 (max(edges[0][0], edges[1][0]), max(edges[0][1], edges[1][1])))
		else:
			edges = None
		if self.oldedges != edges or edges is None:
			for i in self.selected:
				self.session.view.renderer['InstanceRenderer'].removeColored(i._instance)
			self.selected = WeakList()
			self.oldedges = edges
		if edges is not None:
			self._hovering_over = WeakList()
			for x in xrange(edges[0][0], edges[1][0] + 1):
				for y in xrange(edges[0][1], edges[1][1] + 1):
					b = self.session.world.get_building(Point(x, y))
					if b is not None:
						if b not in self._hovering_over:
							self._hovering_over.append(b)
							self._make_surrounding_transparent(b)
							self._remove_object_transparency(Point(x,y))
						if b.tearable and b.owner is not None and b.owner.is_local_player:
							if b not in self.selected:
								self._make_surrounding_transparent(b)
								self.selected.append(b)
								self._remove_object_transparency(Point(x,y))
			for i in self.selected:
				self.session.view.renderer['InstanceRenderer'].addColored(i._instance,
				                                                          *self.tear_selection_color)
		self.log.debug("TearingTool: mark done")

	def _remove_object_transparency(self, coords):
		"""helper function, used to remove transparency from object hovered upon,
		identified through its coordinates"""
		tile = self.session.world.get_tile(coords)
		if tile.object is not None and tile.object.buildable_upon:
			inst = tile.object.fife_instance
			inst.get2dGfxVisual().setTransparency(0)

	def _make_surrounding_transparent(self, building):
		"""Makes the surrounding of building_position transparent"""
		world_contains = self.session.world.map_dimensions.contains_without_border
		for coord in building.position.get_radius_coordinates(self.nearby_objects_radius, include_self=True):
			p = Point(*coord)
			if not world_contains(p):
				continue
			tile = self.session.world.get_tile(p)
			if tile.object is not None and tile.object.buildable_upon:
				inst = tile.object.fife_instance
				inst.get2dGfxVisual().setTransparency(BUILDINGS.TRANSPARENCY_VALUE)
				self._transparent_instances.add(weakref.ref(inst))

	def _restore_transparent_instances(self):
		"""Removes transparency"""
		for inst_weakref in self._transparent_instances:
			fife_instance = inst_weakref()
			if fife_instance:
				# remove transparency only if trees aren't supposed to be transparent as default
				if not hasattr(fife_instance, "keep_translucency") or not fife_instance.keep_translucency:
					fife_instance.get2dGfxVisual().setTransparency(0)
				else:
					# restore regular translucency value, can also be different
					fife_instance.get2dGfxVisual().setTransparency( BUILDINGS.TRANSPARENCY_VALUE )
		self._transparent_instances.clear()

	def _on_object_deleted(self, message):
		self.log.debug("TearingTool: on deletion notification %s", message.worldid)
		if message.sender in self.selected:
			self.log.debug("TearingTool: deleted obj present")
			self.selected.remove(message.sender)

########NEW FILE########
__FILENAME__ = tilelayingtool
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife

import horizons.globals

from horizons.constants import GROUND
from horizons.gui.mousetools import NavigationTool
from horizons.util.shapes import Circle, Point
from horizons.util.loaders.tilesetloader import TileSetLoader


class TileLayingTool(NavigationTool):
	"""Tool to lay ground tiles."""
	HIGHLIGHT_COLOR = (0, 200, 90)

	tile_images = {}

	def __init__(self, session, tile_details):
		super(TileLayingTool, self).__init__(session)
		self.renderer = session.view.renderer['InstanceRenderer']
		self._tile_details = (None, None, None)
		if tile_details[0] in [0, 2]:
			self._tile_details = GROUND.WATER
		elif tile_details[0] in [1, 5]:
			self._tile_details = GROUND.SHALLOW_WATER
		elif tile_details[0] in [6, 4]:
			self._tile_details = GROUND.SAND
		else:
			self._tile_details = GROUND.DEFAULT_LAND
		self._set_cursor_image()

	def _set_cursor_image(self):
		"""Replace the cursor with an image of the selected tile."""
		# FIXME the water tile is too big to use as cursor
		if self._tile_details[0] == 0:
			return

		tile = tuple(self._tile_details)
		image = TileLayingTool.tile_images.get(tile)
		if not image:
			tile_sets = TileSetLoader.get_sets()

			ground_id, action_id, rotation = tile
			set_id = horizons.globals.db.get_random_tile_set(ground_id)
			filename = tile_sets[set_id][action_id][rotation].keys()[0]

			image = horizons.globals.fife.imagemanager.load(filename)
			TileLayingTool.tile_images[tile] = image

		horizons.globals.fife.cursor.set(image)

	def remove(self):
		self._remove_coloring()
		horizons.globals.fife.set_cursor_image('default')
		super(TileLayingTool, self).remove()

	def on_escape(self):
		self.session.ingame_gui.set_cursor()

	def mouseMoved(self, evt):
		self.update_coloring(evt)

	def _place_tile(self, coords):
		brush = Circle(Point(*coords), self.session.world_editor.brush_size - 1)
		self.session.world_editor.intermediate_map.set_south_east_corner(brush.tuple_iter(), self._tile_details)

	def get_world_location(self, evt):
		screenpoint = self._get_screenpoint(evt)
		mapcoords = self.session.view.cam.toMapCoordinates(screenpoint, False)
		return self._round_map_coords(mapcoords.x + 0.5, mapcoords.y + 0.5)

	def mousePressed(self, evt):
		if evt.getButton() == fife.MouseEvent.LEFT:
			coords = self.get_world_location(evt).to_tuple()
			self._place_tile(coords)
			evt.consume()
		elif evt.getButton() == fife.MouseEvent.RIGHT:
			self.on_escape()
			evt.consume()
		else:
			super(TileLayingTool, self).mouseClicked(evt)

	def mouseDragged(self, evt):
		"""Allow placing tiles continusly while moving the mouse."""
		if evt.getButton() == fife.MouseEvent.LEFT:
			coords = self.get_world_location(evt).to_tuple()
			self._place_tile(coords)
			self.update_coloring(evt)
			evt.consume()

	def update_coloring(self, evt):
		self._remove_coloring()
		self._add_coloring(self.get_world_location(evt).to_tuple())

	def _add_coloring(self, pos):
		brush = Circle(Point(*pos), self.session.world_editor.brush_size - 1)
		for p in brush.tuple_iter():
			if p not in self.session.world.full_map:
				continue

			tile = self.session.world.full_map[p]
			if hasattr(tile, '_instance'):
				self.renderer.addColored(tile._instance, *self.HIGHLIGHT_COLOR)

	def _remove_coloring(self):
		self.renderer.removeAllColored()

########NEW FILE########
__FILENAME__ = style
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

try:
	#TODO fifechan / FIFE 0.3.5+ compat
	from fife.fifechan import Color
except ImportError:
	# this is the old (0.3.4 and earlier) API
	from fife.fife import Color

BROWN = { 64: Color(80, 80, 40,  64),
          96: Color(80, 80, 40,  96),
         128: Color(80, 80, 40, 128),
         192: Color(80, 80, 40, 192),
         255: Color(80, 80, 40, 255),
}

WHITE = { 32: Color(255, 255, 255,  32),
          64: Color(255, 255, 255,  64),
          96: Color(255, 255, 255,  96),
         160: Color(255, 255, 255, 160),
         255: Color(255, 255, 255, 255),
}

NOTHING = Color(0, 0, 0, 0)

STYLES = {
'default': {
		'default': {
			'background_color': NOTHING,
			'base_color': NOTHING,
			'foreground_color': BROWN[255],
			'selection_color': BROWN[192],
			'border_size': 0,
			'margins': (0, 0),
			'font': 'default',
			'vertical_scrollbar': 1,
			'horizontal_scrollbar': 0,
		},
		'Button': {
			'base_color': BROWN[64],
			'foreground_color': BROWN[192],
			'margins': (10, 5),
		},
		#TODO combine the following two after the tuple notation bug is fixed:
		# http://github.com/fifengine/fifengine/issues/656
		'CheckBox': {
			'background_color': WHITE[96],
		},
		'RadioButton': {
			'background_color': WHITE[96],
		},
		'ListBox': {
			'selection_color': WHITE[160],
		},
		'ScrollArea': {
			'selection_color': WHITE[255],
			'background_color': WHITE[64],
			'base_color': BROWN[64],
		},
		#TODO combine the following two after the tuple notation bug is fixed
		'Slider': {
			'base_color': BROWN[96],
		},
		'StepSlider': {
			'base_color': BROWN[96],
		},
		'TextField': {
			'selection_color': BROWN[96],
			'background_color': WHITE[64],
		},
},

'menu': { #Used in the main menu
		'default': {
			'font': 'headline_light',
		},
		'Label': {
			'background_color': Color(0, 0, 0, 102),
			'font': 'mainmenu',
		},
},

'resource_bar': {
		'default': {
			'font': 'resourcebar',
		},
},

'headline': { # style for headlines
		'default': {
			'font': 'headline',
		},
},

}

########NEW FILE########
__FILENAME__ = boatbuildertabs
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import math
from operator import itemgetter

from fife.extensions.pychan.widgets import Icon, HBox, Label, Container

from horizons.command.production import AddProduction, RemoveFromQueue, CancelCurrentProduction
from horizons.engine import Fife
from horizons.gui.tabs import OverviewTab
from horizons.gui.util import create_resource_icon
from horizons.gui.widgets.imagebutton import OkButton, CancelButton
from horizons.i18n import _lazy
from horizons.scheduler import Scheduler
from horizons.util.python.callback import Callback
from horizons.constants import PRODUCTIONLINES, RES, UNITS, GAME_SPEED
from horizons.world.production.producer import Producer

class _BoatbuilderOverviewTab(OverviewTab):
	"""Private class all classes here inherit."""
	@property
	def producer(self):
		"""Abstract the instance, work only on components"""
		return self.instance.get_component(Producer)


class BoatbuilderTab(_BoatbuilderOverviewTab):
	widget = 'boatbuilder.xml'
	helptext = _lazy("Boat builder overview")

	SHIP_THUMBNAIL = "content/gui/icons/thumbnails/{type_id}.png"
	SHIP_PREVIEW_IMG = "content/gui/images/objects/ships/116/{type_id}.png"

	def show(self):
		super(BoatbuilderTab, self).show()
		Scheduler().add_new_object(Callback(self.refresh), self, run_in=GAME_SPEED.TICKS_PER_SECOND, loops=-1)

	def hide(self):
		super(BoatbuilderTab, self).hide()
		Scheduler().rem_all_classinst_calls(self)

	def refresh(self):
		"""This function is called by the TabWidget to redraw the widget."""
		super(BoatbuilderTab, self).refresh()

		main_container = self.widget.findChild(name="BB_main_tab")
		container_active = main_container.findChild(name="container_active")
		container_inactive = main_container.findChild(name="container_inactive")
		progress_container = main_container.findChild(name="BB_progress_container")
		cancel_container = main_container.findChild(name="BB_cancel_container")
		needed_res_container = self.widget.findChild(name="BB_needed_resources_container")

		# a boatbuilder is considered active here if it builds sth, no matter if it's paused
		production_lines = self.producer.get_production_lines()

		if production_lines:
			cancel_container.parent.showChild(cancel_container)

			# Set progress
			progress_container.parent.showChild(progress_container)
			progress = math.floor(self.producer.get_production_progress() * 100)
			self.widget.findChild(name='progress').progress = progress
			progress_perc = self.widget.findChild(name='BB_progress_perc')
			progress_perc.text = u'{progress}%'.format(progress=progress)

			container_active.parent.showChild(container_active)
			if (Fife.getVersion() >= (0, 4, 0)):
				container_inactive.parent.hideChild(container_inactive)
			else:
				if not container_inactive in container_inactive.parent.hidden_children:
					container_inactive.parent.hideChild(container_inactive)

			# Update boatbuilder queue
			queue = self.producer.get_unit_production_queue()
			queue_container = container_active.findChild(name="queue_container")
			queue_container.removeAllChildren()
			for place_in_queue, unit_type in enumerate(queue):
				image = self.__class__.SHIP_THUMBNAIL.format(type_id=unit_type)
				helptext = _("{ship} (place in queue: {place})").format(
				        ship=self.instance.session.db.get_unit_type_name(unit_type),
				        place=place_in_queue+1)
				# people don't count properly, always starting at 1..
				icon_name = "queue_elem_"+str(place_in_queue)
				icon = Icon(name=icon_name, image=image, helptext=helptext)
				rm_from_queue_cb = Callback(RemoveFromQueue(self.producer, place_in_queue).execute,
				                            self.instance.session)
				icon.capture(rm_from_queue_cb, event_name="mouseClicked")
				queue_container.addChild( icon )

			# Set built ship info
			production_line = self.producer._get_production(production_lines[0])
			produced_unit_id = production_line.get_produced_units().keys()[0]

			name = self.instance.session.db.get_unit_type_name(produced_unit_id)

			container_active.findChild(name="headline_BB_builtship_label").text = _(name)
			ship_icon = container_active.findChild(name="BB_cur_ship_icon")
			ship_icon.helptext = self.instance.session.db.get_ship_tooltip(produced_unit_id)
			ship_icon.image = self.__class__.SHIP_PREVIEW_IMG.format(type_id=produced_unit_id)

			button_active = container_active.findChild(name="toggle_active_active")
			button_inactive = container_active.findChild(name="toggle_active_inactive")
			to_active = not self.producer.is_active()

			if not to_active: # swap what we want to show and hide
				button_active, button_inactive = button_inactive, button_active
			if (Fife.getVersion() >= (0, 4, 0)):
				button_active.parent.hideChild(button_active)
			else:
				if not button_active in button_active.parent.hidden_children:
					button_active.parent.hideChild(button_active)
			button_inactive.parent.showChild(button_inactive)

			set_active_cb = Callback(self.producer.set_active, active=to_active)
			button_inactive.capture(set_active_cb, event_name="mouseClicked")

			upgrades_box = container_active.findChild(name="BB_upgrades_box")
			upgrades_box.removeAllChildren()

			# Update needed resources
			production = self.producer.get_productions()[0]
			needed_res = production.get_consumed_resources()
			# Now sort! -amount is the positive value, drop unnecessary res (amount 0)
			needed_res = dict((res, -amount) for res, amount in needed_res.iteritems() if amount < 0)
			needed_res = sorted(needed_res.iteritems(), key=itemgetter(1), reverse=True)
			needed_res_container.removeAllChildren()
			for i, (res, amount) in enumerate(needed_res):
				icon = create_resource_icon(res, self.instance.session.db)
				icon.max_size = icon.min_size = icon.size = (16, 16)
				label = Label(name="needed_res_lbl_%s" % i)
				label.text = u'{amount}t'.format(amount=amount)
				new_hbox = HBox(name="needed_res_box_%s" % i)
				new_hbox.addChildren(icon, label)
				needed_res_container.addChild(new_hbox)

			cancel_button = self.widget.findChild(name="BB_cancel_button")
			cancel_cb = Callback(CancelCurrentProduction(self.producer).execute, self.instance.session)
			cancel_button.capture(cancel_cb, event_name="mouseClicked")

		else: # display sth when nothing is produced
			container_inactive.parent.showChild(container_inactive)
			for w in (container_active, progress_container, cancel_container):
				if (Fife.getVersion() >= (0, 4, 0)):
					w.parent.hideChild(w)
				else:
					if not w in w.parent.hidden_children:
						w.parent.hideChild(w)

		self.widget.adaptLayout()

# this tab additionally requests functions for:
# * decide: show [start view] = nothing but info text, look up the xml, or [building status view]
# * get: currently built ship: name / image / upgrades
# * resources still needed:
#	(a) which ones? three most important (image, name)
#	(b) how many? sort by amount, display (amount, overall amount needed of them, image)
# * pause production (keep order and "running" running costs [...] but collect no new resources)
# * abort building process: delete task, remove all resources, display [start view] again

class BoatbuilderSelectTab(_BoatbuilderOverviewTab):
	widget = 'boatbuilder_showcase.xml'

	def init_widget(self):
		super(BoatbuilderSelectTab, self).init_widget()
		self.widget.findChild(name='headline').text = self.helptext

		showcases = self.widget.findChild(name='showcases')
		for i, (ship, prodline) in enumerate(self.ships):
			showcase = self.build_ship_info(i, ship, prodline)
			showcases.addChild(showcase)

	def build_ship_info(self, index, ship, prodline):
		size = (260, 90)
		widget = Container(name='showcase_%s' % index, position=(0, 20 + index*90),
		                   min_size=size, max_size=size, size=size)
		bg_icon = Icon(image='content/gui/images/background/square_80.png', name='bg_%s'%index)
		widget.addChild(bg_icon)

		image = 'content/gui/images/objects/ships/76/{unit_id}.png'.format(unit_id=ship)
		helptext = self.instance.session.db.get_ship_tooltip(ship)
		unit_icon = Icon(image=image, name='icon_%s'%index, position=(2, 2),
		                 helptext=helptext)
		widget.addChild(unit_icon)

		# if not buildable, this returns string with reason why to be displayed as helptext
		#ship_unbuildable = self.is_ship_unbuildable(ship)
		ship_unbuildable = False
		if not ship_unbuildable:
			button = OkButton(position=(60, 50), name='ok_%s'%index, helptext=_('Build this ship!'))
			button.capture(Callback(self.start_production, prodline))
		else:
			button = CancelButton(position=(60, 50), name='ok_%s'%index,
			helptext=ship_unbuildable)

		widget.addChild(button)

		# Get production line info
		production = self.producer.create_production_line(prodline)
		# consumed == negative, reverse to sort in *ascending* order:
		costs = sorted(production.consumed_res.iteritems(), key=itemgetter(1))
		for i, (res, amount) in enumerate(costs):
			xoffset = 103 + (i  % 2) * 55
			yoffset =  20 + (i // 2) * 20
			icon = create_resource_icon(res, self.instance.session.db)
			icon.max_size = icon.min_size = icon.size = (16, 16)
			icon.position = (xoffset, yoffset)
			label = Label(name='cost_%s_%s' % (index, i))
			if res == RES.GOLD:
				label.text = unicode(-amount)
			else:
				label.text = u'{amount:02}t'.format(amount=-amount)
			label.position = (22 + xoffset, yoffset)
			widget.addChild(icon)
			widget.addChild(label)
		return widget

	def start_production(self, prod_line_id):
		AddProduction(self.producer, prod_line_id).execute(self.instance.session)
		# show overview tab
		self.instance.session.ingame_gui.get_cur_menu().show_tab(0)


class BoatbuilderFisherTab(BoatbuilderSelectTab):
	icon_path = 'icons/tabwidget/boatbuilder/fisher'
	helptext = _lazy("Fisher boats")

	ships = [
		#(UNITS.FISHER_BOAT, PRODUCTIONLINES.FISHING_BOAT),
		#(UNITS.CUTTER, PRODUCTIONLINES.xxx),
		#(UNITS.HERRING_FISHER, PRODUCTIONLINES.xxx),
		#(UNITS.WHALER, PRODUCTIONLINES.xxx),
	]


class BoatbuilderTradeTab(BoatbuilderSelectTab):
	icon_path = 'icons/tabwidget/boatbuilder/trade'
	helptext = _lazy("Trade boats")

	ships = [
		(UNITS.HUKER_SHIP, PRODUCTIONLINES.HUKER),
		#(UNITS.COURIER_BOAT, PRODUCTIONLINES.xxx),
		#(UNITS.SMALL_MERCHANT, PRODUCTIONLINES.xxx),
		#(UNITS.BIG_MERCHANT, PRODUCTIONLINES.xxx),
	]


class BoatbuilderWar1Tab(BoatbuilderSelectTab):
	icon_path = 'icons/tabwidget/boatbuilder/war1'
	helptext = _lazy("War boats")

	ships = [
		#(UNITS.SMALL_GUNBOAT, PRODUCTIONLINES.SMALL_GUNBOAT),
		#(UNITS.NAVAL_CUTTER, PRODUCTIONLINES.NAVAL_CUTTER),
		#(UNITS.BOMBADIERE, PRODUCTIONLINES.BOMBADIERE),
		#(UNITS.SLOOP_O_WAR, PRODUCTIONLINES.SLOOP_O_WAR),
	]


class BoatbuilderWar2Tab(BoatbuilderSelectTab):
	icon_path = 'icons/tabwidget/boatbuilder/war2'
	helptext = _lazy("War ships")

	ships = [
		#(UNITS.GALLEY, PRODUCTIONLINES.GALLEY),
		#(UNITS.BIG_GUNBOAT, PRODUCTIONLINES.BIG_GUNBOAT),
		#(UNITS.CORVETTE, PRODUCTIONLINES.CORVETTE),
		(UNITS.FRIGATE, PRODUCTIONLINES.FRIGATE),
	]


# these tabs additionally request functions for:
# * goto: show [confirm view] tab (not accessible via tab button in the end)
#	need to provide information about the selected ship (which of the 4 buttons clicked)
# * check: mark those ship's buttons as unbuildable (close graphics) which do not meet the specified requirements.
#	the tooltips contain this info as well.

class BoatbuilderConfirmTab(_BoatbuilderOverviewTab):
	widget = 'boatbuilder_confirm.xml'
	helptext = _lazy("Confirm order")

	def init_widget(self):
		super(BoatbuilderConfirmTab, self).init_widget()
		events = { 'create_unit': self.start_production }
		self.widget.mapEvents(events)

	def start_production(self):
		AddProduction(self.producer, 15).execute(self.instance.session)

# this "tab" additionally requests functions for:
# * get: currently ordered ship: name / image / type (fisher/trade/war)
# * => get: currently ordered ship: description text / costs / available upgrades
#						(fisher/trade/war, builder level)
# * if resource icons not hardcoded: resource icons, sort them by amount
# UPGRADES: * checkboxes * check for boat builder level (+ research) * add. costs (get, add, display)
# * def start_production(self):  <<< actually start to produce the selected ship unit with the selected upgrades
#	(use inventory or go collect resources, switch focus to overview tab).
#	IMPORTANT: lock this button until unit is actually produced (no queue!)

########NEW FILE########
__FILENAME__ = buildingtabs
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.gui.tabs import OverviewTab
from horizons.i18n import _lazy
from horizons.util.loaders.actionsetloader import ActionSetLoader
from horizons.component.namedcomponent import NamedComponent
from horizons.component.storagecomponent import StorageComponent
from horizons.component.depositcomponent import DepositComponent


class TowerOverviewTab(OverviewTab): # defensive tower
	widget = 'overview_tower.xml'
	helptext = _lazy("Tower overview")

	def init_widget(self):
		super(TowerOverviewTab, self).init_widget()
		self.widget.findChild(name="headline").text = self.instance.settlement.get_component(NamedComponent).name

class SignalFireOverviewTab(OverviewTab):
	widget = 'overview_signalfire.xml'
	helptext = _lazy("Overview")

	def init_widget(self):
		super(SignalFireOverviewTab, self).init_widget()
		action_set = ActionSetLoader.get_sets()[self.instance._action_set_id]
		action_gfx = action_set.items()[0][1]
		image = action_gfx[45].keys()[0]
		self.widget.findChild(name="building_image").image = image

class ResourceDepositOverviewTab(OverviewTab):
	widget = 'overview_resourcedeposit.xml'

	def init_widget(self):
		super(ResourceDepositOverviewTab, self).init_widget()
		# display range starts 0, not min_amount, else it looks like there's nothing in it
		# when parts of the ore have been mined already
		resources = self.instance.get_component(DepositComponent).get_res_ranges()
		amounts = dict( (res, (0, max_amount)) for res, min_, max_amount in resources )
		self.widget.child_finder("inventory").init(self.instance.session.db,
		                                           self.instance.get_component(StorageComponent).inventory,
		                                           ordinal=amounts)
	def refresh(self):
		super(ResourceDepositOverviewTab, self).refresh()
		self.widget.child_finder("inventory").update()

########NEW FILE########
__FILENAME__ = buildrelatedtab
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import Icon

from horizons.gui.tabs import OverviewTab
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.imagebutton import ImageButton
from horizons.i18n import _lazy
from horizons.util.python.callback import Callback
from horizons.entities import Entities
from horizons.component.selectablecomponent import SelectableComponent

class BuildRelatedTab(OverviewTab):
	"""
	Adds a special tab to each production building with at least one entry in
	the table related_buildings. This tab acts as modified build menu tab and
	only displays those buildings actually related to the selected building.
	Examples: tree for lumberjack; pavilion, school, etc. for inhabitants.
	"""
	widget = 'related_buildings.xml'
	icon_path = 'icons/tabwidget/production/related'
	helptext = _lazy("Build related buildings")
	template_gui_xml = 'related_buildings_container.xml'

	def refresh(self):
		"""
		This function is called by the TabWidget to redraw the widget.
		"""
		# remove old data
		parent_container = self.widget.child_finder('related_buildings')
		while parent_container.children:
			parent_container.removeChild(parent_container.children[0])

		# load all related buildings from DB
		building_ids = self.instance.session.db.get_related_building_ids_for_menu(self.instance.id)
		sorted_ids = sorted([(b, Entities.buildings[b].settler_level) for b in building_ids], key=lambda x : x[1])
		container = self.__get_new_container()
		self.current_row = min(building[1] for building in sorted_ids)
		for building_id, level in sorted_ids:
			if level <= self.instance.owner.settler_level: # available in build menu?
				button = self._create_build_buttons(building_id, container)
				# check whether to start new line (for new tier row)
				if level > self.current_row:
					self.current_row = level
					parent_container.addChild(container)
					container = self.__get_new_container()
				container.findChild(name="build_button_container").addChild(button)
				button_bg = Icon(image="content/gui/images/buttons/buildmenu_button_bg.png")
				container.findChild(name="build_button_bg_container").addChild(button_bg)
		# Still need to add last container
		parent_container.addChild(container)
		super(BuildRelatedTab, self).refresh()

	def __get_new_container(self):
		"""
		Loads a background container xml file. Returns the loaded widget.
		"""
		gui = load_uh_widget(self.template_gui_xml)
		return gui.findChild(name="buildings_container")

	def _create_build_buttons(self, building_id, container):
		# {{mode}} in double braces because it is replaced as a second step
		building_type = Entities.buildings[building_id]
		build_button = ImageButton(name="build{id}".format(id=building_id), helptext=building_type.get_tooltip())
		build_button.path = "icons/buildmenu/{id:03d}".format(id=building_id)
		build_button.capture(Callback(self.build_related, building_id))
		return build_button

	def build_related(self, building_id):
		self.hide()
		# deselect all
		for instance in self.instance.session.selected_instances:
			instance.get_component(SelectableComponent).deselect()
		self.instance.session.selected_instances.clear()

		self.instance.session.ingame_gui.set_cursor('building', Entities.buildings[building_id],
		                                            ship=None,
		                                            build_related=self.instance)

########NEW FILE########
__FILENAME__ = buildtabs
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import horizons.globals

from horizons.entities import Entities
from horizons.gui.tabs.tabinterface import TabInterface
from horizons.command.building import Build
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.yamlcache import YamlCache
from horizons.util.lastactiveplayersettlementmanager import LastActivePlayerSettlementManager
from horizons.component.storagecomponent import StorageComponent
from horizons.messaging import NewPlayerSettlementHovered
from horizons.ext.enum import Enum

class InvalidBuildMenuFileFormat(Exception):
	pass

class BuildTab(TabInterface):
	"""
	Layout data is defined in image_data and text_data.
	Columns in the tabs are enumerated as follows:
	  01  11  21  31
	  02  12  22  32
	  03  13  23  33
	  04  14  24  34
	Boxes and Labels have the same number as their left upper icon.
	Check buildtab.xml for details. Icons without image are transparent.
	"""
	lazy_loading = True
	widget = 'buildtab.xml'

	MAX_ROWS = 4
	MAX_COLS = 4

	build_menus = [
	  "content/objects/gui_buildmenu/build_menu_per_tier.yaml",
	  "content/objects/gui_buildmenu/build_menu_per_type.yaml"
	  ]

	build_menu_config_per_tier = build_menus[0]
	build_menu_config_per_type = build_menus[1]

	default_build_menu_config = build_menu_config_per_tier

	cur_build_menu_config = default_build_menu_config

	# NOTE: check for occurrences of this when adding one, you might want to
	#       add respective code there as well
	unlocking_strategies = Enum("tab_per_tier", # 1 tab per tier
	                            "single_per_tier" # each single building unlocked if tier is unlocked
	                            )

	last_active_build_tab = None

	def __init__(self, session, tabindex, data, build_callback, unlocking_strategy, build_menu_config):
		"""
		@param tabindex: position of tab
		@param data: data directly from yaml specifying the contents of this tab
		@param build_callback: called on clicks
		@param unlocking_strategy: element of unlocking_strategies
		@param build_menu_config: entry of build_menus where this definition originates from
		"""
		icon_path = None
		helptext = None
		headline = None
		rows = []
		for entry in data:
			if isinstance(entry, dict):
				# this is one key-value pair, e.g. "- icon: img/foo.png"
				if len(entry) != 1:
					raise InvalidBuildMenuFileFormat("Invalid entry in buildmenuconfig: %s" % entry)
				key, value = entry.items()[0]
				if key == "icon":
					icon_path = value
				elif key == "helptext":
					helptext = value[2:] if value.startswith('_ ') else value
				elif key == "headline":
					headline = value[2:] if value.startswith('_ ') else value
				else:
					raise InvalidBuildMenuFileFormat("Invalid key: %s\nMust be either icon, helptext or headline." % key)
			elif isinstance(entry, list):
				# this is a line of data
				rows.append(entry) # parse later on demand
			else:
				raise InvalidBuildMenuFileFormat("Invalid entry: %s" % entry)

		if not icon_path:
			raise InvalidBuildMenuFileFormat("icon_path definition is missing.")

		self.session = session
		self.tabindex = tabindex
		self.build_callback = build_callback
		self.unlocking_strategy = unlocking_strategy
		if self.unlocking_strategy != self.__class__.unlocking_strategies.tab_per_tier:
			if not helptext and not headline:
				raise InvalidBuildMenuFileFormat("helptext definition is missing.")
		self.row_definitions = rows
		self.headline = _(headline) if headline else headline # don't translate None
		self.helptext = _(helptext) if helptext else self.headline

		#get build style
		saved_build_style = horizons.globals.fife.get_uh_setting("Buildstyle")
		self.cur_build_menu_config = self.__class__.build_menus[ saved_build_style ]

		super(BuildTab, self).__init__(icon_path=icon_path)

	@classmethod
	def get_saved_buildstyle(cls):
		saved_build_style = horizons.globals.fife.get_uh_setting("Buildstyle")
		return cls.build_menus[ saved_build_style ]

	def init_widget(self):
		self.__current_settlement = None
		headline_lbl = self.widget.child_finder('headline')
		if self.headline: # prefer specific headline
			headline_lbl.text = self.headline
		elif self.unlocking_strategy == self.__class__.unlocking_strategies.tab_per_tier:
			headline_lbl.text = _(self.session.db.get_settler_name(self.tabindex))

	def set_content(self):
		"""Parses self.row_definitions and sets the content accordingly"""
		settlement = LastActivePlayerSettlementManager().get()
		def _set_entry(button, icon, building_id):
			"""Configure a single build menu button"""
			if self.unlocking_strategy == self.__class__.unlocking_strategies.single_per_tier and \
			   self.get_building_tiers()[building_id] > self.session.world.player.settler_level:
				return

			building = Entities.buildings[building_id]
			button.helptext = building.get_tooltip()

			# Add necessary resources to tooltip text.
			# tooltip.py will then place icons from this information.
			required_resources = ''
			for resource_id, amount_needed in sorted(building.costs.items()):
				required_resources += ' %s:%s' % (resource_id, amount_needed)
			required_text = '[[Buildmenu%s]]' % (required_resources)
			button.helptext = required_text + button.helptext

			enough_res = False # don't show building by default
			if settlement is not None: # settlement is None when the mouse has left the settlement
				res_overview = self.session.ingame_gui.resource_overview
				show_costs = Callback(res_overview.set_construction_mode, settlement, building.costs)
				button.mapEvents({
				  button.name+"/mouseEntered/buildtab" : show_costs,
				  button.name+"/mouseExited/buildtab" : res_overview.close_construction_mode
				  })

				(enough_res, missing_res) = Build.check_resources({}, building.costs, settlement.owner, [settlement])
			# Check whether to disable build menu icon (not enough res available).
			if enough_res:
				icon.image = "content/gui/images/buttons/buildmenu_button_bg.png"
				button.path = "icons/buildmenu/{id:03d}".format(id=building_id)
			else:
				icon.image = "content/gui/images/buttons/buildmenu_button_bg_bw.png"
				button.path = "icons/buildmenu/greyscale/{id:03d}".format(id=building_id)

			button.capture(Callback(self.build_callback, building_id))

		for row_num, row in enumerate(self.row_definitions):
			# we have integers for building types, strings for headlines above slots and None as empty slots
			column = -1 # can't use enumerate, not always incremented
			for entry in row:
				column += 1
				position = (10*column) + (row_num+1) # legacy code, first row is 1, 11, 21
				if entry is None:
					continue
				elif (column + 1) > self.MAX_COLS:
					# out of 4x4 bounds
					err = "Invalid entry '%s': column %s does not exist." % (entry, column + 1)
					err += " Max. column amount in current layout is %s." % self.MAX_COLS
					raise InvalidBuildMenuFileFormat(err)
				elif row_num > self.MAX_ROWS:
					# out of 4x4 bounds
					err = "Invalid entry '%s': row %s does not exist." % (entry, row_num)
					err += " Max. row amount in current layout is %s." % self.MAX_ROWS
					raise InvalidBuildMenuFileFormat(err)
				elif isinstance(entry, basestring):
					column -= 1 # a headline does not take away a slot
					lbl = self.widget.child_finder('label_{position:02d}'.format(position=position))
					lbl.text = _(entry[2:]) if entry.startswith('_ ') else entry
				elif isinstance(entry, int):
					button = self.widget.child_finder('button_{position:02d}'.format(position=position))
					icon = self.widget.child_finder('icon_{position:02d}'.format(position=position))
					_set_entry(button, icon, entry)
				else:
					raise InvalidBuildMenuFileFormat("Invalid entry: %s" % entry)

	def refresh(self):
		self.set_content()

	def on_settlement_change(self, message):
		if message.settlement is not None:
			# only react to new actual settlements, else we have no res source
			self.refresh()

	def __remove_changelisteners(self):
		NewPlayerSettlementHovered.discard(self.on_settlement_change)
		if self.__current_settlement is not None:
			inventory = self.__current_settlement.get_component(StorageComponent).inventory
			inventory.discard_change_listener(self.refresh)

	def __add_changelisteners(self):
		NewPlayerSettlementHovered.subscribe(self.on_settlement_change)
		if self.__current_settlement is not None:
			inventory = self.__current_settlement.get_component(StorageComponent).inventory
			if not inventory.has_change_listener(self.refresh):
				inventory.add_change_listener(self.refresh)

	def show(self):
		self.__remove_changelisteners()
		self.__current_settlement = LastActivePlayerSettlementManager().get()
		self.__add_changelisteners()
		self.__class__.last_active_build_tab = self.tabindex
		super(BuildTab, self).show()

		button = self.widget.child_finder("switch_build_menu_config_button")
		self._set_switch_layout_button_image(button)
		button.capture(self._switch_build_menu_config)

	def hide(self):
		self.__remove_changelisteners()
		super(BuildTab, self).hide()

	def _set_switch_layout_button_image(self, button):
		image_path = "content/gui/icons/tabwidget/buildmenu/"
		if self.__class__.cur_build_menu_config is self.build_menu_config_per_type:
			button.up_image = image_path + "tier.png"
		else:
			button.up_image = image_path + "class.png"
		self.switch_layout_button_needs_update = False

	def _switch_build_menu_config(self):
		"""Sets next build menu config and recreates the gui"""
		cur_index = self.__class__.build_menus.index( self.cur_build_menu_config )
		new_index = (cur_index + 1) % len(self.__class__.build_menus)
		self.__class__.cur_build_menu_config = self.__class__.build_menus[ new_index ]

		# after switch set active tab to first
		self.__class__.last_active_build_tab = 0
		self.session.ingame_gui.show_build_menu(update=True)

		#save build style
		horizons.globals.fife.set_uh_setting("Buildstyle",new_index)
		horizons.globals.fife.save_settings();

	@classmethod
	def create_tabs(cls, session, build_callback):
		"""Create according to current build menu config
		@param build_callback: function to call to enable build mode, has to take building type parameter
		"""
		source = cls.get_saved_buildstyle()
		# parse
		data = YamlCache.get_file( source, game_data=True )
		if 'meta' not in data:
			raise InvalidBuildMenuFileFormat('File does not contain "meta" section')
		metadata = data['meta']
		if 'unlocking_strategy' not in metadata:
			raise InvalidBuildMenuFileFormat('"meta" section does not contain "unlocking_strategy"')
		try:
			unlocking_strategy = cls.unlocking_strategies.get_item_for_string( metadata['unlocking_strategy'] )
		except KeyError:
			raise InvalidBuildMenuFileFormat('Invalid entry for "unlocking_strategy"')

		# create tab instances
		tabs = []
		for tab, tabdata in sorted(data.iteritems()):
			if tab == "meta":
				continue # not a tab

			if unlocking_strategy == cls.unlocking_strategies.tab_per_tier and len(tabs) > session.world.player.settler_level:
				break

			try:
				tab = BuildTab(session, len(tabs), tabdata, build_callback, unlocking_strategy, source)
				tabs.append( tab )
			except Exception as e:
				to_add = "\nThis error happened in %s of %s ." % (tab, source)
				e.args = ( e.args[0] + to_add, ) + e.args[1:]
				e.message = ( e.message + to_add )
				raise

		return tabs

	@classmethod
	@decorators.cachedfunction
	def get_building_tiers(cls):
		"""Returns a dictionary mapping building type ids to their tiers
		@return cached dictionary (don't modify)"""
		building_tiers = {}
		data = YamlCache.get_file( cls.build_menu_config_per_tier, game_data=True )
		tier = -1
		for tab, tabdata in sorted(data.iteritems()):
			if tab == "meta":
				continue # not a tab

			tier += 1

			for row in tabdata:
				if isinstance(row, list): # actual content
					for entry in row:
						if isinstance(entry, int): # actual building button
							building_tiers[entry] = tier
		return building_tiers

########NEW FILE########
__FILENAME__ = buyselltab
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife
import logging
import functools

from horizons.gui.tabs.tabinterface import TabInterface
from horizons.extscheduler import ExtScheduler
from horizons.command.uioptions import SetTradeSlot, ClearTradeSlot
from horizons.gui.widgets.tradehistoryitem import TradeHistoryItem
from horizons.gui.util import load_uh_widget, get_res_icon_path, create_resource_selection_dialog
from horizons.util.python.callback import Callback
from horizons.util.worldobject import WorldObject
from horizons.component.tradepostcomponent import TradePostComponent
from horizons.constants import TRADER

class BuySellTab(TabInterface):
	"""
	Allows players to tell settlements which resources to buy or sell by adding
	slots in either buy or sell mode and introducing a limit per such slot.
	Also contains the trade history.
	"""
	log = logging.getLogger("gui")

	widget = 'buysellmenu.xml'
	icon_path = 'icons/tabwidget/warehouse/buysell'

	buy_button_path = "content/gui/images/tabwidget/ship_to_warehouse.png"
	buy_hover_button_path = "content/gui/images/tabwidget/buysell_toggle.png"
	sell_button_path = "content/gui/images/tabwidget/warehouse_to_ship.png"
	sell_hover_button_path = "content/gui/images/tabwidget/buysell_toggle.png"

	dummy_icon_path = "icons/resources/none_gray"

	def __init__(self, instance):
		"""Set up the GUI and game logic for the buyselltab."""
		self.inited = False # prevents execution of commands during init
		# this makes sharing code easier
		self.session = instance.session
		self.trade_post = instance.settlement.get_component(TradePostComponent)
		assert isinstance(self.trade_post, TradePostComponent)

		super(BuySellTab, self).__init__()

	def init_widget(self):
		# don't access instance beyond this point, only components

		# add the buy/sell slot widgets
		self.slot_widgets = {}
		self.resources = None # Placeholder for resource gui
		self.add_slots(len(self.trade_post.slots))

		for slot_id in xrange(len(self.trade_post.slots)):
			if self.trade_post.slots[slot_id] is not None:
				trade_slot_info = self.trade_post.slots[slot_id]
				self.slot_widgets[slot_id].action = 'sell' if trade_slot_info.selling else 'buy'
				self.add_resource(trade_slot_info.resource_id, slot_id, trade_slot_info.limit)

				if trade_slot_info.selling:
					self._show_sell(self.slot_widgets[slot_id])
				else:
					self._show_buy(self.slot_widgets[slot_id])

		# init the trade history
		self.trade_history = self.widget.findChild(name='trade_history')
		self.trade_history_widget_cache = {} # {(tick, player_id, resource_id, amount, gold): widget, ...}

		self.hide()
		self.helptext = _("Trade")
		self.inited = True

	def hide(self):
		"""Hide the tab and all widgets we may have added at runtime."""
		ExtScheduler().rem_all_classinst_calls(self)
		self.widget.hide()
		if self.resources is not None:
			self.resources.hide()

	def show(self):
		"""Display the tab's content, start the refresher."""
		self.widget.show()
		self.session.ingame_gui.minimap_to_front()
		self.refresh()
		ExtScheduler().add_new_object(self.refresh, self, run_in=0.4, loops=-1)

	def is_visible(self):
		# this tab sometimes is made up an extra widget, so it must also be considered
		# when checking for visibility
		return super(BuySellTab, self).is_visible() or \
		       (self.resources is not None and self.resources.isVisible())

	def _refresh_trade_history(self):
		self.trade_history.removeAllChildren()
		unused_rows = set(self.trade_history_widget_cache.keys())

		settlement_trade_history = self.trade_post.trade_history
		total_entries = len(settlement_trade_history)
		for i in xrange(min(4, total_entries)):
			row = settlement_trade_history[total_entries - i - 1]
			player = WorldObject.get_object_by_id(row[1])
			if row not in self.trade_history_widget_cache:
				self.trade_history_widget_cache[row] = TradeHistoryItem(player, row[2], row[3], row[4])
			widget = self.trade_history_widget_cache[row]
			self.trade_history.addChild(widget)
			unused_rows.discard(row)
		self.trade_history.adaptLayout()

		for row in unused_rows:
			del self.trade_history_widget_cache[row]

	def refresh(self):
		self._refresh_trade_history()
		# TODO: We don't refresh. Ticket #970
		if not self.trade_post.buy_list and not self.trade_post.sell_list:
			self._set_hint(_("Click on one of the resource slots to add a trade offer."))

	def add_slots(self, amount):
		"""
		Add `amount` slot widgets to the buysellmenu.
		@param amount: number of slot widgets that are to be added.
		"""
		content = self.widget.findChild(name="content")
		for i in xrange(amount):
			slot = load_uh_widget('trade_single_slot.xml')
			self.slot_widgets[i] = slot
			slot.id = i
			slot.action = 'buy'
			slot.res = None
			slot.name = "slot_%d" % i
			slot.findChild(name='button').capture(self.handle_click, event_name='mouseClicked')
			slot.findChild(name='button').path = self.dummy_icon_path
			slider = slot.findChild(name="slider")
			slider.scale_start = 0.0
			slider.scale_end = float(self.trade_post.get_inventory().limit)
			# Set scale according to the settlement inventory size
			slot.findChild(name="buysell").capture(Callback(self.toggle_buysell, i))
			fillbar = slot.findChild(name="fillbar")
			# hide fillbar by setting position
			icon = slot.findChild(name="icon")
			fillbar.position = (icon.width - fillbar.width - 1, icon.height)
			content.addChild(slot)
		self.widget.adaptLayout()


	def add_resource(self, resource_id, slot_id, value=None):
		"""
		Adds a resource to the specified slot
		@param resource_id: int - resource id
		@param slot_id: int - slot number of the slot that is to be set
		"""
		self.log.debug("BuySellTab add_resource() resid: %s; slot_id %s; value: %s", resource_id, slot_id, value)

		keep_hint = False
		if self.resources is not None: # Hide resource menu
			self.resources.hide()
			self.show()
			if resource_id != 0: # new res
				self._set_hint( _("Set to buy or sell by clicking on that label, then adjust the amount via the slider to the right.") )
			else:
				self._set_hint( u"" )
			keep_hint = True
		slot = self.slot_widgets[slot_id]
		slider = slot.findChild(name="slider")

		if value is None: # use current slider value if player provided no input
			value = int(slider.value)
		else: # set slider to value entered by the player
			slider.value = float(value)

		if slot.action == "sell":
			if slot.res is not None: # slot has been in use before, delete old value
				self.clear_slot(slot_id)
			if resource_id != 0:
				self.set_slot_info(slot.id, resource_id, True, value)
		elif slot.action == "buy":
			if slot.res is not None: # slot has been in use before, delete old value
				self.clear_slot(slot_id)
			if resource_id != 0:
				self.set_slot_info(slot.id, resource_id, False, value)

		button = slot.findChild(name="button")
		fillbar = slot.findChild(name="fillbar")
		# reset slot value for new res
		if resource_id == 0:
			button.path = self.dummy_icon_path
			button.helptext = u""
			slot.findChild(name="amount").text = u""
			slot.findChild(name="slider").value = 0.0
			slot.res = None
			slider.capture(None)
			# hide fillbar by setting position
			icon = slot.findChild(name="icon")
			fillbar.position = (icon.width - fillbar.width - 1, icon.height)
			button = slot.findChild(name="buysell")
			button.up_image = None
			button.hover_image = None
		else:
			icon = get_res_icon_path(resource_id)
			icon_disabled = get_res_icon_path(resource_id, greyscale=True)
			button.up_image = icon
			button.down_image = icon
			button.hover_image = icon_disabled
			button.helptext = self.session.db.get_res_name(resource_id)
			slot.res = resource_id
			# use some python magic to assign a res attribute to the slot to
			# save which resource_id it stores
			slider.capture(Callback(self.slider_adjust, resource_id, slot.id))
			slot.findChild(name="amount").text = u"{amount:-5d}t".format(amount=value)
			icon = slot.findChild(name="icon")
			inventory = self.trade_post.get_inventory()
			filled = (100 * inventory[resource_id]) // inventory.get_limit(resource_id)
			fillbar.position = (icon.width - fillbar.width - 1,
			                    icon.height - int(icon.height*filled))
			# reuse code from toggle to finish setup (must switch state before, it will reset it)
			slot.action = "sell" if slot.action == "buy" else "buy"
			self.toggle_buysell(slot_id, keep_hint=keep_hint)
		slot.adaptLayout()

	def toggle_buysell(self, slot_id, keep_hint=False):
		"""Switches modes of individual resource slots between 'buy' and 'sell'."""
		slot_widget = self.slot_widgets[slot_id]
		limit = int(slot_widget.findChild(name="slider").value)
		if slot_widget.action == "buy":
			# setting to sell
			self._show_sell(slot_widget)
			slot_widget.action = "sell"
		elif slot_widget.action == "sell":
			# setting to buy
			self._show_buy(slot_widget)
			slot_widget.action = "buy"

		if slot_widget.res is not None:
			selling = slot_widget.action == "sell"
			self.set_slot_info(slot_widget.id, slot_widget.res, selling, limit)

		if not keep_hint:
			self._update_hint(slot_id)

	def set_slot_info(self, slot_id, resource_id, selling, limit):
		assert resource_id is not None
		self.log.debug("BuySellTab: setting slot %d to resource %d, selling=%s, limit %d", slot_id, resource_id, selling, limit)
		self.slot_widgets[slot_id].action = "sell" if selling else "buy"
		if self.inited:
			SetTradeSlot(self.trade_post, slot_id, resource_id, selling, limit).execute(self.session)

	def clear_slot(self, slot_id):
		self.log.debug("BuySellTab: Removing resource in slot %d", slot_id)
		if self.inited:
			ClearTradeSlot(self.trade_post, slot_id).execute(self.session)

	def slider_adjust(self, resource_id, slot_id):
		"""Couples the displayed limit of this slot to the slider position."""
		slider = self.slot_widgets[slot_id].findChild(name="slider")
		limit = int(slider.value)
		self.set_slot_info(slot_id, resource_id, self.slot_widgets[slot_id].action == "sell", limit)
		self.slot_widgets[slot_id].findChild(name="amount").text = u"{amount:-5d}t".format(amount=limit)
		self.slot_widgets[slot_id].adaptLayout()
		self._update_hint(slot_id)

	def handle_click(self, widget, event):
		"""Handle clicks on resource slots. Left: change resource; Right: empty slot."""
		if event.getButton() == fife.MouseEvent.LEFT:
			self.show_resource_menu(widget.parent.id)
			self.session.ingame_gui.minimap_to_front()
		elif event.getButton() == fife.MouseEvent.RIGHT:
			# remove the buy/sell offer
			self.add_resource(0, widget.parent.id)

	def show_resource_menu(self, slot_id):
		"""
		Displays a menu where players can choose which resource to add in the
		selected slot. Available resources are all possible resources and a
		'None' resource which allows to delete slot actions.
		The resources are ordered by their res_id.
		"""
		# create dlg
		buy_list = self.trade_post.buy_list
		sell_list = self.trade_post.sell_list

		res_filter = lambda res_id : res_id not in buy_list and res_id not in sell_list
		on_click = functools.partial(self.add_resource, slot_id=slot_id)
		inventory = self.trade_post.get_inventory()

		self.resources = create_resource_selection_dialog(on_click, inventory,
		                                                  self.session.db,
		                                                  res_filter=res_filter)

		self.resources.position = self.widget.position
		self.hide() # hides tab that invoked the selection widget
		self.session.ingame_gui.minimap_to_front()

		self.resources.show() # show selection widget, still display old tab icons


	def _update_hint(self, slot_id):
		"""Sets default hint for last updated slot"""
		slot_widget = self.slot_widgets[slot_id]
		limit = int(slot_widget.findChild(name="slider").value)
		action = slot_widget.action
		price = self.session.db.get_res_value(slot_widget.res)
		if action == "buy":
			hint = _("Will buy {resource_name} for {price} gold/t whenever less than {limit}t are in stock.")
			price *= TRADER.PRICE_MODIFIER_SELL
		elif action == "sell":
			hint = _("Will sell {resource_name} for {price} gold/t whenever more than {limit}t are available.")
			price *= TRADER.PRICE_MODIFIER_BUY

		hint = hint.format(limit=unicode(limit),
		                   resource_name=self.session.db.get_res_name(slot_widget.res),
		                   price=int(price))
		# same price rounding as in tradepostcomponent
		self._set_hint(hint)

	def _set_hint(self, text):
		lbl = self.widget.findChild(name="hint_label")
		lbl.text = text
		lbl.adaptLayout()

	def _show_buy(self, slot):
		"""Make slot show buy button. Purely visual change"""
		button = slot.findChild(name="buysell")
		button.up_image = self.buy_button_path
		button.hover_image = self.buy_hover_button_path
		button.helptext = _("Buying")

	def _show_sell(self, slot):
		"""Make slot show sell button. Purely visual change"""
		button = slot.findChild(name="buysell")
		button.up_image = self.sell_button_path
		button.hover_image = self.sell_hover_button_path
		button.helptext = _("Selling")

########NEW FILE########
__FILENAME__ = diplomacytab
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.gui.tabs.tabinterface import TabInterface
from horizons.gui.tabs.tabwidget import TabWidget
from horizons.util.python.callback import Callback
from horizons.command.diplomacy import AddAllyPair, AddNeutralPair, AddEnemyPair


class PlayerDiplomacyTab(TabInterface):
	"""
	Diplomacy tab set per player.
	It displays the menu for selecting the status between the local player and the tab's player
	"""
	widget = 'diplomacy.xml'
	icon_path = 'images/tabwidget/emblems/emblem_%s'

	def __init__(self, player):
		self.local_player = player.session.world.player
		self.player = player
		self.diplomacy = player.session.world.diplomacy

		super(PlayerDiplomacyTab, self).__init__()

		color = self.player.color.name
		# Set these here to override the defaults in TabInterface.__init__
		# before they are used.
		self.path = self.path_active = self.icon_path % color

	def init_widget(self):
		self.widget.findChild(name='headline').text = self.player.name
		self.widget.mapEvents({
			'ally_label' : self.add_ally,
			'ally_check_box' : self.add_ally,
			'neutral_label' : self.add_neutral,
			'neutral_check_box' : self.add_neutral,
			'enemy_label' : self.add_enemy,
			'enemy_check_box' : self.add_enemy})

		self.check_diplomacy_state()
		self.helptext = self.player.name

	def show(self):
		super(PlayerDiplomacyTab, self).show()
		# if diplomacy is changed by any player, change the checkbox
		self.diplomacy.add_diplomacy_status_changed_listener(Callback(self.check_diplomacy_state))

	def hide(self):
		super(PlayerDiplomacyTab, self).hide()
		self.diplomacy.remove_diplomacy_status_changed_listener(Callback(self.check_diplomacy_state))

	def add_ally(self):
		"""
		Callback for setting ally status between local player and tab's player
		"""
		AddAllyPair(self.player, self.local_player).execute(self.player.session)
		# check the correct checkbox
		self.check_diplomacy_state()

	def add_neutral(self):
		"""
		Callback for setting neutral status between local player and tab's player
		"""
		AddNeutralPair(self.player, self.local_player).execute(self.player.session)
		# check the correct checkbox
		self.check_diplomacy_state()

	def add_enemy(self):
		"""
		Callback for setting enemy status between local player and tab's player
		"""
		AddEnemyPair(self.player, self.local_player).execute(self.player.session)
		# check the correct checkbox
		self.check_diplomacy_state()

	def check_diplomacy_state(self):
		"""
		Checks the box with the diplomacy status between local player and selected player
		"""
		# Uncheck all boxes.
		self.widget.distributeData({
			'ally_check_box' : False,
			'neutral_check_box' : False,
			'enemy_check_box' : False})

		# Get the name of the selected box.
		if self.diplomacy.are_allies(self.local_player, self.player):
			state = 'ally'
		elif self.diplomacy.are_neutral(self.local_player, self.player):
			state = 'neutral'
		else:
			state = 'enemy'

		# Check the selected box.
		self.widget.distributeData({'%s_check_box' % state : True})


class DiplomacyTab(TabWidget):
	name = "diplomacy_widget"

	def __init__(self, ingame_gui, world):
		players = list(world.players)
		players.append(world.pirate)

		# filter out local player and pirate (if it's disabled)
		players = [p for p in players if p not in (world.player, None)]

		tabs = [PlayerDiplomacyTab(p) for p in players]

		super(DiplomacyTab, self).__init__(ingame_gui, tabs=tabs, name="diplomacy_widget")

	@classmethod
	def is_useable(cls, world):
		"""Diplomacy only makes sense if there is another player.
		Pirates do not qualify as players: right now they're not interested in diplomacy.
		"""
		return not (len(world.players) == 1 and not world.pirate)

########NEW FILE########
__FILENAME__ = enemybuildingtabs
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.gui.tabs import OverviewTab
from horizons.i18n import _lazy
from horizons.component.namedcomponent import NamedComponent
from horizons.component.storagecomponent import StorageComponent
from horizons.component.tradepostcomponent import TradePostComponent


class EnemyBuildingOverviewTab(OverviewTab):
	widget = 'overview_enemybuilding.xml'

	def init_widget(self):
		super(EnemyBuildingOverviewTab, self).init_widget()
		self.widget.findChild(name="headline").text = self.instance.owner.name

class EnemyWarehouseOverviewTab(OverviewTab):
	widget = 'overview_enemywarehouse.xml'
	helptext = _lazy("Warehouse overview")

	def init_widget(self):
		super(EnemyWarehouseOverviewTab, self).init_widget()
		self.widget.findChild(name="headline").text = self.instance.settlement.get_component(NamedComponent).name

	def refresh(self):
		settlement = self.instance.settlement
		self.widget.findChild(name="headline").text = settlement.get_component(NamedComponent).name

		selling_inventory = self.widget.findChild(name='selling_inventory')
		selling_inventory.init(self.instance.session.db, settlement.get_component(StorageComponent).inventory, settlement.get_component(TradePostComponent).sell_list, True)

		buying_inventory = self.widget.findChild(name='buying_inventory')
		buying_inventory.init(self.instance.session.db, settlement.get_component(StorageComponent).inventory, settlement.get_component(TradePostComponent).buy_list, False)

		super(EnemyWarehouseOverviewTab, self).refresh()

########NEW FILE########
__FILENAME__ = groundunittabs
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.gui.tabs import OverviewTab, TradeTab
from horizons.i18n import _lazy

class GroundUnitOverviewTab(OverviewTab):
	widget = 'overview_war_groundunit.xml'
	helptext = _lazy("Groundunit overview")

	def init_widget(self):
		super(GroundUnitOverviewTab, self).init_widget()
########NEW FILE########
__FILENAME__ = inventorytab
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.gui.tabs.tabinterface import TabInterface
from horizons.i18n import _lazy
from horizons.extscheduler import ExtScheduler
from horizons.component.storagecomponent import StorageComponent

class InventoryTab(TabInterface):
	widget = 'island_inventory.xml'
	icon_path = 'icons/tabwidget/common/inventory'
	helptext = _lazy("Settlement inventory")

	lazy_loading = True

	def __init__(self, instance=None):
		self.instance = instance
		super(InventoryTab, self).__init__()

	def init_widget(self):
		self.widget.child_finder('inventory').init(self.instance.session.db,
		                                           self.instance.get_component(StorageComponent).inventory)

	def refresh(self):
		"""This function is called by the TabWidget to redraw the widget."""
		self.widget.child_finder('inventory').update()

	def show(self):
		# run once now
		ExtScheduler().add_new_object(self.refresh, self, run_in=0, loops=1)
		# and every sec later
		ExtScheduler().add_new_object(self.refresh, self, run_in=1, loops=-1)
		super(InventoryTab, self).show()

	def hide(self):
		ExtScheduler().rem_call(self, self.refresh)
		super(InventoryTab, self).hide()

########NEW FILE########
__FILENAME__ = mainsquaretabs
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from functools import partial

from fife.extensions.pychan.widgets import Label

from horizons.gui.widgets.productionoverview import ProductionOverview
from horizons.gui.tabs import OverviewTab
from horizons.gui.tabs.residentialtabs import setup_tax_slider

from horizons.i18n import _lazy
from horizons.util.python.callback import Callback
from horizons.messaging import UpgradePermissionsChanged, PlayerLevelUpgrade
from horizons.command.uioptions import SetSettlementUpgradePermissions
from horizons.constants import BUILDINGS, TIER
from horizons.component.tradepostcomponent import TradePostComponent
from horizons.component.collectingcomponent import CollectingComponent
from horizons.component.namedcomponent import NamedComponent
from horizons.component.selectablecomponent import SelectableComponent


class MainSquareTab(OverviewTab):
	"""Tab for main square. Refreshes when one building on the settlement changes"""
	@property
	def settlement(self):
		return self.instance.settlement

	def show(self):
		super(MainSquareTab, self).show()
		PlayerLevelUpgrade.subscribe(self.on_player_level_upgrade)
		# update self when a building of the settlement changes.
		for building in self.settlement.buildings:
			if not building.has_change_listener(self._schedule_refresh):
				building.add_change_listener(self._schedule_refresh)

	def hide(self):
		super(MainSquareTab, self).hide()
		PlayerLevelUpgrade.discard(self.on_player_level_upgrade)
		for building in self.settlement.buildings:
			building.discard_change_listener(self._schedule_refresh)

	def on_player_level_upgrade(self, message):
		self.hide()
		self.instance.get_component(SelectableComponent).show_menu(jump_to_tabclass=type(self))

class AccountTab(MainSquareTab):
	"""Display basic income and expenses of a settlement"""
	widget = 'tab_account.xml'
	icon_path = 'icons/tabwidget/warehouse/account'
	helptext = _lazy("Account")

	def init_widget(self):
		super(AccountTab, self).init_widget()
		self.widget.mapEvents({
		  'show_production_overview/mouseClicked': self.show_production_overview,
		})

		# FIXME having to access the WindowManager this way is pretty ugly
		self._windows = self.instance.session.ingame_gui.windows
		self.prod_overview = ProductionOverview(self._windows, self.settlement)

		self.widget.child_finder('headline').text = self.settlement.get_component(NamedComponent).name
		self.widget.child_finder('headline').helptext = _('Click to change the name of your settlement')

		path = 'icons/widgets/cityinfo/settlement_%s' % self.settlement.owner.color.name
		self.widget.child_finder('show_production_overview').path = path

	def show_production_overview(self):
		self._windows.toggle(self.prod_overview)

	def refresh(self):
		super(AccountTab, self).refresh()
		self.refresh_collector_utilization()
		taxes = self.settlement.cumulative_taxes
		running_costs = self.settlement.cumulative_running_costs
		buy_expenses = self.settlement.get_component(TradePostComponent).buy_expenses
		sell_income = self.settlement.get_component(TradePostComponent).sell_income
		balance = self.settlement.balance
		sign = '+' if balance >= 0 else '-'
		self.widget.child_finder('taxes').text = unicode(taxes)
		self.widget.child_finder('running_costs').text = unicode(running_costs)
		self.widget.child_finder('buying').text = unicode(buy_expenses)
		self.widget.child_finder('sale').text = unicode(sell_income)
		self.widget.child_finder('balance').text = unicode(sign+' '+str(abs(balance)))
		self.widget.child_finder('headline').text = self.settlement.get_component(NamedComponent).name
		rename = Callback(self.instance.session.ingame_gui.show_change_name_dialog, self.settlement)
		self.widget.mapEvents({'headline': rename})

	def refresh_collector_utilization(self):
		if self.instance.has_component(CollectingComponent):
			utilization = int(round(self.instance.get_collector_utilization() * 100))
			utilization = unicode(utilization) + u'%'
		else:
			utilization = u'---'
		self.widget.findChild(name="collector_utilization").text = utilization


class MainSquareOverviewTab(AccountTab):
	helptext = _lazy('Main square overview')

	def init_widget(self):
		super(MainSquareOverviewTab, self).init_widget()
		self.widget.child_finder('headline').text = self.settlement.get_component(NamedComponent).name
		self.widget.child_finder('headline').helptext = _('Click to change the name of your settlement')


class MainSquareSettlerLevelTab(MainSquareTab):
	widget = "mainsquare_inhabitants.xml"
	LEVEL = None # overwrite in subclass

	def __init__(self, instance):
		self.max_inhabitants = instance.session.db.get_tier_inhabitants_max(self.__class__.LEVEL)
		self.min_inhabitants = instance.session.db.get_tier_inhabitants_min(self.__class__.LEVEL)
		self.helptext = instance.session.db.get_settler_name(self.__class__.LEVEL)

		icon_path = 'icons/tabwidget/mainsquare/inhabitants{tier}'.format(tier=self.__class__.LEVEL)
		super(MainSquareSettlerLevelTab, self).__init__(instance=instance, icon_path=icon_path)

	def init_widget(self):
		super(MainSquareSettlerLevelTab, self).init_widget()
		slider = self.widget.child_finder('tax_slider')
		val_label = self.widget.child_finder('tax_val_label')
		setup_tax_slider(slider, val_label, self.settlement, self.__class__.LEVEL)
		self.widget.child_finder('tax_val_label').text = unicode(self.settlement.tax_settings[self.__class__.LEVEL])
		self.widget.child_finder('headline').text = _(self.instance.session.db.get_settler_name(self.__class__.LEVEL))

		if self.__class__.LEVEL == TIER.CURRENT_MAX:
			# highest currently playable tier => upgrades not possible
			upgrades_label = self.widget.child_finder('upgrades_lbl')
			upgrades_label.text = _("Upgrade not possible:")
			upgrades_button = self.widget.child_finder('allow_upgrades')
			upgrades_button.set_inactive()
			upgrades_button.helptext = _("This is the highest playable tier for now!")

	@classmethod
	def shown_for(cls, instance):
		return instance.owner.settler_level >= cls.LEVEL

	def show(self):
		super(MainSquareSettlerLevelTab, self).show()
		UpgradePermissionsChanged.subscribe(self.refresh_via_message, sender=self.settlement)

	def hide(self):
		super(MainSquareSettlerLevelTab, self).hide()
		UpgradePermissionsChanged.discard(self.refresh_via_message, sender=self.settlement)

	def _get_last_tax_paid(self):
		houses = self.settlement.buildings_by_id[BUILDINGS.RESIDENTIAL]
		return sum([building.last_tax_payed for building in houses if building.level == self.__class__.LEVEL])

	def _get_resident_counts(self):
		result = {}
		for building in self.settlement.buildings_by_id[BUILDINGS.RESIDENTIAL]:
			if building.level == self.__class__.LEVEL:
				if building.inhabitants not in result:
					result[building.inhabitants] = 0
				result[building.inhabitants] += 1
		return result

	def refresh_via_message(self, message):
		# message bus requires parameter, refresh() doesn't allow parameter
		# TODO: find general solution
		self.refresh()

	def refresh(self):
		self.widget.mapEvents({
			'allow_upgrades/mouseClicked' : self.toggle_upgrades,
		})

		# refresh taxes
		self.widget.child_finder('taxes').text = unicode(self._get_last_tax_paid())

		# refresh upgrade permissions
		upgrades_button = self.widget.child_finder('allow_upgrades')
		# The currently highest playable tier cannot allow upgrades.
		if self.__class__.LEVEL < TIER.CURRENT_MAX:
			if self.settlement.upgrade_permissions[self.__class__.LEVEL]:
				upgrades_button.set_active()
				upgrades_button.helptext = _("Don't allow upgrades")
			else:
				upgrades_button.set_inactive()
				upgrades_button.helptext = _('Allow upgrades')

		# refresh residents per house info
		resident_counts = self._get_resident_counts()
		houses = 0
		residents = 0
		container = self.widget.child_finder('residents_per_house_table')
		space_per_label = container.size[0] // 6
		for number in xrange(self.min_inhabitants, self.max_inhabitants + 1):
			column = number - (self.min_inhabitants - 1 if self.min_inhabitants > 0 else 0)
			house_count = resident_counts.get(number, 0)
			houses += house_count
			residents += house_count * number
			position_x = (space_per_label * (column - 1)) + 10
			if not container.findChild(name="resident_"+str(column)):
				label = Label(name="resident_"+str(column), position=(position_x, 0), text=unicode(number))
				container.addChild(label)
				count_label = Label(name="resident_count_"+str(column), position=(position_x - 1, 20), text=unicode(house_count))
				container.addChild(count_label)
			else:
				container.findChild(name="resident_"+str(column)).text = unicode(number)
				container.findChild(name="resident_count_"+str(column)).text = unicode(house_count)

		sad = self.instance.session.db.get_lower_happiness_limit()
		happy = self.instance.session.db.get_upper_happiness_limit()
		inhabitants = partial(self.settlement.get_residentials_of_lvl_for_happiness,
		                      self.__class__.LEVEL)
		self.widget.child_finder('sad_amount').text = unicode(inhabitants(max_happiness=sad))
		self.widget.child_finder('avg_amount').text = unicode(inhabitants(sad, happy))
		self.widget.child_finder('happy_amount').text = unicode(inhabitants(happy))

		# refresh the summary
		self.widget.child_finder('house_count').text = unicode(houses)
		self.widget.child_finder('resident_count').text = unicode(residents)

		self.widget.adaptLayout()
		super(MainSquareSettlerLevelTab, self).refresh()

	def toggle_upgrades(self):
		SetSettlementUpgradePermissions(self.settlement, self.__class__.LEVEL, not self.settlement.upgrade_permissions[self.__class__.LEVEL]).execute(self.settlement.session)


class MainSquareSailorsTab(MainSquareSettlerLevelTab):
	LEVEL = TIER.SAILORS

class MainSquarePioneersTab(MainSquareSettlerLevelTab):
	LEVEL = TIER.PIONEERS

class MainSquareSettlersTab(MainSquareSettlerLevelTab):
	LEVEL = TIER.SETTLERS

class MainSquareCitizensTab(MainSquareSettlerLevelTab):
	LEVEL = TIER.CITIZENS

########NEW FILE########
__FILENAME__ = overviewtab
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.gui.tabs.tabinterface import TabInterface
from horizons.i18n import _lazy
from horizons.component.namedcomponent import NamedComponent


class OverviewTab(TabInterface):
	widget = 'overviewtab.xml'
	icon_path = 'icons/tabwidget/common/building_overview'
	helptext = _lazy("Overview")

	has_stance = False

	def __init__(self, instance, widget=None, icon_path=None):
		self.instance = instance
		super(OverviewTab, self).__init__(widget=widget, icon_path=icon_path)

	def init_widget(self):
		# set player emblem
		if self.widget.child_finder('player_emblem'):
			if self.instance.owner is not None:
				player_color = self.instance.owner.color.name
			else:
				player_color = 'no_player'
			emblem = 'content/gui/images/tabwidget/emblems/emblem_%s.png'
			self.widget.child_finder('player_emblem').image = emblem % player_color

		if self.__class__.has_stance:
			self.init_stance_widget()

	def refresh(self):
		if (hasattr(self.instance, 'name') or self.instance.has_component(NamedComponent)) and self.widget.child_finder('name'):
			name_widget = self.widget.child_finder('name')
			# Named objects can't be translated.
			if self.instance.has_component(NamedComponent):
				name_widget.text = self.instance.get_component(NamedComponent).name
			else:
				name_widget.text = _(self.instance.name)

		if hasattr(self.instance, 'running_costs') and \
		   self.widget.child_finder('running_costs'):
			self.widget.child_finder('running_costs').text = \
			    unicode(self.instance.running_costs)

		self.widget.adaptLayout()

	def show(self):
		super(OverviewTab, self).show()
		if not self.instance.has_change_listener(self.refresh):
			self.instance.add_change_listener(self.refresh)
		if not self.instance.has_remove_listener(self.on_instance_removed):
			self.instance.add_remove_listener(self.on_instance_removed)
		if hasattr(self.instance, 'settlement') and \
		   self.instance.settlement is not None and \
		   not self.instance.settlement.has_change_listener(self._schedule_refresh):
			# listen for settlement name changes displayed as tab headlines
			self.instance.settlement.add_change_listener(self._schedule_refresh)

	def hide(self):
		super(OverviewTab, self).hide()
		if self.instance is not None:
			self.instance.discard_change_listener(self.refresh)
			self.instance.discard_remove_listener(self.on_instance_removed)
		if hasattr(self.instance, 'settlement') and self.instance.settlement is not None:
			self.instance.settlement.discard_change_listener(self._schedule_refresh)

	def on_instance_removed(self):
		self.on_remove()
		self.instance = None

	def init_stance_widget(self):
		"""Call this for tabs with stances."""
		stance_widget = self.widget.findChild(name='stance')
		stance_widget.init(self.instance)
		self.add_remove_listener(stance_widget.remove)


class GroundUnitOverviewTab(OverviewTab):
	widget = 'overview_groundunit.xml'
	helptext = _lazy("Unit overview")

	has_stance = True

	def init_widget(self):
		super(GroundUnitOverviewTab, self).init_widget()
		health_widget = self.widget.findChild(name='health')
		health_widget.init(self.instance)
		self.add_remove_listener(health_widget.remove)
		weapon_storage_widget = self.widget.findChild(name='weapon_storage')
		weapon_storage_widget.init(self.instance)
		self.add_remove_listener(weapon_storage_widget.remove)


class GenericOverviewTab(OverviewTab):
	"""Name and running costs."""
	widget = 'overview_generic.xml'

########NEW FILE########
__FILENAME__ = productiontabs
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import operator
import weakref

from fife.extensions.pychan.widgets import Icon, Label

from horizons.command.production import ToggleActive
from horizons.command.building import Tear
from horizons.constants import GAME_SPEED, PRODUCTION
from horizons.gui.tabs import OverviewTab
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.imagefillstatusbutton import ImageFillStatusButton
from horizons.i18n import _lazy
from horizons.scheduler import Scheduler
from horizons.util.python.callback import Callback
from horizons.util.pychananimation import PychanAnimation
from horizons.component.storagecomponent import StorageComponent
from horizons.world.production.producer import Producer


class ProductionOverviewTab(OverviewTab):
	widget = 'overview_productionbuilding.xml'
	helptext = _lazy("Production overview")
	production_line_gui_xml = 'overview_productionline.xml'

	ACTIVE_PRODUCTION_ANIM_DIR = "content/gui/images/animations/cogs/large"
	BUTTON_BACKGROUND = "content/gui/images/buttons/msg_button.png"
	ARROW_TOP = "content/gui/icons/templates/production/production_arrow_top.png"
	ARROW_MID = "content/gui/icons/templates/production/production_arrow_start.png"
	ARROW_BOTTOM = "content/gui/icons/templates/production/production_arrow_bottom.png"
	ARROW_CONNECT_UP = "content/gui/icons/templates/production/production_arrow_connect_up.png"
	ARROW_CONNECT_DOWN = "content/gui/icons/templates/production/production_arrow_connect_down.png"

	def  __init__(self, instance):
		self._animations = []
		super(ProductionOverviewTab, self).__init__(instance=instance)

	def get_displayed_productions(self):
		"""List all possible productions of a buildings sorted by production line id.
		Overwritten in some child classes (e.g. farm tab).
		"""
		productions = self.instance.get_component(Producer).get_productions()
		return sorted(productions, key=operator.methodcaller('get_production_line_id'))

	def refresh(self):
		"""This function is called by the TabWidget to redraw the widget."""
		self._refresh_utilization()

		# remove old production line data
		parent_container = self.widget.child_finder('production_lines')
		while parent_container.children:
			child = parent_container.children[-1]
			if hasattr(child, "anim"):
				child.anim.stop()
				del child.anim
			parent_container.removeChild(child)

		# create a container for each production
		# sort by production line id to have a consistent (basically arbitrary) order
		for production in self.get_displayed_productions():
			# we need to be notified of small production changes
			# that aren't passed through the instance
			production.add_change_listener(self._schedule_refresh, no_duplicates=True)

			gui = load_uh_widget(self.production_line_gui_xml)
			# fill in values to gui reflecting the current game state
			container = gui.findChild(name="production_line_container")
			self._set_resource_amounts(container, production)

			centered_container = container.findChild(name='centered_production_icons')
			self._connect_input_res(centered_container, container, production)

			if production.is_paused():
				centered_container.removeChild( centered_container.findChild(name="toggle_active_active") )
				toggle_icon = centered_container.findChild(name="toggle_active_inactive")
				toggle_icon.name = "toggle_active"
			else:
				centered_container.removeChild( centered_container.findChild(name="toggle_active_inactive") )
				toggle_icon = centered_container.findChild(name="toggle_active_active")
				toggle_icon.name = "toggle_active"

				if production.get_state() == PRODUCTION.STATES.producing:
					bg = Icon(image=self.__class__.BUTTON_BACKGROUND)
					bg.position = toggle_icon.position
					centered_container.addChild(bg)
					centered_container.removeChild(toggle_icon) # fix z-ordering
					centered_container.addChild(toggle_icon)
					anim = PychanAnimation(toggle_icon, self.__class__.ACTIVE_PRODUCTION_ANIM_DIR)
					centered_container.anim = anim
					anim.start(1.0/12, -1) # always start anew, people won't notice
					self._animations.append( weakref.ref( anim ) )

			# fill it with input and output resources
			in_res_container = container.findChild(name="input_res")
			self._add_resource_icons(in_res_container, production.get_consumed_resources(), marker=True)
			out_res_container = container.findChild(name="output_res")
			self._add_resource_icons(out_res_container, production.get_produced_resources())

			# active toggle_active button
			toggle_active = ToggleActive(self.instance.get_component(Producer), production)
			centered_container.mapEvents({
				'toggle_active': Callback(toggle_active.execute, self.instance.session)
			})
			# NOTE: this command causes a refresh, so we needn't change the toggle_active-button-image
			parent_container.addChild(container)
		super(ProductionOverviewTab, self).refresh()

	def _connect_input_res(self, centered_container, container, production):
		"""Draws incoming arrows for production line container."""
		input_amount = len(production.get_consumed_resources())
		if input_amount == 0:
			# Do not draw input arrows if there is no input
			return

		# center the production line
		icon_height = ImageFillStatusButton.CELL_SIZE[1] + ImageFillStatusButton.PADDING
		center_y = (icon_height // 2) * (input_amount - 1)
		centered_container.position = (0, center_y)

		if input_amount % 2:
			# Add center arrow for 1, 3, 5, ... but not 2, 4, ...
			mid_arrow = Icon(image=self.__class__.ARROW_MID)
			mid_arrow.position = (58, 17 + center_y)
			container.insertChild(mid_arrow, 0)

		for res in xrange(input_amount // 2):
			# --\                      <= placed for res = 1
			# --\| <= place connector  <= placed for res = 0
			# ---O-->                  <= placed above (mid_arrow)
			# --/| <= place connector  <= placed for res = 0
			# --/                      <= placed for res = 1
			offset = -17 + (icon_height // 2) * (2 * res + (input_amount % 2) + 1)

			top_arrow = Icon(image=self.__class__.ARROW_TOP)
			top_arrow.position = (58, center_y - offset)
			container.insertChild(top_arrow, 0)

			bottom_arrow = Icon(image=self.__class__.ARROW_BOTTOM)
			bottom_arrow.position = (58, center_y + offset)
			container.insertChild(bottom_arrow, 0)

			# Place a connector image (the | in above sketch) that vertically connects
			# the input resource arrows. We need those if the production line has more
			# than three input resources. Connectors are placed in the inner loop parts.
			place_connectors = (1 + 2 * res) < (input_amount // 2)
			if place_connectors:
				# the connector downwards connects top_arrows
				down_connector = Icon(image=self.__class__.ARROW_CONNECT_DOWN)
				down_connector.position = (98, center_y - offset)
				container.insertChild(down_connector, 0)
				# the connector upwards connects up_arrows
				up_connector = Icon(image=self.__class__.ARROW_CONNECT_UP)
				up_connector.position = (98, center_y + offset)
				container.insertChild(up_connector, 0)

	def _set_resource_amounts(self, container, production):
		for res, amount in production.get_consumed_resources().iteritems():
			# consumed resources are negative!
			label = Label(text=unicode(-amount), margins=(0, 15))
			container.findChild(name='input_box').addChild(label)

		for res, amount in production.get_produced_resources().iteritems():
			label = Label(text=unicode(amount).rjust(2), margins=(0, 15))
			container.findChild(name='output_box').addChild(label)

	def destruct_building(self):
		self.instance.session.ingame_gui.hide_menu()
		Tear(self.instance).execute(self.instance.session)

	def _refresh_utilization(self):
		utilization = 0
		if self.instance.has_component(Producer):
			utilization = int(round(self.instance.get_component(Producer).capacity_utilization * 100))
		self.widget.child_finder('capacity_utilization').text = unicode(utilization) + u'%'

	def _add_resource_icons(self, container, resources, marker=False):
		calculate_position = lambda amount: (amount * 100) // inventory.get_limit(res)
		for res in resources:
			inventory = self.instance.get_component(StorageComponent).inventory
			filled = calculate_position(inventory[res])
			marker_level = calculate_position(-resources[res]) if marker else 0
			image_button = ImageFillStatusButton.init_for_res(self.instance.session.db, res,
					inventory[res], filled, marker=marker_level, use_inactive_icon=False, uncached=True)
			container.addChild(image_button)

	def show(self):
		super(ProductionOverviewTab, self).show()
		Scheduler().add_new_object(Callback(self._refresh_utilization),
		                           self, run_in=GAME_SPEED.TICKS_PER_SECOND, loops=-1)

	def hide(self):
		super(ProductionOverviewTab, self).hide()
		self._cleanup()

	def on_instance_removed(self):
		self._cleanup()
		super(ProductionOverviewTab, self).on_instance_removed()

	def _cleanup(self):
		Scheduler().rem_all_classinst_calls(self)
		for production in self.get_displayed_productions():
			production.discard_change_listener(self._schedule_refresh)
		for anim in self._animations:
			if anim():
				anim().stop()
		self._animations = []


class SmallProductionOverviewTab(ProductionOverviewTab):
	"""Only display productions for which we have a related 'field' in range.
	Requires the building class using this tab to implement get_providers().
	"""
	widget = 'overview_farm.xml'
	helptext = _lazy("Production overview")
	production_line_gui_xml = "overview_farmproductionline.xml"

	# the farm uses small buttons
	ACTIVE_PRODUCTION_ANIM_DIR = "content/gui/images/animations/cogs/small"
	BUTTON_BACKGROUND = "content/gui/images/buttons/msg_button_small.png"

	def get_displayed_productions(self):
		possible_res = set(res for field in self.instance.get_providers()
		                       for res in field.provided_resources)
		all_farm_productions = self.instance.get_component(Producer).get_productions()
		productions = set([p for p in all_farm_productions
		                     for res in p.get_consumed_resources().keys()
		                   if res in possible_res])
		return sorted(productions, key=operator.methodcaller('get_production_line_id'))

########NEW FILE########
__FILENAME__ = residentialtabs
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.python.callback import Callback
from horizons.util.loaders.actionsetloader import ActionSetLoader
from horizons.constants import SETTLER
from horizons.command.uioptions import SetTaxSetting
from horizons.gui.tabs import OverviewTab
from horizons.gui.util import create_resource_icon, get_happiness_icon_and_helptext
from horizons.i18n import _lazy
from horizons.component.namedcomponent import NamedComponent
from horizons.messaging import SettlerUpdate


class SettlerOverviewTab(OverviewTab):
	widget = 'overview_settler.xml'
	helptext = _lazy("Settler overview")

	def init_widget(self):
		super(SettlerOverviewTab, self).init_widget()
		name = self.instance.settlement.get_component(NamedComponent).name
		self.widget.findChild(name="headline").text = name
		setup_tax_slider(self.widget.child_finder('tax_slider'),
		                 self.widget.child_finder('tax_val_label'),
		                 self.instance.settlement,
		                 self.instance.level)

		taxes = self.instance.settlement.tax_settings[self.instance.level]
		self.widget.child_finder('tax_val_label').text = unicode(taxes)
		action_set = ActionSetLoader.get_sets()[self.instance._action_set_id]
		action_gfx = action_set.items()[0][1]
		image = action_gfx[45].keys()[0]
		self.widget.findChild(name="building_image").image = image

	def on_settler_level_change(self, message):
		assert isinstance(message, SettlerUpdate)
		setup_tax_slider(self.widget.child_finder('tax_slider'),
		                 self.widget.child_finder('tax_val_label'),
		                 self.instance.settlement,
		                 message.level)
		taxes = self.instance.settlement.tax_settings[self.instance.level]
		self.widget.child_finder('tax_val_label').text = unicode(taxes)
		imgs = ActionSetLoader.get_sets()[self.instance._action_set_id].items()[0][1]
		self.widget.findChild(name="building_image").image = imgs[45].keys()[0]

	def show(self):
		super(SettlerOverviewTab, self).show()
		SettlerUpdate.subscribe(self.on_settler_level_change, sender=self.instance)

	def hide(self):
		SettlerUpdate.discard(self.on_settler_level_change, sender=self.instance)
		super(SettlerOverviewTab, self).hide()

	def refresh(self):
		image, helptext = get_happiness_icon_and_helptext(self.instance.happiness, self.instance.session)
		self.widget.child_finder('happiness_label').image = image
		self.widget.child_finder('happiness_label').helptext = helptext
		self.widget.child_finder('happiness').progress = self.instance.happiness
		self.widget.child_finder('inhabitants').text = u"%s/%s" % (
		                                               self.instance.inhabitants,
		                                               self.instance.inhabitants_max)
		self.widget.child_finder('taxes').text = unicode(self.instance.last_tax_payed)
		self.update_consumed_res()
		name = self.instance.settlement.get_component(NamedComponent).name
		self.widget.findChild(name="headline").text = name
		events = {
				'headline': Callback(self.instance.session.ingame_gui.show_change_name_dialog,
				                     self.instance.settlement)
		         }
		self.widget.mapEvents(events)
		super(SettlerOverviewTab, self).refresh()

	def update_consumed_res(self):
		"""Updates the container that displays the needed resources of the settler"""
		container = self.widget.findChild(name="needed_res")
		# remove icons from the container
		container.removeAllChildren()

		# create new ones
		resources = self.instance.get_currently_not_consumed_resources()
		for res in resources:
			icon = create_resource_icon(res, self.instance.session.db)
			icon.max_size = icon.min_size = icon.size = (32, 32)
			container.addChild(icon)

		container.adaptLayout()

def setup_tax_slider(slider, val_label, settlement, level):
	"""Set up a slider to work as tax slider"""
	slider.scale_start = SETTLER.TAX_SETTINGS_MIN
	slider.scale_end = SETTLER.TAX_SETTINGS_MAX
	slider.step_length = SETTLER.TAX_SETTINGS_STEP
	slider.value = settlement.tax_settings[level]
	def on_slider_change():
		val_label.text = unicode(slider.value)
		if settlement.tax_settings[level] != slider.value:
			SetTaxSetting(settlement, level, slider.value).execute(settlement.session)
	slider.capture(on_slider_change)

########NEW FILE########
__FILENAME__ = selectmultitab
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
from collections import defaultdict

from fife.extensions.pychan.widgets import Icon

from horizons.util.python.callback import Callback
from horizons.gui.tabs.tabinterface import TabInterface
from horizons.gui.util import load_uh_widget
from horizons.i18n import _lazy
from horizons.scheduler import Scheduler
from horizons.command.unit import SetStance
from horizons.component.healthcomponent import HealthComponent
from horizons.component.stancecomponent import DEFAULT_STANCES
from horizons.component.selectablecomponent import SelectableComponent
from horizons.constants import UNITS
from horizons.util.loaders.actionsetloader import ActionSetLoader


class SelectMultiTab(TabInterface):
	"""
	Tab shown when multiple units are selected
	"""
	widget = 'overview_select_multi.xml'
	icon_path = 'icons/tabwidget/common/inventory'
	helptext = _lazy("Selected Units")

	max_row_entry_number = 3
	max_column_entry_number = 4

	def __init__(self, selected_instances=None):
		self.selected_instances = selected_instances or []

		# keep track of units that have stance
		self.stance_unit_number = 0
		# keep local track of selected instances
		self.instances = []
		# keep track of number of instances per type
		self.type_number = defaultdict(int)

		for i in self.selected_instances:
			if hasattr(i, 'stance'):
				self.stance_unit_number += 1
			self.instances.append(i)
			if not i.has_remove_listener(Callback(self.on_instance_removed, i)):
				i.add_remove_listener(Callback(self.on_instance_removed, i))
			self.type_number[i.id] += 1

		self._scheduled_refresh = False

		super(SelectMultiTab, self).__init__()

	def init_widget(self):
		if self.stance_unit_number != 0:
			self.show_stance_widget()

		self.draw_selected_units_widget()

	def add_entry(self, entry):
		if self.column_number > self.max_column_entry_number - 1:
			self.column_number = 0
			self.row_number += 1
		if self.row_number >= 3:
			# TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
			# This crashes when more than 2 rows are needed.
			# There just aren't any hboxes in the xml.
			# TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
			self.row_number = 2
			return
		self.column_number += 1
		self.widget.findChild(name="hbox_%s" % self.row_number).addChild(entry.widget)
		self.entries.append(entry)

	def draw_selected_units_widget(self):
		self.entries = []
		self.row_number = 0
		self.column_number = 0
		# if only one type of units is selected draw individual widgets for selected units
		if len(self.type_number) == 1:
			for instance in self.instances:
				self.add_entry(UnitEntry([instance], False))
		else:
			entry_instances = defaultdict(list)
			for instance in self.instances:
				entry_instances[instance.id].append(instance)
			for instances in entry_instances.values():
				self.add_entry(UnitEntry(instances))

	def hide_selected_units_widget(self):
		for entry in self.entries:
			entry.remove()
		for i in xrange(0, self.max_row_entry_number):
			self.widget.findChild(name="hbox_%s" % i).removeAllChildren()

	def schedule_unit_widget_refresh(self):
		if not self._scheduled_refresh:
			self._scheduled_refresh = True
			Scheduler().add_new_object(self.refresh_unit_widget, self, run_in=0)

	def refresh_unit_widget(self):
		if self.instances:
			self._scheduled_refresh = False
			self.hide_selected_units_widget()
			self.draw_selected_units_widget()
			self.toggle_stance()
			self.widget.adaptLayout()
		else:
			# all units were destroyed
			self.hide_selected_units_widget()

	def on_instance_removed(self, instance):
		if hasattr(instance, 'stance'):
			self.stance_unit_number -= 1

		self.instances.remove(instance)
		instance.discard_remove_listener(Callback(self.on_instance_removed, instance))

		if self.widget.isVisible():
			if len(self.instances) < 2:
				# hide the multi-selection tab
				instance.session.ingame_gui.hide_menu()
				# if one unit remains, show its menu
				if len(self.instances) == 1:
					self.instances[0].get_component(SelectableComponent).show_menu()
				return

		self.type_number[instance.id] -= 1
		if self.type_number[instance.id] == 0:
			del self.type_number[instance.id]
			# if one type of units dies, schedule refresh
			self.schedule_unit_widget_refresh()

		# if one type of units is left, any removal would mean refresh
		if len(self.type_number) == 1:
			self.schedule_unit_widget_refresh()

		if self.stance_unit_number == 0:
			self.hide_stance_widget()

	def show_stance_widget(self):
		stance_widget = load_uh_widget('stancewidget.xml')
		self.widget.findChild(name='stance').addChild(stance_widget)
		self.toggle_stance()
		events = dict((i.NAME, Callback(self.set_stance, i)) for i in DEFAULT_STANCES)
		self.widget.mapEvents(events)

	def hide_stance_widget(self):
		Scheduler().rem_all_classinst_calls(self)
		self.widget.findChild(name='stance').removeAllChildren()

	def set_stance(self, stance):
		for i in self.instances:
			if hasattr(i, 'stance'):
				SetStance(i, stance).execute(i.session)
		self.toggle_stance()

	def toggle_stance(self):
		"""
		Toggles the stance. Assumes at least one stance unit is selected.
		"""
		for stance in DEFAULT_STANCES:
			self.widget.findChild(name=stance.NAME).set_inactive()
		# get first unit stance
		stance_units = [u for u in self.instances if hasattr(u, "stance")]
		stance = stance_units[0].stance
		for unit in stance_units[1:]:
			if unit.stance != stance:
				# not all have the same stance, toggle none
				return
		self.widget.findChild(name=stance.NAME).set_active()


class UnitEntry(object):
	def __init__(self, instances, show_number=True):
		self.log = logging.getLogger("gui.tabs")
		self.instances = instances
		self.widget = load_uh_widget("unit_entry_widget.xml")
		# get the icon of the first instance
		i = instances[0]
		if i.id < UNITS.DIFFERENCE_BUILDING_UNIT_ID:
			# A building. Generate dynamic thumbnail from its action set.
			imgs = ActionSetLoader.get_sets()[i._action_set_id].items()[0][1]
			thumbnail = imgs[45].keys()[0]
		else:
			# Units use manually created thumbnails because those need to be
			# precise and recognizable in combat situations.
			thumbnail = self.get_unit_thumbnail(i.id)
		self.widget.findChild(name="unit_button").up_image = thumbnail
		if show_number:
			self.widget.findChild(name="instance_number").text = unicode(len(self.instances))
		# only two callbacks are needed so drop unwanted changelistener inheritance
		for i in instances:
			if not i.has_remove_listener(Callback(self.on_instance_removed, i)):
				i.add_remove_listener(Callback(self.on_instance_removed, i))
			health_component = i.get_component(HealthComponent)
			if not health_component.has_damage_dealt_listener(self.draw_health):
				health_component.add_damage_dealt_listener(self.draw_health)
		self.draw_health()

	def get_unit_thumbnail(self, unit_id):
		"""Returns path of the thumbnail icon for unit with id *unit_id*."""
		template = "content/gui/icons/thumbnails/{unit_id}.png"
		path = template.format(unit_id=unit_id)
		try:
			Icon(image=path)
		except RuntimeError:
			self.log.warning('Missing unit thumbnail {0}'.format(path))
			path = template.format(unit_id='unknown_unit')
		return path

	def on_instance_removed(self, instance):
		self.instances.remove(instance)
		instance.discard_remove_listener(Callback(self.on_instance_removed, instance))
		health_component = instance.get_component(HealthComponent)
		if health_component.has_damage_dealt_listener(self.draw_health):
			health_component.remove_damage_dealt_listener(self.draw_health)

		if self.instances:
			self.widget.findChild(name="instance_number").text = unicode(len(self.instances))

	def draw_health(self, caller=None):
		health = 0
		max_health = 0
		for instance in self.instances:
			health_component = instance.get_component(HealthComponent)
			health += health_component.health
			max_health += health_component.max_health
		health_ratio = float(health) / max_health
		container = self.widget.findChild(name="main_container")
		health_bar = self.widget.findChild(name="health")
		health_bar.position = (health_bar.position[0], int((1 - health_ratio) * container.height))

	def remove(self):
		"""
		Clears all the listeners in instances
		"""
		for instance in self.instances:
			instance.discard_remove_listener(Callback(self.on_instance_removed, instance))
			health_component = instance.get_component(HealthComponent)
			if health_component.has_damage_dealt_listener(self.draw_health):
				health_component.remove_damage_dealt_listener(self.draw_health)

########NEW FILE########
__FILENAME__ = shiptabs
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import weakref

from horizons.constants import BUILDINGS, WEAPONS
from horizons.command.uioptions import EquipWeaponFromInventory, UnequipWeaponToInventory
from horizons.entities import Entities
from horizons.gui.tabs import OverviewTab, TradeTab
from horizons.gui.widgets.routeconfig import RouteConfig
from horizons.i18n import _lazy
from horizons.util.python.callback import Callback
from horizons.component.storagecomponent import StorageComponent
from horizons.component.selectablecomponent import SelectableComponent


class ShipOverviewTab(OverviewTab):
	widget = 'overview_trade_ship.xml'
	icon_path = 'icons/tabwidget/ship/ship_inv'
	helptext = _lazy("Ship overview")

	def init_widget(self):
		super(ShipOverviewTab, self).init_widget()
		ship_inv = self.instance.get_component(StorageComponent).inventory
		self.widget.child_finder('inventory').init(self.instance.session.db, ship_inv)

		# FIXME having to access the WindowManager this way is pretty ugly
		self._windows = self.instance.session.ingame_gui.windows
		self.route_menu = RouteConfig(self._windows, self.instance)

	def _configure_route(self):
		self._windows.toggle(self.route_menu)

	def _refresh_found_settlement_button(self, events):
		island_without_player_settlement_found = False
		helptext = _("The ship needs to be close to an island to found a settlement.")
		for island in self.instance.session.world.get_islands_in_radius(self.instance.position, self.instance.radius):
			if not any(settlement.owner.is_local_player for settlement in island.settlements):
				island_without_player_settlement_found = True
			else:
				helptext = _("You already have a settlement on this island.")

		if island_without_player_settlement_found:
			events['found_settlement'] = Callback(self.instance.session.ingame_gui._build,
			                                      BUILDINGS.WAREHOUSE,
			                                      weakref.ref(self.instance) )
			self.widget.child_finder('found_settlement_bg').set_active()
			self.widget.child_finder('found_settlement').set_active()
			self.widget.child_finder('found_settlement').helptext = _("Build settlement")
		else:
			events['found_settlement'] = None
			self.widget.child_finder('found_settlement_bg').set_inactive()
			self.widget.child_finder('found_settlement').set_inactive()
			self.widget.child_finder('found_settlement').helptext = helptext

		cb = Callback( self.instance.session.ingame_gui.resource_overview.set_construction_mode,
		               self.instance,
		               Entities.buildings[BUILDINGS.WAREHOUSE].costs)
		events['found_settlement/mouseEntered'] = cb

		cb1 = Callback(self.instance.session.ingame_gui.resource_overview.close_construction_mode)
		cb2 = Callback(self.widget.child_finder('found_settlement').hide_tooltip)
		#TODO the tooltip should actually hide on its own. Ticket #1096
		cb = Callback.ChainedCallbacks(cb1, cb2)
		events['found_settlement/mouseExited'] = cb

	def _refresh_trade_button(self, events):
		warehouses = self.instance.get_tradeable_warehouses()

		if warehouses:
			if warehouses[0].owner is self.instance.owner:
				helptext = _('Load/Unload')
			else:
				helptext = _('Buy/Sell')
			events['trade'] = Callback(self.instance.get_component(SelectableComponent).show_menu, TradeTab)
			self.widget.findChild(name='trade_bg').set_active()
			self.widget.findChild(name='trade').set_active()
			self.widget.findChild(name='trade').helptext = helptext
		else:
			events['trade'] = None
			self.widget.findChild(name='trade_bg').set_inactive()
			self.widget.findChild(name='trade').set_inactive()
			self.widget.findChild(name='trade').helptext = _('Too far from the nearest tradeable warehouse')

	def _refresh_combat(self): # no combat
		def click_on_cannons(button):
			button.button.capture(Callback(
			  self.instance.session.ingame_gui.open_popup,
			  _("Cannot equip trade ship with weapons"),
			  _("It is not possible to equip a trade ship with weapons.")
			))
		self.widget.findChild(name='inventory').apply_to_buttons(click_on_cannons, lambda b: b.res_id == WEAPONS.CANNON)

	def refresh(self):
		# show rename when you click on name
		events = {
			'name': Callback(self.instance.session.ingame_gui.show_change_name_dialog, self.instance),
			'configure_route/mouseClicked': Callback(self._configure_route)
		}

		self._refresh_found_settlement_button(events)
		self._refresh_trade_button(events)
		self.widget.mapEvents(events)

		self.widget.child_finder('inventory').update()
		self._refresh_combat()
		super(ShipOverviewTab, self).refresh()


class FightingShipOverviewTab(ShipOverviewTab):
	widget = 'overview_war_ship.xml'
	# TODO why is this here:
	icon_path = 'icons/tabwidget/ship/ship_inv'

	has_stance = True

	def init_widget(self):
		super(FightingShipOverviewTab, self).init_widget()
		# Create weapon inventory, needed only in gui for inventory widget.
		self.weapon_inventory = self.instance.get_weapon_storage()
		self.widget.findChild(name='weapon_inventory').init(self.instance.session.db, self.weapon_inventory)

	def _refresh_combat(self):
		def apply_equip(button):
			button.button.helptext = _("Equip weapon")
			button.button.capture(Callback(self.equip_weapon, button.res_id))

		def apply_unequip(button):
			button.button.helptext = _("Unequip weapon")
			button.button.capture(Callback(self.unequip_weapon, button.res_id))

		self.widget.findChild(name='weapon_inventory').apply_to_buttons(apply_unequip, lambda b: b.res_id == WEAPONS.CANNON)
		self.widget.findChild(name='inventory').apply_to_buttons(apply_equip, lambda b: b.res_id == WEAPONS.CANNON)

	def equip_weapon(self, weapon_id):
		if EquipWeaponFromInventory(self.instance, weapon_id, 1).execute(self.instance.session) == 0:
			self.weapon_inventory.alter(weapon_id, 1)
		self.widget.child_finder('weapon_inventory').update()
		self.refresh()

	def unequip_weapon(self, weapon_id):
		if UnequipWeaponToInventory(self.instance, weapon_id, 1).execute(self.instance.session) == 0:
			self.weapon_inventory.alter(weapon_id, -1)
		self.widget.child_finder('weapon_inventory').update()
		self.refresh()

	def on_instance_removed(self):
		self.weapon_inventory = None
		super(FightingShipOverviewTab, self).on_instance_removed()

class TraderShipOverviewTab(OverviewTab):
	widget = 'overview_tradership.xml'
	icon_path = 'icons/tabwidget/ship/ship_inv'
	helptext = _lazy("Ship overview")

class EnemyShipOverviewTab(OverviewTab):
	widget = 'overview_enemyunit.xml'
	icon_path = 'icons/tabwidget/ship/ship_inv'
	helptext = _lazy("Ship overview")

	def init_widget(self):
		super(EnemyShipOverviewTab, self).init_widget()
		self.widget.findChild(name="headline").text = self.instance.owner.name

########NEW FILE########
__FILENAME__ = tabinterface
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.gui.util import load_uh_widget
from horizons.util.changelistener import metaChangeListenerDecorator
from horizons.util.pychanchildfinder import PychanChildFinder
from horizons.util.python.callback import Callback
from horizons.extscheduler import ExtScheduler

@metaChangeListenerDecorator('remove')
class TabInterface(object):
	"""
	The TabInterface should be used by all classes that represent Tabs for the
	TabWidget.

	By default the code will the widget from a file given by `widget`. If you
	want to run code after the widget has been loaded, override `init_widget`.
	To handle widget loading yourself, override `get_widget` and return the new
	widget.
	In both cases the widget is accessible at `self.widget`.

	If you want to override the TabButton image used for the tab, you also have
	to set the button_image_{up,down,hover} variables.

	Use the refresh() method to implement any redrawing of the widget. The
	TabWidget will call this method based on callbacks. If you set any callbacks
	yourself, make sure you get them removed when the widget is deleted.

	@param widget: Filename of widget to load.
	@param icon_path: Where to look for ImageButton icons. Note: this is a `path` attribute!
	"""

	# Whether to load the tab only when it's shown.
	# If True, self.widget will only be valid after _lazy_loading_init, which
	# is guaranteed to be executed before show(), refresh() and the like.
	# Usually, you will want to overwrite _lazy_loading_init and call the super impl as first step.
	lazy_loading = False

	# Override these in your subclass either as class attribute, or by passing it
	# to the constructor. The value of the constructor has preference over the
	# class attribute.
	widget = None
	icon_path = 'images/tabwidget/tab'

	scheduled_update_delay = 0.4 # seconds, update after this time when an update is scheduled

	def __init__(self, widget=None, icon_path=None, **kwargs):
		"""
		@param widget: filename of a widget. Set this to None if you create your
		               widget in `get_widget`.
		"""
		super(TabInterface, self).__init__()
		if widget or self.__class__.widget:
			self.widget = widget or self.__class__.widget
			if not self.__class__.lazy_loading:
				self._setup_widget()
		else:
			# set manually by child
			self.widget = None

		# Regular `image` paths for Icon
		self.button_background_image = 'content/gui/images/tabwidget/tab_dark.png'
		self.button_background_image_active = 'content/gui/images/tabwidget/tab_active_xxl.png'

		# `path` attribute for ImageButton, i.e. without 'content/gui/' and '.png'
		self.path = icon_path or self.__class__.icon_path
		# the active tab image has no special down or hover images, so this works with `path` too
		self.path_active = self.path + '_a'

		self._refresh_scheduled = False

	def _setup_widget(self):
		"""Gets the widget and sets up some attributes and helper.

		This is called when the Tab is created, or, when lazy loading is
		active once the tab is about to be shown.
		"""
		self.widget = self.get_widget()
		self.widget.child_finder = PychanChildFinder(self.widget)
		self.init_widget()

	def get_widget(self):
		"""Loads the filename in self.widget.

		Override this in your subclass if you want to handle widget
		loading/creation yourself.
		"""
		return load_uh_widget(self.widget)

	def init_widget(self):
		"""Initialize widget after it was loaded.

		Override this in your subclass if you have custom post-load code.
		"""
		pass

	def show(self):
		"""Shows the current widget"""
		self.widget.show()

	def hide(self):
		"""Hides the current widget"""
		self.widget.hide()

		if self._refresh_scheduled:
			ExtScheduler().rem_all_classinst_calls(self)
			self._refresh_scheduled = False

	def is_visible(self):
		self.ensure_loaded()
		# naming convention clash: python vs c++
		return self.widget.isVisible()

	def refresh(self):
		"""This function is called by the TabWidget to redraw the widget."""
		pass

	def _schedule_refresh(self):
		"""Schedule a refresh soon, dropping all other refresh request, that appear until then.
		This saves a lot of CPU time, if you have a huge island, or play on high speed."""
		if not self._refresh_scheduled:
			self._refresh_scheduled = True
			def unset_flag():
				# set the flag here and not in refresh() since we can't be sure whether
				# refresh() of this class will be reached or a subclass will not call super()
				self._refresh_scheduled = False
			ExtScheduler().add_new_object(Callback.ChainedCallbacks(unset_flag, self.refresh),
			                              self, run_in=self.__class__.scheduled_update_delay)

	@classmethod
	def shown_for(cls, instance):
		"""Method for fine-grained control of which tabs to show.
		@return: whether this tab should really be shown for this instance"""
		return True

	def ensure_loaded(self):
		"""Called when a tab is shown, acts as hook for lazy loading"""
		if self.__class__.lazy_loading and not hasattr(self, "_lazy_loading_loaded"):
			self._setup_widget()
			self._lazy_loading_loaded = True

	def _get_position(self):
		return self.widget.position

	def _set_position(self, value):
		"""Sets the widgets position to tuple *value*"""
		self.widget.position = value

	# Shortcut to set and retrieve the widget's current position.
	position = property(_get_position, _set_position)

	def __del__(self):
		"""Do cleanup work here."""
		self.widget = None

########NEW FILE########
__FILENAME__ = tabwidget
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import traceback
import weakref

from fife.extensions.pychan.widgets import Container, Icon

from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.imagebutton import ImageButton
from horizons.util.python.callback import Callback
from horizons.util.changelistener import metaChangeListenerDecorator

@metaChangeListenerDecorator('remove')
class TabWidget(object):
	"""The TabWidget class handles widgets which consist of many
	different tabs(subpanels, switchable via buttons(TabButtons).
	"""
	log = logging.getLogger("gui.tabs.tabwidget")

	def __init__(self, ingame_gui, tabs=None, name=None, active_tab=None):
		"""
		@param ingame_gui: IngameGui instance
		@param tabs: tab instances to show
		@param name: optional name for the tabwidget
		@param active_tab: int id of tab, 0 <= active_tab < len(tabs)
		"""
		super(TabWidget, self).__init__()
		self.name = name
		self.ingame_gui = ingame_gui
		self._tabs = [] if not tabs else tabs
		self.current_tab = self._tabs[0] # Start with the first tab
		self.widget = load_uh_widget("tab_base.xml")
		self.widget.position_technique = 'right-239:top+209'
		self.content = self.widget.findChild(name='content')
		self._init_tab_buttons()
		# select a tab to show (first one is default)
		if active_tab is not None:
			self.show_tab(active_tab)

	def _init_tab_buttons(self):
		"""Add enough tabbuttons for all widgets."""
		def on_tab_removal(tabwidget):
			# called when a tab is being removed (via weakref since tabs shouldn't have references to the parent tabwidget)
			# If one tab is removed, the whole tabwidget will die..
			# This is easy usually the desired behavior.
			if tabwidget():
				tabwidget().on_remove()

		# Load buttons
		for index, tab in enumerate(self._tabs):
			# don't add a reference to the
			tab.add_remove_listener(Callback(on_tab_removal, weakref.ref(self)))
			container = Container(name="container_%s" % index)
			background = Icon(name="bg_%s" % index)
			button = ImageButton(name=str(index), size=(50, 50))
			if self.current_tab is tab:
				background.image = tab.button_background_image_active
				button.path = tab.path_active
			else:
				background.image = tab.button_background_image
				button.path = tab.path
			button.capture(Callback(self.show_tab, index))
			if hasattr(tab, 'helptext') and tab.helptext:
				button.helptext = tab.helptext
			container.size = background.size
			container.addChild(background)
			container.addChild(button)
			self.content.addChild(container)
		self.widget.size = (50, 55*len(self._tabs))
		self.widget.adaptLayout()

		self._apply_layout_hack()

	def show_tab(self, number):
		"""Used as callback function for the TabButtons.
		@param number: tab number that is to be shown.
		"""
		if not number in range(len(self._tabs)):
			# this usually indicates a non-critical error, therefore we can handle it without crashing
			traceback.print_stack()
			self.log.warning("Invalid tab number %s, available tabs: %s", number, self._tabs)
			return
		if self.current_tab.is_visible():
			self.current_tab.hide()
		new_tab = self._tabs[number]
		old_bg = self.content.findChild(name = "bg_%s" % self._tabs.index(self.current_tab))
		old_bg.image = self.current_tab.button_background_image
		name = str(self._tabs.index(self.current_tab))
		old_button = self.content.findChild(name=name)
		old_button.path = self.current_tab.path

		new_bg = self.content.findChild(name = "bg_%s" % number)
		new_bg.image = self.current_tab.button_background_image_active
		new_button = self.content.findChild(name=str(number))
		new_button.path = new_tab.path_active
		self.current_tab = new_tab
		# important to display the tabs correctly in front
		self.widget.hide()
		self.show()

		self._apply_layout_hack()

	def _apply_layout_hack(self):
		# pychan layouting depends on time, it's usually in a better mood later.
		# this introduces some flickering, but fixes #916
		from horizons.extscheduler import ExtScheduler
		def do_apply_hack():
			# just query widget when executing, since if lazy loading is used, the widget
			# does not exist yet in the outer function
			self.current_tab.widget.adaptLayout()
		ExtScheduler().add_new_object(do_apply_hack, self, run_in=0)

	def _draw_widget(self):
		"""Draws the widget, but does not show it automatically"""
		self.current_tab.position = (self.widget.position[0] + self.widget.size[0] - 11,
		                             self.widget.position[1] - 52)
		self.current_tab.refresh()

	def show(self):
		"""Show the current widget"""
		self.current_tab.ensure_loaded()
		# show before drawing so that position_technique properly sets
		# button positions (which we want to draw our tabs relative to)
		self.widget.show()
		self._draw_widget()
		self.current_tab.show()
		self.ingame_gui.minimap_to_front()

	def hide(self, caller=None):
		"""Hide the current widget"""
		self.current_tab.hide()
		self.widget.hide()

########NEW FILE########
__FILENAME__ = tradetab
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.constants import GUI
from horizons.gui.widgets.imagefillstatusbutton import ImageFillStatusButton
from horizons.gui.tabs.tabinterface import TabInterface
from horizons.command.uioptions import SellResource, BuyResource, TransferResource
from horizons.util.python.callback import Callback
from horizons.component.tradepostcomponent import TradePostComponent
from horizons.component.storagecomponent import StorageComponent
from horizons.component.namedcomponent import NamedComponent
from horizons.i18n import _lazy


class TradeTab(TabInterface):
	"""Ship to trade post's trade tab. International as well as national trade."""
	log = logging.getLogger("gui.tabs.tradetab")

	widget = 'tradetab.xml'
	icon_path = 'icons/tabwidget/warehouse/buysell'
	helptext = _lazy('Trade')

	scheduled_update_delay = 0.3

	# map the size buttons in the gui to an amount
	exchange_size_buttons = {
	  1 : 'size_1',
	  5 : 'size_2',
	  10: 'size_3',
	  20: 'size_4',
	  50: 'size_5',
	}

	images = {
	  'box_highlighted': 'content/gui/icons/ship/smallbutton_a.png',
	  'box': 'content/gui/icons/ship/smallbutton.png',
	}

	def __init__(self, instance):
		"""
		@param instance: ship instance used for trading
		"""
		self.instance = instance
		super(TradeTab, self).__init__()

	def init_widget(self):
		events = {}
		for k, v in self.exchange_size_buttons.iteritems():
			events[v] = Callback(self.set_exchange, k)
		self.widget.mapEvents(events)
		self.partner = None
		self.exchange = None
		self.set_exchange(GUI.DEFAULT_EXCHANGE_AMOUNT, initial=True)

	def refresh(self):
		super(TradeTab, self).refresh()
		self.draw_widget()

	def draw_widget(self):
		self.widget.findChild(name='ship_name').text = self.instance.get_component(NamedComponent).name
		self.partners = self.instance.get_tradeable_warehouses()
		# set up gui dynamically according to partners
		# NOTE: init on inventories will be optimized away internally if it's only an update
		if self.partners:
			partner_label = self.widget.findChild(name='partners')
			nearest_partner = self.get_nearest_partner(self.partners)
			partner_label.text = self.partners[nearest_partner].settlement.get_component(NamedComponent).name

			new_partner = self.partners[nearest_partner]
			different_partner = new_partner is not self.partner
			if self.partner is not None and different_partner:
				self.__remove_changelisteners()
			self.partner = new_partner
			if different_partner:
				self.__add_changelisteners()

			is_own = self.partner.owner is self.instance.owner
			if not is_own: # foreign warehouse => disable exchange widget, enable trade interface
				self.widget.findChild(name='domestic').hide()
				selling_inventory = self.widget.findChild(name='selling_inventory')
				selling_inventory.init(self.instance.session.db,
				                       self.partner.get_component(StorageComponent).inventory,
				                       self.partner.settlement.get_component(TradePostComponent).sell_list,
				                       selling=True)
				for button in self.get_widgets_by_class(selling_inventory, ImageFillStatusButton):
					button.button.capture(Callback(self.transfer, button.res_id, self.partner.settlement, True))

				buying_inventory = self.widget.findChild(name='buying_inventory')
				buying_inventory.init(self.instance.session.db,
				                      self.partner.get_component(StorageComponent).inventory,
				                      self.partner.settlement.get_component(TradePostComponent).buy_list,
				                      selling=False)
				for button in self.get_widgets_by_class(buying_inventory, ImageFillStatusButton):
					button.button.capture(Callback(self.transfer, button.res_id, self.partner.settlement, False))
				self.widget.findChild(name='international').show()
			else: # own warehouse => enable exchange widget, disable trade interface
				self.widget.findChild(name='international').hide()
				inv_partner = self.widget.findChild(name='inventory_partner') # This is no BuySellInventory!
				inv_partner.init(self.instance.session.db,
				                 self.partner.get_component(StorageComponent).inventory)
				for button in self.get_widgets_by_class(inv_partner, ImageFillStatusButton):
					button.button.capture(Callback(self.transfer, button.res_id, self.partner.settlement, self.instance))
				self.widget.findChild(name='domestic').show()

			inv = self.widget.findChild(name='inventory_ship')
			inv.init(self.instance.session.db, self.instance.get_component(StorageComponent).inventory)
			for button in self.get_widgets_by_class(inv, ImageFillStatusButton):
				button.button.capture(Callback(self.transfer, button.res_id, self.partner.settlement, False))
			self.widget.adaptLayout()
		else:
			# no partner in range any more
			pass

	def __remove_changelisteners(self):
		# never redraw on clicks immediately because of
		# http://github.com/fifengine/fifengine/issues/387
		# This way, there is a chance of clicks being noticed by pychan.
		# The cost is to delay all updates, which in this case is 0.3 sec, therefore deemed bearable.

		# need to be idempotent, show/hide calls it in arbitrary order
		if self.instance:
			self.instance.discard_change_listener(self._schedule_refresh)
			inv = self.instance.get_component(StorageComponent).inventory
			inv.discard_change_listener(self._schedule_refresh)
		if self.partner:
			inv = self.partner.get_component(StorageComponent).inventory
			inv.discard_change_listener(self._schedule_refresh)
			tradepost = self.partner.settlement.get_component(TradePostComponent)
			tradepost.discard_change_listener(self._schedule_refresh)

	def __add_changelisteners(self):
		# need to be idempotent, show/hide calls it in arbitrary order
		if self.instance:
			self.instance.add_change_listener(self._schedule_refresh, no_duplicates=True)
			inv = self.instance.get_component(StorageComponent).inventory
			inv.add_change_listener(self._schedule_refresh, no_duplicates=True)
		if self.partner:
			inv = self.partner.get_component(StorageComponent).inventory
			inv.add_change_listener(self._schedule_refresh, no_duplicates=True)
			tradepost = self.partner.settlement.get_component(TradePostComponent)
			tradepost.add_change_listener(self._schedule_refresh, no_duplicates=True)

	def hide(self):
		self.widget.hide()
		self.__remove_changelisteners()

	def show(self):
		self.widget.show()
		self.__add_changelisteners()
		self.refresh()

	def set_exchange(self, size, initial=False):
		"""
		Highlight radio button with selected amount and deselect old highlighted.
		@param initial: bool, use it to set exchange size when initing the widget
		"""
		self.log.debug("Tradewidget: exchange size now: %s", size)
		if not initial:
			old_name = self.exchange_size_buttons[self.exchange]
			old_box = self.widget.findChild(name=old_name)
			old_box.up_image = self.images['box']

		self.exchange = size

		new_name = self.exchange_size_buttons[self.exchange]
		box_h = self.widget.findChild(name=new_name)
		box_h.up_image = self.images['box_highlighted']
		if not initial:
			self.draw_widget()

	def transfer(self, res_id, settlement, selling):
		"""Buy or sell the resources"""
		if self.instance.position.distance(settlement.warehouse.position) <= self.instance.radius:
			is_own = settlement.owner is self.instance.owner
			if selling and not is_own: # ship sells resources to settlement
				self.log.debug('InternationalTrade: %s/%s is selling %d of res %d to %s/%s',
				               self.instance.get_component(NamedComponent).name, self.instance.owner.name,
				               self.exchange, res_id,
				               settlement.get_component(NamedComponent).name, settlement.owner.name)
				# international trading has own error handling, no signal_error
				SellResource(settlement.get_component(TradePostComponent), self.instance,
				             res_id, self.exchange).execute(self.instance.session)
			elif selling and is_own: # transfer from settlement to ship
				self.log.debug('Trade: Transferring %s of res %s from %s/%s to %s/%s',
				               self.exchange, res_id,
				               settlement.get_component(NamedComponent).name, settlement.owner.name,
				               self.instance.get_component(NamedComponent).name, self.instance.owner.name)
				TransferResource(self.exchange, res_id, settlement,
				                 self.instance, signal_errors=True).execute(self.instance.session)

			elif not selling and not is_own: # ship buys resources from settlement
				self.log.debug('InternationalTrade: %s/%s is buying %d of res %d from %s/%s',
				               self.instance.get_component(NamedComponent).name,
				               self.instance.owner.name, self.exchange, res_id,
				               settlement.get_component(NamedComponent).name, settlement.owner.name)
				# international trading has own error handling, no signal_error
				BuyResource(settlement.get_component(TradePostComponent), self.instance, res_id, self.exchange).execute(self.instance.session)
			elif not selling and is_own: # transfer from ship to settlement
				self.log.debug('Trade: Transferring %s of res %s from %s/%s to %s/%s',
				               self.exchange, res_id,
				               self.instance.get_component(NamedComponent).name, self.instance.owner.name,
				               settlement.get_component(NamedComponent).name, settlement.owner.name)
				TransferResource(self.exchange, res_id, self.instance,
				                 settlement, signal_errors=True).execute(self.instance.session)
			# let gui update be handled by changelisteners (mp-safe)

	def get_widgets_by_class(self, parent_widget, widget_class):
		"""Gets all widget of a certain widget class from the tab. (e.g. pychan.widgets.Label for all labels)"""
		children = []
		def _find_widget(widget):
			if isinstance(widget, widget_class):
				children.append(widget)
		parent_widget.deepApply(_find_widget)
		return children

	def get_nearest_partner(self, partners):
		nearest = None
		nearest_dist = None
		for partner in partners:
			dist = partner.position.distance(self.instance.position)
			if nearest_dist is None or dist < nearest_dist:
				nearest_dist = dist
				nearest = partners.index(partner)
		return nearest

########NEW FILE########
__FILENAME__ = translations
# Encoding: utf-8
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

###############################################################################
#
# == I18N DEV USE CASES: CHEATSHEET ==
#
# ** Refer to  development/create_pot.sh  for help with building or updating
#    the translation files for Unknown Horizons.
#
###############################################################################
#
# WARNING: This file is generated automagically.
#          You need to update it to see changes to strings in-game.
#          DO NOT MANUALLY UPDATE THIS FILE (by editing strings).
#          The script to generate .pot templates calls the following:
# ./development/extract_strings_from_xml.py  horizons/gui/translations.py
#
# NOTE: In string-freeze mode (shortly before releases, usually
#       announced in a meeting), updates to this file must not happen
#       without permission of the responsible translation admin!
#
###############################################################################

from horizons.constants import VERSION

text_translations = {}

def set_translations():
	global text_translations
	text_translations = {

	'stringpreviewwidget.xml' : {
		},

	'editor_pause_menu.xml' : {
		(u'help'                         , 'text'    ): _(u"Help"),
		(u'loadgame'                     , 'text'    ): _(u"Load map"),
		(u'quit'                         , 'text'    ): _(u"Exit editor"),
		(u'savegame'                     , 'text'    ): _(u"Save map"),
		(u'settings'                     , 'text'    ): _(u"Settings"),
		(u'start'                        , 'text'    ): _(u"Return to editor"),
		},

	'editor_settings.xml' : {
		(u'cursor_hint'                  , 'text'    ): _(u"(right click to stop)"),
		(u'headline_brush_size'          , 'text'    ): _(u"Select brush size:"),
		(u'headline_terrain'             , 'text'    ): _(u"Select terrain:"),
		},

	'buildtab.xml' : {
		},

	'buildtab_no_settlement.xml' : {
		(u'headline'                     , 'text'    ): _(u"Game start"),
		(u'howto_1_need_warehouse'       , 'text'    ): _(u"You need to found a settlement before you can construct buildings!"),
		(u'howto_2_navigate_ship'        , 'text'    ): _(u"Select your ship and approach the coast via right-click."),
		(u'howto_3_build_warehouse'      , 'text'    ): _(u"Afterwards, press the large button in the ship overview tab."),
		},

	'place_building.xml' : {
		(u'headline'                     , 'text'    ): _(u"Build"),
		(u'running_costs_label'          , 'text'    ): _(u"Running costs:"),
		},

	'related_buildings.xml' : {
		(u'headline'                     , 'text'    ): _(u"Related buildings"),
		},

	'city_info.xml' : {
		(u'city_info_inhabitants'        , 'helptext'): _(u"Inhabitants"),
		},

	'messagewidget_icon.xml' : {
		},

	'messagewidget_message.xml' : {
		},

	'minimap.xml' : {
		(u'build'                        , 'helptext'): _(u"Build menu ({key})"),
		(u'destroy_tool'                 , 'helptext'): _(u"Destroy ({key})"),
		(u'diplomacyButton'              , 'helptext'): _(u"Diplomacy"),
		(u'gameMenuButton'               , 'helptext'): _(u"Game menu ({key})"),
		(u'logbook'                      , 'helptext'): _(u"Captain's log ({key})"),
		(u'rotateLeft'                   , 'helptext'): _(u"Rotate map counterclockwise ({key})"),
		(u'rotateRight'                  , 'helptext'): _(u"Rotate map clockwise ({key})"),
		(u'speedDown'                    , 'helptext'): _(u"Decrease game speed ({key})"),
		(u'speedUp'                      , 'helptext'): _(u"Increase game speed ({key})"),
		(u'zoomIn'                       , 'helptext'): _(u"Zoom in"),
		(u'zoomOut'                      , 'helptext'): _(u"Zoom out"),
		},

	'resource_overview_bar_entry.xml' : {
		},

	'resource_overview_bar_gold.xml' : {
		},

	'resource_overview_bar_stats.xml' : {
		},

	'change_name.xml' : {
		(u'enter_new_name_lbl'           , 'text'    ): _(u"Enter new name:"),
		(u'headline_change_name'         , 'text'    ): _(u"Change name"),
		(u'old_name_label'               , 'text'    ): _(u"Old name:"),
		(u'okButton'                     , 'helptext'): _(u"Apply the new name"),
		},

	'chat.xml' : {
		(u'chat_lbl'                     , 'text'    ): _(u"Enter your message:"),
		(u'headline'                     , 'text'    ): _(u"Chat"),
		},

	'boatbuilder.xml' : {
		(u'BB_cancel_build_label'        , 'text'    ): _(u"Cancel building:"),
		(u'BB_cancel_warning_label'      , 'text'    ): _(u"(lose all resources)"),
		(u'BB_current_order'             , 'text'    ): _(u"Currently building:"),
		(u'BB_howto_build_lbl'           , 'text'    ): _(u"To build a boat, click on one of the class tabs, select the desired ship and confirm the order."),
		(u'BB_needed_res_label'          , 'text'    ): _(u"Resources still needed:"),
		(u'BB_progress_label'            , 'text'    ): _(u"Construction progress:"),
		(u'BB_cancel_button'             , 'helptext'): _(u"Cancel all building progress"),
		(u'running_costs_label'          , 'helptext'): _(u"Running costs"),
		(u'toggle_active_active'         , 'helptext'): _(u"Pause"),
		(u'toggle_active_inactive'       , 'helptext'): _(u"Resume"),
		},

	'boatbuilder_showcase.xml' : {
		},

	'diplomacy.xml' : {
		(u'ally_label'                   , 'text'    ): _(u"ally"),
		(u'enemy_label'                  , 'text'    ): _(u"enemy"),
		(u'neutral_label'                , 'text'    ): _(u"neutral"),
		},

	'overview_farm.xml' : {
		(u'headline'                     , 'text'    ): _(u"Building overview"),
		(u'capacity_utilization_label'   , 'helptext'): _(u"Capacity utilization"),
		(u'running_costs_label'          , 'helptext'): _(u"Running costs"),
		(u'capacity_utilization'         , 'helptext'): _(u"Capacity utilization"),
		(u'running_costs'                , 'helptext'): _(u"Running costs"),
		},

	'island_inventory.xml' : {
		(u'headline'                     , 'text'    ): _(u"Settlement inventory"),
		},

	'mainsquare_inhabitants.xml' : {
		(u'headline'                     , 'text'    ): _(u"Settler overview"),
		(u'headline_happiness_per_house' , 'text'    ): _(u"Happiness per house"),
		(u'headline_residents_per_house' , 'text'    ): _(u"Residents per house"),
		(u'headline_residents_total'     , 'text'    ): _(u"Summary"),
		(u'houses'                       , 'text'    ): _(u"houses"),
		(u'residents'                    , 'text'    ): _(u"residents"),
		(u'tax_label'                    , 'text'    ): _(u"Taxes:"),
		(u'upgrades_lbl'                 , 'text'    ): _(u"Upgrade permissions:"),
		(u'avg_icon'                     , 'helptext'): _(u"satisfied"),
		(u'happiness_house_icon'         , 'helptext'): _(u"Amount of houses with this happiness"),
		(u'happy_icon'                   , 'helptext'): _(u"happy"),
		(u'houses_icon'                  , 'helptext'): _(u"Houses with this amount of inhabitants"),
		(u'inhabitants_icon'             , 'helptext'): _(u"Number of inhabitants per house"),
		(u'paid_taxes_icon'              , 'helptext'): _(u"Paid taxes"),
		(u'sad_icon'                     , 'helptext'): _(u"sad"),
		(u'tax_rate_icon'                , 'helptext'): _(u"Tax rate"),
		(u'tax_val_label'                , 'helptext'): _(u"Tax rate"),
		(u'taxes'                        , 'helptext'): _(u"Paid taxes"),
		},

	'overview_enemybuilding.xml' : {
		},

	'overview_enemyunit.xml' : {
		},

	'overview_enemywarehouse.xml' : {
		(u'buying_label'                 , 'text'    ): _(u"Buying"),
		(u'selling_label'                , 'text'    ): _(u"Selling"),
		},

	'overview_firestation.xml' : {
		(u'headline'                     , 'text'    ): _(u"Building overview"),
		(u'name_label'                   , 'text'    ): _(u"Name:"),
		(u'running_costs_label'          , 'helptext'): _(u"Running costs"),
		(u'running_costs'                , 'helptext'): _(u"Running costs"),
		},

	'overview_groundunit.xml' : {
		(u'lbl_weapon_storage'           , 'text'    ): _(u"Weapons:"),
		},

	'overview_productionbuilding.xml' : {
		(u'capacity_utilization_label'   , 'helptext'): _(u"Capacity utilization"),
		(u'running_costs_label'          , 'helptext'): _(u"Running costs"),
		(u'capacity_utilization'         , 'helptext'): _(u"Capacity utilization"),
		(u'running_costs'                , 'helptext'): _(u"Running costs"),
		},

	'overview_resourcedeposit.xml' : {
		(u'headline'                     , 'text'    ): _(u"Resource deposit"),
		(u'res_dep_description_lbl'      , 'text'    ): _(u"This is a resource deposit where you can build a mine to dig up resources."),
		(u'res_dep_description_lbl2'     , 'text'    ): _(u"It contains these resources:"),
		},

	'overview_settler.xml' : {
		(u'needed_res_label'             , 'text'    ): _(u"Needed resources:"),
		(u'tax_label'                    , 'text'    ): _(u"Taxes:"),
		(u'happiness_label'              , 'helptext'): _(u"Happiness"),
		(u'paid_taxes_label'             , 'helptext'): _(u"Paid taxes"),
		(u'paid_taxes_label'             , 'helptext'): _(u"Tax rate"),
		(u'residents_label'              , 'helptext'): _(u"Residents"),
		(u'inhabitants'                  , 'helptext'): _(u"Residents"),
		(u'tax_val_label'                , 'helptext'): _(u"Tax rate"),
		(u'taxes'                        , 'helptext'): _(u"Paid taxes"),
		(u'happiness'                    , 'helptext'): _(u"Happiness"),
		},

	'overview_signalfire.xml' : {
		(u'signal_fire_description_lbl'  , 'text'    ): _(u"The signal fire shows the free trader how to reach your settlement in case you want to buy or sell goods."),
		},

	'overview_tower.xml' : {
		(u'name_label'                   , 'text'    ): _(u"Name:"),
		(u'running_costs_label'          , 'helptext'): _(u"Running costs"),
		(u'running_costs'                , 'helptext'): _(u"Running costs"),
		},

	'overview_tradership.xml' : {
		(u'trader_description_lbl'       , 'text'    ): _(u"This is the free trader's ship. It will visit you from time to time to buy or sell goods."),
		},

	'overviewtab.xml' : {
		},

	'overview_select_multi.xml' : {
		},

	'unit_entry_widget.xml' : {
		},

	'overview_trade_ship.xml' : {
		(u'configure_route'              , 'helptext'): _(u"Configure trading route"),
		(u'found_settlement'             , 'helptext'): _(u"Build settlement"),
		(u'trade'                        , 'helptext'): _(u"Trade"),
		},

	'overview_war_ship.xml' : {
		(u'configure_route'              , 'helptext'): _(u"Configure trading route"),
		(u'found_settlement'             , 'helptext'): _(u"Build settlement"),
		(u'trade'                        , 'helptext'): _(u"Trade"),
		},

	'tradetab.xml' : {
		(u'buying_label'                 , 'text'    ): _(u"Buying"),
		(u'exchange_label'               , 'text'    ): _(u"Exchange:"),
		(u'headline'                     , 'text'    ): _(u"Trade"),
		(u'selling_label'                , 'text'    ): _(u"Selling"),
		(u'ship_label'                   , 'text'    ): _(u"Ship:"),
		(u'trade_with_label'             , 'text'    ): _(u"Trade partner:"),
		},

	'tab_base.xml' : {
		},

	'buysellmenu.xml' : {
		(u'headline'                     , 'text'    ): _(u"Buy or sell resources"),
		(u'headline_trade_history'       , 'text'    ): _(u"Trade history"),
		},

	'select_trade_resource.xml' : {
		(u'headline'                     , 'text'    ): _(u"Select resources:"),
		},

	'tab_account.xml' : {
		(u'buy_expenses_label'           , 'text'    ): _(u"Buying"),
		(u'headline_balance_label'       , 'text'    ): _(u"Balance:"),
		(u'headline_expenses_label'      , 'text'    ): _(u"Expenses:"),
		(u'headline_income_label'        , 'text'    ): _(u"Income:"),
		(u'running_costs_label'          , 'text'    ): _(u"Running costs"),
		(u'sell_income_label'            , 'text'    ): _(u"Sale"),
		(u'taxes_label'                  , 'text'    ): _(u"Taxes"),
		(u'collector_utilization_label'  , 'helptext'): _(u"Collector utilization"),
		(u'show_production_overview'     , 'helptext'): _(u"Show resources produced in this settlement"),
		(u'collector_utilization'        , 'helptext'): _(u"Collector utilization"),
		},

	'trade_single_slot.xml' : {
		},

	'overview_farmproductionline.xml' : {
		(u'toggle_active_active'         , 'helptext'): _(u"Pause production"),
		(u'toggle_active_inactive'       , 'helptext'): _(u"Start production"),
		},

	'overview_productionline.xml' : {
		(u'toggle_active_active'         , 'helptext'): _(u"Pause production"),
		(u'toggle_active_inactive'       , 'helptext'): _(u"Start production"),
		},

	'related_buildings_container.xml' : {
		},

	'resbar_resource_selection.xml' : {
		(u'headline'                     , 'text'    ): _(u"Select resource:"),
		(u'make_default_btn'             , 'helptext'): _(u"Save current resource configuration as default for all settlements."),
		(u'reset_default_btn'            , 'helptext'): _(u"Reset default resource configuration for all settlements."),
		(u'headline'                     , 'helptext'): _(u"The resource you select is displayed instead of the current one. Empty by clicking on X."),
		},

	'route_entry.xml' : {
		(u'delete_warehouse'             , 'helptext'): _(u"Delete entry"),
		(u'move_down'                    , 'helptext'): _(u"Move down"),
		(u'move_up'                      , 'helptext'): _(u"Move up"),
		},

	'trade_history_item.xml' : {
		},

	'traderoute_resource_selection.xml' : {
		(u'select_res_label'             , 'text'    ): _(u"Select a resource:"),
		},

	'captains_log.xml' : {
		(u'stats_players'                , 'text'    ): _(u"Players"),
		(u'stats_settlements'            , 'text'    ): _(u"My settlements"),
		(u'stats_ships'                  , 'text'    ): _(u"My ships"),
		(u'weird_button_1'               , 'text'    ): _(u"Whole world"),
		(u'weird_button_4'               , 'text'    ): _(u"Everybody"),
		(u'headline_chat'                , 'text'    ): _(u"Chat"),
		(u'headline_game_messages'       , 'text'    ): _(u"Game messages"),
		(u'headline_statistics'          , 'text'    ): _(u"Statistics"),
		(u'okButton'                     , 'helptext'): _(u"Return to game"),
		(u'weird_button_4'               , 'helptext'): _(u"Sends the chat messages to all players."),
		(u'backwardButton'               , 'helptext'): _(u"Read previous entries"),
		(u'forwardButton'                , 'helptext'): _(u"Read next entries"),
		},

	'configure_route.xml' : {
		(u'lbl_route_activity'           , 'text'    ): _(u"Route activity:"),
		(u'lbl_wait_at_load'             , 'text'    ): _(u"Wait at load:"),
		(u'lbl_wait_at_unload'           , 'text'    ): _(u"Wait at unload:"),
		(u'okButton'                     , 'helptext'): _(u"Exit"),
		(u'start_route'                  , 'helptext'): _(u"Start route"),
		},

	'healthwidget.xml' : {
		},

	'island_production.xml' : {
		(u'okButton'                     , 'helptext'): _(u"Close"),
		},

	'players_overview.xml' : {
		(u'building_score'               , 'text'    ): _(u"Buildings"),
		(u'headline'                     , 'text'    ): _(u"Player scores"),
		(u'land_score'                   , 'text'    ): _(u"Land"),
		(u'money_score'                  , 'text'    ): _(u"Money"),
		(u'player_name'                  , 'text'    ): _(u"Name"),
		(u'resource_score'               , 'text'    ): _(u"Resources"),
		(u'settler_score'                , 'text'    ): _(u"Settlers"),
		(u'total_score'                  , 'text'    ): _(u"Total"),
		(u'unit_score'                   , 'text'    ): _(u"Units"),
		(u'building_score'               , 'helptext'): _(u"Value of all the buildings in the player's settlement(s)"),
		(u'land_score'                   , 'helptext'): _(u"Value of usable land i.e Amount of Land that can be used to create buildings "),
		(u'money_score'                  , 'helptext'): _(u"Player's current treasury + income expected in near future"),
		(u'player_name'                  , 'helptext'): _(u"Player Name"),
		(u'resource_score'               , 'helptext'): _(u"Value of resources generated from all the possible sources in the player's settlement(s)"),
		(u'settler_score'                , 'helptext'): _(u"Value denoting the progress of the settlement(s) in terms of inhabitants, buildings and overall happiness"),
		(u'total_score'                  , 'helptext'): _(u"The total value from all individual entities or in short : Total Player Score"),
		(u'unit_score'                   , 'helptext'): _(u"Value of all the units owned by the player"),
		},

	'players_settlements.xml' : {
		(u'balance'                      , 'text'    ): _(u"Balance"),
		(u'inhabitants'                  , 'text'    ): _(u"Inhabitants"),
		(u'running_costs'                , 'text'    ): _(u"Running costs"),
		(u'settlement_name'              , 'text'    ): _(u"Name"),
		(u'taxes'                        , 'text'    ): _(u"Taxes"),
		},

	'ships_list.xml' : {
		(u'health'                       , 'text'    ): _(u"Health"),
		(u'ship_name'                    , 'text'    ): _(u"Name"),
		(u'ship_type'                    , 'text'    ): _(u"Type"),
		(u'status'                       , 'text'    ): _(u"Status"),
		(u'weapons'                      , 'text'    ): _(u"Weapons"),
		},

	'stancewidget.xml' : {
		(u'aggressive_stance'            , 'helptext'): _(u"Aggressive"),
		(u'flee_stance'                  , 'helptext'): _(u"Flee"),
		(u'hold_ground_stance'           , 'helptext'): _(u"Hold ground"),
		(u'none_stance'                  , 'helptext'): _(u"Passive"),
		},

	'credits.xml' : {
		},

	'editor_create_map.xml' : {
		(u'headline_choose_map_size_lbl' , 'text'    ): _(u"Choose a map size:"),
		},

	'editor_select_map.xml' : {
		(u'headline_choose_map_lbl'      , 'text'    ): _(u"Choose a map:"),
		},

	'editor_select_saved_game.xml' : {
		(u'headline_choose_saved_game'   , 'text'    ): _(u"Choose a saved game's map:"),
		},

	'editor_start_menu.xml' : {
		(u'headline'                     , 'text'    ): _(u"Select map source"),
		(u'create_new_map'               , 'text'    ): _(u"Create new map"),
		(u'load_existing_map'            , 'text'    ): _(u"Load existing map"),
		(u'load_saved_game_map'          , 'text'    ): _(u"Load saved game's map"),
		(u'cancel'                       , 'helptext'): _(u"Exit to main menu"),
		(u'okay'                         , 'helptext'): _(u"Start editor"),
		},

	'help.xml' : {
		(u'okButton'                     , 'helptext'): _(u"Return"),
		},

	'hotkeys.xml' : {
		(u'reset_to_default'             , 'text'    ): _(u"Reset to default keys"),
		(u'labels_headline'              , 'text'    ): _(u"Actions"),
		(u'primary_buttons_headline'     , 'text'    ): _(u"Primary"),
		(u'secondary_buttons_headline'   , 'text'    ): _(u"Secondary"),
		(u'okButton'                     , 'helptext'): _(u"Exit to main menu"),
		(u'reset_to_default'             , 'helptext'): _(u"Reset to default"),
		(u'lbl_BUILD_TOOL'               , 'helptext'): _(u"Show build menu"),
		(u'lbl_CHAT'                     , 'helptext'): _(u"Chat"),
		(u'lbl_CONSOLE'                  , 'helptext'): _(u"Toggle showing FPS on/off"),
		(u'lbl_COORD_TOOLTIP'            , 'helptext'): _(u"Show coordinate values (Debug)"),
		(u'lbl_DESTROY_TOOL'             , 'helptext'): _(u"Enable destruct mode"),
		(u'lbl_DOWN'                     , 'helptext'): _(u"Scroll down"),
		(u'lbl_GRID'                     , 'helptext'): _(u"Toggle grid on/off"),
		(u'lbl_HEALTH_BAR'               , 'helptext'): _(u"Toggle health bars"),
		(u'lbl_HELP'                     , 'helptext'): _(u"Display help"),
		(u'lbl_LEFT'                     , 'helptext'): _(u"Scroll left"),
		(u'lbl_LOGBOOK'                  , 'helptext'): _(u"Toggle Captain's log"),
		(u'lbl_PAUSE'                    , 'helptext'): _(u"Pause game"),
		(u'lbl_PIPETTE'                  , 'helptext'): _(u"Enable pipette mode (clone buildings)"),
		(u'lbl_PLAYERS_OVERVIEW'         , 'helptext'): _(u"Show player scores"),
		(u'lbl_QUICKLOAD'                , 'helptext'): _(u"Quickload"),
		(u'lbl_QUICKSAVE'                , 'helptext'): _(u"Quicksave"),
		(u'lbl_REMOVE_SELECTED'          , 'helptext'): _(u"Remove selected units / buildings"),
		(u'lbl_RIGHT'                    , 'helptext'): _(u"Scroll right"),
		(u'lbl_ROAD_TOOL'                , 'helptext'): _(u"Enable road building mode"),
		(u'lbl_ROTATE_LEFT'              , 'helptext'): _(u"Rotate building or map counterclockwise"),
		(u'lbl_ROTATE_RIGHT'             , 'helptext'): _(u"Rotate building or map clockwise"),
		(u'lbl_SCREENSHOT'               , 'helptext'): _(u"Screenshot"),
		(u'lbl_SETTLEMENTS_OVERVIEW'     , 'helptext'): _(u"Show settlement list"),
		(u'lbl_SHIPS_OVERVIEW'           , 'helptext'): _(u"Show ship list"),
		(u'lbl_SHOW_SELECTED'            , 'helptext'): _(u"Focus camera on selection"),
		(u'lbl_SPEED_DOWN'               , 'helptext'): _(u"Decrease game speed"),
		(u'lbl_SPEED_UP'                 , 'helptext'): _(u"Increase game speed"),
		(u'lbl_TILE_OWNER_HIGHLIGHT'     , 'helptext'): _(u"Highlight tile ownership"),
		(u'lbl_TRANSLUCENCY'             , 'helptext'): _(u"Toggle translucency of ambient buildings"),
		(u'lbl_UP'                       , 'helptext'): _(u"Scroll up"),
		},

	'ingamemenu.xml' : {
		(u'help'                         , 'text'    ): _(u"Help"),
		(u'loadgame'                     , 'text'    ): _(u"Load game"),
		(u'quit'                         , 'text'    ): _(u"Cancel game"),
		(u'savegame'                     , 'text'    ): _(u"Save game"),
		(u'settings'                     , 'text'    ): _(u"Settings"),
		(u'start'                        , 'text'    ): _(u"Return to game"),
		},

	'loadingscreen.xml' : {
		(u'loading_label'                , 'text'    ): _(u"Loading…"),
		},

	'mainmenu.xml' : {
		(u'credits_label'                , 'text'    ): _(u"Credits"),
		(u'editor_label'                 , 'text'    ): _(u"Editor"),
		(u'help_label'                   , 'text'    ): _(u"Help"),
		(u'load_label'                   , 'text'    ): _(u"Load game"),
		(u'multi_label'                  , 'text'    ): _(u"Multiplayer"),
		(u'quit_label'                   , 'text'    ): _(u"Quit"),
		(u'settings_label'               , 'text'    ): _(u"Settings"),
		(u'single_label'                 , 'text'    ): _(u"Singleplayer"),
		(u'version_label'                , 'text'    ): VERSION.string(),
		},

	'multiplayer_creategame.xml' : {
		(u'gamename_lbl'                 , 'text'    ): _(u"Name of the game:"),
		(u'headline'                     , 'text'    ): _(u"Choose a map:"),
		(u'headline'                     , 'text'    ): _(u"Create game - Multiplayer"),
		(u'mp_player_limit_lbl'          , 'text'    ): _(u"Player limit:"),
		(u'password_lbl'                 , 'text'    ): _(u"Password of the game:"),
		(u'cancel'                       , 'helptext'): _(u"Exit to multiplayer menu"),
		(u'create'                       , 'helptext'): _(u"Create this new game"),
		(u'gamename_lbl'                 , 'helptext'): _(u"This will be displayed to other players so they recognize the game."),
		(u'password_lbl'                 , 'helptext'): _(u"This game's password. Required to join this game."),
		},

	'multiplayer_gamelobby.xml' : {
		(u'game_player_color'            , 'text'    ): _(u"Color"),
		(u'game_player_status'           , 'text'    ): _(u"Status"),
		(u'game_start_notice'            , 'text'    ): _(u"The game will start as soon as all players are ready."),
		(u'headline'                     , 'text'    ): _(u"Chat:"),
		(u'headline'                     , 'text'    ): _(u"Gamelobby"),
		(u'ready_lbl'                    , 'text'    ): _(u"Ready:"),
		(u'startmessage'                 , 'text'    ): _(u"Game details:"),
		(u'cancel'                       , 'helptext'): _(u"Exit gamelobby"),
		(u'ready_btn'                    , 'helptext'): _(u"Sets your state to ready (necessary for the game to start)"),
		},

	'multiplayermenu.xml' : {
		(u'create_game_lbl'              , 'text'    ): _(u"Create game:"),
		(u'headline_active_games_lbl'    , 'text'    ): _(u"Active games:"),
		(u'headline_left'                , 'text'    ): _(u"New game - Multiplayer"),
		(u'join_game_lbl'                , 'text'    ): _(u"Join game:"),
		(u'load_game_lbl'                , 'text'    ): _(u"Load game:"),
		(u'refr_gamelist_lbl'            , 'text'    ): _(u"Refresh list:"),
		(u'cancel'                       , 'helptext'): _(u"Exit to main menu"),
		(u'create'                       , 'helptext'): _(u"Create a new game"),
		(u'join'                         , 'helptext'): _(u"Join the selected game"),
		(u'load'                         , 'helptext'): _(u"Load a saved game"),
		(u'refresh'                      , 'helptext'): _(u"Refresh list of active games"),
		},

	'set_player_details.xml' : {
		(u'headline_set_player_details'  , 'text'    ): _(u"Change player details"),
		},

	'settings.xml' : {
		(u'auto_unload_label'            , 'text'    ): _(u"Auto-unload ship:"),
		(u'autosave_interval_label'      , 'text'    ): _(u"Autosave interval in minutes:"),
		(u'cursor_centered_zoom_label'   , 'text'    ): _(u"Cursor centered zoom:"),
		(u'debug_log_lbl'                , 'text'    ): _(u"Enable logging:"),
		(u'edge_scrolling_label'         , 'text'    ): _(u"Scroll at map edge:"),
		(u'effect_volume_label'          , 'text'    ): _(u"Effects volume:"),
		(u'fps_label'                    , 'text'    ): _(u"Frame rate limit:"),
		(u'headline_graphics'            , 'text'    ): _(u"Graphics"),
		(u'headline_language'            , 'text'    ): _(u"Language"),
		(u'headline_misc'                , 'text'    ): _(u"General"),
		(u'headline_mouse'               , 'text'    ): _(u"Mouse"),
		(u'headline_network'             , 'text'    ): _(u"Network"),
		(u'headline_saving'              , 'text'    ): _(u"Saving"),
		(u'headline_sound'               , 'text'    ): _(u"Sound"),
		(u'middle_mouse_pan_lbl'         , 'text'    ): _(u"Middle mouse button pan:"),
		(u'minimap_rotation_label'       , 'text'    ): _(u"Rotate minimap with map:"),
		(u'mouse_sensitivity_label'      , 'text'    ): _(u"Mouse sensitivity:"),
		(u'music_volume_label'           , 'text'    ): _(u"Music volume:"),
		(u'network_port_lbl'             , 'text'    ): _(u"Network port:"),
		(u'number_of_autosaves_label'    , 'text'    ): _(u"Number of autosaves:"),
		(u'number_of_quicksaves_label'   , 'text'    ): _(u"Number of quicksaves:"),
		(u'quote_type_label'             , 'text'    ): _(u"Choose a quote type:"),
		(u'screen_fullscreen_text'       , 'text'    ): _(u"Full screen:"),
		(u'screen_resolution_label'      , 'text'    ): _(u"Screen resolution:"),
		(u'scroll_speed_label'           , 'text'    ): _(u"Scroll delay:"),
		(u'show_resource_icons_lbl'      , 'text'    ): _(u"Production indicators:"),
		(u'sound_enable_opt_text'        , 'text'    ): _(u"Enable sound:"),
		(u'uninterrupted_building_label' , 'text'    ): _(u"Uninterrupted building:"),
		(u'use_renderer_label'           , 'text'    ): _(u"Used renderer:"),
		(u'cancelButton'                 , 'helptext'): _(u"Discard current changes"),
		(u'defaultButton'                , 'helptext'): _(u"Reset to default settings"),
		(u'okButton'                     , 'helptext'): _(u"Save changes"),
		(u'auto_unload_label'            , 'helptext'): _(u"Whether to unload the ship after founding a settlement"),
		(u'cursor_centered_zoom_label'   , 'helptext'): _(u"When enabled, mouse wheel zoom will use the cursor position as new viewport center. When disabled, always zoom to current viewport center."),
		(u'debug_log_lbl'                , 'helptext'): _(u"Don't use in normal game session. Decides whether to write debug information in the logging directory of your user directory. Slows the game down."),
		(u'edge_scrolling_label'         , 'helptext'): _(u"Whether to move the viewport when the mouse pointer is close to map edges"),
		(u'fps_label'                    , 'helptext'): _(u"Set the maximum frame rate used. Default: 60 fps."),
		(u'middle_mouse_pan_lbl'         , 'helptext'): _(u"When enabled, dragging the middle mouse button will pan the camera"),
		(u'minimap_rotation_label'       , 'helptext'): _(u"Whether to also rotate the minimap whenever the regular map is rotated"),
		(u'mouse_sensitivity_label'      , 'helptext'): _(u"0 is default system settings"),
		(u'network_port_lbl'             , 'helptext'): _(u"If set to 0, use the router default"),
		(u'quote_type_label'             , 'helptext'): _(u"What kind of quote to display while loading a game"),
		(u'scroll_speed_label'           , 'helptext'): _(u"Higher values slow down scrolling."),
		(u'show_resource_icons_lbl'      , 'helptext'): _(u"Whether to show resource icons over buildings whenever they finish production"),
		(u'uninterrupted_building_label' , 'helptext'): _(u"When enabled, do not exit the build mode after successful construction"),
		(u'use_renderer_label'           , 'helptext'): _(u"SDL is only meant as unsupported fallback and might cause problems!"),
		},

	'select_savegame.xml' : {
		(u'enter_filename_label'         , 'text'    ): _(u"Enter filename:"),
		(u'gamename_lbl'                 , 'text'    ): _(u"Name of the game:"),
		(u'gamepassword_lbl'             , 'text'    ): _(u"Password of the game:"),
		(u'headline_details_label'       , 'text'    ): _(u"Details:"),
		(u'headline_saved_games_label'   , 'text'    ): _(u"Your saved games:"),
		(u'cancelButton'                 , 'helptext'): _(u"Cancel"),
		(u'deleteButton'                 , 'helptext'): _(u"Delete selected savegame"),
		(u'gamename_lbl'                 , 'helptext'): _(u"This will be displayed to other players so they recognize the game."),
		(u'gamepassword_lbl'             , 'helptext'): _(u"Password of the game. Required to join this game"),
		},

	'singleplayermenu.xml' : {
		(u'headline'                     , 'text'    ): _(u"New game - Singleplayer"),
		(u'free_maps'                    , 'text'    ): _(u"Free play"),
		(u'random'                       , 'text'    ): _(u"Random map"),
		(u'scenario'                     , 'text'    ): _(u"Scenario"),
		(u'cancel'                       , 'helptext'): _(u"Exit to main menu"),
		(u'okay'                         , 'helptext'): _(u"Start game"),
		},

	'sp_free_maps.xml' : {
		(u'headline_choose_map_lbl'      , 'text'    ): _(u"Choose a map to play:"),
		},

	'sp_random.xml' : {
		(u'headline_map_settings_lbl'    , 'text'    ): _(u"Map settings:"),
		(u'seed_string_lbl'              , 'text'    ): _(u"Seed:"),
		},

	'sp_scenario.xml' : {
		(u'choose_map_lbl'               , 'text'    ): _(u"Choose a map to play:"),
		(u'select_lang_lbl'              , 'text'    ): _(u"Select a language:"),
		},

	'aidataselection.xml' : {
		(u'ai_players_label'             , 'text'    ): _(u"AI players:"),
		},

	'game_settings.xml' : {
		(u'headline_game_settings_lbl'   , 'text'    ): _(u"Game settings:"),
		(u'lbl_disasters'                , 'text'    ): _(u"Disasters"),
		(u'lbl_free_trader'              , 'text'    ): _(u"Free Trader"),
		(u'lbl_pirates'                  , 'text'    ): _(u"Pirates"),
		},

	'playerdataselection.xml' : {
		(u'color_label'                  , 'text'    ): _(u"Color:"),
		(u'player_label'                 , 'text'    ): _(u"Player name:"),
		},

	'popup_230.xml' : {
		},

	'popup_290.xml' : {
		},

	'popup_350.xml' : {
		},

	'startup_error_popup.xml' : {
		},

	}

########NEW FILE########
__FILENAME__ = util
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import os
# Find the best implementation available on this platform
try:
	from cStringIO import StringIO
except:
	from StringIO import StringIO

from fife.extensions.pychan import loadXML
from fife.extensions.pychan.widgets import Container, HBox, Icon

from horizons.gui.i18n import translate_widget
from horizons.gui.widgets.imagebutton import ImageButton
from horizons.util.python import decorators
from horizons.util.python.callback import Callback

@decorators.cachedfunction
def get_gui_files_map():
	"""Returns a dictionary { basename : full_path }
	for all xml gui files in content/gui
	"""
	xml_files = {}
	for root, dirs, files in os.walk('content/gui/xml'):
		for f in files:
			if not f.endswith('.xml'):
				continue
			if f in xml_files:
				raise Exception('Another file by the name {name} already exists. '
								'Please use unique names!'.format(name=f))
			xml_files[f] = os.path.join(root, f)
	return xml_files

def get_happiness_icon_and_helptext(value, session):
	happiness_icon_path = "content/gui/icons/templates/happiness/"
	sad = session.db.get_lower_happiness_limit()
	happy = session.db.get_upper_happiness_limit()
	if value <= sad:
		happiness_icon_path += "sad.png"
		happiness_helptext = _("sad")
	elif sad < value < happy:
		happiness_icon_path += "average.png"
		happiness_helptext = _("satisfied")
	elif value >= happy:
		happiness_icon_path += "happy.png"
		happiness_helptext = _("happy")

	return happiness_icon_path, happiness_helptext

@decorators.cachedfunction
def get_widget_xml(filename):
	"""
	This function reads the given widget file's content and returns the XML. 
	It is cached to avoid useless IO.
	"""
	with open(get_gui_files_map()[filename]) as open_file:
		return open_file.read()

def load_uh_widget(filename, style=None, center_widget=False):
	"""Loads a pychan widget from an xml file and applies uh-specific modifications
	"""
	# load widget
	try:
		widget = loadXML(StringIO(get_widget_xml(filename)))
	except (IOError, ValueError) as error:
		log = logging.getLogger('gui')
		log.error(u'PLEASE REPORT: invalid path %s in translation!\n> %s', filename, error)
		raise

	# translate
	widget = translate_widget(widget, filename)

	if style:
		widget.stylize(style)
	# format headline
	for w in widget.findChildren():
		if w.name.startswith("headline") or w.name == "name":
			w.stylize('headline')
		elif w.name.startswith("uni_") or w.comment.startswith("uni_"):
			w.font = 'unifont'
	if center_widget:
		widget.position_technique = "center:center"

	return widget

@decorators.cachedfunction
def get_res_icon_path(res, size=32, greyscale=False, full_path=True):
	"""Returns path of a resource icon or placeholder path, if icon does not exist.
	@param res: resource id. Pass 'placeholder' to get placeholder path.
	@param full_path: whether to return full icon path or a stub path suitable for ImageButton path=
	"""
	icon_path = 'content/gui/icons/resources/{size}/'.format(size=size)
	if greyscale:
		icon_path = icon_path + 'greyscale/'
	if res == 'placeholder':
		icon_path = icon_path + 'placeholder.png'
	else:
		icon_path = icon_path + '{res:03d}.png'.format(res=res)

	try:
		Icon(image=icon_path)
	except RuntimeError: # ImageManager: image not found, use placeholder or die
		if res == 'placeholder':
			raise Exception('Image not found: {icon_path}'.format(icon_path=icon_path))
		else:
			log = logging.getLogger('gui')
			log.warning('Image not found: %s', icon_path)
			icon_path = get_res_icon_path('placeholder', size)

	if full_path:
		return icon_path
	else:
		# remove 'content/gui/' and '.png'
		return icon_path[12:][:-4]

def create_resource_icon(res_id, db):
	"""Creates a pychan Icon for a resource. Helptext is set to name of *res_id*.
	@param res_id: resource id
	@param db: dbreader for main db"""
	widget = Icon(image=get_res_icon_path(res_id))
	widget.helptext = db.get_res_name(res_id)
	return widget


def create_resource_selection_dialog(on_click, inventory, db,
                                     widget='select_trade_resource.xml', res_filter=None, amount_per_line=None):
	"""Returns a container containing resource icons.
	@param on_click: called with resource id as parameter on clicks
	@param inventory: to determine fill status of resource slots
	@param db: main db instance
	@param widget: which xml file to use as a template. Default: tabwidget. Required
	               since the resource bar also uses this code (no tabs there though).
	@param res_filter: callback to decide which icons to use. Default: show all
	@param amount_per_line: how many resource icons per line. Default: try to fit layout
	"""
	from horizons.gui.widgets.imagefillstatusbutton import ImageFillStatusButton
	dummy_icon_path = "icons/resources/none_gray"

	dlg = load_uh_widget(widget)

	icon_size = ImageFillStatusButton.ICON_SIZE # used for dummy button
	cell_size = ImageFillStatusButton.CELL_SIZE
	button_width = cell_size[0]
	vbox = dlg.findChild(name="resources")
	amount_per_line = amount_per_line or vbox.width // button_width
	# Add the zero element to the beginning that allows to remove the currently
	# sold/bought resource:
	resources = [0] + db.get_res(only_tradeable=True)
	current_hbox = HBox(name="hbox_0", padding=0)
	index = 1
	for res_id in resources:
		# don't show resources that are already in the list
		if res_filter is not None and not res_filter(res_id):
			continue

		# on click: add this res
		cb = Callback(on_click, res_id)

		# create button (dummy one or real one)
		if res_id == 0 or inventory is None:
			reset_button = ImageButton(max_size=icon_size, name="resource_icon_00")
			reset_button.path = dummy_icon_path

			button = Container(size=cell_size)
			# add the "No Resource" image to the container, positioned in the top left
			button.addChild(reset_button)
			# capture a mouse click on the container. It's possible to click on the
			# image itself or into the empty area (below or to the right of the image)
			button.capture(cb, event_name="mouseClicked")
			button.name = "resource_%d" % res_id
		else:
			amount = inventory[res_id]
			filled = int(float(inventory[res_id]) / float(inventory.get_limit(res_id)) * 100.0)
			button = ImageFillStatusButton.init_for_res(db, res_id,
						                                amount=amount, filled=filled, uncached=True,
						                                use_inactive_icon=False, showprice=True)
			button.button.capture(cb)
			button.button.name = "resource_%d" % res_id

		current_hbox.addChild(button)
		if index % amount_per_line == 0:
			vbox.addChild(current_hbox)
			box_id = index // amount_per_line
			current_hbox = HBox(name="hbox_%s" % box_id, padding=0)
		index += 1
	vbox.addChild(current_hbox)
	vbox.adaptLayout()

	return dlg
########NEW FILE########
__FILENAME__ = buysellinventory
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import HBox

from horizons.gui.widgets.imagefillstatusbutton import ImageFillStatusButton
from horizons.gui.widgets.inventory import Inventory

class BuySellInventory(Inventory):
	"""The buy/sell inventory widget displays an inventory of goods
	where the available resources are restricted. It makes use of the
	ImageFillStatusButton to display resource icons and the fill bar.
	It can be used like any other widget in xml files, but for full
	functionality the inventory has to be manually set, or use the
	TabWidget, which will autoset it (was made to be done this way).

	XML use: <BuySellInventory />, can take all parameters of an Inventory.
	Note that BuySellInventory has False as default value for display_legend
	where Inventory has True.
	"""
	def __init__(self, display_legend=False, **kwargs):
		super(BuySellInventory, self).__init__(display_legend=display_legend, **kwargs)

	def init(self, db, inventory, limits, selling):
		if self.init_needed(inventory, limits, selling):
			self._inited = True
			self.db = db
			self._inventory = inventory

			# Specific to BuySellInventory
			self._limits = limits
			self._selling = selling

		self.update()

	def init_needed(self, inventory, limits, selling):
		return super(BuySellInventory, self).init_needed(inventory) or \
		       self._limits != limits or self._selling != selling

	def _draw(self, vbox, current_hbox, index=0):
		"""Draws the inventory."""
		for resid, limit in sorted(self._limits.iteritems()):
			if self._selling:
				amount = max(0, self._inventory[resid] - limit)
			else:
				amount = max(0, limit - self._inventory[resid])

			# check if this res should be displayed
			button = ImageFillStatusButton.init_for_res(self.db, resid, amount,
			                                            filled=0, uncached=self.uncached)
			button.button.name = "buy_sell_inventory_%s_entry_%s" % (self._selling, index) # for tests
			current_hbox.addChild(button)

			if index % self.items_per_line == self.items_per_line - 1:
				vbox.addChild(current_hbox)
				current_hbox = HBox(padding=0)
			index += 1
		vbox.addChild(current_hbox)
		self.addChild(vbox)

########NEW FILE########
__FILENAME__ = container
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from fife.extensions.pychan.widgets import Container


class AutoResizeContainer(Container):
	"""A regular pychan container, that implements resizeToContent"""

	def resizeToContent(self):
		"""resizeToContent for unlayouted containers. Sets size to smallest box"""
		for child in self.children:
			child.adaptLayout() # recalc values for children

		max_x = max_y = 0
		for child in self.children:
			x = child.position[0] + child.size[0]
			y = child.position[1] + child.size[1]
			if x > max_x:
				max_x = x
			if y > max_y:
				max_y = y
		self.size = (max_x, max_y)

########NEW FILE########
__FILENAME__ = fpsdisplay
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import Label

import horizons.globals
from horizons.extscheduler import ExtScheduler
from horizons.gui.widgets.container import AutoResizeContainer


class FPSDisplay(AutoResizeContainer):
	"""Display the frames per second.

	Updates once a second if visible.
	"""

	def __init__(self):
		super(FPSDisplay, self).__init__()

		self._label = Label(text=u"- - -")
		self.addChild(self._label)
		self.stylize('menu')
		self.position_technique = "left:bottom"

		self._timemanager = horizons.globals.fife.engine.getTimeManager()

	def _update(self):
		fps = 1000 / self._timemanager.getAverageFrameTime()
		self._label.text = u"FPS: %.1f" % fps
		self.resizeToContent()
		self.toggle()  # hide and show again to fix position (pychan...)
		self.toggle()

	def show(self):
		ExtScheduler().add_new_object(self._update, self, loops=-1)
		return super(FPSDisplay, self).show()

	def hide(self):
		ExtScheduler().rem_call(self, self._update)
		return super(FPSDisplay, self).hide()

	def toggle(self):
		if self._visible:
			self.hide()
		else:
			self.show()

########NEW FILE########
__FILENAME__ = icongroup
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import HBox, Icon, VBox
from fife.extensions.pychan.widgets.common import IntAttr

class TilingBackground(object):
	"""The TilingBackground is a shortcut for several Icons combined to one group.
	It usually serves as auxiliary widget if a tiling background image is desired,
	but the layout also requires some kind of border around those tiling panels.
	Default attributes are set in the widgets inheriting from TilingBackground.
	"""
	def __init__(self, amount, base_path, start_img, tiles_img, final_img, **kwargs):
		super(TilingBackground, self).__init__()
		# Note: Don't set the tile amount in the constructor,
		# as it will not layout correctly, blame pychan for it :-)
		self.__tile_amount = amount
		self.start_img = base_path + start_img
		self.tiles_img = base_path + tiles_img
		self.final_img = base_path + final_img

	def _get_tile_amount(self):
		return self.__tile_amount

	def _set_tile_amount(self, amount):
		if amount == self.__tile_amount and amount > 0:
			# Default amount of 0 should still add top/bottom graphics once
			return
		self.__tile_amount = amount
		self.removeAllChildren()
		start_img = Icon(image=self.start_img, name=self.name + '0')
		self.addChild(start_img)
		for i in xrange(self.amount):
			mid = Icon(image=self.tiles_img, name=self.name + str(i+1))
			self.addChild(mid)
		self.addChild(Icon(image=self.final_img, name=self.name + str(self.amount+1)))

	amount = property(_get_tile_amount, _set_tile_amount)

class TooltipBG(VBox, TilingBackground):
	"""Not usable from xml!"""
	def __init__(self, **kwargs):
		VBox.__init__(self, name='tooltip_background', padding=0)
		TilingBackground.__init__(self,
			amount=0,
			base_path="content/gui/images/background/widgets/tooltip_bg_",
			start_img="top.png", tiles_img="middle.png", final_img="bottom.png",
			**kwargs)

class TabBG(VBox, TilingBackground):
	"""Intended to be used for any tab we display.
	Uses content/gui/images/tabwidget/main_bg_*.png.
	@param amount: amount of 50px tiles/panels in between top and bottom icon
	"""
	ATTRIBUTES = VBox.ATTRIBUTES + [IntAttr('amount')]
	def __init__(self, **kwargs):
		VBox.__init__(self, name='tab_background_icons', padding=0)
		TilingBackground.__init__(self,
			amount=0,
			base_path="content/gui/images/tabwidget/main_bg_",
			start_img="top.png", tiles_img="fill.png", final_img="bottom.png",
			**kwargs)

class TilingHBox(HBox, TilingBackground):
	"""Currently mostly used by cityinfo, thus using its arguments as defaults.

	Another use case is the TilingProgressBar.
	@param amount: amount of 10px tiles/panels in between left and right icon
	"""
	ATTRIBUTES = HBox.ATTRIBUTES + [IntAttr('amount')]
	def __init__(self, **kwargs):
		HBox.__init__(self, name='city_info_background', padding=0)
		TilingBackground.__init__(self,
			amount=0,
			base_path="content/gui/images/background/widgets/cityinfo_",
			start_img="left.png", tiles_img="fill.png", final_img="right.png",
			**kwargs)


class hr(Icon):
	def __init__(self, **kwargs):
		super(hr, self).__init__(image="content/gui/images/background/hr.png", **kwargs)

########NEW FILE########
__FILENAME__ = imagebutton
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import Icon, ImageButton as FifeImageButton
from fife.extensions.pychan.widgets.common import Attr


class ImageButton(FifeImageButton):
	"""Extends ImageButton functionality by providing a new path= attribute.
	Unless manually overridden, specifying path="path/to/file" (note: no .png
	extension) will interpret that as these attributes:

	      up_image = "content/gui/path/to/file.png"
	    down_image = "content/gui/path/to/file_d.png"
	   hover_image = "content/gui/path/to/file_h.png"
	inactive_image = "content/gui/path/to/file_bw.png" ("black/white")

	Other possible names also checked are
	      up_image = "content/gui/path/to/file_u.png" ("up", for tabwidget)
	inactive_image = "content/gui/path/to/file_gr.png" ("grayscale")

	If some of those files could not be found, we use up_image instead.
	Sets is_focusable to False unless overridden.

	You can set the button active or inactive (only in code for now).
	Setting to inactive will change *all* images (up, down and hover) to the
	inactive image. If you set it active again, everything will be reset.
	"""
	ATTRIBUTES = FifeImageButton.ATTRIBUTES + [Attr('path'), Attr('inactive_image')]
	IMAGE = "content/gui/{path}{{mode}}.png"
	# These two constants are used to describe the toggle state of the widget.
	ACTIVE = 0
	INACTIVE = 1

	def __init__(self, path='', inactive_image=None, is_focusable=False, **kwargs):
		super(ImageButton, self).__init__(is_focusable=is_focusable, **kwargs)
		self.old_images = (None, None, None)
		if path:
			# initializing from python, not xml, so path is available here
			# and should be set
			self.path = path
		if inactive_image:
			self.inactive_image = inactive_image
		self.state = self.ACTIVE

	def toggle(self):
		if self.is_active:
			self.set_inactive()
		else:
			self.set_active()

	def set_active(self):
		"""Sets the button active. Restores up, down and hover image to
		previous state."""
		if self.is_active:
			return
		self.up_image, self.down_image, self.hover_image = self.old_images
		self.state = self.ACTIVE

	def set_inactive(self):
		"""Sets the button inactive. Overrides up, down and hover image with
		inactive image."""
		if not self.is_active:
			# running this with inactive state would overwrite all elements
			# of old_images with inactive_image
			return
		# store old images to be reloaded when button is set active again
		self.old_images = (self.up_image, self.down_image, self.hover_image)
		self.up_image = self.down_image = self.hover_image = self.inactive_image
		self.state = self.INACTIVE

	@property
	def is_active(self):
		return (self.state == self.ACTIVE)

	def _get_path(self):
		return self.__path

	def _set_path(self, path):
		self.__path = path
		image_path = self.IMAGE.format(path=path)
		try:
			self.up_image = image_path.format(mode='')
		except RuntimeError:
			# RuntimeError: _[NotFound]_ , Something was searched, but not found
			#TODO Temporarily try to find _u for the tabwidget
			self.up_image = image_path.format(mode='_u')
		try:
			self.hover_image = image_path.format(mode='_h')
		except RuntimeError:
			# By default, guichan/pychan will set hover_image to be the same as
			# up_image even if it is not explicitly set here (the following line
			# just reading `pass` instead of setting hover_image to up_image).
			# This however is stored internally in a way that would segfault FIFE
			# when trying to restore images from self.old_images that were set
			# like that implicitly (see #2000).
			self.hover_image = self.up_image
		try:
			self.down_image = image_path.format(mode='_d')
		except RuntimeError:
			self.down_image = self.up_image

		# Since inactive_image is no image attribute in pychan, it would
		# not be validated upon setting self.inactive_image (which works
		# for ImageButton.{up,down,hover}_image and Icon.image).
		# Instead, we try to load an Icon with that image and manually
		# set inactive_image to the path that worked, if there is any.
		try:
			image = image_path.format(mode='_bw')
			Icon(image=image)
			self.inactive_image = image
		except RuntimeError:
			try:
				image = image_path.format(mode='_gr')
				Icon(image=image)
				self.inactive_image = image
			except RuntimeError:
				self.inactive_image = self.up_image

	path = property(_get_path, _set_path)


class OkButton(ImageButton):
	"""The OkButton is a shortcut for an ImageButton with our OK / apply icon.
	Its default attributes are:
	name="okButton" path="images/buttons/ok"
	"""
	DEFAULT_NAME = 'okButton'
	def __init__(self, name=None, **kwargs):
		if name is None:
			name = self.__class__.DEFAULT_NAME
		size = (34, 40)
		super(OkButton, self).__init__(
			name=name, is_focusable=False,
			max_size=size, min_size=size, size=size, **kwargs)
		self.path = "images/buttons/ok"
		self.inactive_image = "content/gui/images/buttons/close.png"

class CancelButton(ImageButton):
	"""The CancelButton is a shortcut for an ImageButton with our cancel / close
	icon. Its default attributes are:
	name="cancelButton" path="images/buttons/close"
	"""
	DEFAULT_NAME = 'cancelButton'
	def __init__(self, name=None, **kwargs):
		if name is None:
			name = self.__class__.DEFAULT_NAME
		size = (34, 40)
		super(CancelButton, self).__init__(
			name=name, is_focusable=False,
			max_size=size, min_size=size, size=size, **kwargs)
		self.path = "images/buttons/close"

class DeleteButton(ImageButton):
	"""The DeleteButton is a shortcut for an ImageButton with our delete / tear
	icon. Its default attributes are:
	name="deleteButton" path="images/buttons/delete"
	"""
	DEFAULT_NAME = 'deleteButton'
	def __init__(self, name=None, **kwargs):
		if name is None:
			name = self.__class__.DEFAULT_NAME
		size = (34, 40)
		super(DeleteButton, self).__init__(
			name=name, is_focusable=False,
			max_size=size, min_size=size, size=size, **kwargs)
		self.path = "images/buttons/delete"


class MainmenuButton(ImageButton):
	"""For use in main menu. bw: whether to use greyscale or color."""

	ATTRIBUTES = ImageButton.ATTRIBUTES + [Attr('icon')]
	ICON = "content/gui/icons/mainmenu/{icon}{bw}.png"

	def __init__(self, icon='door', **kwargs):
		super(MainmenuButton, self).__init__(is_focusable=False, **kwargs)
		self.icon = icon

	def _get_icon(self):
		return self.__icon

	def _set_icon(self, icon):
		self.__icon = icon
		self.up_image = self.ICON.format(icon=icon, bw='_bw')
		self.hover_image = self.down_image = self.ICON.format(icon=icon, bw='')

	icon = property(_get_icon, _set_icon)

########NEW FILE########
__FILENAME__ = imagefillstatusbutton
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import Container, Icon, Label

from horizons.constants import TRADER
from horizons.util.python.callback import Callback
from horizons.gui.util import get_res_icon_path
from horizons.gui.widgets.imagebutton import ImageButton

class ImageFillStatusButton(Container):

	ICON_SIZE = (32, 32)
	CELL_SIZE = (54, 50) # 32x32 icon, fillbar to the right, label below, padding
	PADDING = 3

	def __init__(self, path, text, res_id, helptext="",
	             filled=0, marker=0, uncached=False, **kwargs):
		"""Represents the image in the ingame gui, with a bar to show how full
		the inventory is for that resource. Derives from Container and also takes
		all arguments of Imagebutton in order to display the resource icon.
		This is meant to be used with the Inventory widget."""
		super(ImageFillStatusButton, self).__init__(**kwargs)
		self.path = path
		self.text = text
		self.helptext = _(helptext)
		# res_id is used by the TradeTab for example to determine the resource this button represents
		self.res_id = res_id
		self.text_position = (9, 30)
		self.marker = marker
		# force no cache. needed when the same icon has to appear several times at the same time
		self.uncached = uncached
		# Since draw() needs all other stuff initialized, only set this in the end:
		self.filled = filled # <- black magic at work! this calls _draw()

	@classmethod
	def init_for_res(cls, db, res, amount=0, filled=0, marker=0, use_inactive_icon=True, uncached=False, showprice=False):
		"""Inites the button to display the icons for res
		@param db: dbreader to get info about res icon.
		@param res: resource id
		@param amount: int amount of res (used to decide inactiveness and as text)
		@param filled: percent of fill status (values are ints in [0, 100])
		@param use_inactive_icon: whether to use inactive icon if amount == 0
		@param uncached: force no cache. see __init__()
		@return: ImageFillStatusButton instance"""
		greyscale = use_inactive_icon and amount == 0
		path = get_res_icon_path(res, cls.ICON_SIZE[0], greyscale, full_path=False)

		if showprice:
			value = db.get_res_value(res)
			if TRADER.PRICE_MODIFIER_BUY == TRADER.PRICE_MODIFIER_SELL:
				helptext = _('{resource_name}: {price} gold').format(resource_name=db.get_res_name(res), price=db.get_res_value(res))
			else:
				buyprice = value * TRADER.PRICE_MODIFIER_BUY
				sellprice = value * TRADER.PRICE_MODIFIER_SELL
				helptext = (u'{resource_name}[br]'.format(resource_name=db.get_res_name(res))
				            + _('buy for {buyprice} gold').format(buyprice=buyprice)
				            + u'[br]'
				            + _('sell for {sellprice} gold').format(sellprice=sellprice))
		else:
			helptext = db.get_res_name(res)

		return cls(path=path, text=unicode(amount), helptext=helptext,
		           size=cls.CELL_SIZE, res_id=res, filled=filled,
		           max_size=cls.CELL_SIZE, min_size=cls.CELL_SIZE,
		           marker=marker, uncached=uncached)

	def _set_filled(self, percent):
		""""@param percent: int percent that fillstatus will be green"""
		self._filled = percent
		self._draw()

	def _get_filled(self):
		return self._filled

	filled = property(_get_filled, _set_filled)

	__widget_cache = {}
	def _draw(self):
		"""Draws the icon + bar."""
		# hash buttons by creation function call
		# NOTE: there may be problems with multiple buttons with the same
		# images and helptext at the same time
		create_btn = Callback(ImageButton, path=self.path, helptext=self.helptext)
		self.button = None
		if self.uncached:
			self.button = create_btn()
		else:
			self.button = self.__widget_cache.get(create_btn, None)
			if self.button is None: # create button
				self.__widget_cache[create_btn] = self.button = create_btn()
			else: # disconnect button from earlier layout
				if self.button.parent:
					self.button.parent.removeChild(self.button)

		# can't cache the other instances, because we need multiple instances
		# with the same data active at the same time
		self.label = Label(text=self.text)
		self.label.position = self.text_position
		self.fill_bar = Icon(image="content/gui/images/tabwidget/green_line.png")
		fill_level = (self.button.height * self.filled) // 100
		self.fill_bar.size = ((2 * self.fill_bar.size[0]) // 3, fill_level)
		# move fillbar down after resizing, since its origin is top aligned
		self.fill_bar.position = (self.button.width, self.button.height - fill_level)
		self.addChildren(self.button, self.fill_bar, self.label)
		if self.marker > 0:
			marker_icon = Icon(image="content/gui/icons/templates/production/marker.png")
			marker_level = (self.button.height * self.marker) // 100
			marker_icon.position = (self.button.width - 1, self.button.height - marker_level)
			marker_icon.max_size = (5, 1)
			self.addChild(marker_icon)

########NEW FILE########
__FILENAME__ = inventory
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import Container, HBox, Icon, Label, VBox
from fife.extensions.pychan.widgets.common import BoolAttr, IntAttr

from horizons.gui.widgets.imagefillstatusbutton import ImageFillStatusButton
from horizons.world.storage import TotalStorage, PositiveSizedSlotStorage, PositiveTotalNumSlotsStorage

class Inventory(Container):
	"""The inventory widget displays information about the goods in
	a Storage. It uses ImageFillStatusButtons to display icons and
	a fill bar for these resources.
	It can be used like any other widget in xml files, but for full
	functionality the inventory has to be manually set, or use the
	TabWidget, which will autoset it (was made to be done this way).

	XML use: <Inventory />, can take all parameters of a Container.
	"""
	ATTRIBUTES = Container.ATTRIBUTES + [BoolAttr('uncached'),
	                                     BoolAttr('display_legend'),
	                                     IntAttr("items_per_line")]
	# uncached: required when resource icons should appear multiple times at any given moment
	# on the screen. this is usually not the case with single inventories, but e.g. for trading.
	# display_legend: whether to display a string explanation about slot limits

	UNUSABLE_SLOT_IMAGE = "content/gui/icons/resources/none_gray.png"

	def __init__(self, uncached=False, display_legend=True, items_per_line=4, **kwargs):
		# this inits the gui part of the inventory. @see init().
		super(Inventory, self).__init__(**kwargs)
		self._inventory = None
		self._inited = False
		self.uncached = uncached
		self.display_legend = display_legend
		self.items_per_line = items_per_line or 1 # negative values are fine, 0 is not

	def init_needed(self, inventory):
		return not self._inited or self._inventory is not inventory

	def init(self, db, inventory, ordinal=None):
		"""This inits the logic of the inventory. @see __init__().
		@param ordinal: {res: (min, max)} Display ordinal scale with these boundaries instead of numbers for a particular resource. Currently implemented via ImageFillStatusButton.
		"""
		# check if we must init everything anew
		if self.init_needed(inventory):
			self._inited = True
			self.db = db
			self._inventory = inventory

			# specific to Inventory
			self.ordinal = ordinal
			self._res_order = sorted(self._inventory.iterslots())
			self.legend = Label(name="legend")
			self.__icon = Icon(name="legend_icon")
			self.__icon.image = "content/gui/icons/ship/civil_16.png"
			if isinstance(self._inventory, TotalStorage):
				self.__icon.position = (130, 53)
				self.legend.position = (150, 53)
			elif isinstance(self._inventory, PositiveSizedSlotStorage):
				self.__icon.position = ( 0, 248)
				self.legend.position = (20, 248)

		self.update()

	def update(self):
		self.removeAllChildren()
		if self.display_legend:
			self.addChildren(self.__icon, self.legend)
		vbox = VBox(padding=0)
		vbox.width = self.width
		current_hbox = HBox(padding=0)

		# draw the content
		self._draw(vbox, current_hbox)

		self.adaptLayout()

	def _draw(self, vbox, current_hbox, index=0):
		"""Draws the inventory."""
		# add res to res order in case there are new ones
		# (never remove old ones for consistent positioning)
		new_res = sorted( resid for resid in self._inventory.iterslots() if resid not in self._res_order )

		if isinstance(self._inventory, PositiveTotalNumSlotsStorage):
			# limited number of slots. We have to switch unused slots with newly added ones on overflow

			while len(self._res_order) + len(new_res) > self._inventory.slotnum:
				for i in xrange(self._inventory.slotnum):
					if len(self._res_order) <= i or self._inventory[self._res_order[i]]:
						# search empty slot
						continue
					# insert new res here
					self._res_order[i] = new_res.pop(0)
					if not new_res:
						break # all done

		# add remaining slots for slotstorage or just add it without consideration for other storage kinds
		self._res_order += new_res

		for resid in self._res_order:
			# check if this res should be displayed
			if not self.db.cached_query('SELECT shown_in_inventory FROM resource WHERE id = ?', resid)[0][0]:
				continue

			amount = self._inventory[resid]

			if self.ordinal:
				lower, upper = self.ordinal.get(resid, (0, 100))
				filled = (100 * (amount - lower)) // (upper - lower)
				amount = "" # do not display exact information for resource deposits
			elif isinstance(self._inventory, TotalStorage):
				filled = 0
			else:
				filled = (100 * amount) // self._inventory.get_limit(resid)

			button = ImageFillStatusButton.init_for_res(self.db, resid, amount,
			                                            filled=filled, uncached=self.uncached)
			button.button.name = "inventory_entry_%s" % index # required for gui tests
			current_hbox.addChild(button)

			if index % self.items_per_line == self.items_per_line - 1:
				vbox.addChild(current_hbox)
				current_hbox = HBox(padding=0)
			index += 1
		if index <= self.items_per_line: # Hide/Remove second line
			icons = self.parent.findChildren(name='slot')
			if len(icons) > self.items_per_line:
				self.parent.removeChildren(icons[self.items_per_line-1:])
		vbox.addChild(current_hbox)
		self.addChild(vbox)
		height = ImageFillStatusButton.CELL_SIZE[1] * len(self._res_order) // self.items_per_line
		self.min_size = (self.min_size[0], height)

		if isinstance(self._inventory, TotalStorage):
			# if it's full, the additional slots have to be marked as unusable (#1686)
			# check for any res, the res type doesn't matter here
			if not self._inventory.get_free_space_for(0):
				for i in xrange(index, self.items_per_line):
					button = Icon(image=self.__class__.UNUSABLE_SLOT_IMAGE)
					# set min & max_size to prevent pychan to expand this dynamic widget (icon)
					button.min_size = button.max_size = ImageFillStatusButton.ICON_SIZE
					current_hbox.addChild(button)

		if self.display_legend:
			limit = self._inventory.get_limit(None)
			if isinstance(self._inventory, TotalStorage):
				# Add total storage indicator
				sum_stored = self._inventory.get_sum_of_stored_resources()
				self.legend.text = _('{stored}/{limit}').format(stored=sum_stored, limit=limit)
			elif isinstance(self._inventory, PositiveSizedSlotStorage):
				self.legend.text = _('Limit: {amount}t per slot').format(amount=limit)

	def apply_to_buttons(self, action, filt=None):
		"""Applies action to all buttons shown in inventory
		@param action: function called that touches button
		@param filt: function used to filter the buttons
		both functions take one parameter which is the button
		"""
		if filt:
			assert callable(filt)
		assert callable(action)

		def _find_widget(widget):
			if isinstance(widget, ImageFillStatusButton):
				if filt is None or filt(widget):
					action(widget)
		self.deepApply(_find_widget)

########NEW FILE########
__FILENAME__ = logbook
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

import json
from itertools import groupby
from fife.extensions.pychan.widgets import HBox, Icon, Label

from horizons.util.python.callback import Callback
from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.command.game import UnPauseCommand
from horizons.command.misc import Chat
from horizons.gui.widgets.pickbeltwidget import PickBeltWidget
from horizons.gui.widgets.imagebutton import OkButton
from horizons.gui.windows import Window
from horizons.scenario.actions import show_message


class LogBook(PickBeltWidget, Window):
	"""Implementation of the logbook as described here:
	http://wiki.unknown-horizons.org/w/Message_System

	It displays longer messages, which are essential for scenarios.
	Headings can be specified for each entry.
	"""
	log = logging.getLogger('gui.widgets.logbook')

	widget_xml = 'captains_log.xml'
	page_pos = (170, 38)
	sections = (('logbook', _('Logbook')),
	            ('statistics', _('Statistics')),
	            ('chat_overview', _('Chat')))

	def __init__(self, session, windows):
		self.statistics_index = [i for i, sec in self.sections].index('statistics')
		self.logbook_index = [i for i, sec in self.sections].index('logbook')
		self._page_ids = {} # dict mapping self._cur_entry to message.msgcount
		super(LogBook, self).__init__()
		self.session = session
		self._windows = windows
		self._parameters = [] # list of lists of all parameters added to a logbook page
		self._message_log = [] # list of all messages that have been displayed
		self._messages_to_display = [] # list messages to display on page close
		self._displayed_messages = [] # list of messages that were already displayed
		self._cur_entry = None # remember current location; 0 to len(messages)-1
		self._hiding_widget = False # True if and only if the widget is currently in the process of being hidden
		self.stats_visible = None
		self.last_stats_widget = 'players'
		self.current_mode = 0 # used to determine if the logbook is on the statistics page
		self._init_gui()

#		self.add_captainslog_entry([
#		  ['Headline', "Heading"],
#		  ['Image', "content/gui/images/background/hr.png"],
#		  ['Label', "Welcome to the Captain's log"],
#		  ['Label', "\n\n"],
#			]) # test code

	def _init_gui(self):
		"""Initial gui setup for all subpages accessible through pickbelts."""
		self._gui = self.get_widget()
		self._gui.mapEvents({
		  OkButton.DEFAULT_NAME : self._windows.close,
		  'backwardButton' : Callback(self._scroll, -2),
		  'forwardButton' : Callback(self._scroll, 2),
		  'stats_players' : Callback(self.show_statswidget, widget='players'),
		  'stats_settlements' : Callback(self.show_statswidget, widget='settlements'),
		  'stats_ships' : Callback(self.show_statswidget, widget='ships'),
		  'chatTextField' : self._send_chat_message,
		  })

		# stuff in the game message / chat history subwidget
		self.textfield = self._gui.findChild(name="chatTextField")
		self.textfield.capture(self._chatfield_onfocus, 'mouseReleased', 'default')
		self.chatbox = self._gui.findChild(name="chatbox")
		self.messagebox = self._gui.findChild(name="game_messagebox")
		#self._display_chat_history() # initially print all loaded messages
		#self._display_message_history()

		# these buttons flip pages in the captain's log if there are more than two
		self.backward_button = self._gui.findChild(name="backwardButton")
		self.forward_button = self._gui.findChild(name="forwardButton")
		self._redraw_captainslog()

	def update_view(self, number=0):
		""" update_view from PickBeltWidget, cleaning up the logbook subwidgets
		"""
		self.current_mode = number

		# self.session might not exist yet during callback setup for pickbelts
		if hasattr(self, 'session'):
			self._hide_statswidgets()
		if self.statistics_index == number:
			self.show_statswidget(self.last_stats_widget)
		super(LogBook, self).update_view(number)

	def save(self, db):
		db("INSERT INTO logbook(widgets) VALUES(?)", json.dumps(self._parameters))
		for message in self._message_log:
			db("INSERT INTO logbook_messages(message) VALUES(?)", message)
		db("INSERT INTO metadata(name, value) VALUES(?, ?)",
		   "logbook_cur_entry", self._cur_entry)

	def load(self, db):
		db_data = db("SELECT widgets FROM logbook")
		widget_list = json.loads(db_data[0][0] if db_data else "[]")
		for widgets in widget_list:
			self.add_captainslog_entry(widgets, show_logbook=False)

		for msg in db("SELECT message FROM logbook_messages"):
			self._message_log.append(msg[0]) # each line of the table is one tuple
		# wipe self._messages_to_display on load, otherwise all previous messages get displayed
		self._messages_to_display = []
		self._displayed_messages = []

		value = db('SELECT value FROM metadata WHERE name = "logbook_cur_entry"')
		if (value and value[0] and value[0][0]):
			self.set_cur_entry(int(value[0][0])) # this also redraws

	def show(self, msg_id=None):
		if not hasattr(self, '_gui'):
			self._init_gui()
		if msg_id:
			self._cur_entry = self._page_ids[msg_id]
		if not self.is_visible():
			self._gui.show()
			self._redraw_captainslog()
			if self.current_mode == self.statistics_index:
				self.show_statswidget(self.last_stats_widget)

	def hide(self):
		if not self._hiding_widget:
			self._hiding_widget = True
			self._hide_statswidgets()
			self._gui.hide()
			self._hiding_widget = False

			for message in self._messages_to_display:
				# show all messages (except those already displayed) and map them to the current logbook page
				if message in self._displayed_messages:
					continue
				for msg_id in show_message(self.session, "logbook", message):
					self._page_ids[msg_id] = self._cur_entry
					self._displayed_messages.append(message)

			self._message_log.extend(self._messages_to_display)
			self._messages_to_display = []
		# Make sure the game is unpaused always and in any case
		UnPauseCommand(suggestion=False).execute(self.session)

	def is_visible(self):
		return hasattr(self, '_gui') and self._gui.isVisible()

	def _redraw_captainslog(self):
		"""Redraws gui. Necessary when current message has changed."""
		if self._parameters: # there is something to display if this has items
			self._display_parameters_on_page(self._parameters[self._cur_entry], 'left')
			if self._cur_entry+1 < len(self._parameters): # check for content on right page
				self._display_parameters_on_page(self._parameters[self._cur_entry+1], 'right')
			else:
				self._display_parameters_on_page([], 'right') # display empty page
		else:
			self._display_parameters_on_page([
			  ['Headline', _("Emptiness")],
			  ['Image', "content/gui/images/background/hr.png"],
			  ['Label', u"\n\n"],
			  ['Label', _('There is nothing written in your logbook yet!')],
				], 'left')
		self.backward_button.set_active()
		self.forward_button.set_active()
		if not self._parameters or self._cur_entry == 0:
			self.backward_button.set_inactive()
		if not self._parameters or self._cur_entry >= len(self._parameters) - 2:
			self.forward_button.set_inactive()
		self._gui.adaptLayout()


########
#        LOGBOOK  SUBWIDGET
########

	def parse_logbook_item(self, parameter):
		# Some error checking for widgets that are to be loaded.
		# This happens, for example, with outdated YAML stored in old
		# scenario savegames. Instead of crashing, display nothing.
		def _icon(image):
			try:
				# Pychan can only use str objects as file path.
				# json.loads() however returns unicode.
				return Icon(image=str(image))
			except RuntimeError:
				return None

		def _label(text, font='default'):
			try:
				return Label(text=unicode(text), wrap_text=True,
				             min_size=(335, 0), max_size=(335, 508),
				             font=font)
			except RuntimeError:
				return None

		if parameter and parameter[0]: # allow empty Labels
			parameter_type = parameter[0]
		if isinstance(parameter, basestring):
			add = _label(parameter)
		elif parameter_type == u'Label':
			add = _label(parameter[1])
		elif parameter_type == u'Image':
			add = _icon(parameter[1])
		elif parameter_type == u'Gallery':
			add = HBox()
			for image in parameter[1]:
				new_icon = _icon(image)
				if new_icon is not None:
					add.addChild(new_icon)
		elif parameter_type == u'Headline':
			add = HBox()
			is_not_last_headline = self._parameters and self._cur_entry < (len(self._parameters) - 2)
			if is_not_last_headline:
				add.addChild(_icon("content/gui/images/tabwidget/done.png"))
			add.addChild(_label(parameter[1], font='headline'))
		elif parameter_type == u'BoldLabel':
			add = _label(parameter[1], font='default_bold')
		elif parameter_type == u'Message':
			add = None
			# parameters are re-read on page reload.
			# duplicate_message stops messages from
			# being duplicated on page reload.
			message = parameter[1]
			# message is already going to be displayed or has been displayed
			# before (e.g. re-opening older logbook pages)
			duplicate_message = (message in self._messages_to_display or
								message in self._message_log)

			if not duplicate_message:
				self._messages_to_display.append(message) # the new message has not been displayed
		else:
			self.log.warning('Unknown parameter type %s in parameter %s',
			                 parameter[0], parameter)
			add = None
		return add

	def _display_parameters_on_page(self, parameters, page):
		"""
		@param parameters: parameter list, cf. docstring of add_captainslog_entry
		@param page: 'left' or 'right'
		"""
		parameterbox = self._gui.findChild(name="custom_widgets_{page}".format(page=page))
		parameterbox.removeAllChildren()
		for parameter_definition in parameters:
			add = self.parse_logbook_item(parameter_definition)
			if add is not None:
				parameterbox.addChild(add)

	def add_captainslog_entry(self, parameters, show_logbook=True):
		"""Adds an entry to the logbook VBoxes consisting of a parameter list.
		Check e.g. content/scenarios/tutorial_en.yaml for real-life usage.

		@param parameters: Each item in here is a list like the following:
		[Label, "Awesome text to be displayed as a label"]
		"Shortcut notation for a Label"
		[Headline, "Label to be styled as headline (in small caps)"]
		[BoldLabel, "Like Label but with bold font, use to highlight lines"]
		[Image, "content/gui/images/path/to/the/file.png"]
		[Gallery, ["/path/1.png", "/path/file.png", "/file/3.png"]]
		[Message, "Text to display as a notification on logbook close"]
		[Pagebreak]
		"""
		#TODO last line of message text sometimes get eaten. Ticket #535
		def _split_on_pagebreaks(parameters):
			"""This black magic splits the parameter list on each ['Pagebreak']
			>> [['a','a'], ['b','b'], ['Pagebreak'], ['c','c'], ['d','d']]
			>>>> into [[['a', 'a'], ['b', 'b']], [['c', 'c'], ['d', 'd']]]
			#TODO n successive pagebreaks should insert (n-1) blank pages (currently 0 are inserted)
			"""
			return [list(l[1]) for l in groupby(parameters, lambda x: x != ['Pagebreak']) if l[0]]

		# If a scenario goal has been completed, remove the corresponding message
		for message in self._displayed_messages:
			self.session.ingame_gui.message_widget.remove(message)

		self._displayed_messages = [] # Reset displayed messages
		for parameter_list in _split_on_pagebreaks(parameters):
			self._parameters.append(parameter_list)
			for parameter_definition in parameter_list:
				self.parse_logbook_item(parameter_definition)
		# if a new entry contains more than one page, we want to display the first
		# unread message. note that len(parameters) starts at 1 and _cur_entry at 0.
		# position always refers to the left page, so only multiples of 2 are valid
		len_old = len(self._parameters) - len(_split_on_pagebreaks(parameters))
		if len_old % 2 == 1: # uneven amount => empty last page, space for 1 new
			self._cur_entry = len_old - 1
		else: # even amount => all pages filled. we could display two new messages
			self._cur_entry = len_old
		if show_logbook and hasattr(self, "_gui"):
			self._redraw_captainslog()
			self._windows.open(self)
			self.show_logbookwidget()

	def clear(self):
		"""Remove all entries"""
		self._parameters = []
		self._cur_entry = None

	def get_cur_entry(self):
		return self._cur_entry

	def set_cur_entry(self, cur_entry):
		if cur_entry < 0 or cur_entry >= len(self._parameters):
			raise ValueError
		self._cur_entry = cur_entry
		self._redraw_captainslog()

	def _scroll(self, direction):
		"""Scroll back or forth one message.
		@param direction: -1 or 1"""
		if not self._parameters:
			return
		new_cur = self._cur_entry + direction
		if new_cur < 0 or new_cur >= len(self._parameters):
			return # invalid scroll
		self._cur_entry = new_cur
		AmbientSoundComponent.play_special('flippage')
		self._redraw_captainslog()

	def show_logbookwidget(self):
		"""Shows logbook with Logbook page selected"""
		if self.current_mode != self.logbook_index:
			self.update_view(self.logbook_index)

########
#        STATISTICS  SUBWIDGET
########
#
#TODO list:
#  [ ] Extract this stuff to extra widget class that properly handles all the
#      hide and save calls
#  [ ] fix stats show/hide mess: how is update_view called before self.__init__
#  [ ] save last shown stats widget and re-show it when clicking on Statistics
#  [ ] semantic distinction between general widget and subwidgets (log, stats)
#
########

	def show_statswidget(self, widget='players'):
		"""Shows logbook with Statistics page selected"""
		if self.current_mode != self.statistics_index:
			self.update_view(self.statistics_index)
		self._hide_statswidgets()
		if widget:
			getattr(self, '_show_{widget}'.format(widget=widget))()
			self.stats_visible = widget
			self.last_stats_widget = widget

	def toggle_stats_visibility(self, widget='players'):
		"""
		Only hides logbook if hotkey of current stats selection pressed.
		Otherwise, switch to displaying the new widget instead of hiding.
		@param widget: 'players' or 'settlements' or 'ships'
		"""
		# we're treating every statswidget as a separate window, so if the stats change,
		# close the logbook and reopen it with a different active widget
		if self.stats_visible != widget:
			if self.stats_visible:
				self._windows.close()

			self._windows.open(self)
			self.show_statswidget(widget=widget)
		else:
			self._windows.close()

	def _show_ships(self):
		self.session.ingame_gui.players_ships.show()

	def _show_settlements(self):
		self.session.ingame_gui.players_settlements.show()

	def _show_players(self):
		self.session.ingame_gui.players_overview.show()

	def _hide_statswidgets(self):
		statswidgets = [
		  self.session.ingame_gui.players_overview,
		  self.session.ingame_gui.players_ships,
		  self.session.ingame_gui.players_settlements,
		  ]
		for statswidget in statswidgets:
			# we don't care which one is shown currently (if any), just hide all of them
			statswidget.hide()
		self.stats_visible = None



########
#        MESSAGE  AND  CHAT  HISTORY  SUBWIDGET
########
#
#TODO list:
#  [ ] use message bus to check for new updates
#  [ ] only display new message on update, not reload whole history
#  [x] update message history on new game messages. not on sending a chat line
#  [ ] implement word wrapping for message history display
#
########

	def _send_chat_message(self):
		"""Sends a chat message. Called when user presses enter in the input field"""
		msg = self.textfield.text
		if msg:
			Chat(msg).execute(self.session)
			self.textfield.text = u''
		self._display_chat_history()

	def display_message_history(self):
		self.messagebox.items = []
		messages = self.session.ingame_gui.message_widget.active_messages + \
		        self.session.ingame_gui.message_widget.archive
		for msg in sorted(messages, key=lambda m: m.created):
			if msg.id != 'CHAT': # those get displayed in the chat window instead
				self.messagebox.items.append(msg.message)
		self.messagebox.selected = len(self.messagebox.items) - 1 # scroll to bottom

	def _display_chat_history(self):
		self.chatbox.items = []
		messages = self.session.ingame_gui.message_widget.chat
		for msg in sorted(messages, key=lambda m: m.created):
			self.chatbox.items.append(msg.message)
		self.chatbox.selected = len(self.chatbox.items) - 1 # scroll to bottom

	def _chatfield_onfocus(self):
		"""Removes text in chat input field when it gets focused."""
		self.textfield.text = u''
		self.textfield.capture(None, 'mouseReleased', 'default')

########NEW FILE########
__FILENAME__ = messagewidget
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import textwrap
import itertools

from fife.extensions.pychan.widgets import Icon

import horizons.globals

from horizons.extscheduler import ExtScheduler
from horizons.util.living import LivingObject
from horizons.util.python.callback import Callback
from horizons.util.shapes import Point
from horizons.scheduler import Scheduler
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.imagebutton import ImageButton
from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.i18n.voice import get_speech_file


class MessageWidget(LivingObject):
	"""Class that organizes the messages. Displayed on left screen edge.
	It uses _IngameMessage instances to store messages and manages the archive.
	"""

	BG_IMAGE_MIDDLE = 'content/gui/images/background/widgets/message_bg_middle.png'
	IMG_HEIGHT = 24 # distance of above segments in px.
	LINE_HEIGHT = 17
	ICON_TEMPLATE = 'messagewidget_icon.xml'
	MSG_TEMPLATE = 'messagewidget_message.xml'
	CHARS_PER_LINE = 31 # character count after which we start new line. no wrap
	SHOW_NEW_MESSAGE_TEXT = 7 # seconds
	MAX_MESSAGES = 5

	_DUPLICATE_TIME_THRESHOLD = 10 # sec
	_DUPLICATE_SPACE_THRESHOLD = 8 # distance

	OVERVIEW_WIDGET = 'messagewidget_overview.xml'

	log = logging.getLogger('gui.widgets.messagewidget')

	def __init__(self, session):
		super(MessageWidget, self).__init__()
		self.session = session
		self.active_messages = [] # for displayed messages
		self.archive = [] # messages, that aren't displayed any more
		self.chat = [] # chat messages sent by players
		self.msgcount = itertools.count() # sort to preserve order after loading

		self.widget = load_uh_widget(self.ICON_TEMPLATE)
		screenheight = horizons.globals.fife.engine_settings.getScreenHeight()
		self.widget.position = (5, (screenheight // 2) - (self.widget.size[1] // 2))

		self.text_widget = load_uh_widget(self.MSG_TEMPLATE)
		self.reference_text_widget_position = (self.widget.x + self.widget.width, self.widget.y)

		self.widget.show()
		ExtScheduler().add_new_object(self.tick, self, loops=-1)
		# buttons to toggle through messages

		self._last_message = {} # used to detect fast subsequent messages in add()
		self.draw_widget()

	def add(self, string_id, point=None, msg_type=None, message_dict=None, play_sound=True, check_duplicate=False):
		"""Adds a message to the MessageWidget.
		@param point: point where the action took place. Clicks on the message will then focus that spot.
		@param id: message id string, needed to retrieve the message text from the content database.
		@param msg_type: message type; determines what happens on click
		@param message_dict: dict with strings to replace in the message, e.g. {'player': 'Arthus'}
		@param play_sound: whether to play the default message speech for string_id
		@param check_duplicate: check for pseudo-duplicates (similar messages recently nearby)
		"""
		if check_duplicate:
			if string_id in self._last_message:
				when, where = self._last_message[string_id]
				if when > Scheduler().cur_tick - Scheduler().get_ticks(self.__class__._DUPLICATE_TIME_THRESHOLD) and \
				   where.distance(point) < self.__class__._DUPLICATE_SPACE_THRESHOLD:
					# there has been a message nearby recently, abort
					return
			self._last_message[string_id] = (Scheduler().cur_tick, point)

		sound = get_speech_file(string_id) if play_sound else None
		return self._add_message(_IngameMessage(point=point, id=string_id, msg_type=msg_type,
		                                        created=self.msgcount.next(), message_dict=message_dict),
		                         sound=sound)

	def remove(self, messagetext):
		"""Remove a message containing the text *messagetext*"""
		index = -1
		for i, message in enumerate(self.active_messages):
			if messagetext == message.message:
				index = i
				break
		if index > -1:
			del self.active_messages[index]

	def add_custom(self, messagetext, point=None, msg_type=None, visible_for=40, icon_id=1):
		""" See docstring for add().
		Uses no predefined message template from content database like add() does.
		Instead, directly provides text and icon to be shown (messagetext, icon_id)
		@param visible_for: how many seconds the message will stay visible in the widget
		"""
		return self._add_message(_IngameMessage(point=point, id=None, msg_type=msg_type,
		                                        display=visible_for, created=self.msgcount.next(),
		                                        message=messagetext, icon_id=icon_id))

	def add_chat(self, player, messagetext, icon_id=1):
		""" See docstring for add().
		"""
		message_dict = {'player': player, 'message': messagetext}
		self.add('CHAT', msg_type=None, message_dict=message_dict)
		self.chat.append(self.active_messages[0])

	def _add_message(self, message, sound=None):
		"""Internal function for adding messages. Do not call directly.
		@param message: _IngameMessage instance
		@param sound: path to soundfile"""
		self.active_messages.insert(0, message)
		if len(self.active_messages) > self.MAX_MESSAGES:
			self.active_messages.remove(self.active_messages[self.MAX_MESSAGES])

		if sound:
			horizons.globals.fife.play_sound('speech', sound)
		else:
			# play default msg sound
			AmbientSoundComponent.play_special('message')

		if message.x is not None and message.y is not None:
			self.session.ingame_gui.minimap.highlight( (message.x, message.y) )

		self.draw_widget()
		self.show_text(0)
		ExtScheduler().add_new_object(self.hide_text, self, self.SHOW_NEW_MESSAGE_TEXT)

		self.session.ingame_gui.logbook.display_message_history() # update message history on new message

		return message.created

	def draw_widget(self):
		"""
		Updates whole messagewidget (all messages): draw icons.
		Inactive messages need their icon hovered to display their text again
		"""
		button_space = self.widget.findChild(name="button_space")
		button_space.removeAllChildren() # Remove old buttons
		for index, message in enumerate(self.active_messages):
			if index >= len(self.active_messages):
				# Only display most recent notifications
				continue
			button = ImageButton()
			button.name = str(index)
			button.path = message.path
			# show text on hover
			events = {
				button.name + "/mouseEntered": Callback(self.show_text, index),
				button.name + "/mouseExited": self.hide_text,
			}
			# init callback to something callable to improve robustness
			callback = Callback(lambda: None)
			if message.x is not None and message.y is not None:
				# move camera to source of event on click, if there is a source
				callback = Callback.ChainedCallbacks(
					   callback, # this makes it so the order of callback assignment doesn't matter
					   Callback(self.session.view.center, message.x, message.y),
					   Callback(self.session.ingame_gui.minimap.highlight, (message.x, message.y) )
				   )
			if message.msg_type == "logbook":
				# open logbook to relevant page
				callback = Callback.ChainedCallbacks(
					   callback, # this makes it so the order of callback assignment doesn't matter
					   Callback(self.session.ingame_gui.windows.toggle, self.session.ingame_gui.logbook, msg_id=message.created)
				)
			if callback:
				events[button.name] = callback

			button.mapEvents(events)
			button_space.addChild(button)
		button_space.resizeToContent()
		self.widget.size = button_space.size

	def show_text(self, index):
		"""Shows the text for a button.
		@param index: index of button"""
		assert isinstance(index, int)
		# stop hiding if a new text has been shown
		ExtScheduler().rem_call(self, self.hide_text)

		try:
			text = self.active_messages[index].message
		except IndexError:
			# Something went wrong, try to find out what. Also see #2273.
			self.log.error(u'Tried to access message at index %s, only have %s. Messages:',
			               index, len(self.active_messages))
			self.log.error(u'\n'.join(unicode(m) for m in self.active_messages))
			text = (u'Error trying to access message!\n'
			        u'Please report a bug. Thanks!')

		text = text.replace(r'\n', self.CHARS_PER_LINE * ' ')
		text = text.replace('[br]', self.CHARS_PER_LINE * ' ')
		text = textwrap.fill(text, self.CHARS_PER_LINE)

		self.bg_middle = self.text_widget.findChild(name='msg_bg_middle')
		self.bg_middle.removeAllChildren()

		line_count = len(text.splitlines()) - 1
		for i in xrange(line_count * self.LINE_HEIGHT // self.IMG_HEIGHT):
			middle_icon = Icon(image=self.BG_IMAGE_MIDDLE)
			self.bg_middle.addChild(middle_icon)

		button = self.widget.findChild(name=str(index))
		# y position relative to parent
		button_y = button.position[1]
		# Show text next to corresponding icon
		x, y = self.reference_text_widget_position
		self.text_widget.position = (x, y + button_y)

		message_container = self.text_widget.findChild(name='message')
		message_container.size = (300, 21 + self.IMG_HEIGHT * line_count + 21)

		self.bg_middle.adaptLayout()
		label = self.text_widget.findChild(name='text')
		label.text = text
		label.adaptLayout()
		self.text_widget.show()

	def hide_text(self):
		"""Hides the text."""
		self.text_widget.hide()

	def tick(self):
		"""Check whether a message is old enough to be put into the archives"""
		changed = False
		for item in self.active_messages:
			item.display -= 1
			if item.display == 0:
				# item not displayed any more -- put it in archive
				self.archive.append(item)
				self.active_messages.remove(item)
				self.hide_text()
				changed = True
		if changed:
			self.draw_widget()

	def end(self):
		self.hide_text()
		self.widget.findChild(name="button_space").removeAllChildren() # Remove old buttons
		ExtScheduler().rem_all_classinst_calls(self)
		self.active_messages = []
		self.archive = []
		super(MessageWidget, self).end()

	def save(self, db):
		for message in self.active_messages:
			if message.id is not None and message.id != 'CHAT': # only save default messages (for now)
				db("INSERT INTO message_widget_active (id, x, y, read, created, display, message) "
				   "VALUES (?, ?, ?, ?, ?, ?, ?)",
				   message.id, message.x, message.y, int(message.read),
				   message.created, message.display, message.message)
		for message in self.archive:
			if message.id is not None and message.id != 'CHAT':
				db("INSERT INTO message_widget_archive (id, x, y, read, created, display, message) "
				   "VALUES (?, ?, ?, ?, ?, ?, ?)",
				   message.id, message.x, message.y, int(message.read),
				   message.created, message.display, message.message)
		for message in self.chat:
			# handle 'CHAT' special case: display is 0 (do not show old chat on load)
			db("INSERT INTO message_widget_archive (id, x, y, read, created, display, message) "
			   "VALUES (?, ?, ?, ?, ?, ?, ?)",
			   message.id, message.x, message.y, int(message.read), message.created, 0, message.message)

	def load(self, db):
		messages = db("SELECT id, x, y, read, created, display, message "
		              "FROM message_widget_active ORDER BY created ASC")
		for (msg_id, x, y, read, created, display, message) in messages:
			msg = _IngameMessage(point=Point(x, y), id=msg_id, created=created,
			                     read=bool(read), display=bool(display), message=message)
			self.active_messages.append(msg)
		messages = db("SELECT id, x, y, read, created, display, message "
		              "FROM message_widget_archive ORDER BY created ASC")
		for (msg_id, x, y, read, created, display, message) in messages:
			msg = _IngameMessage(point=Point(x, y), id=msg_id, created=created,
			                     read=bool(read), display=bool(display), message=message)
			if msg_id == 'CHAT':
				self.chat.append(msg)
			else:
				self.archive.append(msg)
		count = max([-1] + [m.created for m in self.active_messages + self.archive + self.chat]) + 1
		self.msgcount = itertools.count(count) # start keyword only works with 2.7+
		self.draw_widget()


class _IngameMessage(object):
	"""Represents a message that is to be displayed in the MessageWidget.
	The message is used as a string template, meaning it can contain placeholders
	like the following: {player}, {gold}. The *message_dict* needed to fill in
	these placeholders needs to be provided when creating _IngameMessages.

	@param point: Point position on the map where the action took place, or None.
	@param id: message id string, needed to retrieve the message from the database.
	@param created: tickid when the message was created. Keeps message order after load.

	@param msg_type: messages coupled with logbook entries use this to link to pages
	@param read: #TODO
	@param display: #TODO
	@param message: message text to display. Loads preset for `id` if None.
	@param message_dict: dict with strings to replace in the message, e.g. {'player': 'Arthus'}
	@param icon_id: which icon to display. Loads preset for `id` if None.
	"""
	def __init__(self, point, id, created,
	             msg_type=None, read=False, display=None, message=None, message_dict=None, icon_id=None):
		self.x, self.y = None, None
		if point is not None:
			self.x, self.y = point.x, point.y
		self.id = id
		self.msg_type = msg_type
		self.read = read
		self.created = created
		self.display = display if display is not None else horizons.globals.db.get_msg_visibility(id)
		icon = icon_id if icon_id is not None else horizons.globals.db.get_msg_icon_id(id)
		self.path = horizons.globals.db.get_msg_icon_path(icon)
		if message is not None:
			assert isinstance(message, unicode), "Message is not unicode: %s" % message
			self.message = message
		else:
			msg = _(horizons.globals.db.get_msg_text(id))
			#TODO why can message_dict not be used with custom messages (`if` branch above)
			try:
				self.message = msg.format(**message_dict if message_dict is not None else {})
			except KeyError as err:
				self.message = msg
				self.log.warning(u'Unsubstituted string %s in %s message "%s", dict %s',
				                 err, msg, id, message_dict)

	def __repr__(self):
		return "% 4d: %s %s %s%s" % (self.created, self.id,
			'(%s,%s) ' % (self.x, self.y) if self.x and self.y else '',
			'R' if self.read else ' ',
			'D' if self.display else ' ')

	def __unicode__(self):
		return u"% 4d: %s  '%s'  %s %s%s" % (self.created, self.id,
			self.message,
			'(%s,%s) ' % (self.x, self.y) if self.x and self.y else '',
			'R' if self.read else ' ',
			'D' if self.display else ' ')

########NEW FILE########
__FILENAME__ = minimap
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import itertools
import json
import math
import re
from math import sin, cos

import horizons.globals
from fife import fife

from horizons.extscheduler import ExtScheduler
from horizons.util.python import decorators
from horizons.util.shapes import Circle, Point, Rect
from horizons.command.unit import Act
from horizons.component.namedcomponent import NamedComponent
from horizons.messaging import SettingChanged


class Minimap(object):
	"""A basic minimap.

	USAGE:
	Minimap can be drawn via GenericRenderer on an arbitrary position (determined by rect in ctor)
	or
	via Pychan Icon. In this case, the rect parameter only determines the size, the
	Minimap will scroll by default on clicks, overwrite on_click if you don't want that.

	TODO:
	* Remove renderer when used in icon node
	* Clear up distinction of coords where the minimap image or screen is the origin
	* Create a minimap tag for pychan
	** Handle clicks, remove overlay icon
	"""
	COLORS = {
		"island":    (137, 117,  87),
		"cam":       (  1,   1,   1),
		"water":     (198, 188, 165),
		"highlight": (255,   0,   0),  # for events
	}

	WAREHOUSE_IMAGE = "content/gui/icons/minimap/warehouse.png"
	SHIP_NEUTRAL = "content/gui/icons/minimap/ship_neutral.png"
	SHIP_PIRATE = "content/gui/icons/minimap/pirate.png"
	GROUND_UNIT_IMAGE = "content/gui/icons/minimap/groundunit.png"

	SHIP_DOT_UPDATE_INTERVAL = 0.5 # seconds

	# Alpha-ordering determines the order:
	RENDER_NAMES = {
	  "background" : "c",
	  "base" : "d",  # islands, etc.
	  "warehouse" : "e",
	  "ship" : "f",
	  "cam" : "g",
	  "ship_route" : "h",
	  "highlight" : "l",
	  }

	__minimap_id_counter = itertools.count()
	__ship_route_counter = itertools.count()
	_instances = [] # all active instances

	_dummy_fife_point = fife.Point(0, 0) # use when you quickly need a temporary point

	def __init__(self, position, session, view, targetrenderer, imagemanager, renderer=None, world=None,
	             cam_border=True, use_rotation=True, on_click=None, preview=False, tooltip=None):
		"""
		@param position: a Rect or a Pychan Icon, where we will draw to
		@param world: World object or fake thereof
		@param view: View object for cam control. Can be None to disable this
		@param renderer: renderer to be used if position isn't an icon
		@param targetrenderer: fife target renderer for drawing on icons
		@param imagemanager: fife imagemanager for drawing on icons
		@param cam_border: boolean, whether to draw the cam border
		@param use_rotation: boolean, whether to use rotation (it must also be enabled in the settings)
		@param on_click: function taking 1 argument or None for scrolling
		@param preview: flag, whether to only show the map as preview
		@param tooltip: always show this tooltip when cursor hovers over minimap
		"""
		if isinstance(position, Rect):
			self.location = position
			self.renderer = renderer
		else: # assume icon
			self.location = Rect.init_from_topleft_and_size(0, 0, position.width, position.height)
			self.icon = position
			self.use_overlay_icon(self.icon)
		self.session = session
		self.world = world
		if self.world:
			self._update_world_to_minimap_ratio()
		self.view = view
		self.rotation = 0
		self.fixed_tooltip = tooltip

		if on_click is not None:
			self.on_click = on_click

		self.cam_border = cam_border
		self.use_rotation = use_rotation
		self.preview = preview

		self.location_center = self.location.center

		self._id = str(self.__class__.__minimap_id_counter.next()) # internal identifier, used for allocating resources

		self._image_size_cache = {} # internal detail

		self.imagemanager = imagemanager

		self.minimap_image = _MinimapImage(self, targetrenderer)

		self._rotation_setting = horizons.globals.fife.get_uh_setting("MinimapRotation")
		if self.use_rotation:
			SettingChanged.subscribe(self._on_setting_changed)

	def end(self):
		self.disable()
		self.world = None
		self.session = None
		self.renderer = None
		if self.use_rotation:
			SettingChanged.unsubscribe(self._on_setting_changed)

	def disable(self):
		"""Due to the way the minimap works, there isn't really a show/hide,
		but you can disable it with this and enable again with draw().
		Stops all updates."""
		ExtScheduler().rem_all_classinst_calls(self)
		if self.view is not None:
			self.view.discard_change_listener(self.update_cam)

		if self in self.__class__._instances:
			self.__class__._instances.remove(self)

	def draw(self):
		"""Recalculates and draws the whole minimap of self.session.world or world.
		The world you specified is reused for every operation until the next draw().
		"""
		if self.world is None and self.session.world is not None:
			self.world = self.session.world # in case minimap has been constructed before the world
			self._update_world_to_minimap_ratio()
		if not self.world.inited:
			return # don't draw while loading

		self.__class__._instances.append(self)

		# update cam when view updates
		if self.view is not None and not self.view.has_change_listener(self.update_cam):
			self.view.add_change_listener(self.update_cam)

		if not hasattr(self, "icon"):
			# add to global generic renderer with id specific to this instance
			self.renderer.removeAll("minimap_image"+self._id)
			self.minimap_image.reset()
			# NOTE: this is for the generic renderer interface, the offrenderer has slightly different methods
			node = fife.RendererNode(fife.Point(self.location.center.x, self.location.center.y))
			self.renderer.addImage("minimap_image"+self._id, node, self.minimap_image.image, False)

		else:
			# attach image to pychan icon (recommended)
			self.minimap_image.reset()
			self.icon.image = fife.GuiImage(self.minimap_image.image)

		self.update_cam()
		self._recalculate()
		if not self.preview:
			self._timed_update(force=True)
			ExtScheduler().rem_all_classinst_calls(self)
			ExtScheduler().add_new_object(self._timed_update, self,
			                              self.SHIP_DOT_UPDATE_INTERVAL, -1)

	def dump_data(self):
		"""Returns a string representing the minimap data"""
		return self._recalculate(dump_data=True)

	def draw_data(self, data):
		"""Display data from dump_data"""
		# only icon mode for now
		self.minimap_image.reset()
		self.icon.image = fife.GuiImage(self.minimap_image.image)

		self.minimap_image.set_drawing_enabled()
		rt = self.minimap_image.rendertarget
		render_name = self._get_render_name("base")
		draw_point = rt.addPoint
		point = fife.Point()

		# XXX There have been reports about `data` containing Fife debug
		# output (e.g. #2193). As temporary workaround, we try to only
		# parse what looks like valid json in there and ignore the rest.
		found_json = re.findall(r'\[\[.*\]\]', data)[0]

		for x, y, r, g, b in json.loads(found_json):
			point.set(x, y)
			draw_point(render_name, point, r, g, b)


	def _get_render_name(self, key):
		return self.RENDER_NAMES[key] + self._id

	def update_cam(self):
		"""Redraw camera border."""
		if not self.cam_border or self.view is None: # needs view
			return
		if self.world is None or not self.world.inited:
			return # don't draw while loading
		use_rotation = self._get_rotation_setting()
		self.minimap_image.set_drawing_enabled()
		self.minimap_image.rendertarget.removeAll(self._get_render_name("cam"))
		# draw rect for current screen
		displayed_area = self.view.get_displayed_area()
		minimap_corners_as_point = []
		for corner in displayed_area.get_corners():
			# check if the corners are outside of the screen
			corner = list(corner)
			if corner[0] > self.world.max_x:
				corner[0] = self.world.max_x
			if corner[0] < self.world.min_x:
				corner[0] = self.world.min_x
			if corner[1] > self.world.max_y:
				corner[1] = self.world.max_y
			if corner[1] < self.world.min_y:
				corner[1] = self.world.min_y
			corner = tuple(corner)

			coords = self._world_to_minimap(corner, use_rotation)
			minimap_corners_as_point.append(fife.Point(coords[0], coords[1]))


		for i in xrange(0, 4):
			self.minimap_image.rendertarget.addLine(self._get_render_name("cam"),
			                                        minimap_corners_as_point[i],
			                                        minimap_corners_as_point[(i+1) % 4],
			                                                         *self.COLORS["cam"])

	@classmethod
	def update(cls, tup):
		for minimap in cls._instances:
			minimap._update(tup)

	def _update(self, tup):
		"""Recalculate and redraw minimap for real world coord tup
		@param tup: (x, y)"""
		if self.world is None or not self.world.inited:
			return # don't draw while loading
		minimap_point = self._world_to_minimap(tup, self._get_rotation_setting())
		world_to_minimap = self._world_to_minimap_ratio
		# TODO: remove this remnant of the old implementation, perhaps by refactoring recalculate()
		minimap_point = (
		  minimap_point[0] + self.location.left,
		  minimap_point[1] + self.location.top,
		)
		rect = Rect.init_from_topleft_and_size(minimap_point[0], minimap_point[1],
								                           int(round(1/world_to_minimap[0])) + 1,
								                           int(round(1/world_to_minimap[1])) + 1)
		self._recalculate(rect)

	def use_overlay_icon(self, icon):
		"""Configures icon so that clicks get mapped here.
		The current gui requires, that the minimap is drawn behind an icon."""
		self.overlay_icon = icon
		icon.mapEvents({
			icon.name + '/mousePressed' : self._on_click,
			icon.name + '/mouseDragged' : self._on_drag,
			icon.name + '/mouseEntered' : self._mouse_entered,
			icon.name + '/mouseMoved' : self._mouse_moved,
			icon.name + '/mouseExited' : self._mouse_exited,
		})

	def on_click(self, event, drag):
		"""Handler for clicks (pressed and dragged)
		Scrolls screen to the point, where the cursor points to on the minimap.
		Overwrite this method to your convenience.
		"""
		if self.preview:
			return # we don't do anything in this mode
		button = event.getButton()
		map_coords = event.map_coords
		if button == fife.MouseEvent.RIGHT:
			if drag:
				return
			for i in self.session.selected_instances:
				if i.movable:
					Act(i, *map_coords).execute(self.session)
		elif button == fife.MouseEvent.LEFT:
			if self.view is None:
				print "Warning: Can't handle minimap clicks since we have no view object"
			else:
				self.view.center(*map_coords)

	def _on_click(self, event):
		if self.world is not None: # supply world coords if there is a world
			event.map_coords = self._get_event_coords(event)
			if event.map_coords:
				self.on_click(event, drag=False)
		else:
			self.on_click(event, drag=True)

	def _on_drag(self, event):
		if self.world is not None: # supply world coords if there is a world
			event.map_coords = self._get_event_coords(event)
			if event.map_coords:
				self.on_click(event, drag=True)
		else:
			self.on_click(event, drag=True)

	def _get_event_coords(self, event):
		"""Returns position of event as uh map coordinate tuple or None"""
		mouse_position = Point(event.getX(), event.getY())
		if not hasattr(self, "icon"):
			icon_pos = Point(*self.overlay_icon.getAbsolutePos())
			abs_mouse_position = icon_pos + mouse_position
			if not self.location.contains(abs_mouse_position):
				# mouse click was on icon but not actually on minimap
				return
			abs_mouse_position = abs_mouse_position.to_tuple()
		else:
			abs_mouse_position = mouse_position.to_tuple()
		if self._get_rotation_setting():
			abs_mouse_position = self._get_from_rotated_coords(abs_mouse_position)
		return self._minimap_coords_to_world_coords(abs_mouse_position)

	def _mouse_entered(self, event):
		self._show_tooltip(event)

	def _mouse_moved(self, event):
		self._show_tooltip(event)

	def _mouse_exited(self, event):
		if hasattr(self, "icon"): # only supported for icon mode atm
			self.icon.hide_tooltip()

	def _show_tooltip(self, event):
		if not hasattr(self, "icon"):
			# only supported for icon mode atm
			return
		if self.fixed_tooltip is not None:
			self.icon.helptext = self.fixed_tooltip
			self.icon.position_tooltip(event)
			#self.icon.show_tooltip()
		else:
			coords = self._get_event_coords(event)
			if not coords: # no valid/relevant event location
				self.icon.hide_tooltip()
				return

			tile = self.world.get_tile(Point(*coords))
			if tile is not None and tile.settlement is not None:
				new_helptext = tile.settlement.get_component(NamedComponent).name
				if self.icon.helptext != new_helptext:
					self.icon.helptext = new_helptext
					self.icon.show_tooltip()
				else:
					self.icon.position_tooltip(event)
			else:
				# mouse not over relevant part of the minimap
				self.icon.hide_tooltip()

	def highlight(self, tup, factor=1.0, speed=1.0, finish_callback=None, color=(0, 0, 0)):
		"""Try to get the users attention on a certain point of the minimap.
		@param tup: world coords
		@param factor: float indicating importance of event
		@param speed: animation speed as factor
		@param finish_callback: executed when animation finishes
		@param color: color of anim, (r,g,b), r,g,b of [0,255]
		@return duration of full animation in seconds"""
		tup = self._world_to_minimap(tup, self._get_rotation_setting())

		# grow the circle from MIN_RAD to MAX_RAD and back with STEPS steps, where the
		# interval between steps is INTERVAL seconds
		MIN_RAD = int( 3 * factor) # pixel
		MAX_RAD = int(12 * factor) # pixel
		STEPS = int(20 * factor)
		INTERVAL = (math.pi / 16) * factor

		def high(i=0):
			i += 1
			render_name = self._get_render_name("highlight")+str(tup)
			self.minimap_image.set_drawing_enabled()
			self.minimap_image.rendertarget.removeAll(render_name)
			if i > STEPS:
				if finish_callback:
					finish_callback()
				return
			part = i # grow bigger
			if i > STEPS // 2: # after the first half
				part = STEPS-i  # become smaller

			radius = MIN_RAD + int((float(part) / (STEPS // 2)) * (MAX_RAD - MIN_RAD))

			draw_point = self.minimap_image.rendertarget.addPoint
			for x, y in Circle(Point(*tup), radius=radius).get_border_coordinates():
				draw_point(render_name, fife.Point(x, y), *color)

			ExtScheduler().add_new_object(lambda : high(i), self, INTERVAL, loops=1)

		high()
		return STEPS*INTERVAL

	def show_unit_path(self, unit):
		"""Show the path a unit is moving along"""
		path = unit.path.path
		if path is None: # show at least the position
			path = [unit.position.to_tuple()]

		# the path always contains the full path, the unit might be somewhere in it
		position_of_unit_in_path = 0
		unit_pos = unit.position.to_tuple()
		for i, pos in enumerate(path):
			if pos == unit_pos:
				position_of_unit_in_path = i
				break

		# display units one ahead if possible, it looks nicer if the unit is moving
		if len(path) > 1 and position_of_unit_in_path+1 < len(path):
			position_of_unit_in_path += 1 #
		path = path[position_of_unit_in_path:]

		# draw every step-th coord
		step = 1
		relevant_coords = [path[0]]
		for i in xrange(step, len(path), step):
			relevant_coords.append(path[i])
		relevant_coords.append(path[-1])

		# get coords, actual drawing
		use_rotation = self._get_rotation_setting()
		self.minimap_image.set_drawing_enabled()
		p = fife.Point(0, 0)
		render_name = self._get_render_name("ship_route") + str(self.__class__.__ship_route_counter.next())
		color = unit.owner.color.to_tuple()
		last_coord = None
		draw_point = self.minimap_image.rendertarget.addPoint
		for i in relevant_coords:
			coord = self._world_to_minimap(i, use_rotation)
			if last_coord is not None and \
			   sum(abs(last_coord[i] - coord[i]) for i in (0, 1)) < 2:  # 2 is min dist in pixels
				continue
			last_coord = coord
			p.x = coord[0]
			p.y = coord[1]
			draw_point(render_name, p, *color)

		def cleanup():
			self.minimap_image.set_drawing_enabled()
			self.minimap_image.rendertarget.removeAll(render_name)

		speed = 1.0 + math.sqrt(5) / 2
		self.highlight(path[-1], factor=0.4, speed=speed, finish_callback=cleanup, color=color)

		return True

	def _recalculate(self, where=None, dump_data=False):
		"""Calculate which pixel of the minimap should display what and draw it
		@param where: Rect of minimap coords. Defaults to self.location
		@param dump_data: Don't draw but return calculated data"""
		self.minimap_image.set_drawing_enabled()

		rt = self.minimap_image.rendertarget
		render_name = self._get_render_name("base")

		if where is None:
			where = self.location
			rt.removeAll(render_name)

		# calculate which area of the real map is mapped to which pixel on the minimap
		pixel_per_coord_x, pixel_per_coord_y = self._world_to_minimap_ratio

		# calculate values here so we don't have to do it in the loop
		pixel_per_coord_x_half_as_int = int(pixel_per_coord_x/2)
		pixel_per_coord_y_half_as_int = int(pixel_per_coord_y/2)

		world_min_x = self.world.min_x
		world_min_y = self.world.min_y
		island_col = self.COLORS["island"]
		water_col = self.COLORS["water"]
		location_left = self.location.left
		location_top = self.location.top
		if dump_data:
			data = []
			draw_point = lambda name, fife_point, r, g, b : data.append((fife_point.x, fife_point.y, r, g, b))
		else:
			draw_point = rt.addPoint
		fife_point = fife.Point(0, 0)

		use_rotation = self._get_rotation_setting()
		full_map = self.world.full_map

		# loop through map coordinates, assuming (0, 0) is the origin of the minimap
		# this facilitates calculating the real world coords
		for x in xrange(where.left-self.location.left, where.left+where.width-self.location.left):
			for y in xrange(where.top-self.location.top, where.top+where.height-self.location.top):

				"""
				This code should be here, but since python can't do inlining, we have to inline
				ourselves for performance reasons
				covered_area = Rect.init_from_topleft_and_size(
				  int(x * pixel_per_coord_x)+world_min_x,
				  int(y * pixel_per_coord_y)+world_min_y),
				  int(pixel_per_coord_x), int(pixel_per_coord_y))
				real_map_point = covered_area.center
				"""
				# use center of the rect that the pixel covers
				real_map_x = int(x * pixel_per_coord_x) + world_min_x + pixel_per_coord_x_half_as_int
				real_map_y = int(y * pixel_per_coord_y) + world_min_y + pixel_per_coord_y_half_as_int
				real_map_coords = (real_map_x, real_map_y)

				# check what's at the covered_area
				if real_map_coords in full_map:
					# this pixel is an island
					tile = full_map[real_map_coords]
					settlement = tile.settlement
					if settlement is None:
						# island without settlement
						if tile.id <= 0:
							color = water_col
						else:
							color = island_col
					else:
						# pixel belongs to a player
						color = settlement.owner.color.to_tuple()
				else:
					color = water_col

				if use_rotation:
					# inlined _get_rotated_coords
					rot_x, rot_y = self._rotate((location_left + x, location_top + y), self._rotations)
					fife_point.set(rot_x - location_left, rot_y - location_top)
				else:
					fife_point.set(x, y)

				draw_point(render_name, fife_point, *color)

		if dump_data:
			return json.dumps(data)


	def _timed_update(self, force=False):
		"""Regular updates for domains we can't or don't want to keep track of."""
		# OPTIMIZATION NOTE: There can be pretty many ships.
		# Don't rely on the loop being rarely executed!
		# update ship icons
		self.minimap_image.set_drawing_enabled()
		render_name = self._get_render_name("ship")
		self.minimap_image.rendertarget.removeAll(render_name)
		use_rotation = self._get_rotation_setting()
		# Make use of these dummy points instead of creating fife.Point instances
		# (which are consuming a lot of resources).
		dummy_point0 = fife.Point(0, 0)
		dummy_point1 = fife.Point(0, 0)
		for ship in self.world.ships:
			if not ship.in_ship_map:
				continue # no fisher ships, etc
			coord = self._world_to_minimap(ship.position.to_tuple(), use_rotation)
			color = ship.owner.color.to_tuple()
			# set correct icon
			if ship.owner is self.session.world.pirate:
				ship_icon_path = self.__class__.SHIP_PIRATE
			else:
				ship_icon_path = self.__class__.SHIP_NEUTRAL
			ship_icon = self.imagemanager.load(ship_icon_path)
			dummy_point1.set(coord[0], coord[1])
			self.minimap_image.rendertarget.addImage(render_name, dummy_point1, ship_icon)
			if ship.owner.regular_player:
				# add the 'flag' over the ship icon, with the color of the owner
				dummy_point0.set(coord[0] - 5, coord[1] - 5)
				dummy_point1.set(coord[0], coord[1] - 5)
				self.minimap_image.rendertarget.addLine(render_name, dummy_point0,
									dummy_point1, color[0], color[1], color[2])
				dummy_point0.set(coord[0] - 6, coord[1] - 6)
				dummy_point1.set(coord[0], coord[1] - 6)
				self.minimap_image.rendertarget.addLine(render_name, dummy_point0,
									dummy_point1, color[0], color[1], color[2])
				dummy_point0.set(coord[0] - 4, coord[1] - 4)
				dummy_point1.set(coord[0], coord[1] - 4)
				self.minimap_image.rendertarget.addLine(render_name, dummy_point0,
									dummy_point1, color[0], color[1], color[2])
				# add black border around the flag
				dummy_point0.set(coord[0] - 6, coord[1] - 7)
				dummy_point1.set(coord[0], coord[1] - 7)
				self.minimap_image.rendertarget.addLine(render_name, dummy_point0, dummy_point1, 0, 0, 0)
				dummy_point0.set(coord[0] - 4, coord[1] - 3)
				dummy_point1.set(coord[0], coord[1] - 4)
				self.minimap_image.rendertarget.addLine(render_name, dummy_point0, dummy_point1, 0, 0, 0)
				dummy_point0.set(coord[0] - 6, coord[1] - 7)
				dummy_point1.set(coord[0] - 4, coord[1] - 3)
				self.minimap_image.rendertarget.addLine(render_name, dummy_point0, dummy_point1, 0, 0, 0)

			# TODO: nicer selected view
			dummy_point0.set(coord[0], coord[1])
			draw_point = self.minimap_image.rendertarget.addPoint
			if ship in self.session.selected_instances:
				draw_point(render_name, dummy_point0, *Minimap.COLORS["water"])
				for x_off, y_off in ((-2,  0),
				                     (+2,  0),
				                     ( 0, -2),
				                     ( 0, +2)):
					dummy_point1.set(coord[0] + x_off, coord[1] + y_off)
					draw_point(render_name, dummy_point1, *color)

		# draw settlement warehouses if something has changed
		settlements = self.world.settlements
		# save only worldids as to not introduce actual coupling
		cur_settlements = set(i.worldid for i in settlements)
		if force or \
		   (not hasattr(self, "_last_settlements") or cur_settlements != self._last_settlements):
			# update necessary
			warehouse_render_name = self._get_render_name("warehouse")
			self.minimap_image.rendertarget.removeAll(warehouse_render_name)
			for settlement in settlements:
				coord = settlement.warehouse.position.center.to_tuple()
				coord = self._world_to_minimap(coord, use_rotation)
				self._update_image(self.__class__.WAREHOUSE_IMAGE,
				                   warehouse_render_name,
				                   coord)
			self._last_settlements = cur_settlements

	def _update_image(self, img_path, name, coord_tuple):
		"""Updates image as part of minimap (e.g. when it has moved)"""
		img = self.imagemanager.load(img_path)

		size_tuple = self._image_size_cache.get(img_path)
		if size_tuple is None:
			ratio = sum(self._world_to_minimap_ratio) / 2.0
			ratio = max(1.0, ratio)
			size_tuple = int(img.getWidth()/ratio), int(img.getHeight()/ratio)
			self._image_size_cache[img_path] = size_tuple
		new_width, new_height = size_tuple
		p = self.__class__._dummy_fife_point
		p.set(*coord_tuple)
		# resizeImage also means draw
		self.minimap_image.rendertarget.resizeImage(name, p, img, new_width, new_height)

	def rotate_right(self):
		# keep track of rotation at any time, but only apply
		# if it's actually used
		self.rotation -= 1
		self.rotation %= 4
		if self._get_rotation_setting():
			self.draw()

	def rotate_left(self):
		# see above
		self.rotation += 1
		self.rotation %= 4
		if self._get_rotation_setting():
			self.draw()

	## CALC UTILITY
	def _world_to_minimap(self, coords, use_rotation):
		"""Complete coord transformation, batteries included.
		The methods below are for more specialized purposes."""
		coords = self._world_coords_to_minimap_coords(coords)

		if use_rotation:
			coords = self._get_rotated_coords(coords)
		# transform from screen coords to minimap coords
		coords = (coords[0] - self.location.left,
		          coords[1] - self.location.top)
		return coords

	def _get_rotation_setting(self):
		if not self.use_rotation:
			return False
		return self._rotation_setting

	def _on_setting_changed(self, message):
		if message.setting_name == "MinimapRotation":
			self._rotation_setting = message.new_value
			self.draw()

	_rotations = { 0 : 0,
				         1 : 3 * math.pi / 2,
				         2 : math.pi,
				         3 : math.pi / 2
				         }
	def _get_rotated_coords(self, tup):
		"""Rotates according to current rotation settings.
		Input coord must be relative to screen origin, not minimap origin"""
		return self._rotate(tup, self._rotations)

	_from_rotations = { 0 : 0,
				              1 : math.pi / 2,
				              2 : math.pi,
				              3 : 3 * math.pi / 2
				              }
	def _get_from_rotated_coords(self, tup):
		return self._rotate(tup, self._from_rotations)

	def _rotate(self, tup, rotations):
		rotation = rotations[self.rotation]

		x = tup[0]
		y = tup[1]

		# Rotate around center of minimap.
		x -= self.location_center.x
		y -= self.location_center.y

		new_x = x * cos(rotation) - y * sin(rotation)
		new_y = x * sin(rotation) + y * cos(rotation)

		new_x += self.location_center.x
		new_y += self.location_center.y

		new_x = int(round(new_x))
		new_y = int(round(new_y))

		# Some points may get out of range.
		new_x = max(self.location.left, new_x)
		new_x = min(self.location.right, new_x)
		new_y = max(self.location.top, new_y)
		new_y = min(self.location.bottom, new_y)

		return (new_x, new_y)

	def _update_world_to_minimap_ratio(self):
		world_height = self.world.map_dimensions.height
		world_width = self.world.map_dimensions.width
		minimap_height = self.location.height
		minimap_width = self.location.width
		pixel_per_coord_x = float(world_width) / minimap_width
		pixel_per_coord_y = float(world_height) / minimap_height
		self._world_to_minimap_ratio = (pixel_per_coord_x, pixel_per_coord_y)

	def _world_coords_to_minimap_coords(self, tup):
		"""Calculates which pixel in the minimap contains a coord in the real map.
		@param tup: (x, y) as ints
		@return tuple"""
		pixel_per_coord_x, pixel_per_coord_y = self._world_to_minimap_ratio
		return (
			int(round(float(tup[0] - self.world.min_x)/pixel_per_coord_x))+self.location.left,
			int(round(float(tup[1] - self.world.min_y)/pixel_per_coord_y))+self.location.top
		)

	def _minimap_coords_to_world_coords(self, tup):
		"""Inverse to _world_coords_to_minimap_coords"""
		pixel_per_coord_x, pixel_per_coord_y = self._world_to_minimap_ratio
		world_x = round(pixel_per_coord_x * (tup[0] - self.location.left))
		world_y = round(pixel_per_coord_y * (tup[1] - self.location.top))
		return (int(world_x) + self.world.min_x, int(world_y) + self.world.min_y)

	def get_size(self):
		return (self.location.height, self.location.width)


class _MinimapImage(object):
	"""Encapsulates handling of fife Image.
	Provides:
	- self.rendertarget: instance of fife.RenderTarget
	"""
	def __init__(self, minimap, targetrenderer):
		self.minimap = minimap
		self.targetrenderer = targetrenderer
		size = self.minimap.get_size()
		self.image = self.minimap.imagemanager.loadBlank(size[0], size[1])
		self.rendertarget = targetrenderer.createRenderTarget(self.image)
		self.set_drawing_enabled()

	def reset(self):
		"""Reset image to original image"""
		# reload
		self.rendertarget.removeAll()
		size = self.minimap.get_size()
		self.rendertarget.addQuad(self.minimap._get_render_name("background"),
		                          fife.Point(0, 0),
		                          fife.Point(0, size[1]),
		                          fife.Point(size[0], size[1]),
		                          fife.Point(size[0], 0),
		                          *Minimap.COLORS["water"])

	def set_drawing_enabled(self):
		"""Always call this."""
		targetname = self.rendertarget.getTarget().getName()
		self.targetrenderer.setRenderTarget(targetname, False, 0)


decorators.bind_all(Minimap)

########NEW FILE########
__FILENAME__ = pickbeltwidget
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.gui.style import NOTHING
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.imagebutton import ImageButton, OkButton
from horizons.gui.windows import Window
from horizons.util.python.callback import Callback


class PickBeltWidget(object):
	"""Base class for widget with sections behaving as pages"""
	sections = () # Tuple with widget name and Label
	widget_xml = '' # xml to load for the widget
	pickbelt_start_pos = (5, 150)
	page_pos = (185, 45)

	def __init__(self):
		self.page_widgets = {}
		self.widget = load_uh_widget(self.widget_xml, center_widget=True)

		# Lists holding pickbelt ImageButtons, placed to the left/right of the book
		self.buttons = {'left': [], 'right': []}

		for i, (name, text) in enumerate(self.sections):
			self.page_widgets[i] = self.widget.findChild(name=name)

		# Create the required pickbelts
		for i, (name, text) in enumerate(self.sections):
			for side in self.buttons:
				pickbelt = ImageButton(text=text)
				pickbelt.name = name + '_' + side
				pickbelt.path = 'images/background/pickbelt_%s' % side
				pickbelt.font = "pickbelt"

				pickbelt.capture(Callback(self.update_view, i), event_name="mouseClicked")

				start_x, start_y = self.pickbelt_start_pos
				pickbelt.position = (start_x + 5*i, start_y + 70*i)

				container = self.widget.findChild(name="%s_pickbelts" % side)
				container.addChild(pickbelt)
				self.buttons[side].append(pickbelt)

		self.widget.show() # Hack to initially setup the pickbelts properly
		self.update_view()
		self.widget.hide() # Hack to initially setup the pickbelts properly

	def get_widget(self):
		return self.widget

	def update_view(self, number=0):
		for page in self.page_widgets.values():
			page.hide()
		self.page_widgets[number].show()
		# Setup the pickbelts according to selection
		for belts in self.buttons.values():
			for belt in belts:
				belt.show()
		split = number + 1
		for belt in self.buttons['left'][split:] + self.buttons['right'][:split]:
			belt.hide()


class CreditsPickbeltWidget(PickBeltWidget, Window):
	"""Widget for credits dialog with pickbelt style pages"""
	widget_xml = 'credits.xml'
	sections = (
		('credits_team', u'UH-Team'),
		('credits_patchers', u'Patchers'),
		('credits_translators', u'Translators'),
		('credits_packagers', u'Packagers'),
		('credits_thanks', u'Thanks'),
	)

	def __init__(self, windows):
		Window.__init__(self, windows)
		PickBeltWidget.__init__(self)

		# Overwrite a few style pieces
		for box in self.widget.findChildren(name='box'):
			box.margins = (30, 0) # to get some indentation
			box.padding = 3
		for listbox in self.widget.findChildren(name='translators'):
			listbox.background_color = NOTHING

		self.widget.findChild(name=OkButton.DEFAULT_NAME).capture(self._windows.close)

	def show(self):
		self.widget.show()

	def hide(self):
		self.widget.hide()

########NEW FILE########
__FILENAME__ = playersoverview
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan import widgets

from horizons.gui.widgets.statswidget import StatsWidget
from horizons.util.python import decorators

class PlayersOverview(StatsWidget):
	"""Widget that shows the scores of every player in the game."""

	widget_file_name = 'players_overview.xml'

	def __init__(self, session):
		super(PlayersOverview, self).__init__(session)
		# this is supposed to run on the tick after the stats update

	def refresh(self):
		super(PlayersOverview, self).refresh()
		for player in sorted(self.session.world.players, key = lambda player: (-player.get_latest_stats().total_score, player.worldid)):
			self._add_line_to_gui(player)
		self._content_vbox.adaptLayout()

	def _add_line_to_gui(self, player):
		stats = player.get_latest_stats()

		emblem = widgets.Label(name = 'emblem_%d' % player.worldid, text=u"   ")
		emblem.background_color = player.color
		emblem.min_size = (12, 20)

		name = widgets.Label(name = 'player_%d' % player.worldid)
		name.text = player.name
		name.min_size = (108, 20)

		money_score = widgets.Label(name = 'money_score_%d' % player.worldid)
		money_score.text = unicode(stats.money_score)
		money_score.min_size = (60, 20)

		land_score = widgets.Label(name = 'land_score_%d' % player.worldid)
		land_score.text = unicode(stats.land_score)
		land_score.min_size = (50, 20)

		resource_score = widgets.Label(name = 'resource_score_%d' % player.worldid)
		resource_score.text = unicode(stats.resource_score)
		resource_score.min_size = (90, 20)

		building_score = widgets.Label(name = 'building_score_%d' % player.worldid)
		building_score.text = unicode(stats.building_score)
		building_score.min_size = (70, 20)

		settler_score = widgets.Label(name = 'settler_score_%d' % player.worldid)
		settler_score.text = unicode(stats.settler_score)
		settler_score.min_size = (60, 20)

		unit_score = widgets.Label(name = 'unit_score_%d' % player.worldid)
		unit_score.text = unicode(stats.unit_score)
		unit_score.min_size = (50, 20)

		total_score = widgets.Label(name = 'total_score_%d' % player.worldid)
		total_score.text = unicode(stats.total_score)
		total_score.min_size = (70, 20)

		hbox = widgets.HBox()
		hbox.addChild(emblem)
		hbox.addChild(name)
		hbox.addChild(money_score)
		hbox.addChild(land_score)
		hbox.addChild(resource_score)
		hbox.addChild(building_score)
		hbox.addChild(settler_score)
		hbox.addChild(unit_score)
		hbox.addChild(total_score)
		self._content_vbox.addChild(hbox)

decorators.bind_all(PlayersOverview)

########NEW FILE########
__FILENAME__ = playerssettlements
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan import widgets

from horizons.gui.widgets.statswidget import StatsWidget
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.component.namedcomponent import NamedComponent

class PlayersSettlements(StatsWidget):
	"""Widget that shows a list of the player's settlements."""

	widget_file_name = 'players_settlements.xml'

	def __init__(self, session):
		super(PlayersSettlements, self).__init__(session)

	def refresh(self):
		super(PlayersSettlements, self).refresh()
		self._gui.findChild(name='headline').text = _("Settlements of {player}").format(player=self.session.world.player.name)

		sequence_number = 0
		events = {}
		for settlement in sorted(self.session.world.settlements, key = lambda settlement: (settlement.get_component(NamedComponent).name, settlement.worldid)):
			if settlement.owner is self.session.world.player:
				sequence_number += 1
				name_label, rename_icon = self._add_line_to_gui(settlement, sequence_number)
				events['%s/mouseClicked' % name_label.name] = Callback(self._go_to_settlement, settlement)
				cb = Callback(self.session.ingame_gui.show_change_name_dialog, settlement)
				events['%s/mouseClicked' % rename_icon.name] = cb
		self._gui.mapEvents(events)
		self._add_summary_line_to_gui()
		self._content_vbox.adaptLayout()

	def _go_to_settlement(self, settlement):
		position = settlement.warehouse.position.center
		self.session.view.center(position.x, position.y)

	def _add_generic_line_to_gui(self, id, line_prefix, people, tax, costs):
		inhabitants = widgets.Label(name='inhabitants_%d' % id)
		inhabitants.text = unicode(people)
		inhabitants.min_size = inhabitants.max_size = (110, 20)

		taxes = widgets.Label(name='taxes_%d' % id)
		taxes.text = unicode(tax)
		taxes.min_size = taxes.max_size = (50, 20)

		running_costs = widgets.Label(name='running_costs_%d' % id)
		running_costs.text = unicode(costs)
		running_costs.min_size = running_costs.max_size = (100, 20)

		balance = widgets.Label(name='balance_%d' % id)
		balance.text = unicode(tax - costs)
		balance.min_size = balance.max_size = (60, 20)

		hbox = widgets.HBox()
		for widget in line_prefix:
			hbox.addChild(widget)
		hbox.addChild(inhabitants)
		hbox.addChild(taxes)
		hbox.addChild(running_costs)
		hbox.addChild(balance)
		self._content_vbox.addChild(hbox)

	def _add_line_to_gui(self, settlement, sequence_number):
		sequence_number_label = widgets.Label(name='sequence_number_%d' % settlement.worldid)
		sequence_number_label.text = unicode(sequence_number)
		sequence_number_label.min_size = sequence_number_label.max_size = (15, 20)

		name = widgets.Label(name='name_%d' % settlement.worldid)
		name.text = settlement.get_component(NamedComponent).name
		name.min_size = name.max_size = (175, 20)

		from horizons.engine.pychan_util import RenameImageButton
		rename_icon = RenameImageButton(name='rename_%d' % settlement.worldid)
		rename_icon.path = "images/background/rename_feather_20"
		rename_icon.helptext = _("Click to change the name of your settlement")
		rename_icon.max_size = (20, 20) # (width, height)

		self._add_generic_line_to_gui(settlement.worldid, [sequence_number_label, name, rename_icon],
			settlement.inhabitants, settlement.cumulative_taxes, settlement.cumulative_running_costs)
		return name, rename_icon

	def _add_summary_line_to_gui(self):
		people = 0
		tax = 0
		costs = 0
		for settlement in self.session.world.settlements:
			if settlement.owner is self.session.world.player:
				people += settlement.inhabitants
				tax += settlement.cumulative_taxes
				costs += settlement.cumulative_running_costs

		sequence_number_label = widgets.Label(name='sequence_number_total')
		sequence_number_label.min_size = sequence_number_label.max_size = (15, 20)

		name = widgets.Label(name='name_total')
		name.text = _('Total')
		name.min_size = name.max_size = (200, 20)

		self._add_generic_line_to_gui(0, [sequence_number_label, name], people, tax, costs)

decorators.bind_all(PlayersSettlements)

########NEW FILE########
__FILENAME__ = playersships
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import HBox, Label

from horizons.gui.widgets.statswidget import StatsWidget
from horizons.util.python.callback import Callback
from horizons.util.python import decorators
from horizons.world.units.fightingship import FightingShip
from horizons.component.healthcomponent import HealthComponent
from horizons.component.namedcomponent import NamedComponent
from horizons.component.selectablecomponent import SelectableComponent

class PlayersShips(StatsWidget):
	"""Widget that shows a list of the player's ships."""

	widget_file_name = 'ships_list.xml'

	def __init__(self, session):
		super(PlayersShips, self).__init__(session)

	def refresh(self):
		super(PlayersShips, self).refresh()
		player = self.session.world.player
		self._clear_entries()
		self._gui.findChild(name='headline').text = _("Ships of {player}").format(player=self.session.world.player.name)

		sequence_number = 0
		events = {}
		for ship in sorted(self.session.world.ships, key = lambda ship: (ship.get_component(NamedComponent).name, ship.worldid)):
			if ship.owner is player and ship.has_component(SelectableComponent):
				sequence_number += 1
				name_label, rename_icon, status_label, status_position = \
				          self._add_line_to_gui(ship, sequence_number)
				events['%s/mouseClicked' % name_label.name] = Callback(self._go_to_ship, ship)
				cb = Callback(self.session.ingame_gui.show_change_name_dialog, ship)
				events['%s/mouseClicked' % rename_icon.name] = cb
				events['%s/mouseClicked' % status_label.name] = Callback(self._go_to_point, status_position)
		self._gui.mapEvents(events)
		self._content_vbox.adaptLayout()

	def _go_to_ship(self, ship):
		self._go_to_point(ship.position)

	def _go_to_point(self, point):
		self.session.view.center(point.x, point.y)

	def _add_line_to_gui(self, ship, sequence_number):
		sequence_number_label = Label(name='sequence_number_%d' % ship.worldid)
		sequence_number_label.text = unicode(sequence_number)
		sequence_number_label.min_size = sequence_number_label.max_size = (15, 20)

		ship_name = Label(name='ship_name_%d' % ship.worldid)
		ship_name.text = ship.get_component(NamedComponent).name
		ship_name.min_size = ship_name.max_size = (100, 20)

		from horizons.engine.pychan_util import RenameImageButton
		rename_icon = RenameImageButton(name='rename_%d' % ship.worldid)
		rename_icon.path = "images/background/rename_feather_20"
		rename_icon.helptext = _("Click to change the name of this ship")
		rename_icon.max_size = (20, 20) # (width, height)

		ship_type = Label(name='ship_type_%d' % ship.worldid)
		ship_type.text = ship.classname
		ship_type.min_size = ship_type.max_size = (60, 20)

		weapons = Label(name='weapons_%d' % ship.worldid)
		if isinstance(ship, FightingShip):
			weapon_list = []
			for weapon_id, amount in sorted(ship.get_weapon_storage().itercontents()):
				weapon_list.append('%d %s' % (amount, self.session.db.get_res_name(weapon_id)))
			if weapon_list:
				weapons.text = u', '.join(weapon_list)
			else:
				#i18n There are no weapons equipped at the moment.
				weapons.text = _('None')
		else:
			weapons.text = _('N/A')
		weapons.min_size = weapons.max_size = (60, 20)

		health = Label(name='health_%d' % ship.worldid)
		health_component = ship.get_component(HealthComponent)
		health.text = u'%d/%d' % (health_component.health, health_component.max_health)
		health.min_size = health.max_size = (65, 20)

		status = Label(name='status_%d' % ship.worldid)
		status.text, status_position = ship.get_status()
		status.min_size = status.max_size = (320, 20)

		hbox = HBox()
		hbox.addChild(sequence_number_label)
		hbox.addChild(ship_name)
		hbox.addChild(rename_icon)
		hbox.addChild(ship_type)
		hbox.addChild(weapons)
		hbox.addChild(health)
		hbox.addChild(status)
		self._content_vbox.addChild(hbox)
		return (ship_name, rename_icon, status, status_position)

decorators.bind_all(PlayersShips)

########NEW FILE########
__FILENAME__ = productionoverview
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from operator import itemgetter

from fife.extensions.pychan import widgets

from horizons.constants import GAME_SPEED
from horizons.gui.widgets.statswidget import StatsWidget
from horizons.scheduler import Scheduler
from horizons.util.python import decorators
from horizons.gui.util import create_resource_icon
from horizons.gui.windows import Window
from horizons.util.python.callback import Callback
from horizons.component.namedcomponent import NamedComponent
from horizons.gui.widgets.imagebutton import OkButton

class ProductionOverview(StatsWidget, Window):
	"""
	Widget that shows every produced resource in this game.

	Implementation based on https://github.com/unknown-horizons/unknown-horizons/issues/749 .
	"""

	widget_file_name = 'island_production.xml'

	def __init__(self, windows, settlement):
		StatsWidget.__init__(self, settlement.session, center_widget=True)
		Window.__init__(self, windows)

		self.settlement = settlement
		self.db = self.settlement.session.db
		Scheduler().add_new_object(Callback(self._refresh_tick), self, run_in=GAME_SPEED.TICKS_PER_SECOND, loops=-1)

	def _init_gui(self):
		super(ProductionOverview, self)._init_gui()
		self._gui.findChild(name=OkButton.DEFAULT_NAME).capture(self._windows.close)

	def refresh(self):
		super(ProductionOverview, self).refresh()
		name = self.settlement.get_component(NamedComponent).name
		text = _('Production overview of {settlement}').format(settlement=name)
		self._gui.findChild(name='headline').text = text

		data = sorted(self.settlement.produced_res.items(), key=itemgetter(1), reverse=True)
		for resource_id, amount in data:
			self._add_line_to_gui(resource_id, amount)
		self._content_vbox.adaptLayout()

	def _add_line_to_gui(self, resource_id, amount):
		displayed = self.db.get_res_inventory_display(resource_id)
		if not displayed:
			return
		res_name = self.db.get_res_name(resource_id)

		icon = create_resource_icon(resource_id, self.db)
		icon.name = 'icon_%s' % resource_id
		icon.max_size = icon.min_size = icon.size = (20, 20)

		label = widgets.Label(name = 'resource_%s' % resource_id)
		label.text = res_name
		label.min_size = (100, 20)

		amount_label = widgets.Label(name = 'produced_sum_%s' % resource_id)
		amount_label.text = unicode(amount)

		hbox = widgets.HBox()
		hbox.addChild(icon)
		hbox.addChild(label)
		hbox.addChild(amount_label)
		self._content_vbox.addChild(hbox)

decorators.bind_all(ProductionOverview)

########NEW FILE########
__FILENAME__ = progressbar
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from fife.extensions.pychan.widgets import Icon, Widget
from fife.extensions.pychan.widgets.common import Attr, IntAttr

from horizons.gui.widgets.container import AutoResizeContainer
from horizons.gui.widgets.icongroup import TilingHBox


class ProgressBar(AutoResizeContainer):
	"""The ProgressBar is a pychan widget. It can be used in xml files like this:
	<ProgressBar />
	It is used to display a ProgressBar with a certain progress ;). Set the
	widgets progress attribute to set the progress. Pretty straight forward.
	The progress is a value from 0 to 100. Think of it as percent.
	"""
	ATTRIBUTES = AutoResizeContainer.ATTRIBUTES + [
		IntAttr('progress'), Attr('fill'), Attr('background'),
	]

	def __init__(self, progress=0, fill=None, background=None, **kwargs):
		super(ProgressBar, self).__init__(**kwargs)
		if self.max_size == Widget.DEFAULT_MAX_SIZE:
			self.max_size = (100, 16)
		self.__progress = progress
		self.__fill = fill
		self.__background = background
		self.tiles = None
		self.bg_icon = None

	def _set_progress(self, progress):
		self.__progress = progress
		if self.bg_icon is None:
			self.background = "content/gui/images/background/bar_bg.png"
		if self.tiles is None:
			self.fill = "content/gui/images/background/widgets/progressbar_fill.png"
		self.tiles.size = (int(self.max_size[0] * progress / 100.0), self.max_size[1])
		self.adaptLayout()

	def _get_progress(self):
		return self.__progress

	def _set_fill_image(self, image):
		self.__fill = image
		self.tiles = Icon(image=image)
		self.addChild(self.tiles)

	def _get_fill_image(self):
		return self.__fill

	def _set_background(self, background):
		self.__background = background
		self.bg_icon = Icon(image=background)
		self.bg_icon.min_size = self.bg_icon.size = self.max_size
		self.addChild(self.bg_icon)

	def _get_background(self):
		return self.__background

	progress = property(_get_progress, _set_progress)
	fill = property(_get_fill_image, _set_fill_image)
	background = property(_get_background, _set_background)


class TilingProgressBar(ProgressBar):
	"""ProgressBar that tiles its fill image instead of stretching.

	Also supports distinct left and right border/frame images which count
	towards the displayed progress value and fill images of width > 1px.
	"""
	ATTRIBUTES = ProgressBar.ATTRIBUTES + [Attr('left'), Attr('right')]

	def __init__(self, left=None, right=None, **kwargs):
		super(TilingProgressBar, self).__init__(**kwargs)
		self.__left = left
		self.__right = right
		self.tiles = TilingHBox()
		self.addChild(self.tiles)
		self.tiles_width = 1
		self.left_width = 0
		self.right_width = 0

	def _get_progress(self):
		return self.__progress
	def _set_progress(self, progress):
		self.__progress = progress
		fill_width = (progress / 100.0) * (self.max_size[0] / self.tiles_width)
		self.tiles.amount = int(fill_width) - self.left_width - self.right_width
		self.adaptLayout()

	def _get_left_image(self):
		return self.__left
	def _set_left_image(self, image):
		self.__left = image
		self.left_width = Icon(image=image).size[0]
		self.tiles.start_img = image

	def _get_fill_image(self):
		return self.__fill
	def _set_fill_image(self, image):
		self.__fill = image
		self.tiles_width = Icon(image=image).size[0]
		self.tiles.tiles_img = image

	def _get_right_image(self):
		return self.__right
	def _set_right_image(self, image):
		self.__right = image
		self.right_width = Icon(image=image).size[0]
		self.tiles.final_img = image

	progress = property(_get_progress, _set_progress)
	left = property(_get_left_image, _set_left_image)
	fill = property(_get_fill_image, _set_fill_image)
	right = property(_get_right_image, _set_right_image)

########NEW FILE########
__FILENAME__ = resourceoverviewbar
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import json
import weakref
import itertools
import functools

from fife import fife
from fife.extensions.pychan.widgets import HBox, Icon, Label, Spacer

import horizons.globals

from horizons.constants import TIER, RES
from horizons.component.storagecomponent import StorageComponent
from horizons.gui.mousetools.buildingtool import BuildingTool
from horizons.gui.mousetools.navigationtool import NavigationTool
from horizons.gui.util import load_uh_widget, get_res_icon_path, create_resource_selection_dialog
from horizons.util.pychanchildfinder import PychanChildFinder
from horizons.util.python.callback import Callback
from horizons.util.python.decorators import cachedmethod
from horizons.extscheduler import ExtScheduler
from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.util.lastactiveplayersettlementmanager import LastActivePlayerSettlementManager
from horizons.messaging import NewPlayerSettlementHovered, ResourceBarResize, TabWidgetChanged
from horizons.world.player import Player


class ResourceOverviewBar(object):
	"""The thing on the top left.

	http://wiki.unknown-horizons.org/w/HUD

	Features:
	- display contents of currently relevant inventory (settlement/ship)
	- always show gold of local player
	- show costs of current build
	- configure the resources to show
		- per settlement
		- add new slots
		- switch displayed resources to construction relevant res on build
		- res selection consistent with other res selection dlgs

	Invariants:
	- it should be obvious that the res bar can be configured
	- it should be obvious that the res bar can be set per settlement

	Has distinguished treatment of gold because it's distinguished by a bigger icon
	and by being shown always.
	"""

	GOLD_ENTRY_GUI_FILE = "resource_overview_bar_gold.xml"
	INITIAL_X_OFFSET = 100 # length of money icon (87px) + padding (10px left, 3px right)

	ENTRY_GUI_FILE = "resource_overview_bar_entry.xml"
	ENTRY_X_OFFSET = 52 # length of entry icons (49px) + padding (3px right)
	ENTRY_Y_OFFSET = 17 # only padding (17px top)!
	ENTRY_Y_HEIGHT = 66 # only height of entry icons (66px)!
	CONSTRUCTION_LABEL_HEIGHT = 22 # height of extra label shown in build preview mode

	STATS_GUI_FILE = "resource_overview_bar_stats.xml"

	STYLE = "resource_bar"

	DEFAULT_RESOURCES = [ RES.TOOLS,
	                      RES.BOARDS,
	                      RES.BRICKS,
	                      RES.FOOD,
	                      RES.TEXTILE,
	                      RES.SALT]

	# order should match the above, else confuses players when in build mode
	CONSTRUCTION_RESOURCES = { # per inhabitant tier
	  TIER.SAILORS:  [ RES.TOOLS, RES.BOARDS ],
	  TIER.PIONEERS: [ RES.TOOLS, RES.BOARDS, RES.BRICKS ],
	  TIER.SETTLERS: [ RES.TOOLS, RES.BOARDS, RES.BRICKS ],
	  TIER.CITIZENS: [ RES.TOOLS, RES.BOARDS, RES.BRICKS ],
	}

	def __init__(self, session):
		from horizons.session import Session
		assert isinstance(session, Session)
		self.session = session

		# special slot because of special properties
		self.gold_gui = load_uh_widget(self.__class__.GOLD_ENTRY_GUI_FILE, style=self.__class__.STYLE)
		self.gold_gui.balance_visible = False
		self.gold_gui.child_finder = PychanChildFinder(self.gold_gui)
		gold_icon = self.gold_gui.child_finder("res_icon")
		gold_icon.image = get_res_icon_path(RES.GOLD)
		gold_icon.max_size = gold_icon.min_size = gold_icon.size = (32, 32)
		self.gold_gui.mapEvents({
		  "resbar_gold_container/mouseClicked/stats" : self._toggle_stats,
		  })
		self.gold_gui.helptext = _("Click to show statistics")
		self.stats_gui = None

		self.gui = [] # list of slots
		self.resource_configurations = weakref.WeakKeyDictionary()
		self.current_instance = weakref.ref(self) # can't weakref to None
		self.construction_mode = False
		self._last_build_costs = None
		self._do_show_dummy = False

		self._update_default_configuration()

		NewPlayerSettlementHovered.subscribe(self._on_different_settlement)
		TabWidgetChanged.subscribe(self._on_tab_widget_changed)

		# set now and then every few sec
		ExtScheduler().add_new_object(self._update_balance_display, self, run_in=0)
		ExtScheduler().add_new_object(self._update_balance_display, self, run_in=Player.STATS_UPDATE_INTERVAL, loops=-1)

	def hide(self):
		self.gold_gui.hide()
		for slot in self.gui:
			slot.hide()
		if self.stats_gui:
			self.stats_gui.hide()

	def end(self):
		self.set_inventory_instance( None, force_update=True )
		self.current_instance = weakref.ref(self)
		ExtScheduler().rem_all_classinst_calls(self)
		self.resource_configurations.clear()
		self.hide()
		self.gold_gui = None
		self.gui = None
		self.stats_gui = None
		self._custom_default_resources = None
		NewPlayerSettlementHovered.unsubscribe(self._on_different_settlement)
		TabWidgetChanged.unsubscribe(self._on_tab_widget_changed)

	def _update_default_configuration(self):
		# user defined variante of DEFAULT_RESOURCES (will be preferred)
		self._custom_default_resources = None
		setting = horizons.globals.fife.get_uh_setting("ResourceOverviewBarConfiguration")
		if setting: # parse it if there is something
			config = json.loads(setting)
			if config: # actually use it if it was parseable
				self._custom_default_resources = config

	def save(self, db):
		for obj, config in self.resource_configurations.iteritems():
			for position, res in enumerate(config):
				db("INSERT INTO resource_overview_bar(object, position, resource) VALUES(?, ?, ?)",
				   obj.worldid, position, res)

	def load(self, db):
		from horizons.util.worldobject import WorldObject
		for obj in db("SELECT DISTINCT object FROM resource_overview_bar"):
			obj = obj[0]
			l = []
			for pos, res in db("SELECT position, resource FROM resource_overview_bar where object=?", obj):
				l.append( (pos, res) )
			obj = WorldObject.get_object_by_id(obj)
			self.resource_configurations[obj] = [ i[1] for i in sorted(l) ]

		# called when any game (also new ones) start
		# register at player inventory for gold updates
		inv = self.session.world.player.get_component(StorageComponent).inventory
		inv.add_change_listener(self._update_gold, call_listener_now=True)
		self.gold_gui.show()
		self._update_gold() # call once more to make pychan happy

		self.set_inventory_instance(
		  LastActivePlayerSettlementManager().get(get_current_pos=True))

	def redraw(self):
		self.set_inventory_instance(self.current_instance(), force_update=True)

	def _on_different_settlement(self, message):
		self.set_inventory_instance(message.settlement)

	def set_inventory_instance(self, instance, keep_construction_mode=False, force_update=False):
		"""Display different inventory. May change resources that are displayed"""
		if self.current_instance() is instance and not self.construction_mode and not force_update:
			return # caller is drunk yet again
		if self.construction_mode and not keep_construction_mode:
			# stop construction mode, immediately update view, which will be a normal view
			self.close_construction_mode(update_slots=False)

		# reconstruct general gui

		# remove old gui (keep entries for reuse)
		for i in self.gui:
			i.hide()
		self._hide_resource_selection_dialog()

		inv = self._get_current_inventory()
		if inv is not None:
			inv.remove_change_listener(self._update_resources)

		if instance in (None, self): # show nothing instead
			self.current_instance = weakref.ref(self) # can't weakref to None
			self._do_show_dummy = False # don't save dummy value
			return

		self.current_instance = weakref.ref(instance)

		# construct new slots (fill values later)
		load_entry = lambda : load_uh_widget(self.ENTRY_GUI_FILE, style=self.__class__.STYLE)
		resources = self._get_current_resources()
		addition = [-1] if self._do_show_dummy or not resources else [] # add dummy at end for adding stuff
		for i, res in enumerate( resources + addition ):
			try: # get old slot
				entry = self.gui[i]
				if res == -1: # can't reuse dummy slot, need default data
					self.gui[i] = entry = load_entry()
			except IndexError: # need new one
				entry = load_entry()
				self.gui.append(entry)

			entry.findChild(name="entry").position = (self.INITIAL_X_OFFSET + i * self.ENTRY_X_OFFSET,
			                                          self.ENTRY_Y_OFFSET)
			background_icon = entry.findChild(name="entry")
			background_icon.capture(Callback(self._show_resource_selection_dialog, i), 'mouseEntered', 'resbar')

			if res != -1:
				helptext = self.session.db.get_res_name(res)
				icon = entry.findChild(name="res_icon")
				icon.num = i
				icon.image = get_res_icon_path(res)
				icon.max_size = icon.min_size = icon.size = (24, 24)
				icon.capture(self._on_res_slot_click, event_name='mouseClicked')
			else:
				helptext = _("Click to add a new slot")
				entry.show() # this will not be filled as the other res
			background_icon.helptext = helptext

			# show it just when values are entered, this appeases pychan

		# fill values
		inv = self._get_current_inventory()
		# update on all changes as well as now
		inv.add_change_listener(self._update_resources, call_listener_now=True)

	def set_construction_mode(self, resource_source_instance, build_costs):
		"""Show resources relevant to construction and build costs
		@param resource_source_instance: object with StorageComponent
		@param build_costs: dict, { res : amount }
		"""
		if resource_source_instance is None:
			# Build moved out of settlement. This is usually not sane and an interaction error.
			# Use this heuristically computed settlement to fix preconditions.
			resource_source_instance = LastActivePlayerSettlementManager().get()
		if self.construction_mode and \
		   resource_source_instance == self.current_instance() and \
		   build_costs == self._last_build_costs:
			return # now that's not an update

		self._last_build_costs = build_costs

		self.construction_mode = True
		self.set_inventory_instance(resource_source_instance, keep_construction_mode=True)

		# label background icons
		cost_icon_gold = "content/gui/images/background/widgets/resbar_stats_bottom.png"
		cost_icon_res = "content/gui/images/background/widgets/res_extra_bg.png"

		res_list = self._get_current_resources()

		# remove old one before, avoids duplicates
		self._drop_cost_labels()

		for res, amount in build_costs.iteritems():
			assert res in res_list or res == RES.GOLD

			cost_label = Label(text=u"-"+unicode(amount))
			cost_label.stylize( self.__class__.STYLE )
			# add icon below end of background icon
			if res in res_list:
				entry = res_list.index(res)
				cur_gui = self.gui[ entry ]
				reference_icon = cur_gui.findChild(name="background_icon")
				below = reference_icon.size[1]
				cost_icon = Icon(image=cost_icon_res, position=(0, below))
				cost_label.position = (15, below) # TODO: centering

				cur_gui.addChild(cost_icon)
				cur_gui.addChild(cost_label)
				cur_gui.cost_gui = [cost_label, cost_icon]

				cur_gui.resizeToContent() # container needs to be bigger now
			else: # must be gold
				# there is an icon with scales there, use its positioning
				reference_icon = self.gold_gui.child_finder("balance_background")
				cost_icon = Icon(image=cost_icon_gold, position=(reference_icon.x, reference_icon.y))
				cost_label.position = (23, 74) # TODO: centering

				self.gold_gui.addChild(cost_icon)
				self.gold_gui.addChild(cost_label)
				self.gold_gui.cost_gui = [cost_label, cost_icon]

				self.gold_gui.resizeToContent()

	def close_construction_mode(self, update_slots=True):
		"""Return to normal configuration"""
		self.construction_mode = False
		if update_slots: # cleanup
			self._drop_cost_labels()
			self.set_inventory_instance(None)
		#self._update_gold()
		self.gold_gui.show()
		self._update_gold(force=True)

		# reshow last settlement
		self.set_inventory_instance( LastActivePlayerSettlementManager().get(get_current_pos=True) )

	def _drop_cost_labels(self):
		"""Removes all labels below the slots indicating building costs"""
		for entry in itertools.chain(self.gui, [self.gold_gui]):
			if hasattr(entry, "cost_gui"): # get rid of possible cost labels
				for elem in entry.cost_gui:
					entry.removeChild(elem)
				del entry.cost_gui

	def _update_gold(self, force=False):
		"""Changelistener to upate player gold"""
		# can be called pretty often (e.g. if there's an settlement.inventory.alter() in a loop)
		# only update every 0.3 sec at most
		scheduled_attr = "_gold_upate_scheduled"
		if not hasattr(self, scheduled_attr):
			setattr(self, scheduled_attr, True)
			ExtScheduler().add_new_object(Callback(self._update_gold, force=True), self, run_in=0.3)
			return
		elif not force:
			return # these calls we want to suppress, wait for scheduled call

		delattr(self, scheduled_attr)

		# set gold amount
		gold = self.session.world.player.get_component(StorageComponent).inventory[RES.GOLD]
		gold_available_lbl = self.gold_gui.child_finder("gold_available")
		gold_available_lbl.text = unicode(gold)
		# reposition according to magic formula passed down from the elders in order to support centering
		gold_available_lbl.resizeToContent() # this sets new size values
		gold_available_lbl.position = (42 - (gold_available_lbl.size[0] // 2), 51)

		self.gold_gui.resizeToContent() # update label size

	def _update_balance_display(self):
		"""Updates balance info below gold icon"""
		balance = self.session.world.player.get_balance_estimation()
		balance_lbl = self.gold_gui.child_finder("balance")
		balance_lbl.text = u"{balance:+}".format(balance=balance)
		balance_lbl.resizeToContent()
		# 38
		balance_lbl.position = (70 - balance_lbl.size[0],  74) # see _update_gold

		self.gold_gui.resizeToContent() # update label size

	def _update_resources(self):
		"""Same as _update_gold but for all other slots"""
		if self.current_instance() in (None, self): # instance died
			self.set_inventory_instance(None)
			return
		inv = self._get_current_inventory()
		for i, res in enumerate(self._get_current_resources()):
			cur_gui = self.gui[i]

			# set amount
			label = cur_gui.findChild(name="res_available")
			label.text = unicode( inv[res] )

			# reposition according to magic formula passed down from the elders in order to support centering
			cur_gui.adaptLayout() # update size values (e.g. if amount of digits changed)
			cur_gui.show()
			label.position = (24 - (label.size[0] // 2), 44)

	def _get_current_resources(self):
		"""Return list of resources to display now"""
		if self.construction_mode:
			tier = self.session.world.player.settler_level
			res_list = self.__class__.CONSTRUCTION_RESOURCES[tier]
			# also add additional res that might be needed
			res_list += [ res for res in self._last_build_costs if
			              res not in res_list and res != RES.GOLD ]
			return res_list
		# prefer user defaults over general defaults
		default = self._custom_default_resources if self._custom_default_resources else self.__class__.DEFAULT_RESOURCES
		# prefer specific setting over any defaults
		return self.resource_configurations.get(self.current_instance(), default)

	def _get_current_inventory(self):
		if not (self.current_instance() in (None, self)): # alive and set
			return self.current_instance().get_component(StorageComponent).inventory
		else:
			return None

	def get_size(self):
		"""Returns (x,y) size tuple.

		Used by the cityinfo to determine how to change its position if the widgets
		overlap using default positioning (resource bar can get arbitrarily long).
		Note that the money icon has the same offset effect as all entry icons have
		(height 73 + padding 10 == height 66 + padding 17), thus the calculation only
		needs of regular items (ENTRY_Y_*) to determine the maximum widget height.
		"""
		item_amount = len(self._get_current_resources())
		width = self.INITIAL_X_OFFSET + self.ENTRY_X_OFFSET * item_amount
		height = self.ENTRY_Y_OFFSET + self.ENTRY_Y_HEIGHT
		return (width, height)


	###
	# Resource slot selection

	def _show_resource_selection_dialog(self, slot_num):
		"""Shows gui for selecting a resource for slot slot_num"""
		if isinstance(self.session.ingame_gui.cursor, BuildingTool):
			return

		self._hide_resource_selection_dialog()
		inv = self._get_current_inventory()
		if inv is None:
			return

		self._show_dummy_slot()

		# set mousetool to get notified on clicks outside the resbar area
		if not isinstance(self.session.ingame_gui.cursor, ResBarMouseTool):
			self.session.ingame_gui.cursor = ResBarMouseTool(self.session, self.session.ingame_gui.cursor,
			                                      self.close_resource_selection_mode)


		on_click = functools.partial(self._set_resource_slot, slot_num)
		cur_res = self._get_current_resources()
		res_filter = lambda res_id : res_id not in cur_res
		dlg = create_resource_selection_dialog(on_click, inv, self.session.db,
		                                       widget='resbar_resource_selection.xml',
		                                       res_filter=res_filter)

		# position dlg below slot
		cur_gui = self.gui[slot_num]
		background_icon = cur_gui.findChild(name="background_icon")
		dlg.position = (cur_gui.position[0] + background_icon.position[0],
		                cur_gui.position[1] + background_icon.position[1] + background_icon.size[1] )
		dlg.findChild(name="make_default_btn").capture(self._make_configuration_default)
		reset_default_btn = dlg.findChild(name="reset_default_btn")
		# this is a quadruple-use button.
		# If there is no user set default, restore to factory default
		# If the current config is different from user default, set to default
		# If this is the current user set config, remove user set config and fall back to factory default
		# If there is no user set config and the current config is the system default,
		# the button should be disabled, but the first case below is shown because
		# we can't disable it
		if self._custom_default_resources is None:
			reset_default_btn.helptext = _("Reset this configuration to the factory default.")
			reset_default_btn.capture(Callback(self._drop_settlement_resource_configuration))

		elif self._custom_default_resources != self._get_current_resources():
			reset_default_btn.helptext = _("Reset this settlement's displayed resources to the default configuration you have saved.")
			reset_default_btn.capture(Callback(self._drop_settlement_resource_configuration))

		else:
			reset_default_btn.helptext = _("Reset the default configuration (which you see here) to the factory default for all settlements.")
			cb = Callback.ChainedCallbacks(
			  self._drop_settlement_resource_configuration, # remove specific config
			  Callback(self._make_configuration_default, reset=True) # remove global config
			)
			reset_default_btn.capture( cb )

		dlg.show()
		self._res_selection_dialog = dlg

	def _make_configuration_default(self, reset=False):
		"""Saves current resources as default via game settings"""
		if reset:
			config = [] # meaning invalid
		else:
			config = json.dumps(self._get_current_resources())
		horizons.globals.fife.set_uh_setting("ResourceOverviewBarConfiguration", config)
		horizons.globals.fife.save_settings()
		self._update_default_configuration()
		AmbientSoundComponent.play_special("success")
		if reset: # in the other case, it's already set
			self.redraw()

	def _drop_settlement_resource_configuration(self):
		"""Forget resource configuration for a settlement"""
		if self.current_instance() in self.resource_configurations:
			del self.resource_configurations[self.current_instance()]
		self.redraw()

	def _set_resource_slot(self, slot_num, res_id):
		"""Show res_id in slot slot_num
		@param slot_num: starting at 0, will be added as new slot if greater than no of slots
		@param res_id: a resource id or 0 for remove slot
		"""
		self.close_construction_mode()
		res_copy = self._get_current_resources()[:]
		number_of_slots_changed = False
		if slot_num < len(res_copy): # change existing slot
			if res_id == 0: # remove it
				del res_copy[slot_num]
				number_of_slots_changed = True
			else: # actual slot change
				res_copy[slot_num] = res_id
		else: # addition
			if res_id == 0: # that would mean adding an empty slot
				pass
			else:
				number_of_slots_changed = True
				res_copy += [res_id]

		self.resource_configurations[self.current_instance()] = res_copy

		if number_of_slots_changed:
			ResourceBarResize.broadcast(self)
		self.redraw()

		if isinstance(self.session.ingame_gui.cursor, ResBarMouseTool):
			self.session.ingame_gui.cursor.reset()

	def _hide_resource_selection_dialog(self):
		if hasattr(self, "_res_selection_dialog"):
			self._res_selection_dialog.hide()
			del self._res_selection_dialog

	def close_resource_selection_mode(self):
		"""Fully disable resource selection mode"""
		self._hide_resource_selection_dialog()
		self._hide_dummy_slot()

	def _on_tab_widget_changed(self, msg=None):
		if hasattr(self, "_res_selection_dialog"):
			self.close_resource_selection_mode()

	def _show_dummy_slot(self):
		"""Show the dummy button at the end to allow for addition of slots"""
		if self._do_show_dummy:
			return # already visible
		self._do_show_dummy = True
		self.redraw()

	def _hide_dummy_slot(self):
		self._do_show_dummy = False
		self.redraw()

	def _on_res_slot_click(self, widget, event):
		"""Called when you click on a resource slot in the bar (not the selection dialog)"""
		#TODO let KeyConfig handle this instead of hardcoding rmb
		if event.getButton() == fife.MouseEvent.RIGHT:
			self._set_resource_slot(widget.num, 0)

	def _toggle_stats(self):
		if self.stats_gui is None or not self.stats_gui.isVisible():
			self._show_stats()
		else:
			self._hide_stats()

	def _show_stats(self):
		"""Show data below gold icon when balance label is clicked"""
		if self.stats_gui is None:
			self._init_stats_gui()

		self._update_stats()
		self.stats_gui.show()

		ExtScheduler().add_new_object(self._update_stats, self, run_in=Player.STATS_UPDATE_INTERVAL, loops=-1)

	def _update_stats(self):
		"""Fills in (refreshes) numeric values in expanded stats area."""
		data = self.session.world.player.get_statistics()
		# This list must correspond to `images` in _show_stats
		figures = [
			-data.running_costs,
			data.taxes,
			-data.buy_expenses,
			data.sell_income,
			data.balance
		]
		for (i, numbers) in enumerate(figures):
			label = self.stats_gui.child_finder("resbar_stats_entry_%s" % i)
			label.text = u"%+d" % numbers

	def _hide_stats(self):
		"""Inverse of show_stats"""
		ExtScheduler().rem_call(self, self._update_stats)
		if self.stats_gui is not None:
			self.stats_gui.hide()

	def _init_stats_gui(self):
		reference_icon = self.gold_gui.child_finder("balance_background")
		self.stats_gui = load_uh_widget(self.__class__.STATS_GUI_FILE)
		self.stats_gui.child_finder = PychanChildFinder(self.stats_gui)
		self.stats_gui.position = (reference_icon.x + self.gold_gui.x,
		                           reference_icon.y + self.gold_gui.y)
		self.stats_gui.mapEvents({
			'resbar_stats_container/mouseClicked/stats': self._toggle_stats,
		})

		# This list must correspond to `figures` in _update_stats
		images = [
			("content/gui/images/resbar_stats/expense.png",     _("Running costs")),
			("content/gui/images/resbar_stats/income.png",      _("Taxes")),
			("content/gui/images/resbar_stats/buy.png",         _("Buy expenses")),
			("content/gui/images/resbar_stats/sell.png",        _("Sell income")),
			("content/gui/images/resbar_stats/scales_icon.png", _("Balance")),
		]

		for num, (image, helptext) in enumerate(images):
			# Keep in sync with comment there until we can use that data:
			# ./content/gui/xml/ingame/hud/resource_overview_bar_stats.xml
			box = HBox(padding=0, min_size=(70, 0))
			box.name = "resbar_stats_line_%s" % num
			box.helptext = helptext
			#TODO Fix icon size; looks like not 16x16 a surprising amount of times.
			box.addChild(Icon(image=image))
			box.addSpacer(Spacer())
			box.addChild(Label(name="resbar_stats_entry_%s"%num))
			#TODO This label is a workaround for some fife font bug,
			# probably http://github.com/fifengine/fifengine/issues/666.
			templabel = Label(name="resbar_stats_whatever_%s"%num)
			box.addChild(templabel)
			if num == len(images) - 1:
				# The balance line (last one) gets bold font.
				box.stylize('resource_bar')
			self.stats_gui.child_finder("entries_box").addChild(box)

	##
	# CODE FOR REFERENCE
	##

	@cachedmethod
	def _get_res_background_icon_position(self):
		# currently unused since always 0
		# can be used for relative positioning of labels
		# old formula: label.position = (icon.position[0] - label.size[0]/2 + xoffset, yoffset)
		gui = load_uh_widget( self.__class__.ENTRY_GUI_FILE )
		icon = gui.findChild(name="background_icon")
		return icon.position

	@cachedmethod
	def _get_gold_background_icon_position(self):
		# see above
		gui = load_uh_widget( self.__class__.GOLD_ENTRY_GUI_FILE )
		icon = gui.findChild(name="background_icon")
		return icon.position


class ResBarMouseTool(NavigationTool):
	"""Temporary mousetool for resource selection.
	Terminates self on mousePressed and restores old tool"""
	def __init__(self, session, old_tool, on_click):
		super(ResBarMouseTool, self).__init__(session)
		if old_tool: # can be None in corner cases
			old_tool.disable()
		self.old_tool = old_tool
		self.on_click = on_click

	def mousePressed(self, evt):
		self.on_click()
		self.reset()
		# this click should still count, especially in case the res
		# selection dialog has been closed by other means than clicking
		self.session.ingame_gui.cursor.mousePressed(evt)

	def reset(self):
		"""Enable old tool again"""
		if self.old_tool:
			self.session.ingame_gui.cursor = self.old_tool
		self.remove()
		if self.old_tool:
			self.old_tool.enable()
		else:
			self.session.ingame_gui.set_cursor()

########NEW FILE########
__FILENAME__ = routeconfig
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import weakref
import functools

from fife import fife

from horizons.gui.util import load_uh_widget
from horizons.util.python.callback import Callback
from horizons.util.shapes import Point
from fife.extensions.pychan import widgets
from horizons.component.storagecomponent import StorageComponent
from horizons.gui.widgets.minimap import Minimap
from horizons.gui.windows import Window
from horizons.command.uioptions import RouteConfigCommand
from horizons.component.namedcomponent import NamedComponent
from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.gui.util import create_resource_selection_dialog, get_res_icon_path

from horizons.gui.widgets.imagebutton import OkButton

import horizons.globals


class RouteConfig(Window):
	"""
	Widget that allows configurating a ship's trading route
	"""
	dummy_icon_path = "content/gui/icons/resources/none_gray.png"
	buy_button_path = "content/gui/images/tabwidget/warehouse_to_ship.png"
	sell_button_path = "content/gui/images/tabwidget/ship_to_warehouse.png"
	hover_button_path = "content/gui/images/tabwidget/buysell_toggle.png"
	MAX_ENTRIES = 7
	MIN_ENTRIES = 2
	SLOTS_PER_ENTRY = 3

	def __init__(self, windows, instance):
		super(RouteConfig, self).__init__(windows)

		self.instance = instance

		if not hasattr(instance, 'route'):
			instance.create_route()

		self._init_gui()

	@property
	def session(self):
		session = self.instance.session
		assert isinstance(session, horizons.session.Session)
		return session

	def show(self):
		self.minimap.draw()
		self._gui.show()

		self.instance.add_remove_listener(self.on_instance_removed, no_duplicates=True)
		self.instance.route.add_change_listener(self.on_route_change, no_duplicates=True, call_listener_now=True)

	def hide(self):
		self.minimap.disable()
		self._gui.hide()

		self.instance.discard_remove_listener(self.on_instance_removed)
		self.instance.route.discard_remove_listener(self.on_route_change)

		# make sure user knows that it's not enabled (if it appears to be complete)
		if not self.instance.route.enabled and self.instance.route.can_enable():
			self.session.ingame_gui.message_widget.add('ROUTE_DISABLED')

	def on_instance_removed(self):
		self._windows.close()
		self.instance = None

	def on_route_change(self):
		"""Called on changelistener notifications from the route"""
		if self.instance.route.enabled:
			self.start_button_set_inactive()
		else:
			self.start_button_set_active()

	def start_button_set_active(self):
		self._gui.findChild(name='start_route').set_active()
		self._gui.findChild(name='start_route').helptext = _('Start route')

	def start_button_set_inactive(self):
		self._gui.findChild(name='start_route').set_inactive()
		self._gui.findChild(name='start_route').helptext = _('Stop route')

	def start_route(self):
		if self.instance.route.can_enable():
			self._route_cmd("enable")
		else:
			self.instance.session.ingame_gui.open_popup(
				_("Need at least two settlements"),
				_("You need at least two different settlements in your route."))

	def stop_route(self):
		self._route_cmd("disable")

	def toggle_route(self):
		if not self.instance.route.enabled:
			self.start_route()
		else:
			self.stop_route()

	def remove_entry(self, entry):
		if self.resource_menu_shown:
			self.hide_resource_menu()
		vbox = self._gui.findChild(name="left_vbox")
		self.slots.pop(entry)
		position = self.widgets.index(entry)
		self._route_cmd("remove_waypoint", position)
		self.widgets.pop(position)
		vbox.removeChild(entry)

		self._check_no_entries_label()

		self._gui.adaptLayout()

	def _check_no_entries_label(self):
		"""Update hint informing about how to add waypoints. Only visible when there are none."""
		name = "no_entries_hint"
		if not self.instance.route.waypoints:
			lbl = widgets.Label(name=name, text=_("Click on a settlement to add a waypoint!"))
			self._gui.findChild(name="left_vbox").addChild(lbl)
		else:
			lbl = self._gui.findChild(name=name)
			if lbl:
				self._gui.findChild(name="left_vbox").removeChild(lbl)

	def move_entry(self, entry, direction):
		"""
		moves an entry up or down
		"""
		# Abort (with error sound) if moving this entry is not possible.
		position = self.widgets.index(entry)
		if position == len(self.widgets) and direction == 'down' or \
		   position == 0 and direction == 'up':
			AmbientSoundComponent.play_special('error')
			return

		if direction == 'up':
			new_pos = position - 1
		elif direction == 'down':
			new_pos = position + 1
		else:
			assert False, 'Direction for `move_entry` is neither "up" nor "down".'

		vbox = self._gui.findChild(name="left_vbox")

		vbox.removeChildren(self.widgets)
		self.widgets.insert(new_pos, self.widgets.pop(position))
		self._route_cmd("move_waypoint", position, direction)
		vbox.addChildren(self.widgets)

		self._gui.adaptLayout()
		self._resource_selection_area_layout_hack_fix()

	def show_load_icon(self, slot):
		button = slot.findChild(name="buysell")
		button.up_image = self.buy_button_path
		button.hover_image = self.hover_button_path
		button.helptext = _("Loading into ship")
		slot.action = "load"

	def show_unload_icon(self, slot):
		button = slot.findChild(name="buysell")
		button.up_image = self.sell_button_path
		button.hover_image = self.hover_button_path
		button.helptext = _("Unloading from ship")
		slot.action = "unload"

	def toggle_load_unload(self, slot, entry):
		position = self.widgets.index(entry)
		res_button = slot.findChild(name="button")
		res = self.resource_for_icon[res_button.up_image.source]

		if res != 0:
			self._route_cmd("toggle_load_unload", position, res)

		if slot.action == "unload":
			self.show_load_icon(slot)
		else:
			self.show_unload_icon(slot)

	def slider_adjust(self, slot, res_id, entry):
		position = self.widgets.index(entry)
		slider = slot.findChild(name="slider")
		amount_lbl = slot.findChild(name="amount")
		amount = int(slider.value)
		amount_lbl.text = u'{amount}t'.format(amount=amount)
		if slot.action == "unload":
			amount = -amount
		self._route_cmd("add_to_resource_list", position, res_id, amount)
		slot.adaptLayout()

	def add_resource(self, res_id, slot=None, entry=None, has_value=False, value=0):
		button = slot.findChild(name="button")
		position = self.widgets.index(entry)
		# Remove old resource from waypoints.
		res = self.resource_for_icon[button.up_image.source]
		if res != 0:
			self._route_cmd("remove_from_resource_list", position, res)

		icon = self.icon_for_resource[res_id]
		button.up_image, button.down_image, button.hover_image = icon, icon, icon
		button.max_size = button.min_size = button.size = (32, 32)

		# Hide the resource menu.
		self.hide_resource_menu()

		# Show widget elements for new resource.
		slider = slot.findChild(name="slider")

		if not has_value:
			value = int(slider.value)
			if slot.action == "unload":
				value = -value

		if value < 0:
			self.show_unload_icon(slot)
			slider.value = float(-value)
			amount = -value
		elif value > 0:
			self.show_load_icon(slot)
			slider.value = float(value)
			amount = value
		else:
			# Keep the load/unload persistent if the slider value is 0.
			slider.value = 0.
			amount = value

		if res_id != 0:
			slot.findChild(name="amount").text = unicode(amount) + "t"
			slot.adaptLayout()
			self._route_cmd("add_to_resource_list", position, res_id, value)
			slider.capture(Callback(self.slider_adjust, slot, res_id, entry))
		else:
			slot.findChild(name="amount").text = u""

	def handle_resource_click(self, widget, event):
		if event.getButton() == fife.MouseEvent.LEFT:
			self.show_resource_menu(widget.parent, widget.parent.parent)
		elif event.getButton() == fife.MouseEvent.RIGHT:
			if self.resource_menu_shown:
				# abort resource selection (#1310)
				self.hide_resource_menu()
			else:
				# remove the load/unload order
				self.add_resource(slot=widget.parent, res_id=0, entry=widget.parent.parent)

	def show_resource_menu(self, slot, entry):
		position = self.widgets.index(entry)
		if self.resource_menu_shown:
			self.hide_resource_menu()
		self.resource_menu_shown = True

		on_click = functools.partial(self.add_resource, slot=slot, entry=entry)
		settlement = entry.settlement()
		inventory = settlement.get_component(StorageComponent).inventory if settlement else None
		widget = 'traderoute_resource_selection.xml'

		def res_filter(res_id):
			same_icon = slot.findChild(name='button').up_image.source == self.icon_for_resource[res_id]
			already_listed = res_id in self.instance.route.waypoints[position]['resource_list']
			return not (same_icon or already_listed)

		dlg = create_resource_selection_dialog(on_click=on_click, inventory=inventory,
			db=self.session.db, widget=widget, amount_per_line=6, res_filter=res_filter)

		self._gui.findChild(name="traderoute_resources").addChild(dlg)
		self._gui.adaptLayout()
		self._resource_selection_area_layout_hack_fix()

	def _resource_selection_area_layout_hack_fix(self):
		# no one knows why this is necessary, but sometimes we need to set the values anew
		vbox = self._gui.findChild(name="traderoute_resources")
		scrollarea = vbox.findChild(name="resources_scrollarea")
		if scrollarea:
			scrollarea.max_width = scrollarea.width = vbox.max_width = vbox.width = 320

	def hide_resource_menu(self):
		self.resource_menu_shown = False
		self._gui.findChild(name="traderoute_resources").removeAllChildren()

	def add_trade_slots(self, entry, slot_amount=SLOTS_PER_ENTRY):
		x_position = 105
		# Initialize slots with empty dict.
		self.slots[entry] = {}
		for num in range(slot_amount):
			slot = load_uh_widget('trade_single_slot.xml')
			slot.name = 'slot_%d' % num
			slot.position = (x_position, 0)

			slot.action = "load"

			slider = slot.findChild(name="slider")
			slider.scale_start = 0.0
			slider.scale_end = float(self.instance.get_component(StorageComponent).inventory.limit)

			slot.findChild(name="buysell").capture(Callback(self.toggle_load_unload, slot, entry))

			button = slot.findChild(name="button")
			button.capture(self.handle_resource_click, event_name='mouseClicked')
			button.up_image = self.dummy_icon_path
			button.down_image = self.dummy_icon_path
			button.hover_image = self.dummy_icon_path

			icon = slot.findChild(name="icon")
			fillbar = slot.findChild(name="fillbar")
			fillbar.position = (icon.width - fillbar.width - 1, icon.height)
			x_position += 60

			entry.addChild(slot)
			self.slots[entry][num] = slot
			self.show_load_icon(slot)

	def add_gui_entry(self, warehouse, resource_list=None):
		vbox = self._gui.findChild(name="left_vbox")
		entry = load_uh_widget("route_entry.xml")
		entry.name = 'container_%s' % len(self.widgets)
		entry.settlement = weakref.ref(warehouse.settlement)
		self.widgets.append(entry)

		settlement_name_label = entry.findChild(name="warehouse_name")
		settlement_name_label.text = warehouse.settlement.get_component(NamedComponent).name
		player_name_label = entry.findChild(name="player_name")
		player_name_label.text = warehouse.owner.name

		self.add_trade_slots(entry)

		index = 1
		resource_list = resource_list or {}
		for res_id in resource_list:
			if index > self.SLOTS_PER_ENTRY:
				break
			self.add_resource(slot=self.slots[entry][index - 1],
			                  res_id=res_id,
			                  entry=entry,
			                  has_value=True,
			                  value=resource_list[res_id])
			index += 1

		entry.mapEvents({
		  'delete_warehouse/mouseClicked': Callback(self.remove_entry, entry),
		  'move_up/mouseClicked': Callback(self.move_entry, entry, 'up'),
		  'move_down/mouseClicked': Callback(self.move_entry, entry, 'down')
		  })
		vbox.addChild(entry)

	def append_warehouse(self, warehouse):
		"""Add a warehouse to the list on the left side.
		@param warehouse: Set to add a specific one, else the selected one gets added.
		"""
		if not self.session.world.diplomacy.can_trade(self.session.world.player, warehouse.owner):
			self.session.ingame_gui.message_widget.add_custom(_("You are not allowed to trade with this player"))
			return

		if len(self.widgets) >= self.MAX_ENTRIES:
			# reached max entries the gui can hold
			AmbientSoundComponent.play_special('error')
			return

		self._route_cmd("append", warehouse.worldid)
		self.add_gui_entry(warehouse)
		if self.resource_menu_shown:
			self.hide_resource_menu()

		self._check_no_entries_label()

		self._gui.adaptLayout()

	def on_map_click(self, event, drag):
		if drag:
			return
		if event.getButton() == fife.MouseEvent.LEFT:
			map_coords = event.map_coords
			tile = self.session.world.get_tile(Point(*map_coords))
			if tile is not None and tile.settlement is not None:
				self.append_warehouse(tile.settlement.warehouse)

	def _init_gui(self):
		"""
		Initial init of gui.
		widgets : list of route entry widgets
		slots : dict with slots for each entry
		"""
		self._gui = load_uh_widget("configure_route.xml", center_widget=True)

		self.widgets = []
		self.slots = {}

		icon = self._gui.findChild(name="minimap")

		self.minimap = Minimap(icon, session=self.session,
		                       world=self.session.world,
		                       view=self.session.view,
		                       targetrenderer=horizons.globals.fife.targetrenderer,
		                       imagemanager=horizons.globals.fife.imagemanager,
		                       cam_border=False,
		                       use_rotation=False,
		                       on_click=self.on_map_click)

		resources = self.session.db.get_res(only_tradeable=True)
		# map an icon for a resource
		# map a resource for an icon
		self.resource_for_icon = {self.dummy_icon_path: 0}
		self.icon_for_resource = {0: self.dummy_icon_path}
		for res_id in resources:
			icon = get_res_icon_path(res_id)
			self.resource_for_icon[icon] = res_id
			self.icon_for_resource[res_id] = icon

		# don't do any actions if the resource menu is shown
		self.resource_menu_shown = False
		for entry in self.instance.route.waypoints:
			self.add_gui_entry(entry['warehouse'], entry['resource_list'])

		self._check_no_entries_label()

		wait_at_unload_box = self._gui.findChild(name="wait_at_unload")
		wait_at_unload_box.marked = self.instance.route.wait_at_unload
		def toggle_wait_at_unload():
			self._route_cmd("set_wait_at_unload", not self.instance.route.wait_at_unload)
		wait_at_unload_box.capture(toggle_wait_at_unload)

		wait_at_load_box = self._gui.findChild(name="wait_at_load")
		wait_at_load_box.marked = self.instance.route.wait_at_load
		def toggle_wait_at_load():
			self._route_cmd("set_wait_at_load", not self.instance.route.wait_at_load)
		wait_at_load_box.capture(toggle_wait_at_load)

		self._gui.mapEvents({
			OkButton.DEFAULT_NAME: self._windows.close,
			'start_route/mouseClicked': self.toggle_route,
		})

	def _route_cmd(self, method, *args, **kwargs):
		"""Convenience method for calling a method on instance.route via command (mp-safe)"""
		RouteConfigCommand(self.instance, method, *args, **kwargs).execute(self.session)

########NEW FILE########
__FILENAME__ = statswidget
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.constants import PLAYER, GAME_SPEED
from horizons.extscheduler import ExtScheduler
from horizons.gui.util import load_uh_widget
from horizons.util.python import decorators
from horizons.util.python.callback import Callback


class StatsWidget(object):
	"""A widget that creates a large table with statistics."""

	widget_file_name = None # name of the widget's XML file

	def __init__(self, session, center_widget=False):
		super(StatsWidget, self).__init__()
		self.session = session
		self.center_widget = center_widget
		self._initialized = False
		self._hiding_widget = False # True if and only if the widget is currently in the process of being hidden

	def refresh(self):
		self._clear_entries()

	def _refresh_tick(self):
		if self._initialized and self.is_visible():
			self.refresh()

	def show(self):
		run_in = PLAYER.STATS_UPDATE_FREQUENCY / GAME_SPEED.TICKS_PER_SECOND
		ExtScheduler().add_new_object(Callback(self._refresh_tick),
		                              self, run_in=run_in, loops=-1)
		if not self._initialized:
			self._initialized = True
			self._init_gui()
		self.refresh()
		self._gui.show()

	def hide(self):
		ExtScheduler().rem_all_classinst_calls(self)
		if not self._initialized:
			return # can happen if the logbook calls hide on all statswidgets
		if not self._hiding_widget:
			self._hiding_widget = True
			self._gui.hide()
			self._hiding_widget = False

	def is_visible(self):
		if not self._initialized:
			return False
		return self._gui.isVisible()

	def toggle_visibility(self):
		if self.is_visible():
			self.hide()
		else:
			self.show()
			self.refresh()

	def _init_gui(self):
		self._gui = load_uh_widget(self.widget_file_name, center_widget=self.center_widget)
		if not self.center_widget:
			self._gui.position_technique = 'center+20:center+25'
		self._content_vbox = self._gui.findChild(name='content_vbox')
		self.refresh()

	def _clear_entries(self):
		self._content_vbox.removeAllChildren()

decorators.bind_all(StatsWidget)

########NEW FILE########
__FILENAME__ = stepslider
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from fife.extensions.pychan.widgets import Slider


class StepSlider(Slider):

	def __init__(self, *args, **kwargs):
		"""The StepSlider automatically snaps the steps suggested by stepsize."""
		self.__callbacks_by_group = {} # super init calls capture, so we need this here

		super(StepSlider, self).__init__(*args, **kwargs)

		self.__last_step_value = None # for recognizing new steps, self.value is overwritten in the base class sometimes
		self.capture(None)

	def capture(self, callback, event_name="action", group_name="default"):
		if event_name == "action":
			super(StepSlider, self).capture(self.__update, event_name, group_name="stepslider")
			self.__callbacks_by_group[group_name] = callback
		else:
			super(StepSlider, self).capture(callback, event_name, group_name)

	def __update(self):
		value = round(self.value / self.step_length) * self.step_length
		if value != self.__last_step_value:
			self.__last_step_value = value
			self.value = value # has be overwritten before this has been called
			for callback in self.__callbacks_by_group.itervalues():
				callback()
########NEW FILE########
__FILENAME__ = tooltip
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import re
import textwrap

from fife import fife
from fife.extensions.pychan.widgets import HBox, Icon, Label

import horizons.globals

from horizons.extscheduler import ExtScheduler
from horizons.gui.util import get_res_icon_path
from horizons.gui.widgets.container import AutoResizeContainer
from horizons.gui.widgets.icongroup import TooltipBG

class _Tooltip(object):
	"""Base class for pychan widgets overloaded with tooltip functionality"""

	# Character count after which we start new line.
	CHARS_PER_LINE = 19
	# Find and replace horribly complicated elements that allow simple icons.
	icon_regexp = re.compile(r'\[\[Buildmenu((?: \d+\:\d+)+)\]\]')

	def init_tooltip(self):
		# the widget's parent's parent's ..... until the topmost
		self.topmost_widget = None
		self.gui = None
		self.bg = None
		self.label = None
		self.mapEvents({
			self.name + '/mouseEntered/tooltip' : self.position_tooltip,
			self.name + '/mouseExited/tooltip' : self.hide_tooltip,
			self.name + '/mouseMoved/tooltip' : self.position_tooltip,

			# TIP: the mousePressed event is especially useful when such as click
			# will trigger this tooltip's parent widget to be hidden (or destroyed), 
			# which hides this tooltip first before hides the parent widget. 
			# Otherwise the tooltip will show forever.
			self.name + '/mousePressed/tooltip' : self.hide_tooltip,

			# TODO: not sure if below are useful or not
			# self.name + '/mouseReleased/tooltip' : self.position_tooltip,
			# self.name + '/mouseDragged/tooltip' : self.hide_tooltip
			})
		self.tooltip_shown = False

	def __init_gui(self):
		self.gui = AutoResizeContainer()
		self.label = Label(position=(10, 5))
		self.bg = TooltipBG()
		self.gui.addChildren(self.bg, self.label)

	def position_tooltip(self, event):
		if not self.helptext:
			return
		"""Calculates a nice position for the tooltip.
		@param event: mouse event from fife or tuple screenpoint
		"""
		# TODO: think about nicer way of handling the polymorphism here,
		# e.g. a position_tooltip_event and a position_tooltip_tuple
		where = event # fife forces this to be called event, but here it can also be a tuple
		if isinstance(where, tuple):
			x, y = where
		else:
			if where.getButton() == fife.MouseEvent.MIDDLE:
				return

			x, y = where.getX(), where.getY()

		if self.gui is None:
			self.__init_gui()

		widget_position = self.getAbsolutePos()

		# Sometimes, we get invalid events from pychan, it is probably related to changing the
		# gui when the mouse hovers on gui elements.
		# Random tests have given evidence to believe that pychan indicates invalid events
		# by setting the top container's position to 0, 0.
		# Since this position is currently unused, it can serve as invalid flag,
		# and dropping these events seems to lead to the desired placements
		def get_top(w):
			return get_top(w.parent) if w.parent else w
		top_pos = get_top(self).position
		if top_pos == (0, 0):
			return

		screen_width = horizons.globals.fife.engine_settings.getScreenWidth()
		self.gui.y = widget_position[1] + y + 5
		offset = x + 10
		if (widget_position[0] + self.gui.size[0] + offset) > screen_width:
			# right screen edge, position to the left of cursor instead
			offset = x - self.gui.size[0] - 5
		self.gui.x = widget_position[0] + offset
		if not self.tooltip_shown:
			self.show_tooltip()
			#ExtScheduler().add_new_object(self.show_tooltip, self, run_in=0.3, loops=0)
			self.tooltip_shown = True

	def show_tooltip(self):
		if not self.helptext:
			return
		if self.gui is None:
			self.__init_gui()

		#HACK: support icons in build menu
		# Code below exists for the sole purpose of build menu tooltips showing
		# resource icons. Even supporting that is a pain (as you will see),
		# so if you think you need icons in other tooltips, maybe reconsider.
		# [These unicode() calls brought to you by status icon tooltip code.]
		buildmenu_icons = self.icon_regexp.findall(unicode(self.helptext))
		# Remove the weird stuff before displaying text.
		replaced = self.icon_regexp.sub('', unicode(self.helptext))
		# Specification looks like [[Buildmenu 1:250 4:2 6:2]]
		if buildmenu_icons:
			hbox = HBox(position=(7, 5), padding=0)
			for spec in buildmenu_icons[0].split():
				(res_id, amount) = spec.split(':')
				label = Label(text=amount+'  ')
				icon = Icon(image=get_res_icon_path(int(res_id)), size=(16, 16))
				# For compatibility with FIFE 0.3.5 and older, also set min/max.
				icon.max_size = icon.min_size = (16, 16)
				hbox.addChildren(icon, label)
			hbox.adaptLayout()
			# Now display the 16x16px "required resources" icons in the last line.
			self.gui.addChild(hbox)

		#HACK: wrap tooltip text
		# This looks better than splitting into several lines and joining them.
		# It works because replace_whitespace in `fill` defaults to True.
		replaced = replaced.replace(r'\n', self.CHARS_PER_LINE * ' ')
		replaced = replaced.replace('[br]', self.CHARS_PER_LINE * ' ')
		tooltip = textwrap.fill(replaced, self.CHARS_PER_LINE)

		# Finish up the actual tooltip (text, background panel amount, layout).
		# To display build menu icons, we need another empty (first) line.
		self.bg.amount = len(tooltip.splitlines()) - 1 + bool(buildmenu_icons)
		self.label.text = bool(buildmenu_icons) * '\n' + tooltip
		self.gui.adaptLayout()
		self.gui.show()

		# NOTE: the below code in this method is a hack to resolve #2227
		# cannot find a better way to fix it, cause in fife.pychan, it seems
		# if a widget gets hidden or removed, the children of that widget are not
		# hidden or removed properly (at least in Python code)

		# update topmost_widget every time the tooltip is shown
		# this is to dismiss the tooltip later, see _check_hover_alive
		target_widget = self
		while target_widget:
			self.topmost_widget = target_widget
			target_widget = target_widget.parent

		# add an event to constantly check whether the hovered widget is still there
		# if this is no longer there, dismiss the tooltip widget
		ExtScheduler().add_new_object(self._check_hover_alive, self, run_in=0.5, loops=-1)

	def _check_hover_alive(self):
		target_widget = self
		# traverse the widget chain again
		while target_widget:
			# none of ancestors of this widget gets removed, 
			# just do nothing and let the tooltip shown
			if target_widget == self.topmost_widget:
				return
			# one ancestor of this widget is hidden
			if not target_widget.isVisible():
				self.hide_tooltip()
				return
			target_widget = target_widget.parent

		# if it comes to here, meaning one ancestor of this widget is removed
		self.hide_tooltip()

	def hide_tooltip(self, event=None):
		if self.gui is not None:
			self.gui.hide()
		# tooltip is hidden, no need to check any more
		ExtScheduler().rem_call(self, self._check_hover_alive)
		self.topmost_widget = None
		self.tooltip_shown = False

########NEW FILE########
__FILENAME__ = tradehistoryitem
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import Container

from horizons.gui.util import load_uh_widget, get_res_icon_path
from horizons.constants import RES

class TradeHistoryItem(Container):
	"""Widget that shows the last few trades that have taken place in the settlement."""

	def __init__(self, player, resource_id, amount, gold, **kwargs):
		super(TradeHistoryItem, self).__init__(**kwargs)
		self.widget = load_uh_widget('trade_history_item.xml')
		self.addChild(self.widget)

		self.findChild(name='player_emblem').background_color = player.color
		self.findChild(name='player_name').text = player.name

		gold_amount_label = self.findChild(name='gold_amount')
		gold_amount_label.text = u'{gold:+5d}'.format(gold=gold)

		gold_icon = self.findChild(name='gold_icon')
		gold_icon.image = get_res_icon_path(RES.GOLD)
		gold_icon.max_size = gold_icon.min_size = gold_icon.size = (16, 16)
		gold_icon.helptext = player.session.db.get_res_name(RES.GOLD)

		resource_amount_label = self.findChild(name='resource_amount')
		resource_amount_label.text = u'{amount:+5d}'.format(amount=amount)

		resource_icon = self.findChild(name='resource_icon')
		resource_icon.image = get_res_icon_path(resource_id)
		resource_icon.max_size = resource_icon.min_size = resource_icon.size = (16, 16)
		resource_icon.helptext = player.session.db.get_res_name(resource_id)

		self.size = self.widget.size

########NEW FILE########
__FILENAME__ = unitoverview
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife.extensions.pychan.widgets import Container, HBox, Icon

from horizons.gui.util import load_uh_widget, get_res_icon_path
from horizons.util.python.callback import Callback
from horizons.command.unit import SetStance
from horizons.extscheduler import ExtScheduler
from horizons.component.healthcomponent import HealthComponent
from horizons.component.stancecomponent import DEFAULT_STANCES

class StanceWidget(Container):
	"""Widget used for setting up the stance for one instance"""
	def __init__(self, **kwargs):
		super(StanceWidget, self).__init__(size=(245, 50), **kwargs)
		widget = load_uh_widget('stancewidget.xml')
		self.addChild(widget)
		ExtScheduler().add_new_object(self.refresh, self, run_in=0.3, loops=-1)

	def init(self, instance):
		self.instance = instance
		self.toggle_stance()
		events = dict( (i.NAME, Callback(self.set_stance, i) ) for i in DEFAULT_STANCES )
		self.mapEvents( events )

	def beforeShow(self):
		super(StanceWidget, self).beforeShow()
		ExtScheduler().rem_all_classinst_calls(self)
		ExtScheduler().add_new_object(self.refresh, self, run_in=1, loops=-1)

	def refresh(self):
		if not self.isVisible():
			# refresh not needed
			ExtScheduler().rem_all_classinst_calls(self)
			return
		self.toggle_stance()

	def remove(self, caller=None):
		"""Removes instance ref"""
		ExtScheduler().rem_all_classinst_calls(self)
		self.mapEvents({})
		self.instance = None

	def set_stance(self, stance):
		SetStance(self.instance, stance).execute(self.instance.session)
		self.toggle_stance()

	def toggle_stance(self):
		for stance in DEFAULT_STANCES:
			self.findChild(name=stance.NAME).set_inactive()
		self.findChild(name=self.instance.stance.NAME).set_active()

class HealthWidget(Container):
	"""Widget that shows a health bar for an unit"""
	def __init__(self, **kwargs):
		super(HealthWidget, self).__init__(size=(50, 25), **kwargs)
		widget = load_uh_widget('healthwidget.xml')
		self.addChild(widget)

	def init(self, instance):
		self.instance = instance
		self.draw_health()
		health_component = self.instance.get_component(HealthComponent)
		if not health_component.has_damage_dealt_listener(self.draw_health):
			health_component.add_damage_dealt_listener(self.draw_health)

	def draw_health(self, caller=None):
		health_component = self.instance.get_component(HealthComponent)
		max_health = int(health_component.max_health)
		health = int(health_component.health)
		self.findChild(name='health_label').text = "{health}/{max_health}".format(health=health, max_health=max_health)
		self.findChild(name='health_bar').progress = int(health * 100. / max_health)

	def remove(self, caller=None):
		health_component = self.instance.get_component(HealthComponent)
		if health_component.has_damage_dealt_listener(self.draw_health):
			health_component.remove_damage_dealt_listener(self.draw_health)
		self.instance = None

class WeaponStorageWidget(HBox):
	"""Widget that shows a small overview for one instance weapons"""
	def init(self, instance):
		self.instance = instance
		self.update()

	def remove(self, caller=None):
		self.instance = None

	def update(self):
		self.removeAllChildren()
		weapons_added = False
		if hasattr(self.instance, 'get_weapon_storage'):
			storage = self.instance.get_weapon_storage()
			for weapon, amount in storage:
				weapons_added = True
				icon_image = get_res_icon_path(weapon, 24)
				weapon_name = self.instance.session.db.get_res_name(weapon)
				# You usually do not need to change anything here when translating
				helptext = _('{weapon}: {amount}').format(weapon=weapon_name, amount=amount)
				icon = Icon(image=icon_image, helptext=helptext)
				self.addChild(icon)
		if not weapons_added:
			icon_image = "content/gui/icons/resources/none.png"
			icon = Icon(image=icon_image, helptext=_("none"))
			self.addChild(icon)


########NEW FILE########
__FILENAME__ = windows
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import traceback

from fife import fife
from fife.extensions.pychan.widgets import Icon

import horizons.globals
from horizons.gui.util import load_uh_widget
from horizons.gui.widgets.imagebutton import OkButton, CancelButton
from horizons.util.python.callback import Callback


class Window(object):

	def __init__(self, windows=None):
		# Reference to the window manager. Use it to open new windows or close
		# this window.
		self._windows = windows

		self._modal_background = None

	def open(self, **kwargs):
		"""Open the window.

		After this call, the window should be visible. If you decide to not show
		the window here (e.g. an error occurred), you'll need to call
		`self._windows.close()` to remove the window from the manager.

		You may override this method in a subclass if you need to do stuff when
		a window is first shown.
		"""
		return self.show(**kwargs)

	def show(self, **kwargs):
		"""Show the window.

		After this call, the window should be visible. You should *never* call
		this directly in your code.
		"""
		raise NotImplementedError

	def hide(self):
		"""Hide the window.

		After this call, the window should not be visible anymore. However, it remains
		in the stack of open windows and will be visible once it becomes the topmost
		window again.

		You should *never* call this directly in your code, other than in `close()`
		when you overwrote it in your subclass.
		"""
		raise NotImplementedError

	def close(self):
		"""Closes the window.

		You should *never* call this directly in your code. Use `self._windows.close()`
		to ask the WindowManager to remove the window instead.

		You may override this method in a subclass if you need to do stuff when
		a window is closed.
		"""
		self.hide()

	def on_escape(self):
		"""Define what happens when ESC is pressed.

		By default, the window will be closed.
		"""
		self._windows.close()

	def on_return(self):
		"""Define what happens when RETURN is pressed."""
		pass

	def _show_modal_background(self):
		"""
		Loads transparent background that de facto prohibits access to other
		gui elements by eating all input events.
		"""
		height = horizons.globals.fife.engine_settings.getScreenHeight()
		width = horizons.globals.fife.engine_settings.getScreenWidth()
		image = horizons.globals.fife.imagemanager.loadBlank(width, height)
		image = fife.GuiImage(image)
		self._modal_background = Icon(image=image)
		self._modal_background.position = (0, 0)
		self._modal_background.show()

	def _hide_modal_background(self):
		self._modal_background.hide()


class Dialog(Window):
	"""
	A dialog is very similar to a window, the major difference between the two
	is that when showing a `Window`, control flow will continue immediately.
	However the call to show a `Dialog` will only return when the dialog is
	closed.
	"""
	# Whether to block user interaction while displaying the dialog
	modal = False

	# Name of widget that should get the focus once the dialog is shown
	focus = None

	# Maps Button names to return values that you can handle in `act`
	return_events = {}

	def __init__(self, windows):
		super(Dialog, self).__init__(windows)

		self._gui = None
		self._hidden = False

	def prepare(self, **kwargs):
		"""Setup the dialog gui.

		The widget has to be stored in `self._gui`. If you want to abort the dialog
		here return False.
		"""
		raise NotImplementedError

	def act(self, retval):
		"""Do something after dialog is closed.

		If you want to show the dialog again, you need to do that explicitly, e.g. with:

			self._windows.open(self)
		"""
		return retval

	def show(self, **kwargs):
		# if the dialog is already running but has been hidden, just show the widget
		if self._hidden:
			self._hidden = False
			if self.modal:
				self._show_modal_background()
			self._gui.show()
			self._gui.requestFocus()
			return

		# if `prepare` returned False, we stop the dialog
		if self.prepare(**kwargs) is False:
			self._windows.close()
			return

		self._gui.capture(self._on_keypress, event_name="keyPressed")

		if self.modal:
			self._show_modal_background()

		retval = self._execute()

		self._windows.close()
		return self.act(retval)

	def hide(self):
		if self.modal:
			self._hide_modal_background()
		self._gui.hide()
		self._hidden = True

	def close(self):
		self.hide()
		# this dialog is gone (not just hidden), next time `show` is called,
		# we want to execute the dialog again
		self._hidden = False

	def on_escape(self):
		# escape is handled in `_on_keypress`
		pass

	def _on_keypress(self, event):
		"""Intercept ESC and ENTER keys and execute the appropriate actions."""

		# Convention says use cancel action
		if event.getKey().getValue() == fife.Key.ESCAPE:
			self.trigger_close(CancelButton.DEFAULT_NAME)
		# Convention says use ok action
		elif event.getKey().getValue() == fife.Key.ENTER:
			self.trigger_close(OkButton.DEFAULT_NAME)

	def trigger_close(self, event_name):
		"""Close the dialog and execute the received event"""
		event_to_call = self.return_events.get(event_name)
		if event_to_call is not None:
			self._abort(event_to_call)

	def _abort(self, retval=False):
		"""Break out of mainloop.

		Program flow continues after the `self._execute` call in `show`.
		"""
		horizons.globals.fife.breakLoop(retval)

	def _execute(self):
		"""Execute the dialog synchronously.

		This is done by entering a new mainloop in the engine until the dialog
		is closed (see `abort`).
		"""
		for name, retval in self.return_events.items():
			cb = Callback(self._abort, retval)
			self._gui.findChild(name=name).capture(cb)

		self._gui.show()

		if self.focus:
			self._gui.findChild(name=self.focus).requestFocus()
		else:
			self._gui.is_focusable = True
			self._gui.requestFocus()

		return horizons.globals.fife.loop()

	@classmethod
	def create_from_widget(cls, dlg, bind, event_map=None, modal=False, focus=None):
		"""Shows any pychan dialog.

		@param dlg: dialog that is to be shown
		@param bind: events that make the dialog return + return values {'ok': True, 'cancel': False}
		@param event_map: dictionary with callbacks for buttons. See pychan docu: pychan.widget.mapEvents()
		@param modal: Whether to block user interaction while displaying the dialog
		@param focus: Which child widget should take focus
		"""
		def prepare(self, **kwargs):
			self._gui = dlg
			if event_map:
				self._gui.mapEvents(event_map)

		TempDialog = type('TempDialog', (Dialog, ), {
			'modal': modal,
			'return_events': bind,
			'focus': focus,
			'prepare': prepare,
		})

		return TempDialog


class Popup(Dialog):
	"""Displays a popup with the specified text"""
	modal = True

	def __init__(self, windows, windowtitle, message, show_cancel_button=False, size=0):
		self.windowtitle = windowtitle
		self.message = message
		self.show_cancel_button = show_cancel_button
		self.size = size
		super(Popup, self).__init__(windows)

	def prepare(self):
		if self.size == 0:
			wdg_name = "popup_230"
		elif self.size == 1:
			wdg_name = "popup_290"
		elif self.size == 2:
			wdg_name = "popup_350"
		else:
			assert False, "size should be 0 <= size <= 2, but is " + str(self.size)

		self._gui = load_uh_widget(wdg_name + '.xml')

		headline = self._gui.findChild(name='headline')
		headline.text = _(self.windowtitle)
		message_lbl = self._gui.findChild(name='popup_message')
		message_lbl.text = _(self.message)
		self._gui.adaptLayout() # recalculate widths

		self.return_events = {OkButton.DEFAULT_NAME: True}
		if self.show_cancel_button:
			self.return_events[CancelButton.DEFAULT_NAME] = False
		else:
			cancel_button = self._gui.findChild(name=CancelButton.DEFAULT_NAME)
			cancel_button.parent.removeChild(cancel_button)


class WindowManager(object):

	def __init__(self):
		self._windows = []

	def open(self, window, **kwargs):
		"""Open a new window on top.

		Hide the current one and show the new one.
		Keyword arguments will be passed through to the window's `open` method.
		"""
		if self._windows:
			self._windows[-1].hide()

		self._windows.append(window)
		return window.open(**kwargs)

	def close(self):
		"""Close the top window.

		If there is another window left, show it.
		"""
		window = self._windows.pop()
		window.close()
		if self._windows:
			self._windows[-1].show()

	def toggle(self, window, **kwargs):
		"""Hide window if is currently visible (and on top), show it otherwise."""
		if self._windows and self._windows[-1] == window:
			self.close()
		else:
			if window in self._windows:
				self._windows.remove(window)
				if self._windows:
					self._windows[-1].hide()
				self._windows.append(window)
				window.show(**kwargs)
			else:
				self.open(window, **kwargs)

	def on_escape(self):
		"""Let the topmost window handle an escape key event."""
		if not self._windows:
			return

		self._windows[-1].on_escape()

	def on_return(self):
		"""Let the topmost window handle a return key event."""
		if not self._windows:
			return

		self._windows[-1].on_return()

	@property
	def visible(self):
		"""Whether any windows are visible right now."""
		return bool(self._windows)

	def close_all(self):
		while self._windows:
			w = self._windows.pop()
			w.close()

	def hide_all(self):
		"""Hide all windows.

		Use `show_all` to restore the old state.
		"""
		if not self._windows:
			return

		# because we only show one window at a time, it is enough to hide the
		# top-most window
		self._windows[-1].hide()

	def show_all(self):
		"""Undo what `hide_all` did."""
		if not self._windows:
			return

		# because we only show one window at a time, it is enough to show the
		# most recently added window
		self._windows[-1].show()

	def open_popup(self, windowtitle, message, show_cancel_button=False, size=0):
		"""
		@param windowtitle: the title of the popup
		@param message: the text displayed in the popup
		@param show_cancel_button: boolean, show cancel button or not
		@param size: 0, 1 or 2. Larger means bigger.
		"""
		window = Popup(self, windowtitle, message, show_cancel_button, size)
		return self.open(window)

	def open_error_popup(self, windowtitle, description, advice=None, details=None, _first=True):
		"""Displays a popup containing an error message.
		@param windowtitle: title of popup, will be auto-prefixed with "Error: "
		@param description: string to tell the user what happened
		@param advice: how the user might be able to fix the problem
		@param details: technical details, relevant for debugging but not for the user
		@param _first: Don't touch this.

		Guide for writing good error messages:
		http://www.useit.com/alertbox/20010624.html
		"""
		msg = u""
		msg += description + u"\n"
		if advice:
			msg += advice + u"\n"
		if details:
			msg += _("Details: {error_details}").format(error_details=details)
		try:
			self.open_popup( _("Error: {error_message}").format(error_message=windowtitle),
			                 msg)
		except SystemExit: # user really wants us to die
			raise
		except:
			# could be another game error, try to be persistent in showing the error message
			# else the game would be gone without the user being able to read the message.
			if _first:
				traceback.print_exc()
				log = logging.getLogger('gui.windows')
				log.error('Exception while showing error, retrying once more.')
				return self.open_error_popup(windowtitle, description, advice, details, _first=False)
			else:
				raise # it persists, we have to die.

########NEW FILE########
__FILENAME__ = objecttranslations
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

###############################################################################
#
# == I18N DEV USE CASES: CHEATSHEET ==
#
# ** Refer to  development/create_pot.sh  for help with building or updating
#    the translation files for Unknown Horizons.
#
###############################################################################
#
# WARNING: This file is generated automagically.
#          You need to update it to see changes to strings in-game.
#          DO NOT MANUALLY UPDATE THIS FILE (by editing strings).
#          The script to generate .pot templates calls the following:
# ./development/extract_strings_from_objects.py  horizons/i18n/objecttranslations.py
#
# NOTE: In string-freeze mode (shortly before releases, usually
#       announced in a meeting), updates to this file must not happen
#       without permission of the responsible translation admin!
#
###############################################################################










object_translations = {

	"content/objects/buildings/bakery.yaml" : {
		# name of buildings:bakery
		"name"                        : _("Bakery"),
		# tooltip_text of buildings:bakery
		"tooltip_text"                : _("Consumes flour. Produces food."),
		},

	"content/objects/buildings/barracks.yaml" : {
		# name of buildings:barracks
		"name"                        : _("Barracks"),
		# tooltip_text of buildings:barracks
		"tooltip_text"                : _("Recruits units suitable for ground combat."),
		},

	"content/objects/buildings/blender.yaml" : {
		# name of buildings:blender
		"name"                        : _("Blender"),
		# tooltip_text of buildings:blender
		"tooltip_text"                : _("Produces condiments out of spices."),
		},

	"content/objects/buildings/boatbuilder.yaml" : {
		# name of buildings:boatbuilder
		"name"                        : _("Boat Builder"),
		# tooltip_text of buildings:boatbuilder
		"tooltip_text"                : _("Builds boats and small ships. Built on coast."),
		},

	"content/objects/buildings/brickyard.yaml" : {
		# name of buildings:brickyard
		"name"                        : _("Brickyard"),
		# tooltip_text of buildings:brickyard
		"tooltip_text"                : _("Turns clay into bricks."),
		},

	"content/objects/buildings/butchery.yaml" : {
		# name of buildings:butchery
		"name"                        : _("Butchery"),
		# tooltip_text of buildings:butchery
		"tooltip_text"                : _("Needs pigs or cattle. Produces food."),
		},

	"content/objects/buildings/charcoalburning.yaml" : {
		# name of buildings:charcoalburning
		"name"                        : _("Charcoal Burning"),
		# tooltip_text of buildings:charcoalburning
		"tooltip_text"                : _("Burns a lot of boards."),
		},

	"content/objects/buildings/claydeposit.yaml" : {
		# name of buildings:claydeposit
		"name"                        : _("Clay Deposit"),
		},

	"content/objects/buildings/claypit.yaml" : {
		# name of buildings:claypit
		"name"                        : _("Clay Pit"),
		# tooltip_text of buildings:claypit
		"tooltip_text"                : _("Gets clay from deposit."),
		},

	"content/objects/buildings/distillery.yaml" : {
		# name of buildings:distillery
		"name"                        : _("Distillery"),
		# tooltip_text of buildings:distillery
		"tooltip_text"                : _("Turns sugar into liquor."),
		},

	"content/objects/buildings/doctor.yaml" : {
		# name of buildings:doctor
		"name"                        : _("Doctor"),
		# tooltip_text of buildings:doctor
		"tooltip_text"                : _("Treats diseases. Consumes herbs."),
		},

	"content/objects/buildings/farm.yaml" : {
		# name of buildings:farm
		"name"                        : _("Farm"),
		# tooltip_text of buildings:farm
		"tooltip_text"                : _("Grows field crops and raises livestock."),
		},

	"content/objects/buildings/fields/alvearies.yaml" : {
		# name of buildings:fields:alvearies
		"name"                        : _("Alvearies"),
		# tooltip_text of buildings:fields:alvearies
		"tooltip_text"                : _("Keeps bees. Produces honeycombs used for confectionery. Needs a farm."),
		},

	"content/objects/buildings/fields/cattlerun.yaml" : {
		# name of buildings:fields:cattlerun
		"name"                        : _("Cattle Run"),
		# tooltip_text of buildings:fields:cattlerun
		"tooltip_text"                : _("Raises cattle. Needs a farm."),
		},

	"content/objects/buildings/fields/cocoafield.yaml" : {
		# name of buildings:fields:cocoafield
		"name"                        : _("Cocoa Field"),
		# tooltip_text of buildings:fields:cocoafield
		"tooltip_text"                : _("Produces cocoa beans used for confectionery. Needs a farm."),
		},

	"content/objects/buildings/fields/cornfield.yaml" : {
		# name of buildings:fields:cornfield
		"name"                        : _("Corn Field"),
		# tooltip_text of buildings:fields:cornfield
		"tooltip_text"                : _("Yields corn. Needs a farm."),
		},

	"content/objects/buildings/fields/herbary.yaml" : {
		# name of buildings:fields:herbary
		"name"                        : _("Herbary"),
		# tooltip_text of buildings:fields:herbary
		"tooltip_text"                : _("Produces herbs. Needs a farm."),
		},

	"content/objects/buildings/fields/pasture.yaml" : {
		# name of buildings:fields:pasture
		"name"                        : _("Pasture"),
		# tooltip_text of buildings:fields:pasture
		"tooltip_text"                : _("Raises sheep. Produces wool. Needs a farm."),
		},

	"content/objects/buildings/fields/pigsty.yaml" : {
		# name of buildings:fields:pigsty
		"name"                        : _("Pigsty"),
		# tooltip_text of buildings:fields:pigsty
		"tooltip_text"                : _("Raises pigs. Needs a farm."),
		},

	"content/objects/buildings/fields/potatofield.yaml" : {
		# name of buildings:fields:potatofield
		"name"                        : _("Potato Field"),
		# tooltip_text of buildings:fields:potatofield
		"tooltip_text"                : _("Yields food. Needs a farm."),
		},

	"content/objects/buildings/fields/spicefield.yaml" : {
		# name of buildings:fields:spicefield
		"name"                        : _("Spice Field"),
		# tooltip_text of buildings:fields:spicefield
		"tooltip_text"                : _("Grows spices. Needs a farm."),
		},

	"content/objects/buildings/fields/sugarfield.yaml" : {
		# name of buildings:fields:sugarfield
		"name"                        : _("Sugar Field"),
		# tooltip_text of buildings:fields:sugarfield
		"tooltip_text"                : _("Used in liquor production. Needs a farm."),
		},

	"content/objects/buildings/fields/tobaccofield.yaml" : {
		# name of buildings:fields:tobaccofield
		"name"                        : _("Tobacco Field"),
		# tooltip_text of buildings:fields:tobaccofield
		"tooltip_text"                : _("Produces tobacco. Needs a farm."),
		},

	"content/objects/buildings/fields/vineyard.yaml" : {
		# name of buildings:fields:vineyard
		"name"                        : _("Vineyard"),
		# tooltip_text of buildings:fields:vineyard
		"tooltip_text"                : _("Produces grapes for use in wine and confectionery. Needs a farm."),
		},

	"content/objects/buildings/fireservice.yaml" : {
		# name of buildings:fireservice
		"name"                        : _("Fire Station"),
		# tooltip_text of buildings:fireservice
		"tooltip_text"                : _("Extinguishes fires."),
		},

	"content/objects/buildings/fishdeposit.yaml" : {
		# name of buildings:fishdeposit
		"name"                        : _("Fish Deposit"),
		},

	"content/objects/buildings/fishermanstent.yaml" : {
		# name of buildings:fishermanstent
		"name"                        : _("Fisherman's Tent"),
		# tooltip_text of buildings:fishermanstent
		"tooltip_text"                : _("Fishes the sea, produces food."),
		},

	"content/objects/buildings/hunterstent.yaml" : {
		# name of buildings:hunterstent
		"name"                        : _("Hunter's Tent"),
		# tooltip_text of buildings:hunterstent
		"tooltip_text"                : _("Hunts wild forest animals, produces food."),
		},

	"content/objects/buildings/lookout.yaml" : {
		# name of buildings:lookout
		"name"                        : _("Lookout"),
		# tooltip_text of buildings:lookout
		"tooltip_text"                : _("Increases the player's sight."),
		},

	"content/objects/buildings/lumberjackcamp.yaml" : {
		# name_0 of buildings:lumberjackcamp
		"name_0"                      : _("Lumberjack Tent"),
		# name_1 of buildings:lumberjackcamp
		"name_1"                      : _("Lumberjack Hut"),
		# tooltip_text of buildings:lumberjackcamp
		"tooltip_text"                : _("Chops down trees and turns them into boards."),
		},

	"content/objects/buildings/mainsquare.yaml" : {
		# name of buildings:mainsquare
		"name"                        : _("Main Square"),
		# tooltip_text of buildings:mainsquare
		"tooltip_text"                : _("Supplies citizens with goods. Provides community."),
		},

	"content/objects/buildings/mine.yaml" : {
		# name of buildings:mine
		"name"                        : _("Mine"),
		# tooltip_text of buildings:mine
		"tooltip_text"                : _("Gets iron ore from deposit."),
		},

	"content/objects/buildings/mountain.yaml" : {
		# name of buildings:mountain
		"name"                        : _("Mountain"),
		},

	"content/objects/buildings/pastryshop.yaml" : {
		# name of buildings:pastryshop
		"name"                        : _("Pastry Shop"),
		# tooltip_text of buildings:pastryshop
		"tooltip_text"                : _("Produces all kinds of confectionery."),
		},

	"content/objects/buildings/pavilion.yaml" : {
		# name of buildings:pavilion
		"name"                        : _("Pavilion"),
		# tooltip_text of buildings:pavilion
		"tooltip_text"                : _("Fulfills religious needs of sailors."),
		},

	"content/objects/buildings/ruinedtent.yaml" : {
		# name of buildings:ruinedtent
		"name"                        : _("Ruined Tent"),
		},

	"content/objects/buildings/saltponds.yaml" : {
		# name of buildings:saltponds
		"name"                        : _("Salt Ponds"),
		# tooltip_text of buildings:saltponds
		"tooltip_text"                : _("Evaporates salt. Built on sea coast."),
		},

	"content/objects/buildings/signalfire.yaml" : {
		# name of buildings:signalfire
		"name"                        : _("Signal Fire"),
		# tooltip_text of buildings:signalfire
		"tooltip_text"                : _("Allows the player to trade with the free trader."),
		},

	"content/objects/buildings/smeltery.yaml" : {
		# name of buildings:smeltery
		"name"                        : _("Smeltery"),
		# tooltip_text of buildings:smeltery
		"tooltip_text"                : _("Refines all kind of ores."),
		},

	"content/objects/buildings/stonemason.yaml" : {
		# name_2 of buildings:stonemason
		"name_2"                      : _("Stonemason"),
		# name_4 of buildings:stonemason
		"name_4"                      : _("Carver"),
		# tooltip_text of buildings:stonemason
		"tooltip_text"                : _("Carves stone tops into bricks."),
		},

	"content/objects/buildings/stonepit.yaml" : {
		# name of buildings:stonepit
		"name"                        : _("Stone Pit"),
		# tooltip_text of buildings:stonepit
		"tooltip_text"                : _("Gets stone from a mountain."),
		},

	"content/objects/buildings/storagetent.yaml" : {
		# name_0 of buildings:storagetent
		"name_0"                      : _("Storage Tent"),
		# name_1 of buildings:storagetent
		"name_1"                      : _("Storage Hut"),
		# tooltip_text of buildings:storagetent
		"tooltip_text"                : _("Extends stock and provides collectors."),
		},

	"content/objects/buildings/tavern.yaml" : {
		# name of buildings:tavern
		"name"                        : _("Tavern"),
		# tooltip_text of buildings:tavern
		"tooltip_text"                : _("Provides get-together."),
		},

	"content/objects/buildings/tent.yaml" : {
		# name_0 of buildings:tent
		"name_0"                      : _("Tent"),
		# name_1 of buildings:tent
		"name_1"                      : _("Hut"),
		# name_2 of buildings:tent
		"name_2"                      : _("House"),
		# name_3 of buildings:tent
		"name_3"                      : _("Stone house"),
		# name_4 of buildings:tent
		"name_4"                      : _("Estate"),
		# name_5 of buildings:tent
		"name_5"                      : _("Manor"),
		# tooltip_text of buildings:tent
		"tooltip_text"                : _("Houses your inhabitants."),
		},

	"content/objects/buildings/tobacconist.yaml" : {
		# name of buildings:tobacconist
		"name"                        : _("Tobacconist"),
		# tooltip_text of buildings:tobacconist
		"tooltip_text"                : _("Produces tobaccos out of tobacco."),
		},

	"content/objects/buildings/toolmaker.yaml" : {
		# name of buildings:toolmaker
		"name"                        : _("Toolmaker"),
		# tooltip_text of buildings:toolmaker
		"tooltip_text"                : _("Produces tools out of iron."),
		},

	"content/objects/buildings/trail.yaml" : {
		# name_0 of buildings:trail
		"name_0"                      : _("Trail"),
		# name_1 of buildings:trail
		"name_1"                      : _("Gravel Path"),
		# name_3 of buildings:trail
		"name_3"                      : _("Cobblestone Street"),
		# tooltip_text of buildings:trail
		"tooltip_text"                : _("Needed for collecting goods."),
		},

	"content/objects/buildings/tree.yaml" : {
		# name of buildings:tree
		"name"                        : _("Tree"),
		# tooltip_text of buildings:tree
		"tooltip_text"                : _("Provides lumber. Chopped down by lumberjacks."),
		},

	"content/objects/buildings/villageschool.yaml" : {
		# name of buildings:villageschool
		"name"                        : _("Village school"),
		# tooltip_text of buildings:villageschool
		"tooltip_text"                : _("Provides education."),
		},

	"content/objects/buildings/vintner.yaml" : {
		# name of buildings:vintner
		"name"                        : _("Vintner"),
		# tooltip_text of buildings:vintner
		"tooltip_text"                : _("Produces wine out of grapes."),
		},

	"content/objects/buildings/warehouse.yaml" : {
		# name of buildings:warehouse
		"name"                        : _("Warehouse"),
		},

	"content/objects/buildings/weaverstent.yaml" : {
		# name of buildings:weaverstent
		"name"                        : _("Weaver's Hut"),
		# tooltip_text of buildings:weaverstent
		"tooltip_text"                : _("Turns lamb wool into cloth."),
		},

	"content/objects/buildings/windmill.yaml" : {
		# name of buildings:windmill
		"name"                        : _("Windmill"),
		# tooltip_text of buildings:windmill
		"tooltip_text"                : _("Grinds corn into flour."),
		},

	"content/objects/buildings/woodentower.yaml" : {
		# name of buildings:woodentower
		"name"                        : _("Wooden Tower"),
		# tooltip_text of buildings:woodentower
		"tooltip_text"                : _("Defends your settlement."),
		},

	"content/objects/gui_buildmenu/build_menu_per_tier.yaml" : {
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Companies"),
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Companies"),
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Companies"),
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Companies"),
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Fields"),
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Fields"),
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Fields"),
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Mining"),
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Residents and infrastructure"),
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Services"),
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Services"),
		# headline of gui_buildmenu:build_menu_per_tier
		"headline"                    : _("Services"),
		},

	"content/objects/gui_buildmenu/build_menu_per_type.yaml" : {
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Citizens"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Food"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Fortifications"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Infrastructure"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Military Service"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Mining"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Pioneers"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Precaution"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Residential"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Sea"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Services"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Settlers"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Wood"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Workshops"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Workshops"),
		# headline of gui_buildmenu:build_menu_per_type
		"headline"                    : _("Workshops"),
		# tab1_headline of gui_buildmenu:build_menu_per_type
		"tab1_headline"               : _("Settlement"),
		# tab1_helptext of gui_buildmenu:build_menu_per_type
		"tab1_helptext"               : _("Residents and infrastructure"),
		# tab2_headline of gui_buildmenu:build_menu_per_type
		"tab2_headline"               : _("Fields"),
		# tab3_headline of gui_buildmenu:build_menu_per_type
		"tab3_headline"               : _("Agriculture"),
		# tab4_headline of gui_buildmenu:build_menu_per_type
		"tab4_headline"               : _("Companies"),
		# tab5_headline of gui_buildmenu:build_menu_per_type
		"tab5_headline"               : _("Military"),
		},
}

########NEW FILE########
__FILENAME__ = voice
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


import horizons.globals
import os.path
import glob
from horizons.constants import PATHS
from random import randrange

"""
Internationalization for speech|voice files
"""
class Speech:
	"""Definition of category names, those names are the name of directory where speech should be"""
	CHAT = None
	NEW_SETTLEMENT = "new_settlement"
	NEW_WORLD = "new_world"
	SAVED_GAME = None
	QUICKSAVE = None
	AUTOSAVE = None
	SCREENSHOT = None
	SETTLER_LEVEL_UP = None
	NEED_MORE_RES = None
	NO_MAIN_SQUARE_IN_RANGE = None
	SETTLERS_MOVED_OUT = None
	MINE_EMPTY = None
	DRAG_ROADS_HINT = None
	DIPLOMACY_STATUS_ALLY_NEUTRAL = None
	DIPLOMACY_STATUS_ALLY_ENEMY = None
	DIPLOMACY_STATUS_ENEMY_ALLY = None
	DIPLOMACY_STATUS_ENEMY_NEUTRAL = None
	DIPLOMACY_STATUS_NEUTRAL_ALLY = None
	DIPLOMACY_STATUS_NEUTRAL_ENEMY = None
	MAX_TIER_REACHED = None
	YOU_HAVE_WON = None
	FIELD_NEEDS_FARM = None
	WAREHOUSE_NOT_TEARABLE = None
	ROUTE_DISABLED = None
	MOVE_OUTSIDE_OF_WORLD = None
	MOVE_INVALID_LOCATION = None
	NEW_UNIT = None
	YOU_LOST = None
	BUILDING_ON_FIRE = None
	BUILDING_INFECTED_BY_BLACK_DEATH = None

DEFAULT_LANG="en"
DEFAULT_VARIATION=0
DEFAULT_SPEAKER=0

def get_speech_file(category, variation_id=None, speaker_id=DEFAULT_SPEAKER):
	#TODO expand this docstring
	"""Get speech file path.
	@param category: category id, the same as sentence
	@param variation_id: variation id of sentence
	@param speaker_id: speaker id
	@return: path to speech file or None if not exist"""
	category_name = eval_category_name(category)
	if category_name is None:
		return None
	lang = horizons.globals.fife.get_locale()
	path = prepare_path(lang, category_name, variation_id, speaker_id)
	if path is None:
		path = prepare_path(DEFAULT_LANG, category_name, DEFAULT_VARIATION, DEFAULT_SPEAKER)
	return path

def prepare_path(lang, category_name, var_id, spkr_id):
	dir_path = get_dir_path(lang, category_name, spkr_id)
	if not os.path.isdir(dir_path):
		return None
	file_path = get_file_path(dir_path, var_id)
	if file_path is not None and os.path.isfile(file_path):
		return file_path

def get_file_path(dir_name, var_id):
	"""If var_id is None we get random variation from directory
	"""
	if var_id is not None:
		for infile in glob.glob( os.path.join(dir_name, str(var_id) + '.*') ):
			return infile
	variation_count = count_variations(dir_name)
	if variation_count > 0:
		rand = randrange(0, variation_count)
		filelist = glob.glob( os.path.join(dir_name, '*.*') )
		return filelist[rand]
	else:
		return None

def get_dir_path(lang, category_name, spkr_id):
	return os.path.join(PATHS.VOICE_DIR, lang, str(spkr_id), str(category_name))

def count_variations(dir_name):
	return len([file for file in os.listdir(dir_name) if os.path.isfile(os.path.join(dir_name, file))])

def eval_category_name(category):
	cat_name = None
	try:
		cat_name = getattr(Speech, category)
	except:
		print "Incorrect name of speech category: %s" % category
		print "You might want to add this here in voice.py."
	return cat_name

########NEW FILE########
__FILENAME__ = main
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

"""This is the main game file. It has grown over the years from a collection of global
variables (sic!) to something holding mainly the main gui and game session, as well as
a reference to the engine object (fife).
The functions below are used to start different kinds of games.

TUTORIAL:
Continue to horizons.session for further ingame digging.
"""

import os
import sys
import os.path
import json
import traceback
import threading
from thread import error as ThreadError  # raised by threading.Lock.release
import subprocess
import logging

from fife import fife as fife_module

import horizons.globals

from horizons.savegamemanager import SavegameManager
from horizons.gui import Gui
from horizons.extscheduler import ExtScheduler
from horizons.constants import AI, GAME, PATHS, NETWORK, SINGLEPLAYER, GAME_SPEED, GFX, VERSION
from horizons.messaging import LoadingProgress
from horizons.network.networkinterface import NetworkInterface
from horizons.util.loaders.actionsetloader import ActionSetLoader
from horizons.util.loaders.tilesetloader import TileSetLoader
from horizons.util.startgameoptions import StartGameOptions
from horizons.util.python import parse_port
from horizons.util.python.callback import Callback
from horizons.util.uhdbaccessor import UhDbAccessor
from horizons.util.savegameaccessor import SavegameAccessor
from horizons.util.atlasloadingthread import AtlasLoadingThread


# private module pointers of this module
class Modules(object):
	gui = None
	session = None
_modules = Modules()

# used to save a reference to the string previewer to ensure it is not removed by
# garbage collection
__string_previewer = None

command_line_arguments = None

def start(_command_line_arguments):
	"""Starts the horizons. Will drop you to the main menu.
	@param _command_line_arguments: options object from optparse.OptionParser. see run_uh.py.
	"""
	global debug, preloading, command_line_arguments
	command_line_arguments = _command_line_arguments
	# NOTE: globals are designwise the same thing as singletons. they don't look pretty.
	#       here, we only have globals that are either trivial, or only one instance may ever exist.

	from engine import Fife

	# handle commandline globals
	debug = command_line_arguments.debug

	if command_line_arguments.restore_settings:
		# just delete the file, Settings ctor will create a new one
		os.remove( PATHS.USER_CONFIG_FILE )

	if command_line_arguments.mp_master:
		try:
			mpieces = command_line_arguments.mp_master.partition(':')
			NETWORK.SERVER_ADDRESS = mpieces[0]
			# only change port if port is specified
			if mpieces[2]:
				NETWORK.SERVER_PORT = parse_port(mpieces[2])
		except ValueError:
			print "Error: Invalid syntax in --mp-master commandline option. Port must be a number between 1 and 65535."
			return False

	# init fife before mp_bind is parsed, since it's needed there
	horizons.globals.fife = Fife()

	if command_line_arguments.generate_minimap: # we've been called as subprocess to generate a map preview
		from horizons.gui.modules.singleplayermenu import generate_random_minimap
		generate_random_minimap( * json.loads(
		  command_line_arguments.generate_minimap
		  ) )
		sys.exit(0)

	if debug: # also True if a specific module is logged (but not 'fife')
		setup_debug_mode(command_line_arguments)

	if horizons.globals.fife.get_uh_setting("DebugLog"):
		set_debug_log(True, startup=True)

	if command_line_arguments.mp_bind:
		try:
			mpieces = command_line_arguments.mp_bind.partition(':')
			NETWORK.CLIENT_ADDRESS = mpieces[0]
			horizons.globals.fife.set_uh_setting("NetworkPort", parse_port(mpieces[2]))
		except ValueError:
			print "Error: Invalid syntax in --mp-bind commandline option. Port must be a number between 1 and 65535."
			return False

	setup_AI_settings(command_line_arguments)

	# set MAX_TICKS
	if command_line_arguments.max_ticks:
		GAME.MAX_TICKS = command_line_arguments.max_ticks

	preload_lock = threading.Lock()
	atlas_loading_thread = None
	atlas_loading_thread = AtlasLoadingThread(preload_lock, command_line_arguments)
	atlas_loading_thread.start()
	atlas_loading_thread.join()

	# init game parts

	if not setup_gui_logger(command_line_arguments):
		return False

	# GUI tests always run with sound disabled and SDL (so they can run under xvfb).
	# Needs to be done before engine is initialized.
	if command_line_arguments.gui_test:
		horizons.globals.fife.engine.getSettings().setRenderBackend('SDL')
		horizons.globals.fife.set_fife_setting('PlaySounds', False)

	ExtScheduler.create_instance(horizons.globals.fife.pump)
	horizons.globals.fife.init()

	if not VERSION.IS_DEV_VERSION and horizons.globals.fife.get_uh_setting('AtlasesEnabled'):
		GFX.USE_ATLASES = True
		PATHS.DB_FILES = PATHS.DB_FILES + (PATHS.ATLAS_DB_PATH, )

	horizons.globals.db = _create_main_db()
	_modules.gui = Gui()
	SavegameManager.init()
	horizons.globals.fife.init_animation_loader(GFX.USE_ATLASES)
	
	from horizons.entities import Entities
	Entities.load(horizons.globals.db, load_now=False) # create all references

	# for preloading game data while in main screen
	preload_thread = threading.Thread(target=preload_game_data, args=(preload_lock,))
	preloading = (preload_thread, preload_lock)

	# Singleplayer seed needs to be changed before startup.
	if command_line_arguments.sp_seed:
		SINGLEPLAYER.SEED = command_line_arguments.sp_seed
	SINGLEPLAYER.FREEZE_PROTECTION = command_line_arguments.freeze_protection

	# start something according to commandline parameters
	startup_worked = True
	if command_line_arguments.start_dev_map:
		startup_worked = _start_map('development', command_line_arguments.ai_players,
			force_player_id=command_line_arguments.force_player_id, is_map=True)
	elif command_line_arguments.start_random_map:
		startup_worked = _start_random_map(command_line_arguments.ai_players, force_player_id=command_line_arguments.force_player_id)
	elif command_line_arguments.start_specific_random_map is not None:
		startup_worked = _start_random_map(command_line_arguments.ai_players,
			seed=command_line_arguments.start_specific_random_map, force_player_id=command_line_arguments.force_player_id)
	elif command_line_arguments.start_map is not None:
		startup_worked = _start_map(command_line_arguments.start_map, command_line_arguments.ai_players,
			force_player_id=command_line_arguments.force_player_id, is_map=True)
	elif command_line_arguments.start_scenario is not None:
		startup_worked = _start_map(command_line_arguments.start_scenario, 0, True, force_player_id=command_line_arguments.force_player_id)
	elif command_line_arguments.load_game is not None:
		startup_worked = _load_cmd_map(command_line_arguments.load_game, command_line_arguments.ai_players,
			command_line_arguments.force_player_id)
	elif command_line_arguments.load_quicksave is not None:
		startup_worked = _load_last_quicksave()
	elif command_line_arguments.edit_map is not None:
		startup_worked = edit_map(command_line_arguments.edit_map)
	elif command_line_arguments.edit_game_map is not None:
		startup_worked = edit_game_map(command_line_arguments.edit_game_map)
	elif command_line_arguments.stringpreview:
		tiny = [ i for i in SavegameManager.get_maps()[0] if 'tiny' in i ]
		if not tiny:
			tiny = SavegameManager.get_map()[0]
		startup_worked = _start_map(tiny[0], ai_players=0, trader_enabled=False, pirate_enabled=False,
			force_player_id=command_line_arguments.force_player_id, is_map=True)
		from development.stringpreviewwidget import StringPreviewWidget
		__string_previewer = StringPreviewWidget(_modules.session)
		__string_previewer.show()
	elif command_line_arguments.create_mp_game:
		_modules.gui.show_main()
		_modules.gui.windows.open(_modules.gui.multiplayermenu)
		_modules.gui.multiplayermenu._create_game()
		_modules.gui.windows._windows[-1].act()
	elif command_line_arguments.join_mp_game:
		_modules.gui.show_main()
		_modules.gui.windows.open(_modules.gui.multiplayermenu)
		_modules.gui.multiplayermenu._join_game()
	else: # no commandline parameter, show main screen

		# initialize update checker
		if not command_line_arguments.gui_test:
			setup_update_check()

		_modules.gui.show_main()
		if not command_line_arguments.nopreload:
			preloading[0].start()

	if not startup_worked:
		# don't start main loop if startup failed
		return False

	if command_line_arguments.gamespeed is not None:
		if _modules.session is None:
			print "You can only set the speed via command line in combination with a game start parameter such as --start-map, etc."
			return False
		_modules.session.speed_set(GAME_SPEED.TICKS_PER_SECOND*command_line_arguments.gamespeed)

	if command_line_arguments.gui_test:
		from tests.gui import TestRunner
		TestRunner(horizons.globals.fife, command_line_arguments.gui_test)

	horizons.globals.fife.run()

def setup_update_check():
	from horizons.util.checkupdates import UpdateInfo, check_for_updates, show_new_version_hint
	update_info = UpdateInfo()
	update_check_thread = threading.Thread(target=check_for_updates, args=(update_info,))
	update_check_thread.start()

	def update_info_handler(info):
		if info.status == UpdateInfo.UNINITIALIZED:
			ExtScheduler().add_new_object(Callback(update_info_handler, info), info)
		elif info.status == UpdateInfo.READY:
			show_new_version_hint(_modules.gui, info)
		elif info.status == UpdateInfo.INVALID:
			pass # couldn't retrieve file or nothing relevant in there

	update_info_handler(update_info) # schedules checks by itself

def setup_AI_settings(command_line_arguments):
	if command_line_arguments.ai_highlights:
		AI.HIGHLIGHT_PLANS = True
	if command_line_arguments.ai_combat_highlights:
		AI.HIGHLIGHT_COMBAT = True
	if command_line_arguments.human_ai:
		AI.HUMAN_AI = True

def setup_debug_mode(command_line_arguments):
	if not (command_line_arguments.debug_module
	        and 'fife' not in command_line_arguments.debug_module):
		horizons.globals.fife._log.logToPrompt = True

	if command_line_arguments.debug_log_only:
		# This is a workaround to not show fife logs in the shell even if
		# (due to the way the fife logger works) these logs will not be
		# redirected to the UH logfile and instead written to a file fife.log
		# in the current directory. See #1782 for background information.
		horizons.globals.fife._log.logToPrompt = False
		horizons.globals.fife._log.logToFile = True

def setup_gui_logger(command_line_arguments):
	"""
	Install gui logger, needs to be done before instantiating Gui, otherwise we miss
	the events of the main menu buttons
	"""
	if command_line_arguments.log_gui:
		if command_line_arguments.gui_test:
			raise Exception("Logging gui interactions doesn't work when running tests.")
		try:
			import tests.gui.logger
			logger.setup_gui_logger()
		except ImportError:
			traceback.print_exc()
			print
			print "Gui logging requires code that is only present in the repository and is not being installed."
			return False
	return True

def quit():
	"""Quits the game"""
	# joing preload thread before quiting in case active
	preload_game_join(preloading)
	horizons.globals.fife.quit()

def quit_session():
	"""Quits the current game."""
	_modules.session = None
	_modules.gui.show_main()

def start_singleplayer(options):
	"""Starts a singleplayer game."""
	_modules.gui.show_loading_screen()

	LoadingProgress.broadcast(None, 'load_objects')
	global preloading
	preload_game_join(preloading)

	# remove cursor while loading
	horizons.globals.fife.cursor.set(fife_module.CURSOR_NONE)
	horizons.globals.fife.engine.pump()
	horizons.globals.fife.set_cursor_image('default')

	# destruct old session (right now, without waiting for gc)
	if _modules.session is not None and _modules.session.is_alive:
		_modules.session.end()

	if options.is_editor:
		from horizons.editor.session import EditorSession as session_class
	else:
		from horizons.spsession import SPSession as session_class

	# start new session
	_modules.session = session_class(horizons.globals.db)

	from horizons.scenario import InvalidScenarioFileFormat # would create import loop at top
	try:
		_modules.session.load(options)
		_modules.gui.close_all()
	except InvalidScenarioFileFormat:
		raise
	except Exception:
		_modules.gui.close_all()
		# don't catch errors when we should fail fast (used by tests)
		if os.environ.get('FAIL_FAST', False):
			raise
		print "Failed to load", options.game_identifier
		traceback.print_exc()
		if _modules.session is not None and _modules.session.is_alive:
			try:
				_modules.session.end()
			except Exception:
				print
				traceback.print_exc()
				print "Additionally to failing when loading, cleanup afterwards also failed"
		_modules.gui.show_main()
		headline = _("Failed to start/load the game")
		descr = _("The game you selected could not be started.") + u" " + \
		        _("The savegame might be broken or has been saved with an earlier version.")
		_modules.gui.open_error_popup(headline, descr)
		_modules.gui.load_game()
	return _modules.session

def prepare_multiplayer(game, trader_enabled=True, pirate_enabled=True, natural_resource_multiplier=1):
	"""Starts a multiplayer game server
	TODO: actual game data parameter passing
	"""
	_modules.gui.show_loading_screen()

	global preloading
	preload_game_join(preloading)

	# remove cursor while loading
	horizons.globals.fife.cursor.set(fife_module.CURSOR_NONE)
	horizons.globals.fife.engine.pump()
	horizons.globals.fife.set_cursor_image('default')

	# destruct old session (right now, without waiting for gc)
	if _modules.session is not None and _modules.session.is_alive:
		_modules.session.end()
	# start new session
	from horizons.mpsession import MPSession
	# get random seed for game
	uuid = game.uuid
	random = sum([ int(uuid[i : i + 2], 16) for i in range(0, len(uuid), 2) ])
	_modules.session = MPSession(horizons.globals.db, NetworkInterface(), rng_seed=random)

	# NOTE: this data passing is only temporary, maybe use a player class/struct
	if game.is_savegame:
		map_file = SavegameManager.get_multiplayersave_map(game.map_name)
	else:
		map_file = SavegameManager.get_map(game.map_name)

	options = StartGameOptions.create_start_multiplayer(map_file, game.get_player_list(), not game.is_savegame)
	_modules.session.load(options)

def start_multiplayer(game):
	_modules.gui.close_all()
	_modules.session.start()


## GAME START FUNCTIONS
def _start_map(map_name, ai_players=0, is_scenario=False,
               pirate_enabled=True, trader_enabled=True, force_player_id=None, is_map=False):
	"""Start a map specified by user
	@param map_name: name of map or path to map
	@return: bool, whether loading succeeded"""
	if is_scenario:
		savegames = SavegameManager.get_available_scenarios(locales=True)
	else:
		savegames = SavegameManager.get_maps()
	map_file = _find_matching_map(map_name, savegames)
	if not map_file:
		return False

	options = StartGameOptions.create_start_singleplayer(map_file, is_scenario,
		ai_players, trader_enabled, pirate_enabled, force_player_id, is_map)
	start_singleplayer(options)
	return True

def _start_random_map(ai_players, seed=None, force_player_id=None):
	options = StartGameOptions.create_start_random_map(ai_players, seed, force_player_id)
	start_singleplayer(options)
	return True

def _load_cmd_map(savegame, ai_players, force_player_id=None):
	"""Load a map specified by user.
	@param savegame: either the displayname of a savegame or a path to a savegame
	@return: bool, whether loading succeeded"""
	# first check for partial or exact matches in the normal savegame list
	savegames = SavegameManager.get_saves()
	map_file = _find_matching_map(savegame, savegames)
	if not map_file:
		return False

	options = StartGameOptions.create_load_game(map_file, force_player_id)
	start_singleplayer(options)
	return True

def _find_matching_map(name_or_path, savegames):
	"""*name_or_path* is either a map/savegame name or path to a map/savegame file."""
	game_language = horizons.globals.fife.get_locale()
	# now we have "_en.yaml" which is set to language_extension variable
	language_extension = '_' + game_language + '.' + SavegameManager.scenario_extension
	map_file = None
	for filename, name in zip(*savegames):
		if name in (name_or_path, name_or_path + language_extension):
			# exact match or "tutorial" matching "tutorial_en.yaml"
			return filename
		if name.startswith(name_or_path): # check for partial match
			if map_file is not None:
				# multiple matches, collect all for output
				map_file += u'\n' + filename
			else:
				map_file = filename
	if map_file is not None:
		if len(map_file.splitlines()) > 1:
			print "Error: Found multiple matches:"
			for name_or_path in map_file.splitlines():
				print os.path.basename(name_or_path)
			return
		else:
			return map_file
	else: # not a savegame, check for path to file or fail
		if os.path.exists(name_or_path):
			return name_or_path
		else:
			print u"Error: Cannot find savegame or map '{name}'.".format(name=name_or_path)
			return

def _load_last_quicksave(session=None, force_player_id=None):
	"""Load last quicksave
	@param session: value of session
	@return: bool, whether loading succeeded"""
	save_files = SavegameManager.get_quicksaves()[0]
	if _modules.session is not None:
		if not save_files:
			_modules.session.ingame_gui.open_popup(_("No quicksaves found"),
			                                       _("You need to quicksave before you can quickload."))
			return False
	else:
		if not save_files:
			print "Error: No quicksave found."
			return False

	save = max(save_files)
	options = StartGameOptions.create_load_game(save, force_player_id)
	start_singleplayer(options)
	return True

def _edit_map(map_file):
	"""
	Start editing the specified map file.

	@param map_file: path to the map file or a list of random island strings
	@return: bool, whether loading succeeded
	"""
	if not map_file:
		return False

	options = StartGameOptions.create_editor_load(map_file)
	start_singleplayer(options)
	return True

def edit_map(map_name):
	"""
	Start editing the map file specified by the name.

	@param map_name: name of map or path to map
	@return: bool, whether loading succeeded
	"""
	return _edit_map(_find_matching_map(map_name, SavegameManager.get_maps()))

def edit_game_map(saved_game_name):
	"""
	Start editing the specified map.

	@param map_name: name of map or path to map
	@return: bool, whether loading succeeded
	"""
	saved_games = SavegameManager.get_saves()
	saved_game_path = _find_matching_map(saved_game_name, saved_games)
	if not saved_game_path:
		return False

	accessor = SavegameAccessor(saved_game_path, False)
	map_name = accessor.map_name
	accessor.close()
	if isinstance(map_name, list):
		# a random map represented by a list of island strings
		return _edit_map(map_name)
	return edit_map(map_name)

def _create_main_db():
	"""Returns a dbreader instance, that is connected to the main game data dbfiles.
	NOTE: This data is read_only, so there are no concurrency issues."""
	_db = UhDbAccessor(':memory:')
	for i in PATHS.DB_FILES:
		f = open(i, "r")
		sql = "BEGIN TRANSACTION;" + f.read() + "COMMIT;"
		_db.execute_script(sql)
	return _db

def preload_game_data(lock):
	"""Preloads game data.
	Keeps releasing and acquiring lock, runs until lock can't be acquired."""
	log = logging.getLogger("preload")
	try:
		lock.acquire()
		mydb = _create_main_db() # create own db reader instance, since it's not thread-safe
		from horizons.entities import Entities
		preload_functions = [ ActionSetLoader.load,
		                      TileSetLoader.load,
		                      Callback(Entities.load_grounds, mydb, load_now=True),
		                      Callback(Entities.load_buildings, mydb, load_now=True),
		                      Callback(Entities.load_units, load_now=True) ]
		for f in preload_functions:
			if not lock.acquire(False):
				break
			log.debug("Preload: %s", f)
			f()
			log.debug("Preload: %s is done", f)
			lock.release()
		log.debug("Preloading done.")
	except Exception as e:
		log.warning("Exception occurred in preloading thread: %s", e)
	finally:
		if lock.locked():
			lock.release()

def preload_game_join(preloading):
	"""Wait for preloading to finish.
	@param preloading: tuple: (Thread, Lock)"""
	# lock preloading
	thread, lock = preloading
	lock.acquire()
	# wait until it finished its current action
	if thread.isAlive():
		thread.join()
		assert not thread.isAlive()
	else:
		try:
			lock.release()
		except ThreadError:
			pass # due to timing issues, the lock might be released already

def set_debug_log(enabled, startup=False):
	"""
	@param enabled: boolean if logging should be enabled
	@param startup: True if on startup to apply settings. Won't show popup
	"""
	options = command_line_arguments

	if enabled: # enable logging
		if options.debug:
			# log file is already set up, just make sure everything is logged
			logging.getLogger().setLevel(logging.DEBUG)
		else: # set up all anew
			class Data(object):
				debug = False
				debug_log_only = True
				logfile = None
				debug_module = []
			# use setup call reference, see run_uh.py
			options.setup_debugging(Data)
			options.debug = True

		if not startup:
			headline = _("Logging enabled")
			msg = _("Logs are written to {directory}.").format(directory=PATHS.LOG_DIR)
			# Let the ext scheduler show the popup, so that all other settings can be saved and validated
			ExtScheduler().add_new_object(Callback(_modules.gui.open_popup, headline, msg), None)

	else: #disable logging
		logging.getLogger().setLevel(logging.WARNING)
		# keep debug flag in options so to not reenable it fully twice
		# on reenable, only the level will be reset

########NEW FILE########
__FILENAME__ = manager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import operator
import logging
import itertools

from horizons.timer import Timer
from horizons.scheduler import Scheduler
from horizons.util.worldobject import WorldObject
from horizons.util.living import LivingObject
from horizons.command.building import Build
from horizons.network import CommandError, packets

class SPManager(LivingObject):
	"""The manager class takes care of command issuing to the timermanager, sends tick-packets
	over the network, and synchronization of network games."""

	def __init__(self, session):
		super(SPManager, self).__init__()
		self.session = session
		self.commands = []

	def execute(self, command, local=False):
		"""Executes a command
		@param command: Command the command to be executed
		@param local: Whether to only execute command here (doesn't make sense in singleplayer
		"""
		# if we are in demo playback mode, every incoming command has to be thrown away.
		if self.commands:
			return
		ret = command(issuer=self.session.world.player) # actually execute the command
		# some commands might have a return value, so forward it
		return ret

	def load(self, db):
		pass

	def end(self):
		self.commands = None
		super(SPManager, self).end()

class MPManager(LivingObject):
	"""Handler for commands.
	Initiates sending commands over the network for multiplayer games and their correct
	execution time and is also responsible for handling lags"""
	log = logging.getLogger("mpmanager")
	command_log = logging.getLogger("mpmanager.commands") # command executions
	EXECUTIONDELAY = 4
	HASHDELAY = 4
	HASH_EVAL_DISTANCE = 2 # interval, check hash every nth tick

	def __init__(self, session, networkinterface):
		"""Initialize the Multiplayer Manager"""
		super(MPManager, self).__init__()
		self.session = session
		self.networkinterface = networkinterface
		self.commandsmanager = MPCommandsManager(self)
		self.localcommandsmanager = MPCommandsManager(self)
		self.checkuphashmanager = MPCheckupHashManager(self)
		self.gamecommands = [] # commands from the local user, that will be part of next CommandPacket
		self.localcommands = [] # (only local) commands from the local user (e.g. sounds only this user should hear)

		self.session.timer.add_test(self.can_tick)
		self.session.timer.add_call(self.tick)

		self.session.timer.add_test(self.can_hash_value_check)
		self.session.timer.add_call(self.hash_value_check)

		self._last_local_commands_send_tick = -1 # last tick, where local commands got sent

	def end(self):
		pass

	def can_tick(self, tick):
		"""Checks if we can execute this tick via return value"""
		# get new packages fom networkinteface
		packets_received = None
		try:
			packets_received = self.networkinterface.receive_all()
		except CommandError:
			return Timer.TEST_SKIP

		for packet in packets_received:
			if isinstance(packet, CommandPacket):
				self.log.debug("Got command packet from " + str(packet.player_id) + " for tick " + str(packet.tick))
				self.commandsmanager.add_packet(packet)
			elif isinstance(packet, CheckupHashPacket):
				self.log.debug("Got checkuphash packet from " + str(packet.player_id) + " for tick " + str(packet.tick))
				self.checkuphashmanager.add_packet(packet)
			else:
				self.log.warning("invalid packet: " + str(packet))

		# send out new commands
		# check if we already sent commands for this tick (only 1 packet per tick is allowed,
		# in case of lags this code would be executed multiple times for the same tick)
		if self._last_local_commands_send_tick < tick:
			self._last_local_commands_send_tick = tick
			commandpacket = CommandPacket(self.calculate_execution_tick(tick),
					self.session.world.player.worldid, self.gamecommands)
			self.gamecommands = []
			self.commandsmanager.add_packet(commandpacket)
			self.log.debug("sending command for tick %d" % (commandpacket.tick))
			self.networkinterface.send_packet(commandpacket)

			self.localcommandsmanager.add_packet(CommandPacket(self.calculate_execution_tick(tick),
					self.session.world.player.worldid, self.localcommands))
			self.localcommands = []

			# check if we have to evaluate a hash value
			if self.calculate_hash_tick(tick) % self.HASH_EVAL_DISTANCE == 0:
				hash_value = self.session.world.get_checkup_hash()
				#self.log.debug("MPManager: Checkup hash for tick %s is %s", tick, hash_value)
				checkuphashpacket = CheckupHashPacket(self.calculate_hash_tick(tick),
			                              self.session.world.player.worldid, hash_value)
				self.checkuphashmanager.add_packet(checkuphashpacket)
				self.log.debug("sending checkuphash for tick %d" % (checkuphashpacket.tick))
				self.networkinterface.send_packet(checkuphashpacket)

		# decide if tick can be calculated
		# in the first few ticks, no data is available
		if self.commandsmanager.is_tick_ready(tick) or tick < (Scheduler.FIRST_TICK_ID + self.EXECUTIONDELAY):
			#self.log.debug("MPManager: check tick %s ready: yes", tick)
			return Timer.TEST_PASS
		else:
			self.log.debug("MPManager: check tick %s ready: no", tick)
			return Timer.TEST_SKIP

	def tick(self, tick):
		"""Do the tick (execute all commands for this tick)
		This code may only be reached if we are allowed to tick now (@see can_tick)"""
		# calculate command packets for this tick
		command_packets = self.commandsmanager.get_packets_for_tick(tick)
		command_packets.extend(self.localcommandsmanager.get_packets_for_tick(tick))
		# sort by player, so that the packets get executed in the same order in every client
		# (packets are already in a special order within the packets, so no further sorting is necessary)
		command_packets.sort(key=operator.attrgetter('player_id'))

		for command_packet in command_packets:
			for command in command_packet.commandlist:
				self.log.debug("MPManager: calling command (tick %s): %s", tick, command)
				self.command_log.debug("MPManagerCommand: (tick %s): %s", tick, command)
				command(WorldObject.get_object_by_id(command_packet.player_id))

	def can_hash_value_check(self, tick):
		if self.checkuphashmanager.is_tick_ready(tick) or tick < self.HASHDELAY:
			return Timer.TEST_PASS
		else:
			return Timer.TEST_SKIP

	def hash_value_check(self, tick):
		if tick % self.HASH_EVAL_DISTANCE == 0:
			if not self.checkuphashmanager.are_checkup_hash_values_equal(tick, self.hash_value_diff):
				self.log.error("MPManager: Hash values generated in tick %s are not equal" % str(tick - self.HASHDELAY))
				# if this is reached, we are screwed. Something went wrong in the simulation,
				# but we don't know what. Stop the game.
				msg = _("The games have run out of sync. This indicates an unknown internal error, the game cannot continue.") + "\n" + \
				  _("We are very sorry and hope to have this bug fixed in a future version.")
				self.session.ingame_gui.open_error_popup('Out of sync', msg)

	def hash_value_diff(self, player1, hash1, player2, hash2):
		"""Called when a divergence has been detected"""
		self.log.error("MPManager: Hash diff:\n%s hash1: %s\n%s hash2: %s" % (player1, hash1, player2, hash2))
		self.log.error("------------------")
		self.log.error("Differences:")
		if len(hash1) != len(hash2):
			self.log.error("Different length")
		items1 = sorted(hash1.iteritems())
		items2 = sorted(hash2.iteritems())
		for i in xrange(min(len(hash1), len(hash2))):
			if (items1[i] != items2[i]):
				self.log.error(str(i)+": "+str(items1[i]))
				self.log.error(str(i)+": "+str(items2[i]))
		self.log.error("------------------")

	def calculate_execution_tick(self, tick):
		return tick + self.EXECUTIONDELAY

	def calculate_hash_tick(self, tick):
		return tick + self.HASHDELAY

	def execute(self, command, local=False):
		"""Receive commands to be executed from local player
		@param command: Command instance
		@param local: commands that don't need to be sent over the wire"""
		self.log.debug('MPManager: adding command (next tick: ' + str(self.session.timer.tick_next_id) + ')'+str(command))
		if local:
			self.localcommands.append(command)
		else:
			self.gamecommands.append(command)

	def get_player_count(self):
		return len(self.session.world.players)

	def get_builds_in_construction(self):
		"""Returns all Build-commands by the local player, that are executed in the next ticks"""
		commandpackets = self.commandsmanager.get_packets_from_player(self.session.world.player.worldid)

		# check commands already sent
		l1 = itertools.chain.from_iterable( (pkg.commandlist for pkg in commandpackets) )
		# and the ones that haven't been sent yet (this are of course only commands by the local player)
		commandlist = itertools.chain(l1, self.gamecommands)

		return filter(lambda x: isinstance(x, Build), commandlist)

	def load(self, db):
		"""Execute outstanding commands, loaded from db.
		Currently not supported for MP"""
		# NOTE: it is supported now, and such outstanding commands are dropped right now
		pass

# Packagemanagers storing Packages for later use
################################################

class MPPacketmanager(object):
	log = logging.getLogger("mpmanager")
	def __init__(self, mpmanager):
		self.mpmanager = mpmanager
		self.command_packet_list = []

	def is_tick_ready(self, tick):
		"""Check if packets from all players have arrived (necessary for tick to begin)"""
		ready = len(self.get_packets_for_tick(tick, remove_returned_commands=False)) == self.mpmanager.get_player_count()
		if not ready:
			self.log.debug("tick not ready, packets: " + str(list(str(x) for x in self.get_packets_for_tick(tick, remove_returned_commands=False))))
		return ready

	def get_packets_for_tick(self, tick, remove_returned_commands=True):
		"""Returns packets that are to be executed at a certain tick"""
		command_packets = filter(lambda x: x.tick==tick, self.command_packet_list)
		if remove_returned_commands:
			self.command_packet_list = filter(lambda x: x.tick!=tick, self.command_packet_list)
		return command_packets

	def get_packets_from_player(self, player_id):
		"""
		Returns all command this player has issued, that are not yet executed
		@param player_id: worldid of player
		"""
		return filter(lambda x: x.player_id==player_id, self.command_packet_list)

	def add_packet(self, command_packet):
		"""Receive a packet"""
		self.command_packet_list.append(command_packet)

class MPCommandsManager(MPPacketmanager):
	pass

class MPCheckupHashManager(MPPacketmanager):
	def is_tick_ready(self, tick):
		# we only check hash for every HASH_EVAL_DISTANCE tick
		# if the current tick isn't checked we don't need any packets and are always ready
		if tick % self.mpmanager.HASH_EVAL_DISTANCE != 0:
			return True
		return super(MPCheckupHashManager, self).is_tick_ready(tick)

	def are_checkup_hash_values_equal(self, tick, cb_diff=None):
		"""
		@param packages for tick
		@param cb_diff: called in case hashes differ
		@return False if they are not equal
		"""
		pkges = self.get_packets_for_tick(tick)
		for pkg in pkges[1:]:
			if pkges[0].checkup_hash != pkg.checkup_hash:
				if cb_diff is not None:
					localplayerid = self.mpmanager.session.world.player.worldid
					cb_diff("local" if pkges[0].player_id==localplayerid else "pl#%02d" % (pkges[0].player_id),
						pkges[0].checkup_hash,
						"local" if pkg.player_id==localplayerid else "pl#%02d" % (pkg.player_id),
						pkg.checkup_hash)
				return False
		return True

# Packages transmitted over the network
#######################################

class MPPacket(object):
	"""Packet to be sent from every player to every player"""
	def __init__(self, tick, player_id):
		"""
		@param player_id: worldid of player
		"""
		self.tick = tick
		self.player_id = player_id

	@classmethod
	def allow_network(self, klass):
		"""
		NOTE: this is a security related method and may lead to
		execution of arbritary code if used in a wrong way
		see documentation inside horizons.network.packets.SafeUnpickler
		"""
		packets.SafeUnpickler.add('server', klass)

	def __str__(self):
		return "packet " + str(self.__class__)  + " from player " + str(WorldObject.get_object_by_id(self.player_id)) + " for tick " + str(self.tick)

class CommandPacket(MPPacket):
	"""Packet to be sent from every player to every player every tick.
	Contains list of packets to be executed as well as the designated execution time.
	Also acts as ping (game will stop if a packet for a certain tick hasn't arrived)"""
	def __init__(self, tick, player_id, commandlist):
		super(CommandPacket, self).__init__(tick, player_id)
		self.commandlist = commandlist

MPPacket.allow_network(CommandPacket)

class CheckupHashPacket(MPPacket):
	def __init__(self, tick, player_id, checkup_hash):
		super(CheckupHashPacket, self).__init__(tick, player_id)
		self.checkup_hash = checkup_hash

MPPacket.allow_network(CheckupHashPacket)

########NEW FILE########
__FILENAME__ = message
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.messaging.messagebus import MessageBus


class Message(object):
	"""Message class for the MessageBus. Every Message that is supposed to be
	send through the MessageBus has to subclass this base class, to ensure proper
	setting of base attributes and inheriting the interface.

	The first argument in each message is always a reference to the sender,
	additional expected arguments are defined on the class-level attribute `arguments`,
	these will be stored on the instance.
	"""
	arguments = tuple()

	def __init__(self, sender, *args):
		self.sender = sender
		if len(self.arguments) != len(args):
			raise Exception('Unexpected number of arguments. Expected %d, received %d' % (
				len(self.arguments), len(args)))

		for arg, value in zip(self.arguments, args):
			setattr(self, arg, value)

	@classmethod
	def subscribe(cls, callback, sender=None):
		"""Register a callback to be called whenever a message of this type is send.

		callback - Callable that receives an instance of a message as only argument.

		sender	-	If specified, the callback receives only messages that originated
					from sender. By default, all messages are received.

		Example:

			>>> def cb(msg):
			... 	print 'Received', msg

			>>> MessageClass.subscribe(cb)	# Global
			>>> MessageClass.subscribe(cb, sender=foo) # Specific sender
		"""
		if sender:
			MessageBus().subscribe_locally(cls, sender, callback)
		else:
			MessageBus().subscribe_globally(cls, callback)

	@classmethod
	def unsubscribe(cls, callback, sender=None):
		"""Stop your subscription of this message type for the specified callback.

		callback -	Callable that receives an instance of a message as only argument.
					The same you've been using with `Message.subscribe`.

		sender	-	If specified, the subscription will only be stopped for messages
					from this sender. By default, all subscriptions are ended.

		Note: There has to be a subscription, otherwise an error will be raised.

		Example:

			>>> MessageClass.subscribe(cb)
			>>> MessageClass.broadcast('sender')
			message received
			>>> MessageClass.unsubscribe(cb)
			>>> MessageClass.broadcast('sender')
		"""
		if sender:
			MessageBus().unsubscribe_locally(cls, sender, callback)
		else:
			MessageBus().unsubscribe_globally(cls, callback)

	@classmethod
	def discard(cls, callback, sender=None):
		"""Similar to `Message.unsubscribe`, but does not raise an error if the
		callback has not been registered before.
		"""
		if sender:
			MessageBus().discard_locally(cls, sender, callback)
		else:
			MessageBus().discard_globally(cls, callback)

	@classmethod
	def broadcast(cls, *args):
		"""Send a message that is initialized with `args`.

		The first argument is always a sender, the number of arguments has to be
		N + 1, with N being the number of arguments defined on the message class.

		Example:

			>>> class Foo(Message):
			... 	arguments = ('a', 'b', )

			>>> Foo.broadcast('sender', 1, 2)
		"""
		MessageBus().broadcast(cls(*args))


class AddStatusIcon(Message):
	arguments = ('icon', )

class RemoveStatusIcon(Message):
	arguments = (
		'instance',		# the instance from which to remove the icon
		'icon_class'	# class object of the icon that is to be removed
	)

class SettlerUpdate(Message):
	"""Sent when the level of a settler building changes. Message includes the new
	level and the change (+1/-1).
	"""
	arguments = ('level', 'change', )

class PlayerLevelUpgrade(Message):
	"""Sent when the settler level of a player increases."""
	arguments = ('level', 'building', )

class SettlerInhabitantsChanged(Message):
	"""Class to signal that the number of inhabitants in a settler building
	have changed."""
	arguments = ('change', )

class ResourceBarResize(Message):
	"""Signals a change in resource bar size (not slot changes, but number of slot changes)."""
	pass

class UpgradePermissionsChanged(Message):
	"""In a settlement."""
	pass

class SettlementRangeChanged(Message):
	"""Called on grow and perhaps shrink once that's implemented. Used by buildingtool.
	Sent by a Settlement."""
	arguments = (
		'changed_tiles', # Actual tile objects
	)

class WorldObjectDeleted(Message):
	"""Called when a world object is being deleted.
	Currently emitted in the process of destruction, i.e. you aren't guaranteed
	to be able to access any attributes.
	(Feel free to change the implementation if you need this).
	"""
	arguments = ('worldobject', 'worldid', )

class ShipDestroyed(Message):
	"""Sent just when a ship is destroyed."""
	pass

class NewPlayerSettlementHovered(Message):
	"""Sent when the mouse hovers over a different settlement than before,
	and it belongs to the local player or is None."""
	arguments = ('settlement', )

class HoverSettlementChanged(Message):
	"""Sent when hovering over any different settlement, or no settlement."""
	arguments = ('settlement', )

class NewSettlement(Message):
	"""Sent when a new settlement is created."""
	arguments = ('settlement', 'warehouse_position', )

class HoverInstancesChanged(Message):
	"""Sent when hovering over a different set of instances.
	Not sent on every mouse move but with a bit of delay to be able to do more extensive
	computation without risk of delays."""
	arguments = ('instances', )

class NewDisaster(Message):
	"""Sent when a building is affected by a disaster."""
	arguments = ('building', 'disaster_class', 'disaster')

class TabWidgetChanged(Message):
	"""Sent when the ingamegui displays a different set of tabs, i.e. the tabwidget is exchanged.
	The tabs are not necessarily different from the old ones."""
	pass

class GuiAction(Message):
	"""Sent on events pychan classifies as "action"."""
	pass

class ResourceProduced(Message):
	"""Sent when a production building finished the production of a resource."""
	arguments = ('caller', 'produced_resources', )

class InstanceInventoryUpdated(Message):
	"""Message sent whenever an inventory of any instance is updated.

	This message is sent by StorageComponent but sender is the instance!
	"""
	arguments = ('inventory', )

class SettlementInventoryUpdated(Message):
	"""Message sent whenever a settlement's inventory is updated."""
	pass

class PlayerInventoryUpdated(Message):
	"""Message sent whenever a player's inventory is updated."""
	pass

class LanguageChanged(Message):
	"""Sent when the language has changed."""
	pass

class SpeedChanged(Message):
	"""Sent when the ingame speed has changed."""
	arguments = ('old', 'new', )

class SettingChanged(Message):
	"""Sent when a setting is changed in the dialog."""
	arguments = ('setting_name', 'old_value', 'new_value', )

class MineEmpty(Message):
	"""Sent when there are no more resources left in a mine."""
	arguments = ('mine', )

class LoadingProgress(Message):
	"""Sent when loading screen is updated with a new progress hint."""
	arguments = ('stage', )

class ZoomChanged(Message):
	"""Sent when map zoom has changed."""
	arguments = ('zoom', )

class ActionChanged(Message):
	"""Sent when a ConcreteObject changed its action"""
	arguments = ('action', )

########NEW FILE########
__FILENAME__ = messagebus
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
from collections import defaultdict

from horizons.util.python.singleton import Singleton


class MessageBus(object):
	"""The MessageBus class is used to send Message instances from a sender to
	one or multiple recipients."""
	__metaclass__ = Singleton

	log = logging.getLogger("messaging.messagebus")

	def __init__(self):
		# Register {MessageType: [list of receiver callbacks]}
		self.global_receivers = defaultdict(list)
		# Register for messages from a specific object
		# {(MessageType, instance): [list of receiver callbacks]}
		self.local_receivers = defaultdict(list)

	def subscribe_globally(self, messagetype, callback):
		"""Register for a certain message type.
		@param callback: Callback methode, needs to take 1 parameter: the message"""
		self.global_receivers[messagetype].append(callback)

	def subscribe_locally(self, messagetype, instance, callback):
		"""Register for a certain message type from a specific instance.
		@param callback: Callback methode, needs to take 1 parameter: the message"""
		pair = (messagetype, instance)
		self.local_receivers[pair].append(callback)

	def unsubscribe_globally(self, messagetype, callback):
		assert callback in self.global_receivers[messagetype]
		self.global_receivers[messagetype].remove(callback)

	def unsubscribe_locally(self, messagetype, instance, callback):
		pair = (messagetype, instance)
		assert callback in self.local_receivers[pair]
		self.local_receivers[pair].remove(callback)

	def discard_globally(self, messagetype, callback):
		if callback in self.global_receivers[messagetype]:
			self.unsubscribe_globally(messagetype, callback)

	def discard_locally(self, messagetype, instance, callback):
		pair = (messagetype, instance)
		if pair in self.local_receivers and callback in self.local_receivers[pair]:
			self.unsubscribe_locally(messagetype, instance, callback)

	def broadcast(self, message):
		"""Send a message to the bus and broadcast it to all recipients"""
		messagetype = message.__class__
		for callback in self.global_receivers[messagetype]:
			# Execute the callback
			callback(message)

		pair = (messagetype, message.sender)
		for callback in self.local_receivers[pair]:
			# Execute the callback
			callback(message)

	def reset(self):
		"""Reset to initial state. Drops all subscriptions"""
		# there shouldn't be anything left now, warn if there is
		for messagetype, cb_list in self.global_receivers.iteritems():
			if cb_list:
				self.log.debug("MessageBus: leftover global receivers {cb} for {messagetype}".format(cb=[str(i) for i in cb_list], messagetype=messagetype))
		for messagetype, cb_list in self.local_receivers.iteritems():
			if cb_list:
				self.log.debug("MessageBus: leftover local receivers {cb} for {messagetype}".format(cb=[str(i) for i in cb_list], messagetype=messagetype))

		# suicide, next instance will be created on demand
		self.__class__.destroy_instance()


class SimpleMessageBus(object):
	"""Manages registration and calling of callbacks when events (strings) occur.

	Example:

		bus = SimpleMessageBus(('foo', 'bar'))
		bus.subscribe('foo', cb)

		bus.broadcast('foo')  # cb will be called
	"""

	def __init__(self, message_types):
		self._message_types = message_types
		self._callbacks = defaultdict(list)

	def subscribe(self, type, callback):
		if type not in self._message_types:
			raise TypeError("Unsupported type")
		if callback in self._callbacks[type]:
			raise Exception("Callback %s already subscribed to %s" % (callback, type))

		self._callbacks[type].append(callback)

	def unsubscribe(self, type, callback):
		self._callbacks[type].remove(callback)

	def discard(self, type, callback):
		if callback in self._callbacks[type]:
			self._callbacks[type].remove(callback)

	def broadcast(self, type, *args, **kwargs):
		if type not in self._message_types:
			return

		for cb in self._callbacks[type]:
			cb(*args, **kwargs)

########NEW FILE########
__FILENAME__ = mpsession
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import random

import horizons.main
from horizons.session import Session
from horizons.manager import MPManager
from horizons.timer import Timer
from horizons.savegamemanager import SavegameManager
from horizons.command.game import SaveCommand

class MPSession(Session):
	"""Session class for multiplayer games."""

	def __init__(self, db, network_interface, **kwargs):
		"""
		@param network_interface: instance of NetworkInterface to use for this game
		@param rng_seed: seed for random number generator
		"""
		self.__network_interface = network_interface
		self.__network_interface.subscribe("game_starts", self._start_game)
		self.__network_interface.subscribe("error", self._on_error)
		super(MPSession, self).__init__(db, **kwargs)

	def _start_game(self, game):
		horizons.main.start_multiplayer(game)

	def _on_error(self, exception, fatal=True):
		"""Error callback"""
		if fatal:
			self.timer.ticks_per_second = 0
			self.ingame_gui.windows.open_popup(_("Fatal Network Error"),
		                                       _("Something went wrong with the network:") + u'\n' +
		                                       unicode(exception) )
			self.quit()
		else:
			self.ingame_gui.open_popup(_("Error"), unicode(exception))

	def speed_set(self, ticks, suggestion=False):
		"""Set game speed to ticks ticks per second"""
		if not suggestion:
			super(MPSession, self).speed_set(ticks, suggestion)

	def create_manager(self):
		return MPManager(self, self.__network_interface)

	def create_rng(self, seed=None):
		return random.Random(seed)

	def create_timer(self):
		return Timer(freeze_protection=False)

	def end(self):
		self.__network_interface.unsubscribe("error", self._on_error)
		self.__network_interface.unsubscribe("game_starts", self._start_game)
		self.__network_interface.disconnect()
		super(MPSession, self).end()

	def autosave(self):
		self.ingame_gui.open_popup(_("Not possible"), _("Save/load for multiplayer games is not possible yet"))
		return  #TODO disabled for now, see #2151 for details
		SaveCommand( SavegameManager.create_multiplayer_autosave_name() ).execute(self)

	def quicksave(self):
		self.ingame_gui.open_popup(_("Not possible"), _("Save/load for multiplayer games is not possible yet"))
		return  #TODO disabled for now, see #2151 for details
		SaveCommand( SavegameManager.create_multiplayer_quicksave_name() ).execute(self)

	def quickload(self):
		self.ingame_gui.open_popup(_("Not possible"), _("Save/load for multiplayer games is not possible yet"))

	def save(self, savegamename=None):
		self.ingame_gui.open_popup(_("Not possible"), _("Save/load for multiplayer games is not possible yet"))
		return  #TODO disabled for now, see #2151 for details
		if savegamename is None:
			def sanity_checker(string):
				try:
					SavegameManager.create_multiplayersave_filename(string)
				except RuntimeError:
					return False
				else:
					return True
			sanity_criteria = _(
				"The filename must consist only of letters, numbers, spaces "
				"and these characters: _ . -"
			)
			savegamename = self.ingame_gui.show_select_savegame(mode='mp_save', sanity_checker=sanity_checker,
			                                                    sanity_criteria=sanity_criteria)
			if savegamename is None:
				return True # user aborted dialog

		SaveCommand( savegamename ).execute(self)
		return True

########NEW FILE########
__FILENAME__ = common
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import uuid
from gettext import NullTranslations

from horizons.network import packets, enet


class Address(object):
	def __init__(self, address, port=None):
		if isinstance(address, enet.Address):
			self.host = address.host
			self.port = address.port
		else:
			self.host = address
			self.port = int(port)

	def __str__(self):
		return "%s:%u" % (self.host, self.port)

	def __hash__(self):
		return hash((self.host, self.port))

	def __eq__(self, other):
		if isinstance(other, Address):
			return (self.host == other.host and self.port == other.port)
		if isinstance(other, enet.Address):
			return self.__eq__(Address(other))
		return NotImplemented

	def __ne__(self, other):
		if isinstance(other, Address) or isinstance(other, enet.Address):
			return not self.__eq__(other)
		return NotImplemented

#-----------------------------------------------------------------------------

nulltranslation = NullTranslations()
class Player(object):
	def __init__(self, peer, sid, protocol=0):
		# pickle doesn't use all of these attributes
		# for more detail check __getstate__()
		self.peer     = peer
		assert isinstance(self.peer, enet.Peer)
		self.address  = Address(self.peer.address)
		self.sid      = sid
		# there's a difference between player.protocol and player.version:
		# - player.protocol is the network protocol version used by the
		#   client while talking to the server
		# - player.version is the game version which all players in a game
		#   must match. player.version gets set during oncreate/onjoin
		self.protocol = protocol
		self.version  = None
		self.name     = None
		self.color    = None
		self.clientid = None
		self.game     = None
		self.ready    = False
		self.prepared = False
		self.fetch    = False
		self.gettext  = nulltranslation

	# for pickle: return only relevant data to the player
	def __getstate__(self):
		return {
				'sid':      self.sid,
				'address':  None,
				'name':     self.name,
				'color':    self.color,
				'ready':    self.ready,
				'clientid': self.clientid
			}

	def __hash__(self):
		return hash((self.address))

	def __eq__(self, other):
		if not isinstance(other, Player):
			return NotImplemented
		# server only cares about address
		if self.address is not None or other.address is not None:
			return (self.address == other.address)
		else:
			return (self.sid == other.sid)

	def __ne__(self, other):
		if not isinstance(other, Player):
			return NotImplemented
		return not self.__eq__(other)

	def __str__(self):
		if self.name:
			return "Player(addr=%s;proto=%d;name=%s)" % (self.address, self.protocol, self.name)
		else:
			return "Player(addr=%s;proto=%d)" % (self.address, self.protocol)

	def join(self, game, packet):
		""" assigns player data sent by create/join-command to the player """
		assert (isinstance(packet, packets.client.cmd_creategame)
		        or isinstance(packet, packets.client.cmd_joingame))
		self.game     = game
		self.version  = packet.clientversion
		self.name     = packet.playername
		self.color    = packet.playercolor
		self.clientid = packet.clientid
		self.ready    = False
		if isinstance(packet, packets.client.cmd_joingame):
			self.fetch = packet.fetch

	def toggle_ready(self):
		self.ready = not self.ready
		return self.ready

packets.SafeUnpickler.add('server', Player)

#-----------------------------------------------------------------------------

class Game(object):
	class State(object):
		Open      = 0
		Prepare   = 1
		Running   = 2

		def __init__(self, state=Open):
			self.state = state

		def __str__(self):
			strvals = [ "Open", "Prepare", "Running" ]
			return "%s" % (strvals[self.state])

	def __init__(self, packet, creator):
		# pickle doesn't use all of these attributes
		# for more detail check __getstate__()
		assert isinstance(packet, packets.client.cmd_creategame)
		self.uuid          = uuid.uuid1().hex
		self.mapname       = packet.mapname
		self.maphash       = packet.maphash
		self.maxplayers    = packet.maxplayers
		self.name          = packet.name
		self.password      = packet.password
		self.creator       = creator
		self.players       = []
		self.playercnt     = 0 # needed for privacy for gamelist-requests
		self.state         = Game.State.Open
		self.add_player(self.creator, packet)

	# for pickle: return only relevant data to the player
	def __getstate__(self):
		# NOTE: don't return _ANY_ private data here as these object
		# will be used to build the public game list. if really necessary remove
		# the private data in packets.data_gameslist.addgame
		# NOTE: this classes are used on the client too, so beware of
		# datatype changes
		state = self.__dict__.copy()

		# overwrite private data
		state['password'] = bool(self.password)

		# make data backwards compatible
		state['creator'] = self.creator.name
		state['clientversion'] = self.creator.version
		if self.creator.protocol == 0:
			state['load'] = self.maphash if self.maphash else None
			del state['maphash']

		return state

	def make_public_copy(self):
		# NOTE: __getstate__ will be called afterwards, so don't delete
		# or overwrite data that will be overwritten/deleted by __getstate__
		game = object.__new__(type(self))
		game.__dict__ = self.__dict__.copy()
		game.players = []
		return game

	# add player to game. packet should be packet received in oncreate/onjoin
	def add_player(self, player, packet):
		player.join(self, packet)
		self.players.append(player)
		self.playercnt += 1
		return player

	def remove_player(self, player):
		if player not in self.players:
			return None
		self.players.remove(player)
		self.playercnt -= 1
		player.game = None
		return player

	def is_full(self):
		return (self.playercnt == self.maxplayers)

	def is_empty(self):
		return (self.playercnt == 0)

	def is_ready(self):
		count = 0
		for player in self.players:
			if player.ready:
				count += 1
		return (count == self.maxplayers)

	def is_open(self):
		return (self.state == Game.State.Open)

	def has_password(self):
		return bool(self.password)

	def clear(self):
		for player in self.players:
			player.game = None
		del self.players[:]
		self.playercnt = 0

	def __str__(self):
		return "Game(uuid=%s;maxpl=%d;plcnt=%d;pw=%d;state=%s)" % (self.uuid, self.maxplayers, self.playercnt, self.has_password(), Game.State(self.state))

packets.SafeUnpickler.add('server', Game)

#-----------------------------------------------------------------------------

# types of soft errors used by cmd_error
# this way we don't have to create a new packet for every type of error
class ErrorType(object):
	NotSet = 0
	TerminateGame = 1

	def __init__(self, state=NotSet):
		self.state = state

	def __str__(self):
		strvals = [ "NotSet", "TerminateGame" ]
		return "%s" % (strvals[self.state])

packets.SafeUnpickler.add('common', ErrorType)

########NEW FILE########
__FILENAME__ = connection
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import time

from horizons import network
from horizons.network import enet, packets


# maximal peers enet should handle
MAX_PEERS = 1

# current server/client protocol the client understands
# increment that after incompatible protocol changes
SERVER_PROTOCOL = 1

# time in ms the client will wait for a packet
# on error client may wait twice that time
SERVER_TIMEOUT = 5000


class Connection(object):
	"""Low-level interface to enet.

	Handles sending and receiving packets.
	"""
	log = logging.getLogger("network")

	def __init__(self, process_async_packet, server_address, client_address=None):
		try:
			if client_address:
				client_address = enet.Address(*client_address)

			self.host = enet.Host(client_address, MAX_PEERS, 0, 0, 0)
		except (IOError, MemoryError):
			# these exceptions do not provide any information.
			raise network.NetworkException("Unable to create network structure."
			                               "Maybe invalid or irresolvable client address.")

		self.server_address_parameters = server_address
		self.server_address = None
		self.server_peer = None
		self.packetqueue = []
		self.process_async_packet = process_async_packet

	# Connection setup / keepalive

	@property
	def is_connected(self):
		return self.server_peer is not None

	def connect(self):
		"""Connect to master server.

		After this, you can use `send_packet` and `receive_packet` to communicate
		with the server.
		"""
		if self.is_connected:
			raise network.AlreadyConnected("We are already connected to a server")

		self.log.debug("[CONNECT] to server %s" % (self.server_address))
		try:
			if self.server_address is None:
				# can only construct address now, as it resolves the target and requires internet connection
				self.server_address = enet.Address(*self.server_address_parameters)
			self.server_peer = self.host.connect(self.server_address, 1, SERVER_PROTOCOL)
		except (IOError, MemoryError):
			raise network.NetworkException(_("Unable to connect to server.") + u" " +
			                               _("Maybe invalid or irresolvable server address."))

		event = self.host.service(SERVER_TIMEOUT)
		if event.type != enet.EVENT_TYPE_CONNECT:
			self._reset()
			raise network.UnableToConnect(_("Unable to connect to server."))

	def disconnect(self, server_may_disconnect=False):
		"""End connection to master server.

		This function should _never_ throw an exception.
		"""
		if not self.is_connected:
			return

		if self.server_peer.state == enet.PEER_STATE_DISCONNECTED:
			self._reset()
			return

		try:
			# wait for a disconnect event or empty event
			if server_may_disconnect:
				while True:
					event = self.host.service(SERVER_TIMEOUT)
					if event.type == enet.EVENT_TYPE_DISCONNECT:
						break
					elif event.type == enet.EVENT_TYPE_NONE:
						break

			# disconnect from server if we're still connected
			if self.server_peer.state != enet.PEER_STATE_DISCONNECTED:
				self.server_peer.disconnect()
				while True:
					event = self.host.service(SERVER_TIMEOUT)
					if event.type == enet.EVENT_TYPE_DISCONNECT:
						break
					elif event.type == enet.EVENT_TYPE_NONE:
						raise IOError("No packet from server")
		except IOError:
			self.log.debug("[DISCONNECT] Error while disconnecting from server. Maybe server isn't answering any more")

		self._reset()
		self.log.debug("[DISCONNECT] done")

	def ping(self):
		"""Handle incoming packets.

		Enet doesn't need to send pings. Call this regularly. Incoming packets can be
		handled by process_async_packet, otherwise will be added to a queue.
		"""
		if not self.is_connected:
			raise network.NotConnected()

		packet = self._receive(0)
		if packet is not None:
			if not self.process_async_packet(packet):
				self.packetqueue.append(packet)
			return True

		return False

	# Send / Receive

	def send_packet(self, packet):
		"""Send a packet to the server.

		packet has to be a subclass of `horizons.network.packets.packet`.
		"""
		if self.server_peer is None:
			raise network.NotConnected()

		packet = enet.Packet(packet.serialize(), enet.PACKET_FLAG_RELIABLE)
		self.server_peer.send(0, packet)

	def receive_packet(self, packet_type=None, timeout=SERVER_TIMEOUT):
		"""Return the first received packet.

		If packet_type is given, only a packet of that type will be returned.
		"""

		if self.packetqueue:
			if packet_type is None:
				return self.packetqueue.pop(0)

			for p in self.packetqueue:
				if not isinstance(p[1], packet_type):
					continue
				self.packetqueue.remove(p)
				return p

		if packet_type is None:
			return self._receive(timeout)

		start = time.time()
		timeleft = timeout
		while timeleft > 0:
			packet = self._receive(timeleft)
			# packet type is None -> return whatever we received
			if packet_type is None:
				return packet
			# otherwise only process non-None packets
			if packet is not None:
				if isinstance(packet[1], packet_type):
					return packet
				if not self.process_async_packet(packet):
					self.packetqueue.append(packet)
			timeleft -= time.time() - start
		raise network.FatalError("No reply from server")

	def _receive_event(self, timeout=SERVER_TIMEOUT):
		"""Receives next event of type NONE or RECEIVE."""
		if self.server_peer is None:
			raise network.NotConnected()
		try:
			event = self.host.service(timeout)

			if event.type == enet.EVENT_TYPE_NONE:
				return None
			elif event.type == enet.EVENT_TYPE_DISCONNECT:
				self._reset()
				self.log.warning("Unexpected disconnect from %s" % (event.peer.address))
				raise network.CommandError("Unexpected disconnect from %s" % (event.peer.address))
			elif event.type == enet.EVENT_TYPE_CONNECT:
				self._reset()
				self.log.warning("Unexpected connection from %s" % (event.peer.address))
				raise network.CommandError("Unexpected connection from %s" % (event.peer.address))

			return event
		except IOError as e:
			raise network.FatalError(e)

	def _receive(self, timeout=SERVER_TIMEOUT):
		"""Receive event and return unpacked packet."""
		try:
			event = self._receive_event(timeout)
			if event is None or event.type != enet.EVENT_TYPE_RECEIVE:
				return None

			packet = packets.unserialize(event.packet.data)
		except Exception as e:
			try:
				event
			except NameError:
				pass
			else:
				self.log.error("Unknown packet from %s!" % (event.peer.address))
			errstr = "Pickle/Security: %s" % (e)
			print "[FATAL] %s" % (errstr) # print that even when no logger is enabled!
			self.log.error("[FATAL] %s" % (errstr))
			self.disconnect()
			raise network.FatalError(errstr)

		if isinstance(packet, packets.cmd_error):
			# handle special errors here
			# FIXME: it's better to pass that to the interface,
			# but our ui error handler currently can't handle that

			# the game got terminated by the client
			"""
			# TODO
			if packet.type == ErrorType.TerminateGame:
				game = self.game
				# this will destroy self.game
				self.leavegame(stealth=True)
				self.call_callbacks("lobbygame_terminate", game, packet.errorstr)
				return None
			"""
			raise network.CommandError(packet.errorstr)
		elif isinstance(packet, packets.cmd_fatalerror):
			self.log.error("[FATAL] Network message: %s" % (packet.errorstr))
			self.disconnect(server_may_disconnect=True)
			raise network.FatalError(packet.errorstr)

		return [event.peer, packet]

	def _reset(self):
		self.log.debug("[RESET]")
		if self.is_connected:
			self.server_peer.reset()
			self.server_peer = None
		self.host.flush()

########NEW FILE########
__FILENAME__ = networkinterface
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import uuid

import horizons.globals

from horizons import network
from horizons.constants import NETWORK, VERSION, LANGUAGENAMES
from horizons.extscheduler import ExtScheduler
from horizons.messaging.messagebus import SimpleMessageBus
from horizons.network import CommandError, NetworkException, FatalError, packets
from horizons.network.common import Game
from horizons.network.connection import Connection
from horizons.util.color import Color
from horizons.util.difficultysettings import DifficultySettings
from horizons.util.python import parse_port
from horizons.util.python.singleton import ManualConstructionSingleton


class ClientMode(object):
	Server = 0
	Game = 1


class ClientData(object):
	def __init__(self):
		self.name = horizons.globals.fife.get_uh_setting("Nickname")
		self.color = horizons.globals.fife.get_uh_setting("ColorID")
		self.version = VERSION.RELEASE_VERSION

		try:
			self.id = uuid.UUID(horizons.globals.fife.get_uh_setting("ClientID")).hex
		except (ValueError, TypeError):
			# We need a new client id
			client_id = uuid.uuid4()
			horizons.globals.fife.set_uh_setting("ClientID", client_id)
			horizons.globals.fife.save_settings()
			self.id = client_id.hex


class NetworkInterface(object):
	"""Interface for low level networking"""
	__metaclass__ = ManualConstructionSingleton

	log = logging.getLogger("network")

	PING_INTERVAL = 0.5 # ping interval in seconds

	def __init__(self):
		self._mode = None
		self.sid = None
		self.capabilities = None
		self._game = None

		message_types = ('lobbygame_chat', 'lobbygame_join', 'lobbygame_leave',
		                 'lobbygame_terminate', 'lobbygame_toggleready',
		                 'lobbygame_changename', 'lobbygame_kick',
		                 'lobbygame_changecolor', 'lobbygame_state',
		                 'lobbygame_starts', 'game_starts',
		                 'game_details_changed', 'game_prepare', 'error')

		self._messagebus = SimpleMessageBus(message_types)
		self.subscribe = self._messagebus.subscribe
		self.unsubscribe = self._messagebus.unsubscribe
		self.broadcast = self._messagebus.broadcast
		self.discard = self._messagebus.discard

		# create a game_details_changed callback
		for t in ('lobbygame_join', 'lobbygame_leave', 'lobbygame_changename',
		          'lobbygame_changecolor', 'lobbygame_toggleready'):
			self.subscribe(t, lambda *a, **b: self.broadcast("game_details_changed"))

		self.subscribe("lobbygame_starts", self._on_lobbygame_starts)
		self.subscribe('lobbygame_changename',  self._on_change_name)
		self.subscribe('lobbygame_changecolor', self._on_change_color)

		self.received_packets = []

		ExtScheduler().add_new_object(self.ping, self, self.PING_INTERVAL, -1)

		self._client_data = ClientData()
		self._setup_client()

	# Connection

	def _setup_client(self):
		"""Initialize connection object. Does not connect to the server."""
		server_address = [NETWORK.SERVER_ADDRESS, NETWORK.SERVER_PORT]
		client_address = None
		client_port = parse_port(horizons.globals.fife.get_uh_setting("NetworkPort"))

		if NETWORK.CLIENT_ADDRESS is not None and client_port > 0:
			client_address = [NETWORK.CLIENT_ADDRESS, client_port]
		try:
			self._connection = Connection(self.process_async_packet, server_address, client_address)
		except NetworkException as e:
			raise RuntimeError(e)

	@property
	def is_connected(self):
		return self._connection.is_connected

	def connect(self):
		"""
		@throws: NetworkError
		"""
		try:
			self._connection.connect()

			# wait for session id
			packet = self._connection.receive_packet(packets.server.cmd_session)

			self.sid = packet[1].sid
			self.capabilities = packet[1].capabilities
			self._mode = ClientMode.Server
			self.log.debug("[CONNECT] done (session=%s)" % (self.sid))
			self._set_client_language()
		except NetworkException as e:
			self.disconnect()
			raise e

	def disconnect(self):
		self._mode = None
		self._connection.disconnect()

	def ping(self):
		"""calls _connection.ping until all packets are received"""
		if self.is_connected:
			try:
				while self._connection.ping(): # ping receives packets
					pass
			except NetworkException as e:
				self._handle_exception(e)

	def network_data_changed(self):
		"""Call in case constants like client address or client port changed.

		@throws RuntimeError in case of invalid data or an NetworkException forwarded from connect
		"""
		if self.is_connected:
			self.disconnect()
		self._setup_client()

	def _set_client_language(self):
		lang = LANGUAGENAMES.get_by_value(horizons.globals.fife.get_uh_setting("Language"))
		if lang:
			return self.set_props({'lang': lang})

	def send_packet(self, packet, *args, **kwargs):
		"""
		"""
		if self._mode is ClientMode.Game:
			packet = packets.client.game_data(packet)
		packet.sid = self.sid

		self._connection.send_packet(packet)

	# Game related

	@property
	def is_joined(self):
		return self._game is not None

	def game2mpgame(self, game):
		return MPGame(game, self)

	def get_game(self):
		game = self._game
		if game is None:
			return None
		return self.game2mpgame(game)

	def set_props(self, props):
		try:
			self.log.debug("[SETPROPS]")
			self._assert_connection()
			self.send_packet(packets.client.cmd_sessionprops(props))
			self._connection.receive_packet(packets.cmd_ok)
		except NetworkException as e:
			self._handle_exception(e)
			return False
		return True

	def creategame(self, mapname, maxplayers, gamename, maphash="", password=""):
		self.log.debug("[CREATEGAME] %s(h=%s), %s, %s, %s", mapname, maphash, maxplayers, gamename)
		try:
			self._assert_connection()
			self.log.debug("[CREATE] mapname=%s maxplayers=%d" % (mapname, maxplayers))
			self.send_packet(packets.client.cmd_creategame(
				clientver=self._client_data.version,
				clientid=self._client_data.id,
				playername=self._client_data.name,
				playercolor=self._client_data.color,
				gamename=gamename,
				mapname=mapname,
				maxplayers=maxplayers,
				maphash=maphash,
				password=password
			))
			packet = self._connection.receive_packet(packets.server.data_gamestate)
			game = self._game = packet[1].game
		except NetworkException as e:
			self._handle_exception(e)
			return None
		return self.game2mpgame(game)

	def joingame(self, uuid, password="", fetch=False):
		"""Join a game with a certain uuid"""
		i = 2
		try:
			while i < 10: # FIXME: try 10 different names and colors
				try:
					self._joingame(uuid, password, fetch)
					return True
				except CommandError as e:
					self.log.debug("NetworkInterface: failed to join")
					if 'name' in e.message:
						self.change_name(self._client_data.name + unicode(i), save=False )
					elif 'color' in e.message:
						self.change_color(self._client_data.color + i, save=False)
					else:
						raise
				i += 1
			self._joingame(uuid, password, fetch)
		except NetworkException as e:
			self._handle_exception(e)
		return False

	def _joingame(self, uuid, password="", fetch=False):
		self._assert_connection()
		self.log.debug("[JOIN] %s" % (uuid))
		self.send_packet(packets.client.cmd_joingame(
			uuid=uuid,
			clientver=self._client_data.version,
			clientid=self._client_data.id,
			playername=self._client_data.name,
			playercolor=self._client_data.color,
			password=password,
			fetch=fetch
		))
		packet = self._connection.receive_packet(packets.server.data_gamestate)
		self._game = packet[1].game
		return self._game

	def leavegame(self):
		try:
			self._assert_connection()
			self._assert_lobby()
			self.log.debug("[LEAVE]")
			self.send_packet(packets.client.cmd_leavegame())
			self._connection.receive_packet(packets.cmd_ok)
			self._game = None
		except NetworkException as e:
			fatal = self._handle_exception(e)
			if fatal:
				return False
		return True

	def chat(self, message):
		try:
			self._assert_connection()
			self._assert_lobby()
			self.log.debug("[CHAT] %s" % (message))
			self.send_packet(packets.client.cmd_chatmsg(message))
		except NetworkException as e:
			self._handle_exception(e)
			return False
		return True

	def get_active_games(self):
		"""Returns a list of active games or None on fatal error"""
		ret_mp_games = []
		try:
			self._assert_connection()
			self.log.debug("[LIST]")
			version = self._client_data.version
			self.send_packet(packets.client.cmd_listgames(version))
			packet = self._connection.receive_packet(packets.server.data_gameslist)
			games = packet[1].games
		except NetworkException as e:
			fatal = self._handle_exception(e)
			return [] if not fatal else None
		for game in games:
			ret_mp_games.append(self.game2mpgame(game))
			self.log.debug("NetworkInterface: found active game %s", game.mapname)
		return ret_mp_games

	def toggle_ready(self):
		self.log.debug("[TOGGLEREADY]")
		self.send_packet(packets.client.cmd_toggleready())

	def kick(self, player_sid):
		self.log.debug("[KICK]")
		self.send_packet(packets.client.cmd_kickplayer(player_sid))


	# Client

	def get_client_name(self):
		return self._client_data.name

	def get_client_color(self):
		return self._client_data.color

	def get_clientversion(self):
		return self._client_data.version

	def change_name(self, new_name, save=True):
		if save:
			horizons.globals.fife.set_uh_setting("Nickname", new_name)
			horizons.globals.fife.save_settings()

		try:
			if self._client_data.name == new_name:
				return True
			self.log.debug("[CHANGENAME] %s" % (new_name))
			if self._mode is None or self._game is None:
				self._client_data.name = new_name
				return
			self.send_packet(packets.client.cmd_changename(new_name))
		except NetworkException as e:
			self._handle_exception(e)

	def _on_change_name(self, game, plold, plnew, myself):
		self.log.debug("[ONCHANGENAME] %s -> %s" % (plold.name, plnew.name))
		if myself:
			self._client_data.name = plnew.name

	def change_color(self, new_color, save=True):
		new_color %= len(set(Color))

		if save:
			horizons.globals.fife.set_uh_setting("ColorID", new_color)
			horizons.globals.fife.save_settings()

		try:
			if self._client_data.color == new_color:
				return
			self.log.debug("[CHANGECOLOR] %s" % (new_color))
			if self._mode is None or self._game is None:
				self._client_data.color = new_color
				return
			self.send_packet(packets.client.cmd_changecolor(new_color))
		except NetworkException as e:
			self._handle_exception(e)

	def _on_change_color(self, game, plold, plnew, myself):
		self.log.debug("[ONCHANGECOLOR] %s: %s -> %s" % (plnew.name, plold.color, plnew.color))
		if myself:
			self._client_data.color = plnew.color

	# Helper functions, event callbacks, packet handling

	def receive_all(self):
		"""
		Returns list of all packets, that have arrived until now (since the last call)
		@return: list of packets
		"""
		try:
			while self._connection.ping(): # ping receives packets
				pass
		except NetworkException as e:
			self.log.debug("ping in receive_all failed: "+str(e))
			self._handle_exception(e)
			raise CommandError(e)
		ret_list = self.received_packets
		self.received_packets = []
		return ret_list

	def _handle_exception(self, e):
		try:
			raise e
		except FatalError as e:
			self.broadcast("error", e, fatal=True)
			self.disconnect()
			return True
		except NetworkException as e:
			self.broadcast("error", e, fatal=False)
			return False

	def process_async_packet(self, packet):
		"""
		return True if packet was processed successfully
		return False if packet should be queue
		"""
		if packet is None:
			return True
		if isinstance(packet[1], packets.server.cmd_chatmsg):
			# ignore packet if we are not a game lobby
			if self._game is None:
				return True
			self.broadcast("lobbygame_chat", self._game, packet[1].playername, packet[1].chatmsg)
		elif isinstance(packet[1], packets.server.data_gamestate):
			# ignore packet if we are not a game lobby
			if self._game is None:
				return True
			self.broadcast("lobbygame_state", self._game, packet[1].game)

			oldplayers = list(self._game.players)
			self._game = packet[1].game

			# calculate changeset
			for pnew in self._game.players:
				found = None
				for pold in oldplayers:
					if pnew.sid == pold.sid:
						found = pold
						myself = (pnew.sid == self.sid)
						if pnew.name != pold.name:
							self.broadcast("lobbygame_changename", self._game, pold, pnew, myself)
						if pnew.color != pold.color:
							self.broadcast("lobbygame_changecolor", self._game, pold, pnew, myself)
						if pnew.ready != pold.ready:
							self.broadcast("lobbygame_toggleready", self._game, pold, pnew, myself)
						break
				if found is None:
					self.broadcast("lobbygame_join", self._game, pnew)
				else:
					oldplayers.remove(found)
			for pold in oldplayers:
				self.broadcast("lobbygame_leave", self._game, pold)
			return True
		elif isinstance(packet[1], packets.server.cmd_preparegame):
			# ignore packet if we are not a game lobby
			if self._game is None:
				return True
			self._on_game_prepare()
		elif isinstance(packet[1], packets.server.cmd_startgame):
			# ignore packet if we are not a game lobby
			if self._game is None:
				return True
			self._on_game_start()
		elif isinstance(packet[1], packets.client.game_data):
			self.log.debug("[GAMEDATA] from %s" % (packet[0].address))
			self._on_game_data(packet[1].data)
		elif isinstance(packet[1], packets.server.cmd_kickplayer):
			player = packet[1].player
			game = self._game
			myself = (player.sid == self.sid)
			if myself:
				# this will destroy self._game
				self._assert_connection()
				self._assert_lobby()
				self.log.debug("[LEAVE]")
				self._game = None
			self.broadcast("lobbygame_kick", game, player, myself)

		return False

	def _on_game_prepare(self):
		self.log.debug("[GAMEPREPARE]")
		self._game.state = Game.State.Prepare
		self.broadcast("lobbygame_starts", self._game)
		self.send_packet(packets.client.cmd_preparedgame())

	def _on_game_start(self):
		self.log.debug("[GAMESTART]")
		self._game.state = Game.State.Running
		self._mode = ClientMode.Game
		self.broadcast("game_starts", self._game)

	def _on_lobbygame_starts(self, game):
		game = self.get_game()
		self.broadcast("game_prepare", game)

	def _on_game_data(self, data):
		self.received_packets.append(data)

	def _assert_connection(self):
		if self._mode is None:
			raise network.NotConnected()
		if self._mode is not ClientMode.Server:
			raise network.NotInServerMode("We are not in server mode")

	def _assert_lobby(self):
		if self._game is None:
			raise network.NotInGameLobby("We are not in a game lobby")


class MPGame(object):
	def __init__(self, game, netif):
		self.uuid       = game.uuid
		self.creator    = game.creator
		self.map_name    = game.mapname
		self.map_hash    = game.maphash
		self.player_limit = game.maxplayers
		self.player_count = game.playercnt
		self.players    = game.players
		self.version    = game.clientversion
		self.name       = game.name
		self.password   = game.password
		self.netif      = netif

	@property
	def is_savegame(self):
		return bool(self.map_hash)

	@property
	def has_password(self):
		return self.password

	def get_player_list(self):
		ret_players = []
		for index, player in enumerate(self.players, start=1):
			# TODO: add support for selecting difficulty levels to the GUI
			status = _('Ready') if player.ready else _('Not Ready')
			ret_players.append({
				'id':         index,
				'sid':        player.sid,
				'name':       player.name,
				'color':      Color[player.color],
				'clientid':   player.clientid,
				'local':      self.netif.get_client_name() == player.name,
				'ai':         False,
				'difficulty': DifficultySettings.DEFAULT_LEVEL,
				'status':     status
				})
		return ret_players

	def __str__(self):
		return "%s (%d/%d)" % (self.map_name, self.player_count, self.player_limit)

########NEW FILE########
__FILENAME__ = client
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import uuid

from horizons.network import NetworkException, SoftNetworkException
from horizons.network.packets import packet, SafeUnpickler

class cmd_creategame(packet):
	clientversion = None
	clientid      = None
	playername    = None
	playercolor   = None
	gamename      = u"Unnamed Game"
	mapname       = None
	maxplayers    = None
	maphash       = ""
	password      = ""

	def __init__(self, clientver, clientid, playername, playercolor,
			gamename, mapname, maxplayers, maphash="", password=""):
		self.clientversion = clientver
		self.clientid      = clientid
		self.playername    = playername
		self.playercolor   = playercolor
		self.name          = gamename
		self.mapname       = mapname
		self.maxplayers    = maxplayers
		self.maphash       = maphash
		self.password      = password

	@staticmethod
	def validate(pkt, protocol):
		if not isinstance(pkt.clientversion, unicode):
			raise NetworkException("Invalid datatype: clientversion")
		if not pkt.clientversion:
			raise SoftNetworkException("Invalid client version")

		if protocol == 0:
			pkt.clientid = uuid.uuid4().hex
		if not isinstance(pkt.clientid, str):
			raise NetworkException("Invalid datatype: clientid")
		if len(pkt.clientid) != 32:
			raise SoftNetworkException("Invalid unique player ID")

		if not isinstance(pkt.playername, unicode):
			raise NetworkException("Invalid datatype: playername")
		if not pkt.playername:
			raise SoftNetworkException("Your player name cannot be empty")

		if protocol == 0:
			# hardcoded playercolor
			pkt.playercolor = 1
		else:
			if not isinstance(pkt.playercolor, int):
				raise NetworkException("Invalid datatype: playercolor")
			if pkt.playercolor < 1:
				raise SoftNetworkException("Your color is invalid")

		if not isinstance(pkt.name, unicode):
			raise NetworkException("Invalid datatype: name")
		if not pkt.name:
			pkt.name = u"Unnamed Game"

		if not isinstance(pkt.mapname, unicode):
			raise NetworkException("Invalid datatype: mapname")
		if not pkt.mapname:
			raise SoftNetworkException("You can't run a game with an empty mapname")

		if not isinstance(pkt.maxplayers, int):
			raise NetworkException("Invalid datatype: maxplayers")

		if protocol == 0:
			if pkt.load is None:
				pkt.maphash = ""
			elif isinstance(pkt.load, str):
				pkt.maphash = pkt.load
		if not isinstance(pkt.maphash, str):
			raise NetworkException("Invalid datatype: maphash")

		if not isinstance(pkt.password, str):
			raise NetworkException("Invalid datatype: password")

SafeUnpickler.add('client', cmd_creategame)

#-------------------------------------------------------------------------------

class cmd_listgames(packet):
	clientversion = 0
	mapname       = None
	maxplayers    = None

	def __init__(self, clientver, mapname=None, maxplayers=None):
		self.clientversion = clientver
		self.mapname       = mapname
		self.maxplayers    = maxplayers

	@staticmethod
	def validate(pkt, protocol):
		if not isinstance(pkt.clientversion, (int, unicode)):
			raise NetworkException("Invalid datatype: clientversion")
		if pkt.mapname is not None and not isinstance(pkt.mapname, unicode):
			raise NetworkException("Invalid datatype: mapname")
		if pkt.maxplayers is not None and not isinstance(pkt.maxplayers, int):
			raise NetworkException("Invalid datatype: maxplayers")

SafeUnpickler.add('client', cmd_listgames)

#-------------------------------------------------------------------------------

class cmd_joingame(packet):
	uuid          = None
	clientid      = None
	clientversion = None
	playername    = None
	playercolor   = None
	password      = ""
	fetch         = False

	def __init__(self, uuid, clientver, clientid, playername, playercolor, password="", fetch=False):
		self.uuid          = uuid
		self.clientversion = clientver
		self.clientid      = clientid
		self.playername    = playername
		self.playercolor   = playercolor
		self.password      = password
		self.fetch         = fetch

	@staticmethod
	def validate(pkt, protocol):
		if not isinstance(pkt.uuid, str):
			raise NetworkException("Invalid datatype: uuid")
		if len(pkt.uuid) != 32:
			raise SoftNetworkException("Invalid game UUID")

		if not isinstance(pkt.clientversion, unicode):
			raise NetworkException("Invalid datatype: clientversion")
		if not pkt.clientversion:
			raise SoftNetworkException("Invalid client version")

		if protocol == 0:
			pkt.clientid = uuid.uuid4().hex
		if not isinstance(pkt.clientid, str):
			raise NetworkException("Invalid datatype: clientid")
		if len(pkt.clientid) != 32:
			raise SoftNetworkException("Invalid unique player ID")

		if not isinstance(pkt.playername, unicode):
			raise NetworkException("Invalid datatype: playername")
		if not pkt.playername:
			raise SoftNetworkException("Your player name cannot be empty")

		if protocol == 0:
			# assign playercolor in packet handler
			pkt.playercolor = None
		else:
			if not isinstance(pkt.playercolor, int):
				raise NetworkException("Invalid datatype: playercolor")
			if pkt.playercolor < 1:
				raise SoftNetworkException("Your color is invalid")

		if not isinstance(pkt.password, str):
			raise NetworkException("Invalid datatype: password")

		if not isinstance(pkt.fetch, bool):
			raise NetworkException("Invalid datatype: fetch")

SafeUnpickler.add('client', cmd_joingame)

#-------------------------------------------------------------------------------

class cmd_leavegame(packet):
	def __init__(self):
		"""ctor"""

SafeUnpickler.add('client', cmd_leavegame)

#-------------------------------------------------------------------------------

class cmd_chatmsg(packet):
	chatmsg = None

	def __init__(self, msg):
		self.chatmsg = msg

	@staticmethod
	def validate(pkt, protocol):
		if not isinstance(pkt.chatmsg, unicode):
			raise NetworkException("Invalid datatype: chatmsg")
		if not pkt.chatmsg:
			raise SoftNetworkException("Chat message cannot be empty")

SafeUnpickler.add('client', cmd_chatmsg)

#-------------------------------------------------------------------------------

class cmd_changename(packet):
	playername = None

	def __init__(self, playername):
		self.playername = playername

	@staticmethod
	def validate(pkt, protocol):
		if not isinstance(pkt.playername, unicode):
			raise NetworkException("Invalid datatype: playername")
		if not pkt.playername:
			raise SoftNetworkException("You must have a non empty name")

SafeUnpickler.add('client', cmd_changename)

#-------------------------------------------------------------------------------

class cmd_changecolor(packet):
	playercolor = None

	def __init__(self, playercolor):
		self.playercolor = playercolor

	@staticmethod
	def validate(pkt, protocol):
		if not isinstance(pkt.playercolor, int):
			raise NetworkException("Invalid datatype: playercolor")
		if pkt.playercolor < 1:
			raise SoftNetworkException("Your color is invalid")

SafeUnpickler.add('client', cmd_changecolor)

#-------------------------------------------------------------------------------

class cmd_preparedgame(packet):
	def __init__(self):
		"""ctor"""

SafeUnpickler.add('client', cmd_preparedgame)

#-------------------------------------------------------------------------------

class game_data(packet):
	def __init__(self, data):
		self.data = data

# origin is 'server' as clients will send AND receive them
SafeUnpickler.add('server', game_data)

#-------------------------------------------------------------------------------

class cmd_toggleready(packet):
	def __init__(self):
		"""ctor"""

SafeUnpickler.add('client', cmd_toggleready)

#-------------------------------------------------------------------------------

class cmd_kickplayer(packet):
	def __init__(self, kicksid):
		# NOTE: self.sid is used for session mgmt
		self.kicksid = kicksid

	@staticmethod
	def validate(pkt, protocol):
		if not isinstance(pkt.kicksid, str):
			raise NetworkException("Invalid datatype: player sid")
		if len(pkt.kicksid) != 32:
			raise SoftNetworkException("Invalid player sid")

SafeUnpickler.add('client', cmd_kickplayer)

#-------------------------------------------------------------------------------

class cmd_sessionprops(packet):
	def __init__(self, props):
		if 'lang' in props:
			self.lang = props['lang']

	@staticmethod
	def validate(pkt, protocol):
		if hasattr(pkt, 'lang'):
			if not isinstance(pkt.lang, str):
				raise NetworkException("Invalid datatype: lang")
			if not pkt.lang:
				raise SoftNetworkException("Invalid language property")

SafeUnpickler.add('client', cmd_sessionprops)

#-------------------------------------------------------------------------------

#TODO
class cmd_mapdata(packet):
	def __init__(self, data):
		self.data = data

	@staticmethod
	def validate(pkt, protocol):
		if not isinstance(pkt.data, str):
			raise NetworkException("Invalid datatype: data")

SafeUnpickler.add('client', cmd_mapdata)

########NEW FILE########
__FILENAME__ = server
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.network.packets import packet, SafeUnpickler

class cmd_session(packet):
	def __init__(self, sid, capabilities):
		self.sid = sid
		self.capabilities = capabilities

SafeUnpickler.add('server', cmd_session)

#-------------------------------------------------------------------------------

class data_gameslist(packet):
	def __init__(self):
		self.games = []

	def addgame(self, game):
		newgame = game.make_public_copy()
		self.games.append(newgame)

SafeUnpickler.add('server', data_gameslist)

#-------------------------------------------------------------------------------

class data_gamestate(packet):
	def __init__(self, game):
		self.game = game

SafeUnpickler.add('server', data_gamestate)

#-------------------------------------------------------------------------------

class cmd_chatmsg(packet):
	def __init__(self, playername, msg):
		self.playername = playername
		self.chatmsg    = msg

SafeUnpickler.add('server', cmd_chatmsg)

#-------------------------------------------------------------------------------

class cmd_preparegame(packet):
	def __init__(self):
		"""prepare game packet"""

SafeUnpickler.add('server', cmd_preparegame)

#-------------------------------------------------------------------------------

class cmd_startgame(packet):
	def __init__(self):
		"""start game packet"""

SafeUnpickler.add('server', cmd_startgame)

#-------------------------------------------------------------------------------

class cmd_kickplayer(packet):
	def __init__(self, player):
		self.player = player

SafeUnpickler.add('server', cmd_kickplayer)

########NEW FILE########
__FILENAME__ = server
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import gettext
import logging
import uuid

from horizons import network
from horizons.i18n import find_available_languages
from horizons.network import packets, enet
from horizons.network.common import Player, Game, ErrorType


if not enet:
	raise Exception("Could not find enet module.")


MAX_PEERS = 4095
CONNECTION_TIMEOUT = 500
# protocols used by uh versions:
# 0 ... 2012.1
# 1 ... >2012.1
PROTOCOLS = [0, 1]

logging.basicConfig(format = '[%(asctime)-15s] [%(levelname)s] %(message)s',
		level = logging.DEBUG)

class Server(object):
	def __init__(self, hostname, port, statistic_file=None):
		packets.SafeUnpickler.set_mode(client=False)
		self.host     = None
		self.hostname = hostname
		self.port     = port
		self.statistic = {
			'file':      statistic_file,
			'timestamp': 0,
			'interval':  1 * 60 * 1000,
		}
		self.capabilities = {
			'minplayers'    : 2,
			'maxplayers'    : 8,
			# NOTE: this defines the global packet size maximum.
			# there's still a per packet maximum defined in the
			# individual packet classes
			'maxpacketsize' : 2 * 1024 * 1024,
		}
		self.callbacks = {
			'onconnect':     [ self.onconnect ],
			'ondisconnect':  [ self.ondisconnect ],
			'onreceive':     [ self.onreceive ],
			packets.cmd_error:                 [ self.onerror ],
			packets.cmd_fatalerror:            [ self.onfatalerror ],
			packets.client.cmd_sessionprops:   [ self.onsessionprops ],
			packets.client.cmd_creategame:     [ self.oncreategame ],
			packets.client.cmd_listgames:      [ self.onlistgames ],
			packets.client.cmd_joingame:       [ self.onjoingame ],
			packets.client.cmd_leavegame:      [ self.onleavegame ],
			packets.client.cmd_chatmsg:        [ self.onchat ],
			packets.client.cmd_changename:     [ self.onchangename ],
			packets.client.cmd_changecolor:    [ self.onchangecolor ],
			packets.client.cmd_preparedgame:   [ self.onpreparedgame ],
			packets.client.cmd_toggleready:    [ self.ontoggleready ],
			packets.client.cmd_kickplayer:     [ self.onkick ],
			#TODO packets.client.cmd_fetch_game:     [ self.onfetchgame ],
			#TODO packets.client.savegame_data:      [ self.onsavegamedata ],
			'preparegame':   [ self.preparegame ],
			'startgame':     [ self.startgame ],
			'leavegame':     [ self.leavegame ],
			'deletegame':    [ self.deletegame ],
			'terminategame': [ self.terminategame ],
			'gamedata':      [ self.gamedata ],
		}
		self.games   = [] # list of games
		self.players = {} # sessionid => Player() dict
		self.i18n    = {} # lang => gettext dict
		self.check_urandom()
		self.setup_i18n()


	def check_urandom(self):
		try:
			import os
			os.urandom(1)
		except NotImplementedError:
			import random
			import time
			random.seed(uuid.getnode() + int(time.time() * 1e3))
			logging.warning("[INIT] Your system doesn't support /dev/urandom")


	# we use the following custom prefixes/functions to distinguish
	# between server side messages (domain=unknown-horizons-server) and
	# client side messages (domain=unknown-horizons):
	#
	# S_(player,  ...)    ... same as _(...)
	# SN_(player, ...)    ... same as N_(...)
	# __(...)             ... noop for extracting the strings
	def gettext(self, player, message):
		return player.gettext.ugettext(message)

	def ngettext(self, player, msgid1, msgid2, n):
		return player.gettext.ungettext(msgid1, msgid2, n)

	def setup_i18n(self):
		domain = 'unknown-horizons-server'
		for lang, dir in find_available_languages(domain).items():
			if len(dir) <= 0:
				continue
			try:
				self.i18n[lang] = gettext.translation(domain, dir, [lang])
			except IOError:
				pass
		import __builtin__
		__builtin__.__dict__['S_']   = self.gettext
		__builtin__.__dict__['SN_']  = self.ngettext
		__builtin__.__dict__['__']   = lambda x : x


	# uuid4() uses /dev/urandom when possible
	def generate_session_id(self):
		return uuid.uuid4().hex


	def register_callback(self, type, callback, prepend=False):
		if type in self.callbacks:
			if prepend:
				self.callbacks[type].insert(0, callback)
			else:
				self.callbacks[type].append(callback)
		else:
			raise TypeError("Unsupported type")


	def call_callbacks(self, type, *args):
		if type not in self.callbacks:
			return
		ret = True
		for callback in self.callbacks[type]:
			tmp = callback(*args)
			if tmp is None:
				tmp = True
			ret &= tmp
		return ret


	def run(self):
		logging.info("Starting up server on %s:%d" % (self.hostname, self.port))
		try:
			self.host = enet.Host(enet.Address(self.hostname, self.port), MAX_PEERS, 0, 0, 0)
		except (IOError, MemoryError) as e:
			# these exceptions do not provide any information.
			raise network.NetworkException("Unable to create network structure: %s" % (e))

		logging.debug("Entering the main loop...")
		while True:
			if self.statistic['file'] is not None:
				if self.statistic['timestamp'] <= 0:
					self.print_statistic(self.statistic['file'])
					self.statistic['timestamp'] = self.statistic['interval']
				else:
					self.statistic['timestamp'] -= CONNECTION_TIMEOUT

			event = self.host.service(CONNECTION_TIMEOUT)
			if event.type == enet.EVENT_TYPE_NONE:
				continue
			elif event.type == enet.EVENT_TYPE_CONNECT:
				self.call_callbacks("onconnect", event)
			elif event.type == enet.EVENT_TYPE_DISCONNECT:
				self.call_callbacks("ondisconnect", event)
			elif event.type == enet.EVENT_TYPE_RECEIVE:
				self.call_callbacks("onreceive", event)
			else:
				logging.warning("Invalid packet (%u)" % (event.type))


	def send(self, peer, packet, channelid=0):
		if self.host is None:
			raise network.NotConnected("Server is not running")

		self.sendraw(peer, packet.serialize(), channelid)

	def sendraw(self, peer, data, channelid=0):
		if self.host is None:
			raise network.NotConnected("Server is not running")

		packet = enet.Packet(data, enet.PACKET_FLAG_RELIABLE)
		peer.send(channelid, packet)
		self.host.flush()


	def disconnect(self, peer, later=True):
		logging.debug("[DISCONNECT] Disconnecting client %s" % (peer.address))
		try:
			if later:
				peer.disconnect_later()
			else:
				peer.disconnect()
		except IOError:
			peer.reset()


	def error(self, player, message, _type=ErrorType.NotSet):
		self._error(player.peer, S_(player, message), _type)

	def _error(self, peer, message, _type=ErrorType.NotSet):
		self.send(peer, packets.cmd_error(message, _type))

	def fatalerror(self, player, message, later=True):
		self._fatalerror(player.peer, S_(player, message), later)

	def _fatalerror(self, peer, message, later=True):
		self.send(peer, packets.cmd_fatalerror(message))
		self.disconnect(peer, later)


	def onconnect(self, event):
		peer = event.peer
		# disable that check as peer.data may be uninitialized which segfaults then
		#if peer.data in self.players:
		#	logging.warning("[CONNECT] Already known player %s!" % (peer.address))
		#	self._fatalerror(event.peer, "You can't connect more than once")
		#	return
		player = Player(event.peer, self.generate_session_id(), event.data)
		logging.debug("[CONNECT] New Client: %s" % (player))

		# store session id inside enet.peer.data
		# NOTE: ALWAYS initialize peer.data
		event.peer.data = player.sid

		if not player.protocol in PROTOCOLS:
			logging.warning("[CONNECT] %s runs old or unsupported protocol" % (player))
			self.fatalerror(player, __("Old or unsupported multiplayer protocol. Please check your game version"))
			return

		# NOTE: copying bytes or int doesn't work here
		self.players[player.sid] = player
		self.send(event.peer, packets.server.cmd_session(player.sid, self.capabilities))


	def ondisconnect(self, event):
		peer = event.peer
		# check need for early disconnects (e.g. old protocol)
		if peer.data not in self.players:
			return
		player = self.players[peer.data]
		logging.debug("[DISCONNECT] %s disconnected" % (player))
		if player.game is not None:
			self.call_callbacks("leavegame", player)
		del self.players[peer.data]


	def onreceive(self, event):
		peer = event.peer
		#logging.debug("[RECEIVE] Got data from %s" % (peer.address))
		# check player is known by server
		if peer.data not in self.players:
			logging.warning("[RECEIVE] Packet from unknown player %s!" % (peer.address))
			self._fatalerror(event.peer, "I don't know you")
			return

		player = self.players[peer.data]

		# check packet size
		if len(event.packet.data) > self.capabilities['maxpacketsize']:
			logging.warning("[RECEIVE] Global packet size exceeded from %s: size=%d" % (peer.address, len(event.packet.data)))
			self.fatalerror(player, __("You've exceeded the global packet size.") + " " +
			                        __("This should never happen. "
			                           "Please contact us or file a bug report."))
			return

		# shortpath if game is running
		if player.game is not None and player.game.state is Game.State.Running:
			self.call_callbacks('gamedata', player, event.packet.data)
			return

		packet = None
		try:
			packet = packets.unserialize(event.packet.data, True, player.protocol)
		except network.SoftNetworkException as e:
			self.error(player, e.message)
			return
		except network.PacketTooLarge as e:
			logging.warning("[RECEIVE] Per packet size exceeded from %s: %s" % (player, e))
			self.fatalerror(player, __("You've exceeded the per packet size.") + " " +
			                        __("This should never happen. "
			                           "Please contact us or file a bug report.") +
			                        " " + str(e))
			return
		except Exception as e:
			logging.warning("[RECEIVE] Unknown or malformed packet from %s: %s!" % (player, e))
			self.fatalerror(player, __("Unknown or malformed packet. Please check your game version"))
			return

		# session id check
		if packet.sid != player.sid:
			logging.warning("[RECEIVE] Invalid session id for player %s (%s vs %s)!" % (peer.address, packet.sid, player.sid))
			self.fatalerror(player, __("Invalid/Unknown session")) # this will trigger ondisconnect() for cleanup
			return

		if packet.__class__ not in self.callbacks:
			logging.warning("[RECEIVE] Unhandled network packet from %s - Ignoring!" % (peer.address))
			return
		self.call_callbacks(packet.__class__, player, packet)


	def onerror(self, player, packet):
		# we shouldn't receive any errors from client
		# so ignore them all
		logging.debug("[ERROR] Client Message: %s" % (packet.errorstr))


	def onfatalerror(self, player, packet):
		# we shouldn't receive any fatala errors from client
		# so just disconnect them
		logging.debug("[FATAL] Client Message: %s" % (packet.errorstr))
		self.disconnect(player.peer)


	def onsessionprops(self, player, packet):
		logging.debug("[PROPS] %s" % (player))
		if hasattr(packet, 'lang'):
			if packet.lang in self.i18n:
				player.gettext = self.i18n[packet.lang]
		self.send(player.peer, packets.cmd_ok())

	def oncreategame(self, player, packet):
		if packet.maxplayers < self.capabilities['minplayers']:
			raise network.SoftNetworkException("You can't run a game with less than %d players" % (self.capabilities['minplayers']))
		if packet.maxplayers > self.capabilities['maxplayers']:
			raise network.SoftNetworkException("You can't run a game with more than %d players" % (self.capabilities['maxplayers']))
		game = Game(packet, player)
		logging.debug("[CREATE] [%s] %s created %s" % (game.uuid, player, game))
		self.games.append(game)
		self.send(player.peer, packets.server.data_gamestate(game))

	def deletegame(self, game):
		logging.debug("[REMOVE] [%s] %s removed" % (game.uuid, game))
		game.clear()
		self.games.remove(game)

	def onlistgames(self, player, packet):
		logging.debug("[LIST]")
		gameslist = packets.server.data_gameslist()
		for _game in self.games:
			if _game.creator.protocol != player.protocol:
				continue
			if not _game.is_open():
				continue
			if _game.is_full():
				continue
			if packet.clientversion != -1 and packet.clientversion != _game.creator.version:
				continue
			if packet.mapname and packet.mapname != _game.mapname:
				continue
			if packet.maxplayers and packet.maxplayers != _game.maxplayers:
				continue
			gameslist.addgame(_game)
		self.send(player.peer, gameslist)


	def __find_game_from_uuid(self, packet):
		game = None
		for _game in self.games:
			if packet.clientversion != _game.creator.version:
				continue
			if packet.uuid != _game.uuid:
				continue
			game = _game
			break
		return game


	def onjoingame(self, player, packet):
		if player.game is not None:
			self.error(player, __("You can't join a game while in another game"))
			return

		game = self.__find_game_from_uuid(packet)
		if game is None:
			self.error(player, __("Unknown game or game is running a different version"))
			return
		if not game.is_open():
			self.error(player, __("Game has already started. No more joining"))
			return
		if game.is_full():
			self.error(player, __("Game is full"))
			return
		if game.has_password() and packet.password != game.password:
			self.error(player, __("Wrong password"))
			return

		# protocol=0
		# assign free color
		if packet.playercolor is None:
			colors = []
			for _player in game.players:
				colors.append(_player.color)
			for color in range(1, len(colors) + 2):
				if color not in colors:
					break
			packet.playercolor = color

		# make sure player names, colors and clientids are unique
		for _player in game.players:
			if _player.name == packet.playername:
				self.error(player, __("There's already a player with your name inside this game.") + " " +
				                   __("Please change your name."))
				return
			if _player.color == packet.playercolor:
				self.error(player, __("There's already a player with your color inside this game.") + " " +
				                   __("Please change your color."))
				return
			if _player.clientid == packet.clientid:
				self.error(player, __("There's already a player with your unique player ID inside this game. "
				                      "This should never occur."))
				return

		logging.debug("[JOIN] [%s] %s joined %s" % (game.uuid, player, game))
		game.add_player(player, packet)
		for _player in game.players:
			self.send(_player.peer, packets.server.data_gamestate(game))

		if player.protocol == 0:
			if game.is_full():
				self.call_callbacks("preparegame", game)


	def onleavegame(self, player, packet):
		if player.game is None:
			self.error(player, __("You are not inside a game"))
			return
		self.call_callbacks("leavegame", player)
		self.send(player.peer, packets.cmd_ok())


	def leavegame(self, player):
		game = player.game
		# leaving the game if game has already started is a hard error
		if not game.is_open():
			self.call_callbacks('terminategame', game, player)
			return
		logging.debug("[LEAVE] [%s] %s left %s" % (game.uuid, player, game))
		game.remove_player(player)
		if game.is_empty():
			self.call_callbacks('deletegame', game)
			return
		for _player in game.players:
			self.send(_player.peer, packets.server.data_gamestate(game))
		# the creator leaving the game is a hard error too
		if player.protocol >= 1 and player == game.creator:
			self.call_callbacks('terminategame', game, player)
			return


	def terminategame(self, game, player=None):
		logging.debug("[TERMINATE] [%s] (by %s)" % (game.uuid, player if player is not None else None))
		if game.creator.protocol >= 1 and game.is_open():
			# NOTE: works with protocol >= 1
			for _player in game.players:
				self.error(_player, __("The game has been terminated. The creator has left the game."), ErrorType.TerminateGame)
		else:
			for _player in game.players:
				if _player.peer.state == enet.PEER_STATE_CONNECTED:
					self.fatalerror(_player,
						__("One player has terminated their game. "
						"For technical reasons, this currently means the game cannot continue. "
						"We are very sorry about that."))
		self.call_callbacks('deletegame', game)


	def preparegame(self, game):
		logging.debug("[PREPARE] [%s] Players: %s" % (game.uuid, [unicode(i) for i in game.players]))
		game.state = Game.State.Prepare
		for _player in game.players:
			self.send(_player.peer, packets.server.cmd_preparegame())


	def startgame(self, game):
		logging.debug("[START] [%s] Players: %s" % (game.uuid, [unicode(i) for i in game.players]))
		game.state = Game.State.Running
		for _player in game.players:
			self.send(_player.peer, packets.server.cmd_startgame())


	def onchat(self, player, packet):
		if player.game is None:
			# just ignore if not inside a game
			self.send(player.peer, packets.cmd_ok())
			return
		game = player.game
		# don't send packets to already started games
		if not game.is_open():
			return
		logging.debug("[CHAT] [%s] %s: %s" % (game.uuid, player, packet.chatmsg))
		for _player in game.players:
			self.send(_player.peer, packets.server.cmd_chatmsg(player.name, packet.chatmsg))


	def onchangename(self, player, packet):
		# NOTE: that event _only_ happens inside a lobby
		if player.game is None:
			# just ignore if not inside a game
			self.send(player.peer, packets.cmd_ok())
			return
		# ignore change to existing name
		if player.name == packet.playername:
			return
		game = player.game
		# don't send packets to already started games
		if not game.is_open():
			return

		# make sure player names are unique
		for _player in game.players:
			if _player.name == packet.playername:
				self.error(player, __("There's already a player with your name inside this game.") + " " +
				                   __("Unable to change your name."))
				return

		# ACK the change
		logging.debug("[CHANGENAME] [%s] %s -> %s" % (game.uuid, player.name, packet.playername))
		player.name = packet.playername
		for _player in game.players:
			self.send(_player.peer, packets.server.data_gamestate(game))


	def onchangecolor(self, player, packet):
		# NOTE: that event _only_ happens inside a lobby
		if player.game is None:
			# just ignore if not inside a game
			self.send(player.peer, packets.cmd_ok())
			return
		# ignore change to same color
		if player.color == packet.playercolor:
			return
		game = player.game
		# don't send packets to already started games
		if not game.is_open():
			return

		# make sure player colors are unique
		for _player in game.players:
			if _player.color == packet.playercolor:
				self.error(player, __("There's already a player with your color inside this game.") + " " +
				                   __("Unable to change your color."))
				return

		# ACK the change
		logging.debug("[CHANGECOLOR] [%s] Player:%s %s -> %s" % (game.uuid, player.name, player.color, packet.playercolor))
		player.color = packet.playercolor
		for _player in game.players:
			self.send(_player.peer, packets.server.data_gamestate(game))


	def gamedata(self, player, data):
		game = player.game
		#logging.debug("[GAMEDATA] [%s] %s" % (game.uuid, player))
		for _player in game.players:
			if _player is player:
				continue
			self.sendraw(_player.peer, data)


	# this event happens after a player is done with loading
	# and ready to start the game. we need to wait for all players
	def onpreparedgame(self, player, packet):
		game = player.game
		if game is None:
			return
		logging.debug("[PREPARED] [%s] %s" % (game.uuid, player))
		player.prepared = True
		count = 0
		for _player in game.players:
			if _player.prepared:
				count += 1
		if count != game.playercnt:
			return
		self.call_callbacks('startgame', game)


	def ontoggleready(self, player, packet):
		game = player.game
		if game is None:
			return
		# don't send packets to already started games
		if not game.is_open():
			return

		# ACK the change
		player.toggle_ready()
		logging.debug("[TOGGLEREADY] [%s] Player:%s %s ready" %
				(game.uuid, player.name, "is not" if not player.ready else "is"))
		for _player in game.players:
			self.send(_player.peer, packets.server.data_gamestate(game))

		# start the game after the ACK
		if game.is_ready():
			self.call_callbacks("preparegame", game)


	def onkick(self, player, packet):
		game = player.game
		if game is None:
			return
		# don't send packets to already started games
		if not game.is_open():
			return
		if player is not game.creator:
			return

		kickplayer = None
		for _player in game.players:
			if _player.sid == packet.kicksid:
				kickplayer = _player
				break
		if kickplayer is None:
			return
		if kickplayer is game.creator:
			return

		logging.debug("[KICK] [%s] %s got kicked" % (game.uuid, kickplayer.name))
		for _player in game.players:
			self.send(_player.peer, packets.server.cmd_kickplayer(kickplayer))
		self.call_callbacks("leavegame", kickplayer)


	#TODO fix
	def onfetchgame(self, player, packet):
		game = player.game

		if game is not None:
			self.error(player, __("You can't fetch a game while in another game"))

		fetch_game = self.__find_game_from_uuid(packet)
		for _player in fetch_game.players:
			if _player.name == fetch_game.creator: #TODO
				self.send(_player.peer, packets.server.cmd_fetch_game(player.sid))


	#TODO fix
	def onsavegamedata(self, player, packet):
		game = player.game

		for _player in game.players:
			if _player.sid == packet.psid:
				self.send(_player.peer, packets.server.savegame_data(packet.data, player.sid, game.mapname))


	def print_statistic(self, file):
		try:
			fd = open(file, "w")

			fd.write("Games.Total: %d\n" % (len(self.games)))
			games_playing = 0
			for game in self.games:
				if game.state is Game.State.Running:
					games_playing += 1
			fd.write("Games.Playing: %d\n" % (games_playing))

			fd.write("Players.Total: %d\n" % (len(self.players)))
			players_inlobby = 0
			players_playing = 0
			players_oldprotocol = 0
			for player in self.players.values():
				if player.game is None:
					continue
				if player.game.state is Game.State.Running:
					players_playing += 1
				else:
					players_inlobby += 1
				if player.protocol < PROTOCOLS[-1]:
					players_oldprotocol += 1
			fd.write("Players.Lobby: %d\n" % (players_inlobby))
			fd.write("Players.Playing: %d\n" % (players_playing))
			fd.write("Players.OldProtocol: %d\n" % (players_oldprotocol))

			fd.close()
		except IOError as e:
			logging.error("[STATISTIC] Unable to open statistic file: %s" % (e))
		return


########NEW FILE########
__FILENAME__ = savegamemanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import glob
import logging
import os
import os.path
import re
import sqlite3
import tempfile
import time
from collections import defaultdict

from horizons.constants import PATHS, VERSION
from horizons.util.dbreader import DbReader
from horizons.util.yamlcache import YamlCache

import horizons.globals
import horizons.main


class SavegameManager(object):
	"""Controls savegamefiles.

	This class is rather a namespace than a "real" object, since it has no members.
	The instance in horizons.main is nevertheless important, since it creates
	the savegame directories

	The return value usually is a tuple: (list_of_savegame_files, list_of_savegame_names),
	where savegame_names are meant for displaying to the user.

	IMPORTANT:
	Whenever you make a change that breaks compatibility with old savegames,
	increment horizons/constants.py:VERSION.SAVEGAMEREVISION and add an
	upgrade path in horizons/util/savegameupgrader.py.
	"""
	log = logging.getLogger("savegamemanager")

	savegame_dir = os.path.join(PATHS.USER_DIR, "save")
	autosave_dir = os.path.join(savegame_dir, "autosave")
	multiplayersave_dir = os.path.join(savegame_dir, "multiplayer_save")
	quicksave_dir = os.path.join(savegame_dir, "quicksave")
	maps_dir = os.path.join("content", "maps")
	scenario_maps_dir = os.path.join("content", "scenariomaps")
	scenarios_dir = os.path.join("content", "scenarios")

	savegame_extension = "sqlite"
	scenario_extension = "yaml"

	autosave_basename = "autosave-"
	quicksave_basename = "quicksave-"

	multiplayersave_name_regex = r"^[0-9a-zA-Z _.-]+$" # don't just blindly allow everything

	save_filename_timeformat = u"{prefix}%Y-%m-%d--%H-%M-%S"
	autosave_filenamepattern = save_filename_timeformat.format(prefix=autosave_basename)
	quicksave_filenamepattern = save_filename_timeformat.format(prefix=quicksave_basename)

	# Use {{}} because this string is formatted twice and
	# {} is replaced in the second format() call.
	filename = u"{{directory}}{sep}{{name}}.{ext}".format(sep=os.path.sep, ext=savegame_extension)

	savegame_screenshot_width = 290

	# metadata of a savegame with default values
	savegame_metadata = {'timestamp': -1, 'savecounter': 0,
	                     'savegamerev': 0, 'rng_state': ""}
	savegame_metadata_types = {'timestamp': float, 'savecounter': int,
	                           'savegamerev': int, 'rng_state': str}

	@classmethod
	def init(cls):
		# create savegame directory if it does not exist
		for d in cls.autosave_dir, cls.quicksave_dir, cls.multiplayersave_dir:
			if not os.path.isdir(d):
				os.makedirs(d)

	@classmethod
	def __get_displaynames(cls, files):
		"""Returns player-facing names for the savegames *files*.

		@param files: iterable object containing strings.
		@return: list of names to be displayed for each file.
		"""
		displaynames = []
		def get_timestamp_string(savegameinfo):
			if savegameinfo['timestamp'] == -1:
				return u""
			timestamp = time.localtime(savegameinfo['timestamp'])
			try:
				return time.strftime('%c', timestamp).decode('utf-8')
			except UnicodeDecodeError:
				# With non-utf8 system locales this would crash (#2221).
				return u""

		for f in files:
			if f.startswith(cls.autosave_dir):
				name = u"Autosave {date}".format(date=get_timestamp_string(cls.get_metadata(f)))
			elif f.startswith(cls.quicksave_dir):
				name = u"Quicksave {date}".format(date=get_timestamp_string(cls.get_metadata(f)))
			else:
				name = os.path.splitext(os.path.basename(f))[0]

			if not isinstance(name, unicode):
				name = unicode(name, errors='replace') # only use unicode strings, guichan needs them
			displaynames.append(name)
		return displaynames

	@classmethod
	def __get_saves_from_dirs(cls, dirs, include_displaynames, filename_extension, order_by_date):
		"""Returns the savegame files in each directory in *dirs*. Internal method.

		@param include_displaynames: Whether to add player-readable names displayed in gui.
		"""
		if not filename_extension:
			filename_extension = cls.savegame_extension
		files = sorted((-os.path.getmtime(f) if order_by_date else 0, f)
		               for p in dirs for f in glob.glob(p + '/*.' + filename_extension)
		               if os.path.isfile(f))
		files = zip(*files)[1] if files else []
		if include_displaynames:
			return (files, cls.__get_displaynames(files))
		else:
			return (files,)

	@classmethod
	def create_filename(cls, savegamename):
		"""Returns the full path for a regular save of the name *savegamename*."""
		name = cls.filename.format(directory=cls.savegame_dir, name=savegamename)
		cls.log.debug("Savegamemanager: creating save-filename: %s", name)
		return name

	@classmethod
	def create_autosave_filename(cls):
		"""Builds filename for a new autosave."""
		prepared_filename = time.strftime(cls.autosave_filenamepattern)
		name = cls.filename.format(directory=cls.autosave_dir, name=prepared_filename)
		cls.log.debug("Savegamemanager: creating autosave-filename: %s", name)
		return name

	@classmethod
	def create_quicksave_filename(cls):
		"""Returns the filename for a quicksave"""
		prepared_filename = time.strftime(cls.quicksave_filenamepattern)
		name = cls.filename.format(directory=cls.quicksave_dir, name=prepared_filename)
		cls.log.debug("Savegamemanager: creating quicksave-filename: %s", name)
		return name

	@classmethod
	def create_multiplayer_quicksave_name(cls):
		"""Will create a name, not a path"""
		return "quicksave-" + str(time.time())

	@classmethod
	def create_multiplayer_autosave_name(cls):
		"""Will create a name, not a path"""
		return "autosave-" + str(time.time())

	@classmethod
	def create_multiplayersave_filename(cls, name):
		"""Builds filename for a multiplayer savegame *name*."""
		if not re.match(cls.multiplayersave_name_regex, name):
			err = "Smelly multiplayer filename detected: " + name
			cls.log.error(err)
			raise RuntimeError(err)

		name = cls.filename.format(directory=cls.multiplayersave_dir, name=name)
		cls.log.debug("Savegamemanager: creating multiplayersave-filename: %s", name)
		return name

	@classmethod
	def delete_dispensable_savegames(cls, autosaves=False, quicksaves=False):
		"""Delete oldest savegames that are no longer needed.

		This is usually called to make space for new savegames when the limit
		(defined in settings) for that kind of saves is reached.

		@param autosaves: set to True if autosaves should be cleaned.
		@param quicksaves: set to True if quicksaves should be cleaned.
		"""
		def tmp_del(pattern, limit):
			# Casting to int because get_uh_setting below returns floats like
			# 4.0 (the slider stepping is 1.0) but we use this value as index.
			limit = int(limit)
			files = sorted(glob.glob(pattern))
			for filename in files[:-limit]:
				os.unlink(filename)

		if autosaves:
			tmp_del("%s/*.%s" % (cls.autosave_dir, cls.savegame_extension),
			        horizons.globals.fife.get_uh_setting("AutosaveMaxCount"))
		if quicksaves:
			tmp_del("%s/*.%s" % (cls.quicksave_dir, cls.savegame_extension),
			        horizons.globals.fife.get_uh_setting("QuicksaveMaxCount"))

	@classmethod
	def get_recommended_number_of_players(cls, mapfile):
		"""Returns amount of players recommended for a map *mapfile*."""
		dbdata = DbReader(mapfile) \
			("SELECT value FROM properties WHERE name = ?", "players_recommended")
		if dbdata:
			return dbdata[0][0]
		else:
			return "undefined"

	@classmethod
	def get_metadata(cls, savegamefile):
		"""Returns metainfo of a savegame as dict."""
		metadata = cls.savegame_metadata.copy()
		if isinstance(savegamefile, list):
			return metadata
		db = DbReader(savegamefile)

		try:
			for key in metadata.iterkeys():
				result = db("SELECT `value` FROM `metadata` WHERE `name` = ?", key)
				if result:
					assert len(result) == 1
					metadata[key] = cls.savegame_metadata_types[key](result[0][0])
		except sqlite3.OperationalError as e:
			cls.log.warning('Warning: Cannot read savegame {file}: {exception}'
			                ''.format(file=savegamefile, exception=e))
			return metadata

		screenshot_data = None
		try:
			screenshot_data = db("SELECT value FROM metadata_blob where name = ?", "screen")[0][0]
		except IndexError:
			pass
		except sqlite3.OperationalError:
			pass
		metadata['screenshot'] = screenshot_data

		return metadata

	@classmethod
	def _write_screenshot(cls, db):
		# special handling for screenshot (as blob)
		screenshot_fd, screenshot_filename = tempfile.mkstemp()

		width = horizons.globals.fife.engine_settings.getScreenWidth()
		height = horizons.globals.fife.engine_settings.getScreenHeight()

		# hide whatever dialog we have
		dialog_hidden = False
		windows = horizons.main._modules.session.ingame_gui.windows
		if windows.visible:
			dialog_hidden = True
			windows.hide_all()
			# pump twice to make it work on some machines
			horizons.globals.fife.engine.pump()
			horizons.globals.fife.engine.pump()

		# scale to the correct width and adapt height with same factor
		factor = float(cls.savegame_screenshot_width) / width
		new_width = int(float(width) * factor)
		new_height = int(float(height) * factor)
		backend = horizons.globals.fife.engine.getRenderBackend()
		backend.captureScreen(screenshot_filename, new_width, new_height)

		if dialog_hidden:
			windows.show_all()
			horizons.globals.fife.engine.pump()

		screenshot_data = os.fdopen(screenshot_fd, "r").read()
		db("INSERT INTO metadata_blob values(?, ?)", "screen", sqlite3.Binary(screenshot_data))
		os.unlink(screenshot_filename)

	@classmethod
	def write_metadata(cls, db, savecounter, rng_state):
		"""Writes metadata into database *db*.

		@param db: DbReader instance.
		@param savecounter: int, how many times this file has been saved.
		"""
		metadata = cls.savegame_metadata.copy()
		metadata['timestamp'] = time.time()
		metadata['savecounter'] = savecounter
		metadata['savegamerev'] = VERSION.SAVEGAMEREVISION
		metadata['rng_state'] = rng_state

		for key, value in metadata.iteritems():
			db("INSERT INTO metadata(name, value) VALUES(?, ?)", key, value)

		cls._write_screenshot(db)

	@classmethod
	def get_regular_saves(cls, include_displaynames=True):
		"""Returns all savegames that were saved via the ingame save dialog.

		@param include_displaynames: Whether to add player-readable names displayed in gui.
		"""
		where = [cls.savegame_dir]
		cls.log.debug("Savegamemanager: regular saves from: %s", where)
		return cls.__get_saves_from_dirs(where, include_displaynames, None, True)

	@classmethod
	def get_maps(cls, include_displaynames=True):
		"""Returns all maps in content/maps/ and ~/.unknown-horizons/maps/.

		@param include_displaynames: Whether to add player-readable names displayed in gui.
		"""
		where = [cls.maps_dir, PATHS.USER_MAPS_DIR]
		cls.log.debug("Savegamemanager: get maps from %s", where)
		return cls.__get_saves_from_dirs(where, include_displaynames, None, False)

	@classmethod
	def get_map(cls, map_name):
		return os.path.join(cls.maps_dir, map_name + "." + cls.savegame_extension)

	@classmethod
	def get_multiplayersave_map(cls, name):
		return os.path.join(cls.multiplayersave_dir, name + "." + cls.savegame_extension)

	@classmethod
	def get_saves(cls, include_displaynames=True):
		"""Returns all savegames: regular, auto- and quicksaves.

		@param include_displaynames: Whether to add player-readable names displayed in gui.
		"""
		where = [cls.savegame_dir, cls.autosave_dir, cls.quicksave_dir]
		cls.log.debug("Savegamemanager: get saves from %s", where)
		return cls.__get_saves_from_dirs(where, include_displaynames, None, True)

	@classmethod
	def get_multiplayersaves(cls, include_displaynames=True):
		where = [cls.multiplayersave_dir]
		cls.log.debug("Savegamemanager: get saves from %s", where)
		return cls.__get_saves_from_dirs(where, include_displaynames, None, True)

	@classmethod
	def get_quicksaves(cls, include_displaynames=True):
		"""Returns all quicksave savegames."""
		where = [cls.quicksave_dir]
		cls.log.debug("Savegamemanager: quicksaves from: %s", where)
		return cls.__get_saves_from_dirs(where, include_displaynames, None, True)

	@classmethod
	def get_scenarios(cls, include_displaynames=True):
		"""Returns all scenarios"""
		where = [cls.scenarios_dir]
		cls.log.debug("Savegamemanager: scenarios from: %s", where)
		return cls.__get_saves_from_dirs(where, include_displaynames, cls.scenario_extension, False)

	@classmethod
	def get_available_scenarios(cls, include_displaynames=True, locales=False):
		"""Returns available scenarios."""
		translated_scenarios = defaultdict(list)
		scenarios = zip(*cls.get_scenarios(include_displaynames=True))
		for filename, scenario in scenarios:
			if not os.path.exists(filename):
				continue
			if not os.stat(filename).st_size:
				# file seems empty
				continue
			_locale = cls.get_scenario_metadata(scenario=scenario).get('locale', u'en')
			# sort into dictionary by english filename (without language suffix)
			english_name = scenario.split('_' + _locale)[0]
			translated_scenarios[english_name].append((_locale, filename))
		return translated_scenarios

	@classmethod
	def get_scenario_metadata(cls, scenario="", filename=""):
		"""Return the `metadata` dict for a scenario.

		Pass either the scenario name (*scenario*) or a .yaml *filename*.
		"""
		sfiles, snames = cls.get_scenarios(include_displaynames=True)
		if scenario:
			if scenario not in snames:
				cls.log.error("Error: Cannot find scenario '{name}'.".format(name=scenario))
				return {}
			index = snames.index(scenario)
		elif filename:
			if filename not in sfiles:
				cls.log.error("Error: Cannot find scenario '{name}'.".format(name=filename))
				return {}
			index = sfiles.index(filename)
		data = YamlCache.get_file(sfiles[index], game_data=True)
		return data.get('metadata', {})

	@classmethod
	def get_savegamename_from_filename(cls, savegamefile):
		"""Returns a displayable name, extracted from a filename"""
		name = os.path.basename(savegamefile)
		name = name.rsplit(".%s"%cls.savegame_extension, 1)[0]
		cls.log.debug("Savegamemanager: savegamename: %s", name)
		return name

	@classmethod
	def get_filename_from_map_name(cls, map_name):
		for prefix in [cls.scenario_maps_dir, cls.maps_dir, PATHS.USER_MAPS_DIR]:
			path = prefix + os.sep + map_name + '.sqlite'
			if os.path.exists(path):
				return path
		return None

########NEW FILE########
__FILENAME__ = actions
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import math

import horizons.globals

from horizons.scheduler import Scheduler
from horizons.util.python.callback import Callback
from horizons.util.python.registry import Registry
from horizons.util.shapes import Point, Circle
from horizons.util.worldobject import WorldObject
from horizons.command.unit import CreateUnit
from horizons.scenario import CONDITIONS
from horizons.constants import MESSAGES
from horizons.command.game import PauseCommand, UnPauseCommand
from horizons.messaging import SettlerUpdate
from horizons.component.storagecomponent import StorageComponent


class ACTIONS(object):
	"""Class that holds all available action functions."""
	__metaclass__ = Registry

	@classmethod
	def register_function(cls, func, name=None):
		"""Register action.

		By default, the function's name is used as identifier of the action. You can supply
		a `name` parameter to use instead.
		"""
		cls.registry[name or func.__name__] = func


register = ACTIONS.register


@register(name='message')
def show_message(session, type=None, *messages):
	"""Shows a message with custom text in the messagewidget.
	If you pass more than one message, they are shown simultaneously."""
	visible_ticks = Scheduler().get_ticks(MESSAGES.CUSTOM_MSG_VISIBLE_FOR)

	return [session.ingame_gui.message_widget.add_custom(msg, msg_type=type, visible_for=visible_ticks)
	        for msg in messages]

@register(name='db_message')
def show_db_message(session, database_message_id):
	"""Shows a message with predefined text in the messagewidget."""
	session.ingame_gui.message_widget.add(database_message_id)

@register(name='logbook')
def show_logbook_entry_delayed(session, *parameters):
	"""Shows a logbook entry and opens the logbook after 'delay' seconds.
	Displays a YAML-defined notification message on logbook close.

	Set delay=0 for instant appearing.
	#TODO get *delay* parameter working again, it is currently not implemented!
	@param parameters: arbitrary list of logbook parameters, including their values.
	                Check widgets.logbook#add_captainslog_entry for parameter documentation.
	"""
	def write_logbook_entry(session, parameters):
		"""Adds an entry to the logbook and displays it.
		On logbook close, displays a notification message defined in the YAML."""
		session.ingame_gui.logbook.add_captainslog_entry(parameters, show_logbook=True)
	delay = MESSAGES.LOGBOOK_DEFAULT_DELAY
	callback = Callback(write_logbook_entry, session, parameters)
	Scheduler().add_new_object(callback, session.scenario_eventhandler, run_in=Scheduler().get_ticks(delay))

@register(name='win')
def do_win(session):
	"""The player wins the current scenario."""
	PauseCommand().execute(session)
	show_db_message(session, 'YOU_HAVE_WON')
	horizons.globals.fife.play_sound('effects', "content/audio/sounds/events/scenario/win.ogg")

	continue_playing = session.ingame_gui.open_popup(_("You have won!"),
	                                                 _("You have completed this scenario.") + u" " +
	                                                 _("Do you want to continue playing?"),
	                                                 show_cancel_button=True)
	if not continue_playing:
		Scheduler().add_new_object(session.quit, session, run_in=0)
	else:
		UnPauseCommand().execute(session)

@register(name='goal_reached')
def goal_reached(session, goal_number):
	"""The player reaches a certain goal in the current scenario."""
	# This method is kept to make some tests happy.
	pass

@register(name='lose')
def do_lose(session):
	"""The player fails the current scenario."""
	show_db_message(session, 'YOU_LOST')
	horizons.globals.fife.play_sound('effects', 'content/audio/sounds/events/scenario/lose.ogg')
	# drop events after this event
	Scheduler().add_new_object(session.scenario_eventhandler.drop_events, session.scenario_eventhandler)

@register()
def set_var(session, variable, value):
	"""Assigns values to scenario variables. Overwrites previous assignments to the same variable."""
	session.scenario_eventhandler._scenario_variables[variable] = value
	check_callbacks = Callback.ChainedCallbacks(
	  Callback(session.scenario_eventhandler.check_events, CONDITIONS.var_eq),
	  Callback(session.scenario_eventhandler.check_events, CONDITIONS.var_lt),
	  Callback(session.scenario_eventhandler.check_events, CONDITIONS.var_gt)
	)
	Scheduler().add_new_object(check_callbacks, session.scenario_eventhandler, run_in=0)

@register()
def wait(session, seconds):
	"""Postpones any other scenario events for a certain amount of seconds."""
	delay = Scheduler().get_ticks(seconds)
	session.scenario_eventhandler.sleep(delay)

@register()
def alter_inventory(session, resource, amount):
	"""Alters the inventory of each settlement."""
	for settlement in session.world.settlements:
		if settlement.owner == session.world.player and settlement.warehouse:
			settlement.warehouse.get_component(StorageComponent).inventory.alter(
					resource, amount)

@register()
def highlight_position(session, where, play_sound=False, color=(0, 0, 0)):
	"""Highlights a position on the minimap.
	where: (x, y) coordinate tuple
	color is a optional parameter that defines the color of the highlight. """
	session.ingame_gui.minimap.highlight(where, color=color)
	if play_sound:
		horizons.globals.fife.play_sound('effects', 'content/audio/sounds/ships_bell.ogg')

@register(name='change_increment')
def change_tier(session, tier):
	""" Changes the tier of the settlements. """
	for settlement in session.world.settlements:
		if settlement.owner == session.world.player:
			# Settler levels are zero-based!
			SettlerUpdate.broadcast(settlement.warehouse, tier - 1, tier - 1)

@register()
def spawn_ships(session, owner_id, ship_id, number, *position):
	"""
	Creates a number of ships controlled by a certain player around a position on the map.
	@param owner_id: the owner worldid
	@param ship_id: the ship id
	@param number: number of ships to be spawned
	@param position: position around the ships to be spawned
	"""
	center = Point(*position)
	player = WorldObject.get_object_by_id(owner_id)
	# calculate a radius that should fit all the ships
	# if it doesn't fit them all increase the radius
	radius = int(math.sqrt(number))
	while number != 0:
		for point in Circle(center, radius):
			if (point.x, point.y) in session.world.ship_map \
				or session.world.get_island(point) is not None:
				continue
			CreateUnit(owner_id, ship_id, point.x, point.y)(issuer=player)
			number -= 1
			if number == 0:
				break
		radius += 1

########NEW FILE########
__FILENAME__ = conditions
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.constants import RES, BUILDINGS
from horizons.scheduler import Scheduler
from horizons.util.pathfinding.pather import StaticPather
from horizons.util.python.registry import Registry
from horizons.component.storagecomponent import StorageComponent


class CONDITIONS(object):
	"""
	Class that holds all available conditions.

	These are functions, that perform a certain check at one point in time.
	There is no memory, e.g. if you lose progress, conditions just aren't true any more.

	Condition checking is split up in 2 types:

	  1. possible condition change is notified somewhere in the game code
	  2. condition is checked periodically
	"""
	__metaclass__ = Registry

	check_periodically = []

	@classmethod
	def register_function(cls, func, periodically=False):
		"""Register condition.

		`periodically` means that this condition function will be called periodically
		by the ScenarioEventHandler.
		"""
		name = func.__name__
		cls.registry[name] = func
		# allow CONDITIONS.example_condition_name to work, used as identifier to notify
		# about condition change (see 1)
		setattr(cls, name, name)

		if periodically:
			cls.check_periodically.append(name)


register = CONDITIONS.register


@register()
def settlements_num_greater(session, limit):
	"""Returns whether the number of player settlements is greater than *limit*."""
	return len(_get_player_settlements(session)) > limit

@register()
def settler_level_greater(session, limit):
	"""Returns whether the highest tier reached in any player settlement is greater than *limit*."""
	return (session.world.player.settler_level > limit)

@register(periodically=True)
def player_gold_greater(session, limit):
	"""Returns whether the player has more gold than *limit*."""
	return (session.world.player.get_component(StorageComponent).inventory[RES.GOLD] > limit)

@register(periodically=True)
def player_gold_less(session, limit):
	"""Returns whether the player has less gold than *limit*."""
	return (session.world.player.get_component(StorageComponent).inventory[RES.GOLD] < limit)

@register(periodically=True)
def settlement_balance_greater(session, limit):
	"""Returns whether the balance of at least one player settlement is higher than *limit*."""
	return any(settlement for settlement in _get_player_settlements(session) if
	           settlement.balance > limit)

@register(periodically=True)
def player_balance_greater(session, limit):
	"""Returns whether the cumulative balance of all player settlements is higher than *limit*."""
	return (sum(settlement.balance for settlement in _get_player_settlements(session)) > limit)

@register(periodically=True)
def settlement_inhabitants_greater(session, limit):
	"""Returns whether at least one player settlement has more than *limit* inhabitants."""
	return any(settlement for settlement in _get_player_settlements(session) if
	           settlement.inhabitants > limit)

@register(periodically=True)
def player_inhabitants_greater(session, limit):
	"""Returns whether all player settlements combined have more than *limit* inhabitants."""
	return (sum(settlement.inhabitants for settlement in _get_player_settlements(session)) > limit)

@register()
def building_num_of_type_greater(session, building_class, limit):
	"""Returns whether any player settlement has more than *limit* buildings of type *building_class*."""
	for settlement in _get_player_settlements(session):
		if len(settlement.buildings_by_id[building_class]) > limit:
			return True
	return False

@register(periodically=True)
def player_res_stored_greater(session, resource, limit):
	"""Returns whether all player settlements combined have more than *limit*
	of *resource* in their inventories."""
	return (sum(settlement.get_component(StorageComponent).inventory[resource] for settlement in _get_player_settlements(session)) > limit)

@register(periodically=True)
def player_res_stored_less(session, resource, limit):
	"""Returns whether all player settlements combined have less than *limit*
	of *resource* in their inventories."""
	return (sum(settlement.get_component(StorageComponent).inventory[resource] for settlement in _get_player_settlements(session)) < limit)

@register(periodically=True)
def settlement_res_stored_greater(session, resource, limit):
	"""Returns whether at least one player settlement has more than *limit*
	of *resource* in its inventory."""
	return any(settlement for settlement in _get_player_settlements(session) if
	           settlement.get_component(StorageComponent).inventory[resource] > limit)

@register(periodically=True)
def player_total_earnings_greater(session, limit):
	"""Returns whether the player has earned more than *limit* money with
	trading in all settlements combined. Profit = sell_income - buy_expenses."""
	total_earning = 0
	for settlement in _get_player_settlements(session):
		total_earning += settlement.total_earnings
	return total_earning > limit

@register(periodically=True)
def settlement_produced_res_greater(session, resource, limit):
	"""Returns whether more than *limit* resource have been produced in any player settlement."""
	return any(settlement for settlement in _get_player_settlements(session) if
	           settlement.produced_res.get(resource, 0) > limit)

@register(periodically=True)
def player_produced_res_greater(session, resource, limit):
	"""Returns whether more than *limit* of the resource *resource*
	have been produced in all player settlements combined."""
	return sum(settlement.produced_res.get(resource, 0) for settlement in _get_player_settlements(session)) > limit

@register(periodically=True)
def buildings_connected_to_warehouse_gt(session, building_class, limit):
	"""Checks whether more than *limit* of *building_class* type buildings are
	connected to a warehouse or storage."""
	return (_building_connected_to_any_of(session, building_class,
	        BUILDINGS.WAREHOUSE, BUILDINGS.STORAGE) > limit )

@register(periodically=True)
def buildings_connected_to_warehouse_lt(session, building_class, limit):
	"""Checks whether less than *limit* of *building_class* type buildings are
	connected to a warehouse or storage."""
	return (_building_connected_to_any_of(session, building_class,
	        BUILDINGS.WAREHOUSE, BUILDINGS.STORAGE) < limit )

@register(periodically=True)
def buildings_connected_to_building_gt(session, building_class, class2, limit):
	"""Checks whether more than *limit* of *building_class* type buildings are
	connected to any building of type *class2*."""
	return (_building_connected_to_any_of(session, building_class, class2) > limit )

@register(periodically=True)
def buildings_connected_to_building_lt(session, building_class, class2, limit):
	"""Checks whether less than *limit* of *building_class* type buildings are
	connected to any building of type *class2*."""
	return (_building_connected_to_any_of(session, building_class, class2) < limit )

@register(periodically=True)
def building_in_range(session, building_class1, building_class2):
	"""Checks whether there is a building_class2 in range of a building_class1."""
	return _building_in_range_of(session, building_class1, building_class2)

@register(periodically=True)
def time_passed(session, seconds):
	"""Returns whether at least *seconds* seconds have passed since the game started."""
	return (Scheduler().cur_tick >= Scheduler().get_ticks(seconds))

@register()
def game_started(session):
	"""Always return True. Used for one-off events"""
	return True

@register()
def var_eq(session, variable, value):
	"""Returns whether *variable* has a value equal to *value*.
	Returns False if variable was never set in the current session."""
	if not variable in _get_scenario_vars(session):
		return False
	return (_get_scenario_vars(session)[variable] == value)

@register()
def var_gt(session, variable, value):
	"""Returns whether *variable* has a value greater than *value*.
	Returns False if variable was never set in the current session."""
	if not variable in _get_scenario_vars(session):
		return False
	return (_get_scenario_vars(session)[variable] > value)

@register()
def var_lt(session, variable, value):
	"""Returns whether *variable* has a value less than *value*.
	Returns False if variable was never set in the current session."""
	if not variable in _get_scenario_vars(session):
		return False
	return (_get_scenario_vars(session)[variable] < value)

def _get_player_settlements(session):
	"""Helper generator, returns settlements of local player."""
	return session.world.player.settlements

def _get_scenario_vars(session):
	return session.scenario_eventhandler._scenario_variables

def _building_connected_to_any_of(session, building_class, *classes):
	"""Returns the exact amount of buildings of type *building_class* that are
	connected to any building of a class in the building type list *classes*.
	Counts all player settlements."""
	building_to_check = []
	check_connection = []
	for settlement in _get_player_settlements(session):
		building_to_check.extend(settlement.buildings_by_id[building_class])
		for b_class in classes:
			for building in settlement.buildings_by_id[b_class]:
				check_connection.append(building)
	found_connected = 0
	for building in building_to_check:
		for check in check_connection:
			if StaticPather.get_path_on_roads(building.island, building, check):
				found_connected += 1
				break
	return found_connected

@register(periodically=True)
def player_number_of_ships_gt(session, player_id, limit):
	"""Returns whether the number of ships owned by the player *player_id* is greater than *limit*."""
	number_of_ships = len([s for s in session.world.ships if s.owner.worldid == player_id])
	return number_of_ships > limit

@register(periodically=True)
def player_number_of_ships_lt(session, player_id, limit):
	"""Returns whether the number of ships owned by the player *player_id* is less than *limit*."""
	number_of_ships = len([s for s in session.world.ships if s.owner.worldid == player_id])
	return number_of_ships < limit

def _building_connected_to_all_of(session, building_class, *classes):
	"""Returns the exact amount of buildings of type *building_class* that are
	connected to any building of each class in *classes*. Counts all player settlements."""
	#TODO

def _building_in_range_of(session, building_class, *classes):
	"""Returns whether there is any building of type *building_class*
	in range of any building of a class in the building type list *classes*.
	Counts all player settlements."""

	for settlement in _get_player_settlements(session): # iterate through settlements
		for building in settlement.buildings_by_id[building_class]: # iterate through all buildings of building_class
			for other_class in classes: # iterate through all given other classes
				for building2 in settlement.buildings_by_id[other_class]: # iterate through all buildings of other_class
					if building.position.distance( building2.position ) <= building.radius: # building in range of building2
						return True
	return False # building not found in range

########NEW FILE########
__FILENAME__ = scenarioeventhandler
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import json
import yaml
import copy

from horizons.scheduler import Scheduler
from horizons.util.living import LivingObject
from horizons.util.python.callback import Callback
from horizons.util.yamlcache import YamlCache

from horizons.scenario import ACTIONS, CONDITIONS


class InvalidScenarioFileFormat(Exception):
	def __init__(self, msg=None):
		if msg is None:
			msg = "Invalid scenario file."
		super(InvalidScenarioFileFormat, self).__init__(msg)


class ScenarioEventHandler(LivingObject):
	"""Handles event, that make up a scenario. See wiki.
	An instance of this class is bound to a set of events. On a new scenario, you need a new instance.

	Scenarios consist of condition-action events.
	When all conditions of an event become true, the action is executed and the event is
	removed from the scenario. All events only happen once.

	Whenever the game state changes in a way, that can change the truth value of a condition,
	the event handler must be notified. It will then check all relevant events.
	It is imperative for this notification to always be triggered, else the scenario gets stuck.
	For conditions, where this approach doesn't make sense (e.g. too frequent changes),
	a periodic check can be used.

	Save/load works by dumping all info into a yaml string in the savegame,
	which is loaded just like normal scenarios are loaded.
	"""

	CHECK_CONDITIONS_INTERVAL = 3 # seconds

	PICKLE_PROTOCOL = 2

	def __init__(self, session, scenariofile=None):
		"""
		@param session: Session instance
		@param scenariofile: yaml file that describes the scenario
		@throws InvalidScenarioFileFormat on yaml parse error
		"""
		self.inited = False
		self.session = session
		self._events = []
		self._data = {}
		# map: condition types -> events
		self._event_conditions = {}
		self._scenario_variables = {} # variables for set_var, var_eq ...
		for cond in CONDITIONS.registry.keys():
			self._event_conditions[cond] = set()
		if scenariofile:
			self._apply_data( self._parse_yaml_file( scenariofile ) )

		self.sleep_ticks_remaining = 0


	def start(self):
		# Add the check_events method to the scheduler to be checked every few seconds
		self.check_events("game_started")
		Scheduler().add_new_object(self._scheduled_check, self,
		                           run_in=Scheduler().get_ticks(self.CHECK_CONDITIONS_INTERVAL),
		                           loops=-1)

	def sleep(self, ticks):
		"""Sleep the ScenarioEventHandler for number of ticks. This delays all
		callbacks by the specific amount"""
		callbacks = Scheduler().get_classinst_calls(self)
		for callback in callbacks:
			Scheduler().rem_object(callback)
			callback.run_in = callback.run_in + ticks
			Scheduler().add_object(callback)
		self.sleep_ticks_remaining = ticks
		Scheduler().add_new_object(self._reduce_sleep, self, loops=ticks)

	def _reduce_sleep(self):
		self.sleep_ticks_remaining -= 1

	def end(self):
		Scheduler().rem_all_classinst_calls(self)
		self.session = None
		self._events = None
		self._data = None

	def save(self, db):
		if self.inited: # only save in case we have data applied
			db("INSERT INTO metadata(name, value) VALUES(?, ?)", "scenario_events", self.to_yaml())
		for key, value in self._scenario_variables.iteritems():
			db("INSERT INTO scenario_variables(key, value) VALUES(?, ?)", key,
			   json.dumps(value))

	def load(self, db):
		for key, value in db("SELECT key, value FROM scenario_variables"):
			self._scenario_variables[key] = json.loads(value)
		data = db("SELECT value FROM metadata WHERE name = ?", "scenario_events")
		if not data:
			return # nothing to load
		self._apply_data( self._parse_yaml( data[0][0] ) )

	def schedule_check(self, condition):
		"""Let check_events run in one tick for condition. Useful for lag prevetion if time is a
		critical factor, e.g. when the user has to wait for a function to return.."""
		if self.session.world.inited: # don't check while loading
			Scheduler().add_new_object(Callback(self.check_events, condition), self, run_in=self.sleep_ticks_remaining)

	def schedule_action(self, action):
		if self.sleep_ticks_remaining > 0:
			Scheduler().add_new_object(Callback(action, self.session), self, run_in=self.sleep_ticks_remaining)
		else:
			action(self.session)

	def check_events(self, condition):
		"""Checks whether an event happened.
		@param condition: condition from enum conditions that changed"""
		if not self.session.world.inited: # don't check while loading
			return
		events_to_remove = []
		for event in self._event_conditions[condition]:
			event_executed = event.check(self)
			if event_executed:
				events_to_remove.append(event)
		for event in events_to_remove:
			self._remove_event(event)

	def get_map_file(self):
		try:
			return self._data['metadata']['mapfile']
		except KeyError:
			# Old scenario format
			return self._data['mapfile']

	@classmethod
	def get_metadata_from_file(cls, filename):
		"""Returns metadata dictionary from a yaml scenario file.

		Dictionary contains "unknown" for all of these fields if not specified
		in the scenario file:
		 - difficulty
		 - author
		 - description

		@throws InvalidScenarioFileFormat on yaml parse error
		"""
		fallback = _('unknown')
		metadata = cls._parse_yaml_file(filename).get('metadata', {})
		for required_key in ('author', 'difficulty', 'description'):
			metadata.setdefault(required_key, fallback)
		return metadata

	def drop_events(self):
		"""Removes all events. Useful when player lost."""
		while self._events:
			self._remove_event(self._events[0])

	@staticmethod
	def _parse_yaml(string_or_stream):
		try:
			return YamlCache.load_yaml_data(string_or_stream)
		except Exception as e: # catch anything yaml or functions that yaml calls might throw
			raise InvalidScenarioFileFormat(str(e))

	@classmethod
	def _parse_yaml_file(cls, filename):
		return YamlCache.get_file(filename, game_data=True)

	def _apply_data(self, data):
		"""Apply data to self loaded via from yaml
		@param data: return value of yaml.load or _parse_yaml resp.
		"""
		self._data = data
		for event_dict in self._data['events']:
			event = _Event(self.session, event_dict)
			self._events.append( event )
			for cond in event.conditions:
				self._event_conditions[ cond.cond_type ].add( event )
		self.inited = True

	def _scheduled_check(self):
		"""Check conditions that can only be checked periodically"""
		for cond_type in CONDITIONS.check_periodically:
			self.check_events(cond_type)

	def _remove_event(self, event):
		assert isinstance(event, _Event)
		for cond in event.conditions:
			# we have to use discard here, since cond.cond_type might be the same
			# for multiple conditions of event
			self._event_conditions[ cond.cond_type ].discard( event )
		self._events.remove( event )

	def to_yaml(self):
		"""Returns yaml representation of current state of self.
		Another object of this type, constructed with the return value of this function, has
		to result in the very same object."""
		# every data except events are static, so reuse old data
		data = copy.deepcopy(self._data)
		del data['events']
		yaml_code = dump_dict_to_yaml(data)
		# remove last } so we can add stuff
		yaml_code = yaml_code.rsplit(u'}\n', 1)[0]
		yaml_code += ', events: [ %s ] }' % ', '.join(event.to_yaml() for event in self._events)
		return yaml_code


###
# Simple utility classes

def assert_type(var, expected_type, name):
	if not isinstance(var, expected_type):
		raise InvalidScenarioFileFormat('%s should be a %s, but is: %s' % (
			name, expected_type.__name__, str(var)))


class _Event(object):
	"""Internal data structure representing an event."""
	def __init__(self, session, event_dict):
		self.session = session
		self.actions = []
		self.conditions = []
		assert_type(event_dict['actions'], list, "actions")
		for action_dict in event_dict['actions']:
			self.actions.append( _Action(action_dict) )
		assert_type(event_dict['conditions'], list, "conditions")
		for cond_dict in event_dict['conditions']:
			self.conditions.append( _Condition(session, cond_dict) )

	def check(self, scenarioeventhandler):
		for cond in self.conditions:
			if not cond():
				return False
		for action in self.actions:
			scenarioeventhandler.schedule_action(action)
		return True

	def to_yaml(self):
		"""Returns yaml representation of self"""
		return '{ actions: [ %s ] , conditions: [ %s ]  }' % \
			   (', '.join(action.to_yaml() for action in self.actions),
				', '.join(cond.to_yaml() for cond in self.conditions))


class _Action(object):
	"""Internal data structure representing an ingame scenario action"""
	def __init__(self, action_dict):
		assert_type(action_dict, dict, "action specification")

		try:
			self.action_type = action_dict['type']
		except KeyError:
			raise InvalidScenarioFileFormat('Encountered action without type\n'+str(action_dict))
		try:
			self.callback = ACTIONS.get(self.action_type)
		except KeyError:
			raise InvalidScenarioFileFormat('Found invalid action type: %s' % self.action_type)

		self.arguments = action_dict.get('arguments', [])

	def __call__(self, session):
		"""Executes action."""
		self.callback(session, *self.arguments)

	def to_yaml(self):
		"""Returns yaml representation of self"""
		arguments_yaml = dump_dict_to_yaml(self.arguments)
		return "{arguments: %s, type: %s}" % (arguments_yaml, self.action_type)


class _Condition(object):
	"""Internal data structure representing a condition"""

	def __init__(self, session, cond_dict):
		self.session = session
		assert_type(cond_dict, dict, "condition specification")

		try:
			self.cond_type = cond_dict['type']
		except KeyError:
			raise InvalidScenarioFileFormat("Encountered condition without type\n"+str(cond_dict))
		try:
			self.callback = CONDITIONS.get(self.cond_type)
		except KeyError:
			raise InvalidScenarioFileFormat('Found invalid condition type: %s' % self.cond_type)

		self.arguments = cond_dict.get('arguments', [])

	def __call__(self):
		"""Check for condition.
		@return: bool"""
		return self.callback(self.session, *self.arguments)

	def to_yaml(self):
		"""Returns yaml representation of self"""
		arguments_yaml = dump_dict_to_yaml(self.arguments)
		return '{arguments: %s, type: "%s"}' % ( arguments_yaml, self.cond_type)


def dump_dict_to_yaml(data):
	"""Wrapper for dumping yaml data using common parameters"""
	# NOTE: the line below used to end with this: .replace('\n', '')
	# which broke formatting of logbook messages, of course. Revert in case of problems.

	# default_flow_style: makes use of short list notation without newlines (required here)
	return yaml.safe_dump(data, line_break='\n', default_flow_style=True)


########NEW FILE########
__FILENAME__ = scheduler
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
from collections import deque

import horizons.main

from horizons.util.living import LivingObject
from horizons.util.python.singleton import ManualConstructionSingleton
from horizons.constants import GAME

class Scheduler(LivingObject):
	""""Class providing timed callbacks.
	Master of time.

	TODO:
	- Refactor to use a data structure that is suitable for iteration (ticking) as well as
	  searching/deleting by instance, possibly also by callback.
	  Suggestion: { tick -> { instance -> [callback] }} (basically a k-d tree)


	@param timer: Timer instance the schedular registers itself with.
	"""
	__metaclass__ = ManualConstructionSingleton

	log = logging.getLogger("scheduler")

	# the tick with this id is actually executed, and no tick with a smaller number can occur
	FIRST_TICK_ID = 0

	def __init__(self, timer):
		"""
		@param timer: Timer obj
		"""
		super(Scheduler, self).__init__()
		self.schedule = {}
		self.additional_cur_tick_schedule = [] # jobs to be executed at the same tick they were added
		self.calls_by_instance = {} # for get_classinst_calls
		self.cur_tick = self.__class__.FIRST_TICK_ID-1 # before ticking
		self.timer = timer
		self.timer.add_call(self.tick)

	def end(self):
		self.log.debug("Scheduler end; len: %s", len(self.schedule))
		self.schedule = None
		self.timer.remove_call(self.tick)
		self.timer = None
		super(Scheduler, self).end()

	def tick(self, tick_id):
		"""Threads main loop
		@param tick_id: int id of the tick.
		"""
		assert tick_id == self.cur_tick + 1
		self.cur_tick = tick_id

		if GAME.MAX_TICKS is not None and tick_id >= GAME.MAX_TICKS:
			horizons.main.quit()
			return

		if self.cur_tick in self.schedule:
			self.log.debug("Scheduler: tick %s, cbs: %s", self.cur_tick, len(self.schedule[self.cur_tick]))

			# use iteration method that works in case the list is altered during iteration
			# this can happen for e.g. rem_all_classinst_calls
			cur_schedule = self.schedule[self.cur_tick]
			while cur_schedule:
				callback = cur_schedule.popleft()
				# TODO: some system-level unit tests fail if this list is not processed in the correct order
				#       (i.e. if e.g. pop() was used here). This is an indication of invalid assumptions
				#       in the program and should be fixed.

				if hasattr(callback, "invalid"):
					self.log.debug("S(t:%s): %s: INVALID", tick_id, callback)
					continue
				self.log.debug("S(t:%s): %s", tick_id, callback)
				callback.callback()
				assert callback.loops >= -1
				if callback.loops != 0:
					self.add_object(callback, readd=True)
				else: # gone for good
					if callback.class_instance in self.calls_by_instance:
						# this can already be removed by e.g. rem_all_classinst_calls
						if callback.finish_callback is not None:
							callback.finish_callback()

						try:
							self.calls_by_instance[callback.class_instance].remove(callback)
						except ValueError:
							pass # also the callback can be deleted by e.g. rem_call
			del self.schedule[self.cur_tick]

			self.log.debug("Scheduler: finished tick %s", self.cur_tick)

		# run jobs added in the loop above
		self._run_additional_jobs()

		assert (not self.schedule) or self.schedule.iterkeys().next() > self.cur_tick

	def before_ticking(self):
		"""Called after game load and before game has started.
		Callbacks with run_in=0 are used as generic "do this as soon as the current context
		is finished". If this is done during load, it is supposed to mean tick -1, since it
		does not belong to the first tick. This method simulates this.
		"""
		self._run_additional_jobs()

	def _run_additional_jobs(self):
		for callback in self.additional_cur_tick_schedule:
			assert callback.loops == 0 # can't loop with no delay
			callback.callback()
		self.additional_cur_tick_schedule = []

	def add_object(self, callback_obj, readd=False):
		"""Adds a new CallbackObject instance to the callbacks list for the first time
		@param callback_obj: CallbackObject type object, containing all necessary  information
		@param readd: Whether this object is added another time (looped)
		"""
		if callback_obj.loops > 0:
			callback_obj.loops -= 1
		if callback_obj.run_in == 0: # run in the current tick
			self.additional_cur_tick_schedule.append(callback_obj)
		else: # default: run in future tick
			interval = callback_obj.loop_interval if readd else callback_obj.run_in
			tick_key = self.cur_tick + interval
			if not tick_key in self.schedule:
				self.schedule[tick_key] = deque()
			callback_obj.tick = tick_key
			self.schedule[tick_key].append(callback_obj)
			if not readd:  # readded calls haven't been removed here
				if not callback_obj.class_instance in self.calls_by_instance:
					self.calls_by_instance[callback_obj.class_instance] = []
				self.calls_by_instance[callback_obj.class_instance].append( callback_obj )

	def add_new_object(self, callback, class_instance, run_in=1, loops=1, loop_interval=None, finish_callback=None):
		"""Creates a new CallbackObject instance and calls the self.add_object() function.
		@param callback: lambda function callback, which is called run_in ticks.
		@param class_instance: class instance the function belongs to.
		@param run_in: int number of ticks after which the callback is called. Defaults to 1, run next tick.
		@param loops: How often the callback is called. -1 = infinite times. Defaults to 1, run once.
		@param loop_interval: Delay between subsequent loops in ticks. Defaults to run_in."""
		callback_obj = _CallbackObject(self, callback, class_instance, run_in, loops, loop_interval, finish_callback=finish_callback)
		self.add_object(callback_obj)

	def rem_object(self, callback_obj):
		"""Removes a CallbackObject from all callback lists
		@param callback_obj: CallbackObject to remove
		@return: int, number of removed calls
		"""
		removed_objs = 0
		if self.schedule is not None:
			for key in self.schedule:
				while callback_obj in self.schedule[key]:
					self.schedule[key].remove(callback_obj)
					self.calls_by_instance[callback_obj.class_instance].remove(callback_obj)
					removed_objs += 1

		if not self.calls_by_instance[callback_obj.class_instance]:
			del self.calls_by_instance[callback_obj.class_instance]

		return removed_objs

	def rem_all_classinst_calls(self, class_instance):
		"""Removes all callbacks from the scheduler that belong to the class instance class_inst."""
		"""
		for key in self.schedule:
			callback_objects = self.schedule[key]
			for i in xrange(len(callback_objects) - 1, -1, -1):
				if callback_objects[i].class_instance is class_instance:
					del callback_objects[i]
		"""
		if class_instance in self.calls_by_instance:
			for callback_obj in self.calls_by_instance[class_instance]:
				callback_obj.invalid = True # don't remove, finding them all takes too long
			del self.calls_by_instance[class_instance]

		# filter additional callbacks as well
		self.additional_cur_tick_schedule = \
		    [cb for cb in self.additional_cur_tick_schedule
		        if cb.class_instance is not class_instance]

	def rem_call(self, instance, callback):
		"""Removes all callbacks of 'instance' that are 'callback'
		@param instance: the instance that would execute the call
		@param callback: the function to remove
		@return: int, number of removed calls
		"""
		assert callable(callback)
		removed_calls = 0
		for key in self.schedule:
			callback_objects = self.schedule[key]
			for i in xrange(len(callback_objects) - 1, -1, -1):
				if (callback_objects[i].class_instance is instance
				    and callback_objects[i].callback == callback
				    and not hasattr(callback_objects[i], "invalid")):
					del callback_objects[i]
					removed_calls += 1

		test = 0
		if removed_calls > 0: # there also must be calls in the calls_by_instance dict
			for i in xrange(len(self.calls_by_instance[instance]) - 1, -1, -1):
				obj = self.calls_by_instance[instance][i]
				if obj.callback == callback:
					del self.calls_by_instance[instance][i]
					test += 1
			assert test == removed_calls, "%s, %s" % (test, removed_calls)
			if not self.calls_by_instance[instance]:
				del self.calls_by_instance[instance]

		for i in xrange(len(self.additional_cur_tick_schedule) - 1, -1, -1):
			if self.additional_cur_tick_schedule[i].class_instance is instance and \
				self.additional_cur_tick_schedule[i].callback == callback:
					del callback_objects[i]
					removed_calls += 1

		return removed_calls

	def get_classinst_calls(self, instance, callback=None):
		"""Returns all CallbackObjects of instance.
		Optionally, a specific callback can be specified.
		@param instance: the instance to execute the call
		@param callback: None to get all calls of instance,
		                 else only calls that execute callback.
		@return: dict, entries: { CallbackObject: remaining_ticks_to_executing }
		"""
		calls = {}
		if instance in self.calls_by_instance:
			for callback_obj in self.calls_by_instance[instance]:
				if  callback is None or callback_obj.callback == callback:
					calls[callback_obj] = callback_obj.tick - self.cur_tick
		return calls

	def get_remaining_ticks(self, instance, callback, assert_present=True):
		"""Returns in how many ticks a callback is executed. You must specify 1 single call.
		@param *: just like get_classinst_calls
		@param assert_present: assert that there must be sucha call
		@return int or possbile None if not assert_present"""
		calls = self.get_classinst_calls(instance, callback)
		if assert_present:
			assert len(calls) == 1, 'got %i calls for %s %s: %s' % (len(calls), instance, callback, [str(i) for i in calls])
			return calls.itervalues().next()
		else:
			return calls.itervalues().next() if calls else None

	def get_ticks(self, seconds):
		"""Call propagated to time instance"""
		return self.timer.get_ticks(seconds)

	def get_ticks_of_month(self):
		return self.timer.get_ticks(GAME.INGAME_TICK_INTERVAL)


class _CallbackObject(object):
	"""Class used by the TimerManager Class to organize callbacks."""
	def __init__(self, scheduler, callback, class_instance, run_in, loops, loop_interval, finish_callback=None):
		"""Creates the CallbackObject instance.
		@param scheduler: reference to the scheduler, necessary to react properly on weak reference callbacks
		@see Scheduler.add_new_object
		"""
		assert run_in >= 0, "Can't schedule callbacks in the past, run_in must be a non negative number"
		assert (loops > 0) or (loops == -1), \
			"Loop count must be a positive number or -1 for infinite repeat"
		assert callable(callback)
		assert loop_interval is None or loop_interval > 0

		self.callback = callback
		self.finish_callback = finish_callback

		self.run_in = run_in
		self.loops = loops
		self.loop_interval = loop_interval if loop_interval is not None else run_in
		self.class_instance = class_instance

	def __str__(self):
		cb = str(self.callback)
		if "_move_tick" in cb: # very crude measure to reduce log noise
			return "(_move_tick,%s)" %  self.class_instance.worldid

		return "SchedCb(%s on %s)" % (cb, self.class_instance)

########NEW FILE########
__FILENAME__ = session
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import errno
import os
import os.path
import logging
import json
import traceback
import time
from random import Random

import horizons.globals
import horizons.main

from horizons.ai.aiplayer import AIPlayer
from horizons.gui.ingamegui import IngameGui
from horizons.command.building import Tear
from horizons.util.dbreader import DbReader
from horizons.command.unit import RemoveUnit
from horizons.scheduler import Scheduler
from horizons.extscheduler import ExtScheduler
from horizons.view import View
from horizons.world import World
from horizons.entities import Entities
from horizons.util.living import LivingObject, livingProperty
from horizons.util.savegameaccessor import SavegameAccessor
from horizons.util.worldobject import WorldObject
from horizons.util.uhdbaccessor import read_savegame_template
from horizons.component.namedcomponent import NamedComponent
from horizons.component.selectablecomponent import SelectableBuildingComponent
from horizons.savegamemanager import SavegameManager
from horizons.scenario import ScenarioEventHandler
from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.constants import GAME_SPEED
from horizons.messaging import SettingChanged, MessageBus, SpeedChanged, LoadingProgress

class Session(LivingObject):
	"""The Session class represents the game's main ingame view and controls cameras and map loading.
	It is alive as long as a game is running.
	Many objects require a reference to this, which makes it a pseudo-global, from which we would
	like to move away in the long term. This is where we hope the components come into play, which
	you will encounter later.

	This is the most important class if you are going to hack on Unknown Horizons; it provides most of
	the important ingame variables.
	Here's a small list of commonly used attributes:

	* world - horizons.world instance of the currently running horizons. Stores players and islands,
		which store settlements, which store buildings, which have productions and collectors.
		Therefore, world deserves its name -- it contains the whole game state.
	* scheduler - horizons.scheduler instance. Used to execute timed events. Master of time in UH.
	* manager - horizons.manager instance. Used to execute commands (used to apply user interactions).
		There is a singleplayer and a multiplayer version. Our mp system works by the mp-manager not
		executing the commands directly, but sending them to all players, where they will be executed
		at the same tick.
	* view - horizons.view instance. Used to control the ingame camera.
	* ingame_gui - horizons.gui.ingame_gui instance. Used to control the ingame gui framework.
		(This is different from gui, which is the main menu and general session-independent gui)
	* selected_instances - Set that holds the currently selected instances (building, units).

	TUTORIAL:
	For further digging you should now be checking out the load() function.
	"""
	timer = livingProperty()
	manager = livingProperty()
	view = livingProperty()
	ingame_gui = livingProperty()
	scenario_eventhandler = livingProperty()

	log = logging.getLogger('session')

	def __init__(self, db, rng_seed=None, ingame_gui_class=IngameGui):
		super(Session, self).__init__()
		assert isinstance(db, horizons.util.uhdbaccessor.UhDbAccessor)
		self.log.debug("Initing session")
		self.db = db # main db for game data (game.sql)
		# this saves how often the current game has been saved
		self.savecounter = 0
		self.is_alive = True

		self._clear_caches()

		#game
		self.random = self.create_rng(rng_seed)
		assert isinstance(self.random, Random)
		self.timer = self.create_timer()
		Scheduler.create_instance(self.timer)
		self.manager = self.create_manager()
		self.view = View()
		Entities.load(self.db)
		self.scenario_eventhandler = ScenarioEventHandler(self) # dummy handler with no events

		#GUI
		self._ingame_gui_class = ingame_gui_class

		self.selected_instances = set()
		# List of sets that holds the player assigned unit groups.
		self.selection_groups = [set()] * 10

		self._old_autosave_interval = None

	def start(self):
		"""Actually starts the game."""
		self.timer.activate()
		self.scenario_eventhandler.start()
		self.reset_autosave()
		SettingChanged.subscribe(self._on_setting_changed)

	def reset_autosave(self):
		"""(Re-)Set up autosave. Called if autosave interval has been changed."""
		# get_uh_setting returns floats like 4.0 and 42.0 since slider stepping is 1.0.
		interval = int(horizons.globals.fife.get_uh_setting("AutosaveInterval"))
		if interval != self._old_autosave_interval:
			self._old_autosave_interval = interval
			ExtScheduler().rem_call(self, self.autosave)
			if interval != 0: #autosave
				self.log.debug("Initing autosave every %s minutes", interval)
				ExtScheduler().add_new_object(self.autosave, self, interval * 60, -1)

	def _on_setting_changed(self, message):
		if message.setting_name == 'AutosaveInterval':
			self.reset_autosave()

	def create_manager(self):
		"""Returns instance of command manager (currently MPManager or SPManager)"""
		raise NotImplementedError

	def create_rng(self, seed=None):
		"""Returns a RNG (random number generator). Must support the python random.Random interface"""
		raise NotImplementedError

	def create_timer(self):
		"""Returns a Timer instance."""
		raise NotImplementedError

	@classmethod
	def _clear_caches(cls):
		"""Clear all data caches in global namespace related to a session"""
		WorldObject.reset()
		NamedComponent.reset()
		AIPlayer.clear_caches()
		SelectableBuildingComponent.reset()

	def end(self):
		self.log.debug("Ending session")
		self.is_alive = False

		# Has to be done here, cause the manager uses Scheduler!
		Scheduler().rem_all_classinst_calls(self)
		ExtScheduler().rem_all_classinst_calls(self)

		horizons.globals.fife.sound.end()

		# these will call end() if the attribute still exists by the LivingObject magic
		self.ingame_gui = None # keep this before world

		if hasattr(self, 'world'):
			# must be called before the world ref is gone, but may not exist yet while loading
			self.world.end()
		self.world = None
		self.view = None
		self.manager = None
		self.timer = None
		self.scenario_eventhandler = None

		Scheduler().end()
		Scheduler.destroy_instance()

		self.selected_instances = None
		self.selection_groups = None

		self._clear_caches()

		# discard() in case loading failed and we did not yet subscribe
		SettingChanged.discard(self._on_setting_changed)
		MessageBus().reset()

	def quit(self):
		self.end()
		horizons.main.quit_session()

	def autosave(self):
		raise NotImplementedError
	def quicksave(self):
		raise NotImplementedError
	def quickload(self):
		raise NotImplementedError
	def save(self, savegame=None):
		raise NotImplementedError

	def load(self, options):
		"""Loads a map. Key method for starting a game."""
		"""
		TUTORIAL: Here you see how the vital game elements (and some random things that are also required)
		are initialized.
		"""
		if options.is_scenario:
			# game_identifier is a yaml file, that contains reference to actual map file
			self.scenario_eventhandler = ScenarioEventHandler(self, options.game_identifier)
			# scenario maps can be normal maps or scenario maps:
			map_filename = self.scenario_eventhandler.get_map_file()
			options.game_identifier = os.path.join(SavegameManager.scenario_maps_dir, map_filename)
			if not os.path.exists(options.game_identifier):
				options.game_identifier = os.path.join(SavegameManager.maps_dir, map_filename)
			options.is_map = True

		self.log.debug("Session: Loading from %s", options.game_identifier)
		savegame_db = SavegameAccessor(options.game_identifier, options.is_map, options) # Initialize new dbreader
		savegame_data = SavegameManager.get_metadata(savegame_db.db_path)
		self.view.resize_layers(savegame_db)

		# load how often the game has been saved (used to know the difference between
		# a loaded and a new game)
		self.savecounter = savegame_data.get('savecounter', 0)

		if savegame_data.get('rng_state', None):
			rng_state_list = json.loads(savegame_data['rng_state'])
			# json treats tuples as lists, but we need tuples here, so convert back
			def rec_list_to_tuple(x):
				if isinstance(x, list):
					return tuple(rec_list_to_tuple(i) for i in x)
				else:
					return x
			rng_state_tuple = rec_list_to_tuple(rng_state_list)
			# changing the rng is safe for mp, as all players have to have the same map
			self.random.setstate(rng_state_tuple)

		LoadingProgress.broadcast(self, 'session_create_world')
		self.world = World(self) # Load horizons.world module (check horizons/world/__init__.py)
		self.world._init(savegame_db, options.force_player_id, disasters_enabled=options.disasters_enabled)
		self.view.load(savegame_db, self.world) # load view
		if not self.is_game_loaded():
			options.init_new_world(self)
		else:
			# try to load scenario data
			self.scenario_eventhandler.load(savegame_db)
		self.manager.load(savegame_db) # load the manager (there might be old scheduled ticks).
		LoadingProgress.broadcast(self, "session_index_fish")
		self.world.init_fish_indexer() # now the fish should exist

		# load the old gui positions and stuff
		# Do this before loading selections, they need the minimap setup
		LoadingProgress.broadcast(self, "session_load_gui")
		self.ingame_gui = self._ingame_gui_class(self)
		self.ingame_gui.load(savegame_db)

		Scheduler().before_ticking()
		savegame_db.close()

		assert hasattr(self.world, "player"), 'Error: there is no human player'
		LoadingProgress.broadcast(self, "session_finish")
		"""
		TUTORIAL:
		That's it. After that, we call start() to activate the timer, and we're live.
		From here on you should dig into the classes that are loaded above, especially the world class
		(horizons/world/__init__.py). It's where the magic happens and all buildings and units are loaded.
		"""

	def speed_set(self, ticks, suggestion=False):
		"""Set game speed to ticks ticks per second"""
		old = self.timer.ticks_per_second
		self.timer.ticks_per_second = ticks
		self.view.map.setTimeMultiplier(float(ticks) / float(GAME_SPEED.TICKS_PER_SECOND))
		if old == 0 and self.timer.tick_next_time is None: # back from paused state
			if self.paused_time_missing is None:
				# happens if e.g. a dialog pauses the game during startup on hotkeypress
				self.timer.tick_next_time = time.time()
			else:
				self.timer.tick_next_time = time.time() + (self.paused_time_missing / ticks)
		elif ticks == 0 or self.timer.tick_next_time is None:
			# go into paused state or very early speed change (before any tick)
			if self.timer.tick_next_time is not None:
				self.paused_time_missing = (self.timer.tick_next_time - time.time()) * old
			else:
				self.paused_time_missing = None
			self.timer.tick_next_time = None
		else:
			"""
			Under odd circumstances (anti-freeze protection just activated, game speed
			decremented multiple times within this frame) this can delay the next tick
			by minutes. Since the positive effects of the code aren't really observeable,
			this code is commented out and possibly will be removed.

			# correct the time until the next tick starts
			time_to_next_tick = self.timer.tick_next_time - time.time()
			if time_to_next_tick > 0: # only do this if we aren't late
				self.timer.tick_next_time += (time_to_next_tick * old / ticks)
			"""

		SpeedChanged.broadcast(self, old, ticks)

	def speed_up(self):
		if self.speed_is_paused():
			AmbientSoundComponent.play_special('error')
			return
		if self.timer.ticks_per_second in GAME_SPEED.TICK_RATES:
			i = GAME_SPEED.TICK_RATES.index(self.timer.ticks_per_second)
			if i + 1 < len(GAME_SPEED.TICK_RATES):
				self.speed_set(GAME_SPEED.TICK_RATES[i + 1])
		else:
			self.speed_set(GAME_SPEED.TICK_RATES[0])

	def speed_down(self):
		if self.speed_is_paused():
			AmbientSoundComponent.play_special('error')
			return
		if self.timer.ticks_per_second in GAME_SPEED.TICK_RATES:
			i = GAME_SPEED.TICK_RATES.index(self.timer.ticks_per_second)
			if i > 0:
				self.speed_set(GAME_SPEED.TICK_RATES[i - 1])
		else:
			self.speed_set(GAME_SPEED.TICK_RATES[0])

	_pause_stack = 0 # this saves the level of pausing
	# e.g. if two dialogs are displayed, that pause the game,
	# unpause needs to be called twice to unpause the game. cf. #876
	def speed_pause(self, suggestion=False):
		self.log.debug("Session: Pausing")
		self._pause_stack += 1
		if not self.speed_is_paused():
			self.paused_ticks_per_second = self.timer.ticks_per_second
			self.speed_set(0, suggestion)

	def speed_unpause(self, suggestion=False):
		self.log.debug("Session: Unpausing")
		if self.speed_is_paused():
			self._pause_stack -= 1
			if self._pause_stack == 0:
				self.speed_set(self.paused_ticks_per_second)

	def speed_toggle_pause(self, suggestion=False):
		if self.speed_is_paused():
			self.speed_unpause(suggestion)
		else:
			self.speed_pause(suggestion)

	def speed_is_paused(self):
		return (self.timer.ticks_per_second == 0)

	def is_game_loaded(self):
		"""Checks if the current game is a new one, or a loaded one.
		@return: True if game is loaded, else False
		"""
		return (self.savecounter > 0)

	def remove_selected(self):
		self.log.debug('Removing %s', self.selected_instances)
		for instance in [inst for inst in self.selected_instances]:
			if instance.is_building:
				if instance.tearable and instance.owner is self.world.player:
					self.log.debug('Attempting to remove building %s', inst)
					Tear(instance).execute(self)
					self.selected_instances.discard(instance)
				else:
					self.log.debug('Unable to remove building %s', inst)
			elif instance.is_unit:
				if instance.owner is self.world.player:
					self.log.debug('Attempting to remove unit %s', inst)
					RemoveUnit(instance).execute(self)
					self.selected_instances.discard(instance)
				else:
					self.log.debug('Unable to remove unit %s', inst)
			else:
				self.log.error('Unable to remove unknown object %s', instance)

	def _do_save(self, savegame):
		"""Actual save code.
		@param savegame: absolute path"""
		assert os.path.isabs(savegame)
		self.log.debug("Session: Saving to %s", savegame)
		try:
			if os.path.exists(savegame):
				os.unlink(savegame)
			self.savecounter += 1

			db = DbReader(savegame)
		except IOError as e: # usually invalid filename
			headline = _("Failed to create savegame file")
			descr = _("There has been an error while creating your savegame file.")
			advice = _("This usually means that the savegame name contains unsupported special characters.")
			self.ingame_gui.open_error_popup(headline, descr, advice, unicode(e))
			# retry with new savegamename entered by the user
			# (this must not happen with quicksave/autosave)
			return self.save()
		except OSError as e:
			if e.errno != errno.EACCES:
				raise
			self.ingame_gui.open_error_popup(
				_("Access is denied"),
				_("The savegame file could be read-only or locked by another process.")
			)
			return self.save()

		try:
			read_savegame_template(db)

			db("BEGIN")
			self.world.save(db)
			self.view.save(db)
			self.ingame_gui.save(db)
			self.scenario_eventhandler.save(db)

			# Store RNG state
			rng_state = json.dumps(self.random.getstate())
			SavegameManager.write_metadata(db, self.savecounter, rng_state)

			# Make sure everything gets written now
			db("COMMIT")
			db.close()
			return True
		except Exception:
			self.log.error("Save Exception:")
			traceback.print_exc()
			# remove invalid savegamefile (but close db connection before deleting)
			db.close()
			os.unlink(savegame)
			return False

########NEW FILE########
__FILENAME__ = spsession
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import random

from horizons.session import Session
from horizons.manager import SPManager
from horizons.constants import SINGLEPLAYER
from horizons.savegamemanager import SavegameManager
from horizons.timer import Timer

class SPSession(Session):
	"""Session tailored for singleplayer games."""

	def create_manager(self):
		return SPManager(self)

	def create_rng(self, seed=None):
		return random.Random(seed if seed is not None else SINGLEPLAYER.SEED)

	def create_timer(self):
		return Timer(freeze_protection=SINGLEPLAYER.FREEZE_PROTECTION)

	def load(self, *args, **kwargs):
		super(SPSession, self).load(*args, **kwargs)
		# single player games start right away
		self.start()

	def autosave(self):
		"""Called automatically in an interval"""
		self.log.debug("Session: autosaving")
		success = self._do_save(SavegameManager.create_autosave_filename())
		if success:
			SavegameManager.delete_dispensable_savegames(autosaves=True)
			self.ingame_gui.message_widget.add('AUTOSAVE')

	def quicksave(self):
		"""Called when user presses the quicksave hotkey"""
		self.log.debug("Session: quicksaving")
		# call saving through horizons.main and not directly through session, so that save errors are handled
		success = self._do_save(SavegameManager.create_quicksave_filename())
		if success:
			SavegameManager.delete_dispensable_savegames(quicksaves=True)
			self.ingame_gui.message_widget.add('QUICKSAVE')
		else:
			headline = _("Failed to quicksave.")
			descr = _("An error happened during quicksave.") + u"\n" + _("Your game has not been saved.")
			advice = _("If this error happens again, please contact the development team: "
			           "{website}").format(website="http://unknown-horizons.org/support/")
			self.ingame_gui.open_error_popup(headline, descr, advice)

	def save(self, savegamename=None):
		"""Saves a game
		@param savegamename: string with the full path of the savegame file or None to let user pick one
		@return: bool, whether no error happened (user aborting dialog means success)
		"""
		if savegamename is None:
			savegamename = self.ingame_gui.show_select_savegame(mode='save')
			if savegamename is None:
				return True # user aborted dialog
			savegamename = SavegameManager.create_filename(savegamename)

		success = self._do_save(savegamename)
		if success:
			self.ingame_gui.message_widget.add('SAVED_GAME')
		return success

########NEW FILE########
__FILENAME__ = timer
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import time
import horizons.globals

from horizons.util.living import LivingObject
from horizons.constants import GAME, GAME_SPEED
from horizons.scheduler import Scheduler

class Timer(LivingObject):
	"""
	The Timer class manages game-ticks, every tick executes a set of functions in its call lists,
	this is especially important for multiplayer, to allow synchronous play.
	"""
	TEST_PASS, TEST_SKIP = xrange(0, 2)

	ACCEPTABLE_TICK_DELAY = 0.2 # sec
	DEFER_TICK_ON_DELAY_BY = 0.4 # sec


	def __init__(self, tick_next_id=Scheduler.FIRST_TICK_ID, freeze_protection=False):
		"""
		NOTE: timer will not start until activate() is called
		@param tick_next_id: int next tick id
		@param freeze_protection: whether to check for tick delay and strech time in case (breaks mp)
		"""
		super(Timer, self).__init__()
		self._freeze_protection = freeze_protection
		self.ticks_per_second = GAME_SPEED.TICKS_PER_SECOND
		self.tick_next_id = tick_next_id
		self.tick_next_time = 0.0
		self.tick_func_test = []
		self.tick_func_call = []

	def activate(self):
		"""Actually starts the timer"""
		horizons.globals.fife.pump.append(self.check_tick)

	def end(self):
		if self.check_tick in horizons.globals.fife.pump:
			horizons.globals.fife.pump.remove(self.check_tick)
		super(Timer, self).end()

	def add_test(self, call):
		"""Adds a call to the test list
		@param call: function function which should be added
		"""
		self.tick_func_test.append(call)

	def add_call(self, call):
		"""Adds a call to the call list
		@param call: function function which should be added
		"""
		self.tick_func_call.append(call)

	def remove_test(self, call):
		"""Removes a call from the test list
		@param call: function function which were added before
		"""
		self.tick_func_test.remove(call)

	def remove_call(self, call):
		"""Removes a call from the call list
		@param call: function function which were added before
		"""
		self.tick_func_call.remove(call)

	def get_ticks(self, seconds):
		"""Returns the number of ticks for the specified number of seconds.
		@param seconds: number of seconds that are to be converted into ticks
		@return: int
		"""
		return int(round( seconds*GAME_SPEED.TICKS_PER_SECOND))

	def check_tick(self):
		"""check_tick is called by the engines _pump function to signal a frame idle."""
		if self.ticks_per_second == 0:
			return
		while time.time() >= self.tick_next_time and (GAME.MAX_TICKS is None or self.tick_next_id <= GAME.MAX_TICKS):
			for f in self.tick_func_test:
				r = f(self.tick_next_id)
				if r == self.TEST_SKIP:
					# If a callback changed the speed to zero, we have to exit
					if self.ticks_per_second != 0:
						self.tick_next_time = (self.tick_next_time or time.time()) + 1.0 / self.ticks_per_second
					return
			if self._freeze_protection and self.tick_next_time:
				# stretch time if we're too slow
				diff = time.time() - self.tick_next_time
				if diff > self.ACCEPTABLE_TICK_DELAY:
					self.tick_next_time += self.DEFER_TICK_ON_DELAY_BY
			for f in self.tick_func_call:
				f(self.tick_next_id)
			self.tick_next_id += 1
			if self.ticks_per_second == 0:
				# If a callback changed the speed to zero, we have to exit
				return
			self.tick_next_time = (self.tick_next_time or time.time()) + 1.0 / self.ticks_per_second

########NEW FILE########
__FILENAME__ = atlasloadingthread
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os
import sys
import subprocess
import threading
from thread import error as ThreadError  # raised by threading.Lock.release

import horizons.globals
from horizons.constants import VERSION, GFX, PATHS

class AtlasLoadingThread(threading.Thread):
	"""Class used to preload and generate the atlas files if necessary"""

	def __init__(self, lock, command_line_arguments):
		threading.Thread.__init__(self)
		self.lock = lock
		self.command_line_arguments = command_line_arguments

	def run(self):
		self.lock.acquire()
		if self.command_line_arguments.atlas_generation and not self.command_line_arguments.gui_test and \
		   VERSION.IS_DEV_VERSION and horizons.globals.fife.get_uh_setting('AtlasesEnabled') \
		   and horizons.globals.fife.get_uh_setting('AtlasGenerationEnabled'):
			horizons_path = os.path.dirname(horizons.__file__)
			args = [sys.executable, os.path.join(horizons_path, 'engine', 'generate_atlases.py'),
			        str(horizons.globals.fife.get_uh_setting('MaxAtlasSize'))]
			atlas_generator = subprocess.Popen(args, stdout=None, stderr=subprocess.STDOUT)
			atlas_generator.wait()
			assert atlas_generator.returncode is not None
			if atlas_generator.returncode != 0:
				print 'Atlas generation failed. Continuing without atlas support.'
				print 'This just means that the game will run a bit slower.'
				print 'It will still run fine unless there are other problems.'
				print
				GFX.USE_ATLASES = False
			else:
				GFX.USE_ATLASES = True
				PATHS.DB_FILES = PATHS.DB_FILES + (PATHS.ATLAS_DB_PATH, )
		self.lock.release()
########NEW FILE########
__FILENAME__ = buildingindexer
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.python import decorators


class BuildingIndexer(object):
	"""
	Indexes a subset of the buildings on an island to improve nearby building
	lookup performance.

	Used to answer queries of the form 'I am at (x, y), where is the closest / random
	building that provides resource X in my range'.
	"""

	def __init__(self, radius, coords_list, random=None, buildings=None):
		"""
		Create a BuildingIndexer
		@param radius: int, maximum required radius of the buildings
		@param coords_list: list of tuples, the coordinates of the island
		@param random: the rng of the session
		@param buildings: initial list of buildings. Will only be read.
		"""
		self.radius = radius
		self._map = {}
		for coords in coords_list:
			self._map[coords] = BuildingIndex(coords, random)
		self._add_set = set()
		self._remove_set = set()
		self._changed = False

		if buildings:
			self._update(add_buildings=buildings, initial=True)

	def add(self, building):
		self._remove_set.discard(building)
		self._add_set.add(building)
		self._changed = True

	def remove(self, building):
		self._add_set.discard(building)
		self._remove_set.add(building)
		self._changed = True

	def _update(self, add_buildings=None, initial=False):
		"""
		@param add_buildings: Don't use unless you know why.
		@param initial: can be set on first call as optimization
		"""
		for building in self._remove_set:
			for coords in building.position.get_radius_coordinates(self.radius, include_self=True):
				try:
					index = self._map[coords]
				except KeyError:
					continue # should be faster than contains check, since usually True
				index._remove_set.add(building)
				index._add_set.discard(building)
				index._changed = True

		if not add_buildings:
			add_buildings = self._add_set
		for building in add_buildings:
			for coords in building.position.get_radius_coordinates(self.radius, include_self=True):
				try:
					index = self._map[coords]
				except KeyError:
					continue # should be faster than contains check, since usually True
				if not initial:
					index._remove_set.discard(building)
				index._add_set.add(building)
				index._changed = True

		self._changed = False
		self._add_set.clear()
		self._remove_set.clear()

	def get_buildings_in_range(self, coords):
		"""
		Returns all buildings in range in the form of a Building generator
		@param coords: tuple, the point around which to get the buildings
		"""
		if coords in self._map:
			if self._changed:
				self._update()
			return self._map[coords].get_buildings_in_range()
		return []

	def get_random_building_in_range(self, coords):
		"""
		Returns a random building in range or None if one doesn't exist
		Don't use this for user interactions unless you want to break multiplayer
		@param coords: tuple, the point around which to get the building
		"""
		if coords in self._map:
			if self._changed:
				self._update()
			return self._map[coords].get_random_building_in_range()
		return None

	def get_num_buildings_in_range(self, coords):
		"""
		Returns the number of buildings in range of the position
		@param coords: tuple, the center point
		"""
		if coords in self._map:
			if self._changed:
				self._update()
			return self._map[coords].get_num_buildings_in_range()



class BuildingIndex(object):
	"""
	Indexes buildings around a tile to improve nearby building lookup speed.
	The code isn't particularly pretty for performance reasons.
	"""

	def __init__(self, coords, random):
		self._coords = coords
		self._random = random
		self._add_set = set()
		self._remove_set = set()
		self._list = []
		self._changed = False

	def _update(self):
		new_list = []
		for element in self._list:
			if element[5] not in self._remove_set:
				new_list.append(element)

		x = self._coords[0]
		y = self._coords[1]
		for building in self._add_set:
			pos = building.position
			left = pos.left
			right = pos.right
			top = pos.top
			bottom = pos.bottom

			x_diff = left - x
			if x_diff < x - right:
				x_diff = x - right
			if x_diff < 0:
				x_diff = 0

			y_diff = top - y
			if y_diff < y - bottom:
				y_diff = y - bottom
			if y_diff < 0:
				y_diff = 0

			new_list.append((x_diff * x_diff + y_diff * y_diff, top, bottom, left, right, building))

		self._list = new_list
		self._list.sort()

		self._add_set.clear()
		self._remove_set.clear()
		self._changed = False

	def get_buildings_in_range(self):
		if self._changed:
			self._update()
		for element in self._list:
			yield element[5]

	def get_random_building_in_range(self):
		if self._changed:
			self._update()
		if self._list:
			return self._random.choice(self._list)[5]
		return None

	def get_num_buildings_in_range(self):
		if self._changed:
			self._update()
		return len(self._list)


# apply make_constant to classes
decorators.bind_all(BuildingIndexer)
decorators.bind_all(BuildingIndex)

########NEW FILE########
__FILENAME__ = changelistener
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import traceback

from horizons.util.python.callback import Callback
from horizons.util.python.weakmethodlist import WeakMethodList

class ChangeListener(object):
	"""Trivial ChangeListener.
	The object that changes and the object that listens have to inherit from this class.
	An object calls _changed every time something has changed, obviously.
	This function calls every Callback, that has been registered to listen for a change.
	NOTE: ChangeListeners aren't saved, they have to be reregistered on load
	NOTE: RemoveListeners must not access the object, as it is in progress of being destroyed.
	"""

	log = logging.getLogger('changelistener')

	def __init__(self, *args, **kwargs):
		super(ChangeListener, self).__init__()
		self.__init()

	def __init(self):
		self.__listeners = WeakMethodList()
		self.__remove_listeners = WeakMethodList()
		# number of event calls
		# if any event is triggered increase the number, after all callbacks are executed decrease it
		# if it reaches 0 it means that in the current object all event callbacks were executed
		self.__event_call_number = 0
		self.__hard_remove = True

	def __remove_listener(self, listener_list, listener):
		# check if the listener should be hard removed
		# if so switch it in the list to None
		try:
			if self.__hard_remove:
				listener_list.remove(listener)
			else:
				listener_list[listener_list.index(listener)] = None
		except ValueError as e: # nicer error:
			raise ValueError(str(e)+
			                 "\nTried to remove: "+str(listener)+"\nat "+str(self)+
			                 "\nList: "+str([str(i) for i in listener_list]))

	def __call_listeners(self, listener_list):
		# instead of removing from list, switch the listener in position to None
		# this way, iteration won't be affected while listeners may modify the list
		self.__hard_remove = False
		# increase the event call number
		self.__event_call_number += 1
		for listener in listener_list:
			if listener:
				try:
					listener()
				except ReferenceError as e:
					# listener object is dead, don't crash since it doesn't need updates now anyway
					self.log.warning('The dead are listening to %s: %s', self, e)
					traceback.print_stack()

		self.__event_call_number -= 1

		if self.__event_call_number == 0:
			self.__hard_remove = True
			listener_list[:] = [ l for l in listener_list if l ]

	## Normal change listener
	def add_change_listener(self, listener, call_listener_now=False, no_duplicates=False):
		assert callable(listener)
		if not no_duplicates or listener not in self.__listeners:
			self.__listeners.append(listener)
		if call_listener_now: # also call if duplicate is added
			listener()

	def remove_change_listener(self, listener):
		self.__remove_listener(self.__listeners, listener)

	def has_change_listener(self, listener):
		return (listener in self.__listeners)

	def discard_change_listener(self, listener):
		"""Remove listener if it's there"""
		if self.has_change_listener(listener):
			self.remove_change_listener(listener)

	def clear_change_listeners(self):
		"""Removes all change listeners"""
		self.__listeners = WeakMethodList()

	def _changed(self):
		"""Calls every listener when an object changed"""
		self.__call_listeners(self.__listeners)

	## Removal change listener
	def add_remove_listener(self, listener, no_duplicates=False):
		"""A listener that listens for removal of the object"""
		assert callable(listener)
		if no_duplicates and listener in self.__remove_listeners:
			return # don't allow duplicate entries
		self.__remove_listeners.append(listener)

	def remove_remove_listener(self, listener):
		self.__remove_listener(self.__remove_listeners, listener)

	def has_remove_listener(self, listener):
		return (listener in self.__remove_listeners)

	def discard_remove_listener(self, listener):
		if self.has_remove_listener(listener):
			self.remove_remove_listener(listener)

	def load(self, db, world_id):
		self.__init()

	def remove(self):
		self.__call_listeners(self.__remove_listeners)
		self.end()

	def end(self):
		self.__listeners = None
		self.__remove_listeners = None


""" Class decorator that adds methods for listening for certain events to a class.
These methods get added automatically (eventname is the name you pass to the decorator):
- add_eventname_listener(listener):
    Adds listener callback. This function must take the object as first parameter plus
		any parameter that might be provided additionally to on_eventname.
- remove_eventname_listener(listener);
    Removes a listener previously added.
- has_eventname_listener(listener)
    Checks if a certain listener has been added.
- on_eventname
    This is used to call the callbacks when the event occurred.
    Additional parameters may be provided, which are passed to the callback.

The goal is to simplify adding special listeners, as for example used in the
production_finished listener.
"""
def metaChangeListenerDecorator(event_name):
	def decorator(clas):
		list_name = "__"+event_name+"_listeners"
		event_call_number = "__"+event_name+"call_number"
		hard_remove_event = "__hard_remove"+event_name
		# trivial changelistener operations
		def add(self, listener):
			assert callable(listener)
			getattr(self, list_name).append(listener)

		def rem(self, listener):
			if getattr(self, hard_remove_event):
				getattr(self, list_name).remove(listener)
			else:
				listener_list = getattr(self, list_name)
				listener_list[listener_list.index(listener)] = None

		def has(self, listener):
			return listener in getattr(self, list_name)

		def on(self, *args, **kwargs):
			setattr(self, hard_remove_event, False)
			call_number = getattr(self, event_call_number) + 1
			setattr(self, event_call_number, call_number)
			for f in getattr(self, list_name):
				if f:
					# workaround for encapsuled arguments
					if isinstance(f, Callback):
						f()
					else:
						f(self, *args, **kwargs)

			call_number = getattr(self, event_call_number) - 1
			setattr(self, event_call_number, call_number)
			if getattr(self, event_call_number) == 0:
				setattr(self, hard_remove_event, True)
				setattr(self, list_name, [ l for l in getattr(self, list_name) if l ])

		# add methods to class
		setattr(clas, "add_"+event_name+"_listener", add)
		setattr(clas, "remove_"+event_name+"_listener", rem)
		setattr(clas, "has_"+event_name+"_listener", has)
		setattr(clas, "on_"+event_name, on)

		# use black __new__ magic to add the methods to the instances
		# think of it as being executed in __init__
		old_new = clas.__new__
		def new(cls, *args, **kwargs):
			# this is a proposed way of calling the "old" new:
			#obj = super(cls, cls).__new__(cls)
			# which results in endless recursion, if you construct an instance of a class,
			# that inherits from a base class on which the decorator has been applied.
			# therefore, this workaround is used:
			obj = old_new(cls)
			setattr(obj, list_name, [])
			setattr(obj, event_call_number, 0)
			setattr(obj, hard_remove_event, True)
			return obj
		clas.__new__ = staticmethod(new)
		return clas
	return decorator

########NEW FILE########
__FILENAME__ = checkupdates
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import platform
import webbrowser
import urllib
import urllib2
import socket

from fife.extensions.pychan.widgets import Button

from horizons.constants import NETWORK, VERSION
from horizons.gui.windows import Popup


class UpdateInfo(object):
	INVALID, READY, UNINITIALIZED = range(3)
	def __init__(self):
		self.status = UpdateInfo.UNINITIALIZED
		self.version = None
		self.link = None

TIMEOUT = 5.0 # we should be done before the user can start a game
def check_for_updates(info):
	"""Check if there's a new version.
	@return update file contents or None"""
	# make sure to always set info.status, but only when we're done
	# no updates for git version
	if VERSION.IS_DEV_VERSION:
		info.status = UpdateInfo.INVALID
		return

	# only updates for operating systems missing a packagemanagement
	if (platform.system() == 'Windows' or platform.system() == 'Darwin'):
		# retrieve current version w.r.t. the local version.
		# this way, possible configurations of different most recent versions should be handleable in the future.
		data = urllib.urlencode( {"my_version" : VERSION.RELEASE_VERSION} )
		url = NETWORK.UPDATE_FILE_URL
		try:
			u = urllib2.urlopen( url + "?" + data, timeout=TIMEOUT )
		except (urllib2.URLError, socket.timeout):
			# Silently ignore the failed update, printing stuff might crash the game
			# if no console is available
			info.status = UpdateInfo.INVALID
			return

		version = u.readline()
		link = u.readline()
		u.close()

		version = version[:-1] # remove newlines
		link = link[:-1] # remove newlines

		if version != VERSION.RELEASE_VERSION:
			# there is a new version
			info.version = version
			info.link = link
			info.status = UpdateInfo.READY
		else:
			info.status = UpdateInfo.INVALID
	else:
		info.status = UpdateInfo.INVALID

class VersionHint(Popup):

	def __init__(self, windows, info):
		self.info = info

		title = _("New version of Unknown Horizons")
		text = _("There is a more recent release of Unknown Horizons ({new_version}) "
				 "than the one you are currently using ({old_version}).").format(
				new_version=info.version,
				old_version=VERSION.RELEASE_VERSION)

		super(VersionHint, self).__init__(windows, title, text)

	def prepare(self, **kwargs):
		super(VersionHint, self).prepare(**kwargs)

		dl_btn = Button(name="dl", text=_("Click to download"))
		dl_btn.position = (48, 138) # i've tried, this button cannot be placed in a sane way
		def do_dl():
			webbrowser.open(self.info.link)
			dl_btn.text = _("A page has been opened in your browser.")
			self._gui.adaptLayout()
		dl_btn.capture(do_dl)

		self._gui.addChild(dl_btn)


def show_new_version_hint(gui, info):
	"""
	@param gui: main gui (Gui)
	@param info: UpdateInfo instance
	"""
	window = VersionHint(gui.windows, info)
	gui.windows.open(window)

########NEW FILE########
__FILENAME__ = cmdlineoptions
#!/usr/bin/env python2
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import datetime
import optparse
import re


def get_option_parser():
	"""Returns inited OptionParser object"""
	from horizons.constants import VERSION
	p = optparse.OptionParser(usage="%prog [options]", version=VERSION.string())
	p.add_option("-d", "--debug", dest="debug", action="store_true",
	             default=False, help="Enable debug output to stderr and a logfile.")
	p.add_option("--fife-path", dest="fife_path", metavar="<path>",
	             help="Specify the path to FIFE root directory.")
	p.add_option("--restore-settings", dest="restore_settings", action="store_true", default=False,
	             help="Restores the default settings. "
	                  "Useful if Unknown Horizons crashes on startup due to misconfiguration.")
	p.add_option("--mp-master", dest="mp_master", metavar="<ip:port>",
	             help="Specify alternative multiplayer master server.")
	p.add_option("--mp-bind", dest="mp_bind", metavar="<ip:port>",
	             help="Specify network address to bind local network client to. "
	                  "This is useful if NAT holepunching is not working but you can forward a static port.")

	start_uh = optparse.OptionGroup(p, "Starting Unknown Horizons")
	start_uh.add_option("--start-map", dest="start_map", metavar="<map>",
	             help="Starts <map>. <map> is the mapname.")
	start_uh.add_option("--start-random-map", dest="start_random_map", action="store_true",
	             help="Starts a random map.")
	start_uh.add_option("--start-specific-random-map", dest="start_specific_random_map",
	             metavar="<seed>", help="Starts a random map with seed <seed>.")
	start_uh.add_option("--start-scenario", dest="start_scenario", metavar="<scenario>",
	             help="Starts <scenario>. <scenario> is the scenarioname.")
	start_uh.add_option("--start-dev-map", dest="start_dev_map", action="store_true",
	             default=False, help="Starts the development map without displaying the main menu.")
	start_uh.add_option("--load-game", dest="load_game", metavar="<game>",
	             help="Loads a saved game. <game> is the saved game's name.")
	start_uh.add_option("--load-last-quicksave", dest="load_quicksave", action="store_true",
	             help="Loads the last quicksave.")
	start_uh.add_option("--edit-map", dest="edit_map", metavar="<map>",
	             help="Edit map <map>.")
	start_uh.add_option("--edit-game-map", dest="edit_game_map", metavar="<game>",
	             help="Edit the map from the saved game <game>.")
	p.add_option_group(start_uh)

	ai_group = optparse.OptionGroup(p, "AI options")
	ai_group.add_option("--ai-players", dest="ai_players", metavar="<ai_players>",
	             type="int", default=0,
	             help="Uses <ai_players> AI players (excludes the possible human-AI hybrid; defaults to 0).")
	ai_group.add_option("--human-ai-hybrid", dest="human_ai", action="store_true",
	             help="Makes the human player a human-AI hybrid (for development only).")
	ai_group.add_option("--force-player-id", dest="force_player_id",
	             metavar="<force_player_id>", type="int", default=None,
	             help="Set the player with id <force_player_id> as the active (human) player.")
	ai_group.add_option("--ai-highlights", dest="ai_highlights", action="store_true",
	             help="Shows AI plans as highlights (for development only).")
	ai_group.add_option("--ai-combat-highlights", dest="ai_combat_highlights", action="store_true",
	             help="Highlights combat ranges for units controlled by AI Players (for development only).")
	p.add_option_group(ai_group)

	dev_group = optparse.OptionGroup(p, "Development options")
	dev_group.add_option("--debug-log-only", dest="debug_log_only", action="store_true",
	             default=False, help="Write debug output only to logfile, not to console. Implies -d.")
	dev_group.add_option("--debug-module", action="append", dest="debug_module",
	             metavar="<module>", default=[],
	             help="Enable logging for a certain logging module (for developing only).")
	dev_group.add_option("--logfile", dest="logfile", metavar="<filename>",
	             help="Writes log to <filename> instead of to the uh-userdir")
	dev_group.add_option("--profile", dest="profile", action="store_true",
	             default=False, help="Enable profiling (for developing only).")
	dev_group.add_option("--max-ticks", dest="max_ticks", metavar="<max_ticks>", type="int",
	             help="Run the game for <max_ticks> ticks.")
	dev_group.add_option("--no-freeze-protection", dest="freeze_protection", action="store_false",
	             default=True, help="Disable freeze protection.")
	dev_group.add_option("--string-previewer", dest="stringpreview", action="store_true",
	             default=False, help="Enable the string previewer tool for scenario writers")
	dev_group.add_option("--no-preload", dest="nopreload", action="store_true",
	             default=False, help="Disable preloading while in main menu")
	dev_group.add_option("--game-speed", dest="gamespeed", metavar="<game_speed>", type="float",
	             help="Run the game in the given speed (Values: 0.5, 1, 2, 3, 4, 6, 8, 11, 20)")
	dev_group.add_option("--gui-test", dest="gui_test", metavar="<test>",
	             default=False, help=optparse.SUPPRESS_HELP)
	dev_group.add_option("--gui-log", dest="log_gui", action="store_true",
	             default=False, help="Log gui interactions")
	dev_group.add_option("--sp-seed", dest="sp_seed", metavar="<seed>", type="int",
	             help="Use this seed for singleplayer sessions.")
	dev_group.add_option("--generate-minimap", dest="generate_minimap",
	             metavar="<parameters>", help=optparse.SUPPRESS_HELP)
	dev_group.add_option("--create-mp-game", action="store_true", dest="create_mp_game",
	             help="Create an multiplayer game with default settings.")
	dev_group.add_option("--join-mp-game", action="store_true", dest="join_mp_game",
	             help="Join first multiplayer game.")
	if VERSION.IS_DEV_VERSION:
		dev_group.add_option("--no-atlas-generation", action="store_false", dest="atlas_generation",
	             help="Disable atlas generation.")
	# Add dummy default variables for the DEV_VERSION groups above when in release mode
	p.set_defaults(atlas_generation=True)
	p.add_option_group(dev_group)

	return p


class ManPageFormatter(optparse.HelpFormatter):
	"""Formatter that extracts our huge option list into manpage format.

	Inspired by and mostly copied from this blog post:
	http://andialbrecht.wordpress.com/2009/03/17/creating-a-man-page-with-distutils-and-optparse/
	"""
	def __init__(self, indent_increment=2, max_help_position=24,
			width=72, short_first=1):
		optparse.HelpFormatter.__init__(self,
			indent_increment, max_help_position, width, short_first)

	def _markup(self, text):
		return text.replace('-', r'\-')

	def optmarkup(self, text):
		"""Highlight flags only"""
		replace_with = r'\\fB\1\\fR'
		pattern = r'(--\w*)(?:, )?'
		text = re.sub(pattern, replace_with, text)
		pattern = r'(-\w*)'
		text = re.sub(pattern, replace_with, text)
		return self._markup(text)

	def format_text(self, text):
		return self._markup(text)

	def format_usage(self, usage):
		"""Overridden, else it would print 'options.py usage'."""
		return r'''\
." some portability stuff
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
." disable hyphenation and justification (adjust text to left margin only)
.nh
.ad l
.SH "NAME"
unknown-horizons \- real-time strategy/simulation game
.SH "SYNOPSIS"
.HP \w'\fBunknown\-horizons\fR\ 'u
\fBunknown\-horizons\fR [{\fB\-h\fR\ |\ \fB\-\-help\fR}]
.SH "DESCRIPTION"
.PP
\fBUnknown Horizons\fR: isometric 2D real-time strategy/simulation fun.
.br
It puts emphasis on the economy and city building aspects.
.br
Expand your small settlement to a strong and wealthy colony, collect
taxes and supply your inhabitants with valuable goods.
.br
Increase your power with a well balanced economy, with strategic
trade and diplomacy.
.SH "OPTIONS"'''

	def format_heading(self, text):
		"""Format an option group.."""
		if self.level == 0:
			return u''
		return r'''.TP
\fB%s\fR
''' % self._markup(text.upper())

	def format_option(self, option, *args, **kwargs):
		"""Format a single option.

		The base class takes care to replace custom optparse values."""
		result = []
		opts = self.option_strings[option]
		help_text = self.expand_default(option)
		result.append(r'''\
.TP
.B
%s
%s
''' % (self.optmarkup(opts), self._markup(help_text)))

		return ''.join(result)


if __name__ == '__main__':
	formatter = ManPageFormatter()

	p = get_option_parser()
	p.formatter = formatter

	today = datetime.date.today()
	print r'''\
'\" t
.\"     Title: unknown-horizons
.\"    Author: The Unknown Horizons Team <team@unknown-horizons.org>
.\"      Date: {0}
.\"  Language: English
.\"
.TH "UNKNOWN\-HORIZONS" "6" "{0}" "unknown-horizons" "Unknown Horizons User Commands"
'''.format(datetime.date.today())
	p.print_help()

	print r'''\
.SH "BUGS"
.PP
The bugtracker can be found at \fBhttp://bugs.unknown-horizons.org\fR\&.
.SH "AUTHOR"
.PP
\fBThe Unknown Horizons Team\fR <\&team@unknown-horizons\&.org\&>
.RS 4
.RE
.SH "COPYRIGHT"
.br
Copyright \(co 2008-2014 The Unknown Horizons Team
.br
.PP
Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU General Public License, Version 3 or (at your option) any later
version published by the Free Software Foundation\&.
.sp
'''

########NEW FILE########
__FILENAME__ = color
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import horizons.globals


class ColorMeta(type):
	"""Metaclass allows iteration and indexing of the Color class.

	Example:

		for c in Color:
			pass

		Color['red']
		Color[0]
	"""

	def __getitem__(cls, key):
		"""Gets a color by name or id in the db"""
		query = horizons.globals.db('SELECT red, green, blue FROM colors '
		                            'WHERE name = ? OR id = ?', key, key)
		try:
			rgb = query[0]
		except IndexError:
			raise KeyError('No color defined for this name or id: %s' % key)
		else:
			return Color(*rgb)

	def __iter__(cls):
		"""Iterate over all available colors in the db."""
		colors = horizons.globals.db('SELECT id FROM colors ORDER BY id')
		colors = (Color[id] for id, in colors)
		return iter(colors)


class Color(object):
	"""Class for saving a color.
	Colors are saved in 32 bit rgb-format with an alpha value (for transparency).
	32bit mean that each of the for values can only occupy 8 bit, i.e. the value is between
	0 and 255.

	Attributes:
	 r, g, b, a: Color values + Alpha
	 name: name of the Color or None
	"""
	__metaclass__ = ColorMeta

	def __init__(self, r=0, g=0, b=0, a=255):
		"""
		@params: int (0, 255)
		"""
		self.r, self.g, self.b, self.a = r, g, b, a
		query = horizons.globals.db('SELECT name, rowid FROM colors '
		                            'WHERE red = ? AND green = ? AND blue = ?',
		                            self.r, self.g, self.b)
		try:
			# load name for the color, if it's a standard color
			self.name, self.id = query[0]
		except IndexError:
			# id is not set to indicate this is a nondefault color
			self.name = None

	def to_tuple(self):
		"""Returns color as (r, g, b)-tuple, where each value is between 0 and 255"""
		return (self.r, self.g, self.b)

	@property
	def is_default_color(self):
		return hasattr(self, 'id')

	def __str__(self):
		return 'Color' + str(self.to_tuple())

	def __eq__(self, other):
		return self.to_tuple() == other.to_tuple()

	def __hash__(self):
		return hash("%s%s%s%s" % (self.r, self.g, self.b, self.a))

########NEW FILE########
__FILENAME__ = dbreader
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import sqlite3
import re

from horizons.util.python import decorators

class DbReader(object):
	"""Class that handles connections to sqlite databases
	@param file: str containing the database file."""
	def __init__(self, dbfile):
		self.db_path = dbfile
		self.connection = sqlite3.connect(dbfile)
		self.connection.isolation_level = None
		def regexp(expr, item):
			r = re.compile(expr)
			return r.match(item) is not None
		self.connection.create_function("regexp", 2, regexp)
		self.cur = self.connection.cursor()

	@decorators.make_constants()
	def __call__(self, command, *args):
		"""Executes a sql command.
		@param command: str containing the raw sql command, with ? as placeholders for values (eg. SELECT ? FROM ?). command must not end with ';', it's added automatically here.
		@param args: tuple containing the values to add into the command.
		"""
		assert not command.endswith(";")
		command = '%s;' % command
		self.cur.execute(command, args)
		return self.cur.fetchall()

	@decorators.cachedmethod
	def cached_query(self, command, *args):
		"""Executes a sql command and saves its result in a dict.
		@params, return: same as in __call__"""
		return self(command, *args)

	def execute_many(self, command, parameters):
		"""Executes a sql command for each sequence or mapping
		found in parameters.
		@param command: same as in __call__
		@param parameters: sequence or iterator"""
		return self.cur.executemany(command, parameters)

	def execute_script(self, script):
		"""Executes a multiline script.
		@param script: multiline str containing an sql script."""
		return self.cur.executescript(script)

	def close(self):
		"""Closes the db"""
		self.connection.close()

########NEW FILE########
__FILENAME__ = difficultysettings
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.python import decorators

class DifficultySettings(object):
	EASY_LEVEL = 0
	DEFAULT_LEVEL = 1

	levels = {}

	@classmethod
	def get_settings(cls, level):
		if level not in cls.levels:
			return None
		return cls.levels[level](level)

	@classmethod
	def register_levels(cls):
		cls.levels[cls.EASY_LEVEL] = EasySettings
		cls.levels[cls.DEFAULT_LEVEL] = DefaultSettings

class DifficultyClass(object):
	def __init__(self, level):
		self.level = level

class DefaultSettings(DifficultyClass):
	extra_happiness_constant = 0
	happiness_multiplier = 1
	tax_multiplier = 1

class EasySettings(DefaultSettings):
	tax_multiplier = 1.5

DifficultySettings.register_levels()

decorators.bind_all(DifficultySettings)
decorators.bind_all(DifficultyClass)
decorators.bind_all(DefaultSettings)
decorators.bind_all(EasySettings)

########NEW FILE########
__FILENAME__ = inventorychecker
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.scheduler import Scheduler
from copy import deepcopy

class InventoryChecker(object):

	def __init__(self, message_class, storage_component, check_interval):
		"""Message class is a subclass of message that this checker will broadcast when the storage_component given has change in its inventory.
		This check is done every check_interval ticks."""
		self.__message_class = message_class
		self.__storage_component = storage_component
		self.__inventory_copy = deepcopy(storage_component.inventory._storage)

		self.__check_interval = check_interval

		# Check for updates every few ticks
		Scheduler().add_new_object(self.check_inventory_changed, self, loops=-1, loop_interval=self.__check_interval)

	def check_inventory_changed(self):
		"""Function that checks whether the settlements inventory has changed from the last time checked"""
		inventory = self.__storage_component.inventory._storage
		if inventory != self.__inventory_copy:
			self.__message_class.broadcast(self)
			self.__inventory_copy = deepcopy(inventory)


	def remove(self):
		"""Clean up"""
		Scheduler().rem_all_classinst_calls(self)
		self.__inventory_copy = None
		self.__storage_component = None
		self.__message_class = None
########NEW FILE########
__FILENAME__ = lastactiveplayersettlementmanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import weakref

from horizons.util.python.singleton import ManualConstructionSingleton
from horizons.util.shapes import Point
from horizons.util.worldobject import WorldObject
from horizons.messaging import NewPlayerSettlementHovered, HoverSettlementChanged, NewSettlement

def resolve_weakref(ref):
	"""Resolves a weakref to a hardref, where the ref itself can be None"""
	if ref is None:
		return None
	else:
		return ref()

def create_weakref(obj):
	"""Safe create weakref, that supports None"""
	if obj is None:
		return None
	else:
		return weakref.ref(obj)

class LastActivePlayerSettlementManager(object):
	"""Keeps track of the last active (hovered over) player's settlement.
	Provides it as global reference, but stores as weak reference as not to disturb anything.

	Provide new mouse info to it via update().
	Retrieve settlement via get().
	Hooks itself to view automatically.
	"""
	__metaclass__ = ManualConstructionSingleton

	def __init__(self, session):
		self.session = session
		self.session.view.add_change_listener(self._on_scroll)

		# settlement mouse currently is above or None
		self._cur_settlement = None

		# last settlement of player mouse was on, only None at startup
		self._last_player_settlement = None

		# whether last known event was not on a player settlement
		# can be used to detect reentering the area of _last_player_settlement
		self._last_player_settlement_hovered_was_none = True

		NewSettlement.subscribe(self._on_new_settlement_created)

	def save(self, db):
		if self._last_player_settlement is not None:
			db("INSERT INTO last_active_settlement(type, value) VALUES(?, ?)", "PLAYER", self._last_player_settlement().worldid)
		if self._cur_settlement is not None:
			db("INSERT INTO last_active_settlement(type, value) VALUES(?, ?)", "ANY", self._cur_settlement().worldid)

		db("INSERT INTO last_active_settlement(type, value) VALUES(?, ?)", "LAST_NONE_FLAG", self._last_player_settlement_hovered_was_none)

	def load(self, db):
		data = db('SELECT value FROM last_active_settlement WHERE type = "PLAYER"')
		self._last_player_settlement = weakref.ref(WorldObject.get_object_by_id(data[0][0])) if data else None
		data = db('SELECT value FROM last_active_settlement WHERE type = "ANY"')
		self._cur_settlement = weakref.ref(WorldObject.get_object_by_id(data[0][0])) if data else None
		data = db('SELECT value FROM last_active_settlement WHERE type = "LAST_NONE_FLAG"')
		self._last_player_settlement_hovered_was_none = bool(data[0][0])

	def remove(self):
		self._last_player_settlement = None
		self._cur_settlement = None
		self.session.view.remove_change_listener(self._on_scroll)
		NewSettlement.unsubscribe(self._on_new_settlement_created)

	def update(self, current):
		"""Update to new world position. Sets internal state to new settlement or no settlement
		@param current: some kind of position coords with x- and y-values"""
		settlement = self.session.world.get_settlement(Point(int(round(current.x)), int(round(current.y))))

		# check if it's a new settlement independent of player
		if resolve_weakref(self._cur_settlement) is not settlement:
			self._cur_settlement = create_weakref(settlement)
			HoverSettlementChanged.broadcast(self, settlement)

		# player-sensitive code
		new_player_settlement = weakref.ref(settlement) if \
		  settlement and settlement.owner.is_local_player else None

		need_msg = False
		# check if actual last player settlement is a new one
		if new_player_settlement is not None and \
		   resolve_weakref(self._last_player_settlement) is not resolve_weakref(new_player_settlement):
			self._last_player_settlement = new_player_settlement
			need_msg = True

		# check if we changed to or from None
		# this doesn't change the last settlement, but we need a message
		if (new_player_settlement is None and not self._last_player_settlement_hovered_was_none) or \
		   (new_player_settlement is not None and self._last_player_settlement_hovered_was_none):
			need_msg = True

		if need_msg:
			NewPlayerSettlementHovered.broadcast(self, resolve_weakref(new_player_settlement))
		self._last_player_settlement_hovered_was_none = (new_player_settlement is None)

	def get(self, get_current_pos=False):
		"""The last settlement belonging to the player the mouse has hovered above.
		@param get_current_pos: get current position even if it's None
		"""
		if get_current_pos and self._last_player_settlement_hovered_was_none:
			return None
		return resolve_weakref(self._last_player_settlement)

	def get_current_settlement(self):
		"""Returns settlement mouse currently hovers over or None"""
		return resolve_weakref(self._cur_settlement)

	def _on_scroll(self):
		"""Called when view changes. Scrolling and zooming can change cursor position."""
		if not hasattr(self.session, "cursor"): # not inited yet
			return
		pos = self.session.cursor.__class__.last_event_pos
		if pos is not None:
			loc = self.session.cursor.get_exact_world_location(pos)
			self.update(loc)

	def _on_new_settlement_created(self, msg):
		# if the player has created a new settlement, it is the current one, even
		# if the mouse hasn't hovered over it. Required when immediately entering build menu.
		if msg.settlement.owner.is_local_player:
			self._last_player_settlement = weakref.ref(msg.settlement)
			self._last_player_settlement_hovered_was_none = False

########NEW FILE########
__FILENAME__ = living
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

class livingProperty(object):
	"""livingProperty's are used to assign properties to a class, similar to python properties.
	The extra benefit with livingPropertys is, that they will call the previously assigned
	instances' end() function one being replaced. Note that all classes that are assigned
	to a livingProperty should subclass the LivingObject class, to ensure the existence of
	the end() method.
	The main purpose of the livingProperty is to ensure the correct deletion of objects,
	so Classes that derive from the LivingObject class will usually have all their __del__
	code in the end() method, to ensure it gets called upon being overwritten, even if
	other references to it exist (which should not!).
	Here is a small example on the usage:

	class Livetest(object):
	    prop1 = new livingProperty()

	    def __init__(self):
	        prop1 = new TestObj()
			prop1 = new Test2Obj() // TestObj().end() is called
			prop1 = new TestObj()  // Testobj2().end() is called

	class TestObj(LivingProperty):
	    def end():
		    print "TestObj end"

	class Testobj2(LivingProperty):
	    def end():
		    print "TestObj2 end"

	This would result in the following output:
	TestObj end
	TestObj2 end
	"""

	def __init__(self):
		self.__value = None

	def __get__(self, obj, cls=None):
		return self.__value

	def __set__(self, obj, value):
		if hasattr(self.__value, 'end'):
			self.__value.end()
		self.__value = value

	def __delete__(self, obj):
		self.__set__(obj, None)

	def __del__(self):
		self.__value = None

class LivingObject(object):
	"""This class is intended to be used with the livingProperty to ensure all variables
	are safely deinited when intended by the programmer. The livingProperty calls the
	livingObject's end() function to deinit the object. This mostly replacing the __del__
	function, as its behavior is not well behaved."""

	def end(self):
		"""Put all the code the object needs to end safely here. Make sure it always
		contains the super(YOUROBJECT, self).end() call, to ensure all parentobjects are
		deinited correctly."""
		pass

########NEW FILE########
__FILENAME__ = actionsetloader
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os
import logging

import horizons.globals

from horizons.constants import PATHS
from horizons.util.loaders.loader import GeneralLoader
from horizons.util.loaders.jsondecoder import JsonDecoder

class ActionSetLoader(object):
	"""The ActionSetLoader loads action sets from a directory tree. The directories loaded
	begin with 'as_' to tell tell the loader that they are an action set. directory
	structure is as follows: <action_set>/<action>/<rotation>/<framenumber>.png
	for example that would be: fisher1/work/90/0.png
	Note that all directories except for the rotation dir, all dirs have to be empty and
	must not include additional action sets.
	"""

	log = logging.getLogger("util.loaders.actionsetloader")

	action_sets = {}
	_loaded = False

	@classmethod
	def _find_action_sets(cls, dir):
		"""Traverses recursively starting from dir to find action sets.
		It is similar to os.walk, but more optimized for this use case."""
		for entry in os.listdir(dir):
			full_path = os.path.join(dir, entry)
			if entry.startswith("as_"):
				cls.action_sets[entry] = GeneralLoader._load_action(full_path)
			else:
				if os.path.isdir(full_path) and entry != ".DS_Store":
					cls._find_action_sets(full_path)

	@classmethod
	def load(cls):
		if not cls._loaded:
			cls.log.debug("Loading action_sets...")
			if not horizons.globals.fife.use_atlases:
				cls._find_action_sets(PATHS.ACTION_SETS_DIRECTORY)
			else:
				cls.action_sets = JsonDecoder.load(PATHS.ACTION_SETS_JSON_FILE)
			cls.log.debug("Done!")
			cls._loaded = True

	@classmethod
	def get_sets(cls):
		if not cls._loaded:
			cls.load()
		return cls.action_sets
########NEW FILE########
__FILENAME__ = jsondecoder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import json

class JsonDecoder:
	@classmethod
	def load(cls, path):
		def _decode_list(lst):
			newlist = []
			for i in lst:
				if isinstance(i, unicode):
					i = i.encode('utf-8')
				elif isinstance(i, list):
					i = _decode_list(i)
				newlist.append(i)
			return newlist

		def _decode_dict(dct):
			newdict = {}
			for k, v in dct.iteritems():
				if isinstance(k, unicode):
					try:
						k = int(k)
					except ValueError:
						k = k.encode('utf-8')
				if isinstance(v, unicode):
					v = v.encode('utf-8')
				elif isinstance(v, list):
					v = _decode_list(v)
				newdict[k] = v
			return newdict

		with open(path, "rb") as f:
			return json.load(f, encoding="ascii", object_hook=_decode_dict)

########NEW FILE########
__FILENAME__ = loader
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from collections import defaultdict
import os
import re
import glob
import logging

from horizons.constants import ACTION_SETS

class GeneralLoader(object):
	"""The ActionSetLoader loads action sets from a directory tree. The directories loaded
	begin with 'as_' to tell tell the loader that they are an action set. directory
	structure is as follows: <action_set>/<action>/<rotation>/<framenumber>.png
	for example that would be: fisher1/work/90/0.png
	Note that all directories except for the rotation dir, all dirs have to be empty and
	must not include additional action sets.
	"""

	log = logging.getLogger("util.loaders.loader")

	@classmethod
	def _load_files(cls, directory, time):
		"""Loads the files for a specific rotation
		@param directory: directory to load files from. Example:
		                 'content/gfx/units/lumberjack/'
		@return: dict of 'file: anim_end' items
		"""
		files = glob.glob(os.path.join(directory, "*.png"))
		# Make sure entries are in the correct order: 'zz1.png' < '2.png' < '09.png'
		files.sort(key=lambda f: int(re.search(r'\d+', os.path.basename(f)).group()))

		anim_length = {} # dict containing 'file: anim_end' items
		for i, filename in enumerate(files, start=1):
			anim_length[filename] = i * (time/1000.0) / len(files)
		return anim_length

	@classmethod
	def _load_rotation(cls, directory):
		"""Loads the rotations + files for a specific action
		@param directory: directory to load files from. Example:
		                 'content/gfx/units/lumberjack/'
		@return: dict of 'rotation: filedict' items. See _load_files for example.
		"""
		dirs = cls._action_set_directories(directory)

		for dirname in dirs:
			if dirname.startswith("tm_"):
				time = int(dirname.split('_')[1])
				dirs.remove(dirname)
				break
		else:
			time = ACTION_SETS.DEFAULT_ANIMATION_LENGTH

		rotations = {}
		for dirname in dirs:
			try:
				rotations[int(dirname)] = cls._load_files(os.path.join(directory, dirname), time)
			except Exception as e:
				raise Exception("Failed to load action sets from %s with time %s: %s" %
							 (os.path.join(directory, dirname), time, e))
		return rotations

	@classmethod
	def _load_action(cls, directory):
		"""Loads the actions + rotations + files for a specific action
		@param directory: directory to load files from. Example:
		                 'content/gfx/units/lumberjack/'
		@return: dict of 'action: rotationdict' items. See _load_rotation for example.
		"""
		dirs = cls._action_set_directories(directory)
		actions = {}
		for dirname in dirs:
			basedir = os.path.join(directory, dirname)
			if os.path.isdir(basedir):
				actions[dirname] = cls._load_rotation(basedir)
				if 'streets' in directory:
					actions.update(cls._load_mirrored_roads(dirname, actions[dirname]))
		return actions

	@classmethod
	def _load_mirrored_roads(cls, base_action, existing_files):
		actions = defaultdict(dict)
		for base_rotation, path in existing_files.iteritems():
			action = base_action
			for iteration in range(1, 4):
				rotation = (base_rotation + iteration * 90) % 360
				action = cls._rotate_roads(action)
				actions[action][rotation] = path
		return actions

	@classmethod
	def _rotate_roads(cls, action):
		"""Rotate around 'abcd' and 'efgh' like this:
		>>> G = GeneralLoader()
		>>> G._rotate_roads('a')
		'b'
		>>> G._rotate_roads('bd')
		'ac'
		>>> G._rotate_roads('acde')
		'abdf'
		>>> G._rotate_roads('abdf')
		'abcg'
		"""
		if action == 'single':
			return action

		base = 'abcda' + 'efghe'

		new_action = []
		for char in action:
			idx = base.index(char)
			new_action += base[idx + 1]

		action = ''.join(sorted(new_action))
		return action

	@classmethod
	def _action_set_directories(cls, directory):
		"""Returns directories that are important for loading action sets.
		Discards everything else that we found living there in the past.
		"""
		junk = set(('.DS_Store', ))
		return [d for d in os.listdir(directory)
		          if d not in junk]

########NEW FILE########
__FILENAME__ = sqliteanimationloader
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife

import horizons.globals

from horizons.util.loaders.actionsetloader import ActionSetLoader
from horizons.util.loaders.tilesetloader import TileSetLoader

class SQLiteAnimationLoader(object):
	"""Loads animations from a SQLite database.
	"""
	def __init__(self):
		pass

	def loadResource(self, location):
		"""
		@param location: String with the location. See below for details:
		Location format: <animation_id>:<command>:<params> (e.g.: "123:shift:left-16, bottom-8)
		Available commands:
		- shift:
		Shift the image using the params left, right, center, middle for x shifting and
		y-shifting with the params: top, bottom, center, middle.
		A param looks like this: "param_x(+/-)value, param_y(+/-)value" (e.g.: left-16, bottom+8)
		- cut:
		#TODO: complete documentation
		"""
		commands = location.split(':')
		id = commands.pop(0)
		actionset, action, rotation = id.split('+')
		commands = zip(commands[0::2], commands[1::2])

		# Set the correct loader based on the actionset
		loader = None
		loader = self._get_loader(actionset)

		ani = fife.Animation.createAnimation()
		frame_start, frame_end = 0.0, 0.0
		for file in sorted(loader.get_sets()[actionset][action][int(rotation)].iterkeys()):
			frame_end = loader.get_sets()[actionset][action][int(rotation)][file]
			img = horizons.globals.fife.imagemanager.load(file)
			for command, arg in commands:
				if command == 'shift':
					x, y = arg.split(',')
					if x.startswith('left'):
						x = int(x[4:]) + int(img.getWidth() // 2)
					elif x.startswith('right'):
						x = int(x[5:]) - int(img.getWidth() // 2)
					elif x.startswith(('center', 'middle')):
						x = int(x[6:])
					else:
						x = int(x)

					if y.startswith('top'):
						y = int(y[3:]) + int(img.getHeight() // 2)
					elif y.startswith('bottom'):
						y = int(y[6:]) - int(img.getHeight() // 2)
					elif y.startswith(('center', 'middle')):
						y = int(y[6:])
					else:
						y = int(y)

					img.setXShift(x)
					img.setYShift(y)

			ani.addFrame(img, max(1, int((float(frame_end) - frame_start)*1000)))
			frame_start = float(frame_end)
		ani.setActionFrame(0)
		return ani

	def _get_loader(self, actionset):
			if actionset.startswith("ts_"):
				loader = TileSetLoader
			elif actionset.startswith("as_"):
				loader = ActionSetLoader
			else:
				assert False, "Invalid set being loaded: " + actionset
			return loader

	def load_image(self, file, actionset, action, rotation):
		loader = self._get_loader(actionset)
		entry = loader.get_sets()[actionset][action][int(rotation)][file]

		if horizons.globals.fife.imagemanager.exists(file):
			img = horizons.globals.fife.imagemanager.get(file)
		else:
			img = horizons.globals.fife.imagemanager.create(file)
		return img

########NEW FILE########
__FILENAME__ = sqliteatlasloader
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife

import horizons.globals

from horizons.util.loaders.actionsetloader import ActionSetLoader
from horizons.util.loaders.tilesetloader import TileSetLoader

class SQLiteAtlasLoader(object):
	"""Loads atlases and appropriate action sets from a JSON file and a SQLite database.
	"""
	def __init__(self):
		self.atlaslib = []

		# TODO: There's something wrong with ground entities if atlas.sql
		# is loaded only here, for now it's added to DB_FILES (empty file if no atlases are used)

		#f = open('content/atlas.sql', "r")
		#sql = "BEGIN TRANSACTION;" + f.read() + "COMMIT;"
		#horizons.globals.db.execute_script(sql)

		self.atlases = horizons.globals.db("SELECT atlas_path FROM atlas ORDER BY atlas_id ASC")
		self.inited = False


	def init(self):
		"""Used to lazy init the loader"""
		for (atlas,) in self.atlases:
			# print 'creating', atlas
			# cast explicit to str because the imagemanager is not able to handle unicode strings
			img = horizons.globals.fife.imagemanager.create(str(atlas))
			self.atlaslib.append(img)
		self.inited = True


	def loadResource(self, location):
		"""
		@param location: String with the location. See below for details:
		Location format: <animation_id>:<command>:<params> (e.g.: "123:shift:left-16, bottom-8)
		Available commands:
		- shift:
		Shift the image using the params left, right, center, middle for x shifting and
		y-shifting with the params: top, bottom, center, middle.
		A param looks like this: "param_x(+/-)value, param_y(+/-)value" (e.g.: left-16, bottom+8)
		- cut:
		#TODO: complete documentation
		"""
		if not self.inited:
			self.init()
		commands = location.split(':')
		id = commands.pop(0)
		actionset, action, rotation = id.split('+')
		commands = zip(commands[0::2], commands[1::2])

		ani = fife.Animation.createAnimation()

		# Set the correct loader based on the actionset
		loader = self._get_loader(actionset)


		frame_start, frame_end = 0.0, 0.0
		for file in sorted(loader.get_sets()[actionset][action][int(rotation)].iterkeys()):
			entry = loader.get_sets()[actionset][action][int(rotation)][file]
			# we don't need to load images at this point to query for its parameters
			# such as width and height because we can get those from json file
			xpos, ypos, width, height = entry[2:]

			if horizons.globals.fife.imagemanager.exists(file):
				img = horizons.globals.fife.imagemanager.get(file)
			else:
				img = horizons.globals.fife.imagemanager.create(file)
				region = fife.Rect(xpos, ypos, width, height)
				img.useSharedImage(self.atlaslib[entry[1]], region)

			for command, arg in commands:
				if command == 'shift':
					x, y = arg.split(',')
					if x.startswith('left'):
						x = int(x[4:]) + (width // 2)
					elif x.startswith('right'):
						x = int(x[5:]) - (width // 2)
					elif x.startswith(('center', 'middle')):
						x = int(x[6:])
					else:
						x = int(x)

					if y.startswith('top'):
						y = int(y[3:]) + (height // 2)
					elif y.startswith('bottom'):
						y = int(y[6:]) - (height // 2)
					elif y.startswith(('center', 'middle')):
						y = int(y[6:])
					else:
						y = int(y)

					img.setXShift(x)
					img.setYShift(y)

			frame_end = entry[0]
			ani.addFrame(img, max(1, int((float(frame_end) - frame_start)*1000)))
			frame_start = float(frame_end)
		ani.setActionFrame(0)
		return ani

	def _get_loader(self, actionset):
			if actionset.startswith("ts_"):
				loader = TileSetLoader
			elif actionset.startswith("as_"):
				loader = ActionSetLoader
			else:
				assert False, "Invalid set being loaded: " + actionset
			return loader

	def load_image(self, file, actionset, action, rotation):
		if not self.inited:
			self.init()
		loader = self._get_loader(actionset)
		entry = loader.get_sets()[actionset][action][int(rotation)][file]
		# we don't need to load images at this point to query for its parameters
		# such as width and height because we can get those from json file
		xpos, ypos, width, height = entry[2:]

		if horizons.globals.fife.imagemanager.exists(file):
			img = horizons.globals.fife.imagemanager.get(file)
		else:
			img = horizons.globals.fife.imagemanager.create(file)
			region = fife.Rect(xpos, ypos, width, height)
			img.useSharedImage(self.atlaslib[entry[1]], region)

		return img


########NEW FILE########
__FILENAME__ = tilesetloader
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os
import logging

import horizons.globals

from horizons.constants import PATHS
from horizons.util.loaders.loader import GeneralLoader
from horizons.util.loaders.jsondecoder import JsonDecoder

class TileSetLoader(object):
	"""The TileSetLoader loads tile sets from a directory tree. The directories loaded
	begin with 'ts_' to tell tell the loader that they are an action set. directory
	structure is as follows: <tile_set>/<rotation>/<framenumber>.png
	for example that would be: ts_shallow/90/0.png
	Note that all directories except for the rotation dir, all dirs have to be empty and
	must not include additional tile sets.
	"""

	log = logging.getLogger("util.loaders.tilesetloader")

	tile_sets = {}
	_loaded = False

	@classmethod
	def _find_tile_sets(cls, dir):
		"""Traverses recursively starting from dir to find action sets.
		It is similar to os.walk, but more optimized for this use case."""
		for entry in os.listdir(dir):
			full_path = os.path.join(dir, entry)
			if entry.startswith("ts_"):
				cls.tile_sets[entry] = GeneralLoader._load_action(full_path)
			else:
				if os.path.isdir(full_path) and entry != ".DS_Store":
					cls._find_tile_sets(full_path)

	@classmethod
	def load(cls):
		#print "called"
		if not cls._loaded:
			cls.log.debug("Loading tile_sets...")
			if not horizons.globals.fife.use_atlases:
				cls._find_tile_sets(PATHS.TILE_SETS_DIRECTORY)
			else:
				cls.tile_sets = JsonDecoder.load(PATHS.TILE_SETS_JSON_FILE)
			cls.log.debug("Done!")
			cls._loaded = True

	@classmethod
	def get_sets(cls):
		if not cls._loaded:
			cls.load()
		return cls.tile_sets

########NEW FILE########
__FILENAME__ = pather
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import weakref
import logging

from horizons.util.python import decorators
from horizons.util.shapes import Point

from horizons.util.pathfinding import PathBlockedError
from horizons.util.pathfinding.pathfinding import FindPath

"""
In this file, you will find an interface to the pathfinding algorithm.
We just call this interface Pather. It is used by unit to hide implementation details
of the pathfinding algorithm.
"""

class AbstractPather(object):
	"""Abstract Interface for pathfinding for use by Unit.
	Use only subclasses!"""
	log = logging.getLogger("world.pathfinding")
	def __init__(self, unit, move_diagonal, session, make_target_walkable=True):
		"""
		@param unit: instance of unit, to which the pather belongs
		@param move_diagonal: whether the unit may walk diagonally
		@param make_target_walkable: whether we should assume, that we can walk on
		                             the tiles that make up the target
		"""
		self.session = session
		self.move_diagonal = move_diagonal
		self.make_target_walkable = make_target_walkable

		self._unit = weakref.ref(unit)

		self.destination_in_building = False
		self.source_in_building = False

		self.path = None
		self.cur = None

	@property
	def unit(self):
		return self._unit()

	def _get_path_nodes(self):
		"""Returns nodes, where unit can walk on.
		Return value type must be supported by FindPath"""
		raise NotImplementedError

	def _get_blocked_coords(self):
		"""Returns blocked coordinates
		Return value type must be supported by FindPath"""
		return []

	def _check_for_obstacles(self, point):
		"""Check if the path is unexpectedly blocked by e.g. a unit
		@param point: tuple: (x, y)
		@return: bool, True if path is blocked"""
		return (point in self._get_blocked_coords())

	def _get_position(self):
		"""Returns current position considering movement status and being in a building"""
		source = self.unit.position
		if self.unit.is_moving() and self.path:
			# we are moving, use next step as source
			source = Point(*self.path[self.cur])
		else:
			# check if we are in a building
			building = self.session.world.get_building(self.unit.position)
			if building is not None:
				source = building
		return source

	def calc_path(self, destination, destination_in_building=False, check_only=False,
	              source=None):
		"""Calculates a path to destination
		@param destination: a destination supported by pathfinding
		@param destination_in_building: bool, whether destination is in a building.
		                                this makes the unit "enter the building"
		@param check_only: if True the path isn't saved
		@param source: use this as source of movement instead of self.unit.position
		@return: True iff movement is possible or the path if check_only==True"""
		# calculate our source
		if source is None:
			source = self._get_position()

		# call algorithm
		# to use a different pathfinding code, just change the following line
		path = FindPath()(source, destination, self._get_path_nodes(),
		                  self._get_blocked_coords(), self.move_diagonal,
		                  self.make_target_walkable)

		if path is None:
			return False

		if not check_only:
			# prepare movement
			self.move_on_path(path, source, destination_in_building)
		else:
			return path

		return True

	def move_on_path(self, path, source=None, destination_in_building=False):
		"""Start moving on a precalculated path.
		@param path: return value of FindPath()()
		"""
		if source is None:
			source = self._get_position()
		self.path = path
		if self.unit.is_moving():
			self.cur = 0
			self.unit.show() # make sure unit is displayed
		else:
			self.cur = -1
		self.source_in_building = hasattr(source, 'is_building') and source.is_building
		self.destination_in_building = destination_in_building

	def get_next_step(self):
		"""Returns the next step in the current movement
		@return: Point"""
		if self.cur is None:
			return None

		self.cur += 1
		if not self.path or self.cur == len(self.path):
			# movement finished
			self.cur = None
			self.path = None
			return None

		if self._check_for_obstacles(self.path[self.cur]):
			# path is suddenly blocked, find another path
			self.cur -= 1 # reset, since move is not possible
			# try to calculate another path
			if not self.calc_path(Point(*self.path[-1]), self.destination_in_building):
				self.log.info("tile suddenly %s %s blocked for %s %s",
				               self.path[self.cur][0], self.path[self.cur][1], self.unit, self.unit.worldid)
				# no other path can be found. since the problem cannot be fixed here,
				# we raise an exception
				raise PathBlockedError

		# check if we have to change visibility because of entering or leaving a building
		if self.destination_in_building and self.cur == len(self.path)-1:
			self.destination_in_building = False
			self.unit.hide()
		elif self.source_in_building and self.cur == 2:
			self.source_in_building = False
			self.unit.show()

		return Point(*self.path[self.cur])

	def get_move_source(self):
		"""Returns the source Point of the current movement.
		@return: Point or None if no path has been calculated"""
		return None if not self.path else Point(*self.path[0])

	def get_move_target(self):
		"""Returns the point where the path leads
		@return: Point or None if no path has been calculated"""
		return None if not self.path else Point(*self.path[-1])

	def end_move(self):
		"""Pretends that the path is finished in order to make the unit stop"""
		del self.path[self.cur+1:]

	def save(self, db, unitid):
		# just save each step of the path
		# current position is calculated on loading through unit position
		if self.path:
			for step in xrange(len(self.path)):
				db("INSERT INTO unit_path(`unit`, `index`, `x`, `y`) VALUES(?, ?, ?, ?)",
				    unitid, step, self.path[step][0], self.path[step][1])

	def load(self, db, worldid):
		"""
		@return: Bool, whether a path was loaded
		"""
		path_steps = db.get_unit_path(worldid)
		if path_steps is None:
			return False
		else:
			self.path = path_steps
			cur_position = self.unit.position.to_tuple()
			if cur_position in self.path:
				self.cur = self.path.index(cur_position)
			else:
				self.cur = -1
			return True


class ShipPather(AbstractPather):
	"""Pather for ships (units that move on water tiles)"""
	def __init__(self, unit, *args, **kwargs):
		super(ShipPather, self).__init__(unit, move_diagonal=True, make_target_walkable=False,
		                                 *args, **kwargs)

	def _get_path_nodes(self):
		return self.session.world.water

	def _get_blocked_coords(self):
		return self.session.world.ship_map


class FisherShipPather(ShipPather):
	"""Can also drive through shallow water"""
	def _get_path_nodes(self):
		return self.session.world.water_and_coastline

	def _get_blocked_coords(self):
		# don't let fisher be blocked by other ships (#1023)
		return []


class BuildingCollectorPather(AbstractPather):
	"""Pather for collectors, that move freely (without depending on roads)
	within the radius of their home building such as farm animals."""
	def __init__(self, unit, *args, **kwargs):
		super(BuildingCollectorPather, self).__init__(unit, move_diagonal=True, *args, **kwargs)

	def _get_path_nodes(self):
		from horizons.component.collectingcomponent import CollectingComponent
		return self.unit.home_building.get_component(CollectingComponent).path_nodes.nodes


class RoadPather(AbstractPather):
	"""Pather for collectors, that depend on roads (e.g. the one used for the warehouse)"""
	def __init__(self, unit, *args, **kwargs):
		super(RoadPather, self).__init__(unit, move_diagonal=False, *args, **kwargs)
		self.island = self.session.world.get_island(unit.position)

	def _get_path_nodes(self):
		return self.island.path_nodes.road_nodes


class SoldierPather(AbstractPather):
	"""Pather for units, that move absolutely freely (such as soldiers)
	Their path list is maintained by IslandPathNodes"""
	def __init__(self, unit, *args, **kwargs):
		super(SoldierPather, self).__init__(unit, move_diagonal=True,
		                                    make_target_walkable=False, *args, **kwargs)

	def _get_path_nodes(self):
		# island might change (e.g. when transported via ship), so reload every time
		island = self.session.world.get_island(self.unit.position)
		return island.path_nodes.nodes

	def _get_blocked_coords(self):
		return self.session.world.ground_unit_map

	def _check_for_obstacles(self, point):
		# retrieve island, island of soldier may change at any time
		island = self.session.world.get_island(self.unit.position)
		path_blocked = not island.path_nodes.is_walkable(self.path[self.cur])
		if path_blocked:
			# update list in island, so that new path calculations consider this obstacle
			island.path_nodes.reset_tile_walkability(point)
			self.log.debug("tile %s %s blocked for %s %s on island", point[0], point[1],
			                self.unit, self.unit.worldid)
			return path_blocked
		else:
			# also check in super class
			return super(SoldierPather, self)._check_for_obstacles(point)


class StaticPather(object):
	"""Misc pathing routines not depending on units.
	Does not use AbstractPather Interface"""
	@classmethod
	def get_path_on_roads(cls, island, source, destination):
		"""Returns a path that runs only on roads.
		@param island: island to search path on
		@param source, destination: Point or anything supported by FindPath
		@return: list of tuples or None in case no path is found"""
		return FindPath()(source, destination, island.path_nodes.road_nodes)


decorators.bind_all(AbstractPather)

########NEW FILE########
__FILENAME__ = pathfinding
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.util.python import decorators

"""
This file contains only the pathfinding algorithm. It is implemented in a callable class
called FindPath. You should never ever use this class directly, just through the Pather
interface.
"""

class FindPath(object):
	""" Finds best path from source to destination via a*-algo
	"best path" means path with shortest travel time, which
	is not necessarily the shortest path (cause roads have different speeds)
	"""
	log = logging.getLogger("world.pathfinding")

	@decorators.make_constants()
	def __call__(self, source, destination, path_nodes, blocked_coords=None,
		        diagonal=False, make_target_walkable=True):
		"""
		@param source: Rect, Point or BasicBuilding
		@param destination: Rect, Point or BasicBuilding
		@param path_nodes: dict { (x, y) = speed_on_coords }  or list [(x, y), ..]
		@param blocked_coords: temporarily blocked coords (e.g. by a unit) as list or dict of tuples
		@param diagonal: whether the unit is able to move diagonally
		@param make_target_walkable: whether we force the tiles of the target to be walkable,
		       even if they actually aren't (used e.g. when walking to a building)
		@return: list of coords as tuples that are part of the best path
		         (from first coord after source to first coord in destination)
						 or None if no path is found
		"""
		# assure correct call
		# commented out checks since BasicBuilding can't be imported here
		#assert isinstance(source, (Rect, Point, BasicBuilding))
		#assert isinstance(destination, (Rect, Point, BasicBuilding))
		blocked_coords = blocked_coords or []
		assert isinstance(path_nodes, (dict, list, set))
		assert isinstance(blocked_coords, (dict, list, set))

		# save args
		self.source = source
		self.destination = destination
		self.path_nodes = path_nodes
		self.blocked_coords = blocked_coords
		self.diagonal = diagonal
		self.make_target_walkable = make_target_walkable

		#self.log.debug('searching path from %s to %s. blocked: %s',
		#							 source, destination, blocked_coords)

		# prepare args
		if not self.setup():
			return None

		# execute algorithm on the args
		path = self.execute()
		self.log.debug('found path: %s', path)
		return path

	@decorators.make_constants()
	def setup(self):
		"""Sets up variables for execution of algorithm
		@return: bool, whether setup was successful"""
		# support for building
		if hasattr(self.source, 'position'):
			self.source = self.source.position
		if hasattr(self.destination, 'position'):
			self.destination = self.destination.position

		if isinstance(self.path_nodes, list) or isinstance(self.path_nodes, set):
			self.path_nodes = dict.fromkeys(self.path_nodes, 1.0)

		# check if target is blocked
		target_is_blocked = True
		for coord in self.destination.tuple_iter():
			if not coord in self.blocked_coords:
				target_is_blocked = False
		if target_is_blocked:
			#self.log.debug("FindPath: target is blocked")
			return False

		# check if target is walkable
		if not self.make_target_walkable:
			target_is_walkable = False
			for coord in self.destination:
				if coord.to_tuple() in self.path_nodes:
					target_is_walkable = True
					break
			if not target_is_walkable:
				#self.log.debug("FindPath: target is not walkable")
				return False

		return True

	@decorators.make_constants()
	def execute(self):
		"""Executes algorithm"""
		# nodes are the keys of the following dicts (x, y)
		# the val of the keys are: (previous node, distance to here,
		# distance to here + estimated distance to target)
		# we use this data structure out of speed consideration,
		# using a class would admittedly be more readable

		# values of distance is usually measured in speed
		# since you can't calculate the speed to the destination,
		# these distances are measured in space
		# this might become a problem, but this can just be fixed when
		# the values of speed or slowness and such are defined

		# nodes that weren't processed but will be processed:
		to_check = {}
		# nodes that have been processed:
		checked = {}

		destination = self.destination
		destination_to_tuple_distance_func = destination.get_distance_function((0, 0))

		source_coords = self.source.get_coordinates()
		for coords in source_coords:
			to_check[coords] = (None, 0, destination_to_tuple_distance_func(destination, coords))

		# if any node in dest_coords_set has been processed
		# (i.e. is in checked), a good path has been found
		dest_coords_set = destination.get_coordinates()
		dest_coords_set = set(dest_coords_set)
		if not self.make_target_walkable:
			# restrict destination coords to walkable tiles, by default they are counted as walkable
			# the manual set intersection is used because set.intersection(dict) doesn't take advantage of the fast lookup
			dest_coords_set = set(coords for coords in dest_coords_set if coords in self.path_nodes)
		if not dest_coords_set:
			return None

		from heapq import heappush, heappop
		heap = []
		for coords, data in to_check.iteritems():
			heappush(heap, (data[2], coords))

		# pull dereferencing out of loop
		path_nodes = self.path_nodes
		blocked_coords = self.blocked_coords

		# loop until we have no more nodes to check
		while to_check:

			# find next node to check, which is the one with best rating
			(_, cur_node_coords) = heappop(heap)
			cur_node_data = to_check[cur_node_coords]

			# shortcuts:
			x = cur_node_coords[0]
			y = cur_node_coords[1]

			# find possible neighbors
			# optimization TODO: use data structures more suitable for contains-check
			if self.diagonal:
				# all relevant adjacent neighbors
				x_p1 = x+1
				x_m1 = x-1
				y_p1 = y+1
				y_m1 = y-1
				neighbors = ( i for i in ((x_m1, y_m1), (x_m1, y),
				                          (x_m1, y_p1), (x, y_m1),
				                          (x, y_p1), (x_p1, y_m1),
				                          (x_p1, y), (x_p1, y_p1) )
				              if # conditions are sorted by likelihood in ship worst case
				                 i not in checked
				                 and (   i in path_nodes
				                      or i in source_coords
				                      or i in dest_coords_set)
				                 and i not in blocked_coords )
			else:
				# all relevant vertical and horizontal neighbors
				neighbors = ( i for i in ((x-1, y), (x+1, y),
				                          (x, y-1), (x, y+1) )
				              if
				                   (   i in path_nodes
				                    or i in source_coords
				                    or i in dest_coords_set )
			                      and i not in checked
			                      and i not in blocked_coords )

			# Profiling info: In the worst case, this for-loop takes 80% of the time.
			# Parts of this are actually spent in evaluating the generator expressions from the if above

			for neighbor_node in neighbors:
				if not neighbor_node in to_check:
					# add neighbor to list of reachable nodes to check

					# save previous node, calc distance to neighbor_node
					# and estimate from neighbor_node to destination
					dist_to_here = cur_node_data[1] + path_nodes.get(cur_node_coords, 0)

					total_dist_estimation = destination_to_tuple_distance_func(destination, neighbor_node) + dist_to_here
					to_check[neighbor_node] = (cur_node_coords,
					                           dist_to_here,
					                           total_dist_estimation)

					heappush(heap, (total_dist_estimation, neighbor_node))

				else:
					# neighbor has been processed,
					# check if current node provides a better path to this neighbor
					distance_to_neighbor = cur_node_data[1] + path_nodes.get(cur_node_coords, 0)

					neighbor = to_check[neighbor_node]

					if neighbor[1] > distance_to_neighbor:
						# found better path to neighbor, update values
						neighbor = ( cur_node_coords,
						             distance_to_neighbor,
						             distance_to_neighbor + ( neighbor[2]-neighbor[1] ) )


			# done processing cur_node
			checked[cur_node_coords] = cur_node_data
			del to_check[cur_node_coords]

			# check if cur_node is at the destination
			if cur_node_coords in dest_coords_set:
				# we're done.
				# insert steps of path to a list and return it
				path = [ cur_node_coords ]
				previous_node = cur_node_data[0]
				while previous_node is not None:
					path.insert(0, previous_node)
					previous_node = checked[previous_node][0]

				return path

		else:
			return None

########NEW FILE########
__FILENAME__ = pathnodes
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

class PathNodes(object):
	"""
	Abstract class; used to derive list of path nodes from, which is used for pathfinding.
	We encapsulate this code here to keep it centralized.
	"""
	log = logging.getLogger("world.pathfinding")

	# TODO: currently all paths have speed 1, since we don't have a real velocity-system yet.
	NODE_DEFAULT_SPEED = 1.0

	def __init__(self):
		# store a collection of path_nodes here. the type of this var has to be supported
		# by the pathfinding algo
		pass

class ConsumerBuildingPathNodes(PathNodes):
	"""List of path nodes for a consumer, that is a building
	Interface:
	self.nodes: {(x, y): speed, ...} of the home_building, where the collectors can walk
	"""
	def __init__(self, consumerbuilding):
		super(ConsumerBuildingPathNodes, self).__init__()
		ground_map = consumerbuilding.island.ground_map
		self.nodes = {}
		for coords in consumerbuilding.position.get_radius_coordinates(consumerbuilding.radius, include_self=False):
			if coords in ground_map and not 'coastline' in ground_map[coords].classes:
				self.nodes[coords] = self.NODE_DEFAULT_SPEED


class IslandPathNodes(PathNodes):
	"""List of path nodes for island
	Interface:
	self.nodes: List of nodes on island, where the terrain allows to be walked on
	self.road_nodes: dictionary of nodes, where a road is built on

	(un)register_road has to be called for each coord, where a road is built on (destroyed)
	reset_tile_walkablity has to be called when the terrain changes the walkability
	(e.g. building construction, a flood, or whatever)
	is_walkable rechecks the walkability status of a coordinate
	"""
	def __init__(self, island):
		super(IslandPathNodes, self).__init__()

		self.island = island

		# generate list of walkable tiles
		# we keep this up to date, so that path finding can use it and we don't have
		# to calculate it every time (rather expensive!).
		self.nodes = {}
		for coord in self.island:
			if self.is_walkable(coord):
				self.nodes[coord] = self.NODE_DEFAULT_SPEED

		# nodes where a real road is built on.
		self.road_nodes = {}

	def register_road(self, road):
		for i in road.position:
			self.road_nodes[ (i.x, i.y) ] = self.NODE_DEFAULT_SPEED

	def unregister_road(self, road):
		for i in road.position:
			del self.road_nodes[ (i.x, i.y) ]

	def is_road(self, x, y):
		"""Return if there is a road on (x, y)"""
		return (x, y) in self.road_nodes

	def is_walkable(self, coord):
		"""Check if a unit may walk on the tile specified by coord on land
		NOTE: nature tiles (trees..) are considered to be walkable (or else they could be used as
		      walls against enemies)
		@param coord: tuple: (x, y)
		"""
		tile_object = self.island.get_tile_tuple(coord)

		if tile_object is None:
			# tile is water
			return False

		# if it's not constructable, it is usually also not walkable
		# NOTE: this isn't really a clean implementation, but it works for now
		# it eliminates e.g. water and beaches, that shouldn't be walked on
		if not "constructible" in tile_object.classes:
			return False
		if tile_object.blocked and not tile_object.object.walkable:
			return False
		# every test is passed, tile is walkable
		return True

	def reset_tile_walkability(self, coord):
		"""Reset the status of the walkability of a coordinate in the list of walkable tiles
		of the island. Does not change the tile itself.
		You need to call this when a tile changes, e.g. when a building is built on it. this
		is currently done in add/remove_building
		@param coord: tuple: (x, y)"""
		actually_walkable = self.is_walkable(coord)
		# TODO: this lookup on a list is O(n), use different data structure here
		in_list = (coord in self.nodes)
		if not in_list and actually_walkable:
			self.nodes[coord] = self.NODE_DEFAULT_SPEED
		if in_list and not actually_walkable:
			del self.nodes[coord]

########NEW FILE########
__FILENAME__ = roadpathfinder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import heapq

from horizons.util.python import decorators

class RoadPathFinder(object):
	"""Finds the shortest path that should be most preferred by human players."""

	# the values are based on the configurations of the first two of the three sets of relative coordinates (previous, current, next)
	__counterclockwise_turns = [((0, 0), (0, 1)), ((0, 1), (1, 1)), ((1, 0), (0, 0)), ((1, 1), (1, 0))]

	@classmethod
	def __is_preferred_turn(cls, previous_coords, current_coords, next_coords, clockwise):
		"""Returns True if and only if the turn is in the preferred direction."""
		min_x = min(previous_coords[0], current_coords[0], next_coords[0])
		min_y = min(previous_coords[1], current_coords[1], next_coords[1])
		relative_previous_coords = (previous_coords[0] - min_x, previous_coords[1] - min_y)
		relative_current_coords = (current_coords[0] - min_x, current_coords[1] - min_y)
		return ((relative_previous_coords, relative_current_coords) in cls.__counterclockwise_turns) ^ clockwise

	def __call__(self, path_nodes, source, destination, clockwise=True):
		"""
		Return the path from the source to the destination or None if it is impossible.

		@param path_nodes: {(x, y): unused value, ...}
		@param source: (x, y)
		@param destination: (x, y)
		@param clockwise: bool; whether to try finding the path clockwise or counterclockwise
		"""

		if source not in path_nodes or destination not in path_nodes:
			return None
		if source == destination:
			return [source]

		distance = {}
		heap = []
		for dir in xrange(2): # 0 -> changed x, 1 -> changed y
			# NOTE: all distances are in the form (actual distance, number of turns, number of non-preferred turns)
			real_distance = (1, 0, 0)
			expected_distance = (((source[0] - destination[0]) ** 2 + (source[1] - destination[1]) ** 2) ** 0.5, 0, 0)
			key = (source[0], source[1], dir)
			# the value is (real distance so far, previous key)
			distance[key] = (real_distance, None)
			# (expected distance to the destination, current real distance, key)
			heap.append((expected_distance, real_distance, key))
		heapq.heapify(heap)

		moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		final_key = None

		# perform A*
		while heap:
			(_, distance_so_far, key) = heapq.heappop(heap)
			if distance[key] < distance_so_far:
				continue
			if (key[0], key[1]) == destination:
				final_key = key
				break

			for dir in xrange(4):
				coords = (key[0] + moves[dir][0], key[1] + moves[dir][1])
				if coords not in path_nodes:
					continue
				reduced_dir = 0 if moves[dir][0] != 0 else 1
				next_key = (coords[0], coords[1], reduced_dir)

				# determine whether this is a turn and if so then whether it is in the preferred direction
				turn = reduced_dir != key[2]
				if turn and distance[key][1] is None:
					continue # disallow turning as the first step; doesn't affect the ability to find the best path
				good_turn = self.__is_preferred_turn(distance[key][1][:2], key[:2], coords, clockwise) if turn else True

				# NOTE: all distances are in the form (actual distance, number of turns, number of non-preferred turns)
				real_distance = (distance_so_far[0] + 1, distance_so_far[1] + (1 if turn else 0), distance_so_far[2] + (0 if good_turn else 1))
				expected_distance = (real_distance[0] + ((coords[0] - destination[0]) ** 2 + (coords[1] - destination[1]) ** 2) ** 0.5, real_distance[1], real_distance[2])
				if next_key not in distance or distance[next_key][0] > real_distance:
					distance[next_key] = (real_distance, key)
					heapq.heappush(heap, (expected_distance, real_distance, next_key))

		# save path
		if final_key is not None:
			path = []
			while final_key is not None:
				path.append(final_key[:2])
				final_key = distance[final_key][1]
			return path
		return None

decorators.bind_all(RoadPathFinder)

########NEW FILE########
__FILENAME__ = pychananimation
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os
import os.path
import re

from horizons.extscheduler import ExtScheduler

class PychanAnimation(object):
	"""Displays images in short succession in a pychan icon."""

	def __init__(self, icon, directory):
		self.icon = icon
		files = [os.path.join(directory, filename)
		         for filename in os.listdir(directory)
		         if filename.endswith('.png')]
		def find_int(f):
			return int(re.search(r'\d+', os.path.basename(f)).group())
		self.files = sorted(files, key=find_int)
		self.cur = -1

	def start(self, interval, loops):
		"""Starts the animation.
		@param interval: seconds
		@param loops: number of loops or -1 for infininte
		"""
		self.interval = interval
		self._next()
		ExtScheduler().add_new_object(self._next, self, run_in=interval, loops=loops)

	def stop(self):
		"""Stops the animation (leaves current image)"""
		ExtScheduler().rem_call(self, self._next)

	def _next(self):
		self.cur = (self.cur + 1) % len(self.files)
		# don't set hover image, on mouseover, something has to happen
		# so that the user knows this is a button and now an image
		for img in ('image', 'up_image', 'down_image'):
			if hasattr(self.icon, img):
				setattr(self.icon, img, self.files[self.cur])

########NEW FILE########
__FILENAME__ = pychanchildfinder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


class PychanChildFinder(dict):
	"""Caches child references of a gui object, since pychan's findChild function is expensive.
	Init it with your gui and use like a dictionary or call object directly (__call__)"""
	def __init__(self, gui):
		super(PychanChildFinder, self).__init__()
		self.gui = gui

	def __getitem__(self, key):
		try:
			return dict.__getitem__(self, key)
		except KeyError:
			self[key] = self.gui.findChild(name=key)
			return self[key]

	def __call__(self, name):
		return self[name]
########NEW FILE########
__FILENAME__ = callback
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


class Callback(object):
	"""This class basically provides just callbacks with arguments.
	The same can be achieved via 'lambda: f(arg1, arg2)', but this class has
	more flexibility; e.g. you can compare callbacks, which can't be done with lambda functions.
	"""
	def __init__(self, callback_function, *args, **kwargs):
		assert callable(callback_function), "Argument to for callback_f is %s" % callback_function
		self.callback = callback_function
		self.args = args
		self.kwargs = kwargs

	@staticmethod
	def ChainedCallbacks(*args):
		"""Named constructor for callbacks executed in a row.
		Use Callback objects to pass arguments to the callbacks.
		It is guaranteed that the callbacks are executed in order.
		@param args: callables"""
		callbacks = [ Callback(i) for i in args ]
		def tmp():
			for i in callbacks:
				i()
		return Callback(tmp)

	def __call__(self):
		return self.callback(*self.args, **self.kwargs)

	def __eq__(self, other):
		try:
			if other.callback == self.callback and \
				 other.args == self.args and \
				 other.kwargs == self.kwargs:
				return True
			else:
				return False
		except AttributeError:
			return False

	def __ne__(self, other):
		return not self.__eq__(other)

	def __hash__(self):
		return hash((self.callback, self.args,
		             tuple(self.kwargs.iteritems()))) # to tuple, dict is unhashable

	def __str__(self):
		return 'Callback(%s, %s, %s)' % (self.callback, self.args, self.kwargs)

########NEW FILE########
__FILENAME__ = decorators
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

"""Save general python function decorators here"""

from types import FunctionType, ClassType
import time
import functools

class cachedfunction(object):
	"""Decorator that caches a function's return value each time it is called.
	If called later with the same arguments, the cached value is returned, and
	not re-evaluated.
	"""
	def __init__(self, func):
		self.func = func
		self.cache = {}

	def __call__(self, *args, **kwargs):
		# dicts are not hashable, convert kwargs to a tuple
		kwargs_tuple = tuple(sorted(kwargs.items()))

		try:
			return self.cache[(args, kwargs_tuple)]
		except KeyError:
			self.cache[(args, kwargs_tuple)] = value = self.func(*args, **kwargs)
			return value
		except TypeError:
			assert False, "Supplied invalid argument to cache decorator"


class cachedmethod(object):
	"""Same as cachedfunction, but works also for methods. Results are saved per instance"""
	def __init__(self, func):
		self.cache = {}
		self.func = func

	def __get__(self, instance, cls=None):
		self.instance = instance
		return self

	def __call__(self, *args, **kwargs):
		# dicts are not hashable, convert kwargs to a tuple
		kwargs_tuple = tuple(sorted(kwargs.items()))

		instance = self.instance

		try:
			return self.cache[(instance, args, kwargs_tuple)]
		except KeyError:
			self.cache[(instance, args, kwargs_tuple)] = value = self.func(instance, *args, **kwargs)
			return value
		except TypeError:
			assert False, "Supplied invalid argument to cache decorator"


def temporary_cachedmethod(timeout):
	"""
	Same as cachedproperty, but cached values only remain valid for a certain duration
	@param timeout: number of seconds to cache the value for
	"""
	class _temporary_cachedmethod(cachedmethod):
		def __init__(self, func, timeout):
			super(_temporary_cachedmethod, self).__init__(func)
			self.timeout = timeout
			self.cache_dates = {}

		def __call__(self, *args, **kwargs):
			key = self.instance, args, tuple(sorted(kwargs.items()))

			# check for expiration
			if key in self.cache_dates:
				if self.cache_dates[key] + self.timeout < time.time():
					# expired
					del self.cache[key]
					del self.cache_dates[key]
					return self(*args, **kwargs)
			else:
				self.cache_dates[key] = time.time() # new entry

			return super(_temporary_cachedmethod, self).__call__(*args, **kwargs)

	return functools.partial( _temporary_cachedmethod, timeout=timeout )



# adapted from http://code.activestate.com/recipes/277940/

from opcode import opmap, HAVE_ARGUMENT, EXTENDED_ARG
globals().update(opmap)

def _make_constants(f, builtin_only=False, stoplist=[], verbose=False):
	try:
		co = f.func_code
	except AttributeError:
		return f        # Jython doesn't have a func_code attribute.
	newcode = map(ord, co.co_code)
	newconsts = list(co.co_consts)
	names = co.co_names
	codelen = len(newcode)

	import __builtin__
	env = vars(__builtin__).copy()
	if builtin_only:
		stoplist = dict.fromkeys(stoplist)
		stoplist.update(f.func_globals)
	else:
		env.update(f.func_globals)

	# First pass converts global lookups into constants
	i = 0
	while i < codelen:
		opcode = newcode[i]
		if opcode in (EXTENDED_ARG, STORE_GLOBAL):
			return f    # for simplicity, only optimize common cases
		if opcode == LOAD_GLOBAL:
			oparg = newcode[i+1] + (newcode[i+2] << 8)
			name = co.co_names[oparg]
			if name in env and name not in stoplist:
				value = env[name]
				for pos, v in enumerate(newconsts):
					if v is value:
						break
				else:
					pos = len(newconsts)
					newconsts.append(value)
				newcode[i] = LOAD_CONST
				newcode[i+1] = pos & 0xFF
				newcode[i+2] = pos >> 8
				if verbose:
					print name, '-->', value
		i += 1
		if opcode >= HAVE_ARGUMENT:
			i += 2

	# Second pass folds tuples of constants and constant attribute lookups
	i = 0
	while i < codelen:

		newtuple = []
		while newcode[i] == LOAD_CONST:
			oparg = newcode[i+1] + (newcode[i+2] << 8)
			newtuple.append(newconsts[oparg])
			i += 3

		opcode = newcode[i]
		if not newtuple:
			i += 1
			if opcode >= HAVE_ARGUMENT:
				i += 2
			continue

		if opcode == LOAD_ATTR:
			obj = newtuple[-1]
			oparg = newcode[i+1] + (newcode[i+2] << 8)
			name = names[oparg]
			try:
				value = getattr(obj, name)
			except AttributeError:
				continue
			deletions = 1

		elif opcode == BUILD_TUPLE:
			oparg = newcode[i+1] + (newcode[i+2] << 8)
			if oparg != len(newtuple):
				continue
			deletions = len(newtuple)
			value = tuple(newtuple)

		else:
			continue

		reljump = deletions * 3
		newcode[i-reljump] = JUMP_FORWARD
		newcode[i-reljump+1] = (reljump-3) & 0xFF
		newcode[i-reljump+2] = (reljump-3) >> 8

		n = len(newconsts)
		newconsts.append(value)
		newcode[i] = LOAD_CONST
		newcode[i+1] = n & 0xFF
		newcode[i+2] = n >> 8
		i += 3
		if verbose:
			print "new folded constant:", value

	codestr = ''.join(map(chr, newcode))
	codeobj = type(co)(co.co_argcount, co.co_nlocals, co.co_stacksize,
				             co.co_flags, codestr, tuple(newconsts), co.co_names,
				             co.co_varnames, co.co_filename, co.co_name,
				             co.co_firstlineno, co.co_lnotab, co.co_freevars,
				             co.co_cellvars)
	return type(f)(codeobj, f.func_globals, f.func_name, f.func_defaults,
				         f.func_closure)

_make_constants = _make_constants(_make_constants) # optimize thyself!

def bind_all(mc, builtin_only=False, stoplist=None, verbose=False):
	"""Recursively apply constant binding to functions in a module or class.

	Use as the last line of the module (after everything is defined, but
	before test code).  In modules that need modifiable globals, set
	builtin_only to True.

	"""

	# Ignore gettext functions. At the beginning these point to a NullTranslation
	# object, they change when a language is activated.
	stoplist = stoplist or []
	stoplist.extend(['_', 'N_'])

	try:
		d = vars(mc)
	except TypeError:
		return
	for k, v in d.items():
		if type(v) is FunctionType:
			newv = _make_constants(v, builtin_only, stoplist, verbose)
			setattr(mc, k, newv)
		elif type(v) in (type, ClassType):
			bind_all(v, builtin_only, stoplist, verbose)

@_make_constants
def make_constants(builtin_only=False, stoplist=[], verbose=False):
	""" Return a decorator for optimizing global references.

	Replaces global references with their currently defined values.
	If not defined, the dynamic (runtime) global lookup is left undisturbed.
	If builtin_only is True, then only builtins are optimized.
	Variable names in the stoplist are also left undisturbed.
	Also, folds constant attr lookups and tuples of constants.
	If verbose is True, prints each substitution as is occurs

	"""
	if type(builtin_only) == type(make_constants):
		raise ValueError("The bind_constants decorator must have arguments.")
	return lambda f: _make_constants(f, builtin_only, stoplist, verbose)


# cachedproperty taken from http://code.activestate.com/recipes/576563-cached-property/
# Licensed under MIT
# A cached property is a read-only property that is calculated on demand and automatically cached.
# If the value has already been calculated, the cached value is returned.

def cachedproperty(f):
	"""returns a cached property that is calculated by function f"""
	def get(self):
		try:
			return self._property_cache[f]
		except AttributeError:
			self._property_cache = {}
			x = self._property_cache[f] = f(self)
			return x
		except KeyError:
			x = self._property_cache[f] = f(self)
			return x

	return property(get)

########NEW FILE########
__FILENAME__ = defaultweakkeydictionary
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

"""
DefaultWeakKeyDictionary - Works as a regular WeakKeyDictionary but supports default values.
Note: Default feature works slightly different than collections.defaultdict

Usage:

>>> d = DefaultWeakKeyDictionary(lambda key: key*2)
>>> d['foo'] = 4
>>> print d['foo']
4
>>> print d['bar']
'barbar'
"""
from weakref import WeakKeyDictionary

class DefaultWeakKeyDictionary(WeakKeyDictionary):
	"""
	WeakKeyDictionary with specified default value.
	"""
	def __init__(self, default_function):
		WeakKeyDictionary.__init__(self)
		assert default_function is not None, "Default function must be provided"
		self.default_function = default_function

	def __getitem__(self, item):
		if item not in self.items():
			return self.default_function(item)
		return WeakKeyDictionary.__getitem__(self, item)

########NEW FILE########
__FILENAME__ = registry
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


class Registry(type):
	"""Simple implementation of the registry pattern.

	Example

		class Test(object):
			__metaclass__ = Registry

			@classmethod
			def register_function(cls, func):
				cls.registry[func.__name__] = func


		@Test.register()
		def foo(): pass

	The function foo can now be retrieved with

		Test.get('foo')

	See the Scenario system or the unit tests for further usage examples.
	"""
	def __init__(cls, name, bases, dict):
		setattr(cls, 'registry', {})

	def register(cls, **kwargs):
		"""Returns a decorator to register functions, all arguments are passed through
		to `register_function`. You can use that to allow registeration under a different name
		for example.
		"""
		def deco(func):
			cls.register_function(func, **kwargs)
			return func
		return deco

	def register_function(cls, func, **kwargs):
		"""Function that actually handles the registration. You need to implement this
		yourself.

		For `get` to work, you want to add the function to the `registry` dictionary
		under the same name that will be used to look it up later.
		"""
		raise NotImplementedError

	def get(cls, name):
		"""Retrieve a function given by `name` from the registry."""
		return cls.registry[name]

########NEW FILE########
__FILENAME__ = singleton
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

'''
Warning:
	A Singleton is to some extend the OOP-version of a global variable.
	The Singleton pattern has many downsides.
	Please make sure that this is really the best solution before using this code!
'''


class Singleton(type):
	"""Traditional Singleton design pattern.

	USAGE:
	class MyClass(object):
		__metaclass__ = Singleton
	"""
	def __init__(self, name, bases, dict):
		super(Singleton, self).__init__(name, bases, dict)
		self.instance = None

	def __call__(self, *args, **kwargs):
		if self.instance is None:
			self.instance = super(Singleton, self).__call__(*args, **kwargs)
		return self.instance

	def destroy_instance(self):
		self.instance = None


class ManualConstructionSingleton(Singleton):
	"""Same as Singleton, but Class() never creates an instance.
	Only create_instance() does."""
	def __call__(self):
		return self.instance

	def create_instance(self, *args, **kwargs):
		self.instance = super(ManualConstructionSingleton, self).__call__(*args, **kwargs)

########NEW FILE########
__FILENAME__ = weaklist
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

# This file was stolen from http://home.gna.org/meals/ at 2008-07-24

"""
weaklist - list implementation that store objects with weakref
instead of strong ref
"""

import weakref

class _CopyDocFromParentClass(type):
	"""
    metaclass that copy, for a given class,
    all the docstring from their parents if there are not set
    """

	def __init__(cls, name, bases, dict):
		for name, method in dict.iteritems():
			try:
				if not method.__doc__:
					method.__doc__ = getattr(bases[0], name).__doc__
			except AttributeError:
				pass

class WeakList(list):
	"""
    A Weak_list can store objects but without keeping them
    alive with references couting incrementation.

    When objects are deleted or garbage_collected, they disappear from
    the list.

    ! WARNING: due to the *magic* deletion of item, some method here
    are not guaranteed to give the right result or even to work properly.

    This class is NOT thread safe and NOT GC safe.

    You can have problem with:

    - extend can add broken weakref in the list
    - sort can crash
    - __iter__, __str__, __repr__ and __reversed can return some None
    - all the rich comparison method
    - count can return wrong values or outdated
    - index can return too high values or forget to raise exceptions
    - __get_item__ and __set_item__ are useless

    Be also careful that your work with weakref, so some usual
    tips don't work:

    >>> weak = weaklist.WeakList(weakable_class())
    >>> len(a)
    0

    """

	# This copy all the list's doctstring into this class's method
	# So even if the class look undocumented, it is ! (use pydoc)
	__metaclass__ = _CopyDocFromParentClass


	## Basic custom

	def __init__(self, items=None):
		if items:
			list.__init__(self, self.__iter_over_weakref(items))
		else:
			list.__init__(self)

	def __str__(self):
		return '[' + ', '.join((repr(i) for i in self)) + ']'

	def __repr__(self):
		return 'Weak_list((' + ', '.join((repr(i) for i in self)) + '))'


	## Special method

	def __new_weakref(self, item):
		"""Create a weakref with the good callback"""
		return weakref.ref(item, self.__remove_ref)

	def __iter_over_weakref(self, iterable):
		"""For a given iterable, return an iterable generator over all weakref"""
		return (self.__new_weakref(i) for i in iterable)

	def __remove_ref(self, ref):
		"""
        When an object from the list is destroy, this
        method is call to remove it from list
        """

		list.remove(self, ref)


	## list method

	def extend(self, iterable):
		iterable = self.__iter_over_weakref(list(iterable))
		list.extend(self, iterable)

	def append(self, obj):
		list.append(self, weakref.ref(obj, self.__remove_ref))

	def remove(self, obj):
		list.remove(self, weakref.ref(obj))

	def count(self, value):
		return list.count(self, weakref.ref(value))

	def index(self, value, *args):
		return list.index(self, weakref.ref(value), *args)

	def pop(self, index=-1):
		return list.pop(self, index)()

	def sort(self, cmp=None, key=None, reverse=False):
		sortable = list(self)
		sortable.sort(cmp, key, reverse)
		del self[:]
		self.extend(sortable)

	def insert(self, index, obj):
		list.insert(self, index, self.__new_weakref(obj))


	## Emulating container types

	def __getitem__(self, index):
		return list.__getitem__(self, index)()

	def __setitem__(self, index, value):
		if isinstance(index, slice):
			list.__setitem__(self, index, self.__iter_over_weakref(value))
		else:
			list.__setitem__(self, index, self.__new_weakref(value))

	def __iter__(self):
		for i in list.__iter__(self):
			yield i()

	def __contains__(self, item):
		return list.__contains__(self, weakref.ref(item))

	def __getslice__(self, i, j):
		return WeakList(list(self)[i:j])

	def __setslice__(self, i, j, iterable):
		list.__setslice__(self, i, j, self.__iter_over_weakref(iterable))

	def __reversed__(self):
		return iter([i() for i in list.__reversed__(self)])


	## Emulating numeric types

	def __iadd__(self, other):
		self.extend(other)
		return self

	def __add__(self, other):
		return self.__class__(list(self) + list(other))


	## Rich comparison

	def __eq__(self, other):
		if isinstance(other, WeakList):
			other = list(other)
		return list.__eq__(list(self), other)

	def __ge__(self, other):
		if isinstance(other, WeakList):
			other = list(other)
		return list.__ge__(list(self), other)

	def __le__(self, other):
		if isinstance(other, WeakList):
			other = list(other)

		return list.__le__(list(self), other)

	def __gt__(self, other):
		if isinstance(other, WeakList):
			other = list(other)

		return list.__gt__(list(self), other)

	def __ne__(self, other):
		if isinstance(other, WeakList):
			other = list(other)

		return list.__ne__(list(self), other)

	def __lt__(self, other):
		if isinstance(other, WeakList):
			other = list(other)

		return list.__lt__(list(self), other)

### End of WeakList class

########NEW FILE########
__FILENAME__ = weakmethod
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import types
import weakref

class WeakMethod(object):
	def __init__(self, function):
		assert callable(function)

		if isinstance(function, types.MethodType) and function.im_self is not None:
			self.function = function.im_func
			self.instance = weakref.ref(function.im_self)
		else:
			self.function = function
			self.instance = None

	def __call__(self, *args, **kwargs):
		if self.instance is None:
			return self.function(*args, **kwargs)
		elif self.instance() is not None:
			return self.function(self.instance(), *args, **kwargs)
		else:
			raise ReferenceError("Instance: %s  Function: %s  Function from module: %s" %
			                     (self.instance(), self.function, self.function.__module__))

	def __eq__(self, other):
		if isinstance(other, WeakMethod):
			if self.function != other.function:
				return False
			# check also if either instance is None or else if instances are equal
			if self.instance is None:
				return other.instance is None
			else:
				return self.instance() == other.instance()
		elif callable(other):
			return self == WeakMethod(other)
		else:
			return False

	def __ne__(self, other):
		return not self.__eq__(other)

	def __hash__(self):
		return hash((self.instance, self.function))

	def __str__(self):
		return str(self.function)

########NEW FILE########
__FILENAME__ = weakmethodlist
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.python.weakmethod import WeakMethod

class WeakMethodList(list):
	"""A class that handles zero to n callbacks."""

	def __init__(self, callbacks=None):
		"""
		@param callbacks: None, a function, a list of functions, or a tuple of functions
		"""
		super(WeakMethodList, self).__init__()
		self.append(callbacks)

	def append(self, callback):
		"""Just like list.append, except it can also handle lists and discards None-values"""
		if callback is None:
			pass
		elif callable(callback):
			list.append(self, WeakMethod(callback))
		elif isinstance(callback, list, tuple):
			for i in callback:
				self.append(i)
		else:
			assert False

	extend = append

	def execute(self):
		"""Execute all callbacks. Number of callbacks may be zero to n."""
		for callback in self:
			callback()

	def remove(self, elem):
		if not isinstance(elem, WeakMethod):
			elem = WeakMethod(elem)
		list.remove(self, elem)

	def __contains__(self, elem):
		if isinstance(elem, WeakMethod):
			return list.__contains__(self, elem)
		else:
			return WeakMethod(elem) in self

	def __str__(self):
		return str([str(i) for i in self])

########NEW FILE########
__FILENAME__ = random_map
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import hashlib
import random
import re
import string
import copy

from horizons.util.shapes import Circle, Point, Rect
from horizons.constants import GROUND

# this is how a random island id looks like (used for creation)
_random_island_id_template = "random:${creation_method}:${width}:${height}:${seed}:${island_x}:${island_y}"

# you can check for a random island id with this:
_random_island_id_regexp = r"^random:([0-9]+):([0-9]+):([0-9]+):([\-]?[0-9]+):([\-]?[0-9]+):([\-]?[0-9]+)$"


def create_random_island(map_db, island_id, id_string):
	"""Creates a random island as sqlite db.
	It is rather primitive; it places shapes on the dict.
	The coordinates of tiles will be 0 <= x < width and 0 <= y < height
	@param id_string: random island id string
	"""
	match_obj = re.match(_random_island_id_regexp, id_string)
	assert match_obj
	creation_method, width, height, seed, island_x, island_y = [long(i) for i in match_obj.groups()]
	assert creation_method == 2, 'The only supported island creation method is 2.'

	rand = random.Random(seed)
	map_set = set()

	# place this number of shapes
	for i in xrange(15 + width * height // 45):
		# place shape determined by shape_id on (x, y)
		add = True
		shape_id = rand.randint(2, 8)
		rect_chance = 29
		if rand.randint(0, 4) == 0:
			rect_chance = 13
			add = False

		shape = None
		if rand.randint(1, rect_chance) == 1:
			# use a rect
			if add:
				x = rand.randint(8, width - 7)
				y = rand.randint(8, height - 7)
			else:
				x = rand.randint(0, width)
				y = rand.randint(0, height)
			shape = Rect.init_from_topleft_and_size(x - 5, y - 5, rand.randint(2, 8), rand.randint(2, 8))
		else:
			# use a circle such that the radius is determined by shape_id
			radius = shape_id
			if not add and rand.randint(0, 6) < 5:
				x = rand.randint(-radius * 3 // 2, width + radius * 3 // 2)
				y = rand.randint(-radius * 3 // 2, height + radius * 3 // 2)
				shape = Circle(Point(x, y), shape_id)
			elif width - radius - 4 >= radius + 3 and height - radius - 4 >= radius + 3:
				x = rand.randint(radius + 3, width - radius - 4)
				y = rand.randint(radius + 3, height - radius - 4)
				shape = Circle(Point(x, y), shape_id)

		if shape:
			for shape_coord in shape.tuple_iter():
				if add:
					map_set.add(shape_coord)
				elif shape_coord in map_set:
					map_set.discard(shape_coord)

	# write values to db
	map_db("BEGIN TRANSACTION")

	# add grass tiles
	for x, y in map_set:
		map_db("INSERT INTO ground VALUES(?, ?, ?, ?, ?, ?)", island_id, island_x + x, island_y + y, *GROUND.DEFAULT_LAND)

	def fill_tiny_spaces(tile):
		"""Fills 1 tile gulfs and straits with the specified tile
		@param tile: ground tile to fill with
		"""

		all_neighbors = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
		neighbors = [(-1, 0), (0, -1), (0, 1), (1, 0)]
		corners = [(-1, -1), (-1, 1)]
		knight_moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]
		bad_configs = set([0, 1 << 0, 1 << 1, 1 << 2, 1 << 3, (1 << 0) | (1 << 3), (1 << 1) | (1 << 2)])

		edge_set = copy.copy(map_set)
		reduce_edge_set = True

		while True:
			to_fill = set()
			to_ignore = set()
			for x, y in edge_set:
				# ignore the tiles with no empty neighbors
				if reduce_edge_set:
					is_edge = False
					for x_offset, y_offset in all_neighbors:
						if (x + x_offset, y + y_offset) not in map_set:
							is_edge = True
							break
					if not is_edge:
						to_ignore.add((x, y))
						continue

				for x_offset, y_offset in neighbors:
					x2 = x + x_offset
					y2 = y + y_offset
					if (x2, y2) in map_set:
						continue
					# (x2, y2) is now a point just off the island

					neighbors_dirs = 0
					for i in xrange(len(neighbors)):
						x3 = x2 + neighbors[i][0]
						y3 = y2 + neighbors[i][1]
						if (x3, y3) not in map_set:
							neighbors_dirs |= (1 << i)
					if neighbors_dirs in bad_configs:
						# part of a straight 1 tile gulf
						to_fill.add((x2, y2))
					else:
						for x_offset, y_offset in corners:
							x3 = x2 + x_offset
							y3 = y2 + y_offset
							x4 = x2 - x_offset
							y4 = y2 - y_offset
							if (x3, y3) in map_set and (x4, y4) in map_set:
								# part of a diagonal 1 tile gulf
								to_fill.add((x2, y2))
								break

				# block 1 tile straits
				for x_offset, y_offset in knight_moves:
					x2 = x + x_offset
					y2 = y + y_offset
					if (x2, y2) not in map_set:
						continue
					if abs(x_offset) == 1:
						y2 = y + y_offset // 2
						if (x2, y2) in map_set or (x, y2) in map_set:
							continue
					else:
						x2 = x + x_offset // 2
						if (x2, y2) in map_set or (x2, y) in map_set:
							continue
					to_fill.add((x2, y2))

				# block diagonal 1 tile straits
				for x_offset, y_offset in corners:
					x2 = x + x_offset
					y2 = y + y_offset
					x3 = x + 2 * x_offset
					y3 = y + 2 * y_offset
					if (x2, y2) not in map_set and (x3, y3) in map_set:
						to_fill.add((x2, y2))
					elif (x2, y2) in map_set and (x2, y) not in map_set and (x, y2) not in map_set:
						to_fill.add((x2, y))

			if to_fill:
				for x, y in to_fill:
					map_set.add((x, y))
					map_db("INSERT INTO ground VALUES(?, ?, ?, ?, ?, ?)", island_id, island_x + x, island_y + y, *tile)

				old_size = len(edge_set)
				edge_set = edge_set.difference(to_ignore).union(to_fill)
				reduce_edge_set = old_size - len(edge_set) > 50
			else:
				break

	# possible movement directions
	all_moves = {
		'sw' : (-1, -1),
		'w'  : (-1, 0),
		'nw' : (-1, 1),
		's'  : (0, -1),
		'n'  : (0, 1),
		'se' : (1, -1),
		'e'  : (1, 0),
		'ne' : (1, 1)
		}

	def get_island_outline():
		"""
		@return: the points just off the island as a dict
		"""
		result = set()
		for x, y in map_set:
			for offset_x, offset_y in all_moves.itervalues():
				coords = (x + offset_x, y + offset_y)
				if coords not in map_set:
					result.add(coords)
		return result

	# add grass to sand tiles
	fill_tiny_spaces(GROUND.DEFAULT_LAND)
	outline = get_island_outline()
	for x, y in outline:
		filled = []
		for dir in sorted(all_moves):
			coords = (x + all_moves[dir][1], y + all_moves[dir][0])
			if coords in map_set:
				filled.append(dir)

		tile = None
		# straight coast or 1 tile U-shaped gulfs
		if filled == ['s', 'se', 'sw'] or filled == ['s']:
			tile = GROUND.SAND_NORTH
		elif filled == ['e', 'ne', 'se'] or filled == ['e']:
			tile = GROUND.SAND_WEST
		elif filled == ['n', 'ne', 'nw'] or filled == ['n']:
			tile = GROUND.SAND_SOUTH
		elif filled == ['nw', 'sw', 'w'] or filled == ['w']:
			tile = GROUND.SAND_EAST
		# slight turn (looks best with straight coast)
		elif filled == ['e', 'se'] or filled == ['e', 'ne']:
			tile = GROUND.SAND_WEST
		elif filled == ['n', 'ne'] or filled == ['n', 'nw']:
			tile = GROUND.SAND_SOUTH
		elif filled == ['nw', 'w'] or filled == ['sw', 'w']:
			tile = GROUND.SAND_EAST
		elif filled == ['s', 'sw'] or filled == ['s', 'se']:
			tile = GROUND.SAND_NORTH
		# sandy corner
		elif filled == ['se']:
			tile = GROUND.SAND_NORTHWEST1
		elif filled == ['ne']:
			tile = GROUND.SAND_SOUTHWEST1
		elif filled == ['nw']:
			tile = GROUND.SAND_SOUTHEAST1
		elif filled == ['sw']:
			tile = GROUND.SAND_NORTHEAST1
		# grassy corner
		elif 3 <= len(filled) <= 5:
			coast_set = set(filled)
			if 'e' in coast_set and 'se' in coast_set and 's' in coast_set:
				tile = GROUND.SAND_NORTHEAST3
			elif 's' in coast_set and 'sw' in coast_set and 'w' in coast_set:
				tile = GROUND.SAND_NORTHWEST3
			elif 'w' in coast_set and 'nw' in coast_set and 'n' in coast_set:
				tile = GROUND.SAND_SOUTHWEST3
			elif 'n' in coast_set and 'ne' in coast_set and 'e' in coast_set:
				tile = GROUND.SAND_SOUTHEAST3

		assert tile
		map_db("INSERT INTO ground VALUES(?, ?, ?, ?, ?, ?)", island_id, island_x + x, island_y + y, *tile)
	map_set = map_set.union(outline)

	# add sand to shallow water tiles
	fill_tiny_spaces(GROUND.SAND)
	outline = get_island_outline()
	for x, y in outline:
		filled = []
		for dir in sorted(all_moves):
			coords = (x + all_moves[dir][1], y + all_moves[dir][0])
			if coords in map_set:
				filled.append(dir)

		tile = None
		# straight coast or 1 tile U-shaped gulfs
		if filled == ['s', 'se', 'sw'] or filled == ['s']:
			tile = GROUND.COAST_NORTH
		elif filled == ['e', 'ne', 'se'] or filled == ['e']:
			tile = GROUND.COAST_WEST
		elif filled == ['n', 'ne', 'nw'] or filled == ['n']:
			tile = GROUND.COAST_SOUTH
		elif filled == ['nw', 'sw', 'w'] or filled == ['w']:
			tile = GROUND.COAST_EAST
		# slight turn (looks best with straight coast)
		elif filled == ['e', 'se'] or filled == ['e', 'ne']:
			tile = GROUND.COAST_WEST
		elif filled == ['n', 'ne'] or filled == ['n', 'nw']:
			tile = GROUND.COAST_SOUTH
		elif filled == ['nw', 'w'] or filled == ['sw', 'w']:
			tile = GROUND.COAST_EAST
		elif filled == ['s', 'sw'] or filled == ['s', 'se']:
			tile = GROUND.COAST_NORTH
		# mostly wet corner
		elif filled == ['se']:
			tile = GROUND.COAST_NORTHWEST1
		elif filled == ['ne']:
			tile = GROUND.COAST_SOUTHWEST1
		elif filled == ['nw']:
			tile = GROUND.COAST_SOUTHEAST1
		elif filled == ['sw']:
			tile = GROUND.COAST_NORTHEAST1
		# mostly dry corner
		elif 3 <= len(filled) <= 5:
			coast_set = set(filled)
			if 'e' in coast_set and 'se' in coast_set and 's' in coast_set:
				tile = GROUND.COAST_NORTHEAST3
			elif 's' in coast_set and 'sw' in coast_set and 'w' in coast_set:
				tile = GROUND.COAST_NORTHWEST3
			elif 'w' in coast_set and 'nw' in coast_set and 'n' in coast_set:
				tile = GROUND.COAST_SOUTHWEST3
			elif 'n' in coast_set and 'ne' in coast_set and 'e' in coast_set:
				tile = GROUND.COAST_SOUTHEAST3

		assert tile
		map_db("INSERT INTO ground VALUES(?, ?, ?, ?, ?, ?)", island_id, island_x + x, island_y + y, *tile)
	map_set = map_set.union(outline)

	# add shallow water to deep water tiles
	fill_tiny_spaces(GROUND.SHALLOW_WATER)
	outline = get_island_outline()
	for x, y in outline:
		filled = []
		for dir in sorted(all_moves):
			coords = (x + all_moves[dir][1], y + all_moves[dir][0])
			if coords in map_set:
				filled.append(dir)

		tile = None
		# straight coast or 1 tile U-shaped gulfs
		if filled == ['s', 'se', 'sw'] or filled == ['s']:
			tile = GROUND.DEEP_WATER_NORTH
		elif filled == ['e', 'ne', 'se'] or filled == ['e']:
			tile = GROUND.DEEP_WATER_WEST
		elif filled == ['n', 'ne', 'nw'] or filled == ['n']:
			tile = GROUND.DEEP_WATER_SOUTH
		elif filled == ['nw', 'sw', 'w'] or filled == ['w']:
			tile = GROUND.DEEP_WATER_EAST
		# slight turn (looks best with straight coast)
		elif filled == ['e', 'se'] or filled == ['e', 'ne']:
			tile = GROUND.DEEP_WATER_WEST
		elif filled == ['n', 'ne'] or filled == ['n', 'nw']:
			tile = GROUND.DEEP_WATER_SOUTH
		elif filled == ['nw', 'w'] or filled == ['sw', 'w']:
			tile = GROUND.DEEP_WATER_EAST
		elif filled == ['s', 'sw'] or filled == ['s', 'se']:
			tile = GROUND.DEEP_WATER_NORTH
		# mostly deep corner
		elif filled == ['se']:
			tile = GROUND.DEEP_WATER_NORTHWEST1
		elif filled == ['ne']:
			tile = GROUND.DEEP_WATER_SOUTHWEST1
		elif filled == ['nw']:
			tile = GROUND.DEEP_WATER_SOUTHEAST1
		elif filled == ['sw']:
			tile = GROUND.DEEP_WATER_NORTHEAST1
		# mostly shallow corner
		elif 3 <= len(filled) <= 5:
			coast_set = set(filled)
			if 'e' in coast_set and 'se' in coast_set and 's' in coast_set:
				tile = GROUND.DEEP_WATER_NORTHEAST3
			elif 's' in coast_set and 'sw' in coast_set and 'w' in coast_set:
				tile = GROUND.DEEP_WATER_NORTHWEST3
			elif 'w' in coast_set and 'nw' in coast_set and 'n' in coast_set:
				tile = GROUND.DEEP_WATER_SOUTHWEST3
			elif 'n' in coast_set and 'ne' in coast_set and 'e' in coast_set:
				tile = GROUND.DEEP_WATER_SOUTHEAST3

		assert tile
		map_db("INSERT INTO ground VALUES(?, ?, ?, ?, ?, ?)", island_id, island_x + x, island_y + y, *tile)

	map_db("COMMIT")

def _simplify_seed(seed):
	"""
	Return the simplified seed value. The goal of this is to make it easier for users to convey the seeds orally.

	This function also makes sure its return value fits into a 32bit integer. That is
	necessary because otherwise the hash of the value could be different between
	32 and 64 bit python interpreters. That would cause a map with seed X to be different
	depending on the platform which we don't want to happen.
	"""

	seed = str(seed).lower().strip()
	h = hashlib.md5(seed)
	h.update(seed)
	return int('0x' + h.hexdigest(), 16) % 1000000007

def generate_random_map(seed, map_size, water_percent, max_island_size,
                        preferred_island_size, island_size_deviation):
	"""
	Generates a random map.

	@param seed: random number generator seed
	@param map_size: maximum map side length
	@param water_percent: minimum percent of map covered with water
	@param max_island_size: maximum island side length
	@param preferred_island_size: mean of island side lengths
	@param island_size_deviation: deviation of island side lengths
	@return: filename of the SQLite database containing the map
	"""
	max_island_size = min(max_island_size, map_size)
	rand = random.Random(_simplify_seed(seed))
	min_island_size = 20 # minimum chosen island side length (the real size my be smaller)
	min_island_separation = 3 + map_size // 100 # minimum distance between two islands
	max_island_side_coefficient = 4 # maximum value of island's max(side length) / min(side length)

	islands = []
	estimated_land = 0
	max_land_amount = map_size * map_size * (100 - water_percent) // 100

	trial_number = 0
	while trial_number < 100:
		trial_number += 1
		width = max(min_island_size, min(max_island_size, int(round(rand.gauss(preferred_island_size, island_size_deviation)))))
		side_coefficient = min(1 + abs(rand.gauss(0, 0.2)), max_island_side_coefficient)
		side_coefficient = side_coefficient if rand.randint(0, 1) else 1.0 / side_coefficient
		height = max(min_island_size, min(max_island_size, int(round(width * side_coefficient))))
		size = width * height
		if estimated_land + size > max_land_amount:
			continue

		for _ in xrange(13):
			x = rand.randint(0, map_size - width)
			y = rand.randint(0, map_size - height)

			rect = Rect.init_from_topleft_and_size(x, y, width, height)
			blocked = False
			for existing_island in islands:
				if existing_island.distance(rect) < min_island_separation:
					blocked = True
					break
			if not blocked:
				islands.append(rect)
				estimated_land += size
				trial_number = 0
				break

	# move some of the islands to stretch the map to the right size
	if len(islands) > 1:
		min_top = min(rect.top for rect in islands)
		rect = rand.choice([rect for rect in islands if rect.top == min_top])
		islands[islands.index(rect)] = Rect.init_from_borders(rect.left, rect.top - min_top, rect.right, rect.bottom - min_top)

		max_bottom = max(rect.bottom for rect in islands)
		rect = rand.choice([rect for rect in islands if rect.bottom == max_bottom])
		shift = map_size - max_bottom - 1
		islands[islands.index(rect)] = Rect.init_from_borders(rect.left, rect.top + shift, rect.right, rect.bottom + shift)

		min_left = min(rect.left for rect in islands)
		rect = rand.choice([rect for rect in islands if rect.left == min_left])
		islands[islands.index(rect)] = Rect.init_from_borders(rect.left - min_left, rect.top, rect.right - min_left, rect.bottom)

		max_right = max(rect.right for rect in islands)
		rect = rand.choice([rect for rect in islands if rect.right == max_right])
		shift = map_size - max_right - 1
		islands[islands.index(rect)] = Rect.init_from_borders(rect.left + shift, rect.top, rect.right + shift, rect.bottom)

	island_strings = []
	for rect in islands:
		# The bounds must be platform independent to make sure the same maps are generated on all platforms.
		island_seed = rand.randint(-2147483648, 2147483647)
		island_params = {'creation_method': 2, 'seed': island_seed, 'width': rect.width,
						 'height': rect.height, 'island_x': rect.left, 'island_y': rect.top}
		island_string = string.Template(_random_island_id_template).safe_substitute(island_params)
		island_strings.append(island_string)
	return island_strings

def generate_random_seed(seed):
	rand = random.Random(seed)
	if rand.randint(0, 1) == 0:
		# generate a random string of 1-5 letters a-z with a dash if there are 4 or more letters
		seq = ''
		for i in xrange(rand.randint(1, 5)):
			seq += chr(97 + rand.randint(0, 25))
		if len(seq) > 3:
			split = rand.randint(2, len(seq) - 2)
			seq = seq[:split] + '-' + seq[split:]
		return unicode(seq)
	else:
		# generate a numeric seed
		fields = rand.randint(1, 3)
		if fields == 1:
			# generate a five digit integer
			return unicode(rand.randint(10000, 99999))
		else:
			# generate a sequence of 2 or 3 dash separated fields of integers 10-9999
			parts = []
			for i in xrange(fields):
				power = rand.randint(1, 3)
				parts.append(str(rand.randint(10 ** power, 10 ** (power + 1) - 1)))
			return unicode('-'.join(parts))

def generate_map_from_seed(seed):
	"""
	Generates a random map with the given seed and default parameters.

	@param seed: random number generator seed
	@return: filename of the SQLite database containing the map
	"""

	return generate_random_map(seed, 150, 50, 70, 70, 30)

def generate_huge_map_from_seed(seed):
	"""Same as generate_map_from_seed, but making it as big as it is still reasonable"""
	return generate_random_map(seed, 250, 20, 70, 70, 5)

########NEW FILE########
__FILENAME__ = savegameaccessor
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import hashlib
import os
import os.path
import tempfile

from collections import defaultdict, deque

from horizons.constants import MAP, PATHS
from horizons.savegamemanager import SavegameManager
from horizons.util.dbreader import DbReader
from horizons.util.python import decorators
from horizons.util.random_map import create_random_island
from horizons.util.savegameupgrader import SavegameUpgrader

class SavegameAccessor(DbReader):
	"""
	SavegameAccessor is the class used for loading saved games.

	Frequent select queries are preloaded for faster access.
	"""

	def __init__(self, game_identifier, is_map, options=None):
		is_random_map = False
		if is_map:
			self.upgrader = None
			handle, self._temp_path = tempfile.mkstemp()
			os.close(handle)
			super(SavegameAccessor, self).__init__(dbfile=self._temp_path)
			with open('content/savegame_template.sql') as savegame_template:
				self.execute_script(savegame_template.read())

			if isinstance(game_identifier, list):
				is_random_map = True
				random_island_sequence = game_identifier
			else:
				self._map_path = game_identifier
		else:
			self.upgrader = SavegameUpgrader(game_identifier)
			self._temp_path = None
			game_identifier = self.upgrader.get_path()
			super(SavegameAccessor, self).__init__(dbfile=game_identifier)

			map_name_data = self('SELECT value FROM metadata WHERE name = ?', 'map_name')
			if not map_name_data:
				is_random_map = True
				random_island_sequence = self('SELECT value FROM metadata WHERE name = ?', 'random_island_sequence')[0][0].split(' ')
			else:
				map_name = map_name_data[0][0]
				if map_name.startswith('USER_MAPS_DIR:'):
					self._map_path = PATHS.USER_MAPS_DIR + map_name[len('USER_MAPS_DIR:'):]
				elif os.path.isabs(map_name):
					self._map_path = map_name
				else:
					self._map_path = SavegameManager.get_filename_from_map_name(map_name)

		if is_random_map:
			handle, self._temp_path2 = tempfile.mkstemp()
			os.close(handle)
			random_map_db = DbReader(self._temp_path2)
			with open('content/map-template.sql') as map_template:
				random_map_db.execute_script(map_template.read())
			for island_id, island_string in enumerate(random_island_sequence):
				create_random_island(random_map_db, island_id, island_string)
			random_map_db.close()
			self._map_path = self._temp_path2

			self('INSERT INTO metadata VALUES(?, ?)', 'random_island_sequence',
				' '.join(random_island_sequence))

		if options is not None:
			if options.map_padding is not None:
				self("INSERT INTO map_properties VALUES(?, ?)", 'padding', options.map_padding)

		self('ATTACH ? AS map_file', self._map_path)
		if is_random_map:
			self.map_name = random_island_sequence
		elif os.path.isabs(self._map_path):
			self.map_name = self._map_path
		else:
			self.map_name = SavegameManager.get_savegamename_from_filename(self._map_path)

		map_padding = self("SELECT value FROM map_properties WHERE name = 'padding'")
		self.map_padding = int(map_padding[0][0]) if map_padding else MAP.PADDING

		self._load_building()
		self._load_settlement()
		self._load_concrete_object()
		self._load_production()
		self._load_storage()
		self._load_wildanimal()
		self._load_unit()
		self._load_building_collector()
		self._load_production_line()
		self._load_unit_path()
		self._load_storage_global_limit()
		self._load_health()
		self._load_fish_data()
		self._hash = None

	def close(self):
		super(SavegameAccessor, self).close()
		if self.upgrader is not None:
			self.upgrader.close()
		if self._temp_path is not None:
			os.unlink(self._temp_path)
		if hasattr(self, '_temp_path2'):
			os.unlink(self._temp_path2)

	def _load_building(self):
		self._building = {}
		for row in self("SELECT rowid, x, y, location, rotation, level FROM building"):
			self._building[int(row[0])] = row[1:]

	def get_building_row(self, worldid):
		"""Returns (x, y, location, rotation, level)"""
		return self._building[int(worldid)]

	def get_building_location(self, worldid):
		return self._building[int(worldid)][2]


	def _load_settlement(self):
		self._settlement = {}
		for row in self("SELECT rowid, owner, island FROM settlement"):
			self._settlement[int(row[0])] = row[1:]

	def get_settlement_owner(self, worldid):
		"""Returns the id of the owner of the settlement or None otherwise"""
		return self._settlement.get(int(worldid), [None])[0]

	def get_settlement_island(self, worldid):
		return self._settlement[int(worldid)][1]


	def _load_concrete_object(self):
		self._concrete_object = {}
		for row in self("SELECT id, action_runtime, action_set_id FROM concrete_object"):
			self._concrete_object[int(row[0])] = int(row[1]), row[2]

	def get_concrete_object_data(self, worldid):
		return self._concrete_object[int(worldid)]


	def _load_production(self):
		self._productions_by_worldid = {}
		self._production_lines_by_owner = {}
		self._productions_by_id_and_owner = {}
		db_data = self("SELECT rowid, state, owner, prod_line_id, remaining_ticks, _pause_old_state, creation_tick FROM production")
		for row in db_data:
			rowid = int(row[0])
			data = row[1:]
			self._productions_by_worldid[rowid] = data
			owner = int(row[2])
			line = int(row[3])
			if not line in self._productions_by_id_and_owner:
				self._productions_by_id_and_owner[line] = {}
			# in the line dict, the owners are unique
			self._productions_by_id_and_owner[line][owner] = data

			if owner not in self._production_lines_by_owner:
				self._production_lines_by_owner[owner] = [line]
			else:
				self._production_lines_by_owner[owner].append(line)

			self._production_lines_by_owner[owner].append

		self._production_state_history = defaultdict(deque)
		for object_id, production_id, tick, state in self("SELECT object_id, production, tick, state FROM production_state_history ORDER BY object_id, production, tick"):
			self._production_state_history[int(object_id), int(production_id)].append((tick, state))

	def get_production_by_id_and_owner(self, id, ownerid):
		# owner means worldid of entity
		return self._productions_by_id_and_owner[id][ownerid]

	def get_production_line_id(self, production_worldid):
		"""Returns the prod_line_id of the given production"""
		return self._productions_by_worldid[int(production_worldid)][2]

	def get_production_lines_by_owner(self, owner):
		"""Returns the prod_line_id of the given production"""
		return self._production_lines_by_owner.get(owner, [])

	def get_production_state_history(self, worldid, prod_id):
		return self._production_state_history[int(worldid), int(prod_id)]


	def _load_storage(self):
		self._storage = {}
		for row in self("SELECT object, resource, amount FROM storage"):
			ownerid = int(row[0])
			if ownerid in self._storage:
				self._storage[ownerid].append(row[1:])
			else:
				self._storage[ownerid] = [row[1:]]

	def get_storage_rowids_by_ownerid(self, ownerid):
		"""Returns potentially empty list of worldids referencing storages"""
		return self._storage.get(int(ownerid), [])


	def _load_wildanimal(self):
		self._wildanimal = {}
		for row in self("SELECT rowid, health, can_reproduce FROM wildanimal"):
			self._wildanimal[int(row[0])] = row[1:]

	def get_wildanimal_row(self, worldid):
		"""Returns (health, can_reproduce)"""
		return self._wildanimal[int(worldid)]


	def _load_unit(self):
		self._unit = {}
		for row in self("SELECT rowid, owner FROM unit"):
			self._unit[int(row[0])] = int(row[1])

	def get_unit_owner(self, worldid):
		return self._unit[int(worldid)]


	def _load_building_collector(self):
		self._building_collector = {}
		for row in self("SELECT rowid, home_building, creation_tick FROM building_collector"):
			self._building_collector[int(row[0])] = (int(row[1]) if row[1] is not None else None, row[2])

		self._building_collector_job_history = defaultdict(deque)
		for collector_id, tick, utilization in self("SELECT collector, tick, utilisation FROM building_collector_job_history ORDER BY collector, tick"):
			self._building_collector_job_history[int(collector_id)].append((tick, utilization))

	def get_building_collectors_data(self, worldid):
		"""Returns (id of the building collector's home or None otherwise, creation_tick)"""
		return self._building_collector.get(int(worldid))

	def get_building_collector_job_history(self, worldid):
		return self._building_collector_job_history[int(worldid)]


	def _load_production_line(self):
		self._production_line = {}
		for row in self("SELECT for_worldid, type, res, amount FROM production_line"):
			id = int(row[0])
			if id not in self._production_line:
				self._production_line[id] = []
			self._production_line[id].append(row[1:])

	def get_production_line_row(self, for_worldid):
		return self._production_line[int(for_worldid)]


	def _load_unit_path(self):
		self._unit_path = {}
		for row in self("SELECT unit, x, y FROM unit_path ORDER BY 'index'"):
			id = int(row[0])
			if id not in self._unit_path:
				self._unit_path[id] = []
			self._unit_path[id].append(row[1:])

	def get_unit_path(self, worldid):
		return self._unit_path.get(int(worldid))


	def _load_storage_global_limit(self):
		self._storage_global_limit = {}
		for row in self("SELECT object, value FROM storage_global_limit"):
			self._storage_global_limit[(int(row[0]))] = int(row[1])

	def get_storage_global_limit(self, worldid):
		return self._storage_global_limit[int(worldid)]


	def _load_health(self):
		self._health = dict( self("SELECT owner_id, health FROM unit_health") )

	def get_health(self, owner):
		return self._health[owner]


	def _load_fish_data(self):
		self._fish_data = {}
		for row in self("SELECT rowid, last_usage_tick FROM fish_data"):
			self._fish_data[int(row[0])] = int(row[1])

	def get_last_fish_usage_tick(self, worldid):
		return self._fish_data[worldid]

	# Random savegamefile related utility that i didn't know where to put

	@classmethod
	def get_players_num(cls, savegamefile):
		"""Return number of regular human and ai players"""
		return DbReader(savegamefile)("SELECT count(rowid) FROM player WHERE is_trader = 0 AND is_pirate = 0")[0][0]

	@classmethod
	def get_hash(cls, savegamefile):
		if not os.path.exists(savegamefile):
			return False
		fd = open(savegamefile, "rb")
		h = hashlib.sha1()
		h.update(fd.read())
		filehash = h.hexdigest()
		fd.close()
		return filehash

decorators.bind_all(SavegameAccessor)

########NEW FILE########
__FILENAME__ = savegameupgrader
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import os
import os.path
import json
import shutil
import tempfile

from collections import defaultdict
from sqlite3 import OperationalError
from yaml.parser import ParserError

from horizons.constants import BUILDINGS, VERSION, UNITS
from horizons.entities import Entities
from horizons.util.dbreader import DbReader
from horizons.util.python import decorators
from horizons.util.shapes import Rect
from horizons.util.yamlcache import YamlCache


class SavegameUpgrader(object):
	"""The class that prepares saved games to be loaded by the current version."""

	log = logging.getLogger("util.savegameupgrader")

	def __init__(self, path):
		super(SavegameUpgrader, self).__init__()
		self.original_path = path
		self.using_temp = False
		self.final_path = None

	def _upgrade_to_rev49(self, db):
		db('CREATE TABLE "resource_overview_bar" (object INTEGER NOT NULL, position INTEGER NOT NULL, resource INTEGER NOT NULL)')

	def _upgrade_to_rev50(self, db):
		db('UPDATE stance set stance = "hold_ground_stance" where stance = "hold_ground"')
		db('UPDATE stance set stance = "none_stance" where stance = "none"')
		db('UPDATE stance set stance = "flee_stance" where stance = "flee_stance"')
		db('UPDATE stance set stance = "aggressive_stance" where stance = "aggressive"')

	def _upgrade_to_rev51(self, db):
		# add fire slot to settlers. Use direct numbers since only these work and they must never change.
		for (settler_id, ) in db("SELECT rowid FROM building WHERE type = ?", 3):
			db("INSERT INTO storage_slot_limit(object, slot, value) VALUES(?, ?, ?)",
			   settler_id, 42, 1)

	def _upgrade_to_rev52(self, db):
		# create empty disaster tables
		db('CREATE TABLE "disaster" ( type STRING NOT NULL, settlement INTEGER NOT NULL, remaining_ticks_expand INTEGER NOT NULL)')
		db('CREATE TABLE "fire_disaster" ( disaster INTEGER NOT NULL, building INTEGER NOT NULL, remaining_ticks_havoc INTEGER NOT NULL )')
		db('CREATE TABLE "disaster_manager" ( remaining_ticks INTEGER NOT NULL )')
		db('INSERT INTO "disaster_manager" VALUES(1)')

	def _upgrade_to_rev53(self, db):
		# convert old logbook (heading, message) tuples to new syntax, modify logbook table layout
		old_entries = db("SELECT heading, message FROM logbook")
		db('DROP TABLE logbook')
		db('CREATE TABLE logbook ( widgets STRING )')
		widgets = []
		for heading, message in old_entries:
			add = []
			add.append(['Headline', heading])
			add.append(['Image', "content/gui/images/background/hr.png"])
			add.append(['Label', message])
			widgets.append(add)
		db("INSERT INTO logbook(widgets) VALUES(?)", json.dumps(widgets))

	def _upgrade_to_rev54(self, db):
		for (settlement,) in db("SELECT DISTINCT settlement FROM settlement_level_properties WHERE level = ?", 0):
			db("INSERT INTO settlement_level_properties VALUES(?, 3, 0, 1)", settlement)

	def _upgrade_to_rev55(self, db):
		# The upgrade system has been mishandled, this upgrade tries to fix
		# as much as possible. It's partly brute force and might not work every
		# time, however the savegames are in an undefined state, so recovery is hard

		# make anything inflamable, the code should be able to handle it
		for (obj, ) in db("SELECT rowid FROM building where type != 8"):
			db("INSERT INTO storage_slot_limit (object, slot, value) VALUES (?, ?, ?)",
			   obj, 99, 1)

		# make farm be able to store grain and stuff
		for (obj, ) in db("SELECT rowid FROM building where type = 20"):
			db("INSERT INTO storage_slot_limit (object, slot, value) VALUES (?, ?, ?)",
			   obj, 43, 6)
			db("INSERT INTO storage_slot_limit (object, slot, value) VALUES (?, ?, ?)",
			   obj, 42, 6)

	def _upgrade_to_rev56(self, db):
		db('CREATE TABLE "last_active_settlement" ( type STRING NOT NULL, value INTEGER NOT NULL )')
		db("INSERT INTO last_active_settlement(type, value) VALUES(?, ?)", "LAST_NONE_FLAG", False)

	def _upgrade_to_rev57(self, db):
		"""Change storage of scenario variables from pickle to json."""
		import pickle
		db.connection.text_factory = str # need to read as str, utf-8 chokes on binary pickle

		for key, value in db("SELECT key, value FROM scenario_variables"):
			value = pickle.loads(value)
			value = json.dumps(value)
			db("UPDATE scenario_variables SET value = ? WHERE key = ?", value, key)

	def _upgrade_to_rev58(self, db):
		# multiple resources for collector jobs
		data = [ i for i in db("SELECT rowid, object, resource, amount FROM collector_job") ]
		db("DROP TABLE  collector_job")
		db("CREATE TABLE `collector_job` (`collector` INTEGER, `object` INTEGER DEFAULT NULL, `resource` INTEGER DEFAULT NULL, `amount` INTEGER DEFAULT NULL)")
		for row in data:
			db("INSERT INTO collector_job(collector, object, resource, amount) VALUES(?, ?, ?, ?)", *row)

	def _upgrade_to_rev59(self, db):
		# action set id save/load
		try:
			db("ALTER TABLE concrete_object ADD COLUMN action_set_id STRING DEFAULT NULL")
			# None is not a valid value, but it's hard to determine valid ones here,
			# so as an exception, we let the loading code handle it (in ConcreteObject.load)
		except OperationalError:
			# Some scenario maps had concrete_object updated with 8b3cb4bae1067e
			pass

	def _upgrade_to_rev60(self, db):
		# some production line id changes

		# [(object id, old prod line id, new prod line id)]
		changes = [
			(33, 42, 923331670),
			(9, 18, 1335785398),
			(42, 57, 227255506),
			(20, 8, 21429697),
			(20, 1, 1953634498),
			(20, 4, 70113509),
			(20, 47, 1236502256),
			(20, 52, 2078307024),
			(20, 23, 2092896117),
			(20, 0, 208610842),
			(20, 28, 2053891886),
			(20, 2, 1265004933),
			(20, 51, 1253640427),
			(20, 3, 1849560830),
			(20, 7, 1654557398),
			(60, 0, 532714998),
			(19, 22, 2092896117),
			(63, 2, 2097838825),
			(63, 0, 87034972),
			(63, 1, 570450416),
			(63, 3, 359183511),
			(8, 2, 256812226),
			(26, 34, 1842760585),
			(49, 1, 1953634498),
			(46, 0, 344746552),
			(28, 36, 1510556113),
			(45, 56464472, 1907712664),
			(35, 45, 854772720),
			(55, 0, 1971678669),
			(40, 57, 227255506),
			(54, 0, 1971678669),
			(29, 37, 1698523401),
			(11, 11, 923331670),
			(18, 5, 1654557398),
			(5, 13, 1056282634),
		]
		for obj_type, old_prod_line, new_prod_line in changes:
			for (obj, ) in db("SELECT rowid FROM building WHERE type = ?", obj_type):
				db("UPDATE production SET prod_line_id = ? WHERE owner = ? and prod_line_id = ?", new_prod_line, obj, old_prod_line)

	def _upgrade_to_rev61(self, db):
		from horizons.world.building.settler import SettlerUpgradeData

		# settler upgrade lines used to be the same for several levels
		for (settler, level) in db("SELECT rowid, level FROM building WHERE type = 3"):
			#if settler == 100268:import pdb ; pdb.set_trace()
			# the id used to always be 35
			db("UPDATE production SET prod_line_id = ? WHERE owner = ? and prod_line_id = 35", SettlerUpgradeData.get_production_line_id( level + 1 ), settler)

	def _upgrade_to_rev62(self, db):
		# added a message parameter to the logbook which needs to be saved
		db("CREATE TABLE IF NOT EXISTS logbook_messages ( message STRING )")

	def _upgrade_to_rev63(self, db):
		""" Due to miscommunication, the savegame revision 62 was not changed in
		savegames after updates to 63. To keep savegames functional that have a
		revision of 62 stored but where the upgrade to 63 was executed, we assume
		that this has to happen for savegames of revision <62 unless CREATEing tables
		raises an OperationalError, which indicates that they already exist and thus
		this upgrade routine should also work for savegames with odd upgrade paths:
		There may have been branches storing revision 63 in savegames after all.
		"""
		# adds a table for pirate's 'tick' callback
		try:
			db("CREATE TABLE ai_pirate (remaining_ticks INTEGER NOT NULL DEFAULT 1)")
		except OperationalError:
			return
		db("INSERT INTO ai_pirate (rowid, remaining_ticks) SELECT p.rowid, 1 FROM player p WHERE p.is_pirate")
		# added flag to aiplayer for fighting ships request
		db("ALTER TABLE ai_player ADD COLUMN need_more_combat_ships INTEGER NOT NULL DEFAULT 1")

		# update stance for every pirate player ship
		db('INSERT INTO stance (worldid, stance, state) SELECT u.rowid, "none_stance", "idle" FROM unit u, player p WHERE u.owner=p.rowid AND p.is_pirate=1')

		# update ai_player with long callback function column
		db("ALTER TABLE ai_player ADD COLUMN remaining_ticks_long INTEGER NOT NULL DEFAULT 1")

		# update ai_pirate with long callback function column
		db("ALTER TABLE ai_pirate ADD COLUMN remaining_ticks_long INTEGER NOT NULL DEFAULT 1")

		# Combat missions below:
		# Abstract FleetMission data
		db('CREATE TABLE "ai_fleet_mission" ( "owner_id" INTEGER NOT NULL , "fleet_id" INTEGER NOT NULL , "state_id" INTEGER NOT NULL, "combat_phase" BOOL NOT NULL )')
		# ScoutingMission
		db('CREATE TABLE "ai_scouting_mission" ("owner" INTEGER NOT NULL , "ship" INTEGER NOT NULL , "starting_point_x" INTEGER NOT NULL, '
		   '"starting_point_y" INTEGER NOT NULL, "target_point_x" INTEGER NOT NULL, "target_point_y" INTEGER NOT NULL, "state" INTEGER NOT NULL )')
		# SurpriseAttack
		db('CREATE TABLE "ai_mission_surprise_attack" ("enemy_player_id" INTEGER NOT NULL, "target_point_x" INTEGER NOT NULL, "target_point_y" INTEGER NOT NULL,'
		   '"target_point_radius" INTEGER NOT NULL, "return_point_x" INTEGER NOT NULL, "return_point_y" INTEGER NOT NULL )')
		# ChaseShipsAndAttack
		db('CREATE TABLE "ai_mission_chase_ships_and_attack" ("target_ship_id" INTEGER NOT NULL )')

		# BehaviorManager
		db('CREATE TABLE "ai_behavior_manager" ("owner_id" INTEGER NOT NULL, "profile_token" INTEGER NOT NULL)')

		# No previous token was present, choose anything really
		db('INSERT INTO ai_behavior_manager (owner_id, profile_token) SELECT p.rowid, 42 FROM player p')

		# Locks for Conditions being resolved by StrategyManager
		db('CREATE TABLE "ai_condition_lock" ("owner_id" INTEGER NOT NULL, "condition" TEXT NOT NULL, "mission_id" INTEGER NOT NULL)')

		# Fleets
		db('CREATE TABLE "fleet" ("fleet_id" INTEGER NOT NULL, "owner_id" INTEGER NOT NULL, "state_id" INTEGER NOT NULL, "dest_x" '
		   'INTEGER, "dest_y" INTEGER, "radius" INTEGER, "ratio" DOUBLE)')

		# ships per given fleet
		db('CREATE TABLE "fleet_ship" ("fleet_id" INTEGER NOT NULL, "ship_id" INTEGER NOT NULL, "state_id" INTEGER NOT NULL)')

		# CombatManager's ship states
		db('CREATE TABLE "ai_combat_ship" ( "owner_id" INTEGER NOT NULL, "ship_id" INTEGER NOT NULL, "state_id" INTEGER NOT NULL )')

		# Set CombatManager's state of ship to idle
		db('INSERT INTO ai_combat_ship (owner_id, ship_id, state_id) SELECT p.rowid, u.rowid, 0 FROM player p, unit u WHERE u.owner = p.rowid AND u.type=? and p.client_id="AIPlayer"', UNITS.FRIGATE)

		# Same for pirate ships
		db('INSERT INTO ai_combat_ship (owner_id, ship_id, state_id) SELECT p.rowid, u.rowid, 0 FROM ai_pirate p, unit u WHERE u.owner = p.rowid')

		# save pirate routine mission
		db('CREATE TABLE "ai_mission_pirate_routine" ("target_point_x" INTEGER NOT NULL, "target_point_y" INTEGER NOT NULL )')

	def _upgrade_to_rev64(self, db):
		db("INSERT INTO metadata VALUES (?, ?)", "max_tier_notification", False)

	def _upgrade_to_rev65(self, db):
		island_path = db("SELECT file FROM island ORDER BY file LIMIT 1")[0][0]
		map_names = {
			'content/islands/bay_and_lake.sqlite': 'development',
			'content/islands/fightForRes_island_0_169.sqlite': 'fight-for-res',
			'content/islands/full_house_island_0_25.sqlite': 'full-house',
			'content/islands/mp-dev_island_0_0.sqlite': 'mp-dev',
			'content/islands/quattro_island_0_19.sqlite': 'quattro',
			'content/islands/rouver_island_0_0.sqlite': 'rouver',
			'content/islands/singularity40_island_0_0.sqlite': 'singularity40',
			'content/islands/tiny.sqlite': 'test-map-tiny',
			'content/islands/triple_island_0_74.sqlite': 'triple'
		}
		if island_path in map_names:
			db('INSERT INTO metadata VALUES (?, ?)', 'map_name', map_names[island_path])
			return

		# random map
		island_strings = []
		for island_x, island_y, island_string in db('SELECT x, y, file FROM island ORDER BY rowid'):
			island_strings.append(island_string + ':%d:%d' % (island_x, island_y))
		db('INSERT INTO metadata VALUES (?, ?)', 'random_island_sequence', ' '.join(island_strings))

	def _upgrade_to_rev66(self, db):
		db("DELETE FROM metadata WHERE name='max_tier_notification'")
		db("ALTER TABLE player ADD COLUMN max_tier_notification INTEGER")
		db("UPDATE player SET max_tier_notification = 0")

	def _upgrade_to_rev67(self, db):
		db('CREATE TABLE "trade_slots" ("trade_post" INT NOT NULL, "slot_id" INT NOT NULL, "resource_id" INT NOT NULL, "selling" BOOL NOT NULL, "trade_limit" INT NOT NULL)')
		for trade_post, in db("SELECT DISTINCT object FROM (SELECT object FROM trade_sell UNION SELECT object FROM trade_buy) ORDER BY object"):
			slot_id = 0
			for table in ['trade_buy', 'trade_sell']:
				for resource_id, limit in db("SELECT resource, trade_limit FROM " + table + " WHERE object = ? ORDER BY object, resource", trade_post):
					db("INSERT INTO trade_slots VALUES(?, ?, ?, ?, ?)", trade_post, slot_id, resource_id, table == 'trade_sell', limit)
					slot_id += 1

	def _upgrade_to_rev68(self, db):
		settlement_founding_missions = []
		db_result = db("SELECT rowid, land_manager, ship, warehouse_builder, state FROM ai_mission_found_settlement")
		for (worldid, land_manager_id, ship_id, builder_id, state) in db_result:
			x, y = db("SELECT x, y FROM ai_builder WHERE rowid = ?", builder_id)[0]
			settlement_founding_missions.append((worldid, land_manager_id, ship_id, x, y, state))

		db("DROP TABLE ai_mission_found_settlement")
		db('CREATE TABLE "ai_mission_found_settlement" ("land_manager" INT NOT NULL, "ship" INT NOT NULL, "x" INT NOT NULL, "y" INT NOT NULL, "state" INT NOT NULL)')

		for row in settlement_founding_missions:
			db("INSERT INTO ai_mission_found_settlement(rowid, land_manager, ship, x, y, state) VALUES(?, ?, ?, ?, ?, ?)", *row)

	def _upgrade_to_rev69(self, db):
		settlement_map = {}
		for data in db("SELECT rowid, data FROM settlement_tiles"):
			settlement_id = int(data[0])
			coords_list = [tuple(raw_coords) for raw_coords in json.loads(data[1])] # json saves tuples as list
			for coords in coords_list:
				settlement_map[coords] = settlement_id
		db("DELETE FROM settlement_tiles")

		for (worldid, building_id, x, y, location_id) in db("SELECT rowid, type, x, y, location FROM building WHERE type = ? OR type = ?",
				                                            BUILDINGS.CLAY_DEPOSIT, BUILDINGS.MOUNTAIN):
			worldid = int(worldid)
			building_id = int(building_id)
			origin_coords = (int(x), int(y))
			location_id = int(location_id)

			settlement_ids = set()
			position = Rect.init_from_topleft_and_size_tuples(origin_coords, Entities.buildings[building_id].size)
			for coords in position.tuple_iter():
				if coords in settlement_map:
					settlement_ids.add(settlement_map[coords])
			if not settlement_ids:
				continue # no settlement covers any of the deposit
			else:
				# assign all of it to the earlier settlement
				settlement_id = sorted(settlement_ids)[0]
				for coords in position.tuple_iter():
					settlement_map[coords] = settlement_id
				if location_id != settlement_id:
					db("UPDATE building SET location = ? WHERE rowid = ?", settlement_id, worldid)

		# save the new settlement tiles data
		ground_map = defaultdict(list)
		for (coords, settlement_id) in settlement_map.iteritems():
			ground_map[settlement_id].append(coords)

		for (settlement_id, coords_list) in ground_map.iteritems():
			data = json.dumps(coords_list)
			db("INSERT INTO settlement_tiles(rowid, data) VALUES(?, ?)", settlement_id, data)

	def _upgrade_to_rev70(self, db):
		db('CREATE TABLE "fish_data" ("last_usage_tick" INT NOT NULL)')
		for row in db("SELECT rowid FROM building WHERE type = ?", BUILDINGS.FISH_DEPOSIT):
			db("INSERT INTO fish_data(rowid, last_usage_tick) VALUES(?, ?)", row[0], -1000000)

	def _upgrade_to_rev71(self, db):
		old = 'MAX_INCR_REACHED'
		new = 'MAX_TIER_REACHED'
		db("UPDATE message_widget_active  SET id = ? WHERE id = ?", new, old)
		db("UPDATE message_widget_archive SET id = ? WHERE id = ?", new, old)

	def _upgrade_to_rev72(self, db):
		# rename fire_disaster to building_influencing_disaster
		db("ALTER TABLE fire_disaster RENAME TO building_influencing_disaster")

	def _upgrade_to_rev73(self, db):
		# Attempt to fix up corrupt yaml dumped into scenario savegames (#2164)
		key = 'scenario_events'
		try:
			yaml_data = db("SELECT name, value FROM metadata WHERE name = ?", key)[0][1]
		except IndexError:
			# Not a scenario, nothing to repair
			return
		try:
			YamlCache.load_yaml_data(yaml_data)
		except ParserError:
			messed_up = 'events: [ { actions: [ {'
			yaml_data = yaml_data.replace(messed_up, '}, ' + messed_up)
			db("UPDATE metadata SET value = ? WHERE name = ?", yaml_data, key)

	def _upgrade_to_rev74(self, db):
		db("INSERT INTO metadata VALUES (?, ?)", "selected_tab", None)


	def _upgrade(self):
		# fix import loop
		from horizons.savegamemanager import SavegameManager
		metadata = SavegameManager.get_metadata(self.original_path)
		rev = metadata['savegamerev']
		if rev == 0: # not a regular savegame, usually a map
			self.final_path = self.original_path
		elif rev == VERSION.SAVEGAMEREVISION: # the current version
			self.final_path = self.original_path
		else: # upgrade
			self.log.warning('Discovered old savegame file, auto-upgrading: %s -> %s' % \
						     (rev, VERSION.SAVEGAMEREVISION))
			self.using_temp = True
			handle, self.final_path = tempfile.mkstemp(prefix='uh-savegame.' + os.path.basename(os.path.splitext(self.original_path)[0]) + '.', suffix='.sqlite')
			os.close(handle)
			shutil.copyfile(self.original_path, self.final_path)
			db = DbReader(self.final_path)
			db('BEGIN TRANSACTION')

			if rev < 49:
				self._upgrade_to_rev49(db)
			if rev < 50:
				self._upgrade_to_rev50(db)
			if rev < 51:
				self._upgrade_to_rev51(db)
			if rev < 52:
				self._upgrade_to_rev52(db)
			if rev < 53:
				self._upgrade_to_rev53(db)
			if rev < 54:
				self._upgrade_to_rev54(db)
			if rev < 55:
				self._upgrade_to_rev55(db)
			if rev < 56:
				self._upgrade_to_rev56(db)
			if rev < 57:
				self._upgrade_to_rev57(db)
			if rev < 58:
				self._upgrade_to_rev58(db)
			if rev < 59:
				self._upgrade_to_rev59(db)
			if rev < 60:
				self._upgrade_to_rev60(db)
			if rev < 61:
				self._upgrade_to_rev61(db)
			if rev < 62:
				self._upgrade_to_rev62(db)
			if rev < 63:
				self._upgrade_to_rev63(db)
			if rev < 64:
				self._upgrade_to_rev64(db)
			if rev < 65:
				self._upgrade_to_rev65(db)
			if rev < 66:
				self._upgrade_to_rev66(db)
			if rev < 67:
				self._upgrade_to_rev67(db)
			if rev < 68:
				self._upgrade_to_rev68(db)
			if rev < 69:
				self._upgrade_to_rev69(db)
			if rev < 70:
				self._upgrade_to_rev70(db)
			if rev < 71:
				self._upgrade_to_rev71(db)
			if rev < 72:
				self._upgrade_to_rev72(db)
			if 70 < rev < 73:
				self._upgrade_to_rev73(db)
			if rev < 74:
				self._upgrade_to_rev74(db)

			db('COMMIT')
			db.close()

	@classmethod
	def can_upgrade(cls, from_savegame_version):
		"""Calculates whether a savegame can be upgraded from the current version"""
		for i in xrange(from_savegame_version+1, VERSION.SAVEGAMEREVISION+1, 1):
			if not hasattr(cls, "_upgrade_to_rev" + str(i)):
				return False
		return True


	def get_path(self):
		"""Return the path to the up-to-date version of the saved game."""
		if self.final_path is None:
			self._upgrade()
		return self.final_path

	def close(self):
		if self.using_temp:
			self.using_temp = False
			os.unlink(self.final_path)
		self.final_path = None

decorators.bind_all(SavegameUpgrader)

########NEW FILE########
__FILENAME__ = annulus
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.python.decorators import bind_all
from horizons.util.shapes import Point, Shape

class Annulus(Shape):
	"""Class for the shape of an annulus
	You can access center and radius of the annulus as public members."""
	def __init__(self, center, min_radius, max_radius):
		"""
		@param center: Point
		@param min_radius: int
		@param max_radius: int
		"""
		assert isinstance(center, Point)
		self.center = center
		self.min_radius = min_radius
		self.max_radius = max_radius

	def contains(self, point):
		assert isinstance(point, Point)
		return self.min_radius <= point.distance(self.center) <= self.max_radius

	def __str__(self):
		return "Annulus(center=%s,min_radius=%s,max_radius=%s)" % (self.center, self.min_radius, self.max_radius)

	def __eq__(self, other):
		try:
			return self.center == other.center and \
			       self.min_radius == other.min_radius and \
			       self.max_radius == other.max_radius
		except AttributeError:
			return False

	def __ne__(self, other):
		return not self.__eq__(other)

	def __hash__(self):
		return hash((self.center, self.min_radius, self.max_radius))

	def tuple_iter(self):
		for x in xrange(self.center.x-self.max_radius, self.center.x+self.max_radius+1):
			for y in xrange(self.center.y-self.max_radius, self.center.y+self.max_radius+1):
				if self.min_radius <= self.center.distance((x, y)) <= self.max_radius:
					yield (x, y)

bind_all(Annulus)

########NEW FILE########
__FILENAME__ = circle
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.python.decorators import bind_all
from horizons.util.shapes import Point, Shape

class Circle(Shape):
	"""Class for the shape of a circle
	You can access center and radius of the circle as public members."""
	def __init__(self, center, radius):
		"""
		@param center: Point
		@param radius: int
		"""
		assert isinstance(center, Point)
		self.center = center
		self.radius = radius

	def contains(self, point):
		assert isinstance(point, Point)
		dx = point.x - self.center.x
		dy = point.y - self.center.y
		return dx * dx + dy * dy <= self.radius * self.radius

	def intersects_rect(self, rect):
		return rect.distance(self.center) > self.radius

	def __str__(self):
		return "Circle(center=%s,radius=%s)" % (self.center, self.radius)

	def __eq__(self, other):
		try:
			return self.center == other.center and self.radius == other.radius
		except AttributeError:
			return False

	def __ne__(self, other):
		return not self.__eq__(other)

	def __hash__(self):
		return hash((self.center, self.radius))

	def tuple_iter(self):
		"""Iterate through all coords in the circle as tuples."""
		cx = self.center.x
		cy = self.center.y
		radius_sq = self.radius * self.radius
		for x in xrange(cx - self.radius, cx + self.radius + 1):
			for y in xrange(cy - self.radius, cy + self.radius + 1):
				dx = cx - x
				dy = cy - y
				dist_sq = dx * dx + dy * dy
				if dist_sq <= radius_sq:
					yield (x, y)

	def get_border_coordinates(self, bordersize=1):
		"""Returns only coordinates at the border. Very naive implementation"""
		for x in xrange(self.center.x-self.radius, self.center.x+self.radius+1):
			for y in xrange(self.center.y-self.radius, self.center.y+self.radius+1):
				if (self.radius - bordersize) <= self.center.distance((x, y)) <= self.radius:
					yield (x, y)

bind_all(Circle)

########NEW FILE########
__FILENAME__ = distances
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

# Point

def distance_point_point(p1, p2):
	return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** 0.5

def distance_point_tuple(point, (x, y)):
	return ((point.x - x) ** 2 + (point.y - y) ** 2) ** 0.5

def distance_point_circle(point, circle):
	dist = point.distance(circle.center) - circle.radius
	return dist if dist >= 0 else 0

def distance_point_rect(point, rect):
	return ((max(rect.left - point.x, 0, point.x - rect.right) ** 2) +
            (max(rect.top - point.y, 0, point.y - rect.bottom) ** 2)) ** 0.5

def distance_point_annulus(point, annulus):
	dist = point.distance(annulus.center)
	if dist < annulus.min_radius:
		return annulus.min_radius - dist
	if dist > annulus.max_radius:
		return dist - annulus.max_radius
	return 0

# Circle

def distance_circle_circle(c1, c2):
	dist = c1.distance(c2.center) - c1.radius - c2.radius
	return dist if dist >= 0 else 0

def distance_circle_tuple(circle, (x, y)):
	dist = ((circle.center.x - x) ** 2 + (circle.center.y - y) ** 2) ** 0.5 - circle.radius
	return dist if dist >= 0 else 0

def distance_circle_annulus(circle, annulus):
	dist = circle.distance(annulus.center) - circle.radius - annulus.max_radius
	return dist if dist >= 0 else 0

# Rect

def distance_rect_rect(r1, r2):
	dx = 0
	t = r1.left - r2.right
	if t > dx:
		dx = t
	t = r2.left - r1.right
	if t > dx:
		dx = t

	dy = 0
	t = r1.top - r2.bottom
	if t > dy:
		dy = t
	t = r2.top - r1.bottom
	if t > dy:
		dy = t
	return (dx * dx + dy * dy) ** 0.5

def distance_rect_rect_sq(r1, r2):
	dx = 0
	t = r1.left - r2.right
	if t > dx:
		dx = t
	t = r2.left - r1.right
	if t > dx:
		dx = t

	dy = 0
	t = r1.top - r2.bottom
	if t > dy:
		dy = t
	t = r2.top - r1.bottom
	if t > dy:
		dy = t
	return dx * dx + dy * dy

def distance_rect_tuple(rect, (x, y)):
	dx = 0
	t = rect.left - x
	if t > dx:
		dx = t
	t = x - rect.right
	if t > dx:
		dx = t

	dy = 0
	t = rect.top - y
	if t > dy:
		dy = t
	t = y - rect.bottom
	if t > dy:
		dy = t
	return (dx * dx + dy * dy) ** 0.5

def distance_rect_circle(rect, circle):
	dist = rect.distance(circle.center) - circle.radius
	return dist if dist >= 0 else 0

def distance_rect_annulus(rect, annulus):
	dist = rect.distance(annulus.center) - annulus.max_radius
	return dist if dist >= 0 else 0

# Annulus

def distance_annulus_annulus(a1, a2):
	dist = a1.distance(a2.center) - a1.max_radius - a2.max_radius
	return dist if dist >= 0 else 0

def distance_annulus_tuple(annulus, (x, y)):
	dist = ((annulus.center.x - x) ** 2 + (annulus.center.y - y) ** 2) ** 0.5
	if dist < annulus.min_radius:
		return annulus.min_radius - dist
	if dist > annulus.max_radius:
		return dist - annulus.max_radius
	return 0


# DEBUG
if __name__ == '__main__':
	import itertools
	import distances
	shapes = ('rect', 'point', 'tuple', 'circle', 'annulus')
	for s1, s2 in itertools.product(shapes, shapes):
		if not (hasattr(distances, 'distance_%s_%s' % (s1, s2)) or
		        hasattr(distances, 'distance_%s_%s' % (s2, s1))):
			print 'missing distance between', s1, s2

########NEW FILE########
__FILENAME__ = point
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.python.decorators import bind_all
from horizons.util.python import Const
from horizons.util.shapes import Shape

class Point(Shape):
	def __init__(self, x, y):
		self.x = x
		self.y = y

	def copy(self):
		return Point(self.x, self.y)

	def to_tuple(self):
		"""Returns point as a tuple"""
		return (self.x, self.y)

	@property
	def center(self):
		"""Returns the center of the point (this makes Point interface more coherent with Rect).
		"""
		return self

	def offset(self, x_offset, y_offset):
		"""Returns a Point with an offset of x, y relative to this Point.
		@param x_offset: int relative x-offset of the point to return
		@param y_offset: int relative y-offset of the point to return
		@return: a Point with offset x, y relative to the 'self' Point
		"""
		return Point(self.x + x_offset, self.y + y_offset)

	def contains(self, point):
		"""For compatibility with Rect"""
		return self.x == point.x and self.y == point.y

	def __str__(self):
		""" nice representation for debugging purposes """
		return 'Point(%s, %s)' % (self.x, self.y)

	def __eq__(self, other):
		if other is None:
			return False
		elif isinstance(other, Point):
			return self.x == other.x and self.y == other.y
		else: # other is tuple
			try:
				return self.x == other[0] and self.y == other[1]
			except TypeError:
				return False

	def __add__(self, other):
		assert isinstance(other, Point)
		return Point(self.x+other.x, self.y+other.y)

	def __sub__(self, other):
		assert isinstance(other, Point)
		return Point(self.x-other.x, self.y-other.y)

	def __hash__(self):
		return hash((self.x, self.y))

	def tuple_iter(self):
		yield self.to_tuple()

	def iter_without_border(self):
		yield self

class ConstPoint(Const, Point):
	"""An immutable Point"""
	pass


bind_all(Point)
bind_all(ConstPoint)

########NEW FILE########
__FILENAME__ = radiusshape
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.shapes import Rect

class RadiusShape(object):
	"""Class for generic shapes with a radius.
	The shape includes everything, that the center contains plus every point,
	for which this holds: distance(point, center) <= radius
	The center can by any other shape.
	If the center is a point, it's actually a circle.
	"""
	def __init__(self, center, radius):
		self.center = center
		self.radius = radius

class RadiusRect(RadiusShape):
	"""Specialization of RadiusShape with a Rect as center"""
	def __init__(self, center, radius):
		assert isinstance(center, Rect)
		super(RadiusRect, self).__init__(center, radius)

########NEW FILE########
__FILENAME__ = rect
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.python import Const
from horizons.util.python.decorators import bind_all
from horizons.util.shapes import Shape, Point

class Rect(Shape):
	__slots__ = ('top', 'left', 'right', 'bottom', 'origin')

	def __init__(self, *args):
		if len(args) == 2 and isinstance(args[0], Point) and isinstance(args[1], Point): #args: edge1, edge2
			self.top = min(args[0].y, args[1].y)
			self.left = min(args[0].x, args[1].x)
			self.right = max(args[0].x, args[1].x)
			self.bottom = max(args[0].y, args[1].y)
		elif len(args) == 3 and isinstance(args[0], Point) and isinstance(args[1], int) and isinstance(args[2], int): #args: position, width, height
			self.top = args[0].y
			self.left = args[0].x
			self.right = self.left + args[1]
			self.bottom = self.top + args[2]
		elif len(args) == 4 and isinstance(args[0], int) and isinstance(args[1], int) and isinstance(args[2], int) and isinstance(args[3], int):
			self.top = min(args[1], args[3])
			self.left = min(args[0], args[2])
			self.right = max(args[0], args[2])
			self.bottom = max(args[1], args[3])

		else:
			assert False

		# Convenience attributes (can be used to make code more easy to read/understand)
		self.origin = Point(self.left, self.top)

	# NAMED CONSTRUCTORS:

	@classmethod
	def init_from_borders(cls, left, top, right, bottom):
		self = cls.__new__(cls)
		self.left = left
		self.top = top
		self.right = right
		self.bottom = bottom
		self.origin = Point(self.left, self.top)
		return self

	@classmethod
	def init_from_topleft_and_size(cls, x, y, width, height):
		self = cls.__new__(cls)
		self.left = x
		self.top = y
		self.right = x + width - 1
		self.bottom = y + height - 1
		self.origin = Point(self.left, self.top)
		return self

	@classmethod
	def init_from_topleft_and_size_tuples(cls, coords, size):
		self = cls.__new__(cls)
		self.left = coords[0]
		self.top = coords[1]
		self.right = coords[0] + size[0] - 1
		self.bottom = coords[1] + size[1] - 1
		self.origin = Point(self.left, self.top)
		return self

	@classmethod
	def init_from_corners(cls, point1, point2):
		"""Init rect with 2 points interpreted as 2 corner points"""
		self = cls.__new__(cls)
		x_coords = [ int(round(point1.x)), int(round(point2.x)) ]
		x_coords.sort()
		self.left = x_coords[0]
		self.right = x_coords[1]
		y_coords = [ int(round(point1.y)), int(round(point2.y)) ]
		y_coords.sort()
		self.top = y_coords[0]
		self.bottom = y_coords[1]
		self.origin = Point(self.left, self.top)
		return self

	@property
	def height(self):
		return self.bottom - self.top + 1

	@property
	def width(self):
		return self.right - self.left + 1

	def copy(self):
		return Rect.init_from_borders(self.left, self.top, self.right, self.bottom)

	def get_radius_coordinates(self, radius, include_self=False):
		"""Returns list of all coordinates (as tuples), that are in the radius
		This is a generator.
		@param include_self: whether to include coords in self"""
		# NOTE: this function has to be very fast, since it's blocking on building select
		#       therefore, the distance_to_tuple function is inlined manually.
		"""
		ALGORITHM:
		Idea:
		calculate the borders of the shape for every line (y-axis) to the left and the right
		and fill it up later.
		The borders are calculated this way:
		Take a corner (here we use top right) and calculate a quarter of a circle (top right quarter).
		This can be mirrored to every other corner.
		Then there is only the space exactly above, below and left and right to the rect left.
		Here, since we only got along one axis, we know that the border coords are right + radius, etc.
		q.e.d. ;)
		"""
		borders = {}

		# start with special case

		# above, below
		borders[self.top - radius] = ( self.left, self.right )
		borders[self.bottom + radius] = ( self.left, self.right )

		# left, right
		for y in xrange( self.top, self.bottom+1 ):
			borders[y] = ( self.left - radius, self.right + radius)

		x = radius
		radius_squared = radius ** 2
		# calculate border for line y (y = 0 and y = radius are special cases handled above)
		for y in xrange( 1, radius ):
			test_val = radius_squared - y ** 2
			# TODO: check if it's possible if x is decreased more than once here.
			#       if not, change the while to an if
			while (x ** 2) > test_val: # this is equivalent to  x^2 + y^2 > radius^2
				x -= 1

			# both sides are symmetrical, since it's a rect
			borders[self.top - y] = (self.left - x, self.right + x)
			borders[self.bottom + y] = (self.left - x, self.right + x)

		if not include_self:
			self_coords = frozenset(self.get_coordinates())
			for y, x_range in borders.iteritems():
				if self.top <= y <= self.bottom: # we have to sort out the self_coords here
					for x in xrange(x_range[0], x_range[1]+1):
						t = (x, y)
						if t not in self_coords:
							yield t
				else: # coords of this rect cannot appear here
					for x in xrange(x_range[0], x_range[1]+1):
						yield (x, y)
		else:
			for y, x_range in borders.iteritems():
				for x in xrange(x_range[0], x_range[1]+1):
					yield (x, y)


	@property
	def center(self):
		"""Returns the center point of the rect.
		Implemented with integer division, which means the upper left is preferred."""
		return Point((self.right + self.left) // 2, (self.bottom + self.top) // 2)

	def __contains__(self, point):
		return self.contains(point)

	def contains(self, point):
		""" Returns if this rect (self) contains the point.
		@param point: Point that is checked to be in this rect
		@return: Returns whether the Point point is in this rect (self).
		"""
		return (self.left <= point.x <= self.right) and (self.top <= point.y <= self.bottom)

	def contains_without_border(self, point):
		"""Same as contains, see iter_without_border for difference"""
		return (self.left <= point.x < self.right) and (self.top <= point.y < self.bottom)

	def contains_tuple(self, tup):
		"""Same as contains, but takes a tuple (x, y) as parameter (overloaded function)"""
		return (self.left <= tup[0] <= self.right) and (self.top <= tup[1] <= self.bottom)

	def intersect(self, rect):
		""" Returns a rect that is the intersection of this rect and the rect parameter.
		@param rect: Rect that will be intersected with this rect.
		@return: A Rect which is the intersection of self and rect or None if the intersection is empty.
		"""
		if not self.intersects(rect):
			return None
		return Rect(max(self.left, rect.left), max(self.top, rect.top),
		            min(self.right, rect.right), min(self.bottom, rect.bottom))

	def intersects(self, rect):
		""" Returns if the rectangle intersects with the rect parameter.
		@param rect: Rect that will be intersected with this rect.
		@return: A bool.
		"""
		return not (rect.right < self.left or self.right < rect.left
		            or rect.bottom < self.top or self.bottom < rect.top)

	def get_corners(self):
		"""Returns corners of rect in this order: topleft topright bottomright bottomleft
		@return: tuple of coord-tuples"""
		return ( (self.left, self.top), (self.right, self.top),
		         (self.right, self.bottom), (self.left, self.bottom) )

	def get_surrounding(self, include_corners=True):
		"""Returns neighboring coords of the rect.
		@param include_corners: whether to also move diagonally from the rect corners"""
		# top and bottom
		surrounding_top = self.top - 1
		surrounding_bottom = self.bottom + 1
		for x in xrange(self.left, self.right + 1):
			yield (x, surrounding_bottom)
			yield (x, surrounding_top)
		# left and right
		surrounding_left = self.left - 1
		surrounding_right = self.right + 1
		for y in xrange(self.top, self.bottom + 1):
			yield (surrounding_left, y)
			yield (surrounding_right, y)

		if include_corners:
			yield (self.left - 1, self.top - 1)
			yield (self.right + 1, self.top - 1)
			yield (self.left - 1, self.bottom + 1)
			yield (self.right + 1, self.bottom + 1)

	def __str__(self):
		return "Rect(o:(%s,%s),w:%s,h:%s)" % (self.left, self.top, self.width, self.height)

	def __eq__(self, other):
		if not isinstance(other, Rect):
			return False
		return (self.top == other.top and self.left == other.left
		        and self.right == other.right and self.bottom == other.bottom)

	def __ne__(self, other):
		return not self.__eq__(other)

	def __lt__(self, other):
		if self.left != other.left:
			return self.left < other.left
		if self.top != other.top:
			return self.top < other.top
		if self.right != other.right:
			return self.right < other.right
		return self.bottom < other.bottom

	def __hash__(self):
		return hash((self.top, self.right, self.bottom, self.left))

	def tuple_iter(self):
		"""Generates an iterator, that returns tuples"""
		for x in xrange(self.left, self.right+1):
			for y in xrange(self.top, self.bottom+1):
				yield x, y

	def iter_without_border(self):
		"""There are 2 possible interpretations about what *width* means.
		You can either include the last point in the area calculation or
		just consider points without any extensions.
		This method iterates over the points without extensions, while the
		default iteration behavior in other methods is to include said area.
		"""
		for x in xrange(self.left, self.right):
			for y in xrange(self.top, self.bottom):
				yield Point(x, y)

	@classmethod
	def get_surrounding_offsets(cls, size):
		rect = cls.init_from_topleft_and_size_tuples((0, 0), size)
		return list(rect.get_surrounding())

class ConstRect(Const, Rect):
	"""An immutable Rect.
	Can be used for manual const-only optimization"""
	pass


bind_all(Rect)
bind_all(Const)

########NEW FILE########
__FILENAME__ = startgameoptions
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from operator import itemgetter

from horizons.constants import AI, COLORS
from horizons.util.color import Color
from horizons.util.difficultysettings import DifficultySettings

class StartGameOptions(object):
	def __init__(self, game_identifier):
		super(StartGameOptions, self).__init__()
		self.game_identifier = game_identifier
		self._player_list = None

		self.trader_enabled = True
		self.pirate_enabled = True
		self.natural_resource_multiplier = 1
		self.disasters_enabled = True
		self.force_player_id = None
		self.is_map = False
		self.is_multiplayer = False
		self.is_scenario = False

		self.player_name = 'Player'
		self.player_color = None
		self.ai_players = 0
		self.human_ai = AI.HUMAN_AI

		# this is used by the map editor to pass along the new map's size
		self.map_padding = None
		self.is_editor = False

	def init_new_world(self, session):
		# NOTE: this must be sorted before iteration, cause there is no defined order for
		#       iterating a dict, and it must happen in the same order for mp games.
		for i in sorted(self._get_player_list(), key=itemgetter('id')):
			session.world.setup_player(i['id'], i['name'], i['color'], i['clientid'] if self.is_multiplayer else None, i['local'], i['ai'], i['difficulty'])
		session.world.set_forced_player(self.force_player_id)
		center = session.world.init_new_world(self.trader_enabled, self.pirate_enabled, self.natural_resource_multiplier)
		session.view.center(center[0], center[1])

	def set_human_data(self, player_name, player_color):
		self.player_name = player_name
		self.player_color = player_color

	def _get_player_list(self):
		if self._player_list is not None:
			return self._player_list

		# for now just make it a bit easier for the AI
		difficulty_level = {False: DifficultySettings.DEFAULT_LEVEL, True: DifficultySettings.EASY_LEVEL}

		players = []
		players.append({
			'id': 1,
			'name': self.player_name,
			'color': Color[1] if self.player_color is None else self.player_color,
			'local': True,
			'ai': self.human_ai,
			'difficulty': difficulty_level[bool(self.human_ai)],
		})

		# add AI players with a distinct color; if none can be found then use black
		for num in xrange(self.ai_players):
			color = Color[COLORS.BLACK] # if none can be found then be black
			for possible_color in Color:
				if possible_color == Color[COLORS.BLACK]:
					continue # black is used by the trader and the pirate
				used = any(possible_color == player['color'] for player in players)
				if not used:
					color = possible_color
					break

			players.append({
				'id' : num + 2,
				'name' : 'AI' + str(num + 1),
				'color' : color,
				'local' : False,
				'ai' : True,
				'difficulty' : difficulty_level[True],
			})
		return players

	@classmethod
	def create_start_multiplayer(cls, game_file, player_list, is_map):
		options = StartGameOptions(game_file)
		options._player_list = player_list
		options.is_map = is_map
		options.is_multiplayer = True
		return options

	@classmethod
	def create_start_singleplayer(cls, game_identifier, is_scenario, ai_players,
		                          trader_enabled, pirate_enabled, force_player_id, is_map):
		options = StartGameOptions(game_identifier)
		options.is_scenario = is_scenario
		options.ai_players = ai_players
		options.trader_enabled = trader_enabled
		options.pirate_enabled = pirate_enabled
		options.force_player_id = force_player_id
		options.is_map = is_map
		return options

	@classmethod
	def create_start_random_map(cls, ai_players, seed, force_player_id):
		from horizons.util.random_map import generate_map_from_seed
		options = StartGameOptions(generate_map_from_seed(seed))
		options.ai_players = ai_players
		options.force_player_id = force_player_id
		options.is_map = True
		return options

	@classmethod
	def create_editor_load(cls, map_name):
		options = StartGameOptions(map_name)
		options.player_name = 'Editor'
		options.trader_enabled = False
		options.pirate_enabled = False
		options.natural_resource_multiplier = 0
		options.disasters_enabled = False
		options.is_map = True
		options.is_editor = True
		return options

	@classmethod
	def create_start_scenario(cls, scenario_file):
		options = StartGameOptions(scenario_file)
		options.is_scenario = True
		return options

	@classmethod
	def create_start_map(cls, map_name):
		options = StartGameOptions(map_name)
		options.is_map = True
		return options

	@classmethod
	def create_load_game(cls, saved_game, force_player_id):
		options = StartGameOptions(saved_game)
		options.force_player_id = force_player_id
		return options

	@classmethod
	def create_game_test(cls, game_identifier, player_list):
		options = StartGameOptions(game_identifier)
		options._player_list = player_list
		options.trader_enabled = False
		options.pirate_enabled = False
		options.natural_resource_multiplier = 0
		return options

	@classmethod
	def create_ai_test(cls, game_identifier, player_list):
		options = StartGameOptions(game_identifier)
		options._player_list = player_list
		options.is_map = True
		return options

########NEW FILE########
__FILENAME__ = uhdbaccessor
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import random

from horizons.constants import PATHS, TIER
from horizons.util.python import decorators
from horizons.util.dbreader import DbReader
from horizons.entities import Entities

########################################################################
class UhDbAccessor(DbReader):
	"""UhDbAccessor is the class that contains the sql code. It is meant
	to keep all the sql code in a central place, to make it reusable and
	maintainable.

	It should be used as a utility to remove data access code from places where
	it doesn't belong, such as game logic.

	Due to historic reasons, sql code is spread over the game code; for now, it is left at
	places, that are data access routines (e.g. unit/building class)."""

	def __init__(self, dbfile):
		super(UhDbAccessor, self).__init__(dbfile=dbfile)


	# ------------------------------------------------------------------
	# Db Access Functions start here
	# ------------------------------------------------------------------

	# Resource table

	def get_res_name(self, id):
		"""Returns the translated name for a specific resource id.
		@param id: int resource's id, of which the name is returned """
		name = self.cached_query("SELECT name FROM resource WHERE id = ?", id)[0][0]
		return _(name)

	def get_res_inventory_display(self, id):
		sql = "SELECT shown_in_inventory FROM resource WHERE id = ?"
		return self.cached_query(sql, id)[0][0]

	def get_res_value(self, id):
		"""Returns the resource's value
		@param id: resource id
		@return: float value"""
		return self.cached_query("SELECT value FROM resource WHERE id = ?", id)[0][0]

	def get_res(self, only_tradeable=False, only_inventory=False):
		"""Returns a list of all resources.
		@param only_tradeable: return only those you can trade.
		@param only_inventory: return only those displayed in inventories.
		@return: list of resource ids"""
		sql = "SELECT id FROM resource WHERE id"
		if only_tradeable:
			sql += " AND tradeable = 1"
		if only_inventory:
			sql += " AND shown_in_inventory = 1"
		db_data = self.cached_query(sql)
		return map(lambda x: x[0], db_data)

	# Sound table

	def get_sound_file(self, soundname):
		"""
		Returns the soundfile to the related sound name.
		@param sound: string, key in table sounds_special
		"""
		sql = 'SELECT file FROM sounds \
		       INNER JOIN sounds_special ON sounds.id = sounds_special.sound AND \
		       sounds_special.type = ?'
		return self.cached_query(sql, soundname)[0][0]

	# Building table

	@decorators.cachedmethod
	def get_related_building_ids(self, building_class_id):
		"""Returns list of building ids related to building_class_id.
		@param building_class_id: class of building, int
		@return list of building class ids
		"""
		sql = "SELECT related_building FROM related_buildings WHERE building = ?"
		return map(lambda x: x[0], self.cached_query(sql, building_class_id))

	@decorators.cachedmethod
	def get_related_building_ids_for_menu(self, building_class_id):
		"""Returns list of building ids related to building_class_id, which should
		be shown in the build_related menu.
		@param building_class_id: class of building, int
		@return list of building class ids
		"""
		sql = "SELECT related_building FROM related_buildings WHERE building = ? and show_in_menu = 1"
		return map(lambda x: x[0], self.cached_query(sql, building_class_id))

	@decorators.cachedmethod
	def get_inverse_related_building_ids(self, building_class_id):
		"""Inverse of the above, gives the lumberjack to the tree.
		@param building_class_id: class of building, int
		@return list of building class ids
		"""
		sql = "SELECT building FROM related_buildings WHERE related_building = ?"
		return map(lambda x: x[0], self.cached_query(sql, building_class_id))

	@decorators.cachedmethod
	def get_buildings_with_related_buildings(self):
		"""Returns all buildings that have related buildings"""
		sql = "SELECT DISTINCT building FROM related_buildings"
		return map(lambda x: x[0], self.cached_query(sql))

	# Messages

	def get_msg_visibility(self, msg_id_string):
		"""
		@param msg_id_string: string id of the message
		@return: int: for how long in seconds the message will stay visible
		"""
		sql = "SELECT visible_for FROM message WHERE id_string = ?"
		return self.cached_query(sql, msg_id_string)[0][0]

	def get_msg_text(self, msg_id_string):
		"""
		@param msg_id_string: string id of the message
		"""
		sql = "SELECT text FROM message_text WHERE id_string = ?"
		return self.cached_query(sql, msg_id_string)[0][0]

	def get_msg_icon_id(self, msg_id_string):
		"""
		@param msg_id_string: string id of the message
		@return: int: id
		"""
		sql = "SELECT icon FROM message where id_string = ?"
		return self.cached_query(sql, msg_id_string)[0][0]

	def get_msg_icon_path(self, msg_id_string):
		"""
		@param msg_id_string: string id of the message
		@return: str: path attribute to message icon suitable for ImageButton
		"""
		sql = "SELECT path FROM message_icon WHERE icon_id = ?"
		return self.cached_query(sql, msg_id_string)[0][0]

	#
	#
	# Inhabitants
	#
	#

	def get_settler_name(self, level):
		"""Returns the name of inhabitants for a specific tier.
		@param level: int - which tier
		@return: string - inhabitant name"""
		sql = "SELECT name FROM tier WHERE level = ?"
		return self.cached_query(sql, level)[0][0]

	def get_settler_house_name(self, level):
		"""Returns name of the residential building for a specific tier
		@param level: int - which tier
		@return: string - housing name"""
		sql = "SELECT residential_name FROM tier WHERE level = ?"
		return self.cached_query(sql, level)[0][0]

	def get_settler_tax_income(self, level):
		sql = "SELECT tax_income FROM tier WHERE level = ?"
		return self.cached_query(sql, level)[0][0]

	def get_tier_inhabitants_max(self, level):
		"""Returns the upper limit of inhabitants per house for a specific tier.
		Inhabitants will try to increase their tier upon exceeding this value.
		@param level: int - which tier
		"""
		sql = "SELECT inhabitants_max FROM tier WHERE level = ?"
		return self.cached_query(sql, level)[0][0]

	def get_tier_inhabitants_min(self, level):
		"""Returns the lower limit of inhabitants per house for a specific tier.
		This limit coincides with the max. amount of the previous tier.
		Inhabitants will decrease their tier after falling below.
		@param level: int - which tier
		"""
		if level == TIER.LOWEST:
			return 0
		else:
			sql = "SELECT inhabitants_max FROM tier WHERE level = ?"
			return self.cached_query(sql, level - 1)[0][0]

	def get_upper_happiness_limit(self):
		sql = "SELECT value FROM balance_values WHERE name='happiness_inhabitants_increase_requirement'"
		return self.cached_query(sql)[0][0]

	def get_lower_happiness_limit(self):
		sql = "SELECT value FROM balance_values WHERE name='happiness_inhabitants_decrease_limit'"
		return self.cached_query(sql)[0][0]

	# Misc

	def get_player_start_res(self):
		"""Returns resources, that players should get at startup as dict: { res : amount }"""
		start_res = self.cached_query("SELECT resource, amount FROM player_start_res")
		return dict(start_res)

	@decorators.cachedmethod
	def get_storage_building_capacity(self, storage_type):
		"""Returns the amount that a storage building can store of every resource.
		@param storage_type: building class id"""
		sql = "SELECT size FROM storage_building_capacity WHERE type = ?"
		return self.cached_query(sql, storage_type)[0][0]

	# Tile sets

	def get_random_tile_set(self, ground_id):
		"""Returns a tile set for a tile of type ground_id"""
		sql = "SELECT set_id FROM tile_set WHERE ground_id = ?"
		db_data = self.cached_query(sql, ground_id)
		return random.choice(db_data)[0] if db_data else None

	@decorators.cachedmethod
	def get_translucent_buildings(self):
		"""Returns building types that should become translucent on demand"""
		# use set because of quick contains check
		return frozenset( id for (id, b) in Entities.buildings.iteritems() if b.translucent )

	# Weapon table

	def get_weapon_stackable(self, weapon_id):
		"""Returns True if the weapon is stackable, False otherwise."""
		return self.cached_query("SELECT stackable FROM weapon WHERE id = ?", weapon_id)[0][0]

	def get_weapon_attack_radius(self, weapon_id):
		"""Returns weapon's attack radius modifier."""
		return self.cached_query("SELECT attack_radius FROM weapon WHERE id = ?", weapon_id)[0][0]


	# Units

	def get_unit_type_name(self, type_id):
		"""Returns the name of a unit type identified by its type"""
		return Entities.units[type_id].name

	def get_ship_tooltip(self, ship_id):
		"""Tries to identify ship properties to display as tooltip.
		#TODO Should be extended later to also include movement speed, etc."""
		helptexts = [] # collects all information we will find
		ship = Entities.units[ship_id]
		try:
			comp = ship.get_component_template('StorageComponent')
			storage = comp['PositiveTotalNumSlotsStorage']
			# Ship storage properties
			helptext = _('{slotnum} slots, {limit}t')
			helptext = helptext.format(slotnum=storage['slotnum'],
			                           limit=storage['limit'])
			helptexts.append(helptext)
		except KeyError: # Component not found, ignore this part
			pass
		try:
			comp = ship.get_component_template('HealthComponent')
			helptext = _('Health: {health}')
			helptext = helptext.format(health=comp['maxhealth'])
			helptexts.append(helptext)
		except KeyError: # Component not found, ignore this part
			pass
		return u'\\n'.join(helptexts)


def read_savegame_template(db):
	savegame_template = open(PATHS.SAVEGAME_TEMPLATE, "r")
	db.execute_script(savegame_template.read())

########NEW FILE########
__FILENAME__ = worldobject
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import weakref
import logging

from horizons.util.changelistener import ChangeListener
from horizons.messaging import WorldObjectDeleted

class WorldObjectNotFound(KeyError):
	pass

class WorldObject(ChangeListener):
	"""Gives every instance a unique id.
	"""
	__next_id = 1
	__objects = weakref.WeakValueDictionary()
	log = logging.getLogger("util.worldobject")
	def __init__(self, worldid=None, **kwargs):
		"""
		@param worldid: worldid to assign. Use None to get an autogenerated one.
		"""
		super(WorldObject, self).__init__(**kwargs)
		self.__init(worldid)

	def __init(self, worldid=None):
		self.worldid = worldid if worldid is not None else WorldObject.__next_id
		assert self.worldid not in WorldObject.__objects, "WorldObject ID(" + str(worldid) + ") already in use by " + str(self.get_object_by_id(worldid))
		WorldObject.__objects[self.worldid] = self
		# Make sure that new WorldIDs are always higher than every other WorldObject
		WorldObject.__next_id = max(WorldObject.__next_id, self.worldid+1)

	@classmethod
	def get_object_by_id(cls, id):
		"""Returns the worldobject with id id
		Throws WorldObjectNotFound with the worldid as arg.
		"""
		try:
			return cls.__objects[id]
		except KeyError as e:
			raise WorldObjectNotFound(e.args[0])

	@classmethod
	def reset(cls):
		cls.__next_id = 1
		cls.__objects.clear()

	def save(self, db):
		pass

	def load(self, db, worldid):
		super(WorldObject, self).load(db, worldid)
		self.__init(worldid)
		self.log.debug('Loading worldobject %s %s', worldid, self)

	def remove(self):
		WorldObjectDeleted.broadcast(self, self, self.worldid)
		super(WorldObject, self).remove()
		self.log.debug("Removing WorldObject %s %s", self.worldid, self)
		del WorldObject.__objects[self.worldid]

	def __lt__(self, other):
		return self.worldid < other.worldid

	# for testing:
	@classmethod
	def get_objs(self): return self.__objects

########NEW FILE########
__FILENAME__ = yamlcache
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os
import yaml
import threading
import logging

from horizons.constants import TIER, RES, UNITS, BUILDINGS, PATHS
from horizons.util.yamlcachestorage import YamlCacheStorage

try:
	from yaml import CSafeLoader as SafeLoader
except ImportError:
	from yaml import SafeLoader

# make SafeLoader allow unicode
def construct_yaml_str(self, node):
	return self.construct_scalar(node)
SafeLoader.add_constructor(u'tag:yaml.org,2002:python/unicode', construct_yaml_str)
SafeLoader.add_constructor(u'tag:yaml.org,2002:str', construct_yaml_str)


def parse_token(token, token_klass):
	"""Helper function that tries to parse a constant name.
	Does not do error detection, but passes unparseable stuff through.
	Allowed values: integer or token_klass.LIKE_IN_CONSTANTS
	@param token_klass: "TIER", "RES", "UNITS" or "BUILDINGS"
	"""
	classes = {'TIER': TIER, 'RES': RES, 'UNITS': UNITS, 'BUILDINGS': BUILDINGS}

	if not isinstance(token, basestring):
		# Probably numeric already
		return token
	if not token.startswith(token_klass):
		# No need to parse anything
		return token
	try:
		return getattr( classes[token_klass], token.split(".", 2)[1])
	except AttributeError as e: # token not defined here
		err = ("This means that you either have to add an entry in horizons/constants.py "
		       "in the class %s for %s,\nor %s is actually a typo."
		       % (token_klass, token, token))
		raise Exception( str(e) + "\n\n" + err +"\n" )


def convert_game_data(data):
	"""Translates convenience symbols into actual game data usable by machines"""
	if isinstance(data, dict):
		return dict( [ convert_game_data(i) for i in data.iteritems() ] )
	elif isinstance(data, (tuple, list)):
		return type(data)( ( convert_game_data(i) for i in data) )
	else: # leaf
		data = parse_token(data, "TIER")
		data = parse_token(data, "RES")
		data = parse_token(data, "UNITS")
		data = parse_token(data, "BUILDINGS")
		return data


class YamlCache(object):
	"""Loads and caches YAML files in a persistent cache.
	Threadsafe.

	Use get_file for files to cache (default case) or load_yaml_data for special use cases (behaves like yaml.load).
	"""

	cache = None
	cache_filename = os.path.join(PATHS.USER_DIR, 'yamldata.cache')

	sync_scheduled = False

	lock = threading.Lock()

	log = logging.getLogger("yamlcache")

	@classmethod
	def load_yaml_data(self, string_or_stream):
		"""Use this instead of yaml.load everywhere in uh in case get_file isn't useable"""
		return yaml.load( string_or_stream, Loader=SafeLoader )

	@classmethod
	def get_file(cls, filename, game_data=False):
		"""Get contents of a yaml file
		@param filename: path to the file
		@param game_data: Whether this file contains data like BUILDINGS.LUMBERJACK to resolve
		"""

		# calc the hash
		f = open(filename, 'r')
		h = hash(f.read())
		f.seek(0)

		# check for updates or new files
		if cls.cache is None:
			cls._open_cache()

		yaml_file_in_cache = (filename in cls.cache and cls.cache[filename][0] == h)
		if not yaml_file_in_cache:
			data = cls.load_yaml_data( f )
			if game_data: # need to convert some values
				try:
					data = convert_game_data(data)
				except Exception as e:
					# add info about file
					to_add = "\nThis error happened in %s ." % filename
					e.args = ( e.args[0] + to_add, ) + e.args[1:]
					e.message = ( e.message + to_add )
					raise

			cls.lock.acquire()
			cls.cache[filename] = (h, data)
			if not cls.sync_scheduled:
				cls.sync_scheduled = True
				from horizons.extscheduler import ExtScheduler
				ExtScheduler().add_new_object(cls._do_sync, cls, run_in=1)
			cls.lock.release()

		return cls.cache[filename][1] # returns an object from the YAML

	@classmethod
	def _open_cache(cls):
		cls.lock.acquire()
		cls.cache = YamlCacheStorage.open(cls.cache_filename)
		cls.lock.release()

	@classmethod
	def _do_sync(cls):
		"""Only write to disc once in a while, it's too slow when done every time"""
		cls.lock.acquire()
		cls.sync_scheduled = False
		cls.cache.sync()
		cls.lock.release()

########NEW FILE########
__FILENAME__ = yamlcachestorage
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import os.path

try:
	import cPickle as pickle
except:
	import pickle

class YamlCacheStorage(object):
	"""
	Store the YamlCache data in a cache.

	An instance of this class provides a implements a cache that always has all the data
	in memory. It tries to also load the data from disk and write it back on disk but
	if it fails then it just ignores the errors and keeps working.
	"""

	log = logging.getLogger("yamlcachestorage")

	# Increment this when the users of this class change the way they use it.
	version = 1

	def __init__(self, filename):
		super(YamlCacheStorage, self).__init__()
		self._filename = filename
		self._data = {}

	@classmethod
	def _validate(cls, data):
		"""Make sure data is a tuple (version no, _data dict) with the right version."""
		if not isinstance(data, tuple):
			return False
		if len(data) != 2:
			return False
		if not isinstance(data[1], dict):
			return False
		return data[0] == cls.version

	def _reload(self):
		"""Load the cache from disk if possible. Create an empty cache otherwise."""
		if os.path.exists(self._filename):
			self.log.debug('%s._reload(): loading cache from disk', self)
			file = open(self._filename)
			try:
				data = pickle.load(file)
				if not self._validate(data):
					raise RuntimeError('Bad YamlCacheStorage data format')
				self._data = data[1]
			finally:
				file.close()
			self.log.debug('%s._reload(): successfully loaded cache from disk', self)
		else:
			self._clear()

	def _clear(self):
		"""Clear the cache in memory."""
		self.log.debug('%s._clear(): creating a new cache', self)
		self._data = {}

	@classmethod
	def open(cls, filename):
		"""Open the cache specified by the file name or create an empty one otherwise."""
		cls.log.debug("YamlCacheStorage.open('%s')", filename)
		obj = YamlCacheStorage(filename)
		try:
			obj._reload()
		except Exception as e:
			# Ignore all exceptions because loading the cache from disk is not critical.
			e = unicode(str(e), errors='replace')
			cls.log.warning("Warning: Failed to open %s as cache: %s\nThis warning is expected when upgrading from old versions.\n" % (filename, e))
			obj._clear()
		return obj

	def sync(self):
		"""Write the file to disk if possible. Do nothing otherwise."""
		try:
			file = open(self._filename, 'wb')
			try:
				pickle.dump((self.version, self._data), file)
				self.log.debug('%s.sync(): success', self)
			finally:
				file.close()
		except Exception as e:
			# Ignore all exceptions because saving the cache on disk is not critical.
			self.log.warning("Warning: Unable to save cache into %s: %s" % (self._filename, unicode(e)))

	def close(self):
		"""Write the file to disk if possible and then invalidate the object in memory."""
		self.log.debug('%s.close()', self)
		self.sync()
		self._filename = None
		self._data = None

	def __getitem__(self, key):
		"""This function enables the following syntax: cache[key]"""
		self.log.debug("%s.__getitem__('%s')", self, key)
		return self._data[key]

	def __setitem__(self, key, value):
		"""This function enables the following syntax: cache[key] = value"""
		self.log.debug("%s.__setitem__('%s', data excluded)", self, key)
		self._data[key] = value

	def __contains__(self, item):
		"""This function enables the following syntax: item in cache"""
		self.log.debug("%s.__contains__('%s')", self, item)
		return item in self._data

	def __str__(self):
		return "YamlCacheStorage('%s', %d items)" % (self._filename, len(self._data))

########NEW FILE########
__FILENAME__ = view
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import math
import time
from fife import fife

import horizons.globals

from horizons.messaging import ZoomChanged
from horizons.util.changelistener import ChangeListener
from horizons.util.shapes import Rect
from horizons.constants import LAYERS, VIEW, GAME_SPEED

class View(ChangeListener):
	"""Class that takes care of all the camera and rendering stuff."""

	def __init__(self):
		super(View, self).__init__()
		self.world = None
		self.model = horizons.globals.fife.engine.getModel()
		self.map = self.model.createMap("map")

		cellgrid = self.model.getCellGrid('square')
		cellgrid.thisown = 0
		cellgrid.setRotation(0)
		cellgrid.setXScale(1)
		cellgrid.setYScale(1)
		cellgrid.setXShift(0)
		cellgrid.setYShift(0)

		using_opengl = horizons.globals.fife.engine.getRenderBackend().getName() == "OpenGL"

		self.layers = []
		for layer_id in xrange(LAYERS.NUM):
			layer = self.map.createLayer(str(layer_id), cellgrid)
			if layer_id == LAYERS.OBJECTS:
				layer.setPathingStrategy(fife.CELL_EDGES_AND_DIAGONALS)
				layer.setWalkable(True)
			elif using_opengl and layer_id == LAYERS.WATER:
				layer.setStatic(True)
			self.layers.append(layer)

		self.map.initializeCellCaches()
		self.map.finalizeCellCaches()

		# Make sure layer can't change size on layer.createInstance
		# This is necessary because otherwise ship movement on the map edges would
		# keep changing the units' layer size.
		for layer in self.layers:
			if layer.getCellCache():
				layer.getCellCache().setStaticSize(True)

		rect = fife.Rect(0, 0, horizons.globals.fife.engine_settings.getScreenWidth(),
		                       horizons.globals.fife.engine_settings.getScreenHeight())
		self.cam = self.map.addCamera("main", self.layers[-1], rect)
		self.cam.setCellImageDimensions(*VIEW.CELL_IMAGE_DIMENSIONS)
		self.cam.setRotation(VIEW.ROTATION)
		self.cam.setTilt(VIEW.TILT)
		self.cam.setZoom(VIEW.ZOOM_DEFAULT)

		self.cam.resetRenderers()
		self.renderer = {}
		for r in ('InstanceRenderer', 'GridRenderer',
		          'CellSelectionRenderer', 'BlockingInfoRenderer', 'FloatingTextRenderer',
		          'QuadTreeRenderer', 'CoordinateRenderer', 'GenericRenderer'):
			self.renderer[r] = getattr(fife, r).getInstance(self.cam) if hasattr(fife, r) else self.cam.getRenderer(r)
			self.renderer[r].clearActiveLayers()
			self.renderer[r].setEnabled(r in ('InstanceRenderer', 'GenericRenderer'))
		self.renderer['InstanceRenderer'].activateAllLayers(self.map)
		self.renderer['GenericRenderer'].addActiveLayer(self.layers[LAYERS.OBJECTS])
		self.renderer['GridRenderer'].addActiveLayer(self.layers[LAYERS.GROUND])

		#Setup autoscroll
		horizons.globals.fife.pump.append(self.do_autoscroll)
		self.time_last_autoscroll = time.time()
		self._autoscroll = [0, 0]
		self._autoscroll_keys = [0, 0]

	def end(self):
		horizons.globals.fife.pump.remove(self.do_autoscroll)
		self.model.deleteMaps()
		super(View, self).end()

	def center(self, x, y):
		"""Sets the camera position
		@param center: tuple with x and y coordinate (float or int) of tile to center
		"""
		loc = self.cam.getLocationRef()
		pos = loc.getExactLayerCoordinatesRef()
		pos.x = x
		pos.y = y
		self.cam.refresh()
		self._changed()

	def autoscroll(self, x, y):
		"""Scrolling via mouse (reaching edge of screen)"""
		if horizons.globals.fife.get_uh_setting('EdgeScrolling'):
			self._autoscroll = [x, y]

	def autoscroll_keys(self, x, y):
		"""Scrolling via keyboard keys"""
		self._autoscroll_keys = [x, y]

	def do_autoscroll(self):
		if self._autoscroll == [0, 0] and self._autoscroll_keys == [0, 0]:
			self.time_last_autoscroll = time.time()
			return
		t = time.time()
		speed_factor = GAME_SPEED.TICKS_PER_SECOND * (t - self.time_last_autoscroll)
		self.scroll(speed_factor * (self._autoscroll[0] + self._autoscroll_keys[0]),
		            speed_factor * (self._autoscroll[1] + self._autoscroll_keys[1]))
		self.time_last_autoscroll = t
		self._changed()

	def scroll(self, x, y):
		"""Moves the camera across the screen
		@param x: int representing the amount of pixels to scroll in x direction
		@param y: int representing the amount of pixels to scroll in y direction
		"""
		loc = self.cam.getLocation()
		pos = loc.getExactLayerCoordinatesRef()
		cell_dim = self.cam.getCellImageDimensions()

		if x != 0:
			new_angle = math.pi * self.cam.getRotation() / 180.0
			zoom_factor = self.cam.getZoom() * cell_dim.x * horizons.globals.fife.get_uh_setting('ScrollSpeed')
			pos.x += x * math.cos(new_angle) / zoom_factor
			pos.y += x * math.sin(new_angle) / zoom_factor
		if y != 0:
			new_angle = math.pi * self.cam.getRotation() / -180.0
			zoom_factor = self.cam.getZoom() * cell_dim.y * horizons.globals.fife.get_uh_setting('ScrollSpeed')
			pos.x += y * math.sin(new_angle) / zoom_factor
			pos.y += y * math.cos(new_angle) / zoom_factor

		if pos.x > self.world.max_x:
			pos.x = self.world.max_x
		elif pos.x < self.world.min_x:
			pos.x = self.world.min_x

		if pos.y > self.world.max_y:
			pos.y = self.world.max_y
		elif pos.y < self.world.min_y:
			pos.y = self.world.min_y

		self.cam.setLocation(loc)
		for i in ['speech', 'effects']:
			emitter = horizons.globals.fife.sound.emitter[i]
			if emitter is not None:
				emitter.setPosition(pos.x, pos.y, 1)
		if horizons.globals.fife.get_fife_setting("PlaySounds"):
			horizons.globals.fife.sound.soundmanager.setListenerPosition(pos.x, pos.y, 1)
		self._changed()

	def _prepare_zoom_to_cursor(self, zoom):
		"""Change the camera's position to accommodation zooming to the specified setting."""
		def middle(click_coord, scale, length):
			mid = length / 2.0
			return int(round(mid - (click_coord - mid) * (scale - 1)))

		scale = self.cam.getZoom() / zoom
		x, y = horizons.globals.fife.cursor.getPosition()
		new_x = middle(x, scale, horizons.globals.fife.engine_settings.getScreenWidth())
		new_y = middle(y, scale, horizons.globals.fife.engine_settings.getScreenHeight())
		screen_point = fife.ScreenPoint(new_x, new_y)
		map_point = self.cam.toMapCoordinates(screen_point, False)
		self.center(map_point.x, map_point.y)

	def zoom_out(self, track_cursor=False):
		zoom = self.cam.getZoom() * VIEW.ZOOM_LEVELS_FACTOR
		if zoom < VIEW.ZOOM_MIN:
			zoom = VIEW.ZOOM_MIN
		if track_cursor:
			self._prepare_zoom_to_cursor(zoom)
		self.zoom = zoom

	def zoom_in(self, track_cursor=False):
		zoom = self.cam.getZoom() / VIEW.ZOOM_LEVELS_FACTOR
		if zoom > VIEW.ZOOM_MAX:
			zoom = VIEW.ZOOM_MAX
		if track_cursor:
			self._prepare_zoom_to_cursor(zoom)
		self.zoom = zoom

	@property
	def zoom(self):
		return self.cam.getZoom()

	@zoom.setter
	def zoom(self, value):
		self.cam.setZoom(value)
		ZoomChanged.broadcast(self, value)

	def rotate_right(self):
		self.cam.setRotation((self.cam.getRotation() - 90) % 360)

	def rotate_left(self):
		self.cam.setRotation((self.cam.getRotation() + 90) % 360)

	def set_rotation(self, rotation):
		self.cam.setRotation(rotation)
		self._changed()

	def get_displayed_area(self):
		"""Returns the coords of what is displayed on the screen as Rect"""
		coords = self.cam.getLocationRef().getLayerCoordinates()
		cell_dim = self.cam.getCellImageDimensions()
		width_x = horizons.globals.fife.engine_settings.getScreenWidth() // cell_dim.x + 1
		width_y = horizons.globals.fife.engine_settings.getScreenHeight() // cell_dim.y + 1
		screen_width_as_coords = (width_x // self.zoom, width_y // self.zoom)
		return Rect.init_from_topleft_and_size(coords.x - (screen_width_as_coords[0] // 2),
		                                       coords.y - (screen_width_as_coords[1] // 2),
		                                       *screen_width_as_coords)

	def save(self, db):
		loc = self.cam.getLocation().getExactLayerCoordinates()
		db("INSERT INTO view(zoom, rotation, location_x, location_y) VALUES(?, ?, ?, ?)",
			 self.cam.getZoom(), self.cam.getRotation(), loc.x, loc.y)

	def load(self, db, world):
		# NOTE: this is no class function, since view is initiated before loading
		self.world = world
		res = db("SELECT zoom, rotation, location_x, location_y FROM view")
		if not res:
			# no view info
			return
		zoom, rotation, loc_x, loc_y = res[0]
		self.zoom = zoom
		self.set_rotation(rotation)
		self.center(loc_x, loc_y)

	def resize_layers(self, db):
		"""Resize layers to the size required by the entire map."""
		min_x, min_y, max_x, max_y = db("SELECT min(x), min(y), max(x), max(y) FROM ground")[0]
		if min_x is None:
			# this happens on the empty maps that are created for the editor
			min_x, min_y, max_x, max_y = (0, 0, 0, 0)
		min_x -= db.map_padding
		min_y -= db.map_padding
		max_x += db.map_padding
		max_y += db.map_padding

		for layer_id, layer in enumerate(self.layers):
			if not layer.getCellCache():
				continue
			assert layer_id != LAYERS.WATER, 'Water layer would need special treatment (see previous version)'

			rect = fife.Rect(min_x, min_y, max_x - min_x + 1, max_y - min_y + 1)
			layer.getCellCache().setSize(rect)

########NEW FILE########
__FILENAME__ = binarycache
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.buildability.terraincache import TerrainBuildabilityCache

class LazyBinaryBuildabilityCacheElement(object):
	"""
	Lazily computed cache element of a BinaryBuildabilityCache instance.

	Instances of this class are used to make less frequently needed caches of the
	BinaryBuildabilityCache class instances get computed lazily just when it is needed.
	"""

	def __init__(self, buildability_cache, width):
		self._buildability_cache = buildability_cache
		self._width = width
		self._cache = None

	def _init_size_cache(self):
		if self._cache is not None:
			return

		r3x3 = self._buildability_cache.cache[(3, 3)]
		offset = self._width - 3

		usable = set()
		for coords in r3x3:
			x, y = coords
			if (x + offset, y) in r3x3 and (x, y + offset) in r3x3 and (x + offset, y + offset) in r3x3:
				usable.add(coords)

		self._cache = usable
		size = (self._width, self._width)
		# Replace the reference to this instance with the actual cache
		self._buildability_cache.cache[size] = usable

	def __getattr__(self, name):
		# required to make set methods such as set.intersect work
		self._init_size_cache()
		return getattr(self._cache, name)

	def __contains__(self, key):
		# required to make the syntax "coords in cache" work efficiently
		self._init_size_cache()
		return key in self._cache

	def __iter__(self):
		# required to make iteration work
		self._init_size_cache()
		return iter(self._cache)

class BinaryBuildabilityCache(object):
	"""
	A cache that knows where rectangles can be placed such that they are entirely inside the area.

	This cache can be used to keep track of building buildability in case the
	buildability depends on the building being entirely within a certain area.
	The binary part of the name refers to the fact that a node either is or isn't part of
	the area that the instance is about.

	A query of the form (x, y) in instance.cache[(width, height)] is a very cheap way of
	finding out whether a rectangle of size (width, height) can be placed on origin (x, y)
	such that it is entirely within the given area.

	All elements of instance.cache[(width, height)] can be iterated to get a complete list
	of all such coordinates.
	"""

	def __init__(self, terrain_cache):
		self.terrain_cache = terrain_cache
		self.coords_set = set() # set((x, y), ...)
		self._row2 = set()

		self.cache = {} # {(width, height): set((x, y), ...), ...}
		self.cache[(1, 1)] = self.coords_set
		for size in TerrainBuildabilityCache.sizes:
			if size != (1, 1):
				self.cache[size] = set()
				if size[0] != size[1]:
					self.cache[(size[1], size[0])] = set()

	def _reset_lazy_sets(self):
		self.cache[(4, 4)] = LazyBinaryBuildabilityCacheElement(self, 4)
		self.cache[(6, 6)] = LazyBinaryBuildabilityCacheElement(self, 6)

	@classmethod
	def _extend_set(cls, cur_set, prev_set, prev_set_additions, dx, dy):
		base_set_additions = set()
		for coords in prev_set_additions:
			x, y = coords
			prev_coords = (x - dx, y - dy)
			if prev_coords in prev_set:
				cur_set.add(prev_coords)
				base_set_additions.add(prev_coords)
			next_coords = (x + dx, y + dy)
			if next_coords not in prev_set_additions and next_coords in prev_set:
				cur_set.add(coords)
				base_set_additions.add(coords)
		return base_set_additions

	def add_area(self, new_coords_list):
		"""
		Add a list of new coordinates to the area.

		This function quickly updates the information about the changed coordinates.
		For example when (x, y) is added to the area then it will update the information
		showing whether the 2x1 rectangles with the origin on (x - 1, y) and (x, y) are
		now completely part of the area. Similar the things are done for the larger sizes.
		"""

		for coords in new_coords_list:
			assert coords not in self.coords_set
			assert coords in self.terrain_cache.land_or_coast
			self.coords_set.add(coords)

		coords_set = self.coords_set
		new_coords_set = set(new_coords_list)

		new_row2 = self._extend_set(self._row2, coords_set, new_coords_set, 1, 0)
		new_r2x2 = self._extend_set(self.cache[(2, 2)], self._row2, new_row2, 0, 1)

		new_r2x3 = self._extend_set(self.cache[(2, 3)], self.cache[(2, 2)], new_r2x2, 0, 1)
		new_r2x4 = self._extend_set(self.cache[(2, 4)], self.cache[(2, 3)], new_r2x3, 0, 1)

		new_r3x2 = self._extend_set(self.cache[(3, 2)], self.cache[(2, 2)], new_r2x2, 1, 0)
		new_r4x2 = self._extend_set(self.cache[(4, 2)], self.cache[(3, 2)], new_r3x2, 1, 0)

		self._extend_set(self.cache[(3, 3)], self.cache[(3, 2)], new_r3x2, 0, 1)
		self._reset_lazy_sets()

	@classmethod
	def _reduce_set(cls, cur_set, prev_set_removals, dx, dy):
		base_set_removals = set()
		for coords in prev_set_removals:
			x, y = coords
			prev_coords = (x - dx, y - dy)
			if prev_coords in cur_set:
				cur_set.discard(prev_coords)
				base_set_removals.add(prev_coords)
			next_coords = (x + dx, y + dy)
			if next_coords not in prev_set_removals and coords in cur_set:
				cur_set.discard(coords)
				base_set_removals.add(coords)
		return base_set_removals

	def remove_area(self, removed_coords_list):
		"""Remove a list of existing coordinates from the area."""
		for coords in removed_coords_list:
			assert coords in self.coords_set
			assert coords in self.terrain_cache.land_or_coast
			self.coords_set.discard(coords)
		removed_coords_set = set(removed_coords_list)

		removed_row2 = self._reduce_set(self._row2, removed_coords_set, 1, 0)
		removed_r2x2 = self._reduce_set(self.cache[(2, 2)], removed_row2, 0, 1)

		removed_r2x3 = self._reduce_set(self.cache[(2, 3)], removed_r2x2, 0, 1)
		removed_r2x4 = self._reduce_set(self.cache[(2, 4)], removed_r2x3, 0, 1)

		removed_r3x2 = self._reduce_set(self.cache[(3, 2)], removed_r2x2, 1, 0)
		removed_r4x2 = self._reduce_set(self.cache[(4, 2)], removed_r3x2, 1, 0)

		self._reduce_set(self.cache[(3, 3)], removed_r3x2, 0, 1)
		self._reset_lazy_sets()

########NEW FILE########
__FILENAME__ = connectedareacache
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from collections import deque

class ConnectedAreaCache(object):
	"""
	Query whether (x1, y1) and (x2, y2) are connected.

	This class aims to let one cheaply query the id of the area where (x, y) are. Getting
	that information for (x1, y1) and (x2, y2) shows that it is possible to get from
	one to the other entirely within the area if and only if they have the same area id.

	The area id is an arbitrary integer that is returned for all coordinates in a
	connected area. It is only valid between updates of the cache (any addition/removal
	may change the area id). Thus the ids should never be used for anything other than
	(in)equality checks.
	"""

	__moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]

	def __init__(self):
		self.area_numbers = {} # {(x, y): area id, ...}
		self.areas = {} # {area id: set((x, y), ...), ...}
		self._next_area_id = 1

	def _label_area(self, seed_coords):
		area_id = self._next_area_id
		self._next_area_id += 1

		area_numbers = self.area_numbers
		area_numbers[seed_coords] = area_id
		new_area = set([seed_coords])
		self.areas[area_id] = new_area

		moves = self.__moves
		queue = deque([seed_coords])
		while queue:
			(x, y) = queue.popleft()
			for (dx, dy) in moves:
				coords = (x + dx, y + dy)
				if coords not in area_numbers:
					continue
				if area_numbers[coords] == area_id:
					continue

				area_numbers[coords] = area_id
				new_area.add(coords)
				queue.append(coords)

	def _renumber_affected_areas(self, affected_areas):
		for area_id in affected_areas:
			for coords in self.areas[area_id]:
				if self.area_numbers[coords] == area_id:
					self._label_area(coords)
					assert self.area_numbers[coords] != area_id
			del self.areas[area_id]

	def add_area(self, coords_list):
		"""Add a list of new coordinates to the area."""
		moves = self.__moves
		affected_areas = set()
		for coords in coords_list:
			assert coords not in self.area_numbers
			nearby_areas = []
			for (dx, dy) in moves:
				neighbor_coords = (coords[0] + dx, coords[1] + dy)
				if neighbor_coords in self.area_numbers:
					area_id = self.area_numbers[neighbor_coords]
					if area_id not in nearby_areas:
						nearby_areas.append(area_id)

			if not nearby_areas:
				# create a new area
				area_id = self._next_area_id
				self._next_area_id += 1
				self.area_numbers[coords] = area_id
				self.areas[area_id] = set([coords])
			else:
				# add to one of the nearby areas
				area_id = nearby_areas[0]
				self.area_numbers[coords] = area_id
				self.areas[area_id].add(coords)
				if len(nearby_areas) > 1:
					# more than one nearby area; merge them later on
					for nearby_area_id in nearby_areas:
						affected_areas.add(nearby_area_id)

		self._renumber_affected_areas(affected_areas)

	def remove_area(self, coords_list):
		"""Remove a list of existing coordinates from the area."""
		affected_areas = set()
		for coords in coords_list:
			area_id = self.area_numbers[coords]
			del self.area_numbers[coords]
			affected_areas.add(area_id)
			self.areas[area_id].discard(coords)
		self._renumber_affected_areas(affected_areas)

########NEW FILE########
__FILENAME__ = freeislandcache
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.buildability.binarycache import BinaryBuildabilityCache

class FreeIslandBuildabilityCache(object):
	"""
	An instance of this class is used to keep track of the unclaimed area on an island.

	Instances of this class can answer the same queries as BinaryBuildabilityCache.
	It is specialized for keeping track of the unclaimed land on an island. That way it
	is possible to use it in conjunction with the TerrainCache to find all available
	warehouse positions on an island.

	Note that the cache is initialized with all unclaimed tiles on the island and after
	that it can only reduce in size because it is currently impossible for land to change
	ownership after it has been claimed by the first player.
	"""

	def __init__(self, island):
		self._binary_cache = BinaryBuildabilityCache(island.terrain_cache)
		self.cache = self._binary_cache.cache # {(width, height): set((x, y), ...), ...}
		self.island = island
		self._init()

	def _init(self):
		land_or_coast = self._binary_cache.terrain_cache.land_or_coast
		coords_list = []
		for (coords, tile) in self.island.ground_map.iteritems():
			if coords not in land_or_coast:
				continue
			if tile.settlement is not None:
				continue
			if tile.object is not None and not tile.object.buildable_upon:
				continue
			coords_list.append(coords)
		self._binary_cache.add_area(coords_list)

	def remove_area(self, coords_list):
		"""Remove a list of existing coordinates from the area."""
		clean_list = []
		for coords in coords_list:
			if coords in self._binary_cache.coords_set:
				clean_list.append(coords)
		self._binary_cache.remove_area(clean_list)

	def add_area(self, coords_list):
		"""Add a list of coordinates to the area."""
		clean_list = []
		for coords in coords_list:
			if coords not in self._binary_cache.coords_set:
				clean_list.append(coords)
		self._binary_cache.add_area(clean_list)

########NEW FILE########
__FILENAME__ = partialbinarycache
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.buildability.terraincache import TerrainBuildabilityCache

class PartialBinaryBuildabilityCache(object):
	"""
	A cache that knows where rectangles can be placed such that they are entirely inside the area.

	This cache can be used to keep track of building buildability in case the
	buildability depends on the building being at least partly within a certain area.
	The binary part of the name refers to the fact that a node either is or isn't part of
	the area that the instance is about.

	A query of the form (x, y) in instance.cache[(width, height)] is a very cheap way of
	finding out whether a rectangle of size (width, height) can be placed on origin (x, y)
	such that at least some part of it is within the given area.

	All elements of instance.cache[(width, height)] can be iterated to get a complete list
	of all such coordinates.
	"""

	def __init__(self, terrain_cache):
		self.terrain_cache = terrain_cache
		self.coords_set = set() # set((x, y), ...)
		self._row2 = set()

		sizes = set(TerrainBuildabilityCache.sizes)
		# extra sizes for the intermediate computation
		sizes.add((3, 4))
		sizes.add((4, 5))
		sizes.add((5, 5))
		sizes.add((5, 6))

		self.cache = {} # {(width, height): set((x, y), ...), ...}
		self.cache[(1, 1)] = self.coords_set
		for size in sizes:
			if size != (1, 1):
				self.cache[size] = set()
				if size[0] != size[1]:
					self.cache[(size[1], size[0])] = set()

	@classmethod
	def _extend_set(cls, cur_set, prev_set_additions, dx, dy):
		base_set_additions = set()
		for coords in prev_set_additions:
			x, y = coords
			prev_coords = (x - dx, y - dy)
			if prev_coords not in cur_set:
				cur_set.add(prev_coords)
				base_set_additions.add(prev_coords)
			next_coords = (x + dx, y + dy)
			if next_coords not in prev_set_additions and coords not in cur_set:
				cur_set.add(coords)
				base_set_additions.add(coords)
		return base_set_additions

	def add_area(self, new_coords_list):
		"""Add a list of new coordinates to the area."""
		for coords in new_coords_list:
			assert coords not in self.coords_set
			assert coords in self.terrain_cache.land_or_coast
			self.coords_set.add(coords)

		added_coords_set = set(new_coords_list)
		new_row2 = self._extend_set(self._row2, added_coords_set, 1, 0)
		new_r2x2 = self._extend_set(self.cache[(2, 2)], new_row2, 0, 1)

		new_r2x3 = self._extend_set(self.cache[(2, 3)], new_r2x2, 0, 1)
		new_r2x4 = self._extend_set(self.cache[(2, 4)], new_r2x3, 0, 1)

		new_r3x2 = self._extend_set(self.cache[(3, 2)], new_r2x2, 1, 0)
		new_r4x2 = self._extend_set(self.cache[(4, 2)], new_r3x2, 1, 0)

		new_r3x3 = self._extend_set(self.cache[(3, 3)], new_r3x2, 0, 1)

		# the further sizes are created just to support 4x4 and 6x6 buildings
		new_r3x4 = self._extend_set(self.cache[(3, 4)], new_r3x3, 0, 1)
		new_r4x4 = self._extend_set(self.cache[(4, 4)], new_r3x4, 1, 0)
		new_r4x5 = self._extend_set(self.cache[(4, 5)], new_r4x4, 0, 1)
		new_r5x5 = self._extend_set(self.cache[(5, 5)], new_r4x5, 1, 0)
		new_r5x6 = self._extend_set(self.cache[(5, 6)], new_r5x5, 0, 1)
		self._extend_set(self.cache[(6, 6)], new_r5x6, 1, 0)

	@classmethod
	def _reduce_set(cls, cur_set, prev_set, prev_set_removals, dx, dy):
		base_set_removals = set()
		for coords in prev_set_removals:
			x, y = coords
			prev_coords = (x - dx, y - dy)
			if prev_coords not in prev_set:
				cur_set.discard(prev_coords)
				base_set_removals.add(prev_coords)
			next_coords = (x + dx, y + dy)
			if next_coords not in prev_set_removals and next_coords not in prev_set:
				cur_set.discard(coords)
				base_set_removals.add(coords)
		return base_set_removals

	def remove_area(self, removed_coords_list):
		"""Remove a list of existing coordinates from the area."""
		for coords in removed_coords_list:
			assert coords in self.coords_set
			assert coords in self.terrain_cache.land_or_coast
			self.coords_set.discard(coords)
		removed_coords_set = set(removed_coords_list)

		removed_row2 = self._reduce_set(self._row2, self.coords_set, removed_coords_set, 1, 0)
		removed_r2x2 = self._reduce_set(self.cache[(2, 2)], self._row2, removed_row2, 0, 1)

		removed_r2x3 = self._reduce_set(self.cache[(2, 3)], self.cache[(2, 2)], removed_r2x2, 0, 1)
		removed_r2x4 = self._reduce_set(self.cache[(2, 4)], self.cache[(2, 3)], removed_r2x3, 0, 1)

		removed_r3x2 = self._reduce_set(self.cache[(3, 2)], self.cache[(2, 2)], removed_r2x2, 1, 0)
		removed_r4x2 = self._reduce_set(self.cache[(4, 2)], self.cache[(3, 2)], removed_r3x2, 1, 0)

		removed_r3x3 = self._reduce_set(self.cache[(3, 3)], self.cache[(3, 2)], removed_r3x2, 0, 1)
		removed_r3x4 = self._reduce_set(self.cache[(3, 4)], self.cache[(3, 3)], removed_r3x3, 0, 1)
		removed_r4x4 = self._reduce_set(self.cache[(4, 4)], self.cache[(3, 4)], removed_r3x4, 1, 0)
		removed_r4x5 = self._reduce_set(self.cache[(4, 5)], self.cache[(4, 4)], removed_r4x4, 0, 1)
		removed_r5x5 = self._reduce_set(self.cache[(5, 5)], self.cache[(4, 5)], removed_r4x5, 1, 0)
		removed_r5x6 = self._reduce_set(self.cache[(5, 6)], self.cache[(5, 5)], removed_r5x5, 0, 1)
		self._reduce_set(self.cache[(6, 6)], self.cache[(5, 6)], removed_r5x6, 1, 0)

########NEW FILE########
__FILENAME__ = potentialroadconnectivitycache
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.ai.aiplayer.constants import BUILDING_PURPOSE
from horizons.world.buildability.connectedareacache import ConnectedAreaCache

class PotentialRoadConnectivityCache(object):
	"""
	Query whether a toad connection between two sets of coordinates is possible.

	This class is used by the AI to figure out whether it might be possible to build a
	road between two sets of coordinates. Potentially because the area contains some part
	of the AI's plan and the land it has a plan for may be either owned by the AI or not
	yet owned by anyone.
	"""

	def __init__(self, area_builder):
		self._area_builder = area_builder
		self._land_manager = area_builder.land_manager
		self._settlement_ground_map = area_builder.settlement.ground_map
		self._cache = ConnectedAreaCache()
		self.area_numbers = self._cache.area_numbers # {(x, y): area id, ...}

	def modify_area(self, coords_list):
		"""
		Refresh the usability of the coordinates in the given list.

		This function is called with a list of coordinates on which the possibility of
		building a road may have changed. It figures out whether it is possible to build
		a road on (x, y) and updates the underlying ConnectedAreaCache accordingly.
		"""

		add_list = []
		remove_list = []

		for coords in coords_list:
			if coords not in self._settlement_ground_map:
				if coords in self.area_numbers:
					remove_list.append(coords)
			elif coords in self._land_manager.coastline:
				if coords in self.area_numbers:
					remove_list.append(coords)
			elif coords in self._land_manager.roads:
				if coords not in self.area_numbers:
					add_list.append(coords)
			elif coords in self._area_builder.plan:
				if self._area_builder.plan[coords][0] == BUILDING_PURPOSE.NONE:
					if coords not in self.area_numbers:
						add_list.append(coords)
				else:
					assert self._area_builder.plan[coords][0] != BUILDING_PURPOSE.ROAD
					if coords in self.area_numbers:
						remove_list.append(coords)
			else:
				if coords in self.area_numbers:
					remove_list.append(coords)

		if add_list:
			self._cache.add_area(add_list)
		if remove_list:
			self._cache.remove_area(remove_list)

	def is_connection_possible(self, coords_set1, coords_set2):
		"""Return True if and only if it is possible to connect the two coordinate sets.

		More specifically, it returns True if and only if it is possible to build a toad
		from some (x1, y1) in coords_set1 to some (x2, y2) in coords_set2 entirely within
		the area. This is done cheaply using the underlying ConnectedAreaCache.
		"""

		areas1 = set()
		for coords in coords_set1:
			if coords in self.area_numbers:
				areas1.add(self.area_numbers[coords])
		for coords in coords_set2:
			if coords in self.area_numbers:
				if self.area_numbers[coords] in areas1:
					return True
		return False

########NEW FILE########
__FILENAME__ = settlementcache
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.buildability.binarycache import BinaryBuildabilityCache

class SettlementBuildabilityCache(BinaryBuildabilityCache):
	"""A specialized BinaryBuildabilityCache for settlements."""

	def __init__(self, terrain_cache, settlement_ground_map):
		super(SettlementBuildabilityCache, self).__init__(terrain_cache)
		self.settlement_ground_map = settlement_ground_map

	def add_area(self, coords_list):
		"""Add a list of new coordinates to the area."""
		land_or_coast = self.terrain_cache.land_or_coast
		add_list = []
		for coords in coords_list:
			if coords in land_or_coast:
				add_list.append(coords)
		if add_list:
			super(SettlementBuildabilityCache, self).add_area(add_list)

	def modify_area(self, coords_list):
		"""
		Refresh the usability of the coordinates in the given list.

		This function is called with a list of coordinates on which the possibility of
		building a building may have changed to update the underlying BinaryBuildabilityCache.
		"""

		land_or_coast = self.terrain_cache.land_or_coast

		add_list = []
		remove_list = []
		for coords in coords_list:
			assert isinstance(coords, tuple)
			if coords not in land_or_coast or coords not in self.settlement_ground_map:
				continue

			object = self.settlement_ground_map[coords].object
			if object is None or object.buildable_upon:
				if coords not in self.coords_set:
					add_list.append(coords)
			elif coords in self.coords_set:
				remove_list.append(coords)

		if remove_list:
			self.remove_area(remove_list)
		if add_list:
			super(SettlementBuildabilityCache, self).add_area(add_list)

########NEW FILE########
__FILENAME__ = simplecollectorareacache
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.buildability.partialbinarycache import PartialBinaryBuildabilityCache

class SimpleCollectorAreaCache(object):
	"""
	A specialized PartialBinaryBuildabilityCache for keeping track of collector coverage.

	The AI uses instances of this class to figure out where it can place buildings such
	that at least some part of the building would be covered by a general collector. It
	is a simple version in that it doesn't check whether a road to the corresponding
	collector would be possible.
	"""

	def __init__(self, terrain_cache):
		self.terrain_cache = terrain_cache
		self._area_cache = PartialBinaryBuildabilityCache(terrain_cache)
		self.cache = self._area_cache.cache # {(width, height): set((x, y), ...), ...}
		self._buildings = set()
		self._area_coverage = {}

	def add_building(self, building):
		"""Take the the coverage area of the given building into account."""
		self._buildings.add(building)

		new_coords_list = []
		for coords in building.position.get_radius_coordinates(building.radius, True):
			if coords not in self.terrain_cache.land_or_coast:
				continue

			if coords not in self._area_coverage:
				self._area_coverage[coords] = 1
				new_coords_list.append(coords)
			else:
				self._area_coverage[coords] += 1
		for coords in new_coords_list:
			assert coords in self.terrain_cache.land_or_coast
		self._area_cache.add_area(new_coords_list)

	def remove_building(self, building):
		"""Stop taking the coverage area of the given building into account."""
		self._buildings.remove(building)

		removed_coords_list = []
		for coords in building.position.get_radius_coordinates(building.radius, True):
			if coords not in self.terrain_cache.land_or_coast:
				continue

			if self._area_coverage[coords] == 1:
				removed_coords_list.append(coords)
				del self._area_coverage[coords]
			else:
				self._area_coverage[coords] -= 1
		self._area_cache.remove_area(removed_coords_list)

########NEW FILE########
__FILENAME__ = terraincache
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.shapes.rect import Rect

class TerrainRequirement:
	LAND = 1 # buildings that must be entirely on flat land
	LAND_AND_COAST = 2 # buildings that have to be partially on the coast
	LAND_AND_COAST_NEAR_SEA = 3 # coastal buildings that have to be near the sea

class TerrainBuildabilityCache(object):
	"""
	Keep track of the locations where buildings of specific types can be built.

	An instance of this class is used to keep track of the buildability options given the
	terrain. (x, y) are in instance.cache[terrain_type][(width, height)] if and only if
	it is possible to place a building with the given terrain type restrictions and with
	the given size at the origin (x, y) given that other conditions are met. Basically it
	cares about the required terrain type of the building and not about the buildings on
	the island.

	Other than the terrain type dimension it acts like an immutable BinaryBuildabilityCache.
	"""

	sizes = [(1, 1), (2, 2), (2, 3), (2, 4), (3, 3), (4, 4), (6, 6)]
	sea_radius = 3

	def __init__(self, island):
		super(TerrainBuildabilityCache, self).__init__()
		self._island = island
		self._land = None
		self._coast = None
		self.land_or_coast = None # set((x, y), ...)
		self.cache = None # {terrain type: {(width, height): set((x, y), ...), ...}, ...}
		self.create_cache()

	def _init_land_and_coast(self):
		land = set()
		coast = set()

		for coords, tile in self._island.ground_map.iteritems():
			if 'constructible' in tile.classes:
				land.add(coords)
			elif 'coastline' in tile.classes:
				coast.add(coords)

		self._land = land
		self._coast = coast
		self.land_or_coast = land.union(coast)

	def _init_rows(self):
		# these dicts show whether there is a constructible and/or coastline tile in a row
		# of 2 or 3 tiles starting from the coords and going right
		# both are in the format {(x, y): (has land, has coast), ...}
		row2 = {}
		row3 = {}

		land = self._land
		coast = self._coast
		land_or_coast = self.land_or_coast

		for (x, y) in self.land_or_coast:
			if (x + 1, y) not in land_or_coast:
				continue

			has_land = (x, y) in land or (x + 1, y) in land
			has_coast = (x, y) in coast or (x + 1, y) in coast
			row2[(x, y)] = (has_land, has_coast)
			if (x + 2, y) not in land_or_coast:
				continue

			has_land = has_land or (x + 2, y) in land
			has_coast = has_coast or (x + 2, y) in coast
			row3[(x, y)] = (has_land, has_coast)

		self.row2 = row2
		self.row3 = row3

	def _init_squares(self):
		self._init_rows()
		row2 = self.row2
		row3 = self.row3

		sq2 = {}
		for coords in row2:
			coords2 = (coords[0], coords[1] + 1)
			if coords2 in row2:
				has_land = row2[coords][0] or row2[coords2][0]
				has_coast = row2[coords][1] or row2[coords2][1]
				sq2[coords] = (has_land, has_coast)

		sq3 = {}
		for coords in row3:
			coords2 = (coords[0], coords[1] + 1)
			coords3 = (coords[0], coords[1] + 2)
			if coords2 in row3 and coords3 in row3:
				has_land = row3[coords][0] or row3[coords2][0] or row3[coords3][0]
				has_coast = row3[coords][1] or row3[coords2][1] or row3[coords3][1]
				sq3[coords] = (has_land, has_coast)

		self.sq2 = sq2
		self.sq3 = sq3

	def create_cache(self):
		self._init_land_and_coast()

		land = {}
		land_and_coast = {}

		land[(1, 1)] = self._land
		for size in self.sizes:
			if size != (1, 1):
				land[size] = set()
				if size[0] != size[1]:
					land[(size[1], size[0])] = set()

		for size in [(2, 2), (3, 3)]:
			land_and_coast[size] = set()

		self._init_squares()

		sq2 = self.sq2
		for coords, (has_land, has_coast) in sq2.iteritems():
			x, y = coords
			if has_land and has_coast:
				# handle 2x2 coastal buildings
				land_and_coast[(2, 2)].add(coords)
			elif has_land and not has_coast:
				# handle 2x2, 2x3, and 2x4 land buildings
				land[(2, 2)].add(coords)

				if (x + 2, y) in sq2 and not sq2[(x + 2, y)][1]:
					land[(3, 2)].add(coords)
					land[(4, 2)].add(coords)
				elif (x + 1, y) in sq2 and not sq2[(x + 1, y)][1]:
					land[(3, 2)].add(coords)

				if (x, y + 2) in sq2 and not sq2[(x, y + 2)][1]:
					land[(2, 3)].add(coords)
					land[(2, 4)].add(coords)
				elif (x, y + 1) in sq2 and not sq2[(x, y + 1)][1]:
					land[(2, 3)].add(coords)

		sq3 = self.sq3
		for coords, (has_land, has_coast) in sq3.iteritems():
			x, y = coords
			if has_land and has_coast:
				# handle 3x3 coastal buildings
				land_and_coast[(3, 3)].add(coords)
			elif has_land and not has_coast:
				# handle other buildings that have both sides >= 3 (3x3, 4x4, 6x6)
				land[(3, 3)].add(coords)

				if (x, y + 3) in sq3 and not sq3[(x, y + 3)][1] and (x + 3, y) in sq3 \
					    and not sq3[(x + 3, y)][1] and (x + 3, y + 3) in sq3 and not sq3[(x + 3, y + 3)][1]:
					land[(4, 4)].add(coords)
					land[(6, 6)].add(coords)
				elif (x, y + 1) in sq3 and not sq3[(x, y + 1)][1] and (x + 1, y) in sq3 \
					    and not sq3[(x + 1, y)][1] and (x + 1, y + 1) in sq3 and not sq3[(x + 1, y + 1)][1]:
					land[(4, 4)].add(coords)

		self.cache = {}
		self.cache[TerrainRequirement.LAND] = land
		self.cache[TerrainRequirement.LAND_AND_COAST] = land_and_coast

	def create_sea_cache(self):
		# currently only 3x3 buildings can require nearby sea
		coast_set = self.cache[TerrainRequirement.LAND_AND_COAST][(3, 3)]
		near_sea = set()

		nearby_coords_list = []
		base_rect = Rect.init_from_topleft_and_size(0, 0, 3, 3)
		for coords in base_rect.get_radius_coordinates(self.sea_radius):
			nearby_coords_list.append(coords)

		world = self._island.session.world
		water_bodies = world.water_body
		sea_number = world.sea_number

		for bx, by in coast_set:
			for dx, dy in nearby_coords_list:
				coords = (bx + dx, by + dy)
				if coords in water_bodies and water_bodies[coords] == sea_number:
					near_sea.add((bx, by))
					break

		self.cache[TerrainRequirement.LAND_AND_COAST_NEAR_SEA] = {}
		self.cache[TerrainRequirement.LAND_AND_COAST_NEAR_SEA][(3, 3)] = near_sea

	def get_buildability_intersection(self, terrain_type, size, *other_cache_layers):
		result = self.cache[terrain_type][size]
		for cache_layer in other_cache_layers:
			result = result.intersection(cache_layer.cache[size])
		return result

########NEW FILE########
__FILENAME__ = boatbuilder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from building import BasicBuilding
from buildable import BuildableSingleOnOcean
from horizons.world.building.buildingresourcehandler import BuildingResourceHandler
from horizons.component.storagecomponent import StorageComponent

class BoatBuilder(BuildingResourceHandler, BuildableSingleOnOcean, BasicBuilding):

	def __init__(self, **kwargs):
		super(BoatBuilder, self).__init__(**kwargs)

	def initialize(self, **kwargs):
		super(BoatBuilder, self).initialize(**kwargs)
		self.get_component(StorageComponent).inventory.limit = 10

########NEW FILE########
__FILENAME__ = buildable
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import itertools

from horizons.util.pathfinding.roadpathfinder import RoadPathFinder
from horizons.util.python import decorators
from horizons.util.shapes import Circle, Point, Rect
from horizons.util.worldobject import WorldObject
from horizons.world.buildability.terraincache import TerrainRequirement
from horizons.constants import BUILDINGS
from horizons.entities import Entities

class BuildableErrorTypes(object):
	"""Killjoy class. Collection of reasons why you can't build."""
	NO_ISLAND, UNFIT_TILE, NO_SETTLEMENT, OTHER_PLAYERS_SETTLEMENT, \
	OTHER_PLAYERS_SETTLEMENT_ON_ISLAND, OTHER_BUILDING_THERE, UNIT_THERE, NO_COAST, \
	NO_OCEAN_NEARBY, ONLY_NEAR_SHIP, NEED_RES_SOURCE, ISLAND_ALREADY_SETTLED, \
	NO_FLAT_LAND = range(13)

	text = {
	  NO_ISLAND : _("This building must be built on an island."),
	  UNFIT_TILE : _("This ground is not suitable for this building."),
	  NO_SETTLEMENT : _("This building has to be built within your settlement."),
	  OTHER_PLAYERS_SETTLEMENT : _("This area is already occupied by another player."),
	  OTHER_BUILDING_THERE : _("This area is already occupied by another building."),
	  UNIT_THERE : _("This area is already occupied by a unit."),
	  NO_COAST : _("This building must be built on the coastline."),
	  NO_OCEAN_NEARBY : _("This building has to be placed at the ocean."),
	  ONLY_NEAR_SHIP : _("This spot is too far away from your ship."),
	  NEED_RES_SOURCE : _("This building can only be built on a resource source."),
	  ISLAND_ALREADY_SETTLED : _("You have already settled this island."),
	  NO_FLAT_LAND : _("This building must be partly on flat land.")
	}
	# TODO: say res source which one we need, maybe even highlight those

class _BuildPosition(object):
	"""A possible build position in form of a data structure.
	Don't use directly outside of this file"""
	def __init__(self, position, rotation, tearset, buildable, action='idle',
	             problem=None):
		"""
		@param position: Rect, building position and size
		@param rotation: int rotation of building
		@param tearset: list of worldids of buildings to tear for this building to build
		@param buildable: whether building is actually buildable there
		@param action: action (animation of building)
		@param problem: (error number, error string) reason it's not buildable or None
		"""
		self.position = position
		self.rotation = rotation
		self.tearset = tearset
		self.buildable = buildable
		self.action = action
		self.problem = problem

	def __nonzero__(self):
		"""Returns buildable value. This enables code such as "if cls.check_build()"""
		return self.buildable

	def __eq__(self, other):
		if not isinstance(other, _BuildPosition):
			return False
		return (self.position == other.position and
		        self.rotation == other.rotation and
		        self.action == other.action and
		        self.tearset == other.tearset)

	def __ne__(self, other):
		return not self.__eq__(other)

	def __hash__(self):
		return hash((self.position, self.rotation, self.action))

class _NotBuildableError(Exception):
	"""Internal exception."""
	def __init__(self, errortype):
		super(_NotBuildableError, self).__init__()
		self.errortype = errortype

class Buildable(object):
	"""Interface for every kind of buildable objects.
	Contains methods to determine whether a building can be placed on a coordinate, regarding
	island, settlement, ground requirements etc. Does not care about building costs."""

	irregular_conditions = False # whether all ground tiles have to fulfill the same conditions
	terrain_type = TerrainRequirement.LAND

	# check this far for fuzzy build
	CHECK_NEARBY_LOCATIONS_UP_TO_DISTANCE = 3

	# INTERFACE

	@classmethod
	def check_build(cls, session, point, rotation=45, check_settlement=True, ship=None, issuer=None):
		"""Check if a building is buildable here.
		All tiles, that the building occupies are checked.
		@param point: Point instance, coords
		@param rotation: preferred rotation of building
		@param check_settlement: whether to check for a settlement (for settlementless buildings)
		@param ship: ship instance if building from ship
		@return instance of _BuildPosition"""
		# for non-quadratic buildings, we have to switch width and height depending on the rotation
		if rotation == 45 or rotation == 225:
			position = Rect.init_from_topleft_and_size(point.x, point.y, cls.size[0], cls.size[1])
		else:
			position = Rect.init_from_topleft_and_size(point.x, point.y, cls.size[1], cls.size[0])

		buildable = True
		problem = None
		tearset = []
		try:
			island = cls._check_island(session, position)
			# TODO: if the rotation changes here for non-quadratic buildings, wrong results will be returned
			rotation = cls._check_rotation(session, position, rotation)
			tearset = cls._check_buildings(session, position, island=island)
			cls._check_units(session, position)
			if check_settlement:
				cls._check_settlement(session, position, ship=ship, issuer=issuer)
		except _NotBuildableError as e:
			buildable = False
			problem = (e.errortype, _(BuildableErrorTypes.text[e.errortype]))

		return _BuildPosition(position, rotation, tearset, buildable, problem=problem)

	@classmethod
	def check_build_line(cls, session, point1, point2, rotation=45, ship=None):
		"""Checks out a line on the map for build possibilities.
		The line usually is a draw of the mouse.
		@param point1, point2: Point instance, start and end of the line
		@param rotation: prefered rotation
		@param ship: ship instance if building from ship
		@return list of _BuildPositions
		"""
		raise NotImplementedError

	@classmethod
	def is_tile_buildable(cls, session, tile, ship, island=None, check_settlement=True):
		"""Checks a tile for buildability.
		@param tile: Ground object
		@param ship: Ship instance if building from ship
		@param island: Island instance, if already known. If None, it will be calculated
		@param check_settlement: bool, whether to check for settlement
		@return bool, True for "is buildable" """
		position = Point(tile.x, tile.y)
		try:
			cls._check_island(session, position, island)
			if check_settlement:
				cls._check_settlement(session, position, ship=ship)
			cls._check_buildings(session, position)
		except _NotBuildableError:
			return False

		if cls.irregular_conditions:
			# check in case not all ground tiles have to fulfill the same conditions (e.g. when 1 tile has to be coast)

			# at least one location that has this tile must be actually buildable
			# area of the buildings is (x, y) + width/height, therefore all build positions that
			# include (x, y) are (x, y) - ( [0..width], [0..height] )
			return any(cls.check_build(session, Point(tile.x - x_off, tile.y - y_off), ship=ship)
			           for x_off, y_off in itertools.product(xrange(cls.size[0]), xrange(cls.size[1])) )
		else:
			return True

	@classmethod
	def check_build_fuzzy(cls, session, point, *args, **kwargs):
		"""Same as check_build, but consider point to be a vague suggestions
		and search nearby area for buildable position.
		Returns one of the closest viable positions or the original position as not buildable if none can be found"""

		# this is some kind of case study of applied functional programming

		def filter_duplicates(gen, transform=lambda x : x):
			"""
			@param transform: transforms elements to hashable equivalent
			"""
			checked = set()
			for elem in itertools.ifilterfalse(lambda e : transform(e) in checked, gen):
				checked.add(transform(elem))
				yield elem

		# generate coords near point, search coords of small circles to larger ones
		def get_positions():
			iters = (iter(Circle(point, radius)) for radius in xrange(cls.CHECK_NEARBY_LOCATIONS_UP_TO_DISTANCE))
			return itertools.chain.from_iterable(iters)

		# generate positions and check for matches
		check_pos = lambda pos : cls.check_build(session, pos, *args, **kwargs)
		checked = itertools.imap(check_pos,
		                         filter_duplicates(get_positions(), transform=lambda p : p.to_tuple()))

		# filter positive solutions
		result_generator = itertools.ifilter(lambda buildpos: buildpos.buildable, checked)

		try:
			# return first match
			return result_generator.next()
		except StopIteration:
			# No match found, fail with specified parameters.
			return check_pos(point)


	# PRIVATE PARTS

	@classmethod
	def _check_island(cls, session, position, island=None):
		"""Check if there is an island and enough tiles.
		@throws _NotBuildableError if building can't be built.
		@param position: coord Point to build at
		@param island: Island instance if known before"""
		if island is None:
			if position.__class__ is Rect: # performance optimization
				at = position.left, position.top
			else:
				at = position.center.to_tuple()
			island = session.world.get_island_tuple(at)
			if island is None:
				raise _NotBuildableError(BuildableErrorTypes.NO_ISLAND)
		for tup in position.tuple_iter():
			# can't use get_tile_tuples since it discards None's
			tile = island.get_tile_tuple(tup)
			if tile is None:
				raise _NotBuildableError(BuildableErrorTypes.NO_ISLAND)
			if 'constructible' not in tile.classes:
				raise _NotBuildableError(BuildableErrorTypes.UNFIT_TILE)
		return island

	@classmethod
	def _check_rotation(cls, session, position, rotation):
		"""Returns a possible rotation for this building.
		@param position: Rect or Point instance, position and size
		@param rotation: The preferred rotation
		@return: integer, an available rotation in degrees"""
		return rotation

	@classmethod
	def _check_settlement(cls, session, position, ship=None, issuer=None):
		"""Check that there is a settlement that belongs to the player."""
		player = issuer if issuer is not None else session.world.player
		first_legal_settlement = None
		for coords in position.tuple_iter():
			if coords not in session.world.full_map:
				raise _NotBuildableError(BuildableErrorTypes.NO_SETTLEMENT)
			settlement = session.world.full_map[coords].settlement
			if settlement is None:
				raise _NotBuildableError(BuildableErrorTypes.NO_SETTLEMENT)
			if player != settlement.owner:
				raise _NotBuildableError(BuildableErrorTypes.OTHER_PLAYERS_SETTLEMENT)
			# there should be exactly one legal settlement under the position
			assert first_legal_settlement is None or first_legal_settlement is settlement
			first_legal_settlement = settlement
		assert first_legal_settlement

	@classmethod
	def _check_buildings(cls, session, position, island=None):
		"""Check if there are buildings blocking the build.
		@return Iterable of worldids of buildings that need to be teared in order to build here"""
		if island is None:
			island = session.world.get_island(position.center)
			# _check_island already confirmed that there must be an island here, so no check for None again
		tearset = set()
		for tile in island.get_tiles_tuple(position.tuple_iter()):
			obj = tile.object
			if obj is not None: # tile contains an object
				if obj.buildable_upon:
					if obj.__class__ is cls:
						# don't tear trees to build trees over them
						raise _NotBuildableError(BuildableErrorTypes.OTHER_BUILDING_THERE)
					# tear it so we can build over it
					tearset.add(obj.worldid)
				else:
					# building is blocking the build
					raise _NotBuildableError(BuildableErrorTypes.OTHER_BUILDING_THERE)
		if hasattr(session.manager, 'get_builds_in_construction'):
			builds_in_construction = session.manager.get_builds_in_construction()
			for build in builds_in_construction:
				(sizex, sizey) = Entities.buildings[build.building_class].size
				for (neededx, neededy) in position.tuple_iter():
					if neededx in range(build.x, build.x+sizex) and neededy in range(build.y, build.y+sizey):
						raise _NotBuildableError(BuildableErrorTypes.OTHER_BUILDING_THERE)
		return tearset

	@classmethod
	def _check_units(cls, session, position):
		for tup in position.tuple_iter():
			if tup in session.world.ground_unit_map:
				raise _NotBuildableError(BuildableErrorTypes.UNIT_THERE)

class BuildableSingle(Buildable):
	"""Buildings one can build single. """
	@classmethod
	def check_build_line(cls, session, point1, point2, rotation=45, ship=None):
		# only build 1 building at endpoint
		# correct placement for large buildings (mouse should be at center of building)
		point2 = point2.copy() # only change copy
		point2.x -= (cls.size[0] - 1) / 2
		point2.y -= (cls.size[1] - 1) / 2
		return [ cls.check_build_fuzzy(session, point2, rotation=rotation, ship=ship) ]

class BuildableSingleEverywhere(BuildableSingle):
	"""Buildings, that can be built everywhere. Usually not used for buildings placeable by humans."""
	terrain_type = None

	@classmethod
	def check_build(cls, session, point, rotation=45, check_settlement=True, ship=None, issuer=None):
		# for non-quadratic buildings, we have to switch width and height depending on the rotation
		if rotation == 45 or rotation == 225:
			position = Rect.init_from_topleft_and_size(point.x, point.y, cls.size[0], cls.size[1])
		else:
			position = Rect.init_from_topleft_and_size(point.x, point.y, cls.size[1], cls.size[0])

		buildable = True
		tearset = []
		return _BuildPosition(position, rotation, tearset, buildable)


class BuildableRect(Buildable):
	"""Buildings one can build as a Rectangle, such as Trees"""
	@classmethod
	def check_build_line(cls, session, point1, point2, rotation=45, ship=None):
		if point1 == point2:
			# this is actually a masked single build
			return [cls.check_build_fuzzy(session, point1, rotation=rotation, ship=ship)]
		possible_builds = []
		area = Rect.init_from_corners(point1, point2)
		# correct placement for large buildings (mouse should be at center of building)
		area.left -= (cls.size[0] - 1) // 2
		area.right -= (cls.size[0] - 1) // 2
		area.top -= (cls.size[1] - 1) // 2
		area.bottom -= (cls.size[1] - 1) // 2

		xstart, xend = area.left, area.right + 1
		xstep = cls.size[0]
		if point1.x > point2.x:
			xstart, xend = area.right, area.left - 1
			xstep *= -1

		ystart, yend = area.top, area.bottom + 1
		ystep = cls.size[1]
		if point1.y > point2.y:
			ystart, yend = area.bottom, area.top - 1
			ystep *= -1

		for x in xrange(xstart, xend, xstep):
			for y in xrange(ystart, yend, ystep):
				possible_builds.append(
				  cls.check_build(session, Point(x, y), rotation=rotation, ship=ship)
				)
		return possible_builds


class BuildableLine(Buildable):
	"""Buildings one can build in a line, such as paths"""
	@classmethod
	def check_build_line(cls, session, point1, point2, rotation=45, ship=None):

		# Pathfinding currently only supports buildingsize 1x1, so don't use it in this case
		if cls.size != (1, 1):
			return [ cls.check_build_fuzzy(session, point2, rotation=rotation, ship=ship) ]

		# use pathfinding to get a path, then try to build along it
		island = session.world.get_island(point1)
		if island is None:
			return []

		path = RoadPathFinder()(island.path_nodes.nodes, point1.to_tuple(),
		                        point2.to_tuple(), rotation in (45, 225))
		if path is None: # can't find a path between these points
			return [] # TODO: maybe implement alternative strategy

		possible_builds = []

		#TODO duplicates recalculation code in world.building.path
		for x, y in path:
			action = ''
			for action_char, (xoff, yoff) in \
			    sorted(BUILDINGS.ACTION.action_offset_dict.iteritems()): # order is important here
				if action_char in 'abcd' and (xoff + x, yoff + y) in path:
					action += action_char
			if action == '':
				action = 'single' # single trail piece with no neighbors

			build = cls.check_build(session, Point(x, y))
			build.action = action
			possible_builds.append(build)

		return possible_builds


class BuildableSingleOnCoast(BuildableSingle):
	"""Buildings one can only build on coast, such as the fisher."""
	irregular_conditions = True
	terrain_type = TerrainRequirement.LAND_AND_COAST

	@classmethod
	def _check_island(cls, session, position, island=None):
		# ground has to be either coastline or constructible, > 1 tile must be coastline
		# can't use super, since it checks all tiles for constructible

		if island is None:
			island = session.world.get_island(position.center)
			if island is None:
				raise _NotBuildableError(BuildableErrorTypes.NO_ISLAND)

		flat_land_found = False
		coastline_found = False
		first_coords = None
		for coords in position.tuple_iter():
			if first_coords is None:
				first_coords = coords
			# can't use get_tile_tuples since it discards None's
			tile = island.get_tile_tuple(coords)
			if tile is None:
				raise _NotBuildableError(BuildableErrorTypes.NO_ISLAND)
			if 'coastline' in tile.classes:
				coastline_found = True
			elif 'constructible' in tile.classes:
				flat_land_found = True
			elif 'constructible' not in tile.classes: # neither coastline, nor constructible
				raise _NotBuildableError(BuildableErrorTypes.UNFIT_TILE)
		if not coastline_found:
			raise _NotBuildableError(BuildableErrorTypes.NO_COAST)
		elif isinstance(position, Rect) and not flat_land_found:
			# Flat land is required but this function can be called with just a point that
			# is used to show the buildability highlight. In that case the flat land
			# requirement should be ignored.
			raise _NotBuildableError(BuildableErrorTypes.NO_FLAT_LAND)
		return island

	@classmethod
	def _check_rotation(cls, session, position, rotation):
		"""Rotate so that the building faces the seaside"""
		# array of coords (points are True if is coastline)
		coastline = {}
		x, y = position.origin.to_tuple()
		for point in position:
			if session.world.map_dimensions.contains_without_border(point):
				is_coastline = ('coastline' in session.world.get_tile(point).classes)
			else:
				is_coastline = False
			coastline[point.x-x, point.y-y] = is_coastline

		""" coastline looks something like this:
		111
		000
		000
		we have to rotate to the direction with most 1s

		Rotations:
		   45
		135   315
		   225
		"""
		coast_line_points_per_side = {
		   45: sum(coastline[(x, 0)] for x in xrange(0, cls.size[0]) ),
		  135: sum(coastline[(0, y)] for y in xrange(0, cls.size[1]) ),
		  225: sum(coastline[(x, cls.size[1] - 1)] for x in xrange(0, cls.size[0]) ),
		  315: sum(coastline[(cls.size[0] - 1, y)] for y in xrange(0, cls.size[1]) ),
		}

		# return rotation with biggest value
		maximum = -1
		rotation = -1
		for rot, val in coast_line_points_per_side.iteritems():
			if val > maximum:
				maximum = val
				rotation = rot
		return rotation


class BuildableSingleOnOcean(BuildableSingleOnCoast):
	"""Requires ocean nearby as well"""
	terrain_type = TerrainRequirement.LAND_AND_COAST_NEAR_SEA

	@classmethod
	def _check_island(cls, session, position, island=None):
		# this might raise, just let it through
		super(BuildableSingleOnOcean, cls)._check_island(session, position, island)
		if island is None:
			island = session.world.get_island(position.center)
			if island is None:
				raise _NotBuildableError(BuildableErrorTypes.NO_ISLAND)
		posis = position.get_coordinates()
		for tile in posis:
			for rad in Circle(Point(*tile), 3):
				if rad in session.world.water_body and session.world.water_body[rad] == session.world.sea_number:
					# Found legit see tile
					return island
		raise _NotBuildableError(BuildableErrorTypes.NO_OCEAN_NEARBY)


class BuildableSingleFromShip(BuildableSingleOnOcean):
	"""Buildings that can be build from a ship. Currently only Warehouse."""
	@classmethod
	def _check_settlement(cls, session, position, ship, issuer=None):
		# building from ship doesn't require settlements
		# but a ship nearby:
		if ship.position.distance(position) > BUILDINGS.BUILD.MAX_BUILDING_SHIP_DISTANCE:
			raise _NotBuildableError(BuildableErrorTypes.ONLY_NEAR_SHIP)

		for i in position:
			# and the position mustn't be owned by anyone else
			settlement = session.world.get_settlement(i)
			if settlement is not None:
				raise _NotBuildableError(BuildableErrorTypes.OTHER_PLAYERS_SETTLEMENT)

		# and player mustn't have a settlement here already
		island = session.world.get_island(position.center)
		for s in island.settlements:
			if s.owner == ship.owner:
				raise _NotBuildableError(BuildableErrorTypes.ISLAND_ALREADY_SETTLED)


class BuildableSingleOnDeposit(BuildableSingle):
	"""For mines; those buildings are only buildable upon other buildings (clay pit on clay deposit, e.g.)
	For now, mines can only be built on a single type of deposit.
	This is specified in object files, and saved in cls.buildable_on_deposit in
	the buildingclass.
	"""
	irregular_conditions = True
	terrain_type = None

	@classmethod
	def _check_buildings(cls, session, position, island=None):
		"""Check if there are buildings blocking the build"""
		if island is None:
			island = session.world.get_island(position.center)
		deposit = None
		for tile in island.get_tiles_tuple(position.tuple_iter()):
			if tile.object is None or \
			   tile.object.id != cls.buildable_on_deposit_type or \
			   (deposit is not None and tile.object != deposit): # only build on 1 deposit
				raise _NotBuildableError(BuildableErrorTypes.NEED_RES_SOURCE)
			deposit = tile.object
		return set([deposit.worldid])

	@classmethod
	def _check_rotation(cls, session, position, rotation):
		"""The rotation should be the same as the one of the underlying mountain"""
		tearset = cls._check_buildings(session, position) # will raise on problems
		# rotation fix code is only reached when building is buildable
		mountain = WorldObject.get_object_by_id(iter(tearset).next())
		return mountain.rotation


decorators.bind_all(Buildable)
decorators.bind_all(BuildableSingle)
decorators.bind_all(BuildableRect)
decorators.bind_all(BuildableSingleFromShip)
decorators.bind_all(BuildableSingleOnCoast)
decorators.bind_all(BuildableSingleOnDeposit)

########NEW FILE########
__FILENAME__ = building
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from fife import fife

from horizons.command.building import Build
from horizons.component.storagecomponent import StorageComponent
from horizons.component.componentholder import ComponentHolder
from horizons.constants import RES, LAYERS, GAME
from horizons.engine import Fife
from horizons.scheduler import Scheduler
from horizons.util.loaders.actionsetloader import ActionSetLoader
from horizons.util.python import decorators
from horizons.util.shapes import ConstRect, distances, Point
from horizons.util.worldobject import WorldObject
from horizons.world.building.buildable import BuildableSingle
from horizons.world.concreteobject import ConcreteObject
from horizons.world.settlement import Settlement


class BasicBuilding(ComponentHolder, ConcreteObject):
	"""Class that represents a building. The building class is mainly a super class for other buildings."""

	# basic properties of class
	walkable = False # whether we can walk on this building (True for e.g. streets, trees..)
	buildable_upon = False # whether we can build upon this building
	is_building = True
	tearable = True
	layer = LAYERS.OBJECTS

	log = logging.getLogger("world.building")

	"""
	@param x, y: int position of the building.
	@param rotation: value passed to getInstance
	@param owner: Player that owns the building.
	@param level: start in this tier
	@param action_set_id: use this action set id. None means choose one at random
	"""
	def __init__(self, x, y, rotation, owner, island, level=None, **kwargs):
		self.__pre_init(owner, rotation, Point(x, y), level=level)
		super(BasicBuilding, self).__init__(x=x, y=y, rotation=rotation, owner=owner,
		                                    island=island, **kwargs)
		self.__init()
		self.island = island

		settlements = self.island.get_settlements(self.position, owner)
		self.settlement = None
		if settlements:
			self.settlement = settlements[0]
		elif owner:
			# create one if we have an owner
			self.settlement = self.island.add_settlement(self.position, self.radius, owner)

		assert self.settlement is None or isinstance(self.settlement, Settlement)

	def __pre_init(self, owner, rotation, origin, level=None):
		"""Here we face the awkward situation of requiring a fourth init function.
		It is called like __init, but before other parts are inited via super().
		This is necessary since some attributes are used by these other parts."""
		self.owner = owner
		if level is None:
			level = 0 if self.owner is None else self.owner.settler_level
		self.level = level
		self.rotation = rotation
		if self.rotation in (135, 315): # Rotate the rect correctly
			self.position = ConstRect(origin, self.size[1]-1, self.size[0]-1)
		else:
			self.position = ConstRect(origin, self.size[0]-1, self.size[1]-1)

	def __init(self, remaining_ticks_of_month=None):
		self.loading_area = self.position # shape where collector get resources

		origin = self.position.origin
		self._instance, action_name = self.getInstance(self.session, origin.x, origin.y,
		    rotation=self.rotation, action_set_id=self._action_set_id, world_id=str(self.worldid))

		if self.has_running_costs: # Get payout every 30 seconds
			interval = self.session.timer.get_ticks(GAME.INGAME_TICK_INTERVAL)
			run_in = remaining_ticks_of_month if remaining_ticks_of_month is not None else interval
			Scheduler().add_new_object(self.get_payout, self,
			                           run_in=run_in, loops=-1, loop_interval=interval)

	def toggle_costs(self):
		self.running_costs, self.running_costs_inactive = \
				self.running_costs_inactive, self.running_costs

	def running_costs_active(self):
		"""Returns whether the building currently pays the running costs for status 'active'"""
		return (self.running_costs > self.running_costs_inactive)

	def get_payout(self):
		"""Gets the payout from the settlement in form of its running costs"""
		self.owner.get_component(StorageComponent).inventory.alter(RES.GOLD, -self.running_costs)

	def remove(self):
		"""Removes the building"""
		self.log.debug("building: remove %s", self.worldid)
		if hasattr(self, "disaster"):
			self.disaster.recover(self)
		self.island.remove_building(self)
		super(BasicBuilding, self).remove()
		# NOTE: removing layers from the renderer here will affect others players too!

	def save(self, db):
		super(BasicBuilding, self).save(db)
		db("INSERT INTO building (rowid, type, x, y, rotation, location, level) \
		   VALUES (?, ?, ?, ?, ?, ?, ?)",
		                                self.worldid, self.__class__.id, self.position.origin.x,
		                                self.position.origin.y, self.rotation,
		                                (self.settlement or self.island).worldid, self.level)
		if self.has_running_costs:
			remaining_ticks = Scheduler().get_remaining_ticks(self, self.get_payout)
			db("INSERT INTO remaining_ticks_of_month(rowid, ticks) VALUES(?, ?)", self.worldid, remaining_ticks)

	def load(self, db, worldid):
		self.island, self.settlement = self.load_location(db, worldid)
		x, y, location, rotation, level = db.get_building_row(worldid)
		owner_id = db.get_settlement_owner(location)
		owner = None if owner_id is None else WorldObject.get_object_by_id(owner_id)

		# early init before super() call
		self.__pre_init(owner, rotation, Point(x, y), level=level)

		super(BasicBuilding, self).load(db, worldid)

		remaining_ticks_of_month = None
		if self.has_running_costs:
			db_data = db("SELECT ticks FROM remaining_ticks_of_month WHERE rowid=?", worldid)
			if not db_data:
				# this can happen when running costs are set when there were no before
				# we shouldn't crash because of changes in yaml code, still it's suspicious
				self.log.warning('Object %s of type %s does not know when to pay its rent.\n'
					'Disregard this when loading old savegames or on running cost changes.',
					self.worldid, self.id)
				remaining_ticks_of_month = 1
			else:
				remaining_ticks_of_month = db_data[0][0]

		self.__init(remaining_ticks_of_month=remaining_ticks_of_month)


		# island.add_building handles registration of building for island and settlement
		self.island.add_building(self, self.owner, load=True)

	def load_location(self, db, worldid):
		"""
		Does not alter self, just gets island and settlement from a savegame.
		@return: tuple: (island, settlement)
		"""
		location_obj = WorldObject.get_object_by_id(db.get_building_location(worldid))
		if isinstance(location_obj, Settlement):
			# workaround: island can't be fetched from world, because it isn't fully constructed
			island = WorldObject.get_object_by_id(db.get_settlement_island(location_obj.worldid))
			settlement = location_obj
		else: # loc is island
			island = location_obj
			settlement = None
		return (island, settlement)

	def get_buildings_in_range(self):
		# TODO Think about moving this to the Settlement class
		buildings = self.settlement.buildings
		for building in buildings:
			if building is self:
				continue
			if distances.distance_rect_rect(self.position, building.position) <= self.radius:
				yield building

	def update_action_set_level(self, level=0):
		"""Updates this buildings action_set to a random actionset from the specified level
		(if an action set exists in that level).
		Its difference to get_random_action_set is that it just checks one level, and doesn't
		search for an action set everywhere, which makes it a lot more effective if you're
		just updating.
		@param level: int level number"""
		action_set = self.__class__.get_random_action_set(level, exact_level=True)
		if action_set:
			self._action_set_id = action_set  # Set the new action_set
			self.act(self._action, repeating=True)

	def level_upgrade(self, lvl):
		"""Upgrades building to another tier"""
		self.level = lvl
		self.update_action_set_level(lvl)

	@classmethod
	def get_initial_level(cls, player):
		if hasattr(cls, 'default_level_on_build'):
			return cls.default_level_on_build
		return player.settler_level

	@classmethod
	def getInstance(cls, session, x, y, action='idle', level=0, rotation=45, action_set_id=None, world_id=""):
		"""Get a Fife instance
		@param x, y: The coordinates
		@param action: The action, defaults to 'idle'
		@param level: object level. Relevant for choosing an action set
		@param rotation: rotation of the object. Any of [ 45 + 90*i for i in xrange(0, 4) ]
		@param action_set_id: can be set if the action set is already known. If set, level isn't considered.
		@return: tuple (fife_instance, action_set_id)
		"""
		assert isinstance(x, int)
		assert isinstance(y, int)
		#rotation = cls.check_build_rotation(session, rotation, x, y)
		# TODO: replace this with new buildable api
		# IDEA: save rotation in savegame
		facing_loc = fife.Location(session.view.layers[cls.layer])
		instance_coords = list((x, y, 0))
		layer_coords = list((x, y, 0))
		width, length = cls.size

		# NOTE:
		# nobody actually knows how the code below works.
		# it's for adapting the facing location and instance coords in
		# different rotations, and works with all quadratic buildings (tested up to 4x4)
		# for the first unquadratic building (2x4), a hack fix was put into it.
		# the plan for fixing this code in general is to wait until there are more
		# unquadratic buildings, and figure out a pattern of the placement error,
		# then fix that generally.

		if rotation == 45:
			layer_coords[0] = x + width + 3

			if width == 2 and length == 4:
				# HACK: fix for 4x2 buildings
				instance_coords[0] -= 1
				instance_coords[1] += 1

		elif rotation == 135:
			instance_coords[1] = y + length - 1
			layer_coords[1] = y - length - 3

			if width == 2 and length == 4:
				# HACK: fix for 4x2 buildings
				instance_coords[0] += 1
				instance_coords[1] -= 1

		elif rotation == 225:
			instance_coords = list(( x + width - 1, y + length - 1, 0))
			layer_coords[0] = x - width - 3

			if width == 2 and length == 4:
				# HACK: fix for 4x2 buildings
				instance_coords[0] += 1
				instance_coords[1] -= 1

		elif rotation == 315:
			instance_coords[0] = x + width - 1
			layer_coords[1] = y + length + 3

			if width == 2 and length == 4:
				# HACK: fix for 4x2 buildings
				instance_coords[0] += 1
				instance_coords[1] -= 1

		else:
			return None
		instance = session.view.layers[cls.layer].createInstance(
			cls._fife_object,
			fife.ModelCoordinate(*instance_coords),
			world_id)
		facing_loc.setLayerCoordinates(fife.ModelCoordinate(*layer_coords))

		if action_set_id is None:
			action_set_id = cls.get_random_action_set(level=level)
		fife.InstanceVisual.create(instance)

		action_sets = ActionSetLoader.get_sets()
		if not action in action_sets[action_set_id]:
			if 'idle' in action_sets[action_set_id]:
				action = 'idle'
			elif 'idle_full' in action_sets[action_set_id]:
				action = 'idle_full'
			else:
				# set first action
				action = action_sets[action_set_id].keys()[0]

		if (Fife.getVersion() >= (0, 3, 6)):
			instance.actRepeat(action+"_"+str(action_set_id), facing_loc)
		else:
			instance.act(action+"_"+str(action_set_id), facing_loc, True)
		return (instance, action_set_id)

	@classmethod
	def have_resources(cls, inventory_holders, owner):
		return Build.check_resources({}, cls.costs, owner, inventory_holders)[0]

	def init(self):
		"""init the building, called after the constructor is run and the
		building is positioned (the settlement variable is assigned etc)
		"""
		pass

	def start(self):
		"""This function is called when the building is built,
		to start production for example."""
		pass

	def __unicode__(self): # debug
		return u'%s(id=%s;worldid=%s)' % (self.name, self.id, getattr(self, 'worldid', 'none'))


class DefaultBuilding(BasicBuilding, BuildableSingle):
	"""Building with default properties, that does nothing."""
	pass


decorators.bind_all(BasicBuilding)

########NEW FILE########
__FILENAME__ = buildingresourcehandler
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.messaging import ResourceProduced
from horizons.world.resourcehandler import ResourceHandler
from horizons.world.production.producer import Producer


class BuildingResourceHandler(ResourceHandler):
	"""A Resourcehandler that is also a building.
	This class exists because we keep a list of all buildings, that provide something at the island.
	"""
	def __init__(self, island, **kwargs):
		super(BuildingResourceHandler, self).__init__(island=island, **kwargs)
		self.island = island

	def initialize(self):
		super(BuildingResourceHandler, self).initialize()
		self.__init()

	def __init(self):
		self.island.provider_buildings.append(self)
		if self.has_component(Producer):
			self.get_component(Producer).add_activity_changed_listener(self._set_running_costs_to_status)
			self.get_component(Producer).add_production_finished_listener(self.on_production_finished)
			self._set_running_costs_to_status(None, self.get_component(Producer).is_active())

	def load(self, db, worldid):
		super(BuildingResourceHandler, self).load(db, worldid)
		self.__init()

	def remove(self):
		super(BuildingResourceHandler, self).remove()
		self.island.provider_buildings.remove(self)
		if self.has_component(Producer):
			self.get_component(Producer).remove_activity_changed_listener(self._set_running_costs_to_status)
			self.get_component(Producer).remove_production_finished_listener(self.on_production_finished)

	def on_production_finished(self, caller, resources):
		if self.is_valid_tradable_resource(resources):
			ResourceProduced.broadcast(self, caller, resources)

	def is_valid_tradable_resource(self, resources):
		""" Checks if the produced resource tradable (can be carried by collectors).
		"""
		if not resources or not resources.keys():
			return False

		return resources.keys()[0] in \
		       self.island.session.db.get_res(only_tradeable=True, only_inventory=True)

	def _set_running_costs_to_status(self, caller, activate):
		currently_active = self.running_costs_active()
		if (currently_active and not activate) or (not currently_active and activate):
			self.toggle_costs()
			self._changed()


class UnitProducerBuilding(BuildingResourceHandler):
	"""Class for building that produce units.
	Uses a BuildingResourceHandler additionally to ResourceHandler to enable
	building specific behavior."""
	pass

########NEW FILE########
__FILENAME__ = nature
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.building.building import BasicBuilding
from horizons.world.building.buildable import BuildableRect, BuildableSingleEverywhere
from horizons.world.building.buildingresourcehandler import BuildingResourceHandler
from horizons.entities import Entities
from horizons.scheduler import Scheduler
from horizons.constants import LAYERS, BUILDINGS
from horizons.world.production.producer import Producer

class NatureBuilding(BuildableRect, BasicBuilding):
	"""Class for objects that are part of the environment, the nature"""
	walkable = True
	layer = LAYERS.OBJECTS

class NatureBuildingResourceHandler(BuildingResourceHandler, NatureBuilding):
	# sorry, but this class is to be removed soon anyway
	pass

class Field(NatureBuildingResourceHandler):
	walkable = False
	layer = LAYERS.FIELDS

	def initialize(self, **kwargs):
		super(Field, self).initialize(**kwargs)

		if self.owner.is_local_player:
			# make sure to have a farm nearby when we can reasonably assume that the crops are fully grown
			prod_comp = self.get_component(Producer)
			productions = prod_comp.get_productions()
			if not productions:
				print "Warning: Field is assumed to always produce, but doesn't.", self
			else:
				run_in = Scheduler().get_ticks(productions[0].get_production_time())
				Scheduler().add_new_object(self._check_covered_by_farm, self, run_in=run_in)

	def _check_covered_by_farm(self):
		"""Warn in case there is no farm nearby to cultivate the field"""
		farm_in_range = any( (farm.position.distance( self.position ) <= farm.radius) for farm in
		                     self.settlement.buildings_by_id[BUILDINGS.FARM] )
		if not farm_in_range and self.owner.is_local_player:
			pos = self.position.origin
			self.session.ingame_gui.message_widget.add(point=pos, string_id="FIELD_NEEDS_FARM",
			                                           check_duplicate=True)


class Tree(NatureBuildingResourceHandler):
	buildable_upon = True
	layer = LAYERS.OBJECTS

class ResourceDeposit(NatureBuilding):
	"""Class for stuff like clay deposits."""
	tearable = False
	layer = LAYERS.OBJECTS
	walkable = False

class Fish(BuildableSingleEverywhere, BuildingResourceHandler, BasicBuilding):
	def __init__(self, *args, **kwargs):
		super(Fish, self).__init__(*args, **kwargs)
		self.last_usage_tick = -1000000 # a long time ago

		# Make the fish run at different speeds
		multiplier = 0.7 + self.session.random.random() * 0.6
		self._instance.setTimeMultiplier(multiplier)

	def load(self, db, worldid):
		super(Fish, self).load(db, worldid)
		self.last_usage_tick = db.get_last_fish_usage_tick(worldid)

	def save(self, db):
		super(Fish, self).save(db)
		translated_tick = self.last_usage_tick - Scheduler().cur_tick # pre-translate for the loading process
		db("INSERT INTO fish_data(rowid, last_usage_tick) VALUES(?, ?)", self.worldid, translated_tick)

	def remove_incoming_collector(self, collector):
		super(Fish, self).remove_incoming_collector(collector)
		self.last_usage_tick = Scheduler().cur_tick

########NEW FILE########
__FILENAME__ = path
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife

from horizons.constants import LAYERS, BUILDINGS
from horizons.world.building.building import BasicBuilding
from horizons.world.building.buildable import BuildableLine
from horizons.scheduler import Scheduler
from horizons.component.componentholder import ComponentHolder


class Path(ComponentHolder):
	"""Object with path functionality"""
	walkable = True

	# no __init__

	def load(self, db, worldid):
		super(Path, self).load(db, worldid)

	def init(self):
		# this does not belong in __init__, it's just here that all the data should be consistent
		self.__init()

	def __init(self):
		self.island.path_nodes.register_road(self)
		if self.session.world.inited:
			self.recalculate_surrounding_tile_orientation()
			self.recalculate_orientation()
		else:
			# don't always recalculate while loading, we'd recalculate too often.
			# do it once when everything is finished.
			Scheduler().add_new_object(self.recalculate_orientation, self, run_in=0)

	def remove(self):
		super(Path, self).remove()
		self.island.path_nodes.unregister_road(self)
		self.recalculate_surrounding_tile_orientation()

	def recalculate_surrounding_tile_orientation(self):
		for tile in self.island.get_surrounding_tiles(self.position):
			if tile is not None and tile.object is not None and \
			   self.island.path_nodes.is_road(tile.x, tile.y):
				tile.object.recalculate_orientation()

	def recalculate_orientation(self):
		"""
		ROAD ORIENTATION CHEATSHEET
		===========================
		a       b
		 \  e  /     a,b,c,d are connections to nearby roads
		  \   /
		   \ /       e,f,g,h indicate whether this area occupies more space than
		 h  X  f     a single road would (i.e. whether we should fill this three-
		   / \       cornered space with graphics that will make it look like a
		  /   \      coherent square instead of many short-circuit road circles).
		 /  g  \     Note that 'e' can only be placed if both 'a' and 'b' exist.
		d       c

		SAMPLE ROADS
		============
		\     \     \..../  \    /    \    /
		 \    .\     \../    \  /.     \  /.
		  \   ..\     \/      \/..      \/..
		  /   ../     /         ..      /\..
		 /    ./     /           .     /..\.
		/     /     /                 /....\

		ad    adh   abde   abf (im-   abcdfg
		                   possible)
		"""
		action = ''
		origin = self.position.origin
		path_nodes = self.island.path_nodes

		# Order is important here.
		ordered_actions = sorted(BUILDINGS.ACTION.action_offset_dict.iteritems())
		for action_part, (xoff, yoff) in ordered_actions:
			tile = self.island.get_tile(origin.offset(xoff, yoff))
			if tile is None or tile.object is None:
				continue
			if not path_nodes.is_road(tile.x, tile.y):
				continue
			if self.owner != tile.object.owner:
				continue
			if action_part in 'abcd':
				action += action_part
			if action_part in 'efgh':
				# Now check whether we can place valid road-filled areas.
				# Only adds 'g' to action if both 'c' and 'd' are in already
				# (that's why order matters - we need to know at this point)
				# and the condition for 'g' is met: road tiles exist in that
				# direction.
				fill_left = chr(ord(action_part) - 4) in action
				# 'h' has the parents 'd' and 'a' (not 'e'), so we need a slight hack here.
				fill_right = chr(ord(action_part) - 3 - 4*(action_part=='h')) in action
				if fill_left and fill_right:
					action += action_part
		if action == '':
			# Single trail piece with no neighbor road tiles.
			action = 'single'

		location = self._instance.getLocation()
		location.setLayerCoordinates(fife.ModelCoordinate(int(origin.x + 1), int(origin.y), 0))
		self.act(action, location, True)

class Road(Path, BasicBuilding, BuildableLine):
	"""Actual buildable road."""
	layer = LAYERS.FIELDS
########NEW FILE########
__FILENAME__ = production
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from horizons.world.building.buildingresourcehandler import BuildingResourceHandler
from horizons.world.building.building import BasicBuilding
from horizons.world.building.buildable import BuildableSingle, BuildableSingleOnCoast, BuildableSingleOnDeposit, BuildableSingleOnOcean
from horizons.world.building.nature import Field
from horizons.util.shapes import Rect, RadiusRect
from horizons.command.building import Build
from horizons.scheduler import Scheduler
from horizons.constants import BUILDINGS, PRODUCTION
from horizons.world.production.producer import Producer
from horizons.component.storagecomponent import StorageComponent


class ProductionBuilding(BuildingResourceHandler, BuildableSingle, BasicBuilding):
	pass


class PastryShop(ProductionBuilding):
	def get_providers(self):
		reach = RadiusRect(self.position, self.radius)
		resources = self.get_consumed_resources(include_inactive=True)
		providers = self.island.get_providers_in_range(reach, reslist=resources)
		return [provider for provider in providers]


class Farm(ProductionBuilding):
	def get_providers(self):
		reach = RadiusRect(self.position, self.radius)
		resources = self.get_consumed_resources(include_inactive=True)
		providers = self.island.get_providers_in_range(reach, reslist=resources)
		return [provider for provider in providers if isinstance(provider, Field)]


class CoastalProducer(BuildingResourceHandler, BuildableSingleOnOcean, BasicBuilding):
	"""E.g. salt ponds"""
	pass


class Fisher(BuildingResourceHandler, BuildableSingleOnCoast, BasicBuilding):
	"""
	Old selection workaround (only color fish) removed in b69c72aeef0174c42dec4039eed7b81f96f6dcaa.
	"""

	def get_non_paused_utilization(self):
		total = 0
		productions = self.get_component(Producer).get_productions()
		for production in productions:
			if production.get_age() < PRODUCTION.STATISTICAL_WINDOW * 1.5:
				return 1
			state_history = production.get_state_history_times(True)
			total += state_history[PRODUCTION.STATES.producing.index]
		return total / float(len(productions))


class Mine(BuildingResourceHandler, BuildableSingleOnDeposit, BasicBuilding):
	def __init__(self, inventory, deposit_class, *args, **kwargs):
		"""
		@param inventory: inventory dump of deposit (collected by get_prebuild_data())
		@param deposit_class: class num of deposit for later reconstruction (collected by get_prebuild_data())
		"""
		# needs to be inited before super(), since that will call the _on_production_changed hook
		super(Mine, self).__init__(*args, **kwargs)
		self.__inventory = inventory
		self.__deposit_class = deposit_class

	def initialize(self, deposit_class, inventory, **kwargs):
		super(Mine, self).initialize(**kwargs)
		self.__init(deposit_class=deposit_class)
		for res, amount in inventory.iteritems():
			# bury resources from mountain in mine
			self.get_component(StorageComponent).inventory.alter(res, amount)

	@classmethod
	def get_loading_area(cls, building_id, rotation, pos):
		if building_id == BUILDINGS.MOUNTAIN or building_id == BUILDINGS.MINE:
			if rotation == 45:
				return Rect.init_from_topleft_and_size(pos.origin.x, pos.origin.y + 1, 1, 3)
			elif rotation == 135:
				return Rect.init_from_topleft_and_size(pos.origin.x + 1, pos.origin.y + pos.height - 1, 3, 1)
			elif rotation == 225:
				return Rect.init_from_topleft_and_size(pos.origin.x + pos.width -1, pos.origin.y + 1, 1, 3)
			elif rotation == 315:
				return Rect.init_from_topleft_and_size(pos.origin.x + 1, pos.origin.y, 3, 1)
			assert False
		else:
			return pos

	def __init(self, deposit_class):
		self.__deposit_class = deposit_class

		# setup loading area
		# TODO: for now we assume that a mine building is 5x5 with a 3x1 entry on 1 side
		#       this needs to be generalized, possibly by defining the loading tiles in the db
		self.loading_area = self.get_loading_area(deposit_class, self.rotation, self.position)

	@classmethod
	def get_prebuild_data(cls, session, position):
		"""Returns dict containing inventory of deposit, which is needed for the mine build"""
		deposit = session.world.get_building(position.center)
		data = {}
		data["inventory"] = deposit.get_component(StorageComponent).inventory.get_dump()
		data["deposit_class"] = deposit.id
		return data

	def remove(self):
		# build the deposit back here after remove() is finished
		deposit_build_data = { 'inventory' : self.get_component(StorageComponent).inventory.get_dump() }
		build_cmd = Build(self.__deposit_class, self.position.origin.x, self.position.origin.y,
		                  self.island, rotation=self.rotation, ownerless=True, data=deposit_build_data)
		Scheduler().add_new_object(build_cmd, build_cmd, run_in=0)

		super(Mine, self).remove()

	def save(self, db):
		super(Mine, self).save(db)
		db("INSERT INTO mine(rowid, deposit_class) VALUES(?, ?)",
		   self.worldid, self.__deposit_class)

	def load(self, db, worldid):
		super(Mine, self).load(db, worldid)
		deposit_class = db("SELECT deposit_class FROM mine WHERE rowid = ?", worldid)[0][0]
		self.__init(deposit_class)

########NEW FILE########
__FILENAME__ = settler
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import math

from horizons.scheduler import Scheduler

from horizons.gui.tabs import SettlerOverviewTab
from horizons.world.building.building import BasicBuilding
from horizons.world.building.buildable import BuildableRect, BuildableSingle
from horizons.constants import RES, BUILDINGS, GAME, TIER
from horizons.world.building.buildingresourcehandler import BuildingResourceHandler
from horizons.world.production.production import SettlerProduction
from horizons.command.building import Build
from horizons.util.python.callback import Callback
from horizons.util.pathfinding.pather import StaticPather
from horizons.command.production import ToggleActive
from horizons.component.storagecomponent import StorageComponent
from horizons.world.status import SettlerUnhappyStatus, SettlerNotConnectedStatus
from horizons.world.production.producer import Producer
from horizons.messaging import AddStatusIcon, RemoveStatusIcon, SettlerUpdate, SettlerInhabitantsChanged, UpgradePermissionsChanged


class SettlerRuin(BasicBuilding, BuildableSingle):
	"""Building that appears when a settler got unhappy. The building does nothing.

	NOTE: Inheriting from BuildableSingle is necessary, cause it's built via Build Command, which
	checks for buildability
	"""
	buildable_upon = True
	walkable = True


class Settler(BuildableRect, BuildingResourceHandler, BasicBuilding):
	"""Represents a settlers house, that uses resources and creates inhabitants."""
	log = logging.getLogger("world.building.settler")

	production_class = SettlerProduction

	tabs = (SettlerOverviewTab, )

	default_level_on_build = 0

	def __init__(self, x, y, owner, instance=None, **kwargs):
		kwargs['level'] = self.__class__.default_level_on_build # settlers always start in first level
		super(Settler, self).__init__(x=x, y=y, owner=owner, instance=instance, **kwargs)

	def __init(self, loading=False, last_tax_payed=0):
		self.level_max = TIER.CURRENT_MAX # for now
		self._update_level_data(loading=loading, initial=True)
		self.last_tax_payed = last_tax_payed
		UpgradePermissionsChanged.subscribe(self._on_change_upgrade_permissions, sender=self.settlement)
		self._upgrade_production = None # referenced here for quick access

	def initialize(self):
		super(Settler, self).initialize()
		SettlerInhabitantsChanged.broadcast(self, self.inhabitants)
		happiness = self.__get_data("happiness_init_value")
		if happiness is not None:
			self.get_component(StorageComponent).inventory.alter(RES.HAPPINESS, happiness)
		if self.has_status_icon:
			self.get_component(StorageComponent).inventory.add_change_listener( self._update_status_icon )
		# give the user a month (about 30 seconds) to build a main square in range
		if self.owner.is_local_player:
			Scheduler().add_new_object(self._check_main_square_in_range, self, Scheduler().get_ticks_of_month(), loops=-1)
		self.__init()
		self.run()

	def save(self, db):
		super(Settler, self).save(db)
		db("INSERT INTO settler(rowid, inhabitants, last_tax_payed) VALUES (?, ?, ?)",
		   self.worldid, self.inhabitants, self.last_tax_payed)
		remaining_ticks = Scheduler().get_remaining_ticks(self, self._tick)
		db("INSERT INTO remaining_ticks_of_month(rowid, ticks) VALUES (?, ?)",
		   self.worldid, remaining_ticks)

	def load(self, db, worldid):
		super(Settler, self).load(db, worldid)
		self.inhabitants, last_tax_payed = \
		    db("SELECT inhabitants, last_tax_payed FROM settler WHERE rowid=?", worldid)[0]
		remaining_ticks = \
		    db("SELECT ticks FROM remaining_ticks_of_month WHERE rowid=?", worldid)[0][0]
		self.__init(loading=True, last_tax_payed=last_tax_payed)
		self._load_upgrade_data(db)
		SettlerUpdate.broadcast(self, self.level, self.level)
		self.run(remaining_ticks)

	def _load_upgrade_data(self, db):
		"""Load the upgrade production and relevant stored resources"""
		upgrade_material_prodline = SettlerUpgradeData.get_production_line_id(self.level+1)
		if not self.get_component(Producer).has_production_line(upgrade_material_prodline):
			return

		self._upgrade_production = self.get_component(Producer)._get_production(upgrade_material_prodline)

		# readd the res we already had, they can't be loaded since storage slot limits for
		# the special resources aren't saved
		resources = {}
		for resource, amount in db.get_storage_rowids_by_ownerid(self.worldid):
			resources[resource] = amount

		for res, amount in self._upgrade_production.get_consumed_resources().iteritems():
			# set limits to what we need
			self.get_component(StorageComponent).inventory.add_resource_slot(res, abs(amount))
			if res in resources:
				self.get_component(StorageComponent).inventory.alter(res, resources[res])

		self._upgrade_production.add_production_finished_listener(self.level_up)
		self.log.debug("%s: Waiting for material to upgrade from %s", self, self.level)

	def _add_upgrade_production_line(self):
		"""
		Add a production line that gets the necessary upgrade material.
		When the production finishes, it calls upgrade_materials_collected.
		"""
		upgrade_material_prodline = SettlerUpgradeData.get_production_line_id(self.level+1)
		self._upgrade_production = self.get_component(Producer).add_production_by_id( upgrade_material_prodline )
		self._upgrade_production.add_production_finished_listener(self.level_up)

		# drive the car out of the garage to make space for the building material
		for res, amount in self._upgrade_production.get_consumed_resources().iteritems():
			self.get_component(StorageComponent).inventory.add_resource_slot(res, abs(amount))

		self.log.debug("%s: Waiting for material to upgrade from %s", self, self.level)



	def remove(self):
		SettlerInhabitantsChanged.broadcast(self, -self.inhabitants)

		UpgradePermissionsChanged.unsubscribe(self._on_change_upgrade_permissions, sender=self.settlement)
		super(Settler, self).remove()

	@property
	def upgrade_allowed(self):
		return self.session.world.get_settlement(self.position.origin).upgrade_permissions[self.level]

	def _on_change_upgrade_permissions(self, message):
		production = self._upgrade_production
		if production is not None:
			if production.is_paused() == self.upgrade_allowed:
				ToggleActive(self.get_component(Producer), production).execute(self.session, True)

	@property
	def happiness(self):
		difficulty = self.owner.difficulty
		result = int(round(difficulty.extra_happiness_constant + self.get_component(StorageComponent).inventory[RES.HAPPINESS] * difficulty.happiness_multiplier))
		return max(0, min(result, self.get_component(StorageComponent).inventory.get_limit(RES.HAPPINESS)))

	@property
	def capacity_utilization(self):
		# this concept does not make sense here, so spare us the calculations
		return 1.0

	def _update_level_data(self, loading=False, initial=False):
		"""Updates all settler-related data because of a level change or as initialization
		@param loading: whether called to set data after loading
		@param initial: whether called to set data initially
		"""
		# taxes, inhabitants
		self.tax_base = self.session.db.get_settler_tax_income(self.level)
		self.inhabitants_max = self.session.db.get_tier_inhabitants_max(self.level)
		self.inhabitants_min = self.session.db.get_tier_inhabitants_min(self.level)
		#TODO This crops inhabitants at level down, but when can they exceed the limit?
		if self.inhabitants > self.inhabitants_max:
			self.inhabitants = self.inhabitants_max

		# consumption:
		# Settler productions are specified to be disabled by default in the db, so we can enable
		# them here per level. Production data is save/loaded, so we don't need to do anything in that case
		if not loading:
			prod_comp = self.get_component(Producer)
			current_lines = prod_comp.get_production_lines()
			for prod_line in prod_comp.get_production_lines_by_level(self.level):
				if not prod_comp.has_production_line(prod_line):
					prod_comp.add_production_by_id(prod_line)
				# cross out the new lines from the current lines, so only the old ones remain
				if prod_line in current_lines:
					current_lines.remove(prod_line)
			for line in current_lines[:]: # iterate over copy for safe removal
				# all lines, that were added here but are not used due to the current level
				# NOTE: this contains the upgrade material production line
				prod_comp.remove_production_by_id(line)
				# Make sure to set _upgrade_production to None in case we are removing it
				if self._upgrade_production is not None and line == self._upgrade_production.get_production_line_id():
					self._upgrade_production = None

		if not initial:
			# update instance graphics
			# only do it when something has actually change

			# TODO: this probably also isn't necessary on loading, but it's
			# not touched before the relase (2012.1)
			self.update_action_set_level(self.level)

	def run(self, remaining_ticks=None):
		"""Start regular tick calls"""
		interval = self.session.timer.get_ticks(GAME.INGAME_TICK_INTERVAL)
		run_in = remaining_ticks if remaining_ticks is not None else interval
		Scheduler().add_new_object(self._tick, self, run_in=run_in, loops=-1, loop_interval=interval)

	def _tick(self):
		"""Here we collect the functions, that are called regularly (every "month")."""
		self.pay_tax()
		self.inhabitant_check()
		self.level_check()

	def pay_tax(self):
		"""Pays the tax for this settler"""
		# the money comes from nowhere, settlers seem to have an infinite amount of money.
		# see http://wiki.unknown-horizons.org/w/Settler_taxing

		# calc taxes http://wiki.unknown-horizons.org/w/Settler_taxing#Formulae
		happiness_tax_modifier = 0.5 + (float(self.happiness)/70.0)
		inhabitants_tax_modifier = float(self.inhabitants) / self.inhabitants_max
		taxes = self.tax_base * self.settlement.tax_settings[self.level] *  happiness_tax_modifier * inhabitants_tax_modifier
		real_taxes = int(round(taxes * self.owner.difficulty.tax_multiplier))

		self.settlement.owner.get_component(StorageComponent).inventory.alter(RES.GOLD, real_taxes)
		self.last_tax_payed = real_taxes

		# decrease happiness http://wiki.unknown-horizons.org/w/Settler_taxing#Formulae
		difference = 1.0 - self.settlement.tax_settings[self.level]
		happiness_decrease = 10 * difference - 6* abs(difference)
		happiness_decrease = int(round(happiness_decrease))
		# NOTE: this formula was actually designed for a different use case, where the happiness
		# is calculated from the number of available goods -/+ a certain tax factor.
		# to simulate the more dynamic, currently implemented approach (where every event changes
		# the happiness), we simulate discontent of taxes by this:
		happiness_decrease -= 6
		self.get_component(StorageComponent).inventory.alter(RES.HAPPINESS, happiness_decrease)
		self._changed()
		self.log.debug("%s: pays %s taxes, -happy: %s new happiness: %s", self, real_taxes,
									 happiness_decrease, self.happiness)

	def inhabitant_check(self):
		"""Checks whether or not the population of this settler should increase or decrease"""
		sad = self.session.db.get_lower_happiness_limit()
		happy = self.session.db.get_upper_happiness_limit()
		change = 0
		if self.happiness > happy and self.inhabitants < self.inhabitants_max:
			change = 1
			self.log.debug("%s: inhabitants increase to %s", self, self.inhabitants)
		elif self.happiness < sad and self.inhabitants > 1:
			change = -1
			self.log.debug("%s: inhabitants decrease to %s", self, self.inhabitants)

		if change != 0:
			# see http://wiki.unknown-horizons.org/w/Supply_citizens_with_resources
			self.get_component(Producer).alter_production_time( 6.0/7.0 * math.log( 1.5 * (self.inhabitants + 1.2) ) )
			self.inhabitants += change
			SettlerInhabitantsChanged.broadcast(self, change)
			self._changed()

	def can_level_up(self):
		return self.happiness > self.__get_data("happiness_level_up_requirement") and \
		   self.inhabitants >= self.inhabitants_min and not self._has_disaster()

	def level_check(self):
		"""Checks whether we should level up or down.

		Ignores buildings with a active disaster. """
		if self.can_level_up():
			if self.level >= self.level_max:
				# max level reached already, can't allow an update
				if self.owner.max_tier_notification < self.level_max:
					if self.owner.is_local_player:
						self.session.ingame_gui.message_widget.add(
							point=self.position.center, string_id='MAX_TIER_REACHED')
					self.owner.max_tier_notification = self.level_max
				return
			if self._upgrade_production:
				return # already waiting for res

			self._add_upgrade_production_line()

			if not self.upgrade_allowed:
				ToggleActive(self.get_component(Producer), self._upgrade_production).execute(self.session, True)

		elif self.happiness < self.__get_data("happiness_level_down_limit") or \
		     self.inhabitants < self.inhabitants_min:
			self.level_down()
			self._changed()

	def level_up(self, production=None):
		"""Actually level up (usually called when the upgrade material has arrived)"""

		self._upgrade_production = None

		# just level up later that tick, it could disturb other code higher in the call stack

		def _do_level_up():
			self.level += 1
			self.log.debug("%s: Levelling up to %s", self, self.level)
			self._update_level_data()

			# Notify the world about the level up
			SettlerUpdate.broadcast(self, self.level, 1)

			# reset happiness value for new level
			new_happiness = self.__get_data("happiness_init_value") - self.happiness
			self.get_component(StorageComponent).inventory.alter(RES.HAPPINESS, new_happiness)
			self._changed()

		Scheduler().add_new_object(_do_level_up, self, run_in=0)

	def level_down(self):
		if self.level == TIER.LOWEST:
			# Can't level down any more.
			self.make_ruin()
			self.log.debug("%s: Destroyed by lack of happiness", self)
			if self.owner.is_local_player:
				# check_duplicate: only trigger once for different settlers of a neighborhood
				self.session.ingame_gui.message_widget.add(point=self.position.center,
			                                           string_id='SETTLERS_MOVED_OUT', check_duplicate=True)
		else:
			self.level -= 1
			self._update_level_data()
			# reset happiness value for new level
			new_happiness = self.__get_data("happiness_init_value") - self.happiness
			self.get_component(StorageComponent).inventory.alter(RES.HAPPINESS, new_happiness)
			self.log.debug("%s: Level down to %s", self, self.level)
			self._changed()

			# Notify the world about the level down
			SettlerUpdate.broadcast(self, self.level, -1)

	def make_ruin(self):
		""" Replaces itself with a ruin.
		"""
		command = Build(BUILDINGS.SETTLER_RUIN, self.position.origin.x,
		                self.position.origin.y, island=self.island, settlement=self.settlement)

		# Remove the building and then place the Ruin
		Scheduler().add_new_object(Callback.ChainedCallbacks(
			self.remove, Callback(command, self.owner)), self, run_in=0)

	def _has_disaster(self):
		return hasattr(self, "disaster") and self.disaster

	def _check_main_square_in_range(self):
		"""Notifies the user via a message in case there is no main square in range"""
		if not self.owner.is_local_player:
			return # only check this for local player
		for building in self.get_buildings_in_range():
			if building.id == BUILDINGS.MAIN_SQUARE:
				if StaticPather.get_path_on_roads(self.island, self, building) is not None:
					# a main square is in range
					if hasattr(self, "_main_square_status_icon"):
						RemoveStatusIcon.broadcast(self, self, SettlerNotConnectedStatus)
						del self._main_square_status_icon
					return
		if not hasattr(self, "_main_square_status_icon"):
			self._main_square_status_icon = SettlerNotConnectedStatus(self) # save ref for removal later
			AddStatusIcon.broadcast(self, self._main_square_status_icon)
		# no main square found
		# check_duplicate: only trigger once for different settlers of a neighborhood
		self.session.ingame_gui.message_widget.add(point=self.position.origin,
		                                           string_id='NO_MAIN_SQUARE_IN_RANGE', check_duplicate=True)

	def level_upgrade(self, lvl):
		"""Settlers only level up by themselves"""
		pass

	def _update_status_icon(self):
		if self.has_status_icon:
			unhappy = self.happiness < self.__get_data("happiness_inhabitants_decrease_limit")
			# check for changes
			if unhappy and not hasattr(self, "_settler_status_icon"):
				self._settler_status_icon = SettlerUnhappyStatus(self) # save ref for removal later
				AddStatusIcon.broadcast(self, self._settler_status_icon)
			if not unhappy and hasattr(self, "_settler_status_icon"):
				RemoveStatusIcon.broadcast(self, self, SettlerUnhappyStatus)
				del self._settler_status_icon

	def __str__(self):
		try:
			return "%s(l:%s;ihab:%s;hap:%s)" % (super(Settler, self).__str__(), self.level,
			                                    self.inhabitants, self.happiness)
		except AttributeError: # an attribute hasn't been set up
			return super(Settler, self).__str__()

	#@decorators.cachedmethod TODO: replace this with a version that doesn't leak
	def __get_data(self, key):
		"""Returns constant settler-related data from the db.
		The values are cached by python, so the underlying data must not change."""
		return int(
		  self.session.db("SELECT value FROM balance_values WHERE name = ?", key)[0][0]
		  )



class SettlerUpgradeData(object):
	"""This is used as glue between the old upgrade system based on sqlite data used in a non-component environment
	and the current component version with data in yaml"""

	# basically, this is arbitrary as long as it's not the same as any of the regular
	# production lines of the settler. We reuse data that has arbitrarily been set earlier
	# to preserve savegame compatibility.
	production_line_ids = { 1 : 24, 2 : 35, 3: 23451, 4: 34512, 5: 45123 }

	def __init__(self, producer_component, upgrade_material_data):
		self.upgrade_material_data = upgrade_material_data

	def get_production_lines(self):
		d = {}
		for level, prod_line_id in self.__class__.production_line_ids.iteritems():
			d[prod_line_id] = self.get_production_line_data(level)
		return d

	def get_production_line_data(self, level):
		"""Returns production line data for the upgrade to this level"""
		prod_line_data = {
		  'time': 1,
		  'changes_animation' : 0,
		  'enabled_by_default' : False,
		  'save_statistics' : False,
		  'consumes' : self.upgrade_material_data[level]
		}
		return prod_line_data

	@classmethod
	def get_production_line_id(cls, level):
		"""Returns production line id for the upgrade to this level"""
		return cls.production_line_ids[level]


########NEW FILE########
__FILENAME__ = storages
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.resourcehandler import StorageResourceHandler
from horizons.world.building.buildingresourcehandler import BuildingResourceHandler
from horizons.world.building.building import BasicBuilding
from horizons.world.building.buildable import BuildableSingle, BuildableSingleFromShip
from horizons.component.storagecomponent import StorageComponent
from horizons.world.building.production import ProductionBuilding
from horizons.world.building.path import Path
from horizons.world.status import InventoryFullStatus
from horizons.component.collectingcomponent import CollectingComponent

class StorageBuilding(StorageResourceHandler,
                      BuildingResourceHandler, BasicBuilding):
	"""Building that gets pickups and provides them for anyone.
	Inherited eg. by warehouse, storage tent.
	These objects don't have a storage themselves, but use the settlement storage.
	"""
	def __init__(self, x, y, owner, instance=None, **kwargs):
		super(StorageBuilding, self).__init__(x=x, y=y, owner=owner, instance=instance, **kwargs)

	def initialize(self):
		super(StorageBuilding, self).initialize()
		self.get_component(StorageComponent).inventory.add_change_listener(self._changed)
		# add limit, it will be saved so don't set on load()
		inv = self.get_component(StorageComponent).inventory
		inv.adjust_limit(self.session.db.get_storage_building_capacity(self.id))

	def remove(self):
		inv = self.get_component(StorageComponent).inventory
		inv.remove_change_listener(self._changed)
		inv.adjust_limit(-self.session.db.get_storage_building_capacity(self.id))
		super(StorageBuilding, self).remove()

	def load(self, db, worldid):
		super(StorageBuilding, self).load(db, worldid)
		# limit will be save/loaded by the storage, don't do anything here
		self.get_component(StorageComponent).inventory.add_change_listener(self._changed)

	def get_utilization_history_length(self):
		collecting_comp = self.get_component(CollectingComponent)
		if collecting_comp.get_local_collectors():
			return collecting_comp.get_local_collectors()[0].get_utilization_history_length()

	def get_collector_utilization(self):
		collectors = self.get_component(CollectingComponent).get_local_collectors()
		if not collectors:
			return None
		return sum(collector.get_utilization() for collector in collectors) / float(len(collectors))

class StorageTent(StorageBuilding, BuildableSingle):
	"""Can't inherit from Buildable* in StorageBuilding because of mro issues."""
	pass

class Warehouse(StorageBuilding, BuildableSingleFromShip):
	tearable = False
	def __init__(self, *args, **kwargs):
		super(Warehouse, self).__init__(*args, **kwargs)
		self.settlement.warehouse = self
		# we never need to unset this since warehouses are indestructible
		# settlement warehouse setting is done at the settlement for loading

	def get_status_icons(self):
		banned_classes = (InventoryFullStatus,)
		return [ i for i in super(Warehouse, self).get_status_icons() if
		         not i.__class__ in banned_classes ]

class MainSquare(Path, StorageBuilding, ProductionBuilding):
	walkable = True

	def recalculate_orientation(self):
		# change gfx according to roads here
		pass

	def _load_provided_resources(self):
		"""Storages provide every res.
		"""
		return self.session.db.get_res(only_tradeable=False)

########NEW FILE########
__FILENAME__ = war
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.building.buildable import BuildableSingle
from horizons.world.building.building import BasicBuilding

from horizons.world.units.weaponholder import StationaryWeaponHolder
from horizons.constants import WEAPONS

class Tower(BuildableSingle, StationaryWeaponHolder, BasicBuilding):

	POSSIBLE_WEAPONS = [ WEAPONS.CANNON ]

	def __init__(self, *args, **kwargs):
		super(Tower, self).__init__(*args, **kwargs)
		# apply cannons already paid for
		for weapon_type in self.__class__.POSSIBLE_WEAPONS:
			for i in xrange(self.costs.get(weapon_type, 0)):
				self.add_weapon_to_storage(weapon_type)

	def fire_all_weapons(self, dest, rotate=True):
		super(Tower, self).fire_all_weapons(dest, rotate)

	def update_range(self, caller=None):
		self._fix_weapon_range()
		super(Tower, self).update_range(caller=caller)

	def _fix_weapon_range(self):
		"""Set all min weapon ranges to 0.
		Since the tower can't move, melee units could just approach it and
		destroy the tower"""
		for weapon in self._weapon_storage:
			weapon.weapon_range = (0, weapon.weapon_range[1])
########NEW FILE########
__FILENAME__ = buildingowner
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.providerhandler import ProviderHandler
from horizons.util.python import decorators
from horizons.util.shapes import Point, RadiusRect

"""
Simple building management functionality.
Inherited mainly by Island, but also by World for buildings at sea such as fish.
Island adds more functionality to these functions (e.g. settlement handling),
this implementation can be viewed as the the common denominator of building handling
required by World and Island.
The instances need to provide a get_tile function.
"""
class BuildingOwner(object):
	def __init__(self, *args, **kwargs):
		super(BuildingOwner, self).__init__(*args, **kwargs)
		self.provider_buildings = ProviderHandler()
		self.buildings = []

	def add_building(self, building, player, load=False):
		"""Adds a building to the island at the position x, y with player as the owner.
		@param building: Building class instance of the building that is to be added.
		@param player: int id of the player that owns the settlement"""
		# Set all tiles in the buildings position(rect)
		for point in building.position:
			tile = self.get_tile(point)
			tile.blocked = True # Set tile blocked
			tile.object = building # Set tile's object to the building
		self.buildings.append(building)
		building.init()
		return building

	def remove_building(self, building):
		assert building.island == self

		# Reset the tiles this building was covering
		for point in building.position:
			tile = self.get_tile(point)
			tile.blocked = False
			tile.object = None

		# Remove this building from the buildings list
		self.buildings.remove(building)
		assert building not in self.buildings

	def get_settlements(self, rect, player=None):
		"""Returns the list of settlements for the coordinates describing a rect.
		@param rect: Area to search for settlements
		@return: list of Settlement instances at that position."""
		settlements = set()
		for point in rect:
			try:
				if player is None or self.get_tile(point).settlement.owner == player:
					settlements.add( self.get_tile(point).settlement )
			except AttributeError:
				# some tiles don't have settlements, we don't explicitly check for them cause
				# its faster this way.
				pass
		settlements.discard(None) # None values might have been added, we don't want them
		return list(settlements)

	def get_building(self, point):
		"""Returns the building at the point
		@param point: position of the tile to look on
		@return: Building class instance or None if none is found.
		"""
		try:
			return self.get_tile(point).object
		except AttributeError:
			return None

	def get_settlement(self, point):
		"""Look for a settlement at a specific coordinate
		@return: Settlement at point, or None"""
		try:
			return self.get_tile(point).settlement
			# some tiles might be none, so we have to catch that error here
		except AttributeError:
			return None

	def get_tile(self, point):
		"""Returns the tile at Point or None"""
		assert isinstance(point, Point)
		raise NotImplementedError

	@decorators.make_constants()
	def get_providers_in_range(self, radiusrect, res=None, reslist=None, player=None):
		"""Returns all instances of provider within the specified shape.
		NOTE: Specifing the res parameter is usually a huge speed gain.
		@param radiusrect: instance of RadiusShape
		@param res: optional; only return providers that provide res.  conflicts with reslist
		@param reslist: optionally; list of res to search providers for. conflicts with res
		@param player: Player instance, only buildings belonging to this player
		@return: list of providers"""
		assert not (bool(res) and bool(reslist))
		assert isinstance(radiusrect, RadiusRect)
		# find out relevant providers
		if res is not None:
			provider_list = self.provider_buildings.provider_by_resources[res]
		elif reslist:
			provider_list = set()
			for _res in reslist:
				provider_list = provider_list.union(self.provider_buildings.provider_by_resources[_res])
		else:
			# worst case: search all provider buildings
			provider_list = self.provider_buildings
		# filter out those that aren't in range
		r2 = radiusrect.center
		radius_squared = radiusrect.radius ** 2
		for provider in provider_list:
			if (player is None or player == provider.owner):
				# inline of :
				#provider.position.distance_to_rect(radiusrect.center) <= radiusrect.radius:
				r1 = provider.position
				if ((max(r1.left - r2.right, 0, r2.left - r1.right) ** 2) + (max(r1.top - r2.bottom, 0, r2.top - r1.bottom) ** 2)) <= radius_squared:
					yield provider

	def save(self, db):
		for building in self.buildings:
			building.save(db)

	def end(self):
		if self.buildings is not None:
			# remove all buildings
			# this iteration style is the most robust; sometimes the ai reacts to removals
			# by building/tearing, effectively changing the list, therefore iterating over a
			# copy would either miss instances or remove some twice.
			while self.buildings:
				self.buildings[-1].remove()
		self.provider_buildings = None
		self.buildings = None

########NEW FILE########
__FILENAME__ = concreteobject
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import random

from horizons.constants import ACTION_SETS
from horizons.engine import Fife
from horizons.messaging import ActionChanged
from horizons.scheduler import Scheduler
from horizons.util.loaders.actionsetloader import ActionSetLoader
from horizons.util.python.callback import Callback
from horizons.util.worldobject import WorldObject
from horizons.world.units import UnitClass

class ConcreteObject(WorldObject):
	"""Class for concrete objects like Units or Buildings.
	"Concrete" here means "you can touch it", e.g. a Warehouse is a ConcreteObject,
	a Settlement isn't.
	All such objects have positions, so Islands are no ConcreteObjects for technical reasons.

	Assumes that object has a member _instance.
	"""
	movable = False # whether instance can move
	is_unit = False
	is_building = False

	def __init__(self, session, action_set_id=None, **kwargs):
		"""
		@param session: Session instance this obj belongs to
		"""
		super(ConcreteObject, self).__init__(**kwargs)
		from horizons.session import Session
		assert isinstance(session, Session)
		self.session = session
		self.__init(action_set_id)

	def __init(self, action_set_id=None):
		# overwrite in subclass __init[__]
		self._instance = None
		# Default action is 'idle'
		self._action = 'idle'
		# NOTE: this can't be level-aware since not all ConcreteObjects have levels
		self._action_set_id = action_set_id if action_set_id else self.__class__.get_random_action_set()

		# only buildings for now
		# NOTE: this is player dependent, therefore there must be no calls to session.random that depend on this
		self.has_status_icon = self.is_building and self.show_status_icons and \
			self.owner is not None and self.owner.is_local_player # and only for the player's buildings

	@property
	def fife_instance(self):
		return self._instance

	def save(self, db):
		super(ConcreteObject, self).save(db)
		db("INSERT INTO concrete_object(id, action_runtime, action_set_id) VALUES(?, ?, ?)", self.worldid,
			 self._instance.getActionRuntime(), self._action_set_id)

	def load(self, db, worldid):
		super(ConcreteObject, self).load(db, worldid)
		runtime, action_set_id = db.get_concrete_object_data(worldid)
		# action_set_id should never be None in regular games,
		# but this information was lacking in savegames before rev 59.
		if action_set_id is None:
			action_set_id = self.__class__.get_random_action_set(level=self.level if hasattr(self, "level") else 0)
		self.__init(action_set_id)

		# delay setting of runtime until load of sub/super-class has set the action
		def set_action_runtime(self, runtime):
			# workaround to delay resolution of self._instance, which doesn't exist yet
			self._instance.setActionRuntime(runtime)
		Scheduler().add_new_object(Callback(set_action_runtime, self, runtime), self, run_in=0)

	def act(self, action, facing_loc=None, repeating=False, force_restart=True):
		"""
		@param repeating: maps to fife, currently broken: http://github.com/fifengine/fifengine/issues/708
		@param force_restart: whether to always restart, even if action is already displayed
		"""
		if not self.has_action(action):
			action = 'idle'

		if not force_restart and self._action == action:
			return

		self._action = action

		# TODO This should not happen, this is a fix for the component introduction
		# Should be fixed as soon as we move concrete object to a component as well
		# which ensures proper initialization order for loading and initing
		if self._instance is None:
			return

		if facing_loc is None:
			facing_loc = self._instance.getFacingLocation()
		UnitClass.ensure_action_loaded(self._action_set_id, action) # lazy
		if (Fife.getVersion() >= (0, 3, 6)):
			if repeating:
				self._instance.actRepeat(action+"_"+str(self._action_set_id), facing_loc)
			else:
				self._instance.actOnce(action+"_"+str(self._action_set_id), facing_loc)
		else:
			self._instance.act(action+"_"+str(self._action_set_id), facing_loc, repeating)
		ActionChanged.broadcast(self, action)

	def has_action(self, action):
		"""Checks if this unit has a certain action.
		@param action: animation id as string"""
		return (action in ActionSetLoader.get_sets()[self._action_set_id])

	def remove(self):
		self._instance.getLocationRef().getLayer().deleteInstance(self._instance)
		self._instance = None
		Scheduler().rem_all_classinst_calls(self)
		super(ConcreteObject, self).remove()

	@classmethod
	def weighted_choice(cls, weighted_dict):
		""" http://eli.thegreenplace.net/2010/01/22/weighted-random-generation-in-python/
		"""
		# usually we do not need any magic because there only is one set:
		if len(weighted_dict) == 1:
			return weighted_dict.keys()[0]
		weights = sum(ACTION_SETS.DEFAULT_WEIGHT if w is None else w
		              for i, w in weighted_dict.iteritems())
		rnd = random.random() * weights
		for action_set, weight in weighted_dict.iteritems():
			rnd -= ACTION_SETS.DEFAULT_WEIGHT if weight is None else weight
			if rnd < 0:
				return action_set

	@classmethod
	def get_random_action_set(cls, level=0, exact_level=False):
		"""Returns an action set for an object of type object_id in a level <= the specified level.
		The highest level number is preferred.
		@param level: level to prefer. a lower level might be chosen
		@param exact_level: choose only action sets from this level. return val might be None here.
		@return: action_set_id or None"""
		action_sets = cls.action_sets
		action_set = None
		if exact_level:
			if level in action_sets:
				action_set = cls.weighted_choice(action_sets[level])
			# if there isn't one, stick with None
		else: # search all levels for an action set, starting with highest one
			for possible_level in reversed(xrange(level+1)):
				if possible_level in action_sets.iterkeys():
					action_set = cls.weighted_choice(action_sets[possible_level])
					break
			if action_set is None: # didn't find a suitable one
				# fall back to one from a higher level.
				# this does not happen in valid games, but can happen in tests, when level
				# constraints are ignored.
				action_set, weight = action_sets.values()[0].items()[0]

		return action_set

	@property
	def name(self):
		if hasattr(self, "_level_specific_names"):
			return self._level_specific_names[self.level]
		else:
			return self._name


########NEW FILE########
__FILENAME__ = diplomacy
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.changelistener import metaChangeListenerDecorator

@metaChangeListenerDecorator("diplomacy_status_changed")
class Diplomacy(object):
	"""
	Diplomacy class
	handles diplomacy between players
	two players can be allies, neutral or enemies
		allies: set of (a, b) tuples of player instances meaning a and b are allies
		         for making the relationship symmetrical a has a lower worldid than b
		enemies: set of (a, b) tuples of player instances meaning a and b are enemies
		if to players are not allies nore enemies, they are neutral

		for listeners that are not Callback instances, the arguments must be:
			caller, old_state, new_state, a, b
			old_state and new_state are a strings that can be 'ally', 'neutral' or 'enemy'
			a is first player
			b is second player
	"""

	def __init__(self):
		self.allies = set()
		self.enemies = set()

	def add_ally_pair(self, a, b):
		tup = make_tup(a, b)
		if tup is None or tup in self.allies:
			return
		old_state = self._get_state_string(tup)
		self.remove_enemy_pair(a, b)
		self.allies.add(tup)
		self.on_diplomacy_status_changed(old_state=old_state, new_state='ally', a = a, b = b)

	def add_enemy_pair(self, a, b):
		tup = make_tup(a, b)
		if tup is None or tup in self.enemies:
			return
		old_state = self._get_state_string(tup)
		self.remove_ally_pair(a, b)
		self.enemies.add(tup)
		self.on_diplomacy_status_changed(old_state=old_state, new_state='enemy', a = a, b = b)

	def add_neutral_pair(self, a, b):
		tup = make_tup(a, b)
		if tup is None or (tup not in self.allies and tup not in self.enemies):
			return
		old_state = self._get_state_string(tup)
		self.remove_ally_pair(a, b)
		self.remove_enemy_pair(a, b)
		self.on_diplomacy_status_changed(old_state=old_state, new_state='neutral', a = a, b = b)

	def remove_enemy_pair(self, a, b):
		tup = make_tup(a, b)
		if tup is None:
			return
		if tup in self.enemies:
			self.enemies.remove(tup)

	def remove_ally_pair(self, a, b):
		tup = make_tup(a, b)
		if tup is None:
			return
		if tup in self.allies:
			self.allies.remove(tup)

	def are_allies(self, a, b):
		if a is b:
			return True
		tup = make_tup(a, b)
		return tup in self.allies

	def are_enemies(self, a, b):
		if a is b:
			return False
		tup = make_tup(a, b)
		return tup in self.enemies

	def are_neutral(self, a, b):
		if a is b:
			return False
		tup = make_tup(a, b)
		return tup not in self.allies and tup not in self.enemies

	def can_trade(self, a, b):
		# NOTE: this has not been specified w.r.t. game play
		if a is b: # can trade with self
			return True
		else:
			return not self.are_enemies(a, b)

	def _get_state_string(self, tup):
		if tup in self.enemies:
			return 'enemy'
		elif tup in self.allies:
			return 'ally'
		else:
			return 'neutral'

	def load(self, world, db):
		for a, b in db("SELECT player1, player2 FROM diplomacy_allies"):
			tup = world.get_object_by_id(a), world.get_object_by_id(b)
			self.allies.add(tup)
		for a, b in db("SELECT player1, player2 FROM diplomacy_enemies"):
			tup = world.get_object_by_id(a), world.get_object_by_id(b)
			self.enemies.add(tup)

	def save(self, db):
		for tup in self.allies:
			db("INSERT INTO diplomacy_allies(player1, player2) VALUES(?, ?)",
				tup[0].worldid, tup[1].worldid)
		for tup in self.enemies:
			db("INSERT INTO diplomacy_enemies(player1, player2) VALUES(?, ?)",
				tup[0].worldid, tup[1].worldid)

def make_tup(a, b):
	"""
	Utility function that returns x,y tuple with x.worldid < y.worldid
	"""
	if a is b:
		return None
	elif a.worldid < b.worldid:
		return a, b
	else:
		return b, a

########NEW FILE########
__FILENAME__ = blackdeathdisaster
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2013 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.constants import BUILDINGS, RES, TIER
from horizons.util.python.callback import Callback
from horizons.scheduler import Scheduler
from horizons.world.disaster.buildinginfluencingdisaster import BuildingInfluencingDisaster
from horizons.world.status import BlackDeathStatusIcon

class BlackDeathDisaster(BuildingInfluencingDisaster):
	"""Simulates the Black Death.

	"""

	TYPE = "Happy dying."
	NOTIFICATION_TYPE = 'BUILDING_INFECTED_BY_BLACK_DEATH'

	SEED_CHANCE = 0.015

	EXPANSION_RADIUS = 4

	DISASTER_RES = RES.BLACKDEATH

	BUILDING_TYPE = BUILDINGS.RESIDENTIAL

	MIN_BREAKOUT_TIER = TIER.SETTLERS

	MIN_INHABITANTS_FOR_BREAKOUT = 5

	STATUS_ICON = BlackDeathStatusIcon

	RESCUE_BUILDING_TYPE = BUILDINGS.DOCTOR

	def __init__(self, settlement, manager):
		super (BlackDeathDisaster, self).__init__(settlement, manager)
		self.healed_buildings = []

	def infect(self, building, load=None):
		"""@load: (db, disaster_worldid), set on restoring infected state of savegame"""
		if not building in self.healed_buildings:
			super(BlackDeathDisaster, self).infect(building, load=load)

	def wreak_havoc(self, building):
		"""Some inhabitants have to die."""
		super(BlackDeathDisaster, self)
		if building.inhabitants > 1:
			inhabitants_that_will_die = self._manager.session.random.randint(1, building.inhabitants)
			building.inhabitants -= inhabitants_that_will_die
			self.log.debug("%s inhabitants dying", inhabitants_that_will_die)
			Scheduler().add_new_object(Callback(self.wreak_havoc, building), self, run_in=self.TIME_BEFORE_HAVOC)
		else:
			self.recover(building)

	def recover(self, building):
		self.healed_buildings.append(building)
		super(BlackDeathDisaster, self).recover(building)

########NEW FILE########
__FILENAME__ = buildinginfluencingdisaster
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2013 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.disaster import Disaster
from horizons.messaging import AddStatusIcon, RemoveStatusIcon, NewDisaster
from horizons.constants import BUILDINGS, GAME_SPEED, TIER
from horizons.scheduler import Scheduler
from horizons.util.python.callback import Callback
from horizons.util.worldobject import WorldObject

class BuildingInfluencingDisaster(Disaster):
	"""Simulates a building influencing disaster.

	Starts at a certain building and will spread out over time.

	"""

	# Defines the building type that should be influenced, by default it infects the residents of a settlement
	BUILDING_TYPE = BUILDINGS.RESIDENTIAL

	# Defines the minimum tier a settlement needs before this disaster can break out, by default its the PIONEER tier
	MIN_BREAKOUT_TIER = TIER.PIONEERS

	# Defines the minimum number of pioneer or higher residences that need to be in a
	# settlement before this disaster can break loose
	MIN_INHABITANTS_FOR_BREAKOUT = 5

	# Defines the status icon for the influenced BUILDING_TYPE
	STATUS_ICON = None

	# Defines building type that consumes resources of type DISASTER_RES
	RESCUE_BUILDING_TYPE = None

	# In a range of how many tiles can the disaster spread?
	EXPANSION_RADIUS = 0

	TIME_BEFORE_HAVOC = GAME_SPEED.TICKS_PER_SECOND * 30
	# By default, try twice before disasterying
	EXPANSION_TIME = (TIME_BEFORE_HAVOC // 2) - 1


	def __init__(self, settlement, manager):
		super (BuildingInfluencingDisaster, self).__init__(settlement, manager)
		self._affected_buildings = []

	def save(self, db):
		super( BuildingInfluencingDisaster, self).save(db)
		for building in self._affected_buildings:
			ticks = Scheduler().get_remaining_ticks(self, Callback(self.wreak_havoc, building), True)
			db("INSERT INTO building_influencing_disaster(disaster, building, remaining_ticks_havoc) VALUES(?, ?, ?)",
			   self.worldid, building.worldid, ticks)

	def load(self, db, worldid):
		super(BuildingInfluencingDisaster, self).load(db, worldid)
		for building_id, ticks in db("SELECT building, remaining_ticks_havoc FROM building_influencing_disaster WHERE disaster = ?", worldid):
			# do half of infect()
			building = WorldObject.get_object_by_id(building_id)
			self.log.debug("%s loading disaster %s", self, building)
			self.infect(building, load=(db, worldid))

	def breakout(self):
		assert self.can_breakout(self._settlement)
		super(BuildingInfluencingDisaster, self).breakout()
		possible_buildings = self._settlement.buildings_by_id[self.BUILDING_TYPE]
		building = self._settlement.session.random.choice(possible_buildings)
		self.infect(building)
		self.log.debug("%s breakout out on %s at %s", self, building, building.position)

	@classmethod
	def can_breakout(cls, settlement):
		return settlement.owner.settler_level >= cls.MIN_BREAKOUT_TIER and \
		       settlement.count_buildings(cls.BUILDING_TYPE) > cls.MIN_INHABITANTS_FOR_BREAKOUT

	def expand(self):
		if not self.evaluate():
			self._manager.end_disaster(self._settlement)
			self.log.debug("%s ending", self)
			# We are done here, time to leave
			return
		self.log.debug("%s still active, expanding..", self)
		for building in self._affected_buildings:
			for tile in self._settlement.get_tiles_in_radius(building.position, self.EXPANSION_RADIUS, False):
				if tile.object is None or tile.object.id != self.BUILDING_TYPE:
					continue
				if tile.object in self._affected_buildings:
					continue
				if self._settlement.session.random.random() <= self.SEED_CHANCE:
					self.infect(tile.object)
					return

	def end(self):
		Scheduler().rem_all_classinst_calls(self)

	def infect(self, building, load=None):
		"""@load: (db, disaster_worldid), set on restoring infected state of savegame"""
		super(BuildingInfluencingDisaster, self).infect(building, load=load)
		self._affected_buildings.append(building)
		havoc_time = self.TIME_BEFORE_HAVOC
		# keep in sync with load()
		if load:
			db, worldid = load
			havoc_time = db("SELECT remaining_ticks_havoc FROM building_influencing_disaster WHERE disaster = ? AND building = ?", worldid, building.worldid)[0][0]
		Scheduler().add_new_object(Callback(self.wreak_havoc, building), self, run_in=havoc_time)
		AddStatusIcon.broadcast(building, self.STATUS_ICON(building))
		NewDisaster.broadcast(building.owner, building, self.__class__, self)

	def recover(self, building):
		super(BuildingInfluencingDisaster, self).recover(building)
		RemoveStatusIcon.broadcast(self, building, self.STATUS_ICON)
		callback = Callback(self.wreak_havoc, building)
		Scheduler().rem_call(self, callback)
		self._affected_buildings.remove(building)

	def evaluate(self):
		return len(self._affected_buildings) > 0

	def wreak_havoc(self, building):
		super(BuildingInfluencingDisaster, self).wreak_havoc(building)
		self._affected_buildings.remove(building)

########NEW FILE########
__FILENAME__ = disastermanager
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.world.disaster.firedisaster import FireDisaster
from horizons.world.disaster.blackdeathdisaster import BlackDeathDisaster
from horizons.scheduler import Scheduler
from horizons.constants import GAME_SPEED
from horizons.util.worldobject import WorldObject

class DisasterManager(object):
	"""The disaster manager manages disasters. It seeds them into the
	game world and makes all requirements for a disaster are met before
	seeding it."""
	log = logging.getLogger("world.disaster")

	# Number of ticks between calls to run()
	CALL_EVERY = GAME_SPEED.TICKS_PER_SECOND * 60
	#CALL_EVERY = 1 # to conjure the demons of armageddon

	def __init__(self, session, disabled=False):
		"""
		@param disabled: Don't do anything at all if True (but be responsive to normal calls)"""
		from horizons.session import Session
		assert isinstance(session, Session)
		self.session = session
		self.disabled = disabled
		# List of possible disaster classes
		self.disasters = [FireDisaster, BlackDeathDisaster]

		# Mapping settlement -> active disasters
		self._active_disaster = {}

		# keep call also when disabled, simplifies save/load
		Scheduler().add_new_object(self.run, self, run_in=self.CALL_EVERY, loops=-1)

	def save(self, db):
		ticks = Scheduler().get_remaining_ticks(self, self.run, True)
		db("INSERT INTO disaster_manager(remaining_ticks) VALUES(?)", ticks)
		for disaster in self._active_disaster.itervalues():
			disaster.save(db)

	def load(self, db):
		db_data = db("SELECT remaining_ticks FROM disaster_manager")
		if db_data:
			Scheduler().rem_all_classinst_calls(self)
			ticks = db_data[0][0] # only one row in table
			Scheduler().add_new_object(self.run, self, run_in=ticks,
			                           loop_interval=self.CALL_EVERY, loops=-1)

		for disaster_id, disaster_type, settlement_id in db("SELECT rowid, type, settlement FROM disaster"):
			settlement = WorldObject.get_object_by_id(settlement_id)
			klass = (i for i in  self.disasters if i.TYPE == disaster_type).next()
			cata = klass(settlement, self)
			self._active_disaster[settlement] = cata
			cata.load(db, disaster_id)

	def run(self):
		if self.disabled:
			return
		for settlement in self.session.world.settlements:
			for disaster in self.disasters:
				if not settlement in self._active_disaster:
					if self.session.random.random() <= disaster.SEED_CHANCE:
						if disaster.can_breakout(settlement):
							self.log.debug("Seeding disaster: %s", disaster)
							cata = disaster(settlement, self)
							cata.breakout()
							self._active_disaster[settlement] = cata
						else:
							self.log.debug("Disaster %s would breakout apply but can't breakout",
							               disaster)

	def end_disaster(self, settlement):
		# End the disaster
		self.log.debug("ending desaster in %s", settlement)
		self._active_disaster[settlement].end()
		del self._active_disaster[settlement]

	def is_affected(self, settlement):
		"""Returns whether there is currently a disaster in a settlement"""
		return settlement in self._active_disaster

	def get_disaster(self, settlement):
		"""Returns the currently active disaster for the given settlement. None is
		returned in case no disaster is currently active."""
		if self.is_affected(settlement):
			return self._active_disaster[settlement]
		return None



########NEW FILE########
__FILENAME__ = firedisaster
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.disaster.buildinginfluencingdisaster import BuildingInfluencingDisaster
from horizons.world.status import FireStatusIcon
from horizons.constants import BUILDINGS, RES, TIER

class FireDisaster(BuildingInfluencingDisaster):
	"""Simulates a fire.

	"""

	TYPE = "The Flames Of The End"
	NOTIFICATION_TYPE = 'BUILDING_ON_FIRE'

	SEED_CHANCE = 0.005

	EXPANSION_RADIUS = 3

	DISASTER_RES = RES.FIRE

	BUILDING_TYPE = BUILDINGS.RESIDENTIAL

	MIN_BREAKOUT_TIER = TIER.PIONEERS

	MIN_INHABITANTS_FOR_BREAKOUT = 7

	STATUS_ICON = FireStatusIcon

	RESCUE_BUILDING_TYPE = BUILDINGS.FIRE_STATION

	def wreak_havoc(self, building):
		super(FireDisaster, self).wreak_havoc(building)
		building.make_ruin()

########NEW FILE########
__FILENAME__ = ground
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from fife import fife

import horizons.globals

from horizons.constants import LAYERS, GROUND
from horizons.util.loaders.tilesetloader import TileSetLoader


class SurfaceTile(object):
	is_water = False
	layer = LAYERS.GROUND

	__slots__ = ('x', 'y', 'settlement', 'blocked', 'object', 'session', '_instance', '_tile_set_id')

	def __init__(self, session, x, y):
		"""
		@param session: Session instance
		@param x: int x position the ground is created.
		@param y: int y position the ground is created.
		"""
		self.x = x
		self.y = y

		self.settlement = None
		self.blocked = False
		self.object = None
		self.session = session
		self._tile_set_id = horizons.globals.db.get_random_tile_set(self.id)

		layer = session.view.layers[self.layer]
		self._instance = layer.createInstance(self._fife_objects[self._tile_set_id],
		                                      fife.ModelCoordinate(int(x), int(y), 0),
		                                      "")
		fife.InstanceVisual.create(self._instance)

	def __str__(self):
		return "SurfaceTile(id=%s, shape=%s, x=%s, y=%s, water=%s, obj=%s)" % \
		       (self.id, self.shape, self.x, self.y, self.is_water, self.object)

	def act(self, rotation):
		self._instance.setRotation(rotation)

		(x, y) = (self.x, self.y)
		layer_coords = {
			45:  (x + 3, y,     0),
			135: (x,     y - 3, 0),
			225: (x - 3, y,     0),
			315: (x,     y + 3, 0),
		}[rotation]

		facing_loc = fife.Location(self.session.view.layers[self.layer])
		facing_loc.setLayerCoordinates(fife.ModelCoordinate(*layer_coords))
		self._instance.setFacingLocation(facing_loc)

	@property
	def rotation(self):
		# workaround for FIFE's inconsistent rotation rounding
		return int(round(self._instance.getRotation() / 45.0)) * 45


class Ground(SurfaceTile):
	"""Default land surface"""
	pass


class Water(SurfaceTile):
	"""Default water surface"""
	is_water = True
	layer = LAYERS.WATER


class WaterDummy(Water):
	def __init__(self, session, x, y):
		# no super call, we don't have an instance
		self.x = x
		self.y = y

		self.settlement = None
		self.blocked = False
		self.object = None


class GroundClass(type):
	"""
	@param id: ground id.
	"""
	log = logging.getLogger('world')

	def __init__(self, db, id, shape):
		"""
		@param id: id in db for this specific ground class
		@param db: DbReader instance to get data from
		"""
		self.id = id
		self.shape = shape
		self._fife_objects = None
		self.velocity = {}
		self.classes = ['ground[' + str(id) + ']']
		for (name,) in db("SELECT class FROM ground_class WHERE ground = ?", id):
			self.classes.append(name)
		if id != -1	:
			self._loadObject(db)

	def __new__(self, db, id, shape):
		"""
		@param id: ground id.
		@param shape: ground shape (straight, curve_in, curve_out).
		"""
		if id == GROUND.WATER[0]:
			return type.__new__(self, 'Ground[%d-%s]' % (id, shape), (Water,), {})
		elif id == -1:
			return type.__new__(self, 'Ground[%d-%s]' % (id, shape), (WaterDummy,), {})
		else:
			return type.__new__(self, 'Ground[%d-%s]' % (id, shape), (Ground,), {})

	def _loadObject(cls, db):
		"""Loads the ground object from the db (animations, etc)"""
		cls._fife_objects = {}
		tile_sets = TileSetLoader.get_sets()
		model = horizons.globals.fife.engine.getModel()
		load_image = horizons.globals.fife.animationloader.load_image
		tile_set_data = db("SELECT set_id FROM tile_set WHERE ground_id=?", cls.id)
		for tile_set_row in tile_set_data:
			tile_set_id = str(tile_set_row[0])
			cls_name = '%d-%s' % (cls.id, cls.shape)
			cls.log.debug('Loading ground %s', cls_name)
			fife_object = None
			try:
				fife_object = model.createObject(cls_name, 'ground_' + tile_set_id)
			except RuntimeError:
				cls.log.debug('Already loaded ground %d-%s', cls.id, cls.shape)
				fife_object = model.getObject(cls_name, 'ground_' + tile_set_id)
				return

			fife.ObjectVisual.create(fife_object)
			visual = fife_object.get2dGfxVisual()
			for rotation, data in tile_sets[tile_set_id][cls.shape].iteritems():
				if not data:
					raise KeyError('No data found for tile set `%s` in rotation `%s`. '
						'Most likely the shape `%s` is missing.' %
						(tile_set_id, rotation, cls.shape))
				if len(data) > 1:
					raise ValueError('Currently only static tiles are supported. '
						'Found this data for tile set `%s` in rotation `%s`: '
						'%s' % (tile_set_id, rotation, data))
				img = load_image(data.keys()[0], tile_set_id, cls.shape, str(rotation))
				visual.addStaticImage(rotation, img.getHandle())

			# Save the object
			cls._fife_objects[tile_set_id] = fife_object


class MapPreviewTile(object):
	"""This class provides the minimal tile implementation for map preview."""

	def __init__(self, x, y, id):
		super(MapPreviewTile, self).__init__()
		self.x = x
		self.y = y
		self.id = id
		self.classes = ()
		self.settlement = None

########NEW FILE########
__FILENAME__ = ingametype
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import hashlib

from horizons.constants import TIER
from horizons.i18n import _lazy

class IngameType(type):
	"""Class that is used to create Ingame-Type-Classes from yaml data.
	@param id: building or unit type id
	@param yaml_data: a dict containing all the data read from yaml files

	Note this creates class types, NOT instances.
	These types are created at the beginning of a session
	and are later used to create instances, when buildings are built.
	The __new__() function uses quite some python magic to construct the new class.

	TUTORIAL:
	Check out the __new__() function if you feel you're pretty good with python and
	are interested in how it all works. Otherwise, continue to the __init__() function.
	"""

	# Base package to import from, must end with the '.', the package is appended
	basepackage = 'horizons.world.building.'
	# Class name for the type.__new__ constructor
	classstring = 'Type[{id}]'

	def __new__(self, id, yaml_data):
		class_package, class_name = yaml_data['baseclass'].split('.', 1)

		@classmethod
		def load(cls, session, db, worldid):
			self = cls.__new__(cls)
			self.session = session
			super(cls, self).load(db, worldid)
			return self

		module = __import__(str(self.basepackage+class_package), [], [], [str(class_name)])
		return type.__new__(self, self.classstring.format(id=id),
			(getattr(module, class_name),),
			{'load': load, 'class_package': str(class_package), 'class_name': str(class_name)})

	def _strip_translation_marks(self, string):
		"""Converts object translation `string` to translated object for in-game display.

		Object properties supposed to be translated are recognized by the
		(subsequently stripped) leading `_ `.
		If `string` is supposed to be translated, returns lazy translation object of `string`.
		If `string` is not supposed to be translated, returns `string` unchanged.
		If `string` is None (not defined or empty in yaml), returns empty unicode.
		"""
		if not string:
			return u''
		if string.startswith("_ "):
			return _lazy(string[2:])
		else:
			return string

	def __init__(self, id, yaml_data):
		self.id = id
		# self._name is always some default name
		# self._level_specific_names is optional and contains a dict like this: { level_id : name }
		# (with entries for all tiers in which it is active)
		name_data = yaml_data['name']
		start_tier = yaml_data.get('tier', TIER.NATURE)  # first tier where object is available
		if isinstance(name_data, dict): # { level_id : name }
			# fill up dict (fall down to highest tier which has a name specified
			self._level_specific_names = {}
			for lvl in xrange(start_tier, TIER.CURRENT_MAX + 1):
				name = name_data.get(lvl)
				if name is None:
					name = self._level_specific_names.get(lvl - 1)
					assert name is not None, (
						"Error in object file:\n"
						"'name' attribute needs to at least describe tier %s. "
						"Found:\n%s") % (name_data, start_tier)
					self._level_specific_names[lvl] = name
				else:
					self._level_specific_names[lvl] = self._strip_translation_marks(name)

			self._name = self._level_specific_names[start_tier] # default name: lowest available
		else: # assume just one string
			self._name = self._strip_translation_marks( name_data )
		self.radius = yaml_data['radius']
		self.component_templates = yaml_data['components']
		self.action_sets = yaml_data['actionsets']
		self.baseclass = yaml_data['baseclass'] # mostly only for debug
		self._real_object = None # wrapped by _fife_object

		self._parse_component_templates()

		# TODO: move this to the producer component as soon as there is support for class attributes there
		self.additional_provided_resources = yaml_data.get('additional_provided_resources', [])

		"""TUTORIAL: Now you know the basic attributes each type has.
		Further attributes specific to buildings and units can be found in
		horizons/world/{building,units}/__init__.py
		which contains the unit and building specific attributes and loading.

		By now you should know the basic constructs used in UH, so we feel
		comfortable stopping the tutorial here. Be sure to join our IRC
		channel and idle around there, ask us if you're stuck and so on.

		You'll find tasks for getting into the code in our issue tracker at
		https://github.com/unknown-horizons/unknown-horizons/issues
		Especially look for issues with the 'starter' label attached!

		Other relevant parts of the code you might be interested in are:
		* commands: horizons/commands. Abstracts all user interactions.
		* scheduler: horizons/scheduler.py. Manages ingame time.
		* extscheduler: horizons/extscheduler.py. Manages wall clock time.
		* scenario: horizons/scenario. Condition-action system for scenarios
		* automatic tests: tests/. Contains unit tests, gui tests and game (system) tests
		* networking: horizons/network. Sending stuff over the wire
		* concreteobject: horizons/world/concreteobject.py. Things with graphical representations
		* gui: horizons/gui. The ugly parts. IngameGui and Gui, tabs and widgets.
		* production: horizons/world/production
		** Producer: producer component, manages everything
		** ProductionLine: keeps data about the different production lines.
		** Production: the alive version of the production line. Used when a building
		               actually produces something, stores progress and the like.
		* engine: horizons/engine. Direct interface to fife.
		* ai: horizons/ai/aiplayer. Way too big to describe here.
		"""

	def _parse_component_templates(self):
		"""Prepares misc data in self.component_templates"""
		producer = [ comp for comp in self.component_templates if
		             isinstance(comp, dict) and comp.iterkeys().next() == 'ProducerComponent' ]
		if producer:
			# we want to support string production line ids, the code should still only see integers
			# therefore we do a deterministic string -> int conversion here

			producer_data = producer[0]['ProducerComponent']
			original_data = producer_data['productionlines']

			new_data = {}

			for old_key, v in original_data.iteritems():
				if isinstance(old_key, int):
					new_key = old_key
				else:
					# hash the string
					new_key = int(hashlib.sha1(old_key).hexdigest(), 16)
					# crop to integer. this might not be necessary, however the legacy code operated
					# on this data type, so problems might occur, also with respect to performance.
					# in principle, strings and longs should also be supported, but for the sake of
					# safety, we use ints.
					new_key = int( new_key % 2**31 ) # this ensures it's an integer on all reasonable platforms
				if new_key in new_data:
					raise Exception('Error: production line id conflict.'
					                ' Please change "%s" to anything else for "%s"'
					                % (old_key, self.name))
				new_data[new_key] = v

			producer_data['productionlines'] = new_data


	@property
	def _fife_object(self):
		if self._real_object is None:
			self._loadObject()
		return self._real_object

	def _loadObject(self):
		"""Inits self._real_object"""
		raise NotImplementedError

	@property
	def name(self):
		return self._name

########NEW FILE########
__FILENAME__ = island
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from collections import defaultdict

from horizons.entities import Entities
from horizons.scheduler import Scheduler

from horizons.util.buildingindexer import BuildingIndexer
from horizons.util.pathfinding.pathnodes import IslandPathNodes
from horizons.util.shapes import Circle, Rect
from horizons.util.worldobject import WorldObject
from horizons.messaging import SettlementRangeChanged, NewSettlement
from horizons.world.settlement import Settlement
from horizons.constants import BUILDINGS, RES, UNITS
from horizons.command.building import Tear
from horizons.scenario import CONDITIONS
from horizons.world.buildingowner import BuildingOwner
from horizons.world.buildability.freeislandcache import FreeIslandBuildabilityCache
from horizons.world.buildability.terraincache import TerrainBuildabilityCache, TerrainRequirement
from horizons.gui.widgets.minimap import Minimap
from horizons.world.ground import MapPreviewTile

class Island(BuildingOwner, WorldObject):
	"""The Island class represents an island. It contains a list of all things on the map
	that belong to the island. This comprises ground tiles as well as buildings,
	nature objects (which are buildings), and units.
	All those objects also have a reference to the island, making it easy to determine to which island the instance belongs.
	An Island instance is created during map creation, when all tiles are added to the map.
	@param origin: Point instance - Position of the (0, 0) ground tile.
	@param filename: file from which the island is loaded.

	Each island holds some important attributes:
	* grounds - All ground tiles that belong to the island are referenced here.
	* grounds_map -  a dictionary that binds tuples of coordinates with a reference to the tile:
	                  { (x, y): tileref, ...}
					  This is important for pathfinding and quick tile fetching.
	* position - a Rect that borders the island with the smallest possible area.
	* buildings - a list of all Building instances that are present on the island.
	* settlements - a list of all Settlement instances that are present on the island.
	* path_nodes - a special dictionary used by the pather to save paths.

	TUTORIAL:
	Why do we use a separate __init() function, and do not use the __init__() function?
	Simple: if we load the game, the class is not loaded as a new instance, so the __init__
	function is not called. Rather, the load function is called, so everything that new
	classes and loaded classes share to initialize goes into the __init() function.
	This is the common way of doing this in Unknown Horizons, so better get used to it :)
	NOTE: The components work a bit different, but this code here is mostly not component oriented.

	To continue hacking, check out the __init() function now.
	"""
	log = logging.getLogger("world.island")

	def __init__(self, db, island_id, session, preview=False):
		"""
		@param db: db instance with island table
		@param island_id: id of island in that table
		@param session: reference to Session instance
		@param preview: flag, map preview mode
		"""
		super(Island, self).__init__(worldid=island_id)

		self.session = session

		self.terrain_cache = None
		self.available_land_cache = None
		self.__init(db, island_id, preview)

		if not preview:
			# Create building indexers.
			from horizons.world.units.animal import WildAnimal
			self.building_indexers = {}
			self.building_indexers[BUILDINGS.TREE] = BuildingIndexer(WildAnimal.walking_range, self, self.session.random)

		# Load settlements.
		for (settlement_id,) in db("SELECT rowid FROM settlement WHERE island = ?", island_id):
			settlement = Settlement.load(db, settlement_id, self.session, self)
			self.settlements.append(settlement)

		if preview:
			# Caches and buildings are not required for map preview.
			return

		self.terrain_cache = TerrainBuildabilityCache(self)
		flat_land_set = self.terrain_cache.cache[TerrainRequirement.LAND][(1, 1)]
		self.available_flat_land = len(flat_land_set)
		available_coords_set = set(self.terrain_cache.land_or_coast)

		for settlement in self.settlements:
			settlement.init_buildability_cache(self.terrain_cache)
			for coords in settlement.ground_map:
				available_coords_set.discard(coords)
				if coords in flat_land_set:
					self.available_flat_land -= 1

		self.available_land_cache = FreeIslandBuildabilityCache(self)

		# Load buildings.
		from horizons.world import load_building
		buildings = db("SELECT rowid, type FROM building WHERE location = ?", island_id)
		for (building_worldid, building_typeid) in buildings:
			load_building(self.session, db, building_typeid, building_worldid)

	def __init(self, db, island_id, preview):
		"""
		Load the actual island from a file
		@param preview: flag, map preview mode
		"""
		p_x, p_y, width, height = db("SELECT MIN(x), MIN(y), (1 + MAX(x) - MIN(x)), (1 + MAX(y) - MIN(y)) FROM ground WHERE island_id = ?", island_id - 1001)[0]

		self.ground_map = {}
		for (x, y, ground_id, action_id, rotation) in db("SELECT x, y, ground_id, action_id, rotation FROM ground WHERE island_id = ?", island_id - 1001): # Load grounds
			if not preview: # actual game, need actual tiles
				ground = Entities.grounds[str('%d-%s' % (ground_id, action_id))](self.session, x, y)
				ground.act(rotation)
			else:
				ground = MapPreviewTile(x, y, ground_id)
			# These are important for pathfinding and building to check if the ground tile
			# is blocked in any way.
			self.ground_map[(ground.x, ground.y)] = ground

		self._init_cache()

		# Contains references to all resource deposits (but not mines)
		# on the island, regardless of the owner:
		# {building_id: {(x, y): building_instance, ...}, ...}
		self.deposits = defaultdict(dict)

		self.settlements = []
		self.wild_animals = []
		self.num_trees = 0

		# define the rectangle with the smallest area that contains every island tile its position
		min_x = min(zip(*self.ground_map.keys())[0])
		max_x = max(zip(*self.ground_map.keys())[0])
		min_y = min(zip(*self.ground_map.keys())[1])
		max_y = max(zip(*self.ground_map.keys())[1])
		self.position = Rect.init_from_borders(min_x, min_y, max_x, max_y)

		if not preview:
			# This isn't needed for map previews, but it is in actual games.
			self.path_nodes = IslandPathNodes(self)

			# Repopulate wild animals every 2 mins if they die out.
			Scheduler().add_new_object(self.check_wild_animal_population, self,
			                           run_in=Scheduler().get_ticks(120), loops=-1)

		"""TUTORIAL:
		The next step will be an overview of the component system, which you will need
		to understand in order to see how our actual game object (buildings, units) work.
		Please proceed to horizons/component/componentholder.py.
		"""

	def save(self, db):
		super(Island, self).save(db)
		for settlement in self.settlements:
			settlement.save(db, self.worldid)
		for animal in self.wild_animals:
			animal.save(db)

	def get_coordinates(self):
		"""Returns list of coordinates, that are on the island."""
		return self.ground_map.keys()

	def get_tile(self, point):
		"""Returns whether a tile is on island or not.
		@param point: Point contains position of the tile.
		@return: tile instance if tile is on island, else None."""
		return self.ground_map.get((point.x, point.y))

	def get_tile_tuple(self, tup):
		"""Overloaded get_tile, takes a tuple as argument"""
		return self.ground_map.get(tup)

	def get_tiles_tuple(self, tuples):
		"""Same as get_tile, but takes a list of tuples.
		@param tuples: iterable of tuples
		@return: iterable of map tiles"""
		for tup in tuples:
			if tup in self.ground_map:
				yield self.ground_map[tup]

	def add_settlement(self, position, radius, player):
		"""Adds a settlement to the island at the position x, y with radius as area of influence.
		@param position: Rect describing the position of the new warehouse
		@param radius: int radius of the area of influence.
		@param player: int id of the player that owns the settlement"""
		settlement = Settlement(self.session, player)
		settlement.initialize()
		settlement.init_buildability_cache(self.terrain_cache)
		self.add_existing_settlement(position, radius, settlement)
		NewSettlement.broadcast(self, settlement, position.center)

		return settlement

	def add_existing_settlement(self, position, radius, settlement):
		"""Same as add_settlement, but uses settlement from parameter.
		May also be called for extension of an existing settlement by a new building (this
		is useful for loading, where every loaded building extends the radius of its settlement).
		@param position: Rect
		@param load: whether it has been called during load"""
		if settlement not in self.settlements:
			self.settlements.append(settlement)
		self.assign_settlement(position, radius, settlement)
		self.session.scenario_eventhandler.check_events(CONDITIONS.settlements_num_greater)
		return settlement

	def assign_settlement(self, position, radius, settlement):
		"""Assigns the settlement property to tiles within the circle defined by \
		position and radius.
		@param position: Rect
		@param radius:
		@param settlement:
		"""
		settlement_coords_changed = []
		for coords in position.get_radius_coordinates(radius, include_self=True):
			if coords not in self.ground_map:
				continue

			tile = self.ground_map[coords]
			if tile.settlement is not None:
				continue

			tile.settlement = settlement
			settlement.ground_map[coords] = tile
			settlement_coords_changed.append(coords)

			building = tile.object
			# In theory fish deposits should never be on the island but this has been
			# possible since they were turned into a 2x2 building. Since they are never
			# entirely on the island then it is easiest to just make it impossible to own
			# fish deposits.
			if building is None or building.id == BUILDINGS.FISH_DEPOSIT:
				continue

			# Assign the entire building to the first settlement that covers some of it.
			assert building.settlement is None or building.settlement is settlement
			for building_coords in building.position.tuple_iter():
				building_tile = self.ground_map[building_coords]
				if building_tile.settlement is not settlement:
					assert building_tile.settlement is None
					building_tile.settlement = settlement
					settlement.ground_map[building_coords] = building_tile
					settlement_coords_changed.append(building_coords)

			building.settlement = settlement
			building.owner = settlement.owner
			settlement.add_building(building)

		if not settlement_coords_changed:
			return

		flat_land_set = self.terrain_cache.cache[TerrainRequirement.LAND][(1, 1)]
		settlement_tiles_changed = []
		for coords in settlement_coords_changed:
			settlement_tiles_changed.append(self.ground_map[coords])
			Minimap.update(coords)
			if coords in flat_land_set:
				self.available_flat_land -= 1
		self.available_land_cache.remove_area(settlement_coords_changed)

		self._register_change()
		if self.terrain_cache:
			settlement.buildability_cache.modify_area(settlement_coords_changed)

		SettlementRangeChanged.broadcast(settlement, settlement_tiles_changed)
	
	def abandon_buildings(self, buildings_list):
		"""Abandon all buildings in the list
		@param buildings_list: buildings to abandon
		"""
		for building in buildings_list:
			Tear(building)(building.owner)

	def remove_settlement(self, building):
		"""Removes the settlement property from tiles within the radius of the given building"""
		settlement = building.settlement
		buildings_to_abandon, settlement_coords_to_change = Tear.additional_removals_after_tear(building)
		assert building not in buildings_to_abandon
		self.abandon_buildings(buildings_to_abandon)
		
		flat_land_set = self.terrain_cache.cache[TerrainRequirement.LAND][(1, 1)]
		land_or_coast = self.terrain_cache.land_or_coast
		settlement_tiles_changed = []
		clean_coords = set()
		for coords in settlement_coords_to_change:
			tile = self.ground_map[coords]
			tile.settlement = None
			building = tile.object
			if building is not None:
				settlement.remove_building(building)
				building.owner = None
				building.settlement = None
			if coords in land_or_coast:
				clean_coords.add(coords)
			settlement_tiles_changed.append(self.ground_map[coords])
			del settlement.ground_map[coords]
			Minimap.update(coords)
			if coords in flat_land_set:
				self.available_flat_land += 1
		self.available_land_cache.add_area(clean_coords)

		self._register_change()
		if self.terrain_cache:
			settlement.buildability_cache.modify_area(clean_coords)

		SettlementRangeChanged.broadcast(settlement, settlement_tiles_changed)

	def add_building(self, building, player, load=False):
		"""Adds a building to the island at the position x, y with player as the owner.
		@param building: Building class instance of the building that is to be added.
		@param player: int id of the player that owns the settlement
		@param load: boolean, whether it has been called during loading"""
		if building.id in (BUILDINGS.CLAY_DEPOSIT, BUILDINGS.MOUNTAIN) and self.available_land_cache is not None:
			# self.available_land_cache may be None when loading a settlement
			# it is ok to skip in that case because the cache's constructor will take the deposits into account anyway
			self.deposits[building.id][building.position.origin.to_tuple()] = building
			self.available_land_cache.remove_area(list(building.position.tuple_iter()))
		super(Island, self).add_building(building, player, load=load)
		if not load and building.settlement is not None:
			# Note: (In case we do not require all building tiles to lay inside settlement
			# range at some point.) `include_self` is True in get_radius_coordinates()
			# called from here, so the building area itself *is* expanded by even with
			# radius=0! Right now this has no effect (above buildability requirements).
			radius = 0 if building.id not in BUILDINGS.EXPAND_RANGE else building.radius
			self.assign_settlement(building.position, radius, building.settlement)

		if building.settlement is not None:
			building.settlement.add_building(building, load)
		if building.id in self.building_indexers:
			self.building_indexers[building.id].add(building)

		# Reset the tiles this building was covering
		for coords in building.position.tuple_iter():
			self.path_nodes.reset_tile_walkability(coords)
		if not load:
			self._register_change()

		# keep track of the number of trees for animal population control
		if building.id == BUILDINGS.TREE:
			self.num_trees += 1

		return building

	def remove_building(self, building):
		# removal code (before super call)
		if building.id in (BUILDINGS.CLAY_DEPOSIT, BUILDINGS.MOUNTAIN):
			coords = building.position.origin.to_tuple()
			if coords in self.deposits[building.id]:
				del self.deposits[building.id][coords]
		if building.settlement is not None:
			if building.id in BUILDINGS.EXPAND_RANGE:
				self.remove_settlement(building)
			else:
				building.settlement.remove_building(building)
				assert building not in building.settlement.buildings

		super(Island, self).remove_building(building)
		if building.id in self.building_indexers:
			self.building_indexers[building.id].remove(building)

		# Reset the tiles this building was covering (after building has been completely removed)
		for coords in building.position.tuple_iter():
			self.path_nodes.reset_tile_walkability(coords)
			self._register_change()

		# keep track of the number of trees for animal population control
		if building.id == BUILDINGS.TREE:
			self.num_trees -= 1

	def get_building_index(self, resource_id):
		if resource_id == RES.WILDANIMALFOOD:
			return self.building_indexers[BUILDINGS.TREE]
		return None

	def get_surrounding_tiles(self, where, radius=1, include_corners=True):
		"""Returns tiles around point with specified radius.
		@param where: instance of Point, or object with get_surrounding()"""
		if hasattr(where, "get_surrounding"):
			coords = where.get_surrounding(include_corners=include_corners)
		else: # assume Point
			coords = Circle(where, radius).tuple_iter()
		for position in coords:
			tile = self.get_tile_tuple(position)
			if tile is not None:
				yield tile

	def get_tiles_in_radius(self, location, radius, include_self):
		"""Returns tiles in radius of location.
		This is a generator.
		@param location: anything that supports get_radius_coordinates (usually Rect).
		@param include_self: bool, whether to include the coordinates in location
		"""
		for coord in location.get_radius_coordinates(radius, include_self):
			try:
				yield self.ground_map[coord]
			except KeyError:
				pass

	def __iter__(self):
		return self.ground_map.iterkeys()

	def check_wild_animal_population(self):
		"""Creates a wild animal if they died out."""
		self.log.debug("Checking wild animal population: %s", len(self.wild_animals))
		if self.wild_animals:
			# Some animals still alive, nothing to revive.
			return

		# Find a tree where we can place a new animal.
		# We might not find a tree at all, but if that's the case,
		# wild animals would die out again anyway, so we do nothing.
		for building in self.buildings:
			if building.id == BUILDINGS.TREE:
				point = building.position.origin
				entity = Entities.units[UNITS.WILD_ANIMAL]
				animal = entity(self, x=point.x, y=point.y, session=self.session)
				animal.initialize()
				return

	def _init_cache(self):
		""" initializes the cache that knows when the last time the buildability of a rectangle may have changed on this island """
		self.last_change_id = -1

	def _register_change(self):
		""" registers the possible buildability change of a rectangle on this island """
		self.last_change_id += 1

	def end(self):
		# NOTE: killing animals before buildings is an optimization, else they would
		# keep searching for new trees every time a tree is torn down.
		for wild_animal in (wild_animal for wild_animal in self.wild_animals):
			wild_animal.remove()
		super(Island, self).end()
		for settlement in self.settlements:
			settlement.end()
		self.wild_animals = None
		self.ground_map = None
		self.path_nodes = None
		self.building_indexers = None

########NEW FILE########
__FILENAME__ = productionfinishediconmanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife
from horizons.component.storagecomponent import StorageComponent
from horizons.constants import GAME_SPEED

import horizons.globals
from horizons.gui.util import get_res_icon_path
from horizons.messaging import ResourceProduced, SettingChanged
from horizons.scheduler import Scheduler
from horizons.util.python.callback import Callback

class ProductionFinishedIconManager(object):
	"""Manager class that manages all production finished icons. It listens to
	 ResourceProduced messages on the main message bus"""

	def __init__(self, renderer, layer):
		"""
		@param renderer: Renderer used to render the icons
		@param layer: map layer, needed to place icon
		"""
		self.layer = layer
		self.renderer = renderer
		self.run = {}
		self.animation_duration = 20 # The duration how long the image moves up
		self.animation_steps = 1 # The steps that the image makes every run
		self.background = "content/gui/images/background/produced_notification.png"

		if bool(horizons.globals.fife.get_uh_setting("ShowResourceIcons")):
			self.enable()

		SettingChanged.subscribe(self._on_setting_changed)

	def enable(self):
		ResourceProduced.subscribe(self._on_resource_produced)

	def disable(self):
		Scheduler().rem_all_classinst_calls(self)
		ResourceProduced.discard(self._on_resource_produced)
		for group in self.run:
			self.renderer.removeAll(group)

		self.run = {}

	def end(self):
		self.disable()
		self.run = None
		self.renderer = None
		SettingChanged.unsubscribe(self._on_setting_changed)

	def _on_setting_changed(self, message):
		if message.setting_name == 'ShowResourceIcons':
			if message.new_value is True:
				self.enable()
			else:
				self.disable()

	def _on_resource_produced(self, message):
		"""This is called by the message bus with ResourceProduced messages"""
		assert isinstance(message, ResourceProduced)

		# if we get an empty dictionary, abort
		if (not message.produced_resources or not message.produced_resources.keys()) or \
			not message.caller.instance.owner.is_local_player:
			return

		# makes the animation independent from game speed
		cur_ticks_per_second = Scheduler().timer.ticks_per_second
		interval = None
		if cur_ticks_per_second > GAME_SPEED.TICKS_PER_SECOND:
			interval = (cur_ticks_per_second // GAME_SPEED.TICKS_PER_SECOND) - 1

		display_latency = 1
		for resource_item in message.produced_resources.items():
			res = resource_item[0] # TODO multiple resources
			amount = message.sender.get_component(StorageComponent).inventory[res]

			# abort if amount is zero
			if not amount:
				continue

			group = self.get_resource_string(message.sender, res)
			self.run[group] = self.animation_steps

			tick_callback = Callback(self.__render_icon, message.sender, group, res, amount)
			finish_callback = Callback(self.remove_icon, group)

			Scheduler().add_new_object(tick_callback, self, finish_callback=finish_callback,
		                           run_in=display_latency, loops=self.animation_duration,
		                           loop_interval=interval)
			display_latency += (self.animation_duration * display_latency) * (interval if interval else 1)

	def __render_icon(self, instance, group, res, amount):
		""" This renders the icon. It calculates the position of the icon.
		Most parts of this were copied from horizons/world/managers/statusiconmanager.py
		"""
		# TODO: Try to unify the __render methods of this class and statusiconmanager.py!
		self.renderer.removeAll(group)

		pos = instance.position
		# self.run[group] is used for the moving up animation
		# use -50 here to get some more offset in height
		bg_rel = fife.Point(0, -50 - self.run[group])
		rel = fife.Point(-14, -50 - self.run[group])
		self.run[group] += self.animation_steps

		x = pos.origin.x + (pos.width / 4.0)
		y = pos.origin.y + (pos.height / 4.0)
		loc = fife.Location(self.layer)
		loc.setExactLayerCoordinates(fife.ExactModelCoordinate(x, y))

		bg_node = fife.RendererNode(loc, bg_rel)
		node = fife.RendererNode(loc, rel)

		bg_image = horizons.globals.fife.imagemanager.load(self.background)
		res_icon = horizons.globals.fife.imagemanager.load(get_res_icon_path(res))
		font = horizons.globals.fife.pychan.manager.getFont('mainmenu')

		self.renderer.addImage(group, bg_node, bg_image)
		self.renderer.resizeImage(group, node, res_icon, 24, 24)
		self.renderer.addText(group, node, font, ' '*9 + '{amount:>2d}'.format(amount=amount))

	def remove_icon(self, group):
		""" Remove the icon after the animation finished
		Also removes the entry in the run-dictionary.
		"""
		self.renderer.removeAll(group)
		del self.run[group]

	def get_resource_string(self, instance, res):
		"""Returns the render name for resource icons of this instance
		This key MUST be unique!
		"""
		return "produced_resource_" + str(res) + "_" + str(instance.position.origin)\
		       + "_" + str(Scheduler().cur_tick)

########NEW FILE########
__FILENAME__ = statusiconmanager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import horizons.globals

from fife import fife
from fife.extensions.pychan.widgets import Icon

from horizons.world.status import StatusIcon
from horizons.messaging import AddStatusIcon, RemoveStatusIcon, WorldObjectDeleted, HoverInstancesChanged
from horizons.gui.mousetools import NavigationTool

class StatusIconManager(object):
	"""Manager class that manages all status icons. It listenes to AddStatusIcon
	and RemoveStatusIcon messages on the main message bus"""

	def __init__(self, renderer, layer):
		"""
		@param renderer: Renderer used to render the icons
		@param layer: map layer, needed to place icon
		"""
		self.layer = layer
		self.renderer = renderer

		# {instance: [list of icons]}
		self.icons = {}

		self.tooltip_instance = None # no weakref:
		# we need to remove the tooltip always anyway, and along with it the entry here
		self.tooltip_icon = Icon(position=(1, 1)) # 0, 0 is currently not supported by tooltips

		AddStatusIcon.subscribe(self.on_add_icon_message)
		HoverInstancesChanged.subscribe(self.on_hover_instances_changed)
		RemoveStatusIcon.subscribe(self.on_remove_icon_message)
		WorldObjectDeleted.subscribe(self.on_worldobject_deleted_message)

	def end(self):
		self.tooltip_instance = None
		self.tooltip_icon.hide_tooltip()
		self.tooltip_icon = None

		self.renderer = None
		self.icons = None

		AddStatusIcon.unsubscribe(self.on_add_icon_message)
		HoverInstancesChanged.unsubscribe(self.on_hover_instances_changed)
		RemoveStatusIcon.unsubscribe(self.on_remove_icon_message)
		WorldObjectDeleted.unsubscribe(self.on_worldobject_deleted_message)

	def on_add_icon_message(self, message):
		"""This is called by the message bus with AddStatusIcon messages"""
		assert isinstance(message, AddStatusIcon)
		icon_instance = message.icon.instance
		if not icon_instance in self.icons:
			self.icons[icon_instance] = []
		assert not message.icon in self.icons[icon_instance]
		self.icons[icon_instance].append(message.icon)
		# Sort, make sure highest icon is at top
		self.icons[icon_instance] = sorted(self.icons[icon_instance], key=StatusIcon.get_sorting_key(), reverse=True)
		# Now render the most important one
		self.__render_status(icon_instance, self.icons[icon_instance][0])

		if self.tooltip_instance is not None and self.tooltip_instance is icon_instance: # possibly have to update tooltip
			self.on_hover_instances_changed( HoverInstancesChanged(self, [self.tooltip_instance]) )

	def on_worldobject_deleted_message(self, message):
		assert isinstance(message, WorldObjectDeleted)
		# remove icon
		if message.worldobject in self.icons:
			self.renderer.removeAll(self.get_status_string(message.worldobject))
			del self.icons[message.worldobject]
		# remove icon tooltip
		if message.worldobject is self.tooltip_instance:
			self.on_hover_instances_changed( HoverInstancesChanged(self, []) )

	def on_remove_icon_message(self, message):
		"""Called by the MessageBus with RemoveStatusIcon messages."""
		assert isinstance(message, RemoveStatusIcon)
		icon_instance = message.instance
		if icon_instance in self.icons:
			for registered_icon in self.icons[icon_instance][:]:
				if message.icon_class is registered_icon.__class__:
					self.icons[icon_instance].remove(registered_icon)
					if not self.icons[icon_instance]:
						# No icon left for this building, remove it
						self.renderer.removeAll(self.get_status_string(icon_instance))
						del self.icons[icon_instance]
					else:
						# Render next icon
						self.__render_status(icon_instance, self.icons[icon_instance][0])
					break

			if self.tooltip_instance is not None and self.tooltip_instance is icon_instance: # possibly have to update tooltip
				self.on_hover_instances_changed( HoverInstancesChanged(self, [self.tooltip_instance]) )

	def __render_status(self, instance, status):
		status_string = self.get_status_string(instance)

		# Clear icons
		self.renderer.removeAll(status_string)

		# pixel-offset on screen (will be constant across zoom-levels)
		rel = fife.Point(0, -30)

		pos = instance.position

		# trial and error has brought me to this (it's supposed to hit the center)
		x = pos.origin.x + (pos.width / 4.0)
		y = pos.origin.y + (pos.height / 4.0)
		loc = fife.Location(self.layer)
		loc.setExactLayerCoordinates(fife.ExactModelCoordinate(x, y))

		node = fife.RendererNode(loc, rel)

		try: # to load an animation
			anim = horizons.globals.fife.animationloader.loadResource(status.icon)
			self.renderer.addAnimation(status_string, node, anim)
		except ValueError:
			img = horizons.globals.fife.imagemanager.load(status.icon)
			self.renderer.addImage(status_string, node, img)

	def get_status_string(self, instance):
		"""Returns render name for status icons of this instance"""
		status_string = "status_"+ str(id(instance))
		return status_string

	def on_hover_instances_changed(self, msg):
		"""Check if we need to display a tooltip"""
		instances = msg.instances

		# only those that have icons
		instances = (i for i in instances if i in self.icons)
		# and belong to the player
		instances = [i for i in instances if
		             hasattr(i, "owner" ) and
		             hasattr(i.owner, "is_local_player") and
		             i.owner.is_local_player]

		if not instances:
			# hide
			self.tooltip_instance = None
			self.tooltip_icon.hide_tooltip()
		else:
			# get tooltip text, set, position and show
			self.tooltip_instance = instances[0] # pick any (usually ordered by fife)

			icons_of_instance = self.icons[self.tooltip_instance]
			icon = max(icons_of_instance, key=StatusIcon.get_sorting_key())

			self.tooltip_icon.helptext = icon.helptext

			pos = NavigationTool.last_event_pos
			self.tooltip_icon.position_tooltip( (pos.x, pos.y) )
			self.tooltip_icon.show_tooltip()

########NEW FILE########
__FILENAME__ = player
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import collections

import horizons.main

from horizons.constants import PLAYER
from horizons.world.playerstats import PlayerStats
from horizons.util.color import Color
from horizons.util.difficultysettings import DifficultySettings
from horizons.util.inventorychecker import InventoryChecker
from horizons.util.python import decorators
from horizons.util.worldobject import WorldObject
from horizons.scenario import CONDITIONS
from horizons.scheduler import Scheduler
from horizons.component.componentholder import ComponentHolder
from horizons.component.storagecomponent import StorageComponent
from horizons.messaging import SettlerUpdate, PlayerInventoryUpdated, PlayerLevelUpgrade
from horizons.component.tradepostcomponent import TradePostComponent

class Player(ComponentHolder, WorldObject):
	"""Class representing a player"""

	STATS_UPDATE_INTERVAL = 3 # seconds

	regular_player = True # either a human player or a normal AI player (not trader or pirate)
	component_templates = ({'StorageComponent': {'PositiveStorage': {}}},)


	def __init__(self, session, worldid, name, color, clientid=None, difficulty_level=None):
		"""
		@param session: Session instance
		@param worldid: player's worldid
		@param name: user-chosen name
		@param color: color of player (as Color)
		@param clientid: id of client
		@param inventory: {res: value} that are put in the players inventory
		"""
		if False:
			assert isinstance(session, horizons.session.Session)
		self.session = session
		super(Player, self).__init__(worldid=worldid)
		self.__init(name, color, clientid, difficulty_level, 0)

	def initialize(self, inventory):
		super(Player, self).initialize()
		if inventory:
			for res, value in inventory.iteritems():
				self.get_component(StorageComponent).inventory.alter(res, value)

	def __init(self, name, color, clientid, difficulty_level, max_tier_notification, settlerlevel=0):
		assert isinstance(color, Color)
		assert isinstance(name, basestring) and name
		try:
			self.name = unicode(name)
		except UnicodeDecodeError:
			# WORKAROUND: this line should be the only unicode conversion here.
			# however, if unicode() gets a parameter, it will fail if the string is already unicode.
			self.name = unicode(name, errors='ignore')
		self.color = color
		self.clientid = clientid
		self.difficulty = DifficultySettings.get_settings(difficulty_level)
		self.max_tier_notification = max_tier_notification
		self.settler_level = settlerlevel
		self._stats = None
		assert self.color.is_default_color, "Player color has to be a default color"

		if self.regular_player:
			SettlerUpdate.subscribe(self.notify_settler_reached_level)

	@property
	def is_local_player(self):
		return self is self.session.world.player

	def get_latest_stats(self):
		if self._stats is None or self._stats.collection_tick + PLAYER.STATS_UPDATE_FREQUENCY < Scheduler().cur_tick:
			self._stats = PlayerStats(self)
		return self._stats

	@property
	def settlements(self):
		"""Calculate settlements dynamically to save having a redundant list here"""
		return [ settlement for settlement in self.session.world.settlements if
		         settlement.owner == self ]

	def save(self, db):
		super(Player, self).save(db)
		client_id = None
		if self.clientid is not None or self is self.session.world.player:
			client_id = self.clientid
		db("INSERT INTO player"
			" (rowid, name, color, client_id, settler_level,"
			" difficulty_level, max_tier_notification)"
			" VALUES(?, ?, ?, ?, ?, ?, ?)",
			self.worldid, self.name, self.color.id, client_id, self.settler_level,
			self.difficulty.level if self.difficulty is not None else None,
			self.max_tier_notification)

	@classmethod
	def load(cls, session, db, worldid):
		self = cls.__new__(cls)
		self.session = session
		self._load(db, worldid)
		return self

	def _load(self, db, worldid):
		"""This function makes it possible to load playerdata into an already allocated
		Player instance, which is used e.g. in Trader.load"""
		super(Player, self).load(db, worldid)

		color, name, client_id, settlerlevel, difficulty_level, max_tier_notification = db(
			"SELECT color, name, client_id, settler_level, difficulty_level, max_tier_notification"
			" FROM player WHERE rowid = ?", worldid)[0]
		self.__init(name, Color[color], client_id, difficulty_level, max_tier_notification, settlerlevel = settlerlevel)

	def notify_settler_reached_level(self, message):
		"""Settler calls this to notify the player."""
		if message.sender.owner is not self:
			return
		if message.level > self.settler_level:
			self.settler_level = message.level
			self.session.scenario_eventhandler.check_events(CONDITIONS.settler_level_greater)
			for settlement in self.settlements:
				settlement.level_upgrade(self.settler_level)
			self._changed()
			PlayerLevelUpgrade.broadcast(self, self.settler_level, message.sender)

	def end(self):
		self._stats = None
		self.session = None

		if self.regular_player:
			SettlerUpdate.unsubscribe(self.notify_settler_reached_level)

	@decorators.temporary_cachedmethod(timeout=STATS_UPDATE_INTERVAL)
	def get_balance_estimation(self):
		"""This takes a while to calculate, so only do it every 2 seconds at most"""
		return sum(settlement.balance for settlement in self.settlements)

	@decorators.temporary_cachedmethod(timeout=STATS_UPDATE_INTERVAL)
	def get_statistics(self):
		"""Returns a namedtuple containing player-wide statistics"""
		Data = collections.namedtuple('Data', ['running_costs', 'taxes', 'sell_income', 'buy_expenses', 'balance'])
		# balance is duplicated here and above such that the version above
		# can be used independently and the one here is always perfectly in sync
		# with the other values here

		get_sum = lambda l, attr : sum ( getattr(obj, attr) for obj in l )
		trade_posts = [ s.get_component(TradePostComponent) for s in self.settlements ]
		return Data(
		  running_costs = get_sum(self.settlements, 'cumulative_running_costs'),
		  taxes = get_sum(self.settlements, 'cumulative_taxes'),
		  sell_income = get_sum(trade_posts, 'sell_income'),
		  buy_expenses = get_sum(trade_posts, 'buy_expenses'),
		  balance = get_sum(self.settlements, 'balance'),
		)


class HumanPlayer(Player):
	"""Class for players that physically sit in front of the machine where the game is run"""

	def __init(self, *args, **kwargs):
		super(HumanPlayer, self).__init(*args, **kwargs)
		self.__inventory_checker = InventoryChecker(PlayerInventoryUpdated, self.get_component(StorageComponent), 4)

	def end(self):
		if hasattr(self, '__inventory_checker'):
			self.__inventory_checker.remove()
		super(HumanPlayer, self).end()

########NEW FILE########
__FILENAME__ = playerstats
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import math

from collections import defaultdict

from horizons.util.worldobject import WorldObject
from horizons.entities import Entities
from horizons.constants import TIER, BUILDINGS, PRODUCTION, RES, UNITS
from horizons.util.python import decorators
from horizons.component.collectingcomponent import CollectingComponent
from horizons.component.storagecomponent import StorageComponent
from horizons.component.selectablecomponent import SelectableComponent
from horizons.world.production.producer import Producer
from horizons.scheduler import Scheduler

class PlayerStats(WorldObject):
	def __init__(self, player):
		super(PlayerStats, self).__init__()
		self.player = player
		self.db = player.session.db
		self._collect_info()
		self.collection_tick = Scheduler().cur_tick

	def _collect_info(self):
		settlers = defaultdict(int)
		settler_buildings = defaultdict(int)
		settler_resources_provided = defaultdict(int)
		buildings = defaultdict(int)
		available_resources = defaultdict(int)
		total_resources = defaultdict(int)
		ships = defaultdict(int)
		running_costs = 0
		taxes = 0
		usable_land = 0
		settlements = 0

		for settlement in self.player.settlements:
			for building in settlement.buildings:
				buildings[building.id] += 1

				# collect info about settlers
				if building.id == BUILDINGS.RESIDENTIAL:
					settlers[building.level] += building.inhabitants
					settler_buildings[building.level] += 1
					for production in building.get_component(Producer).get_productions():
						if production.get_state() is PRODUCTION.STATES.producing:
							produced_resources = production.get_produced_resources()
							if RES.HAPPINESS in produced_resources:
								happiness = produced_resources[RES.HAPPINESS]
								for resource_id in production.get_consumed_resources():
									settler_resources_provided[resource_id] += happiness / production.get_production_time()

				# resources held in buildings
				if building.has_component(StorageComponent) and building.id not in [BUILDINGS.WAREHOUSE, BUILDINGS.STORAGE, BUILDINGS.MAIN_SQUARE]:
					for resource_id, amount in building.get_component(StorageComponent).inventory.itercontents():
						total_resources[resource_id] += amount

				# resources held by collectors
				if building.has_component(CollectingComponent):
					for collector in building.get_component(CollectingComponent).get_local_collectors():
						for resource_id, amount in collector.get_component(StorageComponent).inventory.itercontents():
							total_resources[resource_id] += amount

			# resources in settlement inventories
			for resource_id, amount in settlement.get_component(StorageComponent).inventory.itercontents():
				available_resources[resource_id] += amount

			# land that could be built on (the building on it may need to be destroyed first)
			for tile in settlement.ground_map.itervalues():
				if 'constructible' in tile.classes:
					usable_land += 1

			settlements += 1
			running_costs += settlement.cumulative_running_costs
			taxes += settlement.cumulative_taxes

		# resources in player controlled ships
		for ship in self.player.session.world.ships:
			if ship.owner is self.player:
				ships[ship.id] += 1
				if ship.has_component(SelectableComponent):
					for resource_id, amount in ship.get_component(StorageComponent).inventory.itercontents():
						available_resources[resource_id] += amount

		for resource_id, amount in available_resources.iteritems():
			total_resources[resource_id] += amount

		self._calculate_settler_score(settlers, settler_buildings, settler_resources_provided)
		self._calculate_building_score(buildings)
		self._calculate_resource_score(available_resources, total_resources)
		self._calculate_unit_score(ships)
		self._calculate_land_score(usable_land, settlements)
		self._calculate_money_score(running_costs, taxes, self.player.get_component(StorageComponent).inventory[RES.GOLD])
		self._calculate_total_score()

	settler_values = {
			TIER.SAILORS: 2,
			TIER.PIONEERS: 3,
			TIER.SETTLERS: 7,
			TIER.CITIZENS: 15,
			}
	settler_building_values = {
			TIER.SAILORS: 3,
			TIER.PIONEERS: 5,
			TIER.SETTLERS: 11,
			TIER.CITIZENS: 19,
			}
	settler_resource_provided_coefficient = 0.1
	settler_score_coefficient = 0.3

	def _calculate_settler_score(self, settlers, settler_buildings, settler_resources_provided):
		total = 0
		for level, number in settlers.iteritems():
			total += self.settler_values[level] * number
		for level, number in settler_buildings.iteritems():
			total += self.settler_building_values[level] * number
		for amount in settler_resources_provided.itervalues():
			total += amount * self.settler_resource_provided_coefficient
		self.settler_score = int(total * self.settler_score_coefficient)

	building_score_coefficient = 0.006

	def _calculate_building_score(self, buildings):
		total = 0
		resources = defaultdict(int)
		for building_id, amount in buildings.iteritems():
			for resource_id, res_amount in Entities.buildings[building_id].costs.iteritems():
				resources[resource_id] += amount * res_amount
		for resource_id, amount in resources.iteritems():
			if resource_id == RES.GOLD:
				total += amount # for some reason the value of gold is 0 by default
			else:
				total += amount * self.db.get_res_value(resource_id)
		self.building_score = int(total * self.building_score_coefficient)

	unavailable_resource_coefficient = 0.3 # the resource exists but isn't usable so it is worth less
	overridden_resource_values = {RES.RAW_CLAY: 1, RES.RAW_IRON: 3}
	resource_score_coefficient = 0.01

	def _calculate_resource_score(self, available_resources, total_resources):
		total = 0
		for resource_id, amount in available_resources.iteritems():
			if resource_id in self.overridden_resource_values: # natural resources have 0 value by default
				total += amount * self.overridden_resource_values[resource_id]
			else:
				value = self.db.get_res_value(resource_id)
				if value is not None: # happiness and some coverage resources have no value
					total += amount * value
		for resource_id, amount in total_resources.iteritems():
			extra_amount = (amount - available_resources[resource_id])
			if resource_id in self.overridden_resource_values: # natural resources have 0 value by default
				total += extra_amount * self.overridden_resource_values[resource_id] * self.unavailable_resource_coefficient
			else:
				value = self.db.get_res_value(resource_id)
				if value is not None: # happiness and some coverage resources have no value
					total += extra_amount * value * self.unavailable_resource_coefficient
		self.resource_score = int(total * self.resource_score_coefficient)

	unit_value = {UNITS.FRIGATE: 1.5, UNITS.PLAYER_SHIP: 1, UNITS.USABLE_FISHER_BOAT: 1, UNITS.FISHER_BOAT: 0.05}
	unit_score_coefficient = 10

	def _calculate_unit_score(self, ships):
		total = 0
		for unit_id, amount in ships.iteritems():
			total += self.unit_value[unit_id] * amount
		self.unit_score = int(total * self.unit_score_coefficient)

	settlement_value = 30
	land_score_coefficient = 0.03

	def _calculate_land_score(self, usable_land, settlements):
		total = 0
		total += usable_land
		total += self.settlement_value * settlements
		self.land_score = int(total * self.land_score_coefficient)

	running_cost_coefficient = 10
	minimum_money = 500
	money_power = 0.4
	money_score_coefficient = 1.3

	def _calculate_money_score(self, running_costs, taxes, money):
		total = 0
		total += money
		total += self.running_cost_coefficient * (taxes - running_costs)
		total = math.pow(max(self.minimum_money, total), self.money_power)
		self.money_score = int(total * self.money_score_coefficient)

	def _calculate_total_score(self):
		self.total_score = self.settler_score + self.building_score + self.resource_score + self.unit_score + self.land_score + self.money_score

decorators.bind_all(PlayerStats)

########NEW FILE########
__FILENAME__ = producer
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.world.production.productionline import ProductionLine
from horizons.world.production.production import Production, SingleUseProduction
from horizons.constants import PRODUCTION
from horizons.scheduler import Scheduler
from horizons.util.python import decorators
from horizons.util.shapes import Circle, Point
from horizons.component.storagecomponent import StorageComponent
from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.component import Component
from horizons.world.status import ProductivityLowStatus, DecommissionedStatus, InventoryFullStatus
from horizons.world.production.unitproduction import UnitProduction
from horizons.command.unit import CreateUnit
from horizons.util.changelistener import metaChangeListenerDecorator
from horizons.messaging import AddStatusIcon, RemoveStatusIcon
from horizons.world.production.utilization import Utilization, FullUtilization, FieldUtilization
from horizons.util.python.callback import Callback
from horizons.component.namedcomponent import NamedComponent
from horizons.messaging import MineEmpty

@metaChangeListenerDecorator("production_finished")
@metaChangeListenerDecorator("activity_changed")
class Producer(Component):
	"""Class for objects, that produce something.
	@param auto_init: bool. If True, the producer automatically adds one
	production for each production_line.
	"""
	log = logging.getLogger("world.production")

	NAME = "producer"
	DEPENDENCIES = [StorageComponent]

	utilization_mapping = {
	    'FieldUtilization': FieldUtilization,
	    'FullUtilization': FullUtilization
	}

	production_class = Production

	# INIT
	def __init__(self, auto_init=True, start_finished=False, productionlines=None,
	             utilization_calculator=None, is_mine_for=None, settler_upgrade_lines=None,
	             **kwargs):
		"""
		@param productionline: yaml-dict for prod line data. Must not be changed since it is cached.
		@param utilization_calculator: one of utilization_mapping
		@param settler_upgrade_lines: data for settler upgrades. can one day be generalized to other upgrades
		"""
		if productionlines is None:
			productionlines = {}
		super(Producer, self).__init__(**kwargs)
		self.__auto_init = auto_init
		self.__start_finished = start_finished
		self.production_lines = productionlines
		assert utilization_calculator is not None
		self.__utilization = utilization_calculator

		if settler_upgrade_lines:
			from horizons.world.building.settler import SettlerUpgradeData
			self.settler_upgrade_lines = SettlerUpgradeData(self, settler_upgrade_lines)

			self.production_lines = self.production_lines.copy()
			self.production_lines.update(self.settler_upgrade_lines.get_production_lines())
		else:
			self.settler_upgrade_lines = None


	def __init(self):
		# we store productions in 2 dicts, one for the active ones, and one for the inactive ones.
		# the inactive ones won't get considered for needed_resources and such.
		# the production_line id is the key in the dict (=> a building must not have two identical
		# production lines)
		self._productions = {}
		self._inactive_productions = {}
		# Store whether or not the producer is active
		self.__active = True
		# Store whether or not the utilization level is currently ok
		self.__utilization_ok = True

		# BIG FAT NOTE: this has to be executed for all players for mp
		# even if this building has no status icons
		# TODO: think about whether this is enough gui-related so it belongs to the ExtScheduler
		# also check its performance when moving
		interval = Scheduler().get_ticks(3)
		run_in = self.session.random.randint(1, interval) # don't update all at once
		if self.instance.has_status_icon:
			Scheduler().add_new_object(self.update_capacity_utilization, self, run_in=run_in,
			                           loops=-1, loop_interval=interval)

	def initialize(self):
		self.__init()
		# add production lines as specified in db.
		if self.__auto_init:
			for prod_line, attributes in self.production_lines.iteritems():
				if 'enabled_by_default' in attributes and not attributes['enabled_by_default']:
					continue  # It's set to False, don't add
				prod = self.create_production(prod_line)
				self.add_production(prod)
		# For newly built producers we set the utilization to full for the first
		# few seconds, this avoids the low productivity icon being shown every
		# time a new producer is built
		temp_util = self.__utilization
		self.__utilization = FullUtilization()
		Scheduler().add_new_object(Callback(self.__set_utilization, temp_util), self, Scheduler().get_ticks(15))

	def get_production_lines_by_level(self, level):
		prod_lines = []
		for key, data in self.production_lines.iteritems():
			if 'level' in data and level in data['level']:
				prod_lines.append(key)
		return prod_lines

	def create_production(self, id, load=False):
		"""
		@param id: production line id
		@param load: whether the production is used for loading.
		"""
		data = self.production_lines[id]
		production_class = self.production_class
		owner_inventory = self.instance._get_owner_inventory()

		# not really fancy way of selecting special production class
		if self.settler_upgrade_lines:
			if id == self.settler_upgrade_lines.get_production_line_id(self.instance.level+1):
				production_class = SingleUseProduction

		return production_class(inventory=self.instance.get_component(StorageComponent).inventory,
		                        owner_inventory=owner_inventory, prod_id=id, prod_data=data,
		                        load=load, start_finished=self.__start_finished)

	def create_production_line(self, id):
		"""Creates a production line instance, this is meant only for data transfer and READONLY use!
		If you want to use production lines for anything else, go the proper way of the production class."""
		assert id in self.production_lines
		data = self.production_lines[id]
		return ProductionLine(id, data)

	def add_production_by_id(self, production_line_id):
		"""Convenience method.
		@param production_line_id: Production line from db
		"""
		production = self.create_production(production_line_id)
		self.add_production( production )
		return production

	def update_capacity_utilization(self):
		"""Called by the scheduler to update the utilization regularly"""
		if not self.capacity_utilization_below(ProductivityLowStatus.threshold) is not self.__utilization_ok:
			self.__utilization_ok = not self.__utilization_ok
			if self.__utilization_ok:
				RemoveStatusIcon.broadcast(self, self.instance, ProductivityLowStatus)
			else:
				icon = ProductivityLowStatus(self.instance)
				AddStatusIcon.broadcast(self, icon)

	@property
	def capacity_utilization(self):
		return self.__utilization.capacity_utilization(self)

	def capacity_utilization_below(self, limit):
		return self.__utilization.capacity_utilization_below(limit, self)

	def load(self, db, worldid):
		# Call this before super, because we have to make sure this is called before the
		# ConcreteObject's callback which is added during loading
		Scheduler().add_new_object(self._on_production_change, self, run_in=0)
		super(Producer, self).load(db, worldid)
		# load all productions
		self.__init()
		for line_id in db.get_production_lines_by_owner(worldid):
			production = self.create_production(line_id, load=True)
			assert isinstance(production, Production)
			production.load(db, worldid)
			self.add_production(production)

		self._update_decommissioned_icon()

	def save(self, db):
		super(Producer, self).save(db)
		for production in self.get_productions():
			production.save(db, self.instance.worldid)

	# INTERFACE
	def add_production(self, production):
		assert isinstance(production, Production)
		self.log.debug('%s: added production line %s', self, production.get_production_line_id())
		if production.is_paused():
			self.log.debug('%s: added production line %s is paused', self, production.get_production_line_id())
			self._inactive_productions[production.get_production_line_id()] = production
		else:
			self.log.debug('%s: added production line %s is active', self, production.get_production_line_id())
			self._productions[production.get_production_line_id()] = production
		production.add_production_finished_listener(self._production_finished)
		# This would be called multiple times during init, just add it later this tick.
		# It also ensures that the changelistener would stick, we used to readd
		# the listener in load(), which was explained by this comment:
			# Listener has been removed in the productions.load(), because the
			# changelistener's load is called
		Scheduler().add_new_object(
		  Callback(production.add_change_listener, self._on_production_change, call_listener_now=True), self, run_in=0
		)
		self.instance._changed()

	def _production_finished(self, production):
		"""Gets called when a production finishes. Intercepts call, adds info
		and forwards it"""
		produced_resources = production.get_produced_resources()
		self.on_production_finished(produced_resources)

	def finish_production_now(self):
		"""Cheat, makes current production finish right now (and produce the resources).
		Useful to make trees fully grown at game start."""
		for production in self._productions.itervalues():
			production.finish_production_now()

	def has_production_line(self, prod_line_id):
		"""Checks if this instance has a production with a certain production line id"""
		return bool( self._get_production(prod_line_id) )

	def remove_production(self, production):
		"""Removes a production instance.
		@param production: Production instance"""
		production.remove() # production "destructor"
		if self.is_active(production):
			del self._productions[production.get_production_line_id()]
			# update decommissioned icon after removing production
			self._update_decommissioned_icon()

			self.instance._changed()
			self.on_activity_changed(self.is_active())

		else:
			del self._inactive_productions[production.get_production_line_id()]

	def remove_production_by_id(self, prod_line_id):
		"""
		Convenience method. Assumes, that this production line id has been added to this instance.
		@param prod_line_id: production line id to remove
		"""
		self.remove_production( self._get_production(prod_line_id) )

	def alter_production_time(self, modifier, prod_line_id=None):
		"""Multiplies the original production time of all production lines by modifier
		@param modifier: a numeric value
		@param prod_line_id: id of production line to alter. None means every production line"""
		if prod_line_id is None:
			for production in self.get_productions():
				production.alter_production_time(modifier)
		else:
			self._get_production(prod_line_id).alter_production_time(modifier)

	def remove(self):
		Scheduler().rem_all_classinst_calls(self)
		for production in self.get_productions():
			self.remove_production(production)
		# call super() after removing all productions since it removes the instance (make it invalid)
		# which can be needed by changelisteners' actions (e.g. in remove_production method)
		super(Producer, self).remove()
		assert not self.get_productions(), 'Failed to remove %s ' % self.get_productions()


	# PROTECTED METHODS
	def _get_current_state(self):
		"""Returns the current state of the producer. It is the most important
		state of all productions combined. Check the PRODUCTION.STATES constant
		for list of states and their importance."""
		current_state = PRODUCTION.STATES.none
		for production in self.get_productions():
			state = production.get_animating_state()
			if state is not None and current_state < state:
				current_state = state
		return current_state

	def get_productions(self):
		"""Returns all productions, inactive and active ones, as list"""
		return self._productions.values() + self._inactive_productions.values()

	def get_production_lines(self):
		"""Returns all production lines that have been added.
		@return: a list of prodline ids"""
		return self._productions.keys() + self._inactive_productions.keys()

	def _get_production(self, prod_line_id):
		"""Returns a production of this producer by a production line id.
		@return: instance of Production or None"""
		if prod_line_id in self._productions:
			return self._productions[prod_line_id]
		elif prod_line_id in self._inactive_productions:
			return self._inactive_productions[prod_line_id]
		else:
			return None

	def is_active(self, production=None):
		"""Checks if a production, or the at least one production if production is None, is active"""
		if production is None:
			for production in self.get_productions():
				if not production.is_paused():
					return True
			return False
		else:
			assert production.get_production_line_id() in self._productions or \
			       production.get_production_line_id() in self._inactive_productions
			return not production.is_paused()

	def set_active(self, production=None, active=True):
		"""Pause or unpause a production (aka set it active/inactive).
		see also: is_active, toggle_active
		@param production: instance of Production. if None, we do it to all productions.
		@param active: whether to set it active or inactive"""
		if production is None:
			# set all
			for production in self.get_productions():
				self.set_active(production, active)
		else:
			line_id = production.get_production_line_id()
			if active:
				if not self.is_active(production):
					self.log.debug("ResHandler %s: reactivating production %s", self.instance.worldid, line_id)
					self._productions[line_id] = production
					del self._inactive_productions[line_id]
					production.pause(pause=False)
			else:
				if self.is_active(production):
					self.log.debug("ResHandler %s: deactivating production %s", self.instance.worldid, line_id)
					self._inactive_productions[line_id] = production
					del self._productions[line_id]
					production.pause()
			self._update_decommissioned_icon()

		self.instance._changed()
		self.on_activity_changed(self.is_active())

	def _update_decommissioned_icon(self):
		"""Add or remove decommissioned icon."""
		if not self.instance.has_status_icon:
			return

		if self.is_active() is not self.__active:
			self.__active = not self.__active
			if self.__active:
				RemoveStatusIcon.broadcast(self, self.instance, DecommissionedStatus)
			else:
				icon = DecommissionedStatus(self.instance)
				AddStatusIcon.broadcast(self, icon)

	def toggle_active(self, production=None):
		if production is None:
			for production in self.get_productions():
				self.toggle_active(production)
		else:
			active = self.is_active(production)
			self.set_active(production, active = not active)

	def _on_production_change(self):
		"""Makes the instance act according to the producers
		current state"""
		state = self._get_current_state()
		new_action = 'idle'
		if state is PRODUCTION.STATES.producing:
			new_action = "work"
		elif state is PRODUCTION.STATES.inventory_full:
			new_action = "idle_full"

		# don't force restarts as not to disturb sequences such as tree growth
		self.instance.act(new_action, repeating=True, force_restart=False)

		if self.instance.has_status_icon:
			full = state is PRODUCTION.STATES.inventory_full
			if full and not hasattr(self, "_producer_status_icon"):
				affected_res = set() # find them:
				for prod in self.get_productions():
					affected_res = affected_res.union( prod.get_unstorable_produced_res() )
				self._producer_status_icon = InventoryFullStatus(self.instance, affected_res)
				AddStatusIcon.broadcast(self, self._producer_status_icon)

			if not full and hasattr(self, "_producer_status_icon"):
				RemoveStatusIcon.broadcast(self, self.instance, InventoryFullStatus)
				del self._producer_status_icon

	def get_status_icons(self):
		l = super(Producer, self).get_status_icons()
		if self.capacity_utilization_below(ProductivityLowStatus.threshold):
			l.append( ProductivityLowStatus() )
		return l

	def __str__(self):
		return "Producer(owner: " + str(self.instance) + ")"

	def get_production_progress(self):
		"""Returns the current progress of the active production."""
		for production in self._productions.itervalues():
			# Always return first production
			return production.progress
		for production in self._inactive_productions.itervalues():
			# try inactive ones, if no active ones are found
			# this makes e.g. the boatbuilder's progress bar constant when you pause it
			return production.progress
		return 0 # No production available

	def __set_utilization(self, utilization):
		self.__utilization = utilization

	@classmethod
	def get_instance(cls, arguments=None):
		arguments = arguments and arguments.copy() or {}

		utilization = None
		if 'utilization' in arguments:
			if arguments['utilization'] in cls.utilization_mapping:
				utilization = cls.utilization_mapping[arguments['utilization']]()
			del arguments['utilization']
		else:
			utilization = Utilization()

		if arguments.get('is_mine_for'):
			# this is more of an aspect than an actual subclass, but python doesn't allow
			# fast aspect-oriented programming
			cls = MineProducer

		return cls(utilization_calculator=utilization, **arguments)


class MineProducer(Producer):
	"""Normal producer that can irrecoverably run out of resources and handles this case"""
	def set_active(self, production=None, active=True):
		super(MineProducer, self).set_active(production, active)
		# check if the user set it to waiting_for_res (which doesn't do anything)
		if active and self._get_current_state() == PRODUCTION.STATES.waiting_for_res:
			super(MineProducer, self).set_active(production, active=False)
			AmbientSoundComponent.play_special('error')

	def _on_production_change(self):
		super(MineProducer, self)._on_production_change()
		if self._get_current_state() == PRODUCTION.STATES.waiting_for_res:
			# this is never going to change, the building is useless now.
			if self.is_active():
				self.set_active(active=False)
			MineEmpty.broadcast(self, self.instance)


class QueueProducer(Producer):
	"""The QueueProducer stores all productions in a queue and runs them one
	by one. """

	production_class = SingleUseProduction

	def __init__(self, **kwargs):
		super(QueueProducer, self).__init__(auto_init=False, **kwargs)
		self.__init()

	def __init(self):
		self.production_queue = [] # queue of production line ids

	def save(self, db):
		super(QueueProducer, self).save(db)
		for i in enumerate(self.production_queue):
			position, prod_line_id = i
			db("INSERT INTO production_queue (object, position, production_line_id) VALUES(?, ?, ?)",
			   self.instance.worldid, position, prod_line_id)

	def load(self, db, worldid):
		super(QueueProducer, self).load(db, worldid)
		self.__init()
		for (prod_line_id,) in db("SELECT production_line_id FROM production_queue WHERE object = ? ORDER by position", worldid):
			self.production_queue.append(prod_line_id)

	def add_production_by_id(self, production_line_id):
		"""Convenience method.
		@param production_line_id: Production line from db
		"""
		self.production_queue.append(production_line_id)
		if not self.is_active():
			# Remove all calls to start_next_production
			# These might still be scheduled if the last production finished
			# in the same tick as this one is being added in
			Scheduler().rem_call(self, self.start_next_production)

			self.start_next_production()


	def check_next_production_startable(self):
		# See if we can start the next production, this only works if the current
		# production is done
		state = self._get_current_state()
		return len(self.production_queue) > 0 and \
		       (state is PRODUCTION.STATES.done or
		        state is PRODUCTION.STATES.none)

	def on_queue_element_finished(self, production):
		"""Callback used for the SingleUseProduction"""
		self.remove_production(production)
		Scheduler().add_new_object(self.start_next_production, self)

	def start_next_production(self):
		"""Starts the next production that is in the queue, if there is one."""
		if self.check_next_production_startable():
			self._productions.clear() # Make sure we only have one production active
			production_line_id = self.production_queue.pop(0)
			prod = self.create_production(production_line_id)
			prod.add_production_finished_listener(self.on_queue_element_finished)
			self.add_production( prod )
			self.set_active(production=prod, active=True)
		else:
			self.set_active(active=False)

	def cancel_all_productions(self):
		self.production_queue = []
		self.cancel_current_production()

	def cancel_current_production(self):
		"""Cancels the current production and proceeds to the next one, if there is one"""
		# Remove current productions, lose all progress and resources
		for production in self._productions.copy().itervalues():
			self.remove_production(production)
		for production in self._inactive_productions.copy().itervalues():
			self.remove_production(production)
		if self.production_queue:
			self.start_next_production()
		else:
			self.set_active(active=False)

	def remove_from_queue(self, index):
		"""Remove the index'th element from the queue. First element is 0"""
		self.production_queue.pop(index)
		self.instance._changed()


class UnitProducer(QueueProducer):
	"""Uses queues to produce naval units"""

	production_class = UnitProduction

	def get_unit_production_queue(self):
		"""Returns a list unit type ids that are going to be produced.
		Does not include the currently produced unit. List is in order."""
		queue = []
		for prod_line_id in self.production_queue:
			prod_line = self.create_production_line(prod_line_id)
			units = prod_line.unit_production.keys()
			if len(units) > 1:
				print 'WARNING: unit production system has been designed for 1 type per order'
			queue.append(units[0])
		return queue

	def on_queue_element_finished(self, production):
		self.__create_unit()
		super(UnitProducer, self).on_queue_element_finished(production)

	def __create_unit(self):
		"""Create the produced unit now."""
		productions = self._productions.values()
		for production in productions:
			assert isinstance(production, UnitProduction)
			self.on_production_finished(production.get_produced_units())
			for unit, amount in production.get_produced_units().iteritems():
				for i in xrange(amount):
					self.__place_unit(unit)

	def __place_unit(self, unit):
		radius = 1
		found_tile = False
		# search for free water tile, and increase search radius if none is found
		while not found_tile:
			for coord in Circle(self.instance.position.center, radius).tuple_iter():
				point = Point(coord[0], coord[1])
				if self.instance.island.get_tile(point) is not None:
					continue
				tile = self.session.world.get_tile(point)
				if tile is not None and tile.is_water and coord not in self.session.world.ship_map:
					# execute bypassing the manager, it's simulated on every machine
					u = CreateUnit(self.instance.owner.worldid, unit, point.x, point.y)(issuer=self.instance.owner)
					# Fire a message indicating that the ship has been created
					name = u.get_component(NamedComponent).name
					self.session.ingame_gui.message_widget.add(string_id='NEW_UNIT', point=point,
					                                           message_dict={'name' : name})
					found_tile = True
					break
			radius += 1


decorators.bind_all(Producer)
decorators.bind_all(MineProducer)
decorators.bind_all(QueueProducer)
decorators.bind_all(UnitProducer)

########NEW FILE########
__FILENAME__ = production
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from collections import defaultdict, deque

from horizons.util.changelistener import metaChangeListenerDecorator, ChangeListener
from horizons.constants import PRODUCTION
from horizons.world.production.productionline import ProductionLine

from horizons.scheduler import Scheduler


@metaChangeListenerDecorator("production_finished")
class Production(ChangeListener):
	"""Class for production to be used by ResourceHandler.
	Controls production and starts it by watching the assigned building's inventory,
	which is virtually the only "interface" to the building.
	This ensures independence and encapsulation from the building code.

	A Production is active by default, but you can pause it.

	Before we can start production, we check certain assertions, i.e. if we have all the
	resources, that the production takes and if there is enough space to store the produced goods.

	It has basic states, which are useful for e.g. setting animation. Changes in state
	can be observed via ChangeListener interface."""
	log = logging.getLogger('world.production')

	# optimization:
	# the special resource gold is only stored in the player's inventory.
	# If productions want to use it, they will observer every change of it, which results in
	# a lot calls. Therefore, this is not done by default but only for few subclasses that actually need it.
	uses_gold = False

	keep_original_prod_line = False

	## INIT/DESTRUCT
	def __init__(self, inventory, owner_inventory, prod_id, prod_data,
	             start_finished=False, load=False, **kwargs):
		"""
		@param inventory: interface to the world, take res from here and put output back there
		@param owner_inventory: same as inventory, but for gold. Usually the players'.
		@param prod_id: int id of the production line
		@param prod_data: ?
		@param start_finished: Whether to start at the final state of a production
		@param load: set to True if this production is supposed to load a saved production
		"""
		super(Production, self).__init__(**kwargs)
		# this has grown to be a bit weird compared to other init/loads
		# __init__ is always called before load, therefore load just overwrites some of the values here
		self._state_history = deque()
		self.prod_id = prod_id
		self.prod_data = prod_data
		self.__start_finished = start_finished
		self.inventory = inventory
		self.owner_inventory = owner_inventory

		self._pause_remaining_ticks = None # only used in pause()
		self._pause_old_state = None # only used in pause()

		self._creation_tick = Scheduler().cur_tick

		assert isinstance(prod_id, int)
		self._prod_line = ProductionLine(id=prod_id, data=prod_data)

		if self.__class__.keep_original_prod_line: # used by unit productions
			self.original_prod_line = self._prod_line.get_original_copy()

		if not load:
			# init production to start right away

			if self.__start_finished:
				# finish the production
				self._give_produced_res()

			self._state = PRODUCTION.STATES.waiting_for_res
			self._add_listeners(check_now=True)

	def save(self, db, owner_id):
		"""owner_id: worldid of the owner of the producer object that owns this production"""
		self._clean_state_history()
		current_tick = Scheduler().cur_tick
		translated_creation_tick = self._creation_tick - current_tick + 1 #  pre-translate the tick number for the loading process

		remaining_ticks = None
		if self._state == PRODUCTION.STATES.paused:
			remaining_ticks = self._pause_remaining_ticks
		elif self._state == PRODUCTION.STATES.producing:
			remaining_ticks = Scheduler().get_remaining_ticks(self, self._get_producing_callback())
		# use a number > 0 for ticks
		if remaining_ticks < 1:
			remaining_ticks = 1
		db('INSERT INTO production(rowid, state, prod_line_id, remaining_ticks, \
		      _pause_old_state, creation_tick, owner) VALUES(?, ?, ?, ?, ?, ?, ?)',
		         None, self._state.index, self._prod_line.id, remaining_ticks,
		         None if self._pause_old_state is None else self._pause_old_state.index,
			    translated_creation_tick, owner_id)

		# save state history
		for tick, state in self._state_history:
				# pre-translate the tick number for the loading process
			translated_tick = tick - current_tick + 1
			db("INSERT INTO production_state_history(production, tick, state, object_id) VALUES(?, ?, ?, ?)",
				 self.prod_id, translated_tick, state, owner_id)

	def load(self, db, worldid):
		# NOTE: __init__ must have been called with load=True
		# worldid is the world id of the producer component instance calling this
		super(Production, self).load(db, worldid)

		db_data = db.get_production_by_id_and_owner(self.prod_id, worldid)
		self._creation_tick = db_data[5]
		self._state = PRODUCTION.STATES[db_data[0]]
		self._pause_old_state = None if db_data[4] is None else PRODUCTION.STATES[db_data[4]]
		if self._state == PRODUCTION.STATES.paused:
			self._pause_remaining_ticks = db_data[3]
		elif self._state == PRODUCTION.STATES.producing:
			Scheduler().add_new_object(self._get_producing_callback(), self, db_data[3])
		elif self._state == PRODUCTION.STATES.waiting_for_res or \
		     self._state == PRODUCTION.STATES.inventory_full:
			# no need to call now, this just restores the state before
			# saving, where it hasn't triggered yet, therefore it won't now
			self._add_listeners()

		self._state_history = db.get_production_state_history(worldid, self.prod_id)

	def remove(self):
		self._remove_listeners()
		Scheduler().rem_all_classinst_calls(self)
		super(Production, self).remove()

	## INTERFACE METHODS
	def get_production_line_id(self):
		"""Returns id of production line"""
		return self._prod_line.id

	def get_consumed_resources(self):
		"""Res that are consumed here. Returns dict {res:amount}. Interface for _prod_line."""
		return self._prod_line.consumed_res

	def get_produced_resources(self):
		"""Res that are produced here. Returns dict {res:amount}. Interface for _prod_line."""
		return self._prod_line.produced_res

	def get_production_time(self):
		return self._prod_line.time

	def get_produced_units(self):
		"""@return dict of produced units {unit_id: amount}"""
		return self._prod_line.unit_production

	def changes_animation(self):
		"""Returns whether the production should change the animation"""
		return self._prod_line.changes_animation

	def get_state(self):
		"""Returns the Production's current state"""
		return self._state

	def get_animating_state(self):
		"""Returns the production's current state,
		but only if it effects the animation, else None"""
		if self._prod_line.changes_animation:
			return self._state
		else:
			return None

	def toggle_pause(self):
		if self.is_paused():
			self.pause()
		else:
			self.pause(pause=False)

	def is_paused(self):
		return self._state == PRODUCTION.STATES.paused

	def pause(self, pause=True):
		self.log.debug("Production pause: %s", pause)
		if not pause: # do unpause
			# switch state
			self._state = self._pause_old_state
			self._pause_old_state = None

			# apply state
			if self._state in (PRODUCTION.STATES.waiting_for_res,
			                   PRODUCTION.STATES.inventory_full,
			                   PRODUCTION.STATES.done):
				# just restore watching
				self._add_listeners(check_now=True)

			elif self._state == PRODUCTION.STATES.producing:
				# restore scheduler call
				Scheduler().add_new_object(self._get_producing_callback(), self,
				                           self._pause_remaining_ticks)
			else:
				assert False, 'Unhandled production state: %s' % self._pause_old_state
		else: # do pause
			# switch state
			self._pause_old_state = self._state
			self._state = PRODUCTION.STATES.paused

			if self._pause_old_state in (PRODUCTION.STATES.waiting_for_res,
			                             PRODUCTION.STATES.inventory_full,
			                             PRODUCTION.STATES.done):
				self._remove_listeners()
			elif self._pause_old_state == PRODUCTION.STATES.producing:
				# save when production finishes and remove that call
				self._pause_remaining_ticks = \
						Scheduler().get_remaining_ticks(self, self._get_producing_callback())
				Scheduler().rem_call(self, self._get_producing_callback())
			else:
				assert False, 'Unhandled production state: %s' % self._pause_old_state

		self._changed()

	def finish_production_now(self):
		"""Makes the production finish now"""
		if self._state != PRODUCTION.STATES.producing:
			return
		Scheduler().rem_call(self, self._get_producing_callback())
		self._finished_producing()

	def alter_production_time(self, modifier):
		"""@see ProductionLine.alter_production_time"""
		try:
			self._prod_line.alter_production_time(modifier)
		except AttributeError: # production line doesn't have this alter method
			pass


	def get_state_history_times(self, ignore_pause):
		"""
		Returns the part of time 0 <= x <= 1 the production has been in a state during the last history_length ticks.
		"""
		self._clean_state_history()
		result = defaultdict(int)
		current_tick = Scheduler().cur_tick
		pause_state = PRODUCTION.STATES.paused.index
		first_relevant_tick = self._get_first_relevant_tick(ignore_pause)
		num_entries = len(self._state_history)

		for i in xrange(num_entries):
			if ignore_pause and self._state_history[i][1] == pause_state:
				continue
			tick = self._state_history[i][0]
			if tick >= current_tick:
				break

			next_tick = min(self._state_history[i + 1][0], current_tick) if i + 1 < num_entries else current_tick
			if next_tick <= first_relevant_tick:
				continue
			relevant_ticks = next_tick - tick
			if tick < first_relevant_tick:
				# the beginning is not relevant
				relevant_ticks -= first_relevant_tick - tick
			result[self._state_history[i][1]] += relevant_ticks

		total_length = sum(result.itervalues())
		if total_length == 0:
			return result
		for key in result:
			result[key] /= float(total_length)
		return result

	def get_age(self):
		return Scheduler().cur_tick - self._creation_tick

	def get_unstorable_produced_res(self):
		"""Returns all produced res for whose there is no space"""
		l = []
		for res, amount in self._prod_line.produced_res.iteritems():
			if self.inventory.get_free_space_for(res) < amount:
				l.append(res)
		return l

	## PROTECTED METHODS
	def _get_producing_callback(self):
		"""Returns the callback used during the process of producing (state: producing)"""
		return self._finished_producing

	def _get_first_relevant_tick(self, ignore_pause):
		"""
		Returns the first tick that is relevant for production utilization calculation
		@param ignore_pause: whether to ignore the time spent in the pause state
		"""

		current_tick = Scheduler().cur_tick
		state_hist_len = min(PRODUCTION.STATISTICAL_WINDOW, current_tick - self._creation_tick)

		first_relevant_tick = current_tick - state_hist_len
		if not ignore_pause:
			return first_relevant_tick

		# ignore paused time
		pause_state = PRODUCTION.STATES.paused.index
		for i in xrange(len(self._state_history) - 1, -1, -1):
			if self._state_history[i][1] != pause_state:
				continue
			tick = self._state_history[i][0]
			next_tick = self._state_history[i + 1][0] if i + 1 < len(self._state_history) else current_tick
			if next_tick <= first_relevant_tick:
				break
			first_relevant_tick -= next_tick - tick
		return max(self._creation_tick, first_relevant_tick)

	def _clean_state_history(self):
		""" remove the part of the state history that is too old to matter """
		first_relevant_tick = self._get_first_relevant_tick(True)
		while len(self._state_history) > 1 and self._state_history[1][0] < first_relevant_tick:
			self._state_history.popleft()

	def _changed(self):
		super(Production, self)._changed()
		if not self._prod_line.save_statistics:
			return

		state = self._state.index
		current_tick = Scheduler().cur_tick

		if self._state_history and self._state_history[-1][0] == current_tick:
			self._state_history.pop() # make sure no two events are on the same tick
		if not self._state_history or self._state_history[-1][1] != state:
			self._state_history.append((current_tick, state))

		self._clean_state_history()

	def _check_inventory(self):
		"""Called when assigned building's inventory changed in some way"""
		check_space = self._check_for_space_for_produced_res()
		if not check_space:
			# can't produce, no space in our inventory
			self._state = PRODUCTION.STATES.inventory_full
			self._changed()
		elif self._check_available_res():
			# we have space in our inventory and needed res are available
			# stop listening for res
			self._remove_listeners()
			self._start_production()
		else:
			# we have space in our inventory, but needed res are missing
			self._state = PRODUCTION.STATES.waiting_for_res
			self._changed()

	def _start_production(self):
		"""Actually start production. Sets self to producing state"""
		self._state = PRODUCTION.STATES.producing
		self._produce()
		self._changed()

	def _produce(self):
		"""Called when there are enough res in the inventory for starting production"""
		self.log.debug("%s _produce", self)
		assert self._check_available_res() and self._check_for_space_for_produced_res()
		# take the res we need
		self._remove_res_to_expend()
		# call finished in some time
		time = Scheduler().get_ticks(self._prod_line.time)
		Scheduler().add_new_object(self._get_producing_callback(), self, time)
		self.log.debug("%s _produce Adding callback in %d time", self, time)

	def _finished_producing(self, continue_producing=True, **kwargs):
		"""Called when the production finishes."""
		self.log.debug("%s finished", self)
		self._give_produced_res()
		self.on_production_finished()
		if continue_producing:
			self._state = PRODUCTION.STATES.waiting_for_res
			self._add_listeners(check_now=True)

	def _add_listeners(self, check_now=False):
		"""Listen for changes in the inventory from now on."""
		# don't set call_listener_now to True here, adding/removing changelisteners wouldn't be atomic any more
		self.inventory.add_change_listener(self._check_inventory)
		if self.__class__.uses_gold:
			self.owner_inventory.add_change_listener(self._check_inventory)

		if check_now: # only check now after adding everything
			self._check_inventory()

	def _remove_listeners(self):
		# depending on state, a check_inventory listener might be active
		self.inventory.discard_change_listener(self._check_inventory)
		if self.__class__.uses_gold:
			self.owner_inventory.discard_change_listener(self._check_inventory)

	def _give_produced_res(self):
		"""Put produces goods to the inventory"""
		for res, amount in self._prod_line.produced_res.iteritems():
			self.inventory.alter(res, amount)

	def _check_available_res(self):
		"""Checks if all required resources are there.
		@return: bool, True if we can start production
		"""
		for res, amount in self._prod_line.consumed_res.iteritems():
			if self.inventory[res] < (-amount): # consumed res have negative sign
				return False
		return True

	def _remove_res_to_expend(self):
		"""Removes the resources from the inventory, that production takes."""
		for res, amount in self._prod_line.consumed_res.iteritems():
			remnant = self.inventory.alter(res, amount)
			assert remnant == 0

	def _check_for_space_for_produced_res(self):
		"""Checks if there is enough space in the inventory for the res, we want to produce.
		@return bool, True if everything can fit."""
		for res, amount in self._prod_line.produced_res.iteritems():
			if self.inventory.get_free_space_for(res) < amount:
				return False
		return True

	def __str__(self): # debug
		if hasattr(self, "_state"):
			return 'Production(state=%s;prodline=%s)' % (self._state, self._prod_line)
		else:
			return "UninitializedProduction()"


class ChangingProduction(Production):
	"""Same as Production, but can changes properties of the production line"""

	def save(self, db, owner_id):
		super(ChangingProduction, self).save(db, owner_id)
		self._prod_line.save(db, owner_id)

	def load(self, db, worldid):
		super(ChangingProduction, self).load(db, worldid)
		self._prod_line.load(db, worldid)


class SettlerProduction(ChangingProduction):
	"""For settlers, production behaves different:
	They produce happiness from the goods they get. They get happy immediately when the get
	the resource (i.e. they produce at production start).
	It needs to be a changing production since the time can be altered"""
	def _give_produced_res(self):
		pass # don't give any resources, when they actually should be given

	def _remove_res_to_expend(self):
		super(SettlerProduction, self)._remove_res_to_expend()
		# give the resources when taking away the consumed goods at prod start
		super(SettlerProduction, self)._give_produced_res()


class SingleUseProduction(Production):
	"""This Production just produces one time, and then finishes.
	Notification of the finishing is done via production_finished listeners.
	Use case: Settler getting upgrade material"""

	# TODO: it seems that these kinds of productions are never removed (for settlers and unit productions)

	def __init__(self, inventory, owner_inventory, prod_id, prod_data, **kwargs):
		super(SingleUseProduction, self).__init__(inventory=inventory, owner_inventory=owner_inventory,
		                                          prod_id=prod_id, prod_data=prod_data, **kwargs)

	def _finished_producing(self, **kwargs):
		super(SingleUseProduction, self)._finished_producing(continue_producing=False, **kwargs)
		self._state = PRODUCTION.STATES.done

########NEW FILE########
__FILENAME__ = productionline
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.constants import UNITS

class ProductionLine(object):
	"""Class that collects the production line data."""

	def __init__(self, id, data):
		"""Inits self from yaml data"""
		self.__data = data or {}
		self.id = id
		self.__init()

	def __init(self):
		self._init_finished = False
		# time in seconds that production takes:
		self.time = self.__data.get('time', 1)
		# whether this prodline influences animation:
		self.changes_animation = self.__data.get('changes_animation', True)
		# whether statistics about this production line should be kept:
		self.save_statistics = self.__data.get('save_statistics', True)

		# here we store all resource information.
		# needed resources have a negative amount, produced ones are positive.
		self.production = {}
		self.produced_res = {} # contains only produced
		self.consumed_res = {} # contains only consumed
		self.unit_production = {} # Stores unit_id: amount entries, if units are to be produced
		if 'produces' in self.__data:
			for produced_object, amount in self.__data['produces']:
				if produced_object < UNITS.DIFFERENCE_BUILDING_UNIT_ID:
					self.production[produced_object] = amount
					self.produced_res[produced_object] = amount
				else:
					self.unit_production[produced_object] = amount
		if 'consumes' in self.__data:
			for res, amount in self.__data['consumes']:
				self.production[res] = amount
				self.consumed_res[res] = amount

		self._init_finished = True

	def __str__(self):
		return "ProductionLineData(lineid=%s)" % self.id

	def alter_production_time(self, modifier):
		"""Sets time to original production time multiplied by modifier"""
		self.time = self.__data.get('time', 1) * modifier

	def change_amount(self, res, amount):
		"""Alters an amount of a res at runtime. Because of redundancy, you can only change
		amounts here."""
		self.production[res] = amount
		if res in self.consumed_res:
			self.consumed_res[res] = amount
		if res in self.produced_res:
			self.produced_res[res] = amount

	def save(self, db, for_worldid):
		# we don't have a worldid, we load it for another world id
		for res, amount in self.production.iteritems():
			db("INSERT INTO production_line(for_worldid, type, res, amount) VALUES(?, ?, ?, ?)",
			   for_worldid, "NORMAL", res, amount)
		for res, amount in self.consumed_res.iteritems():
			db("INSERT INTO production_line(for_worldid, type, res, amount) VALUES(?, ?, ?, ?)",
			   for_worldid, "CONSUMED", res, amount)
		for res, amount in self.produced_res.iteritems():
			db("INSERT INTO production_line(for_worldid, type, res, amount) VALUES(?, ?, ?, ?)",
			   for_worldid, "PRODUCED", res, amount)
		for unit, amount in self.unit_production.iteritems():
			db("INSERT INTO production_line(for_worldid, type, res, amount) VALUES(?, ?, ?, ?)",
			   for_worldid, "UNIT", unit, amount)

		db("INSERT INTO production_line(for_worldid, type, res, amount) VALUES(?, ?, ?, ?)",
			   for_worldid, "TIME", self.time, None)


	def load(self, db, for_worldid):
		# we don't have a worldid, we load it for another world id
		self.production = {}
		self.consumed_res = {}
		self.produced_res = {}
		self.unit_production = {}
		for t, res, amount in db.get_production_line_row(for_worldid):
			if t == "TIME":
				self.time = res
			else:
				{ "NORMAL"   : self.production,
				  "CONSUMED" : self.consumed_res,
				  "PRODUCED" : self.produced_res,
				  "UNIT"     : self.unit_production }[t][res] = amount


	def get_original_copy(self):
		"""Returns a copy of this production, in its original state, no changes
		applied"""
		return ProductionLine(self.id, self.__data)

########NEW FILE########
__FILENAME__ = unitproduction
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.production.production import ChangingProduction
from horizons.constants import PRODUCTION, RES
from horizons.scheduler import Scheduler

class UnitProduction(ChangingProduction):
	"""Production, that produces units."""
	uses_gold = True
	keep_original_prod_line = True

	@property
	def progress(self):
		get_amount = lambda items: sum(amount for res, amount in items.iteritems() if res != RES.GOLD)

		still_needed = get_amount(self._prod_line.consumed_res)
		all_needed = get_amount(self.original_prod_line.consumed_res)
		return 1 - float(still_needed) / all_needed

	## PROTECTED METHODS
	def _get_producing_callback(self):
		return self._produce

	def _check_available_res(self):
		# Gold must be available from the beginning
		if self._prod_line.consumed_res.get(RES.GOLD, 0) > 0: # check if gold is needed
			amount = self._prod_line.consumed_res[RES.GOLD]
		for res, amount in self._prod_line.consumed_res.iteritems():
			# we change the production, so the amount can become 0
			# in this case, we must no consider this resource, as it has already been fully provided
			if amount == 0:
				continue # nothing to take here
			if res == RES.GOLD:
				if self.owner_inventory[RES.GOLD] > 0:
					return True
			elif self.inventory[res] > 0:
				return True
		return False

	def _remove_res_to_expend(self, return_without_gold=False):
		"""Takes as many res as there are and returns sum of amount of res taken.
		@param return_without_gold: return not an integer but a tuple, where the second value is without gold"""
		taken = 0
		taken_without_gold = 0
		for res, amount in self._prod_line.consumed_res.iteritems():
			if res == RES.GOLD:
				inventory = self.owner_inventory
			else:
				inventory = self.inventory
			remnant = inventory.alter(res, amount) # try to get all
			self._prod_line.change_amount(res, remnant) # set how much we still need to get
			if return_without_gold and res != RES.GOLD:
				taken_without_gold += abs(remnant) + amount
			taken += abs(remnant) + amount
		if return_without_gold:
			return (taken, taken_without_gold)
		else:
			return taken

	def _produce(self):
		# check if we're done
		still_needed_res = sum(self._prod_line.consumed_res.itervalues())
		if still_needed_res == 0:
			self._finished_producing()
			return

		removed_res, removed_res_without_gold = self._remove_res_to_expend(return_without_gold=True)
		# check if there were res
		if removed_res == 0:
			# watch inventory for new res
			self.inventory.add_change_listener(self._check_inventory)
			if self.__class__.uses_gold:
				self.owner_inventory.add_change_listener(self._check_inventory)
			self._state = PRODUCTION.STATES.waiting_for_res
			self._changed()
			return

		# calculate how much of the whole production process we can produce now
		# and set the scheduler waiting time accordingly (e.g. half of res => wait half of prod time)
		all_needed_res = sum(amount for res, amount in self.original_prod_line.consumed_res.iteritems()
		                            if res != RES.GOLD)
		part_of_whole_production = float(removed_res_without_gold) / all_needed_res
		prod_time = Scheduler().get_ticks( part_of_whole_production * self._prod_line.time )
		prod_time = max(prod_time, 1) # wait at least 1 tick
		# do part of production and call this again when done
		Scheduler().add_new_object(self._produce, self, prod_time)


	def _finished_producing(self, **kwargs):
		super(UnitProduction, self)._finished_producing(continue_producing=False, **kwargs)
		self._state = PRODUCTION.STATES.done
		# reset prodline
		self._prod_line = self._prod_line.get_original_copy()

########NEW FILE########
__FILENAME__ = utilization
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.constants import PRODUCTION
from horizons.scheduler import Scheduler

class Utilization(object):
	"""Basic utilization class used in producers"""

	def capacity_utilization(self, instance):
		productions = instance.get_productions()
		total = 0
		if not productions:
			return 0 # catch the border case, else there'll be a div by 0
		for production in productions:
			state_history = production.get_state_history_times(False)
			total += state_history[PRODUCTION.STATES.producing.index]
		return total / len(productions)

	def capacity_utilization_below(self, limit, instance):
		"""Returns whether the capacity utilization is below a value.
		It is equivalent to "foo.capacity_utilization <= value, but faster."""
		# idea: retrieve the value, then check how long it has to take until the limit
		# can be reached (from both sides). Within this timespan, don't check again.
		cur_tick = Scheduler().cur_tick
		if not hasattr(self, "_old_capacity_utilization") or \
		   self._old_capacity_utilization[0] < cur_tick or \
		   self._old_capacity_utilization[1] != limit:
			capac = self.capacity_utilization(instance)
			diff = abs(limit - capac)
			# all those values are relative values, so we can just do this:
			interval = diff * PRODUCTION.STATISTICAL_WINDOW
			self._old_capacity_utilization = (cur_tick + interval, # expiration date
						                      limit, capac < limit )
		return self._old_capacity_utilization[2]

class FullUtilization(Utilization):
	"""Used for producers where no utilization calculation is necessary"""

	def capacity_utilization(self, instance):
		return 1.0


class FieldUtilization(Utilization):

	max_fields_possible = 8 # only for utilization calculation

	def capacity_utilization(self, instance):
		"""
		Calculate productivity by the number of fields nearby.
		"""

		result = float(len(instance.instance.get_providers())) / self.max_fields_possible
		# sanity checks for theoretically impossible cases:
		result = min(result, 1.0)
		result = max(result, 0.0)
		return result

########NEW FILE########
__FILENAME__ = providerhandler
# -*- coding: utf-8 -*-
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from collections import defaultdict

class ProviderHandler(list):
	"""Class to keep track of providers of an area, especially an island.
	It acts as a data structure for quick retrieval of special properties, that only resource
	providers have.

	Precondition: Provider never change their provided resources."""

	def __init__(self):
		super(ProviderHandler, self).__init__()
		self.provider_by_resources = defaultdict(list)

	def append(self, provider):
		# NOTE: appended elements need to be removed, else there will be a memory leak
		for res in provider.provided_resources:
			self.provider_by_resources[res].append(provider)
		super(ProviderHandler, self).append(provider)

	def remove(self, provider):
		for res in provider.provided_resources:
			self.provider_by_resources[res].remove(provider)
		super(ProviderHandler, self).remove(provider)





########NEW FILE########
__FILENAME__ = resourcehandler
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from copy import copy

from horizons.gui.tabs import ProductionOverviewTab, InventoryTab
from horizons.constants import PRODUCTION
from horizons.component.storagecomponent import StorageComponent
from horizons.component.ambientsoundcomponent import AmbientSoundComponent
from horizons.util.worldobject import WorldObject
from horizons.world.production.producer import Producer


class ResourceTransferHandler(object):
	"""Objects that can transfer resources. ResourceHandler and units with storages"""
	def transfer_to_storageholder(self, amount, res_id, transfer_to, signal_errors=False):
		"""Transfers amount of res_id to transfer_to.
		@param transfer_to: worldid or object reference
		@param signal_errors: whether to play an error sound in case the transfer completely failed (no res transferred)
		@return: amount that was actually transferred (NOTE: this is different from the
						 return value of inventory.alter, since here are 2 storages involved)
		"""
		try:
			transfer_to = WorldObject.get_object_by_id(int(transfer_to))
		except TypeError: # transfer_to not an int, assume already obj
			pass
		# take res from self
		ret = self.get_component(StorageComponent).inventory.alter(res_id, -amount)
		# check if we were able to get the planned amount
		ret = amount if amount < abs(ret) else abs(ret)
		# put res to transfer_to
		ret = transfer_to.get_component(StorageComponent).inventory.alter(res_id, amount-ret)
		self.get_component(StorageComponent).inventory.alter(res_id, ret) # return resources that did not fit
		actually_transfered = amount-ret
		if signal_errors and actually_transfered == 0:
			AmbientSoundComponent.play_special('error')
		return actually_transfered

class ResourceHandler(ResourceTransferHandler):
	"""The ResourceHandler class acts as a basic class for describing objects
	that handle resources. This means the objects can provide resources for
	Collectors and have multiple productions. This is a base class, meaning
	you have to override a lot of functions in subclasses before you can actually
	use it. You can maybe understand our idea about the ResourceHandler if you
	look at the uml digramm: development/uml/production_classes.png

	A ResourceHandler must not have more than 1 production with the same prod line id.
	"""
	tabs = (ProductionOverviewTab, InventoryTab)

	## INIT/DESTRUCT
	def __init__(self, **kwargs):
		super(ResourceHandler, self).__init__(**kwargs)

	def __init(self):
		# list of collectors that are on the way here
		self.__incoming_collectors = []
		self.provided_resources = self._load_provided_resources()

	def initialize(self):
		super(ResourceHandler, self).initialize()
		self.__init()

	def save(self, db):
		super(ResourceHandler, self).save(db)

	def load(self, db, worldid):
		super(ResourceHandler, self).load(db, worldid)
		self.__init()

	def remove(self):
		super(ResourceHandler, self).remove()
		while self.__incoming_collectors: # safe list remove here
			self.__incoming_collectors[0].cancel()

	## INTERFACE
	def get_consumed_resources(self, include_inactive=False):
		"""Returns the needed resources that are used by the productions
		currently active. *include_inactive* will also include resources
		used in a production line that is currently inactive."""
		needed_res = set()
		if self.has_component(Producer):
			prod_comp = self.get_component(Producer)
			productions = copy(prod_comp._productions)
			if include_inactive:
				productions.update(prod_comp._inactive_productions)
			for production in productions.itervalues():
				needed_res.update(production.get_consumed_resources().iterkeys())
		return list(needed_res)

	def get_produced_resources(self):
		"""Returns the resources, that are produced by productions, that are currently active"""
		produced_resources = set()
		if self.has_component(Producer):
			prod_comp = self.get_component(Producer)
			for production in prod_comp._productions.itervalues():
				produced_resources.update(production.get_produced_resources().iterkeys())
		return list(produced_resources)

	def get_stocked_provided_resources(self):
		"""Returns provided resources, where at least 1 ton is available"""
		return [res for res in self.provided_resources if self.get_component(StorageComponent).inventory[res] > 0]

	def get_currently_consumed_resources(self):
		"""Returns a list of resources, that are currently consumed in a production."""
		consumed_res = set()
		if self.has_component(Producer):
			prod_comp = self.get_component(Producer)
			for production in prod_comp._productions.itervalues():
				if production.get_state() == PRODUCTION.STATES.producing:
					consumed_res.update(production.get_consumed_resources().iterkeys())
		return list(consumed_res)

	def get_currently_not_consumed_resources(self):
		"""Needed, but not currently consumed resources.
		Opposite of get_currently_consumed_resources."""
		# use set types since they support the proper operation
		currently_consumed = frozenset(self.get_currently_consumed_resources())
		consumed = frozenset(self.get_consumed_resources())
		return list(consumed - currently_consumed)

	def get_needed_resources(self):
		"""Returns list of resources, where free space in the inventory exists."""
		return [res for res in self.get_consumed_resources()
		            if self.get_component(StorageComponent).inventory.get_free_space_for(res) > 0]

	def add_incoming_collector(self, collector):
		assert collector not in self.__incoming_collectors
		self.__incoming_collectors.append(collector)

	def remove_incoming_collector(self, collector):
		self.__incoming_collectors.remove(collector)

	def _get_owner_inventory(self):
		"""Returns the inventory of the owner to be able to retrieve special resources such as gold.
		The production system should be as decoupled as possible from actual world objects, so only use
		when there are no other possibilities"""
		try:
			return self.owner.get_component(StorageComponent).inventory
		except AttributeError: # no owner or no inventory, either way, we don't care
			return None

	def pickup_resources(self, res, amount, collector):
		"""Try to get amount number of resources of id res_id that are in stock
		and removes them from the stock. Will return smaller amount if not
		enough resources are available.
		@param res: int resource id
		@param amount: int amount that is to be picked up
		@param collector: the collector instance, that picks it up
		@return: int number of resources that can actually be picked up"""
		picked_up = self.get_available_pickup_amount(res, collector)
		assert picked_up >= 0
		if picked_up > amount:
			picked_up = amount
		remnant = self.get_component(StorageComponent).inventory.alter(res, -picked_up)
		assert remnant == 0
		return picked_up

	def get_available_pickup_amount(self, res, collector):
		"""Returns how much of res a collector may pick up. It's the stored amount minus the amount
		that other collectors are getting"""
		if not res in self.provided_resources:
			return 0 # we don't provide this, and give nothing away because we need it ourselves.
		else:
			amount_from_collectors = sum((entry.amount
			                              for c in self.__incoming_collectors
			                              for entry in c.job.reslist
			                              if c is not collector and
			                              entry.res == res))
			amount = self.get_component(StorageComponent).inventory[res] - amount_from_collectors
			# the user can take away res, even if a collector registered for them
			# if this happens, a negative number would be returned. Use 0 instead.
			return max(amount, 0)

	## PROTECTED METHODS
	def _load_provided_resources(self):
		"""Returns a iterable obj containing all resources this building provides.
		This is outsourced from initialization to a method for the possibility of
		overwriting it.
		Do not alter the returned list; if you need to do so, then copy it."""
		produced_resources = set()
		for prod in self.get_component(Producer).get_productions():
			for res in prod.get_produced_resources():
				produced_resources.add(res)

		for res in self.additional_provided_resources:
			produced_resources.add(res)

		return produced_resources

class StorageResourceHandler(ResourceHandler):
	"""Same as ResourceHandler, but for storage buildings such as warehouses.
	Provides all tradeable resources."""

	def get_consumed_resources(self):
		"""We collect everything we provide"""
		return self.provided_resources

	def _load_provided_resources(self):
		"""Storages provide every res.
		Do not alter the returned list; if you need to do so, then copy it."""
		return self.session.db.get_res(only_tradeable=True)

########NEW FILE########
__FILENAME__ = settlement
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import json
import logging

from collections import defaultdict

from horizons.constants import BUILDINGS, TIER
from horizons.util.worldobject import WorldObject
from horizons.messaging import UpgradePermissionsChanged, SettlementInventoryUpdated
from horizons.util.changelistener import ChangeListener
from horizons.util.inventorychecker import InventoryChecker
from horizons.component.componentholder import ComponentHolder
from horizons.component.tradepostcomponent import TradePostComponent
from horizons.component.storagecomponent import StorageComponent
from horizons.world.buildability.settlementcache import SettlementBuildabilityCache
from horizons.world.production.producer import Producer, UnitProducer
from horizons.world.resourcehandler import ResourceHandler
from horizons.scheduler import Scheduler

class Settlement(ComponentHolder, WorldObject, ChangeListener, ResourceHandler):
	"""The Settlement class describes a settlement and stores all the necessary information
	like name, current inhabitants, lists of tiles and houses, etc belonging to the village."""

	log = logging.getLogger("world.settlement")

	component_templates = (
		{
			'StorageComponent':
				{'PositiveSizedSlotStorage':
					{'limit': 0}
				}
		}
		,
		'TradePostComponent',
		'SettlementNameComponent',
	)

	def __init__(self, session, owner):
		"""
		@param owner: Player object that owns the settlement
		"""
		super(Settlement, self).__init__()
		self.__init(session, owner, self.make_default_upgrade_permissions(), self.make_default_tax_settings())

	def __init(self, session, owner, upgrade_permissions, tax_settings):
		from horizons.session import Session
		assert isinstance(session, Session)
		self.session = session
		self.owner = owner
		self.buildings = []
		self.ground_map = {} # this is the same as in island.py. it uses hard references to the tiles too
		self.produced_res = defaultdict(int) # dictionary of all resources, produced at this settlement
		self.buildings_by_id = defaultdict(list)
		self.warehouse = None # this is set later in the same tick by the warehouse itself or load() here
		self.upgrade_permissions = upgrade_permissions
		self.tax_settings = tax_settings
		Scheduler().add_new_object(self.__init_inventory_checker, self)

	def init_buildability_cache(self, terrain_cache):
		self.buildability_cache = SettlementBuildabilityCache(terrain_cache, self.ground_map)
		self.buildability_cache.modify_area(self.ground_map.keys())

	@classmethod
	def make_default_upgrade_permissions(cls):
		upgrade_permissions = {}
		for level in xrange(TIER.CURRENT_MAX):
			upgrade_permissions[level] = True
		upgrade_permissions[TIER.CURRENT_MAX] = False
		return upgrade_permissions

	@classmethod
	def make_default_tax_settings(cls):
		tax_settings = {}
		for level in xrange(TIER.CURRENT_MAX + 1):
			tax_settings[level] = 1.0
		return tax_settings

	def set_tax_setting(self, level, tax):
		self.tax_settings[level] = tax

	def set_upgrade_permissions(self, level, allowed):
		if self.upgrade_permissions[level] != allowed:
			self.upgrade_permissions[level] = allowed

			UpgradePermissionsChanged.broadcast(self)

	@property
	def inhabitants(self):
		"""Returns number of inhabitants (sum of inhabitants of its buildings)"""
		return sum([building.inhabitants for building in self.buildings])

	@property
	def cumulative_running_costs(self):
		"""Return sum of running costs of all buildings"""
		return sum([building.running_costs for building in self.buildings])

	@property
	def cumulative_taxes(self):
		"""Return sum of all taxes paid in this settlement in 1 tax round"""
		return sum([building.last_tax_payed for building in self.buildings if
								hasattr(building, 'last_tax_payed')])

	def get_residentials_of_lvl_for_happiness(self, level, min_happiness=0, max_happiness=101):
		is_valid_residential = lambda building: (hasattr(building, 'happiness') and
		                                         min_happiness <= building.happiness < max_happiness) and \
		                                        (hasattr(building, 'level') and building.level == level)
		return len(filter(is_valid_residential, self.buildings))

	@property
	def balance(self):
		"""Returns sum(income) - sum(expenses) for settlement"""
		return self.cumulative_taxes + self.get_component(TradePostComponent).sell_income \
					 - self.cumulative_running_costs - self.get_component(TradePostComponent).buy_expenses

	@property
	def island(self):
		"""Returns the island this settlement is on"""
		return self.session.world.get_island(self.warehouse.position.origin)

	def level_upgrade(self, lvl):
		"""Upgrades settlement to a new tier.
		It only delegates the upgrade to its buildings."""
		for building in self.buildings:
			building.level_upgrade(lvl)

	def save(self, db, islandid):
		super(Settlement, self).save(db)

		db("INSERT INTO settlement (rowid, island, owner) VALUES(?, ?, ?)",
			self.worldid, islandid, self.owner.worldid)
		for res, amount in self.produced_res.iteritems():
			db("INSERT INTO settlement_produced_res (settlement, res, amount) VALUES(?, ?, ?)",
			   self.worldid, res, amount)
		for level in xrange(TIER.CURRENT_MAX + 1):
			db("INSERT INTO settlement_level_properties (settlement, level, upgrading_allowed, tax_setting) VALUES(?, ?, ?, ?)",
				self.worldid, level, self.upgrade_permissions[level], self.tax_settings[level])

		# dump ground data via json, it's orders of magnitude faster than sqlite
		data = json.dumps(self.ground_map.keys())
		db("INSERT INTO settlement_tiles(rowid, data) VALUES(?, ?)", self.worldid, data)

	@classmethod
	def load(cls, db, worldid, session, island):
		self = cls.__new__(cls)
		self.session = session
		super(Settlement, self).load(db, worldid)

		owner = db("SELECT owner FROM settlement WHERE rowid = ?", worldid)[0][0]
		upgrade_permissions = {}
		tax_settings = {}
		for level, allowed, tax in db("SELECT level, upgrading_allowed, tax_setting FROM settlement_level_properties WHERE settlement = ?", worldid):
			upgrade_permissions[level] = allowed
			tax_settings[level] = tax
		self.__init(session, WorldObject.get_object_by_id(owner), upgrade_permissions, tax_settings)

		# load the settlement tile map
		tile_data = db("SELECT data FROM settlement_tiles WHERE rowid = ?", worldid)[0][0]
		coords_list = [tuple(raw_coords) for raw_coords in json.loads(tile_data)] # json saves tuples as list
		for coords in coords_list:
			tile = island.ground_map[coords]
			self.ground_map[coords] = tile
			tile.settlement = self

		# load all buildings in this settlement
		from horizons.world import load_building
		for building_id, building_type in \
			  db("SELECT rowid, type FROM building WHERE location = ?", worldid):
			building = load_building(session, db, building_type, building_id)
			if building_type == BUILDINGS.WAREHOUSE:
				self.warehouse = building

		for res, amount in db("SELECT res, amount FROM settlement_produced_res WHERE settlement = ?", worldid):
			self.produced_res[res] = amount

		return self

	def get_tiles_in_radius(self, location, radius, include_self):
		"""Returns tiles in radius of location.
		This is a generator.
		@param location: anything that supports get_radius_coordinates (usually Rect).
		@param include_self: bool, whether to include the coordinates in location
		"""
		for coord in location.get_radius_coordinates(radius, include_self):
			try:
				yield self.ground_map[coord]
			except KeyError:
				pass

	def add_building(self, building, load=False):
		"""Adds a building to the settlement.
		This does not set building.settlement, it must be set beforehand.
		@see Island.add_building
		"""
		self.buildings.append(building)
		if building.id in self.buildings_by_id:
			self.buildings_by_id[building.id].append(building)
		else:
			self.buildings_by_id[building.id] = [building]
		if building.has_component(Producer) and not building.has_component(UnitProducer):
			finished = self.settlement_building_production_finished
			building.get_component(Producer).add_production_finished_listener(finished)
		if not load and not building.buildable_upon and self.buildability_cache:
			self.buildability_cache.modify_area([coords for coords in building.position.tuple_iter()])
		if hasattr(self.owner, 'add_building'):
			# notify interested players of added building
			self.owner.add_building(building)

	def remove_building(self, building):
		"""Properly removes a building from the settlement"""
		if not building in self.buildings:
			self.log.warn("Building %s can not be removed from settlement", building.id)
			return
		self.buildings.remove(building)
		self.buildings_by_id[building.id].remove(building)
		if building.has_component(Producer) and not building.has_component(UnitProducer):
			finished = self.settlement_building_production_finished
			building.get_component(Producer).remove_production_finished_listener(finished)
		if not building.buildable_upon and self.buildability_cache:
			self.buildability_cache.add_area([coords for coords in building.position.tuple_iter()])
		if hasattr(self.owner, 'remove_building'):
			# notify interested players of removed building
			self.owner.remove_building(building)

	def count_buildings(self, id):
		"""Returns the number of buildings in the settlement that are of the given type."""
		return len(self.buildings_by_id.get(id, []))

	def settlement_building_production_finished(self, building, produced_res):
		"""Callback function for registering the production of resources."""
		for res, amount in produced_res.iteritems():
			self.produced_res[res] += amount

	def __init_inventory_checker(self):
		"""Check for changed inventories every 4 ticks."""
		storage = self.get_component(StorageComponent)
		self.__inventory_checker = InventoryChecker(SettlementInventoryUpdated, storage, 4)

	def end(self):
		self.buildability_cache = None
		self.session = None
		self.owner = None
		self.buildings = None
		self.ground_map = None
		self.produced_res = None
		self.buildings_by_id = None
		self.warehouse = None
		if hasattr(self, '__inventory_checker'):
			self.__inventory_checker.remove()

########NEW FILE########
__FILENAME__ = status
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import operator

from horizons.i18n import _lazy

"""Classes used for StatusIcon.

Code design note:
The conditions for the statuses could also have been placed here,
for more modularity and flexiblity.
This way, we'd need to touch the objects' privates sometimes though,
and we'd lose some direct interaction flexiblity. Therefore, the objects
now contain all the logic, this module just covers the data.

Priority:
[   0-1000[: low
[1000-2000[: medium
[2000-3000[: high
Keep the numbers unique to avoid confusion when sorting.
"""
class StatusIcon(object):
	# integer
	priority = None
	# fife identifier for animations or icons. Must be supported by either the animationloader
	# or the imagemanager. (i.e. either file path or something like "as_buoy0+idle+45")
	icon = None
	# use _lazy
	helptext = ""

	def __init__(self, instance):
		"""
		@param instance: the instance the icon is to be attached to
		"""
		self.instance = instance

	@staticmethod
	def get_sorting_key():
		"""Use like this:
		sorted(mylist, key=mylist.get_sorting_key())
		or
		mylist.sort(key=mylist.get_sorting_key())
		"""
		return operator.attrgetter("priority")

	def __cmp__(self, other):
		return cmp(self.__class__, other.__class__)

	def __str__(self):
		return str(self.__class__) + "(prio:%s,icon:%s)" % (self.priority, self.icon)

class BlackDeathStatusIcon(StatusIcon):
	""" Black Death disaster """
	priority = 3000
	icon = 'as_pestilence+idle+45'
	_helptext = _("The inhabitants are infected by the Black Death!")

class FireStatusIcon(StatusIcon):
	""" Fire disaster """
	priority = 3000
	icon = 'as_on_fire+idle+45'
	helptext = _lazy("This building is on fire!")


class SettlerUnhappyStatus(StatusIcon):
	# threshold is the inhabitants decrease level
	priority = 1700
	icon = 'as_attention_please+idle+45'
	helptext = _lazy("These residents are unhappy.")

class SettlerNotConnectedStatus(StatusIcon):
	# threshold is the inhabitants decrease level
	priority = 1700
	icon = 'as_mainsquare_access+idle+45'
	helptext = _lazy("These residents don't have access to a main square.")


class InventoryFullStatus(StatusIcon):
	priority = 1200
	icon = 'as_inventory_full+idle+45'
	helptext = _lazy("The inventory of this building is full.")

	def __init__(self, instance, reslist):
		"""
		@param reslist: list of integers describing the resources
		"""
		super(InventoryFullStatus, self).__init__(instance)
		self.reslist = reslist


class ProductivityLowStatus(StatusIcon):
	"""Terminology: productivity = capacity utilization"""
	threshold = 0.25 # display when productivity lower than this
	priority = 400
	icon = 'as_attention_please+idle+45'
	helptext = _lazy("This building has a very low productivity.")


class DecommissionedStatus(StatusIcon):
	priority = 800
	icon = 'as_decommissioned+idle+45'
	helptext = _lazy("This building is decommissioned.")

########NEW FILE########
__FILENAME__ = storage
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


"""
Here we define how the inventories work, that are used by world objects.
These storage classes exist:

- GenericStorage (abstract): Defines general interface for storage.

Storages with certain properties:
- PositiveStorage: Doesn't allow negative values.
- TotalStorage: Sum of all stored res must be <= a certain limit.
- SpecializedStorage: Allows only certain resources to be stored here.
- SizedSpecializedStorage: Like SpecializedStorage, but each res has an own limit.

Combinations:
- SizedSlottedStorage: One limit, each res value must be <= the limit and >= 0.
- PositiveTotalStorage: use case: ship inventory
- PositiveSizedSlotStorage: every res has the same limit, only positive values (warehouse, collectors)
- PositiveSizedSpecializedStorage: Like SizedSpecializedStorage, plus only positive values.
"""

import sys
import copy
from collections import defaultdict

from horizons.util.changelistener import ChangeListener

class GenericStorage(ChangeListener):
	"""The GenericStorage represents a storage for buildings/units/players/etc. for storing
	resources. The GenericStorage is the general form and is mostly used as baseclass to
	derive storages with special function from it. Normally there should be no need to
	use the GenericStorage. Rather use a specialized version that is suitable for the job.
	"""
	def __init__(self):
		super(GenericStorage, self).__init__()
		self._storage = defaultdict(int)

	def save(self, db, ownerid):
		for slot in self._storage.iteritems():
			db("INSERT INTO storage (object, resource, amount) VALUES (?, ?, ?) ",
				ownerid, slot[0], slot[1])

	def load(self, db, ownerid):
		for (res, amount) in db.get_storage_rowids_by_ownerid(ownerid):
			self.alter(res, amount)

	def alter(self, res, amount):
		"""alter() will return the amount of resources that did not fit into the storage or
		if altering in a negative way to remove resources, the amount of resources that was
		not available in the storage. The totalstorage always returns 0 as there are not
		limits as to what can be in the storage.
		@param res: int res id that is to be altered
		@param amount: int amount that is to be changed. Can be negative to remove resources.
		@return: int - amount that did not fit or was not available, depending on context.
		"""
		self._storage[res] += amount # defaultdict
		self._changed()
		return 0

	def reset(self, res):
		"""Resets a resource slot to zero, removing all its contents."""
		if res in self._storage:
			self._storage[res] = 0
			self._changed()

	def reset_all(self):
		"""Removes every resource from this inventory"""
		for res in self._storage:
			self._storage[res] = 0
		self._changed()

	def get_limit(self, res=None):
		"""Returns the current limit of the storage. Please note that this
		value can have different meanings depending on the context. See the
		storage descriptions on what the value does in each case.
		@param res: int res that the limit should be returned for.
		@return: int
		"""
		return sys.maxint # should not be used for generic storage

	def get_free_space_for(self, res):
		"""Returns how much of res we can still store here (limit - current amount)."""
		return self.get_limit(res) - self[res]

	def get_sum_of_stored_resources(self):
		return sum(self._storage.itervalues())

	def get_dump(self):
		"""Returns a dump of the inventory as dict"""
		return copy.deepcopy(self._storage)

	def __getitem__(self, res):
		return self._storage.get(res, 0)

	def iterslots(self):
		return self._storage.iterkeys()

	def itercontents(self):
		return self._storage.iteritems()

	def __str__(self):
		return "%s(%s)" % (self.__class__, self._storage if hasattr(self, "_storage") else None)

class SpecializedStorage(GenericStorage):
	"""Storage where only certain resources can be stored. If you want to store a resource here,
	you have to call add_resource_slot() before calling alter()."""
	def alter(self, res, amount):
		if self.has_resource_slot(res): # res can be stored, propagate call
			return super(SpecializedStorage, self).alter(res, amount)
		else:
			return amount # we couldn't store any of this

	def add_resource_slot(self, res):
		"""Creates a slot for res. Does nothing if the slot exists."""
		super(SpecializedStorage, self).alter(res, 0)
		self._changed()

	def has_resource_slot(self, res):
		return (res in self._storage)

class SizedSpecializedStorage(SpecializedStorage):
	"""Just like SpecializedStorage, but each res has an own limit.
	Can take a dict {res: size, res2: size2, ...} to init slots
	"""
	def __init__(self, slot_sizes=None):
		super(SizedSpecializedStorage, self).__init__()
		slot_sizes = slot_sizes or {}
		self.__slot_limits = {}
		for res, size in slot_sizes.iteritems():
			self.add_resource_slot(res, size)

	def alter(self, res, amount):
		if not self.has_resource_slot(res):
			# TODO: this is also checked in the super class, refactor one of them away
			return amount

		if amount > 0: # can only reach limit if > 0
			storeable_amount = self.get_free_space_for(res)
			if amount > storeable_amount: # tried to store more than limit allows
				ret = super(SizedSpecializedStorage, self).alter(res, storeable_amount)
				return (amount - storeable_amount ) + ret

		# no limit breach, just propagate call
		return super(SizedSpecializedStorage, self).alter(res, amount)

	def get_limit(self, res):
		return self.__slot_limits.get(res, 0)

	def add_resource_slot(self, res, size):
		"""Add a resource slot for res that can hold at most *size* units.
		If the slot already exists, just update its size to *size*.
		NOTE: THIS IS NOT SAVE/LOADED HERE. It must be restored manually."""
		super(SizedSpecializedStorage, self).add_resource_slot(res)
		assert size >= 0
		self.__slot_limits[res] = size

	def save(self, db, ownerid):
		super(SizedSpecializedStorage, self).save(db, ownerid)
		assert len(self._storage) == len(self.__slot_limits) # we have to have limits for each res

	def load(self, db, ownerid):
		super(SizedSpecializedStorage, self).load(db, ownerid)

class GlobalLimitStorage(GenericStorage):
	"""Storage with some kind of global limit. This limit has to be
	interpreted in the subclass, it has no predefined meaning here.
	This class is used for infrastructure, such as save/load for the limit."""
	def __init__(self, limit):
		super(GlobalLimitStorage, self).__init__()
		self.limit = limit

	def save(self, db, ownerid):
		super(GlobalLimitStorage, self).save(db, ownerid)
		db("INSERT INTO storage_global_limit(object, value) VALUES(?, ?)", ownerid, self.limit)

	def load(self, db, ownerid):
		self.limit = db.get_storage_global_limit(ownerid)
		super(GlobalLimitStorage, self).load(db, ownerid)

	def adjust_limit(self, amount):
		"""Adjusts the limit of the storage by amount.
		If the limit is reduced, every resource that doesn't fit in the storage anymore is dropped!
		@param amount: int, difference to current limit (positive or negative)
		"""
		self.limit += amount
		if self.limit < 0:
			self.limit = 0
		# remove res that don't fit anymore
		for res, amount in self._storage.iteritems():
			if amount > self.limit:
				self._storage[res] = self.limit
		self._changed()

	def get_limit(self, res=None):
		return self.limit

class TotalStorage(GlobalLimitStorage):
	"""The TotalStorage represents a storage with a general limit to the sum of resources
	that can be stored in it. The limit is a general limit, not specialized to one resource.
	E.g. if the limit is 10, you can have 4 items of res A and 6 items of res B, then nothing
	else can be stored here.

	NOTE: Negative values will increase storage size, so consider using PositiveTotalStorage.
	"""
	def __init__(self, limit):
		super(TotalStorage, self).__init__(limit)

	def alter(self, res, amount):
		check = max(0, amount + self.get_sum_of_stored_resources() - self.limit)
		return check + super(TotalStorage, self).alter(res, amount - check)

	def get_free_space_for(self, res):
		return self.limit - self.get_sum_of_stored_resources()

class PositiveStorage(GenericStorage):
	"""The positive storage doesn't allow to have negative values for resources."""
	def alter(self, res, amount):
		subtractable_amount = amount
		if amount < 0 and ( amount + self[res] < 0 ): # tried to subtract more than we have
			subtractable_amount = - self[res] # only amount where we keep a positive value
		ret = super(PositiveStorage, self).alter(res, subtractable_amount)
		return (amount - subtractable_amount) + ret

class PositiveTotalStorage(PositiveStorage, TotalStorage):
	"""A combination of the Total and Positive storage. Used to set a limit and ensure
	there are no negative amounts in the storage."""
	def alter(self, res, amount):
		ret = super(PositiveTotalStorage, self).alter(res, amount)
		if self[res] == 0:
			# remove empty slots, cause else they will get displayed in the ship inventory
			del self._storage[res]
		return ret

class PositiveTotalNumSlotsStorage(PositiveStorage, TotalStorage):
	"""A combination of the Total and Positive storage which only has a limited number of slots.
	Used to set a limit and ensure there are no negative amounts in the storage."""
	def __init__(self, limit, slotnum):
		super(PositiveTotalNumSlotsStorage, self).__init__(limit)
		self.slotnum = slotnum

	def alter(self, res, amount):
		if amount == 0:
			return 0
		if not res in self._storage and len(self._storage) >= self.slotnum:
			return amount
		ret = super(PositiveTotalNumSlotsStorage, self).alter(res, amount)
		if self[res] == 0:
			# remove empty slots, cause else they will get displayed in the ship inventory
			del self._storage[res]
		return ret

	def get_free_space_for(self, res):
		if not res in self._storage and len(self._storage) >= self.slotnum:
			return 0
		else:
			return super(PositiveTotalNumSlotsStorage, self).get_free_space_for(res)

class PositiveSizedSlotStorage(GlobalLimitStorage, PositiveStorage):
	"""A storage consisting of a slot for each resource, all slots have the same size 'limit'
	Used by the warehouse for example. So with a limit of 30 you could have a max of
	30 from each resource."""
	def __init__(self, limit=0):
		super(PositiveSizedSlotStorage, self).__init__(limit)

	def alter(self, res, amount):
		check = max(0, amount + self[res] - self.limit)
		ret = super(PositiveSizedSlotStorage, self).alter(res, amount - check)
		if res in self._storage and self[res] == 0:
			del self._storage[res]
		return check + ret

class PositiveSizedSpecializedStorage(PositiveStorage, SizedSpecializedStorage):
	pass

class PositiveSizedNumSlotStorage(PositiveSizedSlotStorage):
	"""A storage consisting of a number of slots, all slots have the same size 'limit'.
	Used by ships for example. With a limit of 50 and a slot num of 4, you
	could have a max of 50 from each resource and only slotnum resources."""
	def __init__(self, limit, slotnum):
		super(PositiveSizedNumSlotStorage, self).__init__(limit)
		self.slotnum = slotnum

	def alter(self, res, amount):
		if amount == 0:
			return 0
		if not res in self._storage and len(self._storage) >= self.slotnum:
			return amount
		result = super(PositiveSizedNumSlotStorage, self).alter(res, amount)
		return result

	def get_free_space_for(self, res):
		if not res in self._storage and len(self._storage) >= self.slotnum:
			return 0
		else:
			return super(PositiveSizedNumSlotStorage, self).get_free_space_for(res)

########################################################################
class SettlementStorage:
	"""Dummy class to signal the storagecomponent to use the settlements inventory"""

########NEW FILE########
__FILENAME__ = traderoute
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import copy

from horizons.world.units.movingobject import MoveNotPossible
from horizons.util.changelistener import ChangeListener
from horizons.util.shapes import Circle
from horizons.util.worldobject import WorldObject
from horizons.constants import GAME_SPEED
from horizons.scheduler import Scheduler
from horizons.component.storagecomponent import StorageComponent
from horizons.component.tradepostcomponent import TradePostComponent, TRADE_ERROR_TYPE


class TradeRoute(ChangeListener):
	"""
	waypoints: list of dicts with the keys
		- warehouse:  a warehouse object
		- resource_list: a {res_id:amount} dict
			- if amount is negative the ship unloads
			- if amount is positive the ship loads

	Change notifications mainly notify about changes of enable.
	"""

	def __init__(self, ship):
		super(TradeRoute, self).__init__()
		self.ship = ship
		self.waypoints = []
		self.current_waypoint = -1
		self.enabled = False

		self.wait_at_load = False # wait until every res has been loaded
		self.wait_at_unload = False #  wait until every res could be unloaded

		self.current_transfer = {} # used for partial unloading in combination with waiting

	def append(self, warehouse_worldid):
		warehouse = WorldObject.get_object_by_id(warehouse_worldid)
		self.waypoints.append({
			'warehouse': warehouse,
			'resource_list': {},
		})

	def set_wait_at_load(self, flag):
		self.wait_at_load = flag # as method for commands

	def set_wait_at_unload(self, flag):
		self.wait_at_unload = flag # as methods for commands

	def move_waypoint(self, position, direction):
		# Error sounds for invalid move actions are triggered in
		# gui.widgets.routeconfig, not here.
		was_enabled = self.enabled
		if was_enabled:
			self.disable()

		if position == len(self.waypoints) and direction == 'down' or \
		   position == 0 and direction == 'up':
			return
		if direction == 'up':
			new_pos = position - 1
		elif direction == 'down':
			new_pos = position + 1
		else:
			assert False, 'Direction is neither "up" nor "down".'

		self.waypoints.insert(new_pos, self.waypoints.pop(position))

		if was_enabled:
			self.enable()

	def remove_waypoint(self, position):
		was_enabled = self.enabled
		if was_enabled:
			self.disable()
		try:
			self.waypoints.pop(position)
		except IndexError:
			# Usually caused by multiple clicks in short succession with mp delay.
			pass

		if was_enabled:
			# This might fail if there are too few waypoints now.
			self.enable()

		self._changed()

	def toggle_load_unload(self, position, res_id):
		self.waypoints[position]['resource_list'][res_id] *= -1

	def add_to_resource_list(self, position, res_id, amount):
		self.waypoints[position]['resource_list'][res_id] = amount

	def remove_from_resource_list(self, position, res_id):
		self.waypoints[position]['resource_list'].pop(res_id)

	def on_route_warehouse_reached(self):
		"""Transfer resources, wait if necessary and move to next warehouse when possible"""
		warehouse = self.get_location()['warehouse']
		resource_list = self.current_transfer or self.get_location()['resource_list']
		suppress_messages = self.current_transfer is not None # no messages from second try on

		if self.current_transfer is not None:
			for res in copy.copy(self.current_transfer):
				# make sure we don't keep trying to (un)load something when the decision about that resource has changed
				if self.current_transfer[res] == 0 or res not in self.get_location()['resource_list'] or \
				   cmp(self.current_transfer[res], 0) != cmp(self.get_location()['resource_list'][res], 0):
					del self.current_transfer[res]

		settlement = warehouse.settlement
		status = self._transfer_resources(settlement, resource_list, suppress_messages)

		if not self.enabled: # got disabled while retrying transfer
			self.current_transfer = None
			return

		if (not status.settlement_has_enough_space_to_take_res and self.wait_at_unload) or \
		   (not status.settlement_provides_enough_res and self.wait_at_load):
			self.current_transfer = status.remaining_transfers
			# retry
			Scheduler().add_new_object(self.on_route_warehouse_reached, self, GAME_SPEED.TICKS_PER_SECOND)
		else:
			self.current_transfer = None
			self.move_to_next_route_warehouse()

	def _transfer_resources(self, settlement, resource_list, suppress_messages=False):
		"""Transfers resources to/from settlement according to list.
		@return: TransferStatus instance
		"""
		class TransferStatus(object):
			def __init__(self):
				self.settlement_provides_enough_res = self.settlement_has_enough_space_to_take_res = True
				self.remaining_transfers = {}

		status = TransferStatus()
		status.remaining_transfers = copy.copy(resource_list)

		for res in resource_list:
			amount = resource_list[res]
			if amount == 0:
				continue

			ship_inv = self.ship.get_component(StorageComponent).inventory
			settlement_inv = settlement.get_component(StorageComponent).inventory
			if amount > 0:
				# Case A: Load from settlement onto ship.
				if settlement.owner is self.ship.owner:
					# Check whether route asks for more of a resource than the settlement
					# can offer currently. If so, only load that remainder instead.
					if settlement_inv[res] < amount:
						amount = settlement_inv[res]
					# If due to previous trading there is a certain amount of this resource
					# still left on the ship, don't overload: The ship only picks up enough
					# to reach the amount defined in the route config in that case.
					if ship_inv[res] + amount > self.get_location()['resource_list'][res]:
						amount = self.get_location()['resource_list'][res] - ship_inv[res]
					# The check if our ship has enough space is handled implicitly below.
					amount_transferred = settlement.transfer_to_storageholder(amount, res, self.ship)
				else:
					amount_transferred, error = settlement.get_component(TradePostComponent).sell_resource(
					  self.ship.worldid, res, amount, add_error_type=True, suppress_messages=suppress_messages)
					if error == TRADE_ERROR_TYPE.PERMANENT:
						# pretend to have everything and move on, waiting doesn't make sense
						amount_transferred = amount

				if amount_transferred < status.remaining_transfers[res] and \
				   ship_inv.get_free_space_for(res) > 0 and \
				   ship_inv[res] < self.get_location()['resource_list'][res]:
					status.settlement_provides_enough_res = False
				status.remaining_transfers[res] -= amount_transferred
			else:
				# Case B: Load from ship into settlement.
				amount = -amount # use positive below
				if settlement.owner is self.ship.owner:
					# Check if route asks for more of a resource than there is on the ship.
					# If not, only move the remainder that we have loaded instead.
					if ship_inv[res] < amount:
						amount = ship_inv[res]
					# Check if we can store everything we want to unload from ship.
					# If not, only move the amount that can still be stored in settlement.
					if settlement_inv.get_free_space_for(res) < amount:
						amount = settlement_inv.get_free_space_for(res)

					amount_transferred = self.ship.transfer_to_storageholder(amount, res, settlement)
				else:
					amount_transferred, error = settlement.get_component(TradePostComponent).buy_resource(
					  self.ship.worldid, res, amount, add_error_type=True, suppress_messages=suppress_messages)
					if error == TRADE_ERROR_TYPE.PERMANENT:
						amount_transferred = amount # is negative

				if amount_transferred < -status.remaining_transfers[res] and ship_inv[res] > 0:
					status.settlement_has_enough_space_to_take_res = False
				status.remaining_transfers[res] += amount_transferred

		return status

	def on_ship_blocked(self):
		# the ship was blocked while it was already moving so try again
		self.move_to_next_route_warehouse(advance_waypoint=False)

	def move_to_next_route_warehouse(self, advance_waypoint=True):
		next_destination = self.get_next_destination(advance_waypoint)
		if next_destination is None:
			return

		warehouse = next_destination['warehouse']
		if self.ship.position.distance(warehouse.position.center) <= self.ship.radius:
			self.on_route_warehouse_reached()
			return

		try:
			self.ship.move(Circle(warehouse.position.center, self.ship.radius), self.on_route_warehouse_reached,
			               blocked_callback = self.on_ship_blocked)
		except MoveNotPossible:
			# retry in 5 seconds
			Scheduler().add_new_object(self.on_ship_blocked, self, GAME_SPEED.TICKS_PER_SECOND * 5)

	def get_next_destination(self, advance_waypoint):
		if not self.enabled:
			return None
		if len(self.waypoints) < 2:
			return None

		if advance_waypoint:
			self.current_waypoint += 1
			self.current_waypoint %= len(self.waypoints)
		return self.waypoints[self.current_waypoint]

	def get_location(self):
		return self.waypoints[self.current_waypoint]

	def can_enable(self):
		warehouses = set()
		for waypoint in self.waypoints:
			warehouses.add(waypoint['warehouse'])
		return len(warehouses) > 1

	def enable(self):
		if not self.can_enable():
			return False
		self.enabled = True
		self.move_to_next_route_warehouse()
		self._changed()
		return True

	def disable(self):
		self.enabled = False
		self.ship.stop()
		self._changed()

	def clear(self):
		self.waypoints = []
		self.current_waypoint = -1

	@classmethod
	def has_route(cls, db, worldid):
		"""Check if a savegame contains route information for a certain ship"""
		return len(db("SELECT * FROM ship_route WHERE ship_id = ?", worldid)) != 0

	def load(self, db):
		enabled, self.current_waypoint, self.wait_at_load, self.wait_at_unload = \
			db("SELECT enabled, current_waypoint, wait_at_load, wait_at_unload "
			   "FROM ship_route WHERE ship_id = ?", self.ship.worldid)[0]

		query = "SELECT warehouse_id FROM ship_route_waypoint WHERE ship_id = ? ORDER BY waypoint_index"
		offices_id = db(query, self.ship.worldid)

		for office_id, in offices_id:
			warehouse = WorldObject.get_object_by_id(office_id)
			query = "SELECT res, amount FROM ship_route_resources WHERE ship_id = ? and waypoint_index = ?"
			resource_list = dict(db(query, self.ship.worldid, len(self.waypoints)))

			self.waypoints.append({
				'warehouse' : warehouse,
				'resource_list' : resource_list
			})

		waiting = False
		for res, amount in db("SELECT res, amount FROM ship_route_current_transfer WHERE ship_id = ?", self.ship.worldid):
			waiting = True
			self.current_transfer[res] = amount
			Scheduler().add_new_object(self.on_route_warehouse_reached, self, GAME_SPEED.TICKS_PER_SECOND)

		if enabled and not waiting:
			self.current_waypoint -= 1
			self.enable()

	def save(self, db):
		worldid = self.ship.worldid

		db("INSERT INTO ship_route(ship_id, enabled, current_waypoint, wait_at_load, wait_at_unload) VALUES(?, ?, ?, ?, ?)",
		   worldid, self.enabled, self.current_waypoint, self.wait_at_load, self.wait_at_unload)

		if self.current_transfer:
			for res, amount in self.current_transfer.iteritems():
				db("INSERT INTO ship_route_current_transfer(ship_id, res, amount) VALUES(?, ?, ?)",
				   worldid, res, amount)

		for entry in self.waypoints:
			index = self.waypoints.index(entry)
			db("INSERT INTO ship_route_waypoint(ship_id, warehouse_id, waypoint_index) VALUES(?, ?, ?)",
			   worldid, entry['warehouse'].worldid, index)
			for res in entry['resource_list']:
				db("INSERT INTO ship_route_resources(ship_id, waypoint_index, res, amount) VALUES(?, ?, ?, ?)",
				   worldid, index, res, entry['resource_list'][res])

	def get_ship_status(self):
		"""Return the current status of the ship."""
		if self.ship.is_moving():
			location = self.ship.get_location_based_status(self.ship.get_move_target())
			status_msg = _('Trade route: going to {location}').format(location=location)
			return (status_msg, self.ship.get_move_target())
		else:
			position = self.ship.get_location_based_status(self.ship.position)
			status_msg = _('Trade route: waiting at {position}').format(position=position)
			return (status_msg, self.ship.position)

########NEW FILE########
__FILENAME__ = animal
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.scheduler import Scheduler

from horizons.util.pathfinding.pather import SoldierPather
from horizons.util.shapes import Point
from horizons.util.worldobject import WorldObject
from horizons.command.unit import CreateUnit
from horizons.world.units.collectors import Collector, BuildingCollector, JobList, Job
from horizons.constants import RES, WILD_ANIMAL
from horizons.world.units.movingobject import MoveNotPossible
from horizons.component.storagecomponent import StorageComponent
from horizons.world.resourcehandler import ResourceHandler

class Animal(ResourceHandler):
	"""Base Class for all animals. An animal is a unit, that consumes resources (e.g. grass)
	and usually produce something (e.g. wool, meat)."""
	log = logging.getLogger('world.units.animal')

	def __init__(self, *args, **kwargs):
		super(Animal, self).__init__(*args, **kwargs)

class CollectorAnimal(Animal):
	"""Animals that will inherit from collector"""
	def __init__(self, **kwargs):
		super(CollectorAnimal, self).__init__(**kwargs)
		self.__init()

	def __init(self):
		self.collector = None

	def load(self, db, worldid):
		self.__init()
		super(CollectorAnimal, self).load(db, worldid)

	def apply_state(self, state, remaining_ticks=None):
		super(CollectorAnimal, self).apply_state(state, remaining_ticks)
		if self.state == self.states.no_job_walking_randomly:
			self.add_move_callback(self.search_job)

	def stop_after_job(self, collector):
		"""Tells the unit to stop after the current job and call the collector to pick it up"""
		self.collector = collector

	def remove_stop_after_job(self):
		"""Let the animal continue as usual after the job. Can only be called
		after stop_after_job"""
		assert self.collector is not None
		self.collector = None

	def has_collectors(self):
		"""Whether this unit is just now or about to be collected"""
		return self.collector is not None or self.state == self.states.waiting_for_herder

	def finish_working(self):
		# animal is done when it has eaten, and
		# doesn't have to get home, so end job right now
		Collector.finish_working(self)
		self.end_job()

	def search_job(self):
		"""Search for a job, only called if the collector does not have a job."""
		self.log.debug("%s search job", self)
		if self.collector is not None:
			# tell the animalcollector to pick me up
			collector = self.collector
			self.collector = None
			collector.pickup_animal()
			self.state = self.states.waiting_for_herder
		else:
			super(CollectorAnimal, self).search_job()

	def get_home_inventory(self):
		return self.get_component(StorageComponent).inventory

	def get_collectable_res(self):
		return self.get_needed_resources()

class WildAnimal(CollectorAnimal, Collector):
	"""Animals, that live in the nature and feed on natural resources.
	These animals can be hunted.

	They produce wild animal meat and feed on wild animal food x, which is produced by
	e.g. a tree.

	It is assumed, that they need all resources, that they use, for reproduction. If they have
	gathered all resources, and their inventory is full, they reproduce.
	"""
	walking_range = 6
	work_duration = 96
	pather_class = SoldierPather

	def __init__(self, owner, start_hidden=False, can_reproduce=True, **kwargs):
		super(WildAnimal, self).__init__(start_hidden=start_hidden, owner=owner, **kwargs)
		self.__init(owner, can_reproduce)
		self.log.debug("Wild animal %s created at " + str(self.position) +
		               "; can_reproduce: %s; population now: %s",
				self.worldid, can_reproduce, len(self.home_island.wild_animals))

	def __init(self, island, can_reproduce, health=None):
		"""
		@param island: Hard reference to island
		@param can_reproduce: bool
		@param health: int or None
		"""
		assert isinstance(can_reproduce, bool)
		# good health is the main target of an animal. it increases when they eat and
		# decreases, when they have no food. if it reaches 0, they die, and
		# if it reaches HEALTH_LEVEL_TO_REPRODUCE, they reproduce
		self.health = health if health is not None else WILD_ANIMAL.HEALTH_INIT_VALUE
		self.can_reproduce = can_reproduce
		self.home_island = island
		self.home_island.wild_animals.append(self)

		resources = self.get_needed_resources()
		assert resources == [RES.WILDANIMALFOOD] or resources == []
		self._required_resource_id = RES.WILDANIMALFOOD
		self._building_index = self.home_island.get_building_index(self._required_resource_id)

	def save(self, db):
		super(WildAnimal, self).save(db)
		# save members
		db("INSERT INTO wildanimal(rowid, health, can_reproduce) VALUES(?, ?, ?)",
			 self.worldid, self.health, int(self.can_reproduce))
		# set island as owner
		db("UPDATE unit SET owner = ? WHERE rowid = ?", self.home_island.worldid, self.worldid)

		# save remaining ticks when in waiting state
		if self.state == self.states.no_job_waiting:
			calls = Scheduler().get_classinst_calls(self, self.handle_no_possible_job)
			assert len(calls) == 1, 'calls: %s' % calls
			remaining_ticks = max(calls.values()[0], 1) # we have to save a number > 0
			db("UPDATE collector SET remaining_ticks = ? WHERE rowid = ?",
				 remaining_ticks, self.worldid)

	def load(self, db, worldid):
		super(WildAnimal, self).load(db, worldid)
		# get own properties
		health, can_reproduce = db.get_wildanimal_row(worldid)
		# get home island
		island = WorldObject.get_object_by_id(db.get_unit_owner(worldid))
		self.__init(island, bool(can_reproduce), health)

	def get_collectable_res(self):
		return [self._required_resource_id]

	def apply_state(self, state, remaining_ticks=None):
		super(WildAnimal, self).apply_state(state, remaining_ticks)
		if self.state == self.states.no_job_waiting:
			Scheduler().add_new_object(self.handle_no_possible_job, self, remaining_ticks)

	def handle_no_possible_job(self):
		"""Just walk to a random location nearby and search there for food, when we arrive"""
		self.log.debug('%s: no possible job; health: %s', self, self.health)
		# decrease health because of lack of food
		self.health -= WILD_ANIMAL.HEALTH_DECREASE_ON_NO_JOB
		if self.health <= 0:
			self.die()
			return

		# if can't find a job, we walk to a random location near us and search there
		(target, path) = self.get_random_location(self.walking_range)
		if target is not None:
			self.log.debug('%s: no possible job, walking to %s', self, str(target))
			self.move(target, callback=self.search_job, path=path)
			self.state = self.states.no_job_walking_randomly
		else:
			# we couldn't find a target, just try again 3 secs later
			self.log.debug('%s: no possible job, no possible new loc', self)
			Scheduler().add_new_object(self.handle_no_possible_job, self, 48)
			self.state = self.states.no_job_waiting

	def get_job(self):
		pos = self.position.to_tuple()

		# try to get away with a random job (with normal forest density this works > 99% of the time)
		for i in xrange(min(5, self._building_index.get_num_buildings_in_range(pos))):
			provider = self._building_index.get_random_building_in_range(pos)
			if provider is not None and self.check_possible_job_target(provider):
				# animals only collect one resource
				entry = self.check_possible_job_target_for(provider, self._required_resource_id)
				if entry:
					path = self.check_move(provider.loading_area)
					if path:
						job = Job(provider, [entry])
						job.path = path
						return job

		# NOTE: use random job, works fine and is faster than looking for the best
		return None

	def check_possible_job_target(self, provider):
		if provider.position.contains(self.position):
			# force animal to choose a tree where it currently not stands
			return False
		return super(WildAnimal, self).check_possible_job_target(provider)

	def end_job(self):
		super(WildAnimal, self).end_job()
		# check if we can reproduce
		self.log.debug("%s end_job; health: %s", self, self.health)
		self.health += WILD_ANIMAL.HEALTH_INCREASE_ON_FEEDING
		if self.can_reproduce and self.health >= WILD_ANIMAL.HEALTH_LEVEL_TO_REPRODUCE and \
			len(self.home_island.wild_animals) < (self.home_island.num_trees // WILD_ANIMAL.POPULATION_LIMIT):
			self.reproduce()
			# reproduction costs health
			self.health = WILD_ANIMAL.HEALTH_INIT_VALUE

	def reproduce(self):
		"""Create another animal of our type on the place where we stand"""
		if not self.can_reproduce:
			return

		self.log.debug("%s REPRODUCING", self)
		# create offspring
		CreateUnit(self.owner.worldid, self.id, self.position.x, self.position.y,
		           can_reproduce = self.next_clone_can_reproduce())(issuer=None)
		# reset own resources
		for res in self.get_consumed_resources():
			self.get_component(StorageComponent).inventory.reset(res)

	def next_clone_can_reproduce(self):
		"""Returns, whether the next child will be able to reproduce himself.
		Some animal can't reproduce, which makes population growth easier to control.
		@return: bool"""
		return (self.session.random.randint(0, 2) > 0) # 2/3 chance for True

	def die(self):
		"""Makes animal die, e.g. because of starvation or getting killed by herder"""
		self.log.debug("%s dying", self)
		self.home_island.wild_animals.remove(self)
		self.remove()

	def cancel(self, continue_action=None):
		if continue_action is None:
			continue_action = self.search_job
		super(WildAnimal, self).cancel(continue_action=continue_action)

	def __str__(self):
		return "%s(health=%s)" % (super(WildAnimal, self).__str__(),
		                          getattr(self, 'health', None))


class FarmAnimal(CollectorAnimal, BuildingCollector):
	"""Animals that are bred and live in the surrounding area of a farm, such as sheep.
	They have a home_building, representing their farm; they usually feed on whatever
	the farm grows, and collectors from the farm can collect their produced resources.
	"""
	job_ordering = JobList.order_by.random

	def __init__(self, home_building, start_hidden=False, **kwargs):
		super(FarmAnimal, self).__init__(home_building=home_building,
		                                 start_hidden=start_hidden, **kwargs)

	def register_at_home_building(self, unregister=False):
		if unregister:
			self.home_building.animals.remove(self)
		else:
			self.home_building.animals.append(self)

	def get_buildings_in_range(self, reslist=None):
		# we are only allowed to pick up at our pasture
		return [self.home_building]

	def _get_random_positions_on_object(self, obj):
		"""Returns a shuffled list of tuples, that are in obj, but not in self.position"""
		coords = obj.position.get_coordinates()
		my_position = self.position.to_tuple()
		if my_position in coords:
			coords.remove(my_position)
		self.session.random.shuffle(coords)
		return coords

	def begin_current_job(self):
		# we can only move on 1 building; simulate this by choosing a random location with
		# the building
		coords = self._get_random_positions_on_object(self.job.object)

		# move to first walkable target coord we find
		for coord in coords:
			# job target is walkable, so at least one coord of it has to be
			# so we can safely assume, that we will find a walkable coord
			target_location = Point(*coord)
			if self.check_move(target_location):
				super(FarmAnimal, self).begin_current_job(job_location=target_location)
				return
		assert False

	def handle_no_possible_job(self):
		"""Walk around on field, search again, when we arrive"""
		for coord in self._get_random_positions_on_object(self.home_building):
			try:
				self.move(Point(*coord), callback=self.search_job)
				self.state = self.states.no_job_walking_randomly
				return
			except MoveNotPossible:
				pass
		# couldn't find location, so don't move
		super(FarmAnimal, self).handle_no_possible_job()

########NEW FILE########
__FILENAME__ = animalcollector
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.scheduler import Scheduler

from horizons.util.python import decorators
from horizons.util.shapes import RadiusRect
from horizons.world.units.movingobject import MoveNotPossible
from horizons.constants import GAME_SPEED
from horizons.world.units.collectors.buildingcollector import BuildingCollector


class AnimalCollector(BuildingCollector):
	""" Collector that gets resources from animals.
	Behavior (timeline):
	 - search for an animal which has resources to pick up
	 - tell animal to stop when its current job is done
	 - wait for callback from this animal, notifying that we can pick it up
	 - walk to animal
	 - walk home (with animal walking along)
	 - stay at home building for a while
	 - release animal
	 """
	kill_animal = False # whether we kill the animals

	def __init__(self, *args, **kwargs):
		super(AnimalCollector, self).__init__(*args, **kwargs)

	def load(self, db, worldid):
		super(AnimalCollector, self).load(db, worldid)

	def apply_state(self, state, remaining_ticks=None):
		super(AnimalCollector, self).apply_state(state, remaining_ticks)
		if state == self.states.waiting_for_animal_to_stop:
			# register at target
			self.setup_new_job()
			self.stop_animal()
		elif state == self.states.moving_home:
			if not self.__class__.kill_animal:
				self.setup_new_job() # register at target if it's still alive

	def cancel(self, continue_action=None):
		if self.job is not None:
			if self.state == self.states.waiting_for_animal_to_stop:
				if hasattr(self.job.object, 'remove_stop_after_job'):
					# when loading a game fails and the world is destructed again, the
					# worldid may not yet have been resolved to an actual in-game object
					self.job.object.remove_stop_after_job()
		super(AnimalCollector, self).cancel(continue_action=continue_action)

	def begin_current_job(self):
		"""Tell the animal to stop."""
		self.setup_new_job()
		self.stop_animal()
		self.state = self.states.waiting_for_animal_to_stop

	def pickup_animal(self):
		"""Moves collector to animal. Called by animal when it actually stopped"""
		self.show()
		try:
			self.move(self.job.object.loading_area, self.begin_working)
		except MoveNotPossible:
			# the animal is now unreachable.
			self.job.object.search_job()
			self.state = self.states.idle
			self.cancel(continue_action=self.search_job)
			return
		self.state = self.states.moving_to_target

	def finish_working(self):
		"""Called when collector arrives at the animal. Move home with the animal"""
		if self.__class__.kill_animal:
			# get res now, and kill animal right after
			super(AnimalCollector, self).finish_working()
		else:
			self.move_home(callback=self.reached_home)
		self.get_animal() # get or kill animal

	def reached_home(self):
		"""Transfer res to home building and such. Called when collector arrives at it's home"""
		if not self.__class__.kill_animal:
			# sheep and herder are inside the building now, pretending to work.
			super(AnimalCollector, self).finish_working(collector_already_home=True)
			self.release_animal()
		super(AnimalCollector, self).reached_home()

	def get_buildings_in_range(self, reslist=None):
		return self.get_animals_in_range(reslist)

	def get_animals_in_range(self, reslist=None):
		return self.home_building.animals

	@decorators.make_constants()
	def check_possible_job_target_for(self, target, res):
		# An animal can only be collected by one collector.
		# Since a collector only retrieves one type of res, and
		# an animal might produce more than one, two collectors
		# could take this animal as a target.
		# This could also happen, if the animal has an inventory
		# with a limit > 1. In this case, one collector might register
		# for the first ton, then the animal produces another one, which
		# might then be spotted by another collector.
		# TODO:
		# The animal class must be producer class that is only
		# collectable by 1 collector at a time, which also should be checked.
		# This could be a new abstract class.
		if target.has_collectors():
			return None
		else:
			return super(AnimalCollector, self).check_possible_job_target_for(target, res)

	def stop_animal(self):
		"""Tell animal to stop at the next occasion"""
		self.job.object.stop_after_job(self)

	def get_animal(self):
		"""Sends animal to collectors home building"""
		self.log.debug("%s getting animal %s", self, self.job.object)
		if self.__class__.kill_animal:
			self.job.object.die()
			self.job.object = None # there is no target anymore now
		else:
			self.job.object.move(self.home_building.position, destination_in_building = True,
			                     action='move_full')

	def release_animal(self):
		"""Let animal free after shearing and schedules search for a new job for animal."""
		if not self.__class__.kill_animal:
			self.log.debug("%s releasing animal %s", self, self.job.object)
			Scheduler().add_new_object(self.job.object.search_job, self.job.object,
			                           GAME_SPEED.TICKS_PER_SECOND)


class FarmAnimalCollector(AnimalCollector):
	def get_animals_in_range(self, reslist=None):
		"""Returns animals from buildings in range"""
		reach = RadiusRect(self.home_building.position, self.home_building.radius)
		# don't consider res when searching for buildings, since only their animals are
		# the actual providers
		buildings = self.home_building.island.get_providers_in_range(reach)
		animal_lists = (building.animals for building in buildings if hasattr(building, 'animals'))
		# use overloaded + for lists here in sum
		return sum(animal_lists, [])


class HunterCollector(AnimalCollector):
	kill_animal = True

	def get_animals_in_range(self, res=None):
		dist = self.home_building.position.distance
		radius = self.home_building.radius
		return [ animal for animal in self.home_building.island.wild_animals if
		         dist(animal.position) <= radius ]


decorators.bind_all(AnimalCollector)
decorators.bind_all(FarmAnimalCollector)
decorators.bind_all(HunterCollector)

########NEW FILE########
__FILENAME__ = buildingcollector
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import weakref
from collections import deque

from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.shapes import RadiusRect
from horizons.util.worldobject import WorldObject
from horizons.util.pathfinding.pather import RoadPather, BuildingCollectorPather
from horizons.constants import COLLECTORS, BUILDINGS
from horizons.scheduler import Scheduler
from horizons.world.units.movingobject import MoveNotPossible
from horizons.world.units.collectors.collector import Collector, JobList, Job
from horizons.component.storagecomponent import StorageComponent
from horizons.component.collectingcomponent import CollectingComponent


class BuildingCollector(Collector):
	"""Collector, that works for a building and gets its needed resources.
	Essentially extends the Collector by a home building.

	Nearly all of the time, the collector has to have a home_building.
	Only fisher ships violate this rule in case their home building gets demolished.
	Therefore, this class is not functional with home_building == None,
	but basic facilities (esp. save/load) have to work.
	"""
	job_ordering = JobList.order_by.fewest_available_and_distance
	pather_class = BuildingCollectorPather

	def __init__(self, home_building, **kwargs):
		kwargs['x'] = home_building.position.origin.x
		kwargs['y'] = home_building.position.origin.y
		super(BuildingCollector, self).__init__(**kwargs)
		self._job_history = deque()
		self._creation_tick = Scheduler().cur_tick + 1 # adjusted for the initial delay
		self.__init(home_building)

	def __init(self, home_building):
		self.home_building = home_building
		if home_building is not None:
			self.register_at_home_building()
		# save whether it's possible for this instance to access a target
		# @chachedmethod is not applicable since it stores hard refs in the arguments
		self._target_possible_cache = weakref.WeakKeyDictionary()

	def save(self, db):
		super(BuildingCollector, self).save(db)
		self._clean_job_history_log()
		current_tick = Scheduler().cur_tick

		# save home_building and creation tick
		# pre-translate the tick number for the loading process
		translated_creation_tick = self._creation_tick - current_tick + 1
		db("INSERT INTO building_collector(rowid, home_building, creation_tick) VALUES(?, ?, ?)",
			self.worldid, self.home_building.worldid if self.home_building is not None else None,
			translated_creation_tick)

		# save job history
		for tick, utilization in self._job_history:
			# pre-translate the tick number for the loading process
			translated_tick = tick - current_tick + Scheduler.FIRST_TICK_ID
			db("INSERT INTO building_collector_job_history(collector, tick, utilisation) VALUES(?, ?, ?)",
				 self.worldid, translated_tick, utilization)

	def load(self, db, worldid):
		# we have to call __init here before super().load, because a superclass uses a method,
		# which is overwritten here, that uses a member, which has to be initialized via __init.

		# load home_building
		home_building_id, self._creation_tick = db.get_building_collectors_data(worldid)
		self.__init(None if home_building_id is None else WorldObject.get_object_by_id(home_building_id))

		super(BuildingCollector, self).load(db, worldid)

		if home_building_id is None:
			self.show() # make sure that homebuildingsless units are visible on startup
			# TODO: fix "homebuildingless buildingcollectors".
			#       perhaps a new unit should be created, because a fisher ship without a
			#       fisher basically isn't a buildingcollector anymore.

		# load job search failures
		# the tick values were translated to assume that it is currently tick -1
		assert Scheduler().cur_tick == Scheduler.FIRST_TICK_ID - 1
		self._job_history = db.get_building_collector_job_history(worldid)

	def register_at_home_building(self, unregister=False):
		"""Creates reference for self at home building (only hard reference except for
		in job.object)
		@param unregister: whether to reverse registration
		"""
		# TODO: figure out why the home_building can be None when this is run in session.end()
		if self.home_building is not None:
			if unregister:
				self.home_building.get_component(CollectingComponent).remove_local_collector(self)
			else:
				self.home_building.get_component(CollectingComponent).add_local_collector(self)

	def apply_state(self, state, remaining_ticks=None):
		super(BuildingCollector, self).apply_state(state, remaining_ticks)
		if state == self.states.moving_home:
			# collector is on its way home
			self.add_move_callback(self.reached_home)
			self.add_blocked_callback(self.handle_path_home_blocked)
			self.show()

	def remove(self):
		self.register_at_home_building(unregister=True)
		self.home_building = None
		super(BuildingCollector, self).remove()

	def decouple_from_home_building(self):
		"""Makes collector survive deletion of home building."""
		self.cancel(continue_action=lambda : 42) # don't continue
		self.stop()
		self.register_at_home_building(unregister=True)
		self.home_building = None
		self.state = self.states.decommissioned
		self.show() # make sure collector is not pretending to be inside somewhere

	def get_home_inventory(self):
		return self.home_building.get_component(StorageComponent).inventory

	def get_colleague_collectors(self):
		colls = self.home_building.get_component(CollectingComponent).get_local_collectors()
		return ( coll for coll in colls if coll is not self )

	@decorators.make_constants()
	def get_job(self):
		"""Returns the next job or None"""
		if self.home_building is None:
			return None

		collectable_res = self.get_collectable_res()
		if not collectable_res:
			return None

		jobs = JobList(self, self.job_ordering)
		# iterate all building that provide one of the resources
		for building in self.get_buildings_in_range(reslist=collectable_res):
			# check if we can pickup here on principle
			target_possible = self._target_possible_cache.get(building, None)
			if target_possible is None: # not in cache, we have to check
				target_possible = self.check_possible_job_target(building)
				self._target_possible_cache[building] = target_possible

			if target_possible:
				# check for res here
				reslist = ( self.check_possible_job_target_for(building, res) for res in collectable_res )
				reslist = [i for i in reslist if i]

				if reslist: # we can do something here
					jobs.append( Job(building, reslist) )

		# TODO: find out why order of  self.get_buildings_in_range(..) and therefore order of jobs differs from client to client
		# TODO: find out why WildAnimal.get_job(..) doesn't have this problem
		# for MP-Games the jobs must have the same ordering to ensure get_best_possible_job(..) returns the same result
		jobs.sort(key=lambda job: job.object.worldid)

		return self.get_best_possible_job(jobs)

	def search_job(self):
		self._clean_job_history_log()
		super(BuildingCollector, self).search_job()


	def handle_no_possible_job(self):
		super(BuildingCollector, self).handle_no_possible_job()
		# only append a new element if it is different from the last one
		if not self._job_history or abs(self._job_history[-1][1]) > 1e-9:
			self._job_history.append((Scheduler().cur_tick, 0))

	def begin_current_job(self, job_location=None):
		super(BuildingCollector, self).begin_current_job(job_location)
		# Sum up the utilization for all res
		utilization = 0.0
		for entry in self.job.reslist:
			max_amount = min(self.get_component(StorageComponent).inventory.get_limit(entry.res),
			                 self.job.object.get_component(StorageComponent).inventory.get_limit(entry.res))
			utilization += entry.amount / float(max_amount)

		# Divide by number of resources being transferred
		utilization = utilization / len(self.job.reslist)

		# Set job history
		if not self._job_history or abs(self._job_history[-1][1] - utilization) > 1e-9:
			self._job_history.append((Scheduler().cur_tick, utilization))

	def finish_working(self, collector_already_home=False):
		"""Called when collector has stayed at the target for a while.
		Picks up the resources and sends collector home.
		@param collector_already_home: whether collector has moved home before."""
		if not collector_already_home:
			self.move_home(callback=self.reached_home)
		super(BuildingCollector, self).finish_working()

	# unused reroute code removed in 2aef7bba77536da333360566467d9a2f08d38cab

	def reached_home(self):
		"""Exchanges resources with home and calls end_job"""
		self.log.debug("%s reached home", self)
		for entry in self.job.reslist:
			self.transfer_res_to_home(entry.res, entry.amount)
		self.end_job()

	def get_collectable_res(self):
		"""Return all resources the collector can collect (depends on its home building)"""
		# find needed res (only res that we have free room for) - Building function
		return self.home_building.get_needed_resources()

	def get_buildings_in_range(self, reslist=None):
		"""Returns all buildings in range .
		Overwrite in subclasses that need ranges around the pickup.
		@param res: optional, only search for buildings that provide res"""
		reach = RadiusRect(self.home_building.position, self.home_building.radius)
		return self.home_building.island.get_providers_in_range(reach, reslist=reslist,
		                                                        player=self.owner)

	def handle_path_home_blocked(self):
		"""Called when we get blocked while trying to move to the job location. """
		self.log.debug("%s: got blocked while moving home, teleporting home", self)
		# make sure to get home, this prevents all movement problems by design
		# at the expense of some jumping in very unusual corner cases
		# NOTE: if this is seen as problem, self.resume_movement() could be tried before reverting to teleportation
		self.teleport(self.home_building, callback=self.move_callbacks, destination_in_building=True)

	def move_home(self, callback=None, action='move_full'):
		"""Moves collector back to its home building"""
		self.log.debug("%s move_home", self)
		if self.home_building.position.contains(self.position):
			# already home
			self.stop() # make sure unit doesn't go anywhere in case a movement is going on
			Scheduler().add_new_object(callback, self, run_in=0)
		else:
			# actually move home
			try:
				# reuse reversed path of path here (assumes all jobs started at home)
				path = None if (self.job is None or self.job.path is None) else list(reversed(self.job.path))
				self.move(self.home_building, callback=callback, destination_in_building=True,
				          action=action, blocked_callback=self.handle_path_home_blocked, path=path)
				self.state = self.states.moving_home
			except MoveNotPossible:
				# we are in trouble.
				# the collector went somewhere, now there is no way for them to move home.
				# this is an unsolved problem also in reality, so we are forced to use an unconventional solution.
				self.teleport(self.home_building, callback=callback, destination_in_building=True)

	def cancel(self, continue_action=None):
		"""Cancels current job and moves back home"""
		self.log.debug("%s cancel", self)
		if continue_action is None:
			continue_action = Callback(self.move_home, callback=self.end_job, action='move')
		super(BuildingCollector, self).cancel(continue_action=continue_action)

	def get_utilization_history_length(self):
		return min(COLLECTORS.STATISTICAL_WINDOW, Scheduler().cur_tick - self._creation_tick)

	def get_utilization(self):
		"""
		Returns the utilization of the collector.
		It is calculated by observing how full the inventory of the collector is or
		how full it would be if it had reached the place where it picks up the resources.
		"""

		history_length = self.get_utilization_history_length()
		if history_length <= 0:
			return 0

		current_tick = Scheduler().cur_tick
		first_relevant_tick = current_tick - history_length

		self._clean_job_history_log()
		num_entries = len(self._job_history)
		total_utilization = 0
		for i in xrange(num_entries):
			tick = self._job_history[i][0]
			if tick >= current_tick:
				break

			next_tick = min(self._job_history[i + 1][0], current_tick) if i + 1 < num_entries else current_tick
			relevant_ticks = next_tick - tick
			if tick < first_relevant_tick:
				# the beginning is not relevant
				relevant_ticks -= first_relevant_tick - tick
			total_utilization += relevant_ticks * self._job_history[i][1]

		#assert -1e-7 < total_utilization / float(history_length) < 1 + 1e-7

		return total_utilization / float(history_length)

	def _clean_job_history_log(self):
		""" remove too old entries """
		first_relevant_tick = Scheduler().cur_tick - self.get_utilization_history_length()
		while len(self._job_history) > 1 and self._job_history[1][0] < first_relevant_tick:
			self._job_history.popleft()


class StorageCollector(BuildingCollector):
	""" Same as BuildingCollector, except that it moves on roads.
	Used in storage facilities.
	"""
	pather_class = RoadPather
	destination_always_in_building = True
	job_ordering = JobList.order_by.for_storage_collector


class FieldCollector(BuildingCollector):
	""" Similar to the BuildingCollector but used on farms for example.
	The main difference is that it uses a different way to sort it's jobs, to make for a nicer
	look of farm using."""
	job_ordering = JobList.order_by.random


class SettlerCollector(StorageCollector):
	"""Collector for settlers."""
	pass


class FisherShipCollector(BuildingCollector):

	def __init__(self, *args, **kwargs):
		if not args:
			# We haven't preset a home_building, so search for one!
			home_building = self.get_smallest_fisher(kwargs['session'], kwargs['owner'])
			super(FisherShipCollector, self).__init__(home_building=home_building, *args, **kwargs)
		else:
			super(FisherShipCollector, self).__init__(*args, **kwargs)

	def get_smallest_fisher(self, session, owner):
		"""Returns the fisher with the least amount of boats"""
		fishers = []
		for settlement in session.world.settlements:
			if settlement.owner == owner:
				fishers.extend(settlement.buildings_by_id[BUILDINGS.FISHER])
		smallest_fisher = fishers.pop()
		for fisher in fishers:
			if len(smallest_fisher.get_local_collectors()) > len(fisher.get_local_collectors()):
				smallest_fisher = fisher

		return smallest_fisher

	def get_buildings_in_range(self, reslist=None):
		"""Returns all buildings in range .
		Overwrite in subclasses that need ranges around the pickup.
		@param res: optional, only search for buildings that provide res"""
		reach = RadiusRect(self.home_building.position, self.home_building.radius)
		return self.session.world.get_providers_in_range(reach, reslist=reslist)


class DisasterRecoveryCollector(StorageCollector):
	"""Collects disasters such as fire or pestilence."""
	def finish_working(self, collector_already_home=False):
		super(DisasterRecoveryCollector, self).finish_working(collector_already_home=collector_already_home)
		building = self.job.object
		if hasattr(building, "disaster"): # make sure that building hasn't recovered any other way
			building.disaster.recover(building)

	def get_job(self):
		if self.home_building is not None and \
		   not self.session.world.disaster_manager.is_affected( self.home_building.settlement ):
			return None # not one disaster active, bail out

		return super(DisasterRecoveryCollector, self).get_job()

decorators.bind_all(BuildingCollector)
decorators.bind_all(FieldCollector)
decorators.bind_all(FisherShipCollector)
decorators.bind_all(SettlerCollector)
decorators.bind_all(StorageCollector)
decorators.bind_all(DisasterRecoveryCollector)

########NEW FILE########
__FILENAME__ = collector
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import operator
import logging
from collections import namedtuple

from horizons.scheduler import Scheduler
from horizons.util.pathfinding import PathBlockedError
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.worldobject import WorldObject
from horizons.ext.enum import Enum
from horizons.world.units.unit import Unit
from horizons.constants import COLLECTORS
from horizons.component.storagecomponent import StorageComponent
from horizons.component.restrictedpickup import RestrictedPickup
from horizons.component.ambientsoundcomponent import AmbientSoundComponent

class Collector(Unit):
	"""Base class for every collector. Does not depend on any home building.

	Timeline:
	 * search_job
	 * * get_job
	 * * handle_no_possible_job
	 * * begin_current_job
	 * * * setup_new_job
	 * * * move to target
	 on arrival there:
	 * begin_working
	 after some pretended working:
	 * finish_working
	 * * transfer_res
	 after subclass has done actions to finish job:
	 * end_job
	"""
	log = logging.getLogger("world.units.collector")

	work_duration = COLLECTORS.DEFAULT_WORK_DURATION # default is 16
	destination_always_in_building = False

	# all states, any (subclass) instance may have. Keeping a list in one place
	# is important, because every state must have a distinct number.
	# Handling of subclass specific states is done by subclass.
	states = Enum('idle', # doing nothing, waiting for job
	              'moving_to_target',
	              'working',
	              'moving_home',
	              'waiting_for_animal_to_stop', # herder: wait for job target to finish for collecting
	              'waiting_for_herder', # animal: has stopped, now waits for herder
	              'no_job_walking_randomly', # animal: like idle, but moving instead of standing still
	              'no_job_waiting', # animal: as idle, but no move target can be found
	              # TODO: merge no_job_waiting with idle
	              'decommissioned', # fisher ship: When home building got demolished. No more collecting.
	              )


	# INIT/DESTRUCT

	def __init__(self, x, y, slots=1, start_hidden=True, **kwargs):
		super(Collector, self).__init__(slots=slots,
		                                x=x, y=y,
		                                **kwargs)

		self.__init(self.states.idle, start_hidden)

		# start searching jobs just when construction (of subclass) is completed
		Scheduler().add_new_object(self.search_job, self, 1)

	def __init(self, state, start_hidden):
		self.state = state
		self.start_hidden = start_hidden
		if self.start_hidden:
			self.hide()

		self.job = None # here we store the current job as Job object

	def remove(self):
		"""Removes the instance. Useful when the home building is destroyed"""
		self.log.debug("%s: remove called", self)
		self.cancel(continue_action=lambda : 42)
		# remove from target collector list
		self._abort_collector_job()
		self.hide()
		self.job = None
		super(Collector, self).remove()

	def _abort_collector_job(self):
		if self.job is None or self.state == self.states.moving_home:
			# in the move_home state, there still is a job, but the collector is
			# already deregistered
			return
		if not hasattr(self.job.object, 'remove_incoming_collector'):
			# when loading a game fails and the world is destructed again, the
			# worldid may not yet have been resolved to an actual in-game object
			return
		self.job.object.remove_incoming_collector(self)

	# SAVE/LOAD

	def save(self, db):
		super(Collector, self).save(db)

		# save state and remaining ticks for next callback
		# retrieve remaining ticks according current callback according to state
		current_callback = None
		remaining_ticks = None
		if self.state == self.states.idle:
			current_callback = self.search_job
		elif self.state == self.states.working:
			current_callback = self.finish_working
		if current_callback is not None:
			calls = Scheduler().get_classinst_calls(self, current_callback)
			assert len(calls) == 1, 'Collector should have callback %s scheduled, but has %s' % \
			        (current_callback, [ str(i) for i in Scheduler().get_classinst_calls(self).keys() ])
			remaining_ticks = max(calls.values()[0], 1) # save a number > 0

		db("INSERT INTO collector(rowid, state, remaining_ticks, start_hidden) VALUES(?, ?, ?, ?)",
		   self.worldid, self.state.index, remaining_ticks, self.start_hidden)

		# save the job
		if self.job is not None:
			obj_id = -1 if self.job.object is None else self.job.object.worldid
			# this is not in 3rd normal form since the object is saved multiple times but
			# it preserves compatibility with old savegames this way.
			for entry in self.job.reslist:
				db("INSERT INTO collector_job(collector, object, resource, amount) VALUES(?, ?, ?, ?)",
				   self.worldid, obj_id, entry.res, entry.amount)

	def load(self, db, worldid):
		super(Collector, self).load(db, worldid)

		# load collector properties
		state_id, remaining_ticks, start_hidden = \
		        db("SELECT state, remaining_ticks, start_hidden FROM collector \
		            WHERE rowid = ?", worldid)[0]
		self.__init(self.states[state_id], start_hidden)

		# load job
		job_db = db("SELECT object, resource, amount FROM collector_job WHERE collector = ?", worldid)
		if job_db:
			reslist = []
			for obj, res, amount in job_db:
				reslist.append( Job.ResListEntry(res, amount, False) )
			# create job with worldid of object as object. This is used to defer the target resolution,
			# which might not have been loaded
			self.job = Job(obj, reslist)

		def fix_job_object():
			# resolve worldid to object later
			if self.job:
				if self.job.object == -1:
					self.job.object = None   # e.g. when hunters have killed their prey
				else:
					self.job.object = WorldObject.get_object_by_id(self.job.object)

		# apply state when job object is loaded for sure
		Scheduler().add_new_object(
		  Callback.ChainedCallbacks(
		    fix_job_object,
		    Callback(self.apply_state, self.state, remaining_ticks)),
		    self, run_in=0
		)

	def apply_state(self, state, remaining_ticks=None):
		"""Takes actions to set collector to a state. Useful after loading.
		@param state: EnumValue from states
		@param remaining_ticks: ticks after which current state is finished
		"""
		if state == self.states.idle:
			# we do nothing, so schedule a new search for a job
			Scheduler().add_new_object(self.search_job, self, remaining_ticks)
		elif state == self.states.moving_to_target:
			# we are on the way to target, so save the job
			self.setup_new_job()
			# and notify us, when we're at target
			self.add_move_callback(self.begin_working)
			self.add_blocked_callback(self.handle_path_to_job_blocked)
			self.show()
		elif state == self.states.working:
			# we are at the target and work
			# register the new job
			self.setup_new_job()
			# job finishes in remaining_ticks ticks
			Scheduler().add_new_object(self.finish_working, self, remaining_ticks)


	# GETTER

	def get_home_inventory(self):
		"""Returns inventory where collected res will be stored.
		This could be the inventory of a home_building, or it's own.
		"""
		raise NotImplementedError

	def get_colleague_collectors(self):
		"""Returns a list of collectors, that work for the same "inventory"."""
		return []

	def get_collectable_res(self):
		"""Return all resources the collector can collect"""
		raise NotImplementedError

	def get_job(self):
		"""Returns the next job or None"""
		raise NotImplementedError


	# BEHAVIOR
	def search_job(self):
		"""Search for a job, only called if the collector does not have a job.
		If no job is found, a new search will be scheduled in a few ticks."""
		self.job = self.get_job()
		if self.job is None:
			self.handle_no_possible_job()
		else:
			self.begin_current_job()

	def handle_no_possible_job(self):
		"""Called when we can't find a job. default is to wait and try again in a few secs"""
		self.log.debug("%s: found no possible job, retry in %s ticks", self, COLLECTORS.DEFAULT_WAIT_TICKS)
		Scheduler().add_new_object(self.search_job, self, COLLECTORS.DEFAULT_WAIT_TICKS)

	def setup_new_job(self):
		"""Executes the necessary actions to begin a new job"""
		self.job.object.add_incoming_collector(self)

	def check_possible_job_target(self, target):
		"""Checks if we "are allowed" and able to pick up from the target"""
		# Discard building if it works for same inventory (happens when both are storage buildings
		# or home_building is checked out)
		if target.get_component(StorageComponent).inventory is self.get_home_inventory():
			#self.log.debug("nojob: same inventory")
			return False

		if self.has_component(RestrictedPickup): # check if we're allowed to pick up there
			return self.get_component(RestrictedPickup).pickup_allowed_at(target.id)

		# pathfinding would fit in here, but it's too expensive,
		# we just do that at targets where we are sure to get a lot of res later on.

		return True

	@decorators.make_constants()
	def check_possible_job_target_for(self, target, res):
		"""Checks out if we could get res from target.
		Does _not_ check for anything else (e.g. if we are able to walk there).
		@param target: possible target. buildings are supported, support for more can be added.
		@param res: resource id
		@return: instance of Job or None, if we can't collect anything
		"""
		res_amount = target.get_available_pickup_amount(res, self)
		if res_amount <= 0:
			#self.log.debug("nojob: no pickup amount")
			return None

		# check if other collectors get this resource, because our inventory could
		# get full if they arrive.
		total_registered_amount_consumer = sum(
		  entry.amount for
		  collector in self.get_colleague_collectors() if
		  collector.job is not None for
		  entry in collector.job.reslist if
		  entry.res == res )

		inventory = self.get_home_inventory()

		# check if there are resources left to pickup
		home_inventory_free_space = inventory.get_limit(res) - \
		                        (total_registered_amount_consumer + inventory[res])
		if home_inventory_free_space <= 0:
			#self.log.debug("nojob: no home inventory space")
			return None

		collector_inventory_free_space = self.get_component(StorageComponent).inventory.get_free_space_for(res)
		if collector_inventory_free_space <= 0:
			#self.log.debug("nojob: no collector inventory space")
			return None

		possible_res_amount = min(res_amount, home_inventory_free_space,
		                          collector_inventory_free_space)

		target_inventory_full = (target.get_component(StorageComponent).inventory.get_free_space_for(res) == 0)

		# create a new data line.
		return Job.ResListEntry(res, possible_res_amount, target_inventory_full)

	def get_best_possible_job(self, jobs):
		"""Return best possible job from jobs.
		"Best" means that the job is highest when the job list was sorted.
		"Possible" means that we can find a path there.
		@param jobs: unsorted JobList instance
		@return: selected Job instance from list or None if no jobs are possible."""
		jobs.sort_jobs()
		# check if we can move to that targets
		for job in jobs:
			path = self.check_move(job.object.loading_area)
			if path:
				job.path = path
				return job

		return None

	def begin_current_job(self, job_location=None):
		"""Starts executing the current job by registering itself and moving to target.
		@param job_location: Where collector should work. default: job.object.loading_area"""
		self.log.debug("%s prepares job %s", self, self.job)
		self.setup_new_job()
		self.show()
		if job_location is None:
			job_location = self.job.object.loading_area
		self.move(job_location, self.begin_working,
		          destination_in_building = self.destination_always_in_building,
		          blocked_callback = self.handle_path_to_job_blocked, path=self.job.path)
		self.state = self.states.moving_to_target

	def resume_movement(self):
		"""Try to resume movement after getting blocked. If that fails then wait and try again."""
		try:
			self._move_tick(resume=True)
		except PathBlockedError:
			Scheduler().add_new_object(self.resume_movement, self, COLLECTORS.DEFAULT_WAIT_TICKS)

	def handle_path_to_job_blocked(self):
		"""Called when we get blocked while trying to move to the job location.
		The default action is to resume movement in a few seconds."""
		self.log.debug("%s: got blocked while moving to the job location, trying again in %s ticks.",
			self, COLLECTORS.DEFAULT_WAIT_TICKS)
		Scheduler().add_new_object(self.resume_movement, self, COLLECTORS.DEFAULT_WAIT_TICKS)

	def begin_working(self):
		"""Pretends that the collector works by waiting some time. finish_working is
		called after that time."""
		self.log.debug("%s begins working", self)
		assert self.job is not None, '%s job is None in begin_working' % self
		Scheduler().add_new_object(self.finish_working, self, self.work_duration)
		# play working sound
		if self.has_component(AmbientSoundComponent):
			am_comp = self.get_component(AmbientSoundComponent)
			if am_comp.soundfiles:
				am_comp.play_ambient(am_comp.soundfiles[0], position=self.position)
		self.state = self.states.working

	def finish_working(self):
		"""Called when collector has stayed at the target for a while.
		Picks up the resources.
		Should be overridden to specify what the collector should do after this."""
		self.log.debug("%s finished working", self)
		self.act("idle", self._instance.getFacingLocation(), True)
		# deregister at the target we're at
		self.job.object.remove_incoming_collector(self)
		# reconsider job now: there might now be more res available than there were when we started

		reslist = ( self.check_possible_job_target_for(self.job.object, res) for res in self.get_collectable_res() )
		reslist = [i for i in reslist if i]
		if reslist:
			self.job.reslist = reslist

		# transfer res (this must be the last step, it will trigger consecutive actions through the
		# target inventory changelistener, and the collector must be in a consistent state then.
		self.transfer_res_from_target()
		# stop playing ambient sound if any
		if self.has_component(AmbientSoundComponent):
			self.get_component(AmbientSoundComponent).stop_sound()

	def transfer_res_from_target(self):
		"""Transfers resources from target to collector inventory"""
		new_reslist = []
		for entry in self.job.reslist:
			actual_amount = self.job.object.pickup_resources(entry.res, entry.amount, self)
			if entry.amount != actual_amount:
				new_reslist.append( Job.ResListEntry(entry.res, actual_amount, False) )
			else:
				new_reslist.append( entry )

			remnant = self.get_component(StorageComponent).inventory.alter(entry.res, actual_amount)
			assert remnant == 0, "%s couldn't take all of res %s; remnant: %s; planned: %s" % \
			       (self, entry.res, remnant, entry.amount)
		self.job.reslist = new_reslist

	def transfer_res_to_home(self, res, amount):
		"""Transfer resources from collector to the home inventory"""
		self.log.debug("%s brought home %s of %s", self, amount, res)
		remnant = self.get_home_inventory().alter(res, amount)
		#assert remnant == 0, "Home building could not take all resources from collector."
		remnant = self.get_component(StorageComponent).inventory.alter(res, -amount)
		assert remnant == 0, "%s couldn't give all of res %s; remnant: %s; inventory: %s" % \
		       (self, res, remnant, self.get_component(StorageComponent).inventory)

	# unused reroute code removed in 2aef7bba77536da333360566467d9a2f08d38cab

	def end_job(self):
		"""Contrary to setup_new_job"""
		# the job now is finished now
		# before the new job can begin this will be executed
		self.log.debug("%s end_job - waiting for new search_job", self)
		if self.start_hidden:
			self.hide()
		self.job = None
		Scheduler().add_new_object(self.search_job, self, COLLECTORS.DEFAULT_WAIT_TICKS)
		self.state = self.states.idle

	def cancel(self, continue_action):
		"""Aborts the current job.
		@param continue_action: Callback, gets called after cancel. Specifies what collector
		                        is supposed to do now.
		NOTE: Subclasses set this to a proper action that makes the collector continue to work.
		      If the collector is supposed to be remove, use a noop.
		"""
		self.stop()
		self.log.debug("%s was cancelled, continue action is %s", self, continue_action)
		# remove us as incoming collector at target
		self._abort_collector_job()
		if self.job is not None:
			# clean up depending on state
			if self.state == self.states.working:
				removed_calls = Scheduler().rem_call(self, self.finish_working)
				assert removed_calls == 1, 'removed %s calls instead of one' % removed_calls
			self.job = None
			self.state = self.states.idle
		# NOTE:
		# Some blocked movement callbacks use this callback. All blocked
		# movement callbacks have to be cancelled here, else the unit will try
		# to continue the movement later when its state has already changed.
		# This line should fix it sufficiently for now and the problem could be
		# deprecated when the switch to a component-based system is accomplished.
		Scheduler().rem_call(self, self.resume_movement)
		continue_action()

	def __str__(self):
		try:
			return super(Collector, self).__str__() + "(state=%s)" % self.state
		except AttributeError: # state has not been set
			return super(Collector, self).__str__()


class Job(object):
	"""Data structure for storing information of collector jobs"""
	ResListEntry = namedtuple("ResListEntry", ["res", "amount", "target_inventory_full"])
	def __init__(self, obj, reslist):
		"""
		@param obj: ResourceHandler that provides res
		@param reslist: ResListEntry list
			res: resource to get
			amount: amount of resource to get
			target_inventory_full: whether target inventory can't store any more of this res.
		"""
		for entry in reslist:
			assert entry.amount >= 0
		# can't assert that it's not 0, since the value is reset to the amount
		# the collector actually got at the target, which might be 0. yet for new jobs
		# amount > 0 is a necessary precondition.

		self.object = obj
		self.reslist = reslist

		self.path = None # attribute to temporarily store path

	@decorators.cachedproperty
	def amount_sum(self):
		# NOTE: only guaranteed to be correct during job search phase
		return sum(entry.amount for entry in self.reslist)

	@decorators.cachedproperty
	def resources(self):
		# NOTE: only guaranteed to be correct during job search phase
		return [entry.res for entry in self.reslist]

	@decorators.cachedproperty
	def target_inventory_full_num(self):
		# NOTE: only guaranteed to be correct during job search phase
		return sum(1 for entry in self.reslist if entry.target_inventory_full)

	def __str__(self):
		return "Job(%s, %s)" % (self.object, self.reslist)


class JobList(list):
	"""Data structure for evaluating best jobs.
	It's a list extended by special sort functions.
	"""
	order_by = Enum('rating', 'amount', 'random', 'fewest_available', 'fewest_available_and_distance', 'for_storage_collector', 'distance')

	def __init__(self, collector, job_order):
		"""
		@param collector: collector instance
		@param job_order: instance of order_by-Enum
		"""
		super(JobList, self).__init__()
		self.collector = collector
		# choose actual function by name of enum value
		sort_fun_name = '_sort_jobs_' + str(job_order)
		if not hasattr(self, sort_fun_name):
			self.sort_jobs = self._sort_jobs_amount
			print 'WARNING: invalid job order: ', job_order
		else:
			self.sort_jobs = getattr(self, sort_fun_name)

	def sort_jobs(self, obj):
		"""Call this to sort jobs"""
		# (this is overwritten in __init__)
		raise NotImplementedError

	def _sort_jobs_random(self):
		"""Sorts jobs randomly"""
		self.collector.session.random.shuffle(self)

	def _sort_jobs_amount(self):
		"""Sorts the jobs by the amount of resources available"""
		self.sort(key=operator.attrgetter('amount_sum'), reverse=True)

	def _sort_jobs_fewest_available(self, shuffle_first=True):
		"""Prefer jobs where least amount is available in obj's inventory.
		Only considers resource of resource list with minimum amount available.
		This is supposed to fix urgent shortages."""
		# shuffle list before sorting, so that jobs with same value have equal chance
		if shuffle_first:
			self.collector.session.random.shuffle(self)
		inventory = self.collector.get_home_inventory()
		self.sort(key=lambda job: min(inventory[res] for res in job.resources), reverse=False)

	def _sort_jobs_fewest_available_and_distance(self):
		"""Sort jobs by distance, but secondarily also consider fewest available resources"""
		# python sort is stable, so two sequenced sorts work.
		self._sort_jobs_fewest_available(shuffle_first=False)
		self._sort_jobs_distance()

	def _sort_jobs_for_storage_collector(self):
		"""Special sophisticated sorting routing for storage collectors.
		Same as fewest_available_and_distance_, but also considers whether target inv is full."""
		self._sort_jobs_fewest_available_and_distance()
		self._sort_target_inventory_full()

	def _sort_jobs_distance(self):
		"""Prefer targets that are nearer"""
		collector_point = self.collector.position
		self.sort(key=lambda job: collector_point.distance(job.object.loading_area))

	def _sort_target_inventory_full(self):
		"""Prefer targets with full inventory"""
		self.sort(key=operator.attrgetter('target_inventory_full_num'), reverse=True)

	def __str__(self):
		return unicode([ unicode(i) for i in self ])


decorators.bind_all(Collector)

########NEW FILE########
__FILENAME__ = fightingship
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.constants import WEAPONS, GAME_SPEED
from horizons.world.units.weaponholder import MovingWeaponHolder
from horizons.world.units.ship import Ship
from horizons.component.commandablecomponent import CommandableComponent

class FightingShip(MovingWeaponHolder, Ship):
	"""Class representing a fighting ship ship
	@param x: int x position
	@param y: int y position
	"""
	health_bar_y = -190

	def __init__(self, x, y, **kwargs):
		super(FightingShip, self).__init__(x=x, y=y, **kwargs)
		# add default weapons
		for i in xrange(WEAPONS.DEFAULT_FIGHTING_SHIP_WEAPONS_NUM):
			self.add_weapon_to_storage(WEAPONS.CANNON)

	def go(self, x, y):
		self.get_component(CommandableComponent).go(x, y)
		self.stop_attack()

	def fire_all_weapons(self, dest, rotate=True):
		"""
		Fire weapons at rotated coordinates
		"""
		super(FightingShip, self).fire_all_weapons(dest, rotate)

	def act_attack(self, dest):
		"""
		Rotates the ship and triggers correct animation
		"""
		# rotate the ship so it faces dest
		# for this rotate facing location coordinates around position coordinates
		self.stop_for(GAME_SPEED.TICKS_PER_SECOND * 2)
		self_location = self._instance.getLocation()
		facing_location = self._instance.getFacingLocation()

		# ship coords
		x1 = self_location.getMapCoordinates().x
		y1 = self_location.getMapCoordinates().y
		# target coords
		x2 = dest.x
		y2 = dest.y
		# facing coords
		x3 = facing_location.getMapCoordinates().x
		y3 = facing_location.getMapCoordinates().y
		facing_coords = facing_location.getMapCoordinates()
		# calculate the side of the ship - target line facing location is on
		# side > 0 left, side <= 0 right
		side = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)
		# calculate x4 y4 the new facing location coords
		# they are calculated by rotating 90' the target location
		if side > 0:
			x4 = y1 - y2 + x1
			y4 = x2 - x1 + y1
			direction = 'left'
		else:
			x4 = y2 - y1 + x1
			y4 = x1 - x2 + y1
			direction = 'right'

		facing_coords.x = x4
		facing_coords.y = y4

		facing_location.setMapCoordinates(facing_coords)
		self._instance.setFacingLocation(facing_location)
		self.act('fire_%s' % direction, facing_location, repeating=False)
		self._action = 'idle'


########NEW FILE########
__FILENAME__ = groundunit
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import weakref


from horizons.util.pathfinding.pather import SoldierPather
from horizons.util.pathfinding import PathBlockedError
from unit import Unit
from horizons.constants import GAME_SPEED, WEAPONS
from horizons.world.units.weaponholder import MovingWeaponHolder
from horizons.component.selectablecomponent import SelectableComponent


class GroundUnit(Unit):
	"""Class representing ground unit
	@param x: int x position
	@param y: int y position
	"""
	# TODO:
	# set these tabs in yaml as soon as there are ground units
	# tabs = (GroundUnitOverviewTab,)
	# enemy_tabs = (EnemyShipOverviewTab,)

	pather_class = SoldierPather
	health_bar_y = -70

	def __init__(self, x, y, **kwargs):
		super(GroundUnit, self).__init__(x=x, y=y, **kwargs)
		self.session.world.ground_units.append(self)
		self.session.world.ground_unit_map[self.position.to_tuple()] = weakref.ref(self)

	def remove(self):
		super(GroundUnit, self).remove()
		self.session.world.ground_units.remove(self)
		self.session.view.discard_change_listener(self.draw_health)
		del self.session.world.ground_unit_map[self.position.to_tuple()]

	def _move_tick(self, resume=False):
		del self.session.world.ground_unit_map[self.position.to_tuple()]

		try:
			super(GroundUnit, self)._move_tick(resume)
		except PathBlockedError:
			if resume:
				self.session.world.ground_unit_map[self.position.to_tuple()] = weakref.ref(self)
			raise

		self.session.world.ground_unit_map[self.position.to_tuple()] = weakref.ref(self)
		self.session.world.ground_unit_map[self._next_target.to_tuple()] = weakref.ref(self)

	def load(self, db, worldid):
		super(GroundUnit, self).load(db, worldid)

		# register unit in world
		self.session.world.ground_units.append(self)
		self.session.world.ground_unit_map[self.position.to_tuple()] = weakref.ref(self)


class FightingGroundUnit(MovingWeaponHolder, GroundUnit):
	"""Weapon Holder Ground Unit"""
	def __init__(self, x, y, **kwargs):
		super(FightingGroundUnit, self).__init__(x=x, y=y, **kwargs)
		#NOTE weapons
		self.add_weapon_to_storage(WEAPONS.SWORD)
		self.add_weapon_to_storage(WEAPONS.CANNON)
		names = self.session.db("SELECT name FROM groundunitnames")
		# We need unicode strings as the name is displayed on screen.
		self.name = map(lambda x: unicode(x[0], 'utf-8'), names)

	def go(self, x, y):
		self.get_component(SelectableComponent).go(x, y)
		self.stop_attack()

	def act_attack(self, dest):
		"""
		Rotates to target and acts correctly
		"""
		self.stop_for(GAME_SPEED.TICKS_PER_SECOND * 2)
		facing_location = self._instance.getFacingLocation()
		facing_coords = facing_location.getMapCoordinates()
		facing_coords.x = dest.x
		facing_coords.y = dest.y
		facing_location.setMapCoordinates(facing_coords)
		self._instance.setFacingLocation(facing_location)

		if dest.distance(self.position) <= 1:
			action = 'melee'
		else:
			action = 'ranged'

		self.act('attack_%s' % action, facing_location, repeating = False)
		self._action = 'idle'

########NEW FILE########
__FILENAME__ = movingobject
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
from fife import fife

from horizons.scheduler import Scheduler

from horizons.engine import Fife
from horizons.util.shapes import Point
from horizons.util.pathfinding import PathBlockedError
from horizons.util.python import decorators
from horizons.util.python.weakmethodlist import WeakMethodList
from horizons.world.concreteobject import ConcreteObject
from horizons.constants import GAME_SPEED
from horizons.component.componentholder import ComponentHolder
from horizons.world.units import UnitClass

class MoveNotPossible(Exception):
	"""Gets thrown when the unit should move some where, but there is no possible path"""
	pass

class MovingObject(ComponentHolder, ConcreteObject):
	"""This class provides moving functionality and is to be inherited by Unit.
	Its purpose is to provide a cleaner division of the code.

	It provides:
	*attributes:
	- position, last_position: Point
	- path: Pather

	*moving methods:
	- move
	- stop
	- add_move_callback

	*getters/checkers:
	- check_move
	- get_move_target
	- is_moving
	"""
	movable = True

	log = logging.getLogger("world.units")

	pather_class = None # overwrite this with a descendant of AbstractPather

	def __init__(self, x, y, **kwargs):
		super(MovingObject, self).__init__(x=x, y=y, **kwargs)
		self.__init(x, y)

	def __init(self, x, y):
		self.position = Point(x, y)
		self.last_position = Point(x, y)
		self._next_target = Point(x, y)

		self.move_callbacks = WeakMethodList()
		self.blocked_callbacks = WeakMethodList()
		self._conditional_callbacks = {}

		self.__is_moving = False

		self.path = self.pather_class(self, session=self.session)

		self._exact_model_coords1 = fife.ExactModelCoordinate() # save instance since construction is expensive (no other purpose)
		self._exact_model_coords2 = fife.ExactModelCoordinate() # save instance since construction is expensive (no other purpose)
		self._fife_location1 = None
		self._fife_location2 = None

	def check_move(self, destination):
		"""Tries to find a path to destination
		@param destination: destination supported by pathfinding
		@return: object that can be used in boolean expressions (the path in case there is one)
		"""
		return self.path.calc_path(destination, check_only=True)

	def is_moving(self):
		"""Returns whether unit is currently moving"""
		return self.__is_moving

	def stop(self, callback=None):
		"""Stops a unit with currently no possibility to continue the movement.
		The unit actually stops moving when current move (to the next coord) is finished.
		@param callback: a parameter supported by WeakMethodList. is executed immediately if unit isn't moving
		"""
		if not self.is_moving():
			WeakMethodList(callback).execute()
			return
		self.move_callbacks = WeakMethodList(callback)
		self.path.end_move()

	def _setup_move(self, action='move'):
		"""Executes necessary steps to begin a movement. Currently only the action is set."""
		# try a number of actions and use first existent one
		for action_iter in (action, 'move', self._action):
			if self.has_action(action_iter):
				self._move_action = action_iter
				return
		# this case shouldn't happen, but no other action might be available (e.g. ships)
		self._move_action = 'idle'

	def move(self, destination, callback=None, destination_in_building=False, action='move',
	         blocked_callback=None, path=None):
		"""Moves unit to destination
		@param destination: Point or Rect
		@param callback: a parameter supported by WeakMethodList. Gets called when unit arrives.
		@param action: action as string to use for movement
		@param blocked_callback: a parameter supported by WeakMethodList. Gets called when unit gets blocked.
		@param path: a precalculated path (return value of FindPath()())
		"""
		if not path:
			# calculate the path
			move_possible = self.path.calc_path(destination, destination_in_building)

			self.log.debug("%s: move to %s; possible: %s; is_moving: %s", self,
			               destination, move_possible, self.is_moving())

			if not move_possible:
				raise MoveNotPossible
		else:
			self.path.move_on_path(path, destination_in_building=destination_in_building)

		self.move_callbacks = WeakMethodList(callback)
		self.blocked_callbacks = WeakMethodList(blocked_callback)
		self._conditional_callbacks = {}
		self._setup_move(action)

		# start moving by regular ticking (only if next tick isn't scheduled)
		if not self.is_moving():
			self.__is_moving = True
			# start moving in 1 tick
			# this assures that a movement takes at least 1 tick, which is sometimes subtly
			# assumed e.g. in the collector code
			Scheduler().add_new_object(self._move_tick, self)

	def _movement_finished(self):
		self.log.debug("%s: movement finished. calling callbacks %s", self, self.move_callbacks)
		self._next_target = self.position
		self.__is_moving = False
		self.move_callbacks.execute()

	@decorators.make_constants()
	def _move_tick(self, resume=False):
		"""Called by the scheduler, moves the unit one step for this tick.
		"""
		assert self._next_target is not None

		if self._fife_location1 is None:
			# this data structure is needed multiple times, only create once
			self._fife_location1 = fife.Location(self._instance.getLocationRef().getLayer())
			self._fife_location2 = fife.Location(self._instance.getLocationRef().getLayer())

		if resume:
			self.__is_moving = True
		else:
			#self.log.debug("%s move tick from %s to %s", self, self.last_position, self._next_target)
			self.last_position = self.position
			self.position = self._next_target
			self._changed()

		# try to get next step, handle a blocked path
		while self._next_target == self.position:
			try:
				self._next_target = self.path.get_next_step()
			except PathBlockedError:
				# if we are trying to resume and it isn't possible then we need to raise it again
				if resume:
					raise

				self.log.debug("path is blocked")
				self.log.debug("owner: %s", self.owner)
				self.__is_moving = False
				self._next_target = self.position
				if self.blocked_callbacks:
					self.log.debug('PATH FOR UNIT %s is blocked. Calling blocked_callback', self)
					self.blocked_callbacks.execute()
				else:
					# generic solution: retry in 2 secs
					self.log.debug('PATH FOR UNIT %s is blocked. Retry in 2 secs', self)
					# technically, the ship doesn't move, but it is in the process of moving,
					# as it will continue soon in general. Needed in border cases for add_move_callback
					self.__is_moving = True
					Scheduler().add_new_object(self._move_tick, self,
					                           GAME_SPEED.TICKS_PER_SECOND * 2)
				self.log.debug("Unit %s: path is blocked, no way around", self)
				return

		if self._next_target is None:
			self._movement_finished()
			return
		else:
			self.__is_moving = True

		#setup movement
		move_time = self.get_unit_velocity()
		UnitClass.ensure_action_loaded(self._action_set_id, self._move_action) # lazy load move action

		self._exact_model_coords1.set(self.position.x, self.position.y, 0)
		self._fife_location1.setExactLayerCoordinates(self._exact_model_coords1)
		self._exact_model_coords2.set(self._next_target.x, self._next_target.y, 0)
		self._fife_location2.setExactLayerCoordinates(self._exact_model_coords2)
		self._route = fife.Route(self._fife_location1, self._fife_location2)
		# TODO/HACK the *5 provides slightly less flickery behavior of the moving
		# objects. This should be fixed properly by using the fife pathfinder for
		# the entire route and task
		location_list = fife.LocationList([self._fife_location2]*5)
		# It exists for FIFE 0.3.4 compat. See #1993.
		if Fife.getVersion() == (0,3,4):
			location_list.thisown = 0
			self._route.thisown = 0
		self._route.setPath(location_list)

		self.act(self._move_action)
		diagonal = self._next_target.x != self.position.x and self._next_target.y != self.position.y
		speed = float(self.session.timer.get_ticks(1)) / move_time[0]
		action = self._instance.getCurrentAction().getId()
		self._instance.follow(action, self._route, speed)

		#self.log.debug("%s registering move tick in %s ticks", self, move_time[int(diagonal)])
		Scheduler().add_new_object(self._move_tick, self, move_time[int(diagonal)])

		# check if a conditional callback becomes true
		for cond in self._conditional_callbacks.keys(): # iterate of copy of keys to be able to delete
			if cond():
				# start callback when this function is done
				Scheduler().add_new_object(self._conditional_callbacks[cond], self)
				del self._conditional_callbacks[cond]

	def teleport(self, destination, callback=None, destination_in_building=False):
		"""Like move, but nearly instantaneous"""
		if hasattr(destination, "position"):
			destination_coord = destination.position.center.to_tuple()
		else:
			destination_coord = destination
		self.move(destination, callback=callback, destination_in_building=destination_in_building, path=[destination_coord])

	def add_move_callback(self, callback):
		"""Registers callback to be executed when movement of unit finishes.
		This has no effect if the unit isn't moving."""
		if self.is_moving():
			self.move_callbacks.append(callback)

	def add_blocked_callback(self, blocked_callback):
		"""Registers callback to be executed when movement of the unit gets blocked."""
		self.blocked_callbacks.append(blocked_callback)

	def add_conditional_callback(self, condition, callback):
		"""Adds a callback, that gets called, if, at any time of the movement, the condition becomes
		True. The condition is checked every move_tick. After calling the callback, it is removed."""
		assert callable(condition)
		assert callable(callback)
		self._conditional_callbacks[condition] = callback

	def get_unit_velocity(self):
		"""Returns the number of ticks that it takes to do a straight (i.e. vertical or horizontal)
		or diagonal movement as a tuple in this order.
		@return: (int, int)
		"""
		tile = self.session.world.get_tile(self.position)
		if self.id in tile.velocity:
			return tile.velocity[self.id]
		else:
			return (12, 17) # standard values

	def get_move_target(self):
		return self.path.get_move_target()

	def save(self, db):
		super(MovingObject, self).save(db)
		# NOTE: _move_action is currently not yet saved and neither is blocked_callback.
		self.path.save(db, self.worldid)

	def load(self, db, worldid):
		super(MovingObject, self).load(db, worldid)
		x, y = db("SELECT x, y FROM unit WHERE rowid = ?", worldid)[0]
		self.__init(x, y)
		path_loaded = self.path.load(db, worldid)
		if path_loaded:
			self.__is_moving = True
			self._setup_move()
			Scheduler().add_new_object(self._move_tick, self, run_in=0)

decorators.bind_all(MovingObject)

########NEW FILE########
__FILENAME__ = pirateship
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.world.units.fightingship import FightingShip

class PirateShip(FightingShip):
	"""Represents a pirate ship."""
	pass
########NEW FILE########
__FILENAME__ = ship
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import weakref
from fife import fife

import horizons.globals

from horizons.util.pathfinding.pather import ShipPather, FisherShipPather
from horizons.util.pathfinding import PathBlockedError
from horizons.world.units.collectors import FisherShipCollector
from horizons.world.units.unit import Unit
from horizons.constants import LAYERS
from horizons.scheduler import Scheduler
from horizons.component.namedcomponent import ShipNameComponent, NamedComponent
from horizons.component.selectablecomponent import SelectableComponent
from horizons.component.commandablecomponent import CommandableComponent
from horizons.messaging import ShipDestroyed
from horizons.world.traderoute import TradeRoute

class Ship(Unit):
	"""Class representing a ship
	@param x: int x position
	@param y: int y position
	"""
	pather_class = ShipPather
	health_bar_y = -150
	is_ship = True

	in_ship_map = True # (#1023)

	def __init__(self, x, y, **kwargs):
		super(Ship, self).__init__(x=x, y=y, **kwargs)
		self.__init()

	def save(self, db):
		super(Ship, self).save(db)
		if hasattr(self, 'route'):
			self.route.save(db)

	def load(self, db, worldid):
		super(Ship, self).load(db, worldid)
		self.__init()

		# if ship did not have route configured, do not add attribute
		if TradeRoute.has_route(db, worldid):
			self.create_route()
			self.route.load(db)

	def __init(self):
		# register ship in world
		self.session.world.ships.append(self)
		if self.in_ship_map:
			self.session.world.ship_map[self.position.to_tuple()] = weakref.ref(self)

	def set_name(self, name):
		self.get_component(ShipNameComponent).set_name(name)

	def remove(self):
		self.session.world.ships.remove(self)
		self.session.view.discard_change_listener(self.draw_health)
		if self.in_ship_map:
			if self.position.to_tuple() in self.session.world.ship_map:
				del self.session.world.ship_map[self.position.to_tuple()]
			else:
				self.log.error("Ship %s had in_ship_map flag set as True "
				               "but tuple %s was not found in world.ship_map",
				               self, self.position.to_tuple())
			if self._next_target.to_tuple() in self.session.world.ship_map:
				del self.session.world.ship_map[self._next_target.to_tuple()]
			self.in_ship_map = False
		ShipDestroyed.broadcast(self)
		super(Ship, self).remove()

	def create_route(self):
		self.route = TradeRoute(self)

	def _move_tick(self, resume=False):
		"""Keeps track of the ship's position in the global ship_map"""

		# TODO: Originally, only self.in_ship_map should suffice here,
		# but KeyError is raised during combat.
		if self.in_ship_map and self.position.to_tuple() in self.session.world.ship_map:
			del self.session.world.ship_map[self.position.to_tuple()]
		elif self.in_ship_map:  # logging purposes only
			self.log.error("Ship %s had in_ship_map flag set as True but tuple %s was "
			               "not found in world.ship_map", self, self.position.to_tuple())

		try:
			super(Ship, self)._move_tick(resume)
		except PathBlockedError:
			# if we fail to resume movement then the ship should still be on the map
			# but the exception has to be raised again.
			if resume:
				if self.in_ship_map:
					self.session.world.ship_map[self.position.to_tuple()] = weakref.ref(self)
				raise

		if self.in_ship_map:
			# save current and next position for ship, since it will be between them
			self.session.world.ship_map[self.position.to_tuple()] = weakref.ref(self)
			self.session.world.ship_map[self._next_target.to_tuple()] = weakref.ref(self)

	def _movement_finished(self):
		if self.in_ship_map:
			# if the movement somehow stops, the position sticks, and the unit isn't at next_target any more
			if self._next_target is not None:
				ship = self.session.world.ship_map.get(self._next_target.to_tuple())
				if ship is not None and ship() is self:
					del self.session.world.ship_map[self._next_target.to_tuple()]
		super(Ship, self)._movement_finished()

	def go(self, x, y):
		# Disable trade route, direct commands overwrite automated ones.
		if hasattr(self, 'route'):
			self.route.disable()
		if self.get_component(CommandableComponent).go(x, y) is None:
			self._update_buoy()

	def move(self, *args, **kwargs):
		super(Ship, self).move(*args, **kwargs)
		if self.has_component(SelectableComponent) and \
		   self.get_component(SelectableComponent).selected and \
		   self.owner.is_local_player: # handle buoy
			# if move() is called as move_callback, tmp() from above might
			# be executed after this, so draw the new buoy after move_callbacks have finished.
			Scheduler().add_new_object(self._update_buoy, self, run_in=0)

	def _update_buoy(self, remove_only=False):
		"""Draw a buoy at the move target if the ship is moving."""
		if self.owner is None or not self.owner.is_local_player:
			return
		move_target = self.get_move_target()

		ship_id = self.worldid
		session = self.session # this has to happen here,
		# cause a reference to self in a temporary function is implemented
		# as a hard reference, which causes a memory leak
		def tmp():
			session.view.renderer['GenericRenderer'].removeAll("buoy_" + str(ship_id))
		tmp() # also remove now

		if remove_only:
			return

		if move_target is not None:
			# set remove buoy callback
			self.add_move_callback(tmp)

			loc = fife.Location(self.session.view.layers[LAYERS.OBJECTS])
			loc.thisown = 0  # thisown = 0 because the genericrenderernode might delete it
			coords = fife.ModelCoordinate(move_target.x, move_target.y)
			coords.thisown = 1 # thisown = 1 because setLayerCoordinates will create a copy
			loc.setLayerCoordinates(coords)
			self.session.view.renderer['GenericRenderer'].addAnimation(
				"buoy_" + str(self.worldid), fife.RendererNode(loc),
				horizons.globals.fife.animationloader.loadResource("as_buoy0+idle+45")
			)

	def find_nearby_ships(self, radius=15):
		# TODO: Replace 15 with a distance dependent on the ship type and any
		# other conditions.
		ships = self.session.world.get_ships(self.position, radius)
		if self in ships:
			ships.remove(self)
		return ships

	def get_tradeable_warehouses(self, position=None):
		"""Returns warehouses this ship can trade with w.r.t. position, which defaults to the ships ones."""
		if position is None:
			position = self.position
		return self.session.world.get_warehouses(position, self.radius, self.owner,
		                                         include_tradeable=True)

	def get_location_based_status(self, position):
		warehouses = self.get_tradeable_warehouses(position)
		if warehouses:
			warehouse = warehouses[0] # TODO: don't ignore the other possibilities
			player_suffix = u''
			if warehouse.owner is not self.owner:
				player_suffix = u' ({name})'.format(name=warehouse.owner.name)
			return u'{name}{suffix}'.format(name=warehouse.settlement.get_component(NamedComponent).name,
			                                suffix=player_suffix)
		return None

	def get_status(self):
		"""Return the current status of the ship."""
		if hasattr(self, 'route') and self.route.enabled:
			return self.route.get_ship_status()
		elif self.is_moving():
			target = self.get_move_target()
			location_based_status = self.get_location_based_status(target)
			if location_based_status is not None:
				return (_('Going to {location}').format(location=location_based_status), target)
			return (_('Going to {x}, {y}').format(x=target.x, y=target.y), target)
		else:
			location_based_status = self.get_location_based_status(self.position)
			if location_based_status is not None:
				return (_('Idle at {location}').format(location=location_based_status), self.position)
			return (_('Idle at {x}, {y}').format(x=self.position.x, y=self.position.y), self.position)


class TradeShip(Ship):
	"""Represents a trade ship."""
	health_bar_y = -220

	def __init__(self, x, y, **kwargs):
		super(TradeShip, self).__init__(x, y, **kwargs)

	def _possible_names(self):
		return [_('Trader')]


class FisherShip(FisherShipCollector, Ship):
	"""Represents a fisher ship."""
	pather_class = FisherShipPather
	health_bar_y = -50

	in_ship_map = False # (#1023)

	def _update_buoy(self):
		pass # no buoy for the fisher

########NEW FILE########
__FILENAME__ = unit
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import math
from fife import fife

from horizons.world.units.movingobject import MovingObject
from horizons.util.python import decorators
from horizons.util.python.callback import Callback
from horizons.util.python.weakmethod import WeakMethod
from horizons.util.shapes import Point
from horizons.util.worldobject import WorldObject
from horizons.constants import LAYERS
from horizons.component.healthcomponent import HealthComponent
from horizons.extscheduler import ExtScheduler
from horizons.world.resourcehandler import ResourceTransferHandler

class Unit(MovingObject, ResourceTransferHandler):
	log = logging.getLogger("world.units")
	is_unit = True
	is_ship = False
	health_bar_y = -30

	AUTOMATIC_HEALTH_DISPLAY_TIMEOUT = 10 # show health for 10 sec after damage has been taken

	def __init__(self, x, y, owner=None, **kwargs):
		super(Unit, self).__init__(x=x, y=y, **kwargs)
		self.__init(x, y, owner)

	def __init(self, x, y, owner):
		self.owner = owner
		class Tmp(fife.InstanceActionListener):
			pass
		self.InstanceActionListener = Tmp()
		self.InstanceActionListener.onInstanceActionFinished = \
				WeakMethod(self.onInstanceActionFinished)
		self.InstanceActionListener.onInstanceActionCancelled = \
				WeakMethod(self.onInstanceActionCancelled)
		self.InstanceActionListener.onInstanceActionFrame = lambda *args : None
		self.InstanceActionListener.thisown = 0 # fife will claim ownership of this

		self._instance = self.session.view.layers[LAYERS.OBJECTS].createInstance(
			self.__class__._fife_object, fife.ModelCoordinate(int(x), int(y), 0), str(self.worldid))
		fife.InstanceVisual.create(self._instance)
		location = fife.Location(self._instance.getLocation().getLayer())
		location.setExactLayerCoordinates(fife.ExactModelCoordinate(x + x, y + y, 0))
		self.act(self._action, location, True)
		self._instance.addActionListener(self.InstanceActionListener)

		self.loading_area = self.position

		self._health_displayed = False

		if self.has_component(HealthComponent):
			self.get_component(HealthComponent).add_damage_dealt_listener(self._on_damage)

	def remove(self):
		self.log.debug("Unit.remove for %s started", self)
		if hasattr(self.owner, 'remove_unit'):
			self.owner.remove_unit(self)
		self._instance.removeActionListener(self.InstanceActionListener)
		ExtScheduler().rem_all_classinst_calls(self)
		super(Unit, self).remove()
		self.log.debug("Unit.remove finished")

	def onInstanceActionFinished(self, instance, action):
		"""
		@param instance: fife.Instance
		@param action: string representing the action that is finished.
		"""
		location = fife.Location(self._instance.getLocation().getLayer())
		location.setExactLayerCoordinates(fife.ExactModelCoordinate(
			self.position.x + self.position.x - self.last_position.x,
			self.position.y + self.position.y - self.last_position.y, 0))

		facing_loc = self._instance.getFacingLocation()
		if action.getId().startswith('move_'):
			# Remember: this means we *ended* a "move" action just now!
			facing_loc = location

		self.act(self._action, facing_loc=facing_loc, repeating=True)

	def onInstanceActionCancelled(self, instance, action):
		pass

	def _on_damage(self, caller=None):
		"""Called when health has changed"""
		if not self._instance: # dead
			# it is sometimes hard to avoid this being called after the unit has died,
			# e.g. when it's part of a list of changelisteners, and one of the listeners executed before kills the unit
			return
		health_was_displayed_before = self._health_displayed
		# always update
		self.draw_health()
		if health_was_displayed_before:
			return # don't schedule removal
		# remember that it has been drawn automatically
		self._last_draw_health_call_on_damage = True
		# remove later (but only in case there's no manual interference)
		ExtScheduler().add_new_object(Callback(self.draw_health, auto_remove=True),
		                              self, self.__class__.AUTOMATIC_HEALTH_DISPLAY_TIMEOUT)

	def draw_health(self, remove_only=False, auto_remove=False):
		"""Draws the units current health as a healthbar over the unit."""
		if not self.has_component(HealthComponent):
			return
		render_name = "health_" + str(self.worldid)
		renderer = self.session.view.renderer['GenericRenderer']
		renderer.removeAll(render_name)
		if remove_only or (auto_remove and not self._last_draw_health_call_on_damage):
			# only remove on auto_remove if this health was actually displayed as reacton to _on_damage
			# else we might remove something that the user still wants
			self._health_displayed = False
			return
		self._last_draw_health_call_on_damage = False
		self._health_displayed = True
		health_component = self.get_component(HealthComponent)
		health = health_component.health
		max_health = health_component.max_health
		zoom = self.session.view.zoom
		height = int(5 * zoom)
		width = int(50 * zoom)
		y_pos = int(self.health_bar_y * zoom)
		relative_x = int((width * health) // max_health - (width // 2))
		# mid_node is the coord separating healthy (green) and damaged (red) quads
		mid_node_top = fife.RendererNode(self._instance, fife.Point(relative_x, y_pos - height))
		mid_node_btm = fife.RendererNode(self._instance, fife.Point(relative_x, y_pos))

		left_upper = fife.RendererNode(self._instance, fife.Point(-width // 2, y_pos - height))
		right_upper = fife.RendererNode(self._instance, fife.Point(width // 2, y_pos - height))
		left_lower = fife.RendererNode(self._instance, fife.Point(-width // 2, y_pos))
		right_lower = fife.RendererNode(self._instance, fife.Point(width // 2, y_pos))

		if health > 0: # draw healthy part of health bar
			renderer.addQuad(render_name,
			                 left_upper,
			                 left_lower,
			                 mid_node_btm,
			                 mid_node_top,
			                 0, 255, 0)
		if health < max_health: # draw damaged part
			renderer.addQuad(render_name,
			                 mid_node_top,
			                 mid_node_btm,
			                 right_lower,
			                 right_upper,
			                 255, 0, 0)

	def hide(self):
		"""Hides the unit."""
		vis = self._instance.get2dGfxVisual()
		vis.setVisible(False)

	def show(self):
		vis = self._instance.get2dGfxVisual()
		vis.setVisible(True)

	def save(self, db):
		super(Unit, self).save(db)

		owner_id = 0 if self.owner is None else self.owner.worldid
		db("INSERT INTO unit (rowid, type, x, y, owner) VALUES(?, ?, ?, ?, ?)",
			self.worldid, self.__class__.id, self.position.x, self.position.y, owner_id)

	def load(self, db, worldid):
		super(Unit, self).load(db, worldid)

		x, y, owner_id = db("SELECT x, y, owner FROM unit WHERE rowid = ?", worldid)[0]
		if owner_id == 0:
			owner = None
		else:
			owner = WorldObject.get_object_by_id(owner_id)
		self.__init(x, y, owner)

		return self

	def get_random_location(self, in_range):
		"""Returns a random location in walking_range, that we can find a path to
		Does not check every point, only a few samples are tried.
		@param in_range: int, max distance to returned point from current position
		@return: tuple(Instance of Point or None, path or None)"""
		range_squared = in_range * in_range
		randint = self.session.random.randint
		# pick a sample, try tries times
		tries = range_squared // 2
		for i in xrange(tries):
			# choose x-difference, then y-difference so that the distance is in the range.
			x_diff = randint(1, in_range) # always go at least 1 field
			y_max_diff = int( math.sqrt(range_squared - x_diff*x_diff) )
			y_diff = randint(0, y_max_diff)
			# use randomness of x/y_diff below, randint calls are expensive
			# this results in a higher chance for x > y than y < x, so equalize
			if (x_diff + y_diff) % 2 == 0:
				x_diff, y_diff = y_diff, x_diff
			# direction
			if x_diff % 2 == 0:
				y_diff = -y_diff
			if y_diff % 2 == 0:
				x_diff = -x_diff
			# check this target
			possible_target = Point(self.position.x + x_diff, self.position.y + y_diff)
			path = self.check_move(possible_target)
			if path:
				return (possible_target, path)
		return (None, None)

	@property
	def classname(self):
		return self.session.db.get_unit_type_name(self.id)

	def __str__(self): # debug
		return '%s(id=%s;worldid=%s)' % (self.name, self.id, self.worldid if hasattr(self, 'worldid') else 'none')


decorators.bind_all(Unit)

########NEW FILE########
__FILENAME__ = weapon
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging

from horizons.util.python.callback import Callback
from horizons.util.shapes import Point
from horizons.scheduler import Scheduler
from horizons.constants import GAME_SPEED
from horizons.util.changelistener import metaChangeListenerDecorator
from horizons.component.healthcomponent import HealthComponent


@metaChangeListenerDecorator("attack_ready")
@metaChangeListenerDecorator("weapon_fired")
class Weapon(object):
	"""
	Generic Weapon class
	it has the modifiers:
		damage - damage dealt in hp
		weapon_range - tuple with minimum and maximum attack range
		cooldown_time - number of seconds until the attack is ready again
		attack_speed - speed that calculates the time until attack reaches target
		attack_radius - radius affected by attack

		attack_ready callbacks are executed when the attack is made ready
	"""
	log = logging.getLogger("world.combat")

	def __init__(self, session, id):
		"""
		@param session: game session
		@param id: weapon id to be initialized
		"""
		data = session.db("SELECT id, type, damage,\
		                          min_range, max_range,\
		                          cooldown_time, attack_speed,\
		                          attack_radius \
		                  FROM weapon WHERE id = ?", id)
		data = data[0]
		self.weapon_id = data[0]
		self.weapon_type = data[1]
		self.damage = data[2]
		self.weapon_range = data[3], data[4]
		self.cooldown_time = data[5]
		self.attack_speed = data[6]
		self.attack_radius = data[7]
		self.attack_ready = True
		self.session = session

	def get_damage_modifier(self):
		return self.damage

	def get_minimum_range(self):
		return self.weapon_range[0]

	def get_maximum_range(self):
		return self.weapon_range[1]

	@classmethod
	def on_impact(cls, session, weapon_id, damage, position):
		"""
		Classmethod that deals damage to units at position, depending on weapon_id
		Damage is done independent of the weapon instance, which may not exist at the time damage is done
		@param session : UH session
		@param weapon_id : id of the weapon
		@param damage : damage to be done
		@param position : Point with position where damage needs to be done
		"""
		cls.log.debug("%s impact", cls)
		# deal damage to units in position callback
		attack_radius = session.db.get_weapon_attack_radius(weapon_id)

		units = session.world.get_health_instances(position, attack_radius)

		for unit in units:
			cls.log.debug("dealing damage to %s", unit)
			unit.get_component(HealthComponent).deal_damage(weapon_id, damage)

	def make_attack_ready(self):
		self.attack_ready = True
		self.on_attack_ready()

	def fire(self, destination, position):
		"""
		Fires the weapon at a certain destination
		@param destination: Point with position where weapon will be fired
		@param position: position where the weapon is fired from
		"""
		self.log.debug("%s fire; ready: %s", self, self.attack_ready)
		if not self.attack_ready:
			return

		distance = round(position.distance(destination.center))
		if not self.check_target_in_range(distance):
			self.log.debug("%s target not in range", self)
			return

		# Calculate the ticks until impact.
		impact_ticks = int(GAME_SPEED.TICKS_PER_SECOND * distance / self.attack_speed)
		# Deal damage when attack reaches target.
		Scheduler().add_new_object(Callback(Weapon.on_impact,
			self.session, self.weapon_id, self.get_damage_modifier(), destination),
			Weapon, impact_ticks)

		# Calculate the ticks until attack is ready again.
		ready_ticks = int(GAME_SPEED.TICKS_PER_SECOND * self.cooldown_time)
		Scheduler().add_new_object(self.make_attack_ready, self, ready_ticks)

		self.log.debug("fired %s at %s, impact in %s", self, destination, impact_ticks)

		self.attack_ready = False
		self.on_weapon_fired()

	def check_target_in_range(self, distance):
		"""
		Checks if the distance between the weapon and target is in weapon range
		@param distance : distance between weapon and target
		"""
		return self.weapon_range[0] <= distance <= self.weapon_range[1]

	def get_ticks_until_ready(self):
		"""
		Returns the number of ticks until the attack is ready
		If attack is ready return 0
		"""
		return 0 if self.attack_ready else Scheduler().get_remaining_ticks(self, self.make_attack_ready)

	@classmethod
	def load_attacks(cls, session, db):
		"""
		Loads ongoing attacks from savegame database
		Creates scheduled calls for on_impact
		"""
		attacks = db("SELECT remaining_ticks, weapon_id, damage, dest_x, dest_y FROM attacks")
		for (ticks, weapon_id, damage, dx, dy) in attacks:
			Scheduler().add_new_object(Callback(Weapon.on_impact,
				session, weapon_id, damage, Point(dx, dy)), Weapon, ticks)

	@classmethod
	def save_attacks(cls, db):
		"""
		Saves ongoing attacks
		"""
		calls = Scheduler().get_classinst_calls(Weapon)
		for call in calls:
			callback = call.callback
			weapon_id = callback.args[1]
			damage = callback.args[2]
			dest_x = callback.args[3].x
			dest_y = callback.args[3].y
			ticks = calls[call]
			db("INSERT INTO attacks(remaining_ticks, weapon_id, damage, dest_x, dest_y) VALUES (?, ?, ?, ?, ?)",
				ticks, weapon_id, damage, dest_x, dest_y)

	def __str__(self):
		return "Weapon(id:%s;type:%s;rang:%s)" % (self.weapon_id, self.weapon_type, self.weapon_range)


class SetStackableWeaponNumberError(Exception):
	"""
	Raised when setting the number of weapons for a stackable weapon fails
	"""
	pass


class StackableWeapon(Weapon):
	"""
	Stackable Weapon class
	A generic Weapon that can have a number of weapons binded per instance
	It deals the number of weapons times weapon's default damage
	This is used for cannons, reducing the number of instances and bullets fired
	"""
	def __init__(self, session, id):
		super(StackableWeapon, self).__init__(session, id)
		self.__init()

	def __init(self):
		self.number_of_weapons = 1
		self.max_number_of_weapons = 1

	def set_number_of_weapons(self, number):
		"""
		Sets number of cannons as resource binded to a StackableWeapon object
		the number of cannons increases the damage dealt by one StackableWeapon instance
		@param number : number of cannons
		"""
		if number > self.max_number_of_weapons:
			raise SetStackableWeaponNumberError
		else:
			self.number_of_weapons = number

	def increase_number_of_weapons(self, number):
		"""
		Increases number of cannons as resource binded to a StackableWeapon object
		@param number : number of cannons
		"""
		if number + self.number_of_weapons > self.max_number_of_weapons:
			raise SetStackableWeaponNumberError
		else:
			self.number_of_weapons += number

	def decrease_number_of_weapons(self, number):
		"""
		Decreases number of cannons as resource binded to a StackableWeapon object
		@param number : number of cannons
		"""
		if self.number_of_weapons - number <= 0:
			raise SetStackableWeaponNumberError
		else:
			self.number_of_weapons -= number

	def get_damage_modifier(self):
		return self.number_of_weapons * super(StackableWeapon, self).get_damage_modifier()

########NEW FILE########
__FILENAME__ = weaponholder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import logging
import math

from horizons.util.changelistener import metaChangeListenerDecorator
from horizons.util.python.callback import Callback
from horizons.util.shapes import Annulus, Point
from horizons.util.worldobject import WorldObject
from horizons.world.units.movingobject import MoveNotPossible
from horizons.scheduler import Scheduler
from horizons.constants import GAME_SPEED
from horizons.component.stancecomponent import HoldGroundStance, AggressiveStance, \
	NoneStance, FleeStance
from horizons.world.storage import PositiveTotalNumSlotsStorage
from horizons.world.units.ship import Ship
from horizons.world.units.weapon import Weapon, StackableWeapon, SetStackableWeaponNumberError
from horizons.component.storagecomponent import StorageComponent

@metaChangeListenerDecorator("storage_modified")
@metaChangeListenerDecorator("user_attack_issued")
class WeaponHolder(object):
	log = logging.getLogger("world.combat")

	def __init__(self, **kwargs):
		super(WeaponHolder, self).__init__(**kwargs)
		self.__init()

	def __init(self):
		self.create_weapon_storage()
		self._target = None
		self.add_storage_modified_listener(self.update_range)
		self.equipped_weapon_number = 0
		Scheduler().add_new_object(self._stance_tick, self, run_in=2, loops=-1,
		                           loop_interval=GAME_SPEED.TICKS_PER_SECOND)

	def remove(self):
		self.remove_storage_modified_listener(self.update_range)
		self.stop_attack()
		for weapon in self._weapon_storage:
			weapon.remove_attack_ready_listener(Callback(self._add_to_fireable, weapon))
			weapon.remove_weapon_fired_listener(Callback(self._remove_from_fireable, weapon))
			weapon.remove_weapon_fired_listener(self._increase_fired_weapons_number)
		super(WeaponHolder, self).remove()

	def create_weapon_storage(self):
		self._weapon_storage = []
		self._fireable = []
		#TODO make a system for making it load from db
		self.total_number_of_weapons = 30

	def update_range(self, caller=None):
		if self._weapon_storage:
			self._min_range = min([w.get_minimum_range() for w in self._weapon_storage])
			self._max_range = max([w.get_maximum_range() for w in self._weapon_storage])
		else:
			self._min_range = 0
			self._max_range = 0

	def _add_to_fireable(self, weapon):
		"""
		Callback executed when weapon attack is ready
		"""
		self._fireable.append(weapon)

	def _remove_from_fireable(self, weapon):
		"""
		Callback executed when weapon is fired
		"""
		# remove in the next tick
		Scheduler().add_new_object(Callback(self._fireable.remove, weapon), self, run_in=0)

	def _increase_fired_weapons_number(self, caller=None):
		"""
		Callback that helps keeping tack of successful weapon fire number
		"""
		self._fired_weapons_number += 1

	def add_weapon_to_storage(self, weapon_id):
		"""
		adds weapon to storage
		@param weapon_id : id of the weapon to be added
		"""
		self.log.debug("%s add weapon %s", self, weapon_id)
		# If weapon is stackable, try to stack.
		weapon = None
		if self.equipped_weapon_number == self.total_number_of_weapons:
			self.log.debug("%s weapon storage full", self)
			return False
		if self.session.db.get_weapon_stackable(weapon_id):
			stackable = [w for w in self._weapon_storage if weapon_id == w.weapon_id]
			# Try to increase the number of weapons for one stackable weapon.
			increased = False
			for weapon in stackable:
				try:
					weapon.increase_number_of_weapons(1)
					increased = True
					break
				except SetStackableWeaponNumberError:
					continue

			if not increased:
				weapon = StackableWeapon(self.session, weapon_id)
		else:
			weapon = Weapon(self.session, weapon_id)
		if weapon:
			self._weapon_storage.append(weapon)
			weapon.add_weapon_fired_listener(Callback(self._remove_from_fireable, weapon))
			weapon.add_attack_ready_listener(Callback(self._add_to_fireable, weapon))
			weapon.add_weapon_fired_listener(self._increase_fired_weapons_number)
			self._fireable.append(weapon)
			self.equipped_weapon_number += 1
		self.on_storage_modified()  # This will update the range.
		return True

	def remove_weapon_from_storage(self, weapon_id):
		"""
		removes weapon to storage
		@param weapon_id : id of the weapon to be removed
		"""
		self.log.debug("%s remove weapon %s", self, weapon_id)
		weapons = [w for w in self._weapon_storage if w.weapon_id == weapon_id]
		if not weapons:
			self.log.debug("%s can't remove, no weapons there", self)
			return False
		# Remove the weapon last added.
		weapon = weapons[-1]
		#
		remove_from_storage = False
		# If the weapon to be removed was stackable, try to decrease number.
		if self.session.db.get_weapon_stackable(weapon_id):
			try:
				weapon.decrease_number_of_weapons(1)
			except SetStackableWeaponNumberError:
				remove_from_storage = True
		else:
			remove_from_storage = True

		if remove_from_storage:
			self._weapon_storage.remove(weapon)
			weapon.remove_weapon_fired_listener(Callback(self._remove_from_fireable, weapon))
			weapon.remove_attack_ready_listener(Callback(self._add_to_fireable, weapon))
			weapon.remove_weapon_fired_listener(self._increase_fired_weapons_number)
			try:
				self._fireable.remove(weapon)
			except ValueError:
				pass

		self.on_storage_modified()
		self.equipped_weapon_number -= 1
		return True

	def equip_from_inventory(self, weapon_id, number):
		"""Equips weapon if present in inventory
		@param weapon_id: weapon id to be equipped
		@param number: number of weapons to be equipped
		@return: number of weapons that were not equipped
		"""
		while number:
			if self.get_component(StorageComponent).inventory.alter(weapon_id, -1) == 0:
				# try to decrease number from inventory
				if not self.add_weapon_to_storage(weapon_id):
					# if not added, put back in inventory and break
					self.get_component(StorageComponent).inventory.alter(weapon_id, 1)
					break
			else:
				break
			number -= 1
		return number

	def unequip_to_inventory(self, weapon_id, number):
		"""Unequips weapon and adds it to inventory
		@param weapon_id: weapon id to be unequipped
		@param number: number of weapons to be unequipped
		@return: number of weapons that were not added to storage
		"""
		while number:
			if self.remove_weapon_from_storage(weapon_id):
				# try to remove from weapon storage
				if self.get_component(StorageComponent).inventory.alter(weapon_id, 1) == 1:
					# if not added to holder inventory move back to storage and break
					self.add_weapon_to_storage(weapon_id)
					break
			else:
				break
			number -= 1
		return number

	def get_weapon_storage(self):
		"""
		Returns storage object for self._weapon_storage
		"""
		storage = PositiveTotalNumSlotsStorage(self.total_number_of_weapons, 4)
		for weapon in self._weapon_storage:
			weapon_id = weapon.weapon_id
			if self.session.db.get_weapon_stackable(weapon_id):
				number = weapon.number_of_weapons
			else:
				number = 1
			storage.alter(weapon_id, number)
		return storage

	def attack_in_range(self):
		"""
		Returns True if the target is in range, False otherwise
		"""
		if not self._target:
			return False
		distance = self.position.distance(self._target.position.center)
		return self._min_range <= distance <= self._max_range

	def can_attack_position(self, position):
		"""
		Returns True if the holder can attack position at call time
		@param position: position of desired attack
		"""
		# if no fireable weapon return False
		if not self._fireable:
			return False
		# if position not in range return False
		return self._min_range <= self.position.distance(position.center) <= self._max_range

	def try_attack_target(self):
		"""
		Attacking loop
		"""
		self.log.debug("%s try attack target %s", self, self._target)
		if self._target is None:
			return

		if self.attack_in_range():
			dest = self._target.position.center
			if self._target.movable and self._target.is_moving():
				dest = self._target._next_target

			self.fire_all_weapons(dest)
			Scheduler().add_new_object(self.try_attack_target, self, GAME_SPEED.TICKS_PER_SECOND)
			self.log.debug("%s fired, fire again in %s ticks", self, GAME_SPEED.TICKS_PER_SECOND)
		else:
			self.log.debug("%s target not in range", self)

	def _stance_tick(self):
		"""
		Executes every few seconds, doing movement depending on the stance.
		Static WeaponHolders are aggressive, attacking all enemies that are in range
		"""
		enemies = [u for u in self.session.world.get_health_instances(self.position.center, self._max_range)
			if self.session.world.diplomacy.are_enemies(u.owner, self.owner)]

		self.log.debug("%s stance tick, found enemies: %s", self, [str(i) for i in enemies])
		if not enemies:
			return

		self.attack(enemies[0])

	def attack(self, target):
		"""
		Triggers attack on target
		@param target: target to be attacked
		"""
		self.log.debug("%s attack %s", self, target)
		if self._target is not None:
			if self._target is not target:
				#if target is changed remove the listener
				if self._target.has_remove_listener(self.remove_target):
					self._target.remove_remove_listener(self.remove_target)
			else:
				#else do not update the target
				self.log.debug("%s already targeting this one", self)
				return
		if not target.has_remove_listener(self.remove_target):
			target.add_remove_listener(self.remove_target)
		self._target = target

		self.try_attack_target()

	def user_attack(self, targetid):
		"""
		Called when the user triggeres the attack, executes the user_attack_issued callbacks
		@param targetid: world id of the unit that is to be attacked
		"""
		self.attack(WorldObject.get_object_by_id(targetid))
		self.on_user_attack_issued()

	def is_attacking(self):
		"""
		Returns True if the WeaponHolder is trying to attack a target
		"""
		return True if self._target else False

	def remove_target(self):
		"""
		Removes reference from target,
		this happens when the attack is stopped or the target is dead
		either way the refs are checked using gc module
		this is used because after unit death it's possbile that it still has refs
		"""
		self._target = None

	def stop_attack(self):
		# When the ship is told to move, the target is None and the listeners in target removed
		#TODO make another listener for target_changed
		self.log.debug("%s stop attack", self)
		if self._target is not None:
			self._target.discard_remove_listener(self.remove_target)
		self.remove_target()

	def fire_all_weapons(self, dest, rotated=False):
		"""
		Fires all weapons in storage at a given position
		@param dest: Point with the given position
		@param rotated: If True weapons will be fired at different locations, rotated around dest
			override to True for units that need to fire at rotated coords
		"""
		self.log.debug("%s fire all weapons", self)
		self._fired_weapons_number = 0
		if not self.can_attack_position(dest):
			self.log.debug("%s can't attack this position", self)
			return

		if not rotated:
			for weapon in self._fireable:
				weapon.fire(dest, self.position.center)
		else:
			angle = (math.pi / 60) * (-len(self._fireable) / 2)
			cos = math.cos(angle)
			sin = math.sin(angle)

			x = self.position.center.x
			y = self.position.center.y

			dest_x = dest.x
			dest_y = dest.y

			dest_x = (dest_x - x) * cos - (dest_y - y) * sin + x
			dest_y = (dest_x - x) * sin + (dest_y - y) * cos + y

			angle = math.pi / 60
			cos = math.cos(angle)
			sin = math.sin(angle)

			for weapon in self._fireable:
				destination = Point(dest_x, dest_y)
				weapon.fire(destination, self.position.center)
				dest_x = (dest_x - x) * cos - (dest_y - y) * sin + x
				dest_y = (dest_x - x) * sin + (dest_y - y) * cos + y

		if self._fired_weapons_number != 0:
			self.act_attack(dest)

	def act_attack(self, dest):
		"""
		Override in subclasses for action code
		"""
		pass

	def get_attack_target(self):
		return self._target

	def save(self, db):
		super(WeaponHolder, self).save(db)
		# save weapon storage
		for weapon in self._weapon_storage:
			number = 1
			ticks = weapon.get_ticks_until_ready()
			if self.session.db.get_weapon_stackable(weapon.weapon_id):
				number = weapon.number_of_weapons

			db("INSERT INTO weapon_storage(owner_id, weapon_id, number, remaining_ticks) VALUES(?, ?, ?, ?)",
				self.worldid, weapon.weapon_id, number, ticks)
		# save target
		if self._target:
			db("INSERT INTO target(worldid, target_id) VALUES(?, ?)", self.worldid, self._target.worldid)

	def load_target(self, db):
		"""
		Loads target from database
		"""
		target_id = db("SELECT target_id from target WHERE worldid = ?", self.worldid)
		if target_id:
			target = self.session.world.get_object_by_id(target_id[0][0])
			self.attack(target)

	def load(self, db, worldid):
		super(WeaponHolder, self).load(db, worldid)
		self.__init()
		weapons = db("SELECT weapon_id, number, remaining_ticks FROM weapon_storage WHERE owner_id = ?", worldid)
		for weapon_id, number, ticks in weapons:
			# create weapon and add to storage manually
			if self.session.db.get_weapon_stackable(weapon_id):
				weapon = StackableWeapon(self.session, weapon_id)
				weapon.set_number_of_weapons(number)
			else:
				weapon = Weapon(self.session, weapon_id)
			self._weapon_storage.append(weapon)
			# if weapon not ready add scheduled call and remove from fireable
			if ticks:
				weapon.attack_ready = False
				Scheduler().add_new_object(weapon.make_attack_ready, weapon, ticks)
			else:
				self._fireable.append(weapon)
			weapon.add_weapon_fired_listener(Callback(self._remove_from_fireable, weapon))
			weapon.add_attack_ready_listener(Callback(self._add_to_fireable, weapon))
			weapon.add_weapon_fired_listener(self._increase_fired_weapons_number)
		self.on_storage_modified()
		# load target after all objects have been loaded
		Scheduler().add_new_object(Callback(self.load_target, db), self, run_in=0)
		self.log.debug("%s weapon storage after load: %s", self, self._weapon_storage)

	def get_status(self):
		"""Return the current status of the ship."""
		if self.is_attacking():
			target = self.get_attack_target()
			if isinstance(target, Ship):
				string = _("Attacking {target} '{name}' ({owner})")
				return (string.format(target=target.classname.lower(), name=target.name,
				                      owner=target.owner.name),
				        target.position)
			return (_('Attacking {owner}').format(owner=target.owner.name),
			        target.position)
		return super(WeaponHolder, self).get_status()


@metaChangeListenerDecorator("user_move_issued")
class MovingWeaponHolder(WeaponHolder):
	def __init__(self, **kwargs):
		super(MovingWeaponHolder, self).__init__(**kwargs)
		self.__init()

	def __init(self):
		self.add_component(HoldGroundStance())
		self.add_component(AggressiveStance())
		self.add_component(NoneStance())
		self.add_component(FleeStance())
		self.stance = HoldGroundStance

	def _stance_tick(self):
		"""
		Executes every few seconds, doing movement depending on the stance.
		"""
		self.get_component(self.stance).act()

	def stop_for(self, ticks):
		"""
		Delays movement for a number of ticks.
		Used when shooting in specialized unit code.
		"""
		if Scheduler().rem_call(self, self._move_tick):
			Scheduler().add_new_object(Callback(self._move_tick, resume=False), self, ticks)

	def _move_and_attack(self, destination, not_possible_action=None, in_range_callback=None):
		"""
		Callback for moving to a destination, then attack
		@param destination : moving destination
		@param not_possible_action : execute if MoveNotPossible is thrown
		@param in_range_callback : sets up a conditional callback that is executed if the target is in range
		"""
		if not_possible_action:
			assert callable(not_possible_action)
		if in_range_callback:
			assert callable(in_range_callback)

		try:
			self.move(destination, callback = self.try_attack_target,
				blocked_callback = self.try_attack_target)
			if in_range_callback:
				self.add_conditional_callback(self.attack_in_range, in_range_callback)

		except MoveNotPossible:
			if not_possible_action:
				not_possible_action()

	def try_attack_target(self):
		"""
		Attacking loop
		"""
		if self._target is None:
			return

		if not self.attack_in_range():
			destination = Annulus(self._target.position.center, self._min_range, self._max_range)
			not_possible_action = self.stop_attack
			# if target passes near self, attack!
			in_range_callback = self.try_attack_target
			# if executes attack action try to move in 1 second
			self._move_and_attack(destination, not_possible_action, in_range_callback)
		else:
			if self.is_moving() and self._fireable:
				# stop to shoot
				self.stop()
				# finish the move before removing the move tick
				self._movement_finished()
				# do not execute the next move tick
				Scheduler().rem_call(self, self._move_tick)

			distance = self.position.distance(self._target.position.center)
			dest = self._target.position.center
			if self._target.movable and self._target.is_moving():
				dest = self._target._next_target

			fireable_number = len(self._fireable)
			self.fire_all_weapons(dest)
			move_closer = False
			# if no weapon was fired, because of holder positioned in dead range, move closer
			if self._fired_weapons_number == 0 and fireable_number != 0:
				# no weapon was fired but i could have fired weapons
				# check if i have weapons that could be shot from this position
				move_closer = True
				distance = self.position.center.distance(self._target.position.center)
				for weapon in self._weapon_storage:
					if weapon.check_target_in_range(distance):
						move_closer = False
						break

			if move_closer:
				destination = Annulus(self._target.position.center, self._min_range, self._min_range)
				self._move_and_attack(destination)
			else:
				Scheduler().add_new_object(self.try_attack_target, self, GAME_SPEED.TICKS_PER_SECOND)

	def set_stance(self, stance):
		"""
		Sets the stance to a specific one and passes the current state
		"""
		state = self.get_component(self.stance).get_state()
		self.stance = stance
		self.get_component(stance).set_state(state)

	def go(self, x, y):
		super(MovingWeaponHolder, self).go(x, y)
		self.on_user_move_issued()

	def save(self, db):
		super(MovingWeaponHolder, self).save(db)
		db("INSERT INTO stance(worldid, stance, state) VALUES(?, ?, ?)",
			self.worldid, self.stance.NAME, self.get_component(self.stance).get_state())

	def load(self, db, worldid):
		super(MovingWeaponHolder, self).load(db, worldid)
		self.__init()
		stance, state = db("SELECT stance, state FROM stance WHERE worldid = ?", worldid)[0]
		self.stance = self.get_component_by_name(stance)
		self.stance.set_state(state)

	def user_attack(self, targetid):
		super(MovingWeaponHolder, self).user_attack(targetid)
		if self.owner.is_local_player:
			self.session.ingame_gui.minimap.show_unit_path(self)


class StationaryWeaponHolder(WeaponHolder):
	"""Towers and stuff"""
	# TODO: stances (shoot on sight, don't do anything)

	def __init__(self, *args, **kwargs):
		super(StationaryWeaponHolder, self).__init__(*args, **kwargs)
		self.__init()

	def __init(self):
		self.add_component(HoldGroundStance())
		self.stance = HoldGroundStance

	def load(self, db, worldid):
		super(StationaryWeaponHolder, self).load(db, worldid)
		self.__init()

########NEW FILE########
__FILENAME__ = worldutils
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import bisect
import itertools
import os

from collections import deque

from horizons.command.building import Build
from horizons.command.unit import CreateUnit
from horizons.component.selectablecomponent import SelectableComponent
from horizons.component.storagecomponent import StorageComponent
from horizons.constants import BUILDINGS, RES, UNITS, WILD_ANIMAL
from horizons.entities import Entities
from horizons.util.dbreader import DbReader
from horizons.util.shapes import Point
from horizons.util.uhdbaccessor import read_savegame_template

"""
This is used for random features required by world,
that aren't delicate but need to occupy space somewhere.
"""


def toggle_health_for_all_health_instances(world):
	"""Show health bar of every instance with an health component, which isnt selected already"""
	world.health_visible_for_all_health_instances = not world.health_visible_for_all_health_instances
	if world.health_visible_for_all_health_instances:
		for instance in world.get_health_instances():
			if not instance.get_component(SelectableComponent).selected:
				instance.draw_health()
				world.session.view.add_change_listener(instance.draw_health)
	else:
		for instance in world.get_health_instances():
			if not world.session.view.has_change_listener(instance.draw_health):
				continue
			if not instance.get_component(SelectableComponent).selected:
				instance.draw_health(remove_only=True)
				world.session.view.remove_change_listener(instance.draw_health)

def toggle_translucency(world):
	"""Make certain building types translucent"""
	if not hasattr(world, "_translucent_buildings"):
		world._translucent_buildings = set()

	if not world._translucent_buildings: # no translucent buildings saved => enable
		building_types = world.session.db.get_translucent_buildings()
		add = world._translucent_buildings.add
		from weakref import ref as create_weakref

		for b in world.get_all_buildings():
			if b.id in building_types:
				fife_instance = b._instance
				add( create_weakref(fife_instance) )
				fife_instance.keep_translucency = True
				fife_instance.get2dGfxVisual().setTransparency( BUILDINGS.TRANSPARENCY_VALUE )

	else: # undo translucency
		for inst in world._translucent_buildings:
			try:
				inst().get2dGfxVisual().setTransparency( 0 )
				inst().keep_translucency = False
			except AttributeError:
				pass # obj has been deleted, inst() returned None
		world._translucent_buildings.clear()


def save_map(world, path, prefix):
	map_file = os.path.join(path, prefix + '.sqlite')
	db = DbReader(map_file)
	read_savegame_template(db)
	db('BEGIN')
	for island in world.islands:
		island_name = '%s_island_%d_%d.sqlite' % (prefix, island.origin.x, island.origin.y)
		island_db_path = os.path.join(path, island_name)
		if os.path.exists(island_db_path):
			os.unlink(island_db_path) # the process relies on having an empty file
		db('INSERT INTO island (x, y, file) VALUES(?, ?, ?)', island.origin.x, island.origin.y, 'content/islands/' + island_name)
		island_db = DbReader(island_db_path)
		island.save_map(island_db)
		island_db.close()
	db('COMMIT')
	db.close()


def add_resource_deposits(world, resource_multiplier):
	"""
	Place clay deposits and mountains.

	The algorithm:
	1. calculate the manhattan distance from each island tile to the sea
	2. calculate the value of a tile
	3. calculate the value of an object's location as min(covered tile values)
	4. for each island place a number of clay deposits and mountains
	5. place a number of extra clay deposits and mountains without caring about the island
	* the probability of choosing a resource deposit location is proportional to its value

	@param natural_resource_multiplier: multiply the amount of clay deposits and mountains by this.
	"""

	moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]
	ClayDeposit = Entities.buildings[BUILDINGS.CLAY_DEPOSIT]
	Mountain = Entities.buildings[BUILDINGS.MOUNTAIN]
	clay_deposit_locations = []
	mountain_locations = []

	def get_valid_locations(usable_part, island, width, height):
		"""Return a list of all valid locations for a width times height object in the format [(value, (x, y), island), ...]."""
		locations = []
		offsets = list(itertools.product(xrange(width), xrange(height)))
		for x, y in sorted(usable_part):
			min_value = None
			for dx, dy in offsets:
				coords = (x + dx, y + dy)
				if coords in usable_part:
					value = usable_part[coords]
					min_value = value if min_value is None or min_value > value else min_value
				else:
					min_value = None
					break
			if min_value:
				locations.append((1.0 / min_value, (x, y), island))
		return locations

	def place_objects(locations, max_objects, object_class):
		"""Place at most *max_objects* objects of the given class."""
		if not locations:
			return

		total_sum = [0]
		last_sum = 0
		for value in zip(*locations)[0]:
			last_sum += value
			total_sum.append(last_sum)

		for _unused1 in xrange(max_objects):
			for _unused2 in xrange(7): # try to place the object 7 times
				object_sum = world.session.random.random() * last_sum
				pos = bisect.bisect_left(total_sum, object_sum, 0, len(total_sum) - 2)
				x, y = locations[pos][1]
				if object_class.check_build(world.session, Point(x, y), check_settlement=False):
					Build(object_class, x, y, locations[pos][2],
					      45 + world.session.random.randint(0, 3) * 90,
					      ownerless=True)(issuer=None)
					break

	for island in world.islands:
		# mark island tiles that are next to the sea
		queue = deque()
		distance = {}
		for (x, y), tile in island.ground_map.iteritems():
			if len(tile.classes) == 1: # could be a shallow to deep water tile
				for dx, dy in moves:
					coords = (x + dx, y + dy)
					if coords in world.water_body and world.water_body[coords] == world.sea_number:
						distance[(x, y)] = 1
						queue.append((x, y, 1))
						break

		# calculate the manhattan distance to the sea
		while queue:
			x, y, dist = queue.popleft()
			for dx, dy in moves:
				coords = (x + dx, y + dy)
				if coords in distance:
					continue
				if coords in world.water_body and world.water_body[coords] == world.sea_number:
					continue
				distance[coords] = dist + 1
				queue.append((coords[0], coords[1], dist + 1))

		# calculate tiles' values
		usable_part = {}
		for coords, dist in distance.iteritems():
			if coords in island.ground_map and 'constructible' in island.ground_map[coords].classes:
				usable_part[coords] = (dist + 5) ** 2

		# place the local clay deposits
		local_clay_deposit_locations = get_valid_locations(usable_part, island, *ClayDeposit.size)
		clay_deposit_locations.extend(local_clay_deposit_locations)
		local_clay_deposits_base = 0.3 + len(local_clay_deposit_locations) ** 0.7 / 60.0
		num_local_clay_deposits = int(max(0, resource_multiplier * min(3, local_clay_deposits_base + abs(world.session.random.gauss(0, 0.7)))))
		place_objects(local_clay_deposit_locations, num_local_clay_deposits, ClayDeposit)

		# place the local mountains
		local_mountain_locations = get_valid_locations(usable_part, island, *Mountain.size)
		mountain_locations.extend(local_mountain_locations)
		local_mountains_base = 0.1 + len(local_mountain_locations) ** 0.5 / 120.0
		num_local_mountains = int(max(0, resource_multiplier * min(2, local_mountains_base + abs(world.session.random.gauss(0, 0.8)))))
		place_objects(local_mountain_locations, num_local_mountains, Mountain)

	# place some extra clay deposits
	extra_clay_base = len(clay_deposit_locations) ** 0.8 / 400.0
	num_extra_clay_deposits = int(round(max(1, resource_multiplier * min(7, len(world.islands) * 1.0 + 2, extra_clay_base + abs(world.session.random.gauss(0, 1))))))
	place_objects(clay_deposit_locations, num_extra_clay_deposits, ClayDeposit)

	# place some extra mountains
	extra_mountains_base = len(mountain_locations) ** 0.8 / 700.0
	num_extra_mountains = int(round(max(1, resource_multiplier * min(4, len(world.islands) * 0.5 + 2, extra_mountains_base + abs(world.session.random.gauss(0, 0.7))))))
	place_objects(mountain_locations, num_extra_mountains, Mountain)


def add_nature_objects(world, natural_resource_multiplier):
	"""
	Place trees, wild animals, fish deposits, clay deposits, and mountains.

	@param natural_resource_multiplier: multiply the amount of fish deposits, clay deposits, and mountains by this.
	"""

	if not int(world.properties.get('RandomTrees', 1)):
		return

	add_resource_deposits(world, natural_resource_multiplier)
	Tree = Entities.buildings[BUILDINGS.TREE]
	FishDeposit = Entities.buildings[BUILDINGS.FISH_DEPOSIT]
	fish_directions = [(i, j) for i in xrange(-1, 2) for j in xrange(-1, 2)]

	# TODO HACK BAD THING hack the component template to make trees start finished
	Tree.component_templates[1]['ProducerComponent']['start_finished'] = True
	# add trees, wild animals, and fish
	for island in world.islands:
		for (x, y), tile in sorted(island.ground_map.iteritems()):
			# add trees based on adjacent trees
			for (dx, dy) in fish_directions:
				position = Point(x+dx, y+dy)
				newTile = world.get_tile(position)
				if newTile.object is not None and newTile.object.id == BUILDINGS.TREE and world.session.random.randint(0, 2) == 0 and Tree.check_build(world.session, tile, check_settlement=False):
					building = Build(Tree, x, y, island, 45 + world.session.random.randint(0, 3) * 90, ownerless=True)(issuer=None)
					if world.session.random.randint(0, WILD_ANIMAL.POPULATION_INIT_RATIO) == 0:
						CreateUnit(island.worldid, UNITS.WILD_ANIMAL, x, y)(issuer=None)
					if world.session.random.random() > WILD_ANIMAL.FOOD_AVAILABLE_ON_START:
						building.get_component(StorageComponent).inventory.alter(RES.WILDANIMALFOOD, -1)
				
				
			# add tree to every nth tile and an animal to one in every M trees
			if world.session.random.randint(0, 20) == 0 and \
			   Tree.check_build(world.session, tile, check_settlement=False):
				building = Build(Tree, x, y, island, 45 + world.session.random.randint(0, 3) * 90,
				                 ownerless=True)(issuer=None)
				if world.session.random.randint(0, WILD_ANIMAL.POPULATION_INIT_RATIO) == 0: # add animal to every nth tree
					CreateUnit(island.worldid, UNITS.WILD_ANIMAL, x, y)(issuer=None)
				if world.session.random.random() > WILD_ANIMAL.FOOD_AVAILABLE_ON_START:
					building.get_component(StorageComponent).inventory.alter(RES.WILDANIMALFOOD, -1)
			
			if 'coastline' in tile.classes and world.session.random.random() < natural_resource_multiplier / 4.0:
				# try to place fish: from the current position go to a random directions twice
				for (x_dir, y_dir) in world.session.random.sample(fish_directions, 2):
					# move a random amount in both directions
					fish_x = x + x_dir * world.session.random.randint(3, 9)
					fish_y = y + y_dir * world.session.random.randint(3, 9)
					# now we have the location, check if we can build here
					if (fish_x, fish_y) in world.ground_map:
						Build(FishDeposit, fish_x, fish_y, world,
						      45 + world.session.random.randint(0, 3) * 90,
						      ownerless=True)(issuer=None)

	# TODO HACK BAD THING revert hack so trees don't start finished
	Tree.component_templates[1]['ProducerComponent']['start_finished'] = False


def get_random_possible_ground_unit_position(world):
	"""Returns a position in water, that is not at the border of the world"""
	offset = 2
	while True:
		x = world.session.random.randint(world.min_x + offset, world.max_x - offset)
		y = world.session.random.randint(world.min_y + offset, world.max_y - offset)

		if (x, y) in world.ground_unit_map:
			continue

		for island in world.islands:
			if (x, y) in island.path_nodes.nodes:
				return Point(x, y)

def get_random_possible_ship_position(world):
	"""Returns a position in water, that is not at the border of the world"""
	offset = 2
	while True:
		x = world.session.random.randint(world.min_x + offset, world.max_x - offset)
		y = world.session.random.randint(world.min_y + offset, world.max_y - offset)

		if (x, y) in world.ship_map:
			continue # don't place ship where there is already a ship

		# check if there is an island nearby (check only important coords)
		position_possible = True
		for first_sign in (-1, 0, 1):
			for second_sign in (-1, 0, 1):
				point_to_check = Point( x + offset*first_sign, y + offset*second_sign )
				if world.get_island(point_to_check) is not None:
					position_possible = False
					break
		if not position_possible: # propagate break
			continue # try another coord

		break # all checks successful

	return Point(x, y)

def get_random_possible_coastal_ship_position(world):
	"""Returns a position in water, that is not at the border of the world
	but on the coast of an island"""
	offset = 2
	# Don't look for a point if there are no islands for some reason
	if not world.islands:
		return
	while True:
		x = world.session.random.randint(world.min_x + offset, world.max_x - offset)
		y = world.session.random.randint(world.min_y + offset, world.max_y - offset)

		if (x, y) in world.ship_map:
			continue # don't place ship where there is already a ship

		result = Point(x, y)
		if world.get_island(result) is not None:
			continue # don't choose a point on an island

		# check if there is an island nearby (check only important coords)
		for first_sign in (-1, 0, 1):
			for second_sign in (-1, 0, 1):
				point_to_check = Point( x + first_sign, y + second_sign )
				if world.get_island(point_to_check) is not None:
					return result


########NEW FILE########
__FILENAME__ = run_server
#!/usr/bin/env python2

# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import getopt
import os
import sys

from horizons import network
from horizons.network.server import Server

def fork():
	try:
		pid = os.fork()
		if pid > 0:
			sys.exit(0)
	except OSError, e:
		sys.stderr.write("Unable to fork: (%d) %s\n" % (e.errno, e.strerror))
		sys.exit(1)

	os.umask(0)
	os.setsid()

	# fork again to remove a possible session leadership gained after setsid()
	try:
		pid = os.fork( )
		if pid > 0:
			sys.exit(0)
	except OSError, e:
		sys.stderr.write("Unable to fork: (%d) %s\n" % (e.errno, e.strerror))
		sys.exit(1)
	return os.getpid()

def redirect(stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):
	for f in sys.stdout, sys.stderr:
		f.flush()
	ifd = file(stdin,  'r')
	ofd = file(stdout, 'a+')
	efd = ofd if (stdout == stderr) else file(stderr, 'a+')
	os.dup2(ifd.fileno(), sys.stdin.fileno())
	os.dup2(ofd.fileno(), sys.stdout.fileno())
	os.dup2(efd.fileno(), sys.stderr.fileno())

def usage(fd=sys.stdout):
	fd.write("Usage: %s" % (sys.argv[0]))
	if os.name == "posix":
		fd.write(" [-d]")
	fd.write(" -h host [-p port] [-s statistic_file]")
	if os.name == "posix":
		fd.write(" [-l logfile] [-P pidfile] ")
	fd.write("\n")

host = None
port = 2002
statfile = None
daemonize = False
logfile = None
pidfile = None

try:
	options = 'h:p:s:'
	if os.name == "posix":
		options += 'dl:P:'
	opts, args = getopt.getopt(sys.argv[1:], options)
except getopt.GetoptError as err:
	sys.stderr.write(str(err))
	usage()
	sys.exit(1)

try:
	for (key, value) in opts:
		if key == '-h':
			host = value
		if key == '-p':
			port = int(value)
		if key == '-s':
			statfile = value
		if os.name == "posix":
			if key == '-d':
				daemonize = True
			if key == '-l':
				logfile = value
			if key == '-P':
				pidfile = value
except (ValueError, IndexError):
	port = 0

if host == None or port == None or port <= 0:
	usage()
	sys.exit(1)

if pidfile and os.path.isfile(pidfile):
	sys.stderr.write("Error: Pidfile '%s' already exists.\n" % (pidfile))
	sys.stderr.write("Please make sure no other server is running and remove this file\n")
	sys.exit(1)

pid = os.getpid()
if daemonize:
	pid = fork()
	# daemon must redirect!
	if logfile is None:
		logfile = '/dev/null'

if logfile is not None:
	redirect('/dev/null', logfile, logfile)

if pidfile:
	file(pidfile, 'w').write(str(pid))

try:
	server = Server(host, port, statfile)
	server.run()
except network.NetworkException as e:
	sys.stderr.write("Error: %s\n" % e)
	sys.exit(2)

if pidfile:
	os.unlink(pidfile)

########NEW FILE########
__FILENAME__ = run_tests
#!/usr/bin/env python2

# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import gettext
import sys

try:
	import nose
except ImportError:
	print 'The nose package is needed to run the UH tests.'
	sys.exit(1)

try:
	import mock
except ImportError:
	print 'The mock package is needed to run the UH tests.'
	sys.exit(1)


from horizons.ext.dummy import Dummy


def mock_fife():
	"""
	Using a custom import hook, we catch all imports of fife and provide a
	dummy module.
	"""
	class Importer(object):

		def find_module(self, fullname, path=None):
			if fullname.startswith('fife'):
				return self

			return None

		def load_module(self, name):
			mod = sys.modules.setdefault(name, Dummy())
			return mod

	sys.meta_path = [Importer()]

def setup_horizons():
	"""
	Get ready for testing.
	"""

	# This needs to run at first to avoid that other code gets a reference to
	# the real fife module
	mock_fife()

	# set global reference to fife
	import horizons.globals
	import fife
	horizons.globals.fife = fife.fife

	from run_uh import create_user_dirs
	create_user_dirs()

	import horizons.i18n
	horizons.i18n.change_language()


if __name__ == '__main__':
	gettext.install('', unicode=True) # no translations here

	setup_horizons()

	from tests.gui import GuiTestPlugin
	from tests.utils import ReRunInfoPlugin
	nose.run(defaultTest='tests', addplugins=[GuiTestPlugin(), ReRunInfoPlugin()])
########NEW FILE########
__FILENAME__ = run_uh
#!/usr/bin/env python2

# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

"""TUTORIAL: Welcome to the Unknown Horizons in-code tutorial!
This is a guide for people who are interested in how the code works.
All parts of it are marked with 'TUTORIAL', and every entry contains
a pointer to the next step. Have fun :-)

This is the Unknown Horizons launcher; it looks for FIFE and tries
to start the game. You usually don't need to work with this directly.
If you want to dig into the game, continue to horizons/main.py. """

import sys
import os
import os.path
import gettext
import time
import imp
import functools
import locale
import logging
import logging.config
import logging.handlers
import signal
import traceback
import platform

# NOTE: do NOT import anything from horizons.* into global scope
# this will break any run_uh imports from other locations (e.g. _get_version())

def exit_with_error(title, message):
	if title + '.' != message:
		print(title)
	print(message)

	try:
		import Tkinter
		import tkMessageBox
		window = Tkinter.Tk()
		window.wm_withdraw()
		tkMessageBox.showerror(title, message)
	except ImportError:
		# tkinter may be missing
		pass
	exit(1)

def check_python_version():
	# python up to version 2.6.1 returns an int. http://bugs.python.org/issue5561
	if platform.python_version_tuple()[0] not in (2,'2'):
		exit_with_error('Unsupported Python version', 'Python 2 is required to run Unknown Horizons.')


check_python_version()


def log():
	"""Returns Logger"""
	return logging.getLogger("run_uh")

logfilename = None
logfile = None

def get_content_dir_parent_path():
	"""
	Return the path to the parent of the content dir.
	This is usually just the dir the run_uh.py is in but on some Linux installation
	scenarios the horizons dir, the content dir, and run_uh.py are all in different
	locations.
	"""

	options = []
	# Try the directory this file is in. This should work in most cases.
	options.append(os.path.dirname(os.path.realpath(unicode(__file__))))
	# Try path for Mac Os X app container (Unknown Horizons.app).
	# Unknown Horizons.app/Contents/Resources/contents
	options.append(os.path.join(os.getcwd()))
	# Try often-used paths on Linux.
	for path in ('/usr/share/games', '/usr/share', '/usr/local/share/games', '/usr/local/share'):
		options.append(os.path.join(path, u'unknown-horizons'))

	for path in options:
		content_path = os.path.join(path, u'content')
		if os.path.exists(content_path):
			return path
	raise RuntimeError('Unable to find the path to the Unknown Horizons content dir.')

def create_user_dirs():
	"""Creates the userdir and subdirs. Includes from horizons."""
	from horizons.constants import PATHS
	for directory in (PATHS.USER_DIR, PATHS.LOG_DIR, PATHS.USER_MAPS_DIR, PATHS.SCREENSHOT_DIR):
		if not os.path.isdir(directory):
			os.makedirs(directory)

def excepthook_creator(outfilename):
	"""Returns an excepthook function to replace sys.excepthook.
	The returned function does the same as the default, except it also prints the traceback
	to a file.
	@param outfilename: a filename to append traceback to"""
	def excepthook(exception_type, value, tb):
		f = open(outfilename, 'a')
		traceback.print_exception(exception_type, value, tb, file=f)
		traceback.print_exception(exception_type, value, tb)
		print('')
		print(_('Unknown Horizons has crashed.'))
		print('')
		print(_('We are very sorry for this and want to fix the underlying error.'))
		print(_('In order to do this, we need the information from the logfile:'))
		print(outfilename)
		print(_('Please give it to us via IRC or our forum, for both see http://unknown-horizons.org .'))
	return excepthook

def exithandler(exitcode, signum, frame):
	"""Handles a kill quietly"""
	signal.signal(signal.SIGINT, signal.SIG_IGN)
	signal.signal(signal.SIGTERM, signal.SIG_IGN)
	print('')
	print('Oh my god! They killed UH.')
	print('You bastards!')
	if logfile:
		logfile.close()
	sys.exit(exitcode)

def setup_streams():
	"""Ignore output to stderr and stdout if writing to them is not possible."""
	if sys.__stderr__.fileno() < 0:
		sys.stderr = open(os.devnull, 'w')
	if sys.__stdout__.fileno() < 0:
		sys.stdout = open(os.devnull, 'w')

def main():
	# abort silently on signal
	signal.signal(signal.SIGINT, functools.partial(exithandler, 130))
	signal.signal(signal.SIGTERM, functools.partial(exithandler, 1))

	# avoid crashing when writing to unavailable standard streams
	setup_streams()

	# use locale-specific time.strftime handling
	try:
		locale.setlocale(locale.LC_TIME, '')
	except locale.Error: # Workaround for "locale.Error: unsupported locale setting"
		pass

	# Change the working directory to the parent of the content directory
	os.chdir(get_content_dir_parent_path())
	logging.config.fileConfig(os.path.join('content', 'logging.conf'))
	create_user_dirs()

	from horizons.util.cmdlineoptions import get_option_parser
	options = get_option_parser().parse_args()[0]
	setup_debugging(options)
	init_environment(True)

	# test if required libs can be found or display specific error message
	try:
		import yaml
	except ImportError:
		headline = _('Error: Unable to find required library "PyYAML".')
		msg = _("PyYAML (a required library) is missing and needs to be installed.") + "\n" + \
		    _('The Windows installer is available at http://pyyaml.org/wiki/PyYAML.') + " " + \
		    _('Linux users should find it using their package manager under the name "pyyaml" or "python-yaml".')
		exit_with_error(headline, msg)

	# Start UH.
	import horizons.main
	ret = True
	if not options.profile:
		# start normal
		ret = horizons.main.start(options)
	else:
		# start with profiling
		try:
			import cProfile as profile
		except ImportError:
			import profile

		from horizons.constants import PATHS
		profiling_dir = os.path.join(PATHS.USER_DIR, 'profiling')
		if not os.path.exists(profiling_dir):
			os.makedirs(profiling_dir)

		pattern = os.path.join(profiling_dir, time.strftime('%Y-%m-%d') + '.%02d.prof')
		num = 1
		while os.path.exists(pattern % num):
			num += 1

		outfilename = pattern % num
		print('Starting in profile mode. Writing output to: %s' % outfilename)
		profile.runctx('horizons.main.start(options)', globals(), locals(), outfilename)
		print('Program ended. Profiling output: %s' % outfilename)

	if logfile:
		logfile.close()
	if ret:
		print(_('Thank you for using Unknown Horizons!'))


def setup_debugging(options):
	"""Parses and applies options
	@param options: parameters: debug, debug_module, debug_log_only, logfile
	"""
	global logfilename, logfile

	# not too nice way of sharing code, but it is necessary because code from this file
	# can't be accessed elsewhere on every distribution, and we can't just access other code.
	# however, passing options is guaranteed to work
	options.setup_debugging = setup_debugging

	# apply options
	if options.debug or options.debug_log_only:
		logging.getLogger().setLevel(logging.DEBUG)
	for module in options.debug_module:
		if not module in logging.Logger.manager.loggerDict:
			print('No such logger: %s' % module)
			sys.exit(1)
		logging.getLogger(module).setLevel(logging.DEBUG)
	if options.debug or options.debug_module or options.debug_log_only:
		options.debug = True
		# also log to file
		# init a logfile handler with a dynamic filename
		from horizons.constants import PATHS
		if options.logfile:
			logfilename = options.logfile
		else:
			logfilename = os.path.join(PATHS.LOG_DIR, "unknown-horizons-%s.log" %
			                           time.strftime("%Y-%m-%d_%H-%M-%S"))
		print('Logging to {uh} and {fife}'.format(
			uh=logfilename.encode('utf-8', 'replace'),
			fife=os.path.join(os.getcwd(), 'fife.log')) )
		# create logfile
		logfile = open(logfilename, 'w')
		# log there
		file_handler = logging.FileHandler(logfilename, 'a')
		logging.getLogger().addHandler(file_handler)
		# log exceptions
		sys.excepthook = excepthook_creator(logfilename)
		# log any other stdout output there (this happens, when FIFE c++ code launches some
		# FIFE python code and an exception happens there). The exceptionhook only gets
		# a director exception, but no real error message then.
		class StdOutDuplicator(object):
			def write(self, line):
				line = unicode(line)
				sys.__stdout__.write(line)
				logfile.write(line.encode('UTF-8'))
			def flush(self):
				sys.__stdout__.flush()
				logfile.flush()
		sys.stdout = StdOutDuplicator()

		# add a handler to stderr too _but_ only if logfile isn't already a tty
		# this allows --debug-module=<module> --logfile=/dev/stdout
		# without getting logs twice + without enabling debug log for everything
		# (see first if-clause inside that method)
		if not options.debug_log_only and not logfile.isatty():
			logging.getLogger().addHandler(logging.StreamHandler(sys.stderr))

		log_sys_info()

def import_fife(paths):
	try:
		# If FIFE can't be found then this call will throw an exception.
		settings = imp.find_module('fife', paths)
		fife = imp.load_module('fife', *settings)
		try:
			from fife import fife
		except ImportError as e:
			if str(e) != 'cannot import name fife':
				log().warning('Failed to use FIFE from %s', fife)
				log().warning(str(e))
				if str(e) == 'DLL load failed: %1 is not a valid Win32 application.':
					# We found FIFE but the Python and FIFE architectures don't match (Windows).
					exit_with_error('Unsupported Python version', '32 bit FIFE requires 32 bit (x86) Python 2.')
			return False
	except ImportError:
		# FIFE couldn't be found in any of the paths.
		return False
	return True

def find_fife():
	# Use the path the user provided.
	from horizons.util.cmdlineoptions import get_option_parser
	options = get_option_parser().parse_args()[0]
	if options.fife_path:
		fife_path = os.path.abspath(options.fife_path)
		# Support giving the path to FIFE_ROOT/engine/python/fife/__init__.pyc etc.
		if os.path.isfile(fife_path):
			fife_path = os.path.dirname(fife_path)
		# Support giving the path to FIFE_ROOT/engine/python
		if import_fife([fife_path]):
			return True
		# Support giving the path to FIFE_ROOT/engine
		if import_fife([os.path.join(fife_path, 'python')]):
			return True
		# Support giving the path to FIFE_ROOT
		if import_fife([os.path.join(fife_path, 'engine', 'python')]):
			return True
		# Support giving the path to FIFE_ROOT/engine/python/fife
		if import_fife([os.path.join(fife_path, '..')]):
			return True

		# End the search to avoid using the wrong (non-user-specified) FIFE.
		log().error('Unable to find FIFE in %s', fife_path)
		exit(1)

	# Try to use the default FIFE (equivalent of just trying to import it).
	if import_fife(None):
		return True

	# Look for FIFE in the neighborhood of the game dir.
	paths = []
	for opt1 in ('.', '..', '..' + os.sep + '..'):
		for opt2 in ('.', 'fife', 'FIFE', 'Fife', 'fifengine'):
			for opt3 in ('.', 'trunk'):
				path = os.path.abspath(os.path.join('.', opt1, opt2, opt3, 'engine', 'python'))
				if os.path.exists(path):
					paths.append(path)
	return import_fife(paths)

def setup_fife():
	log_paths()
	log_sys_info()
	if not find_fife():
		#TODO useful error message anyone?
		exit_with_error('Failed to find and/or load FIFE', 'Failed to find and/or load FIFE.')

	from fife import fife
	fife_version_major = fife.getMajor() if hasattr(fife, 'getMajor') else 'unknown'
	fife_version_minor = fife.getMinor() if hasattr(fife, 'getMinor') else 'unknown'
	fife_version_patch = fife.getPatch() if hasattr(fife, 'getPatch') else 'unknown'

	from horizons.constants import VERSION
	if (fife_version_major, fife_version_minor, fife_version_patch) < VERSION.REQUIRED_FIFE_VERSION:
		log().warning('Unsupported fife version %s.%s.%s, at least %d.%d.%d required', fife_version_major, fife_version_minor, fife_version_patch, VERSION.REQUIRED_FIFE_MAJOR_VERSION, VERSION.REQUIRED_FIFE_MINOR_VERSION, VERSION.REQUIRED_FIFE_PATCH_VERSION)
	else:
		log().debug('Using fife version %s.%s.%s, at least %d.%d.%d required', fife_version_major, fife_version_minor, fife_version_patch, VERSION.REQUIRED_FIFE_MAJOR_VERSION, VERSION.REQUIRED_FIFE_MINOR_VERSION, VERSION.REQUIRED_FIFE_PATCH_VERSION)

def init_environment(use_fife):
	"""Sets up everything.

	Use in any program that requires access to FIFE and UH modules."""
	# install dummy translation
	gettext.install('', unicode=True)
	if use_fife:
		setup_fife()

def log_paths():
	"""Prints debug info about paths to log"""
	log().debug("SYS.PATH: %s", sys.path)
	log().debug('PATHSEP: "%s" SEP: "%s"', os.path.pathsep, os.path.sep)
	log().debug("LD_LIBRARY_PATH: %s", os.environ.get('LD_LIBRARY_PATH', '<undefined>'))
	log().debug("PATH: %s", os.environ.get('PATH', '<undefined>'))
	log().debug("PYTHONPATH %s", os.environ.get('PYTHONPATH', '<undefined>'))

def log_sys_info():
	"""Prints debug info about the current system to log"""
	log().debug("Python version: %s", sys.version_info)
	log().debug("Platform: %s", platform.platform())

if __name__ == '__main__':
	main()

########NEW FILE########
__FILENAME__ = stage_build_mac
#!/usr/bin/env python

# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import shutil
import sys
import getopt
import os
import glob

verbose = False

help_message = '''
Usage: stage_build_mac.py [options]

Options:
    --run                    Start app with "open ./dist/Unknown Horizons.app" when done (all is cleaned before this)
    --fife-dir=<Location>    Location of FIFE-trunk
    --python-bin=<Location>  For people with a lot of python, this is totally optional!
    --verbose                Just as it sounds :) will output more info
'''


class Usage(Exception):
    def __init__(self, msg):
        self.msg = msg

def setup(fife_dir):
    """
    Setup files and directories
    """
    if verbose: print "Setting up environment"
    # If these two exists we remove them for a clean build
    if os.path.exists('./build'):
        if verbose: print "Cleaning build path"
        shutil.rmtree('./build')
    if os.path.exists('./dist'):
        if verbose: print "Cleaning dist path"
        shutil.rmtree('./dist')

    #These should have cleaned out, else we remove them
    if os.path.exists('./src'):
        if verbose: print "Cleaning src path"
        shutil.rmtree('./src')
    if os.path.exists('./fife'):
        if verbose: print "Cleaning fife path"
        shutil.rmtree('./fife')

    if verbose: print "Create src directory"
    # The source files, for building app correctly
    os.makedirs('./src/Contents/Resources/')

    #Copy fife and content
    if verbose: print "Copying Icon.icns"
    shutil.copy('./content/gui/icons/Icon.icns','./src/Contents/Resources/')

    if verbose: print "Copying fife source from "+fife_dir+"engine/python/fife"
    while shutil.copytree(fife_dir+'engine/python/fife', './fife'):
        if verbose: print "..."

    if verbose: print "Copying content into src"
    while shutil.copytree('./content', './src/Contents/Resources/content'):
        if verbose: print "..."

def tearDown(run):
    shutil.rmtree('./src/')
    shutil.rmtree('./fife')

    #Remove some other styff
    files = glob.glob('*.egg')
    for f in files:
        if os.path.isfile(f):
            os.remove(f)
        else:
            shutil.rmtree(f)

    #If the -r or --run arg is passed we start the app after build
    if run:
        os.popen("open ./dist/Unknown\ Horizons.app")

def build(pyver):
    os.system(pyver+" setup.py build_i18n")
    os.system(pyver+" setup_mac.py py2app")

def main(argv=None):
    fife_dir = False
    pyver = "/usr/bin/python"
    run = False
    if argv is None:
        argv = sys.argv
    try:
        try:
            opts, args = getopt.getopt(argv[1:], "hfp:rv", ["help", "fife-dir=", "python-bin=", "run", "--verbose"])
        except getopt.error, msg:
            raise Usage(msg)


        # option processing
        for option, value in opts:
            if option in ("-p","--python-bin",):
                pyver = value
            if option in ("-f","--fife-dir",):
                fife_dir = value
            if option in ("-h", "--help"):
                raise Usage(help_message)
            if option in ("-r","--run",):
                run = True
            if option in ("-v","--verbose",):
                verbose = True

        #We got to have the fife source!!!!!
        if not fife_dir:
            raise Usage(help_message)

    except Usage, err:
        print >> sys.stderr, sys.argv[0].split("/")[-1] + ": " + str(err.msg)
        print >> sys.stderr, "\t for help use --help"
        return 2

    setup(fife_dir)
    build(pyver)
    tearDown(run)

if __name__ == "__main__":
    sys.exit(main())
########NEW FILE########
__FILENAME__ = test_ai_long
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from functools import partial
from horizons.util.random_map import generate_map_from_seed
from tests.game import game_test

def test_ai_long():
	for seed in [1, 2, 3]:
		yield run_ai_long, seed

def run_ai_long(seed):
	@game_test(mapgen=partial(generate_map_from_seed, seed), human_player=False, ai_players=2, timeout=60*60)
	def test(session, _):
		"""Let 2 AI players play for 40 minutes."""
		session.run(seconds=40*60)
		assert session.world.settlements

	test()

# this disables the test in general and only makes it being run when
# called like this: run_tests.py -a long
test_ai_long.long = True

########NEW FILE########
__FILENAME__ = test_ai_quick
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from functools import partial
from horizons.util.random_map import generate_map_from_seed
from tests.game import game_test

def test_ai_quick():
	for seed in [5, 6, 7, 8, 9]:
		yield run_ai_quick, seed

def run_ai_quick(seed):
	@game_test(mapgen=partial(generate_map_from_seed, seed), human_player=False, ai_players=2, timeout=2*60)
	def test(session, _):
		"""Let 2 AI players play for four minutes."""
		session.run(seconds=4*60)
		assert session.world.settlements

	test()

# this disables the test in general and only makes it being run when
# called like this: run_tests.py -a long
test_ai_quick.long = True

########NEW FILE########
__FILENAME__ = test_ai_very_long
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from functools import partial
from horizons.util.random_map import generate_map_from_seed
from tests.game import game_test

def test_ai_very_long():
	# (function, seed)
	yield run_ai_very_long, 4

def run_ai_very_long(seed):
	@game_test(mapgen=partial(generate_map_from_seed, seed), human_player=False, ai_players=2, timeout=6*60*60)
	def test(session, _):
		"""Let 2 AI players play for 4 hours."""
		session.run(seconds=4*60*60)
		assert session.world.settlements

	test()

# this disables the test in general and only makes it being run when
# called like this: run_tests.py -a long
test_ai_very_long.long = True

########NEW FILE########
__FILENAME__ = test_load_save_long
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os
import tempfile
from functools import partial

from horizons.util.random_map import generate_map_from_seed
from horizons.util.savegameaccessor import SavegameAccessor

from tests.game import game_test

@game_test(mapgen=partial(generate_map_from_seed, 2), human_player=False, ai_players=2, timeout=2*60)
def test_save_trivial(session, _):
	"""
	Let 2 AI players play for a while, then attempt to save the game.

	Be aware, this is a pretty simple test and it doesn't actually check what is
	being saved.
	"""
	session.run(seconds=4*60)

	fd, filename = tempfile.mkstemp()
	os.close(fd)

	assert session.save(savegamename=filename)

	SavegameAccessor(filename, False)

	os.unlink(filename)

# this disables the test in general and only makes it being run when
# called like this: run_tests.py -a long
test_save_trivial.long = True

########NEW FILE########
__FILENAME__ = test_blackdeath
# ###################################################
# Copyright (C) 2013 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from horizons.constants import BUILDINGS
from horizons.world.disaster.blackdeathdisaster import BlackDeathDisaster

from tests.game import game_test


# FIXTURE is settlement in tier settlers with min 16 inhabitants

@game_test(use_fixture='blackdeath')
def test_blackdeath_destroy(s):
	"""
	Check if the black death destroys all settlers
	"""
	dis_man = s.world.disaster_manager
	settlement = s.world.player.settlements[0]

	# need this so that disaster  can break out
	s.world.player.settler_level = 4

	assert settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ]
	inhabitants_before = settlement.inhabitants

	residential_buildings = len(settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ])
	assert residential_buildings > BlackDeathDisaster.MIN_INHABITANTS_FOR_BREAKOUT

	while not dis_man._active_disaster:
		dis_man.run() # try to seed until we have the black death

	# wait until the black death has done some damage
	s.run(seconds=50)

	# it's not defined how bad the black death is, but some inhabitants should die
	assert settlement.inhabitants < inhabitants_before


########NEW FILE########
__FILENAME__ = test_bugs
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.command.building import Build, Tear
from horizons.component.storagecomponent import StorageComponent
from horizons.component.collectingcomponent import CollectingComponent
from horizons.world.production.producer import Producer, QueueProducer
from horizons.constants import BUILDINGS, RES, PRODUCTIONLINES
from horizons.util.worldobject import WorldObject
from horizons.util.shapes import Point
from horizons.world.production.utilization import FieldUtilization
from horizons.world.building.settler import SettlerRuin

from tests.game import settle, game_test, new_session, saveload
from tests.game.test_buildings import test_brick_production_chain, test_tool_production_chain
from tests.game.test_farm import _build_farm


@game_test()
def test_ticket_979(s, p):
	settlement, island = settle(s)
	storage_collectors = settlement.warehouse.get_component(CollectingComponent).get_local_collectors()

	farm = _build_farm(30, 30, BUILDINGS.POTATO_FIELD, island, settlement, p)

	# Let it work for a bit
	s.run(seconds=60)
	assert farm.get_component(StorageComponent).inventory[RES.FOOD]

	# Depending on auto unloading (which we aren't interested in here),
	# the settlement inventory may already be full of food: dispose of it
	settlement.get_component(StorageComponent).inventory.alter(RES.FOOD, -settlement.get_component(StorageComponent).inventory[RES.FOOD])
	assert settlement.get_component(StorageComponent).inventory[RES.FOOD] == 0

	# Build a road, connecting farm and warehouse
	for y in range(23, 30):
		assert Build(BUILDINGS.TRAIL, 30, y, island, settlement=settlement)(p)

	# Step forward in time until a collector picked a job
	got_job = False
	while not got_job:
		s.run()
		if any(c.job for c in storage_collectors):
			got_job = True

	Tear(farm)(p)

	# Let the collector reach the not existing target
	s.run(seconds=10)


@game_test()
def test_ticket_1016(s, p):
	settlement, island = settle(s)

	farm = _build_farm(30, 30, BUILDINGS.POTATO_FIELD, island, settlement, p)

	# tear down job target, then home building (in the same tick)

	torn_down = False
	while not torn_down:
		s.run(seconds=1)
		for col in farm.get_component(CollectingComponent)._CollectingComponent__collectors:
			if col.job:
				Tear(col.job.object)(p)
				Tear(farm)(p)
				torn_down = True
				break

	s.run(seconds=30)


@game_test()
def test_ticket_1005(s, p):
	settlement, island = settle(s)
	assert len(s.world.ships) == 2

	builder = Build(BUILDINGS.BOAT_BUILDER, 35, 20, island, settlement=settlement)(p)
	builder.get_component(StorageComponent).inventory.alter(RES.TEXTILE, 5)
	builder.get_component(StorageComponent).inventory.alter(RES.BOARDS, 4)
	builder.get_component(Producer).add_production_by_id(15)

	s.run(seconds=130)

	assert len(s.world.ships) == 3


@game_test()
def test_ticket_1232(s, p):
	settlement, island = settle(s)
	assert len(s.world.ships) == 2

	boat_builder = Build(BUILDINGS.BOAT_BUILDER, 35, 20, island, settlement=settlement)(p)
	boat_builder.get_component(StorageComponent).inventory.alter(RES.TEXTILE, 10)
	boat_builder.get_component(StorageComponent).inventory.alter(RES.BOARDS, 8)
	assert isinstance(boat_builder.get_component(Producer), QueueProducer)

	production_finished = [False]
	boat_builder.get_component(Producer).add_production_by_id(PRODUCTIONLINES.HUKER)
	production1 = boat_builder.get_component(Producer)._get_production(PRODUCTIONLINES.HUKER)
	production1.add_production_finished_listener(lambda _: production_finished.__setitem__(0, True))
	assert boat_builder.get_component(Producer).is_active()
	while not production_finished[0]:
		s.run(ticks=1)
	assert not boat_builder.get_component(Producer).is_active()
	assert len(s.world.ships) == 3
	# Make sure enough res are available
	boat_builder.get_component(StorageComponent).inventory.alter(RES.TEXTILE, 10)
	boat_builder.get_component(StorageComponent).inventory.alter(RES.BOARDS, 8)
	boat_builder.get_component(StorageComponent).inventory.alter(RES.TOOLS, 5)

	boat_builder.get_component(Producer).add_production_by_id(PRODUCTIONLINES.HUKER)
	assert boat_builder.get_component(Producer).is_active()
	s.run(seconds=130)
	assert not boat_builder.get_component(Producer).is_active()
	assert len(s.world.ships) == 4


def test_brick_tool_interference():
	"""
	Running the brick test at first will break the tool test.
	"""
	test_brick_production_chain()
	test_tool_production_chain()


def test_tool_brick_interference():
	"""
	Running the tool test at first will break the brick test.
	"""
	test_tool_production_chain()
	test_brick_production_chain()


@game_test(manual_session=True)
def test_ticket_1427():
	"""Boatbuilder production progress should be saved properly"""

	session, player = new_session()
	settlement, island = settle(session)

	boat_builder = Build(BUILDINGS.BOAT_BUILDER, 35, 20, island, settlement=settlement)(player)
	worldid = boat_builder.worldid

	# Make sure no boards are available
	settlement.get_component(StorageComponent).inventory.alter(RES.BOARDS, -1000)

	bb_storage = boat_builder.get_component(StorageComponent)

	# Add production to use resources
	bb_producer = boat_builder.get_component(Producer)
	bb_producer.add_production_by_id(PRODUCTIONLINES.HUKER)
	production = bb_producer._productions[PRODUCTIONLINES.HUKER]

	assert production.progress == 0.0

	bb_storage.inventory.alter(RES.TEXTILE, 10)
	bb_storage.inventory.alter(RES.BOARDS, 6)

	production_line = production._prod_line

	# Make sure the boatbuilder consumes everything in its inventory
	session.run(seconds=10)

	# Check if correctly consumed wood
	assert production_line.consumed_res[RES.BOARDS] == -2

	# Save all production process for later
	expected_consumed_res = production_line.consumed_res
	expected_produced_res = production_line.produced_res
	expected_production = production_line.production
	expected_progress = production.progress

	# Make sure the producer used the boards
	assert bb_storage.inventory[RES.BOARDS] == 0

	# Save and reload game
	session = saveload(session)
	loadedbb = WorldObject.get_object_by_id(worldid)

	production_loaded = loadedbb.get_component(Producer)._productions[PRODUCTIONLINES.HUKER]
	production_line_loaded = production_loaded._prod_line

	# Make sure everything is loaded correctly
	assert expected_consumed_res == production_line_loaded.consumed_res
	assert expected_produced_res == production_line_loaded.produced_res
	assert expected_production == production_line_loaded.production
	assert expected_progress == production_loaded.progress

	# if you don't let the session run for a bit then collectors won't be fully initialized and can't be killed => another test will fail in session.end()
	session.run(seconds=1)
	session.end()


@game_test()
def test_ticket_1523(s, p):
	settlement, island = settle(s)

	farm = _build_farm(30, 30, BUILDINGS.POTATO_FIELD, island, settlement, p)

	# Let it work for a bit
	s.run(seconds=60)
	assert farm.get_component(StorageComponent).inventory[RES.FOOD]


	assert isinstance(farm.get_component(Producer)._Producer__utilization, FieldUtilization)
	# Should be 0.5
	assert not farm.get_component(Producer).capacity_utilization_below(0.4)
	assert farm.get_component(Producer).capacity_utilization > 0.4


@game_test()
def test_ticket_1561(s, p):
	settlement, island = settle(s)

	residence = Build(BUILDINGS.RESIDENTIAL, 30, 30, island, settlement=settlement)(p)
	s.run(ticks=1)
	assert residence.level == 0

	residence.level_up()
	s.run(ticks=1)
	assert residence.level == 1

	residence2 = Build(BUILDINGS.RESIDENTIAL, 30, 32, island, settlement=settlement)(p)
	s.run(ticks=1)
	assert residence2.level == 0


@game_test()
def test_ticket_1693(s, p):
	settlement, island = settle(s)

	residence = Build(BUILDINGS.RESIDENTIAL, 30, 30, island, settlement=settlement)(p)
	assert residence.level == 0

	# Run and wait until the settler levels down
	s.run(seconds=250)

	# get settler ruin
	tile = island.get_tile(Point(30, 30))
	ruin = tile.object

	assert ruin is not None
	assert isinstance(ruin, SettlerRuin)

	assert ruin.owner is not None
	assert ruin.tearable
	assert ruin.buildable_upon

	# Build another one on top of the ruin
	residence2 = Build(BUILDINGS.RESIDENTIAL, 30, 30, island, settlement=settlement)(p)
	assert residence2


@game_test()
def test_ticket_1847(s, p):
	"""Tearing down MineProducer (clay pit, mine) crashes game"""
	settlement, island = settle(s)

	assert Build(BUILDINGS.CLAY_DEPOSIT, 30, 30, island, ownerless=True)(None)
	claypit = Build(BUILDINGS.CLAY_PIT, 30, 30, island, settlement=settlement)(p)
	assert claypit

	Tear(claypit)(p)

	s.run(seconds=5)

########NEW FILE########
__FILENAME__ = test_buildings
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from itertools import product

from horizons.command.building import Build, Tear
from horizons.util.worldobject import WorldObject, WorldObjectNotFound
from horizons.command.unit import CreateUnit
from horizons.constants import BUILDINGS, UNITS, RES
from horizons.component.storagecomponent import StorageComponent
from horizons.world.production.producer import Producer

from tests.game import game_test, settle


@game_test()
def test_lumberjack(s, p):
	"""
	Lumberjack will produce boards out of wood, collected from nearby trees.
	"""
	settlement, island = settle(s)

	jack = Build(BUILDINGS.LUMBERJACK, 30, 30, island, settlement=settlement)(p)
	assert jack

	assert jack.get_component(StorageComponent).inventory[RES.BOARDS] == 0
	assert jack.get_component(StorageComponent).inventory[RES.TREES] == 0

	for (x_off, y_off) in product([-2, 2], repeat=2):
		x = 30 + x_off
		y = 30 + y_off
		tree = Build(BUILDINGS.TREE, x, y, island, settlement=settlement)(p)
		assert tree
		tree.get_component(Producer).finish_production_now()

	s.run(seconds=30)

	assert jack.get_component(StorageComponent).inventory[RES.BOARDS]


@game_test()
def test_hunter(s, p):
	"""
	Hunter will produce food from dear meat. No animals were harmed in this test.
	"""
	settlement, island = settle(s)

	hunter = Build(BUILDINGS.HUNTER, 30, 30, island, settlement=settlement)(p)
	assert hunter

	assert hunter.get_component(StorageComponent).inventory[RES.FOOD] == 0
	assert hunter.get_component(StorageComponent).inventory[RES.DEER_MEAT] == 0

	for (x_off, y_off) in product([-5, -4, 4, 5], repeat=2):
		x = 30 + x_off
		y = 30 + y_off
		animal = CreateUnit(island.worldid, UNITS.WILD_ANIMAL, x, y)(None)
		# wild animals are slow eaters, we feed them directly
		animal.get_component(StorageComponent).inventory.alter(12, 10)
		animal.get_component(Producer).finish_production_now()
		assert animal

	s.run(seconds=30)

	assert hunter.get_component(StorageComponent).inventory[RES.FOOD]


@game_test()
def test_fisherman(s, p):
	"""
	A fisherman produces food out of fish, collecting in nearby fish deposits.
	"""
	settlement, island = settle(s)

	for x in (25, 30, 35):
		school = Build(BUILDINGS.FISH_DEPOSIT, x, 18, s.world, ownerless=True)(None)
		assert school
		school.get_component(Producer).finish_production_now()

	fisherman = Build(BUILDINGS.FISHER, 25, 20, island, settlement=settlement)(p)
	assert fisherman

	assert fisherman.get_component(StorageComponent).inventory[RES.FOOD] == 0
	assert fisherman.get_component(StorageComponent).inventory[RES.FISH] == 0

	s.run(seconds=20)

	assert fisherman.get_component(StorageComponent).inventory[RES.FOOD]


@game_test()
def test_brick_production_chain(s, p):
	"""
	A brickyard makes bricks from clay. Clay is collected by a clay pit on a deposit.
	"""
	settlement, island = settle(s)

	assert Build(BUILDINGS.CLAY_DEPOSIT, 30, 30, island, ownerless=True)(None)
	assert Build(BUILDINGS.CLAY_PIT, 30, 30, island, settlement=settlement)(p)

	brickyard = Build(BUILDINGS.BRICKYARD, 30, 25, island, settlement=settlement)(p)
	assert brickyard.get_component(StorageComponent).inventory[RES.BRICKS] == 0
	assert brickyard.get_component(StorageComponent).inventory[RES.CLAY] == 0

	s.run(seconds=60) # 15s clay pit, 15s brickyard

	assert brickyard.get_component(StorageComponent).inventory[RES.BRICKS]


@game_test()
def test_tool_production_chain(s, p):
	"""
	Check if a iron mine gathers raw iron, a smeltery produces iron ingots, boards are converted
	to charcoal and tools are produced.

	Pretty much for a single test, but these are rather trivial in their assertions anyway.
	"""
	settlement, island = settle(s)

	assert Build(BUILDINGS.MOUNTAIN, 30, 35, island, ownerless=True)(None)
	assert Build(BUILDINGS.MINE, 30, 35, island, settlement=settlement)(p)

	charcoal = Build(BUILDINGS.CHARCOAL_BURNER, 25, 35, island, settlement=settlement)(p)
	assert charcoal
	charcoal.get_component(StorageComponent).inventory.alter(RES.BOARDS, 10) # give him boards directly

	assert Build(BUILDINGS.SMELTERY, 25, 30, island, settlement=settlement)(p)

	toolmaker = Build(BUILDINGS.TOOLMAKER, 22, 32, island, settlement=settlement)(p)
	assert toolmaker
	toolmaker.get_component(StorageComponent).inventory.alter(RES.BOARDS, 10) # give him boards directly

	assert toolmaker.get_component(StorageComponent).inventory[RES.TOOLS] == 0
	s.run(seconds=120)
	assert toolmaker.get_component(StorageComponent).inventory[RES.TOOLS]

@game_test()
def test_build_tear(s, p):
	"""
	Build stuff and tear it later
	"""
	settlement, island = settle(s)
	tree = Build(BUILDINGS.TREE, 30, 35, island, settlement=settlement)(p)

	s.run(seconds=1)

	wid = tree.worldid
	Tear(tree)(p)

	try:
		WorldObject.get_object_by_id(wid)
	except WorldObjectNotFound:
		pass # should be gone
	else:
		assert False


@game_test(timeout=60)
def test_tree_production(s, p):
	"""Check whether trees produce wood"""
	settlement, island = settle(s)
	tree = Build(BUILDINGS.TREE, 30, 35, island, settlement=settlement)(p)

	n = 20

	inv = tree.get_component(StorageComponent).inventory
	for i in xrange(n):  # we want n units

		while not inv[RES.TREES]:
			s.run(seconds=5)

		# take one away to free storage space
		#from tests import set_trace ; set_trace()
		inv.alter(RES.TREES, -1)

	# here, n tons of wood have been produced

########NEW FILE########
__FILENAME__ = test_combat
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from nose.plugins.skip import SkipTest

from horizons.util.color import Color
from horizons.util.worldobject import WorldObject, WorldObjectNotFound
from horizons.command.unit import CreateUnit, Attack
from horizons.command.diplomacy import AddEnemyPair, AddNeutralPair, AddAllyPair
from horizons.command.uioptions import EquipWeaponFromInventory, UnequipWeaponToInventory
from horizons.component.storagecomponent import StorageComponent
from horizons.world.player import Player
from horizons.constants import UNITS, WEAPONS
from horizons.component.healthcomponent import HealthComponent

from tests.game import game_test, new_session, saveload


def setup_combat(s, ship):
	worldid = 10000000

	p0 = Player(s, worldid, "p1", Color[1])
	p1 = Player(s, worldid+1, "p2", Color[2])

	for p in (p0, p1):
		p.initialize(None)
		s.world.players.append(p)

	s0 = CreateUnit(p0.worldid, ship, 0, 0)(issuer=p0)
	s1 = CreateUnit(p1.worldid, ship, 3, 3)(issuer=p1)

	return ((p0, s0), (p1, s1))


def health(thing):
	return thing.get_component(HealthComponent).health


def max_health(thing):
	return thing.get_component(HealthComponent).max_health


def one_dead(wid1, wid2):
	for wid in (wid1, wid2):
		at_least_one_dead = False
		try:
			WorldObject.get_object_by_id(wid)
		except WorldObjectNotFound:
			at_least_one_dead = True
	return at_least_one_dead


@game_test()
def test_noncombat_units(s, p):
	raise SkipTest()

	(p0, s0), (p1, s1) = setup_combat(s, UNITS.HUKER_SHIP)

	# healthy before
	assert health(s0) == max_health(s0)
	assert health(s1) == max_health(s1)

	assert len(s.world.ships) == 3 # trader also has a ship
	Attack(s0, s1).execute(s)

	s.run(seconds=60)

	# healthy after
	assert health(s0) == max_health(s0)
	assert health(s1) == max_health(s1)


@game_test()
def test_equip(s, p):
	raise SkipTest()

	assert WEAPONS.DEFAULT_FIGHTING_SHIP_WEAPONS_NUM > 0, (
	        "This test only makes sense with default cannons."
	        " Adapt this if you don't want default cannons.")

	(p0, s0), (p1, s1) = setup_combat(s, UNITS.FRIGATE)

	assert s0.get_component(StorageComponent).inventory[ WEAPONS.CANNON ] == 0
	assert s0.get_weapon_storage()[ WEAPONS.CANNON ] == WEAPONS.DEFAULT_FIGHTING_SHIP_WEAPONS_NUM

	# we don't have swords
	not_equip = EquipWeaponFromInventory(s0, WEAPONS.SWORD, 1).execute(s)
	assert not_equip == 1
	assert s0.get_component(StorageComponent).inventory[ WEAPONS.SWORD ] == 0
	assert s0.get_weapon_storage()[ WEAPONS.SWORD ] == 0

	# test equip
	s0.get_component(StorageComponent).inventory.alter( WEAPONS.CANNON, 2 )

	# this has to work
	not_equip = EquipWeaponFromInventory(s0, WEAPONS.CANNON, 1).execute(s)
	assert not_equip == 0

	assert s0.get_component(StorageComponent).inventory[ WEAPONS.CANNON ] == 1
	assert s0.get_weapon_storage()[WEAPONS.CANNON] == WEAPONS.DEFAULT_FIGHTING_SHIP_WEAPONS_NUM + 1

	# too many
	not_equip = EquipWeaponFromInventory(s0, WEAPONS.CANNON, 2).execute(s)

	assert not_equip == 1
	assert s0.get_component(StorageComponent).inventory[ WEAPONS.CANNON ] == 0
	assert s0.get_weapon_storage()[WEAPONS.CANNON] == WEAPONS.DEFAULT_FIGHTING_SHIP_WEAPONS_NUM + 2

	# no swords
	not_equip = UnequipWeaponToInventory(s0, WEAPONS.SWORD, 2).execute(s)
	assert not_equip == 2

	not_equip = UnequipWeaponToInventory(s0, WEAPONS.CANNON, 2).execute(s)
	assert not_equip == 0
	assert s0.get_component(StorageComponent).inventory[ WEAPONS.CANNON ] == 2
	assert s0.get_weapon_storage()[WEAPONS.CANNON] == WEAPONS.DEFAULT_FIGHTING_SHIP_WEAPONS_NUM

	not_equip = UnequipWeaponToInventory(s0, WEAPONS.CANNON, WEAPONS.DEFAULT_FIGHTING_SHIP_WEAPONS_NUM).execute(s)
	assert not_equip == 0

	assert s0.get_component(StorageComponent).inventory[ WEAPONS.CANNON ] == 2 + WEAPONS.DEFAULT_FIGHTING_SHIP_WEAPONS_NUM
	assert s0.get_weapon_storage()[WEAPONS.CANNON] == 0


@game_test()
def test_diplo0(s, p):

	(p0, s0), (p1, s1) = setup_combat(s, UNITS.FRIGATE)

	Attack(s0, s1).execute(s)
	# attack without war

	s.run(seconds=60)

	assert health(s0) == max_health(s0)
	assert health(s1) == max_health(s1)

	# declare war
	AddEnemyPair(p0, p1).execute(s)

	s.run(seconds=60)

	assert health(s0) < max_health(s0)
	assert health(s1) < max_health(s1)

	# it's not specified which one should lose
	assert health(s0) == 0 or health(s1) == 0


@game_test()
def test_dying(s, p):
	"""
	Check if units actually are gone when they have died
	"""
	(p0, s0), (p1, s1) = setup_combat(s, UNITS.FRIGATE)

	AddEnemyPair(p0, p1).execute(s)
	Attack(s0, s1).execute(s)

	s.run(seconds=60)

	assert health(s0) < max_health(s0)
	assert health(s1) < max_health(s1)

	# it's not specified which one should lose
	assert one_dead(s0.worldid, s1.worldid)


@game_test()
def test_diplo1(s, p):

	(p0, s0), (p1, s1) = setup_combat(s, UNITS.FRIGATE)

	assert health(s0) == max_health(s0)
	assert health(s1) == max_health(s1)

	# declare war
	AddEnemyPair(p0, p1).execute(s)
	# declare peace
	AddAllyPair(p0, p1).execute(s)

	s.run(seconds=60)

	assert health(s0) == max_health(s0)
	assert health(s1) == max_health(s1)

	# declare war
	AddEnemyPair(p0, p1).execute(s)
	# declare peace
	AddNeutralPair(p0, p1).execute(s)

	s.run(seconds=60)

	assert health(s0) == max_health(s0)
	assert health(s1) == max_health(s1)

	# declare war
	AddEnemyPair(p0, p1).execute(s)
	s.run(seconds=60)

	assert health(s0) != max_health(s0)
	assert health(s1) != max_health(s1)


@game_test()
def test_unfair(s, p):
	(p0, s0), (p1, s1) = setup_combat(s, UNITS.FRIGATE)

	# two against one

	s0_1 = CreateUnit(p0.worldid, UNITS.FRIGATE, 5, 5)(issuer=p0)

	AddEnemyPair(p0, p1).execute(s)

	Attack(s0, s1).execute(s)
	Attack(s0_1, s1).execute(s)

	s.run(seconds=60)

	assert health(s1) == 0
	assert health(s0) > 0
	assert health(s0_1) > 0

# TODO: stances

@game_test(manual_session=True)
def test_combat_save_load():
	"""
	create a savegame with combat units and actual combat, then save/load it
	"""

	session, player = new_session()
	(p0, s0), (p1, s1) = setup_combat(session, UNITS.FRIGATE)

	s0_worldid, s1_worldid = s0.worldid, s1.worldid

	session.run(seconds=1)

	# saveload
	session = saveload(session)

	s0 = WorldObject.get_object_by_id(s0_worldid)
	s1 = WorldObject.get_object_by_id(s1_worldid)

	# fight

	AddEnemyPair(p0, p1).execute(session)

	Attack(s0, s1).execute(session)
	Attack(s1, s0).execute(session)

	session.run(seconds=20)

	# saveload
	session = saveload(session)

	assert one_dead(s0_worldid, s1_worldid)

	session.end()

########NEW FILE########
__FILENAME__ = test_example
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from horizons.command.building import Build
from horizons.constants import RES, BUILDINGS, PRODUCTIONLINES
from horizons.component.storagecomponent import StorageComponent
from horizons.world.production.producer import Producer

from tests.game import game_test, settle


@game_test()
def test_example(s, p):
	"""
	Build a farm and 2 pastures. Confirm raw wool is produced at the
	pastures and used by the farm to produce wool.
	"""
	settlement, island = settle(s)

	farm = Build(BUILDINGS.FARM, 30, 30, island, settlement=settlement)(p)
	assert farm

	# Pause the production, we want to start it explicitly later.
	production = farm.get_component(Producer)._get_production(PRODUCTIONLINES.WOOL)
	production.pause()

	# Farm has no raw wool or wool.
	assert farm.get_component(StorageComponent).inventory[RES.LAMB_WOOL] == 0
	assert farm.get_component(StorageComponent).inventory[RES.WOOL] == 0

	# Build pastures, let the game run for 31 seconds. Pastures currently need
	# 30s to produce wool.
	p1 = Build(BUILDINGS.PASTURE, 27, 30, island, settlement=settlement)(p)
	p2 = Build(BUILDINGS.PASTURE, 33, 30, island, settlement=settlement)(p)
	assert p1 and p2

	s.run(seconds=31)

	assert p1.get_component(StorageComponent).inventory[RES.LAMB_WOOL]
	assert p2.get_component(StorageComponent).inventory[RES.LAMB_WOOL]

	# Give farm collectors a chance to get the wool from the pastures.
	s.run(seconds=5)

	assert farm.get_component(StorageComponent).inventory[RES.LAMB_WOOL]

	# Resume the production, let the game run for a second. The farm should have
	# produced wool now.
	production.pause(pause=False)
	s.run(seconds=1)
	assert farm.get_component(StorageComponent).inventory[RES.WOOL]


########NEW FILE########
__FILENAME__ = test_farm
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from itertools import product

from horizons.command.building import Build
from horizons.constants import BUILDINGS, RES
from horizons.component.storagecomponent import StorageComponent

from tests.game import game_test, settle


def _build_farm(x, y, field_type, island, settlement, owner):
	"""
	Build a farm at (x, y) and 4 fields of field_type.

	F   F
	  X		  (X - farm, F - field)
	F   F
	"""
	farm = Build(BUILDINGS.FARM, x, y, island, settlement=settlement)(owner)
	assert farm, "Failed to build a farm at (%d, %d)" % (x, y)

	for (x_off, y_off) in product([-3, 3], repeat=2):
		fx = x + x_off
		fy = x + y_off
		field = Build(field_type, fx, fy, island, settlement=settlement)(owner)
		assert field, "Failed to build a field (%d) at (%d, %d)" % (field_type, x, y)

	return farm


@game_test()
def test_weaver(s, p):
	"""
	A weaver produces textiles from wool. A pasture provides lamb wool for a farm,
	which it converts to wool for the weaver.
	"""
	settlement, island = settle(s)

	_build_farm(30, 30, BUILDINGS.PASTURE, island, settlement, p)

	weaver = Build(BUILDINGS.WEAVER, 27, 30, island, settlement=settlement)(p)
	assert weaver
	assert weaver.get_component(StorageComponent).inventory[RES.TEXTILE] == 0

	s.run(seconds=60)	# pasture 30s, farm 1s, weaver 12s

	assert weaver.get_component(StorageComponent).inventory[RES.TEXTILE]


@game_test()
def test_distillery(s, p):
	"""
	Distillery produces liquor out of sugar. A farm will collect raw sugar from a
	sugar field and produce sugar.
	"""
	settlement, island = settle(s)

	_build_farm(30, 30, BUILDINGS.SUGARCANE_FIELD, island, settlement, p)

	distillery = Build(BUILDINGS.DISTILLERY, 27, 30, island, settlement=settlement)(p)
	assert distillery
	assert distillery.get_component(StorageComponent).inventory[RES.LIQUOR] == 0

	s.run(seconds=60)	# sugarfield 30s, farm 1s, distillery 12s

	assert distillery.get_component(StorageComponent).inventory[RES.LIQUOR]


@game_test()
def test_potato_field(s, p):
	"""
	A farm collects potatoes from the field and produces food.
	"""
	settlement, island = settle(s)

	farm = _build_farm(30, 30, BUILDINGS.POTATO_FIELD, island, settlement, p)
	assert farm.get_component(StorageComponent).inventory[RES.FOOD] == 0
	assert farm.get_component(StorageComponent).inventory[RES.POTATOES] == 0

	s.run(seconds=60)	# potato field 26s, farm 1s

	assert farm.get_component(StorageComponent).inventory[RES.FOOD]

########NEW FILE########
__FILENAME__ = test_fire
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from horizons.constants import RES, BUILDINGS
from horizons.command.building import Build, Tear
from horizons.component.storagecomponent import StorageComponent

from tests.game import game_test


# FIXTURE is settlement with some food, main square and ~8 settlers
# a lumberjack is placed somewhere, where a fire station would be useful

@game_test(use_fixture='fire')
def test_fire_destroy(s):
	"""
	Check if a fire destroys all settlers
	"""
	dis_man = s.world.disaster_manager
	settlement = s.world.player.settlements[0]

	# need this so that fires can break out
	s.world.player.settler_level = 1

	assert settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ]
	old_num = len(settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ])

	while not dis_man._active_disaster:
		dis_man.run() # try to seed until we have a fire

	# wait until fire is over
	while dis_man._active_disaster:
		s.run()

	# it's not defined how bad a fire is, but some buildings should be destroyed in any case
	assert len(settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ]) < old_num


@game_test(use_fixture='fire')
def test_fire_station(s):
	"""
	Check if a fire station stops fires.
	"""
	dis_man = s.world.disaster_manager
	settlement = s.world.player.settlements[0]
	# need this so that fires can break out
	s.world.player.settler_level = 1

	inv = settlement.get_component(StorageComponent).inventory
	# res for fire station
	inv.alter(RES.BOARDS, 10)
	inv.alter(RES.TOOLS, 10)
	inv.alter(RES.BRICKS, 10)

	# second lj is the pos we need
	lj = settlement.buildings_by_id[ BUILDINGS.LUMBERJACK ][1]
	pos = lj.position.origin
	owner = lj.owner
	island = lj.island

	Tear(lj)(owner)
	assert Build(BUILDINGS.FIRE_STATION, pos.x, pos.y, island, settlement=settlement)(owner)

	assert settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ]
	old_num = len(settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ])

	for i in xrange(5): # 5 fires
		while not dis_man._active_disaster:
			dis_man.run() # try to seed until we have a fire

		# wait until fire is over
		while dis_man._active_disaster:
			s.run()

	# in this simple case, the fire station should be 100% effective
	assert len(settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ]) == old_num


@game_test(use_fixture='fire')
def test_upgrade_disallowed_with_fire(s):
	"""
	Check if a building can't upgrade with active fire.
	"""
	dis_man = s.world.disaster_manager
	settlement = s.world.player.settlements[0]

	# need this so that fires can break out
	s.world.player.settler_level = 1

	assert settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ]

	# Fullfil all needs to level up
	for settler in settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ]:
		happiness = s.db("SELECT value FROM balance_values WHERE name = 'happiness_level_up_requirement'")[0][0]
		settler.get_component(StorageComponent).inventory.alter(RES.HAPPINESS, happiness + 1)
		settler.inhabitants = settler.inhabitants_min

	# Now seed a fire
	while not dis_man._active_disaster:
		dis_man.run()

	assert dis_man._active_disaster[settlement]._affected_buildings, "No building is on fire!"
	assert not dis_man._active_disaster[settlement]._affected_buildings[0].can_level_up(), \
				"Buildings should not get upgraded when they are affected by a fire!"

########NEW FILE########
__FILENAME__ = test_load_save
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os
import bz2
import tempfile

from horizons.command.building import Build
from horizons.command.production import ToggleActive
from horizons.command.unit import CreateUnit
from horizons.constants import BUILDINGS, GAME, PRODUCTION, RES, TIER, UNITS
from horizons.util.shapes import Point
from horizons.util.worldobject import WorldObject
from horizons.world.production.producer import Producer
from horizons.component.collectingcomponent import CollectingComponent
from horizons.component.storagecomponent import StorageComponent
from horizons.world.units.collectors import Collector

from tests.game import (
	game_test, new_session, settle, load_session, saveload,
	TEST_FIXTURES_DIR,
)


@game_test(manual_session=True)
def test_load_inactive_production():
	"""
	create a savegame with a inactive production, load it
	"""
	session, player = new_session()
	settlement, island = settle(session)

	lj = Build(BUILDINGS.LUMBERJACK, 30, 30, island, settlement=settlement)(player)
	# Set lumberjack to inactive
	lj.get_component(Producer).set_active(active=False)
	worldid = lj.worldid

	session.run(seconds=1)

	# Save and reload game
	session = saveload(session)

	loadedlj = WorldObject.get_object_by_id(worldid)

	# Make sure it really is not active
	producer = loadedlj.get_component(Producer)
	assert not producer.is_active()

	# Trigger bug #1359
	ToggleActive(producer).execute(session)

	session.end()

def create_lumberjack_production_session():
	"""Create a saved game with a producing production and then load it."""
	session, player = new_session()
	settlement, island = settle(session)

	for x in [29, 30, 31, 32]:
		Build(BUILDINGS.TREE, x, 29, island, settlement=settlement,)(player)
	building = Build(BUILDINGS.LUMBERJACK, 30, 30, island, settlement=settlement)(player)
	production = building.get_component(Producer).get_productions()[0]

	# wait for the lumberjack to start producing
	while True:
		if production.get_state() is PRODUCTION.STATES.producing:
			break
		session.run(ticks=1)

	# Save and reload game
	session = saveload(session)
	return session


@game_test(manual_session=True)
def test_load_producing_production_fast():
	"""Create a saved game with a producing production, load it, and try to save again very fast."""
	session = create_lumberjack_production_session()
	session.run(ticks=2)

	# trigger #1395
	fd2, filename2 = tempfile.mkstemp()
	os.close(fd2)
	assert session.save(savegamename=filename2)
	session.end()


@game_test(manual_session=True)
def test_load_producing_production_slow():
	"""Create a saved game with a producing production, load it, and try to save again in a few seconds."""
	session = create_lumberjack_production_session()
	session.run(ticks=100)

	# trigger #1394
	fd2, filename2 = tempfile.mkstemp()
	os.close(fd2)
	assert session.save(savegamename=filename2)
	session.end()


@game_test(manual_session=True)
def test_hunter_save_load():
	"""Save/loading hunter in different states"""
	session, player = new_session()
	settlement, island = settle(session)

	# setup hunter, trees (to keep animals close) and animals

	hunter = Build(BUILDINGS.HUNTER, 30, 30, island, settlement=settlement)(player)
	hunter_worldid = hunter.worldid
	del hunter # invalid after save/load

	for x in xrange(27, 29):
		for y in xrange(25, 28):
			assert Build(BUILDINGS.TREE, x, y, island, settlement=settlement)(player)

	CreateUnit(island.worldid, UNITS.WILD_ANIMAL, 27, 27)(issuer=None)
	CreateUnit(island.worldid, UNITS.WILD_ANIMAL, 28, 27)(issuer=None)
	CreateUnit(island.worldid, UNITS.WILD_ANIMAL, 29, 27)(issuer=None)

	def get_hunter_collector(session):
		hunter = WorldObject.get_object_by_id(hunter_worldid)
		return hunter.get_component(CollectingComponent)._CollectingComponent__collectors[0]

	def await_transition(session, collector, old_state, new_state):
		assert collector.state == old_state, "expected old state %s, got %s" % (old_state, collector.state)
		while collector.state == old_state:
			session.run(seconds=1)
		assert collector.state == new_state, "expected new state %s, got %s" % (old_state, collector.state)


	sequence = [
	  Collector.states.idle,
	  Collector.states.waiting_for_animal_to_stop,
	  Collector.states.moving_to_target,
	  Collector.states.working,
	  Collector.states.moving_home,
	  Collector.states.idle
	  ]

	# do full run without saveload
	collector = get_hunter_collector(session)
	for i in xrange(len(sequence)-1):
		await_transition(session, collector, sequence[i], sequence[i+1])

	# do full run with saveload
	for i in xrange(len(sequence)-1):
		collector = get_hunter_collector(session)
		await_transition(session, collector, sequence[i], sequence[i+1])
		session = saveload(session)

	# last state reached successfully 2 times -> finished
	session.end()


@game_test(manual_session=True)
def test_settler_save_load():
	"""Save/loading """
	session, player = new_session()
	settlement, island = settle(session)

	# setup:
	# 1) build settler
	# 2) save/load
	# 3) build main square
	# -> settler won't load properly and not use the resources and die

	settler = Build(BUILDINGS.RESIDENTIAL, 25, 22, island, settlement=settlement)(player)
	assert settler

	main_square = Build(BUILDINGS.MAIN_SQUARE, 23, 24, island, settlement=settlement)(player)
	assert main_square
	main_square.get_component(StorageComponent).inventory.alter(RES.FOOD, 100)

	session = saveload(session)

	session.run(seconds=500)

	tile = session.world.get_tile(Point(25, 22))

	# tile will contain ruin in case of failure
	assert tile.object.id == BUILDINGS.RESIDENTIAL
	session.end()


@game_test(manual_session=True)
def test_savegame_upgrade():
	"""Loads an old savegame and keeps it running for a while"""
	fd, filename = tempfile.mkstemp()
	os.close(fd)

	path = os.path.join(TEST_FIXTURES_DIR, 'large.sqlite.bz2')
	compressed_data = open(path, "rb").read()
	data = bz2.decompress(compressed_data)
	f = open(filename, "wb")
	f.write(data)
	f.close()

	# check if loading and running fails
	session = load_session(filename)
	session.run(seconds=30)
	session.end(keep_map=True)


@game_test()
def test_settler_level_save_load(s, p):
	"""
	Verify that settler level up with save/load works
	"""
	# test all available upgrades: 0->1, 1->2, 2->3...
	for test_level in xrange(TIER.CURRENT_MAX):
		session, player = new_session()
		settlement, island = settle(s)

		settler = Build(BUILDINGS.RESIDENTIAL, 22, 22, island, settlement=settlement)(p)
		settler.level += test_level
		settler_worldid = settler.worldid

		# make it happy
		inv = settler.get_component(StorageComponent).inventory
		to_give = inv.get_free_space_for(RES.HAPPINESS)
		inv.alter(RES.HAPPINESS, to_give)
		level = settler.level

		# wait for it to realize it's supposed to upgrade
		s.run(seconds=GAME.INGAME_TICK_INTERVAL)

		session = saveload(session)
		settler = WorldObject.get_object_by_id(settler_worldid)
		inv = settler.get_component(StorageComponent).inventory

		# continue
		s.run(seconds=GAME.INGAME_TICK_INTERVAL)

		assert settler.level == level
		# give upgrade res
		inv.alter(RES.BOARDS, 100)
		inv.alter(RES.BRICKS, 100)

		# give it max population
		settler.inhabitants = settler.inhabitants_max

		s.run(seconds=GAME.INGAME_TICK_INTERVAL)

		# should have leveled up
		assert settler.level == level + 1

########NEW FILE########
__FILENAME__ = test_production
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.command.building import Build
from horizons.component.storagecomponent import StorageComponent
from horizons.world.production.producer import Producer
from horizons.constants import BUILDINGS, RES, PRODUCTIONLINES, PRODUCTION

from tests.game import settle, game_test

@game_test()
def test_basic_wood_production(session, player):
	"""This is a fairly detailed test of the simple wood production"""

	settlement, island = settle(session)

	lj = Build(BUILDINGS.LUMBERJACK, 30, 30, island, settlement=settlement)(player)
	assert lj.id == BUILDINGS.LUMBERJACK

	storage = lj.get_component(StorageComponent)
	assert isinstance(storage, StorageComponent)

	producer = lj.get_component(Producer)
	assert isinstance(producer, Producer)


	# Make sure wood production is added
	assert PRODUCTIONLINES.TREES in producer.get_production_lines()
	assert producer.has_production_line(PRODUCTIONLINES.TREES)
	production = producer._get_production(PRODUCTIONLINES.TREES)

	# Check if the production finished listener is called
	production_finished = [False]
	production.add_production_finished_listener(lambda _: production_finished.__setitem__(0, True))

	assert producer.is_active()

	# No res yet, waiting...
	assert producer._get_current_state() == PRODUCTION.STATES.waiting_for_res

	# Got res, producing
	storage.inventory.alter(RES.TREES, 2)
	assert producer._get_current_state() == PRODUCTION.STATES.producing

	# Work half-way
	session.run(seconds=3)

	#  Pause
	producer.toggle_active()
	assert not producer.is_active()
	assert producer._get_current_state() == PRODUCTION.STATES.paused

	# Unpause
	producer.toggle_active()
	assert producer.is_active()
	assert producer._get_current_state() == PRODUCTION.STATES.producing

	# Finish work partly
	session.run(seconds=2)

	assert producer._get_current_state() == PRODUCTION.STATES.producing
	assert storage.inventory[RES.BOARDS] == 0
	# Callback should not yet have been called
	assert not production_finished[0]

	# Finish work
	session.run(seconds=10)

	# out of res again, waiting for res
	assert producer._get_current_state() == PRODUCTION.STATES.waiting_for_res

	# Produced one board
	assert storage.inventory[RES.BOARDS] == 1
	# Callback should have been called now
	assert production_finished[0]

	# Fillup storage
	storage.inventory.alter(RES.BOARDS, storage.inventory.get_limit(RES.BOARDS))

	# Cannot produce because inventory full
	assert producer._get_current_state() == PRODUCTION.STATES.inventory_full

	# Empty inventory, wait again
	storage.inventory.alter(RES.BOARDS, -storage.inventory.get_limit(RES.BOARDS))
	assert producer._get_current_state() == PRODUCTION.STATES.waiting_for_res

########NEW FILE########
__FILENAME__ = test_remove_buildings
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import random
import sys
from itertools import product

from horizons.command.building import Build, Tear
from horizons.command.unit import CreateUnit
from horizons.constants import BUILDINGS, UNITS
from horizons.util.shapes import Point
from horizons.world.production.producer import Producer
from horizons.component.storagecomponent import StorageComponent
from horizons.util.pathfinding.roadpathfinder import RoadPathFinder

from tests.game import settle, game_test, RANDOM_SEED


def test_removal():
	rng = random.Random(RANDOM_SEED)
	for i in range(10):
		yield remove, rng.randint(1, 200), rng.randint(1, 200), rng.randint(0, 8)


@game_test()
def remove(s, p, before_ticks, after_ticks, tear_index):
	"""
	Place a couple of buildings and tear down one randomly, run a while afterwards.
	Called by test_removal with different parameters.
	"""
	settlement, island = settle(s)
	settlement.warehouse.get_component(StorageComponent).inventory.adjust_limit(sys.maxint)

	# Plant trees
	for (x, y) in product(range(23, 38), repeat=2):
		if s.random.randint(0, 1) == 1:
			tree = Build(BUILDINGS.TREE, x, y, island, settlement=settlement)(p)
			assert tree
			tree.get_component(Producer).finish_production_now()

	jack = Build(BUILDINGS.LUMBERJACK, 25, 30, island, settlement=settlement)(p)
	assert jack
	jack = Build(BUILDINGS.LUMBERJACK, 35, 30, island, settlement=settlement)(p)
	assert jack

	# Throw some fish into the water
	for x in (25, 30, 35):
		school = Build(BUILDINGS.FISH_DEPOSIT, x, 18, s.world, ownerless=True)(None)
		assert school
		school.get_component(Producer).finish_production_now()

	fisherman = Build(BUILDINGS.FISHER, 25, 20, island, settlement=settlement)(p)
	assert fisherman
	fisherman = Build(BUILDINGS.FISHER, 35, 20, island, settlement=settlement)(p)
	assert fisherman

	# Some wild animals in the forest
	for (x_off, y_off) in product([-5, -4, 4, 5], repeat=2):
		x = 30 + x_off
		y = 30 + y_off
		animal = CreateUnit(island.worldid, UNITS.WILD_ANIMAL, x, y)(None)
		assert animal
		animal.get_component(Producer).finish_production_now()

	hunter = Build(BUILDINGS.HUNTER, 30, 35, island, settlement=settlement)(p)
	assert hunter

	# Build a farm
	assert Build(BUILDINGS.FARM, 26, 33, island, settlement=settlement)(p)
	assert Build(BUILDINGS.PASTURE, 22, 33, island, settlement=settlement)(p)
	assert Build(BUILDINGS.PASTURE, 26, 37, island, settlement=settlement)(p)

	# Build roads
	for (start, dest) in [(Point(27, 30), Point(30, 23)), (Point(32, 23), Point(35, 29)),
						  (Point(25, 22), Point(30, 23)), (Point(32, 23), Point(35, 22)),
						  (Point(30, 34), Point(32, 25)), (Point(26, 32), Point(27, 30))]:
		path = RoadPathFinder()(island.path_nodes.nodes, start.to_tuple(), dest.to_tuple())
		assert path
		for (x, y) in path:
			Build(BUILDINGS.TRAIL, x, y, island, settlement=settlement)(p)

	s.run(seconds=before_ticks)
	# Tear down a random building that is not a trail or tree.
	target = [b for b in settlement.buildings if b.id not in (BUILDINGS.TRAIL, BUILDINGS.TREE)][tear_index]
	Tear(target)(p)
	s.run(seconds=after_ticks)

########NEW FILE########
__FILENAME__ = test_savegame_upgrade
# ###################################################
# Copyright (C) 2013 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.game import game_test

# FIXTURE is a savegame revision 49
@game_test(use_fixture='savegame-rev-49')
def test_upgrade(s):
	"""
	Simply let's do nothing except loading the fixture
	"""
	pass



########NEW FILE########
__FILENAME__ = test_settlement_range
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from horizons.constants import RES, BUILDINGS
from horizons.command.building import Build, Tear

from tests.game import game_test
		
# FIXTURE is settlement with a lookout, some tents and some trees
@game_test(use_fixture='settlement-range')
def test_settlement_decrease(s):
	"""
	Check if destroying a lookout destroys surrounding buildings but not trees.
	"""
	settlement = s.world.player.settlements[0]
	lo = settlement.buildings_by_id[ BUILDINGS.LOOKOUT ][0]
	pos = lo.position.origin
	owner = lo.owner
	island = lo.island

	starting_tents = settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ]
	old_tents = len(starting_tents)

	old_trees_owned = len(settlement.buildings_by_id[ BUILDINGS.TREE ])
	old_trees = island.num_trees

	Tear(lo)(owner)

	cur_tents = settlement.buildings_by_id[ BUILDINGS.RESIDENTIAL ]
	new_tents = len(cur_tents)

	new_trees_owned = len(settlement.buildings_by_id[ BUILDINGS.TREE ])
	new_trees = island.num_trees

	assert new_trees == old_trees
	assert old_trees_owned > new_trees_owned
	assert new_tents < old_tents

########NEW FILE########
__FILENAME__ = test_settler
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.command.building import Build
from horizons.constants import BUILDINGS, RES, GAME, TIER
from horizons.component.storagecomponent import StorageComponent
from horizons.command.uioptions import SetSettlementUpgradePermissions

from tests.game import game_test, settle

@game_test()
def test_settler_level(s, p):
	"""
	Verify that settler level up works.
	"""
	settlement, island = settle(s)

	settler = Build(BUILDINGS.RESIDENTIAL, 22, 22, island, settlement=settlement)(p)

	# make it happy
	inv = settler.get_component(StorageComponent).inventory
	to_give = inv.get_free_space_for(RES.HAPPINESS)
	inv.alter(RES.HAPPINESS, to_give)
	level = settler.level

	s.run(seconds=GAME.INGAME_TICK_INTERVAL)

	# give upgrade res
	inv.alter(RES.BOARDS, 100)

	s.run(seconds=GAME.INGAME_TICK_INTERVAL)

	# should have leveled up
	assert settler.level == level + 1

@game_test()
def test_deny_upgrade_permissions_special(s, p):
	"""
	Verify that denying upgrade permissions works even though the settler
	leveled down after starting the upgrade process.
	"""
	settlement, island = settle(s)

	settler = Build(BUILDINGS.RESIDENTIAL, 22, 22, island, settlement=settlement)(p)

	# make it happy
	inv = settler.get_component(StorageComponent).inventory
	to_give = inv.get_free_space_for(RES.HAPPINESS)
	inv.alter(RES.HAPPINESS, to_give)

	s.run(seconds=GAME.INGAME_TICK_INTERVAL)

	# give upgrade res
	inv.alter(RES.BOARDS, 100)

	s.run(seconds=GAME.INGAME_TICK_INTERVAL)

	# should have leveled up
	assert settler.level == TIER.PIONEERS
	assert settler._upgrade_production is None

	# Start leveling up again
	settler._add_upgrade_production_line()
	assert settler._upgrade_production is not None

	s.run(seconds=1)

	# Force the settler to level down, even though it is currently
	# trying to upgrade
	settler.level_down()

	# Make sure this worked!
	assert settler._upgrade_production is None

	# Make sure forbidding upgrades works
	SetSettlementUpgradePermissions(settlement, TIER.SAILORS, False).execute(s)
	assert settler.level == TIER.SAILORS

########NEW FILE########
__FILENAME__ = test_status_icons
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.command.building import Build
from horizons.command.production import ToggleActive
from horizons.world.production.producer import Producer
from horizons.component.storagecomponent import StorageComponent
from horizons.constants import BUILDINGS, RES
from horizons.world.status import SettlerUnhappyStatus, DecommissionedStatus, ProductivityLowStatus, InventoryFullStatus
from horizons.messaging import AddStatusIcon

import mock
from tests.game import settle, game_test

def assert_called_with_icon(cb, icon):
	assert cb.called
	# the first and only parameter is the message send
	assert cb.call_args[0][0].icon.__class__ == icon


@game_test()
def test_productivity_low(session, player):
	settlement, island = settle(session)

	Build(BUILDINGS.CHARCOAL_BURNER, 30, 30, island, settlement=settlement)(player)

	cb = mock.Mock()
	AddStatusIcon.subscribe(cb)

	# Not yet low
	assert not cb.called

	session.run(seconds=60)

	# Now low
	assert_called_with_icon(cb, ProductivityLowStatus)

@game_test()
def test_settler_unhappy(session, player):
	settlement, island = settle(session)

	cb = mock.Mock()
	AddStatusIcon.subscribe(cb)

	settler = Build(BUILDINGS.RESIDENTIAL, 30, 30, island, settlement=settlement)(player)

	# certainly not unhappy
	assert settler.happiness > 0.45
	assert not cb.called

	# make it unhappy
	settler.get_component(StorageComponent).inventory.alter(RES.HAPPINESS, -settler.happiness)
	assert settler.happiness < 0.1
	assert_called_with_icon(cb, SettlerUnhappyStatus)


@game_test()
def test_decommissioned(session, player):
	settlement, island = settle(session)

	lj = Build(BUILDINGS.LUMBERJACK, 30, 30, island, settlement=settlement)(player)

	cb = mock.Mock()
	AddStatusIcon.subscribe(cb)

	assert not cb.called

	ToggleActive(lj.get_component(Producer))(player)

	assert_called_with_icon(cb, DecommissionedStatus)

@game_test()
def test_inventory_full(session, player):
	settlement, island = settle(session)

	lj = Build(BUILDINGS.LUMBERJACK, 30, 30, island, settlement=settlement)(player)

	cb = mock.Mock()
	AddStatusIcon.subscribe(cb)

	# Not full
	assert not cb.called

	inv = lj.get_component(StorageComponent).inventory
	res = RES.BOARDS
	inv.alter(res, inv.get_free_space_for( res ) )

	session.run(seconds=1)

	# Full
	assert_called_with_icon(cb, InventoryFullStatus)

########NEW FILE########
__FILENAME__ = test_traderoute
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from horizons.component.namedcomponent import NamedComponent
from horizons.component.storagecomponent import StorageComponent
from horizons.constants import RES

from tests.game import game_test


@game_test(use_fixture='traderoute')
def test_traderoute_basic(s):
	"""
	Check if traderoutes do anything.
	"""
	settlements = s.world.player.settlements
	assert len(settlements) == 2

	# 2 settlements, one produces food, the other one boards
	# a traderoute is there to exchange the res

	has_food = settlements[0] if 'food' in settlements[0].get_component(NamedComponent).name else settlements[1]
	has_wood = settlements[0] if settlements[0] != has_food else settlements[1]

	food_inv = has_food.get_component(StorageComponent).inventory
	wood_inv = has_wood.get_component(StorageComponent).inventory

	assert food_inv[RES.FOOD] > 0
	assert wood_inv[RES.BOARDS] > 0

	while food_inv[RES.BOARDS] == 0: # first ensure wood to food
		s.run()
	while wood_inv[RES.FOOD] == 0: # traderoute also goes other way around
		s.run()

	while food_inv.get_free_space_for(RES.BOARDS) > 0: # also fill up
		s.run()
	while wood_inv.get_free_space_for(RES.FOOD) > 0: # also fill up
		s.run()

	# when the whiles pass, it is ensured that traderoutes somewhat work

########NEW FILE########
__FILENAME__ = utils
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

"""Some helper functions to use in game tests.
Do not import from here, import directly from tests.game.
"""

import os
import tempfile

from horizons.command.building import Build
from horizons.command.unit import CreateUnit
from horizons.constants import GROUND, BUILDINGS, UNITS, RES
from horizons.util.dbreader import DbReader
from horizons.util.shapes import Point, Rect
from horizons.component.storagecomponent import StorageComponent


def create_map():
	"""
	Create a map with a square island (20x20) at position (20, 20) and return the path
	to the database file.
	"""

	tiles = []
	for x, y in Rect.init_from_topleft_and_size(0, 0, 20, 20).tuple_iter():
		if (0 < x < 20) and (0 < y < 20):
			ground = GROUND.DEFAULT_LAND
		else:
			# Add coastline at the borders.
			ground = GROUND.SHALLOW_WATER
		tiles.append([0, 20 + x, 20 + y] + list(ground))

	fd, map_file = tempfile.mkstemp()
	os.close(fd)

	db = DbReader(map_file)
	with open('content/map-template.sql') as map_template:
		db.execute_script(map_template.read())

	db('BEGIN')
	db.execute_many("INSERT INTO ground VALUES(?, ?, ?, ?, ?, ?)", tiles)
	db('COMMIT')
	db.close()
	return map_file


def new_settlement(session, pos=Point(30, 20)):
	"""
	Creates a settlement at the given position. It returns the settlement and the island
	where it was created on, to avoid making function-baed tests too verbose.
	"""
	island = session.world.get_island(pos)
	assert island, "No island found at %s" % pos
	player = session.world.player

	ship = CreateUnit(player.worldid, UNITS.PLAYER_SHIP, pos.x, pos.y)(player)
	for res, amount in session.db("SELECT resource, amount FROM start_resources"):
		ship.get_component(StorageComponent).inventory.alter(res, amount)

	building = Build(BUILDINGS.WAREHOUSE, pos.x, pos.y, island, ship=ship)(player)
	assert building, "Could not build warehouse at %s" % pos

	return (building.settlement, island)


def settle(s):
	"""
	Create a new settlement, start with some resources.
	"""
	settlement, island = new_settlement(s)
	settlement.get_component(StorageComponent).inventory.alter(RES.GOLD, 5000)
	settlement.get_component(StorageComponent).inventory.alter(RES.BOARDS, 50)
	settlement.get_component(StorageComponent).inventory.alter(RES.TOOLS, 50)
	settlement.get_component(StorageComponent).inventory.alter(RES.BRICKS, 50)
	return settlement, island

########NEW FILE########
__FILENAME__ = cooperative
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import sys
from collections import deque

try:
	import greenlet
except ImportError:
	print 'The greenlet package is needed to run the UH gui tests.'
	sys.exit(1)


_scheduled = deque()
_current = greenlet.getcurrent()


class Tasklet(greenlet.greenlet):
	"""Wrapper around greenlet.

	Let's you add callbacks when the greenlet finished and wait for it to finish.
	"""
	def __init__(self, *args, **kwargs):
		super(Tasklet, self).__init__(*args, **kwargs)
		self.links = []

	def link(self, func):
		"""Call func once this greenlet finished execution."""
		self.links.append(func)

	def join(self):
		"""Blocks until this greenlet finished execution."""

		# little hack because we don't have Python3's nonlocal
		class Flag(object):
			running = True

		def stop(_):
			Flag.running = False

		self.link(stop)

		while Flag.running:
			schedule()


def spawn(func, *args, **kwargs):
	"""Schedule a new function to run."""
	g = Tasklet(func)
	_scheduled.append((g, args, kwargs))
	return g


def schedule():
	global _scheduled
	global _current

	if not _current.dead:
		_scheduled.append((_current, [], {}))
	else:
		[l(_current) for l in _current.links]

	while _scheduled:
		g, args, kwargs = _scheduled.popleft()

		_current = g
		g.switch(*args, **kwargs)
		break

########NEW FILE########
__FILENAME__ = helper
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

"""
Cleaner interface to various game/gui functions to make tests easier.
"""

import contextlib
import os
import tempfile
import types
from collections import deque

import mock
from fife import fife
from fife.extensions import pychan

import horizons.main
from horizons.constants import GAME_SPEED
from horizons.extscheduler import ExtScheduler
from horizons.gui.mousetools.navigationtool import NavigationTool
from horizons.gui.mousetools.buildingtool import BuildingTool
from horizons.gui.mousetools.cursortool import CursorTool
from horizons.scheduler import Scheduler
from horizons.util.shapes import Point
from horizons.util.startgameoptions import StartGameOptions

from tests.gui import cooperative


def get_player_ship(session):
	"""Returns the first ship of a player."""
	for ship in session.world.ships:
		if ship.owner == session.world.player:
			return ship
	raise Exception('Player ship not found')


def move_ship(gui, ship, (x, y)):
	"""Move ship to coordinates and wait until it arrives."""
	gui.cursor_click(x, y, 'right')

	while (ship.position.x, ship.position.y) != (x, y):
		cooperative.schedule()


def found_settlement(gui, ship_pos, (x, y)):
	"""Move ship to coordinates and build a warehouse."""
	ship = get_player_ship(gui.session)
	gui.select([ship])
	move_ship(gui, ship, ship_pos)

	# Found a settlement
	gui.trigger('overview_trade_ship', 'found_settlement')
	assert isinstance(gui.cursor, BuildingTool)
	gui.cursor_click(x, y, 'left')
	assert isinstance(gui.cursor, CursorTool)


def saveload(gui):
	"""Save and load the game (gui test version). Use like this:

	# For gui tests
	saveload(gui)
	"""
	fd, filename = tempfile.mkstemp()
	os.close(fd)
	assert gui.session.save(savegamename=filename)
	options = StartGameOptions.create_load_game(filename, None)
	# This hands out a new session, but `gui.session` is a property.
	horizons.main.start_singleplayer(options)
	# Restore some properties that were changed for tests:
	# Set game speed to maximum, and disable autoscroll.
	gui.setup()


class CursorToolsPatch(object):
	"""Temporarly changes CursorTool to interpret mouse event coordinates
	as map coordinates instead of window coordinates. Makes it easier to
	write tests.

	Example:
		gui.cursor_map_coords.enable()
		gui.cursor_move(2, 3)
		gui.cursor_map_coords.disable()
	"""
	def __init__(self):
		def patched_world_location_from_event(self, evt):
			"""Typically we expect a Mock MouseEvent, genereated by `_make_mouse_event`.

			However NavigationTool keeps track of the last event position, which is
			an instance of fife.ScreenPoint.
			"""
			try:
				# fife.MouseEvent
				x = evt.getX()
				y = evt.getY()
			except AttributeError:
				# fife.ScreenPoint
				x = evt.x
				y = evt.y

			return Point(x, y)

		self.patch1 = mock.patch('horizons.gui.mousetools.CursorTool.get_world_location', patched_world_location_from_event)
		self.patch2 = mock.patch('horizons.gui.mousetools.CursorTool.get_exact_world_location', patched_world_location_from_event)
		self.patch3 = mock.patch('horizons.gui.mousetools.TileLayingTool.get_world_location', patched_world_location_from_event)

		NavigationTool._orig_get_hover_instances = NavigationTool.get_hover_instances

	def enable(self):
		self.patch1.start()
		self.patch2.start()
		self.patch3.start()

		# this makes selecting buildings by clicking on them possible. without this, get_hover_instances receives an event with map
		# coordinates, and will not find the correct building (if any). to fix this, we're converting the coordinates back to screen space
		# and can avoid changing any other code
		def deco(func):
			def wrapped(self, evt, *args, **kwargs):
				screen_point = self.session.view.cam.toScreenCoordinates(fife.ExactModelCoordinate(evt.getX(), evt.getY()))
				evt = mock.Mock()
				evt.getX.return_value = screen_point.x
				evt.getY.return_value = screen_point.y
				return func(self, evt, *args, **kwargs)
			return wrapped
		NavigationTool.get_hover_instances = deco(NavigationTool.get_hover_instances)

	def disable(self):
		self.patch1.stop()
		self.patch2.stop()
		self.patch3.stop()

		NavigationTool.get_hover_instances = NavigationTool._orig_get_hover_instances


class GuiHelper(object):

	Key = fife.Key

	def __init__(self, pychan, runner):
		self._pychan = pychan
		self._manager = self._pychan.manager
		self._runner = runner
		self.follow_mouse = True
		# patch for using map coords with CursorTools is enabled by default
		self.cursor_map_coords = CursorToolsPatch()
		self.cursor_map_coords.enable()
		self.setup()

	def setup(self):
		self.disable_autoscroll()
		self.speed_up()

	@property
	def session(self):
		return horizons.main._modules.session

	@property
	def cursor(self):
		return self.session.ingame_gui.cursor

	@property
	def active_widgets(self):
		"""Active widgets are the top level containers currently
		known by pychan.
		"""
		return self._manager.allWidgets.keys()

	def _get_children(self, w):
		if hasattr(w, 'children'):
			return w.children
		elif hasattr(w, 'findChildren'):
			return w.findChildren()

	def _find(self, name):
		"""Recursive find a widget by name.

		This is the actual search implementation behind `GuiHelper.find`.
		"""
		match = None
		seen = set()
		widgets = deque(self.active_widgets)

		path_components = list(reversed(name.split('/')))

		while path_components:
			name = path_components.pop()

			while widgets:
				w = widgets.popleft()
				seen.add(w)
				if w.name == name:
					# When there are still names left in the path, continue our search
					# in the children of the matched widget
					if path_components:
						widgets = deque([x for x in self._get_children(w) if x not in seen])
						break
					else:
						# We're done!
						match = w
						break
				else:
					widgets.extend([x for x in self._get_children(w) if x not in seen])

			if match:
				break

		return match

	def find(self, name):
		"""Find a widget by name.

		`name` can consist of multiple widget names separated by a slash. In this
		case, this is interpreted as a path to the widget with the last name.
		This is necessary when multiple widgets exist with the same name.

		Example:

			gui.find('menu/button')
			# look for a widget 'menu' with a descendant named 'button'

		Recursively searches through all widgets. Some widgets will be extended
		with helper functions to allow easier interaction in tests.
		"""
		match = self._find(name)

		gui_helper = self

		if isinstance(match, pychan.widgets.ListBox):
			def select(self, value):
				"""Change selection in listbox to value.

				Example:

				    w = gui.find('list_widget')
				    w.select('A')
				"""
				index = self.items.index(value)
				self.selected = index
				# trigger callbacks for selection change
				gui_helper._trigger_widget_callback(self, can_fail=True)

			match.select = types.MethodType(select, match, match.__class__)
		elif isinstance(match, pychan.widgets.TextField):
			def write(self, text):
				"""Change text inside a textfield."""
				self.text = unicode(text)
				return self # return self to allow chaining

			def enter(self):
				"""Trigger callback as if ENTER was pressed."""
				gui_helper._trigger_widget_callback(self, can_fail=True)

			match.write = types.MethodType(write, match, match.__class__)
			match.enter = types.MethodType(enter, match, match.__class__)
		elif isinstance(match, pychan.widgets.Slider):
			def slide(self, value):
				"""Set the slider to this value and trigger callbacks."""
				self.value = float(value)

				# try two possible event group names
				# TODO find out why some sliders use 'stepslider' and others 'default'
				if not gui_helper._trigger_widget_callback(self, can_fail=True):
					gui_helper._trigger_widget_callback(self, group_name="stepslider", can_fail=True)

			match.slide = types.MethodType(slide, match, match.__class__)

		return match

	def trigger(self, root, event, mouse=None):
		"""Trigger a widget event in a container.

		root  - container (object, name or path) that holds the widget.
				For more information on path, see `GuiHelper.find`.
		event - string describing the event (widget/event/group)
		        event and group are optional
		mouse - Optional. Can be 'left' or 'right'. Some event callbacks look
				at the event that occured, so we need to tell what mouse
				button triggered this.

		Example:
			c = gui.find('mainmenu')
			gui.trigger(c, 'okButton/action/default')

		Equivalent to:
			gui.trigger('mainmenu', 'okButton/action/default')
		"""
		group_name = 'default'
		event_name = 'action'

		parts = event.split('/')
		if len(parts) == 3:
			widget_name, event_name, group_name = parts
		elif len(parts) == 2:
			widget_name, event_name = parts
		else:
			widget_name, = parts

		# if container is given by name, look it up first
		if isinstance(root, basestring):
			root_name = root
			root = self.find(name=root_name)
			if not root:
				raise Exception("Container '%s' not found" % root_name)

		widget = root.findChild(name=widget_name)
		if not widget:
			raise Exception("'%s' contains no widget with the name '%s'" % (
								root.name, widget_name))

		self._trigger_widget_callback(widget, event_name, group_name, mouse=mouse)

	def _trigger_widget_callback(self, widget, event_name="action", group_name="default", can_fail=False, mouse=None):
		"""Call callbacks for the given widget."""
		# Check if this widget has any event callbacks at all
		try:
			callbacks = widget.event_mapper.callbacks[group_name]
		except KeyError:
			if can_fail:
				return False
			raise Exception("No callbacks for event group '%s' for event '%s'" % (
							group_name, widget.name))

		# Unusual events are handled normally
		if event_name not in ('action', 'mouseClicked'):
			try:
				callback = callbacks[event_name]
			except KeyError:
				raise Exception("No callback for event '%s/%s' registered for widget '%s'" % (
								event_name, group_name, widget.name))
		# Treat action and mouseClicked as the same event. If a callback is not registered
		# for one, try the other
		else:
			callback = callbacks.get(event_name)
			if not callback:
				callback = callbacks.get(event_name == 'action' and 'mouseClicked' or 'action')

			if not callback:
				raise Exception("No callback for event 'action' or 'mouseClicked' registered for widget '%s'" % (
								group_name, widget.name))

		kwargs = {'widget': widget}
		if mouse:
			kwargs['event'] = self._make_mouse_event(0, 0, button=mouse)

		pychan.tools.applyOnlySuitable(callback, **kwargs)

	@contextlib.contextmanager
	def handler(self, func):
		"""Temporarily install another gui handler, e.g. to handle a dialog."""
		g = cooperative.spawn(func)
		yield
		g.join()

	def select(self, objects):
		"""Select all objects in the given list.

		Note, this is not the same process as selection with a mouse. For example
		selecting a ship will not result in the display of its healthbar, but the
		corresponding tab will be shown.
		"""
		self.session.selected_instances = set(objects)
		self.cursor.apply_select()

	def press_key(self, keycode, shift=False, ctrl=False):
		"""Simulate a global keypress.

		Example:
			gui.press_key(gui.Key.F4)
			gui.press_key(gui.Key.F4, ctrl=True)
		"""
		evt = mock.Mock()
		evt.isConsumed.return_value = False
		evt.getKey.return_value = self.Key(keycode)
		evt.isControlPressed.return_value = ctrl
		evt.isShiftPressed.return_value = shift

		if self.session:
			keylistener = self.session.ingame_gui.keylistener
		else:
			keylistener = horizons.main._modules.gui.mainlistener

		keylistener.keyPressed(evt)
		keylistener.keyReleased(evt)

	def cursor_move(self, x, y):
		self.cursor.mouseMoved(self._make_mouse_event(x, y))
		if self.follow_mouse:
			self.session.view.center(x, y)

	def cursor_press_button(self, x, y, button, shift=False, ctrl=False):
		self.cursor.mousePressed(self._make_mouse_event(x, y, button, shift, ctrl))

	def cursor_release_button(self, x, y, button, shift=False, ctrl=False):
		self.cursor.mouseReleased(self._make_mouse_event(x, y, button, shift, ctrl))

	def cursor_click(self, x, y, button, shift=False, ctrl=False):
		# NOTE `self.run()` is a fix for gui tests with fife rev 4060+
		# it is not known why this helps, but perhaps it's not that unreasonable
		# to give the engine some time in between events (even if we trigger the
		# mousetools directly)

		self.cursor_move(x, y)
		self.run()
		self.cursor_press_button(x, y, button, shift, ctrl)
		self.run()
		self.cursor_release_button(x, y, button, shift, ctrl)

	def cursor_multi_click(self, *coords):
		"""Do multiple clicks in succession.

		Shift is hold to enable non-stop build and after the last coord it will be
		cancelled with a right click.
		"""
		for (x, y) in coords:
			self.cursor_click(x, y, 'left', shift=True)

		# Cancel
		x, y = coords[-1]
		self.cursor_click(x, y, 'right')

	def cursor_drag(self, (start_x, start_y), (end_x, end_y), button):
		"""Press mouse button, move the mouse, release button."""
		self.cursor_move(start_x, start_y)
		self.cursor_press_button(start_x, start_y, button)
		self.run()

		steps = max(abs(end_x - start_x), abs(end_y - start_y))
		x_step = (end_x - start_x) / float(steps)
		y_step = (end_y - start_y) / float(steps)

		for i in range(steps):
			x = int(start_x + i * x_step)
			y = int(start_y + i * y_step)
			self.cursor.mouseDragged(self._make_mouse_event(x, y, button))
			self.run()

		self.cursor_release_button(end_x, end_y, button)

	def _make_mouse_event(self, x, y, button=None, shift=False, ctrl=False):
		if button:
			button = {'left': fife.MouseEvent.LEFT,
					  'right': fife.MouseEvent.RIGHT}[button]

		evt = mock.Mock()
		evt.isConsumedByWidgets.return_value = False
		evt.getX.return_value = x
		evt.getY.return_value = y
		evt.getButton.return_value = button
		evt.isShiftPressed.return_value = shift
		evt.isControlPressed.return_value = ctrl

		return evt

	def run(self, seconds=0):
		"""Provide a nice way to run the game for some time.

		Despite its name, this method will run the *game simulation* for X seconds.
		When the game is paused, the timer continues once the game unpauses.
		"""

		if not seconds:
			cooperative.schedule()
		else:
			# little hack because we don't have Python3's nonlocal
			class Flag(object):
				running = True

			def stop():
				Flag.running = False

			# Scheduler only exists inside games, use ExtScheduler in the mainmenu
			if Scheduler():
				ticks = Scheduler().get_ticks(seconds)
				Scheduler().add_new_object(stop, None, run_in=ticks)
			else:
				ExtScheduler().add_new_object(stop, None, run_in=seconds)

			while Flag.running:
				cooperative.schedule()

	def disable_autoscroll(self):
		"""
		NavigationTool.mouseMoved is using the 'real' mouse position in the window to
		check if it is near the borders and initiates auto scroll. However, we are
		sending events with map coordinates, so a location at (0, 2) would trigger
		scrolling. Disable autoscroll by replacing view.autoscroll with a NOP.
		"""
		if hasattr(self.session, 'view'):
			# try to disable only if we're ingame already
			# Tests starting in the menu need to do call `disable_autoscroll()` explicitly
			self.session.view.autoscroll = mock.Mock()

	def speed_up(self):
		"""Run the test at maximum game speed."""
		if self.session:
			self.session.speed_set(GAME_SPEED.TICK_RATES[-1])

	def speed_default(self):
		"""Reset game to normal speed."""
		if self.session:
			self.session.speed_set(GAME_SPEED.TICKS_PER_SECOND)

	def debug(self):
		"""Call this to stop the test from running and be able to interact with game."""
		self.cursor_map_coords.disable()
		self.speed_default()
		self.run(2**20)

########NEW FILE########
__FILENAME__ = test_boatbuilder
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.constants import BUILDINGS, PRODUCTION, UNITS
from horizons.world.production.producer import Producer

from tests.gui import gui_test
from tests.gui.helper import saveload


@gui_test(use_fixture='boatbuilder', timeout=120)
def test_ticket_1224(gui):
	"""
	Boat builder running costs are inconsistent.
	"""

	settlement = gui.session.world.player.settlements[0]
	boatbuilder = settlement.buildings_by_id[BUILDINGS.BOAT_BUILDER][0]

	# Select boat builder
	gui.cursor_click(64, 10, 'left')

	def running_costs():
		c = gui.find(name='BB_main_tab')
		return c.findChild(name='running_costs').text

	# Check (inactive) running costs
	assert running_costs() == '10', "Expected 10, got %s" % running_costs()

	# Select trade ships tab
	gui.trigger('tab_base', '1')

	# Build huker
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Wait until production starts
	producer = boatbuilder.get_component(Producer)
	while producer._get_current_state() != PRODUCTION.STATES.producing:
		gui.run()

	# Check (active) running costs
	assert running_costs() == '25', "Expected 25, got %s" % running_costs()


@gui_test(use_fixture='boatbuilder', timeout=120)
def test_ticket_1294(gui):
	"""
	Boatbuilder crash with out of order finishing.
	"""

	settlement = gui.session.world.player.settlements[0]
	boatbuilder = settlement.buildings_by_id[BUILDINGS.BOAT_BUILDER][0]

	# Select boat builder
	gui.cursor_click(64, 10, 'left')

	# Select trade ships tab
	gui.trigger('tab_base', '1')

	# Build huker
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Pause huker construction
	gui.trigger('BB_main_tab', 'toggle_active_active')

	# Select war ships tab
	gui.trigger('tab_base', '2')

	# Build frigate
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Wait until production ends
	producer = boatbuilder.get_component(Producer)
	while len(producer.get_productions()) > 1:
		gui.run()

	# Unpause huker construction
	gui.trigger('BB_main_tab', 'toggle_active_inactive')

	while producer.get_productions():
		gui.run()


@gui_test(use_fixture='boatbuilder', timeout=120)
def test_ticket_1830(gui):
	"""
	Boatbuilder should not replace main production while it's paused.
	"""

	settlement = gui.session.world.player.settlements[0]
	boatbuilder = settlement.buildings_by_id[BUILDINGS.BOAT_BUILDER][0]
	producer = boatbuilder.get_component(Producer)

	# Select boat builder
	gui.cursor_click(64, 10, 'left')

	# Select trade ships tab
	gui.trigger('tab_base', '1')

	# Build huker
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Pause huker construction
	gui.trigger('BB_main_tab', 'toggle_active_active')

	# Select war ships tab
	gui.trigger('tab_base', '2')

	# Build frigate
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Check if Main-Production is still just Huker and is paused.
	assert len(producer.get_productions()) == 1
	assert producer.get_productions()[0].get_produced_units()[UNITS.HUKER_SHIP] == 1
	assert producer.get_productions()[0]._state == PRODUCTION.STATES.paused

	# One entry (Frigate) in queue
	assert len(producer.production_queue) == 1


@gui_test(use_fixture='boatbuilder', timeout=60)
def test_remove_from_queue(gui):
	"""
	Boatbuilder crashes when canceling a ship in the queue.
	"""

	# Select boat builder
	gui.cursor_click(64, 10, 'left')

	# Select trade ships tab
	gui.trigger('tab_base', '1')

	# Build huker
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Select war ships tab
	gui.trigger('tab_base', '2')

	# Build frigate
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Cancel queue -> crash
	gui.trigger('BB_main_tab', 'queue_elem_0')


@gui_test(use_fixture='boatbuilder', timeout=60)
def test_cancel_ticket_1424(gui):
	"""
	Boatbuilder crashes when canceling a ship build.
	"""

	# Select boat builder
	gui.cursor_click(64, 10, 'left')

	# Select trade ships tab
	gui.trigger('tab_base', '1')

	# Build huker
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Select war ships tab
	gui.trigger('tab_base', '2')

	# Build frigate
	gui.trigger('boatbuilder_showcase', 'ok_0')

	gui.run()

	# Cancel build completely -> crash
	gui.trigger('BB_main_tab', 'BB_cancel_button')


@gui_test(use_fixture='boatbuilder', timeout=60)
def test_save_load_ticket_1421(gui):
	"""
	Boatbuilder crashes when saving/loading while a ship is being produced.
	"""

	# Select boat builder
	gui.cursor_click(64, 10, 'left')

	# Select trade ships tab
	gui.trigger('tab_base', '1')

	# Build huker
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Select war ships tab
	gui.trigger('tab_base', '2')

	# Build frigate
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Save and reload game
	saveload(gui)


@gui_test(use_fixture='boatbuilder', timeout=120)
def test_ticket_1513(gui):
	"""
	Boat builder costs don't go back to normal after cancelling a ship.
	"""

	settlement = gui.session.world.player.settlements[0]
	boatbuilder = settlement.buildings_by_id[BUILDINGS.BOAT_BUILDER][0]

	# Select boat builder
	gui.cursor_click(64, 10, 'left')

	def running_costs():
		c = gui.find(name='BB_main_tab')
		return c.findChild(name='running_costs').text

	# Check (inactive) running costs
	assert running_costs() == '10', "Expected 10, got %s" % running_costs()

	# Select trade ships tab
	gui.trigger('tab_base', '1')

	# Build huker
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Wait until production starts
	producer = boatbuilder.get_component(Producer)
	while producer._get_current_state() != PRODUCTION.STATES.producing:
		gui.run()

	# Check (active) running costs
	assert running_costs() == '25', "Expected 25, got %s" % running_costs()

	gui.run()

	# Cancel build
	gui.trigger('BB_main_tab', 'BB_cancel_button')

	# Check (inactive) running costs
	assert running_costs() == '10', "Expected 10, got %s" % running_costs()


@gui_test(use_fixture='boatbuilder', timeout=120)
def test_ticket_1514(gui):
	"""
	Cancelling a ship doesn't update the ship builder's tab.
	"""

	settlement = gui.session.world.player.settlements[0]
	boatbuilder = settlement.buildings_by_id[BUILDINGS.BOAT_BUILDER][0]

	# Select boat builder
	gui.cursor_click(64, 10, 'left')

	# nothing being built, no cancel button visible
	assert not gui.find('BB_cancel_button')

	# Select trade ships tab
	gui.trigger('tab_base', '1')

	# Build huker
	gui.trigger('boatbuilder_showcase', 'ok_0')

	assert gui.find('BB_cancel_button')

	# Wait until production starts
	producer = boatbuilder.get_component(Producer)
	while producer._get_current_state() != PRODUCTION.STATES.producing:
		gui.run()

	gui.run()

	# Cancel build
	gui.trigger('BB_main_tab', 'BB_cancel_button')

	# The tab should have changed, no cancel button visible
	assert not gui.find('BB_cancel_button')

########NEW FILE########
__FILENAME__ = test_bugs
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.command.unit import CreateUnit
from horizons.command.building import Tear
from horizons.constants import UNITS, BUILDINGS
from horizons.world.production.producer import Producer

from tests.gui import gui_test
from tests.gui.helper import get_player_ship, move_ship, found_settlement


@gui_test(use_dev_map=True, timeout=120)
def test_ticket_1352(gui):
	"""
	Clicking on a frigate crashes the game.
	"""

	player = gui.session.world.player
	ship = CreateUnit(player.worldid, UNITS.FRIGATE, 68, 10)(player)
	x, y = ship.position.x, ship.position.y

	gui.session.view.center(x, y)

	"""
	# low-level selection
	# disabled because it is difficult to select the ship
	gui.cursor_move(x, y)
	gui.cursor_click(x, y, 'left')
	"""

	gui.select([ship])


@gui_test(use_dev_map=True, ai_players=3, timeout=120)
def test_ticket_1368(gui):
	"""
	Selecting a warehouse from an ai player crashes.

	Test runs faster with 3 AI players, because a new settlement is
	founded earlier. It is still pretty slow, but let's care about
	speed later.
	"""

	# Wait until ai has settled down
	world = gui.session.world
	while not world.settlements:
		gui.run()

	ai_warehouse = world.settlements[0].warehouse
	gui.select([ai_warehouse])


@gui_test(use_fixture='ai_settlement', timeout=60)
def test_ticket_1369(gui):
	"""
	Ship tab closed when moving away from another player's warehouse after trading.
	"""

	ship = get_player_ship(gui.session)
	gui.select([ship])

	# ally players so they can trade
	world = gui.session.world
	for player in world.players:
		if player is not ship.owner:
			world.diplomacy.add_ally_pair( ship.owner, player )

	# move ship near foreign warehouse and wait for it to arrive
	move_ship(gui, ship, (68, 23))

	# click trade button
	gui.trigger('overview_trade_ship', 'trade')

	# trade widget visible
	assert gui.find(name='buy_sell_goods')

	# move ship away from warehouse
	move_ship(gui, ship, (77, 17))

	# trade widget should not be visible anymore
# For now, the trade widget will stay visible.
#	assert gui.find(name='buy_sell_goods') is None

	# but the ship overview should be
	assert gui.find(name='buy_sell_goods')
#	assert gui.find(name='overview_trade_ship')


@gui_test(use_dev_map=True, timeout=120)
def test_ticket_1362(gui):
	"""
	Saving a game, loading it again and attempting to save it again will crash.
	"""

	gui.press_key(gui.Key.F5)	# quicksave
	gui.run(seconds=2)

	gui.press_key(gui.Key.F9)	# quickload
	while gui.find(name='loadingscreen'):
		gui.run()

	def func():
		# test for error popup
		assert gui.find(name='popup_window') is None

	# quicksave
	with gui.handler(func):
		gui.press_key(gui.Key.F5)


@gui_test(use_dev_map=True, timeout=120)
def test_ticket_1371(gui):
	"""
	Build related tab becomes invisible.

	 * use uninterrupted building (press shift)
	 * click on lumberjack
	 * click on the 'build related' tab
	 * click on the tree
	 * build a tree

     => tab itself is invisible, but buttons for choosing it aren't
	"""

	found_settlement(gui, (59, 1), (56, 3))

	# Build lumberjack
	gui.trigger('mainhud', 'build')
	gui.trigger('tab', 'button_03')
	gui.cursor_click(52, 7, 'left')

	# Select lumberjack
	gui.cursor_click(52, 7, 'left')

	# Open build related tab
	gui.trigger('tab_base', '1')

	# Select tree
	gui.trigger('overview_buildrelated', 'build17')

	# Plant a tree (without uninterrupted building)
	gui.cursor_click(49, 6, 'left')
	assert gui.find(name='overview_buildrelated')

	# Select tree again and plant it with uninterrupted building
	gui.trigger('overview_buildrelated', 'build17')
	gui.cursor_click(49, 7, 'left', shift=True)

	# Tab should still be there
	assert gui.find(name='overview_buildrelated')


@gui_test(use_fixture='fife_exception_not_found', timeout=60)
def test_ticket_1447(gui):
	"""
	Clicking on a sequence of buildings may make fife throw an exception.
	"""

	lumberjack = gui.session.world.islands[0].ground_map[(23, 63)].object
	assert lumberjack.id == BUILDINGS.LUMBERJACK

	fisher = gui.session.world.islands[0].ground_map[(20, 67)].object
	assert fisher.id == BUILDINGS.FISHER

	warehouse = gui.session.world.islands[0].ground_map[(18, 63)].object
	assert warehouse.id == BUILDINGS.WAREHOUSE

	gui.cursor_click(20, 67, 'left')
	gui.run()

	gui.cursor_click(23, 63, 'left')
	gui.run()

	gui.cursor_click(18, 63, 'left')
	gui.run()


@gui_test(use_dev_map=True, timeout=120)
def test_ticket_1515(gui):
	"""
	Unable to select an unowned resource deposit.
	"""

	gui.cursor_click(6, 17, 'left')


@gui_test(use_dev_map=True, timeout=120)
def test_ticket_1520(gui):
	"""
	Crash when completing build after outlined/related buildings were removed.
	"""

	found_settlement(gui, (8, 2), (10, 6))

	ground_map = gui.session.world.islands[0].ground_map

	# Build a tent
	gui.trigger('mainhud', 'build')
	gui.trigger('tab', 'button_01')
	gui.cursor_click(7, 9, 'left')

	assert ground_map[(7, 9)].object.id == BUILDINGS.RESIDENTIAL

	# Start building a mainsquare (not releasing left mouse button)
	gui.trigger('tab', 'button_02')
	gui.cursor_move(13, 11)
	gui.cursor_press_button(13, 11, 'left')

	# remove tent
	Tear( ground_map[(7, 9)].object ).execute(gui.session)

	# release mouse button, finish build
	gui.cursor_release_button(13, 11, 'left')


@gui_test(use_dev_map=True, timeout=120)
def test_ticket_1509(gui):
	"""
	Crash when quickly switching between tent tabs.
	"""

	found_settlement(gui, (8, 2), (10, 6))

	# Build a tent
	gui.trigger('mainhud', 'build')
	gui.trigger('tab', 'button_01')
	gui.cursor_click(7, 10, 'left')

	# Select tent
	gui.cursor_click(7, 10, 'left')

	# quickly switch between tabs
	gui.trigger('tab_base', '1')
	gui.run()
	gui.trigger('tab_base', '0')
	gui.run()
	gui.trigger('tab_base', '1')


@gui_test(use_fixture='boatbuilder', timeout=120)
def test_ticket_1526(gui):
	"""
	Multiselection with Ctrl crashes on many combinations.
	"""

	# Select main square and then boat builder
	gui.cursor_click(52, 12, 'left')
	gui.cursor_click(64, 10, 'left', ctrl=True)

	# Select same building twice
	gui.cursor_click(52, 12, 'left')
	gui.cursor_click(52, 12, 'left', ctrl=True)


@gui_test(use_dev_map=True, timeout=120)
def test_pavilion_build_crash_built_via_settler_related_tab(gui):
	"""
	"""

	found_settlement(gui, (59, 1), (56, 3))

	# Build settler
	gui.trigger('mainhud', 'build')
	gui.trigger('tab', 'button_01')
	gui.cursor_click(52, 7, 'left')

	# Select settler
	gui.cursor_click(52, 7, 'left')

	# Open build related tab
	gui.trigger('tab_base', '1')

	# Select pavilion
	gui.trigger('overview_buildrelated', 'build5')

	# Plant it
	gui.cursor_click(49, 6, 'left')

	# if we survive until here, the bug hasn't happened


@gui_test(use_fixture='boatbuilder', timeout=120)
def test_ticket_1848(gui):
	"""Settlement production overview crashes if ships were produced"""

	settlement = gui.session.world.player.settlements[0]
	boatbuilder = settlement.buildings_by_id[BUILDINGS.BOAT_BUILDER][0]

	# Build huker
	gui.cursor_click(64, 10, 'left')
	gui.trigger('tab_base', '1')
	gui.trigger('boatbuilder_showcase', 'ok_0')

	# Wait until production ends
	producer = boatbuilder.get_component(Producer)
	while producer.get_productions():
		gui.run()

	gui.cursor_click(51, 13, 'left')
	gui.trigger('tab_account', 'show_production_overview')


@gui_test(use_dev_map=True)
def test_ticket_1948(gui):
	"""Triggers a crash that happens when building a storage tent on the border of the settlement"""
	# Units cannot be selected right now, you need to do it this way. This is almost
	# the same as selecting it with the mouse
	ship = get_player_ship(gui.session)
	gui.select([ship])
	found_settlement(gui, (59, 1), (56, 3))

	# Select storage tent
	gui.trigger('mainhud', 'build')
	gui.trigger('tab', 'button_11')
	# Build storage at the border of the settlement
	gui.cursor_click(37, 20, 'left')


@gui_test(use_fixture='fife_exception_not_found', timeout=60)
def test_ticket_2117(gui):
	"""Changing language with active production overview tab crashes game"""

	# Select lumberjack to open production tab
	gui.cursor_click(23, 63, 'left')

	# Open settings
	gui.trigger('mainhud', 'gameMenuButton')
	gui.trigger('menu', 'settingsLink')

	# Change language (to anything not system default)
	gui.trigger('settings_window', 'game_settings_right')
	gui.find('uni_language').select(u'English')
	gui.trigger('settings_window', 'okButton')

########NEW FILE########
__FILENAME__ = test_build
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import time

from horizons.constants import BUILDINGS
from horizons.world.units.collectors.collector import Collector
from horizons.component.collectingcomponent import CollectingComponent

from tests.gui import gui_test
from tests.gui.helper import found_settlement


@gui_test(use_dev_map=True, timeout=60)
def test_found_settlement(gui):
	"""
	Found a settlement.
	"""

	player = gui.session.world.player
	assert not player.settlements

	found_settlement(gui, (68, 10), (64, 12))

	assert len(player.settlements) == 1

	# activate the build menu
	ground_map = gui.session.world.islands[0].ground_map
	gui.trigger('mainhud', 'build')

	# build a lumberjack
	gui.trigger('tab', 'button_03')
	gui.cursor_click(55, 5, 'left')
	assert(ground_map[(55, 5)].object.id == BUILDINGS.LUMBERJACK)

	# build a storage
	gui.trigger('tab', 'button_11')
	gui.cursor_click(55, 15, 'left')
	storage = ground_map[(55, 15)].object
	assert(storage.id == BUILDINGS.STORAGE)

	# connect the lumberjack and storage using a road
	gui.trigger('tab', 'button_21')
	for y in xrange(7, 15):
		gui.cursor_click(55, y, 'left')
		assert(ground_map[(55, y)].object.id == BUILDINGS.TRAIL)
	gui.cursor_click(55, y, 'right')

	# select the storage
	gui.cursor_click(55, 15, 'left')
	gui.trigger('tab_base', '0')
	assert gui.find('tab_account')
	collectors = storage.get_component(CollectingComponent).get_local_collectors()

	while True:
		if any(collector.state is Collector.states.moving_to_target for collector in collectors):
			break
		gui.run()

	# remove the storage, trigger ticket 1441
	gui.press_key(gui.Key.DELETE)
	start = time.time()
	# wait 0.5 seconds
	while time.time() - start < 0.5:
		gui.run()
	assert ground_map[(55, 15)].object is None

	# open build menu again
	gui.trigger('mainhud', 'build')

	# build a fisher
	gui.trigger('tab', 'button_33')
	gui.cursor_click(60, 4, 'left')
	fisher = ground_map[(60, 4)].object
	assert(fisher.id == BUILDINGS.FISHER)

	# connect the lumberjack and fisher using a road
	gui.trigger('tab', 'button_21')
	for x in xrange(57, 60):
		gui.cursor_click(x, 5, 'left')
		assert(ground_map[(x, 5)].object.id == BUILDINGS.TRAIL)
	gui.cursor_click(x, 5, 'right')

	# trigger ticket 1767
	# build a signal fire
	gui.trigger('tab', 'button_22')
	gui.cursor_click(58, 5, 'left')
	gui.cursor_click(58, 4, 'left')

########NEW FILE########
__FILENAME__ = test_dialogs
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.component.namedcomponent import NamedComponent

from tests.gui import gui_test
from tests.gui.helper import get_player_ship


@gui_test(use_dev_map=True, timeout=60)
def test_change_name(gui):
	"""Rename a ship."""

	ship = get_player_ship(gui.session)
	old_name = ship.get_component(NamedComponent).name

	assert not gui.find(name='change_name_dialog_window')
	gui.select([ship])

	def rename():
		gui.find('new_name').write('Dagobert')
		assert gui.find(name='change_name_dialog_window')
		gui.trigger('change_name_dialog_window', 'okButton')

	with gui.handler(rename):
		gui.trigger('overview_trade_ship', 'name')

	assert not gui.find(name='change_name_dialog_window')
	new_name = ship.get_component(NamedComponent).name
	assert old_name != new_name
	assert new_name == 'Dagobert'


@gui_test(use_dev_map=True, timeout=60)
def test_change_name_empty_not_allowed(gui):
	"""Make sure an object's name can't be changed to some empty string.

	See issue #1978.
	"""
	ship = get_player_ship(gui.session)
	old_name = ship.get_component(NamedComponent).name

	gui.select([ship])

	# try empty name
	def rename_empty():
		gui.find('new_name').write('')
		gui.trigger('change_name_dialog_window', 'okButton')

	with gui.handler(rename_empty):
		gui.trigger('overview_trade_ship', 'name')

	new_name = ship.get_component(NamedComponent).name
	assert old_name == new_name

	# try name with just spaces
	def rename_spaces():
		gui.find('new_name').write('   ')
		gui.trigger('change_name_dialog_window', 'okButton')

	with gui.handler(rename_spaces):
		gui.trigger('overview_trade_ship', 'name')

	new_name = ship.get_component(NamedComponent).name
	assert old_name == new_name


@gui_test(use_dev_map=True, timeout=60)
def test_chat(gui):
	"""Opens chat dialog.

	NOTE: Doesn't test if anything was send, just checking that nothing
	crashes.
	"""

	assert not gui.find(name='chat_dialog_window')

	def func1():
		assert gui.find(name='chat_dialog_window')
		gui.trigger('chat_dialog_window', 'cancelButton')

	with gui.handler(func1):
		gui.press_key(gui.Key.C)

	assert not gui.find(name='chat_dialog_window')

	def func2():
		assert gui.find(name='chat_dialog_window')
		gui.find('msg').write('Hello World')
		gui.trigger('chat_dialog_window', 'okButton')

	with gui.handler(func2):
		gui.press_key(gui.Key.C)

	assert not gui.find(name='chat_dialog_window')

########NEW FILE########
__FILENAME__ = test_diplomacy
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.gui import gui_test


@gui_test(use_dev_map=True, ai_players=1)
def test_diplomacy(gui):
	"""Test changing diplomacy status."""

	human = gui.session.world.player

	players = list(gui.session.world.players)
	players.remove(human)

	pirate = gui.session.world.pirate
	ai = players[0]

	diplomacy = gui.session.world.diplomacy

	# Make sure they are neutral at first
	for p in (ai, pirate):
		assert diplomacy.are_neutral(human, p)

	# Ally with first player
	gui.trigger('mainhud', 'diplomacyButton')
	gui.trigger('tab0', 'ally_check_box')

	assert diplomacy.are_allies(human, ai)

	# Be enemy with second player
	gui.trigger('tab_base', '1')
	gui.trigger('tab0', 'enemy_check_box')

	assert diplomacy.are_enemies(human, pirate)

########NEW FILE########
__FILENAME__ = test_generated
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import itertools

from tests.gui import gui_test
from tests.gui.helper import get_player_ship


@gui_test(use_dev_map=True, timeout=120)
def test_build_a_settlement(gui):
	"""
	Build a settlement. Generated with gui logger.
	"""

	ship = get_player_ship(gui.session)

	gui.select([ship])

	# Move ship
	gui.cursor_click(57, 0, 'right')

	# Wait for ship to arrive
	while (ship.position.x, ship.position.y) != (57, 0):
		gui.run()

	gui.trigger('overview_trade_ship', 'found_settlement')

	# Place warehouse
	gui.cursor_click(56, 3, 'left')
	assert gui.session.world.settlements

	# Select buildmenu
	gui.trigger('mainhud', 'build')

	# Select fisher
	gui.trigger('tab', 'button_33')

	# Place fisher
	gui.cursor_click(52, 3, 'left')

	# Select path
	gui.trigger('tab', 'button_21')

	# Build some paths
	# Has to be one by one, no mouse drag support yet
	gui.cursor_click(52, 5, 'left')
	gui.cursor_click(53, 5, 'left')
	gui.cursor_click(54, 5, 'left')
	gui.cursor_click(55, 5, 'left')
	gui.cursor_click(56, 5, 'left')
	gui.cursor_click(57, 5, 'left')
	gui.cursor_click(54, 7, 'right')	# cancel

	# Build lumberjack
	gui.trigger('tab', 'button_03')
	gui.cursor_click(52, 6, 'left')

	# Build main square
	gui.trigger('tab', 'button_02')
	gui.cursor_click(53, 11, 'left')

	# Select path
	gui.trigger('tab', 'button_21')

	# Build some paths
	gui.cursor_click(57, 6, 'left')
	gui.cursor_click(57, 7, 'left')
	gui.cursor_click(57, 8, 'left')
	gui.cursor_click(57, 9, 'left')
	gui.cursor_click(57, 10, 'left')
	gui.cursor_click(57, 11, 'left')
	gui.cursor_click(57, 12, 'left')
	gui.cursor_click(57, 13, 'right')	# cancel

	# Build a tent
	gui.trigger('tab', 'button_01')
	gui.cursor_click(58, 9, 'left')

	# Build a tent
	gui.trigger('tab', 'button_01')
	gui.cursor_click(58, 7, 'left')

	# Build a tent
	gui.trigger('tab', 'button_01')
	gui.cursor_click(58, 5, 'left')


@gui_test(use_dev_map=True, timeout=120)
def test_buildingtool(gui):
	"""
	Trigger different buildingtool highlights
	"""

	ship = get_player_ship(gui.session)

	gui.select([ship])

	# Move ship
	gui.cursor_click(57, 0, 'right')

	# Wait for ship to arrive
	while (ship.position.x, ship.position.y) != (57, 0):
		gui.run()

	gui.trigger('overview_trade_ship', 'found_settlement')

	def build_at(target):
		# build while moving around cursor beforehand
		OFFSETS = [ 0, 1, -1, 2, -2, 5, -5, 20, -20 ] # don't add more, takes long enough already
		for off_x, off_y in itertools.product( OFFSETS, repeat=2 ):
			# will trigger preview_build of BuildingTool
			gui.cursor_move( target[0]+off_x, target[1]+off_y )
		gui.cursor_click(target[0], target[1], 'left')

	# Place warehouse
	build_at( (56, 3) )
	assert gui.session.world.settlements

	# Select buildmenu
	gui.trigger('mainhud', 'build')

	# Select fisher
	gui.trigger('tab', 'button_33')

	# Place fisher
	build_at( (52, 3) )


	# Build lumberjack
	gui.trigger('tab', 'button_03')
	build_at( (52, 6) )

	# Build main square
	gui.trigger('tab', 'button_02')
	build_at( (53, 11) )

	# Select path
	gui.trigger('tab', 'button_21')

	# Build some paths
	for i in xrange(6, 13):
		build_at( (57, i) )
	gui.cursor_click(54, 7, 'right') # cancel

	# Build a tent
	gui.trigger('tab', 'button_01')
	build_at( (58, 7) )

	# Select pavilion (tent highlights)
	gui.trigger('tab', 'button_12')
	build_at( (58, 5) )

	# Build a tent (pavilion highlights)
	gui.trigger('tab', 'button_01')
	build_at( (58, 9) )

########NEW FILE########
__FILENAME__ = test_hud
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.gui import gui_test


@gui_test(use_dev_map=True, timeout=60)
def test_hud(gui):
	"""
	Click on some buttons at the ingame menu.
	"""

	gui.trigger('mainhud', 'zoomOut')
	gui.trigger('mainhud', 'zoomIn')
	gui.trigger('mainhud', 'rotateRight')
	gui.trigger('mainhud', 'rotateLeft')

	gui.trigger('mainhud', 'logbook')
	gui.trigger('captains_log', 'okButton')

	gui.trigger('mainhud', 'build')
	gui.trigger('mainhud', 'diplomacyButton')

########NEW FILE########
__FILENAME__ = test_keys
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.gui import gui_test


@gui_test(use_dev_map=True, timeout=120)
def test_ticket_1342(gui):
	"""
	Ship list widget (F3, formerly F4) crashes game on access.
	"""

	assert gui.find(name='ships_list') is None
	gui.press_key(gui.Key.F3)
	assert gui.find(name='ships_list')
	gui.press_key(gui.Key.F3)
	assert gui.find(name='ships_list') is None

########NEW FILE########
__FILENAME__ = test_logbook
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.gui import gui_test


@gui_test(use_dev_map=True, timeout=60)
def test_logbook(gui):
	"""
	Open the (empty) logbook.
	"""

	gui.trigger('mainhud', 'logbook')

	logbook = gui.find(name='captains_log')
	assert logbook

	# Close it and confirm it's gone
	gui.trigger(logbook, 'okButton')
	assert gui.find(name='captains_log') is None


@gui_test(use_fixture='boatbuilder', timeout=60)
def test_logbook_statistics(gui):
	"""Open the 3 three different statistic tabs in the logbook."""

	# Open statistics page in logbook
	gui.trigger('mainhud', 'logbook')
	gui.trigger('captains_log', 'statistics_right')

	# Open players/ships/settlements tabs
	gui.trigger('captains_log', 'stats_players')
	gui.trigger('captains_log', 'stats_ships')
	gui.trigger('captains_log', 'stats_settlements')

########NEW FILE########
__FILENAME__ = test_selection
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.command.unit import CreateUnit
from horizons.constants import UNITS

from tests.gui import gui_test
from tests.gui.helper import get_player_ship


@gui_test(use_dev_map=True, timeout=60)
def test_select_ship(gui):
	"""
	Select a ship.
	"""

	assert gui.find('overview_trade_ship')

	gui.press_key(gui.Key.NUM_0)
	assert gui.find('tab_base') is None

	# Find player's ship
	player_ship = get_player_ship(gui.session)

	gui.select([player_ship])
	assert gui.find('overview_trade_ship')


@gui_test(use_dev_map=True, timeout=60)
def test_selectmultitab(gui):
	"""
	Select two frigates and delete them.
	"""

	gui.press_key(gui.Key.NUM_0)
	assert gui.find('tab_base') is None

	player = gui.session.world.player
	def create_ship(type):
		return CreateUnit(player.worldid, type, *gui.session.world.get_random_possible_ship_position().to_tuple())(issuer=player)

	ships = [create_ship(UNITS.FRIGATE), create_ship(UNITS.FRIGATE)]
	gui.select(ships)
	assert gui.find('overview_select_multi')
	gui.run(seconds=0.1)

	gui.press_key(gui.Key.DELETE)
	assert gui.find('tab_base') is None
	gui.run(seconds=0.1)


@gui_test(use_dev_map=True, timeout=120)
def test_selection_groups(gui):
	"""Check group selection using ctrl-NUM"""

	# Starting a new game assigns player ship to group 1
	ship = get_player_ship(gui.session)
	assert gui.session.selected_instances == set([ship])

	gui.select([ship])

	# make first group
	gui.press_key(gui.Key.NUM_2, ctrl=True)

	gui.select( [] )
	assert not gui.session.selected_instances

	# check group
	gui.press_key(gui.Key.NUM_2)
	assert iter(gui.session.selected_instances).next() is ship

	gui.cursor_click(59, 1, 'right')
	while (ship.position.x, ship.position.y) != (59, 1):
		gui.run()

	# Found settlement
	gui.trigger('overview_trade_ship', 'found_settlement')

	gui.cursor_click(56, 3, 'left')

	gui.trigger('mainhud', 'build')

	wh = gui.session.world.player.settlements[0].warehouse

	gui.select( [wh] )
	gui.press_key(gui.Key.NUM_3, ctrl=True)

	# check group again
	gui.press_key(gui.Key.NUM_2)
	assert len(gui.session.selected_instances) == 1 and \
	       iter(gui.session.selected_instances).next() is ship

	# now other one
	gui.press_key(gui.Key.NUM_3)
	assert len(gui.session.selected_instances) == 1 and \
	       iter(gui.session.selected_instances).next() is wh

	# check group still once again
	gui.press_key(gui.Key.NUM_2)
	assert len(gui.session.selected_instances) == 1 and \
	       iter(gui.session.selected_instances).next() is ship

	# no group
	gui.press_key(gui.Key.NUM_0)
	assert not gui.session.selected_instances

########NEW FILE########
__FILENAME__ = test_trade
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from tests.gui import gui_test
from tests.gui.helper import get_player_ship, move_ship

from horizons.command.uioptions import SetTradeSlot
from horizons.component.storagecomponent import StorageComponent
from horizons.component.tradepostcomponent import TradePostComponent
from horizons.constants import RES



@gui_test(use_fixture='ai_settlement', timeout=60)
def test_trade(gui):
	"""
	"""

	ship = get_player_ship(gui.session)
	gui.select([ship])

	# ally players so they can trade
	world = gui.session.world
	for player in world.players:
		if player is not ship.owner:
			world.diplomacy.add_ally_pair( ship.owner, player )

	# move ship near foreign warehouse and wait for it to arrive
	move_ship(gui, ship, (68, 23))

	# click trade button
	gui.trigger('overview_trade_ship', 'trade')

	# trade widget visible
	assert gui.find(name='buy_sell_goods')

	ship_inv = ship.get_component(StorageComponent).inventory
	settlement = gui.session.world.islands[0].settlements[0]
	settlement_inv = settlement.get_component(StorageComponent).inventory

	# transfer 1 t
	gui.trigger('buy_sell_goods', 'size_1')

	old_ship_value = ship_inv[RES.BOARDS]
	old_settlement_value = settlement_inv[RES.BOARDS]

	# of boards (will be bought)
	gui.trigger('buy_sell_goods', 'inventory_entry_0')

	assert old_settlement_value + 1 == settlement_inv[RES.BOARDS]
	assert old_ship_value - 1 == ship_inv[RES.BOARDS]

	old_ship_value = ship_inv[RES.CANNON]
	old_settlement_value = settlement_inv[RES.CANNON]

	# now cannons (won't be bought)
	gui.trigger('buy_sell_goods', 'inventory_entry_3')

	assert old_settlement_value == settlement_inv[RES.CANNON]
	assert old_ship_value == ship_inv[RES.CANNON]

	# the ai has to want more boards
	trade_post = settlement.get_component(TradePostComponent)
	assert settlement_inv[RES.BOARDS] < trade_post.slots[trade_post.buy_list[RES.BOARDS]].limit

	# transfer 50 t of boards
	gui.trigger('buy_sell_goods', 'size_5')
	gui.trigger('buy_sell_goods', 'inventory_entry_0')

	# now it has enough
	assert settlement_inv[RES.BOARDS] == trade_post.slots[trade_post.buy_list[RES.BOARDS]].limit

	old_ship_value = ship_inv[RES.BOARDS]

	# so another click won't do anything
	gui.trigger('buy_sell_goods', 'inventory_entry_0')

	assert old_ship_value == ship_inv[RES.BOARDS]

	# no matter how small the amount
	gui.trigger('buy_sell_goods', 'size_1')
	gui.trigger('buy_sell_goods', 'inventory_entry_0')

	assert old_ship_value == ship_inv[RES.BOARDS]

	# make room on ship inventory
	ship_inv.alter(RES.BOARDS, - ship_inv[RES.BOARDS])

	# test sell now, give settlement something to sell
	SetTradeSlot(trade_post, 2, RES.ALVEARIES, True, 5)(settlement.owner)
	settlement.get_component(StorageComponent).inventory.alter(RES.ALVEARIES, 10)

	# this gives us 5 alevaries
	assert ship_inv[RES.ALVEARIES] == 0
	# first transfer one
	gui.trigger('buy_sell_goods', 'size_1')
	gui.trigger('buy_sell_goods', 'buy_sell_inventory_True_entry_1')

	print ship_inv[RES.ALVEARIES]
	assert ship_inv[RES.ALVEARIES] == 1
	assert settlement_inv[RES.ALVEARIES] == 9

	# now transfer 5, should actually transfer 4
	gui.trigger('buy_sell_goods', 'size_2')
	gui.trigger('buy_sell_goods', 'buy_sell_inventory_True_entry_1')
	assert ship_inv[RES.ALVEARIES] == 5
	assert settlement_inv[RES.ALVEARIES] == 5

########NEW FILE########
__FILENAME__ = test_traderoute
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from fife import fife
from mock import Mock

from horizons.constants import RES
from horizons.util.shapes import Point

from tests.gui import gui_test
from tests.gui.helper import get_player_ship, found_settlement


@gui_test(additional_cmdline=['--start-map', 'mp-dev'])
def test_traderoute(gui):
	"""Check that a ship's route is configured correctly after setting it up using the GUI."""

	ship = get_player_ship(gui.session)
	gui.select([ship])

	# Create the first settlement
	found_settlement(gui, (36, 34), (38, 39))

	# Give the resources back to the ship
	# Click the trade button
	gui.trigger('overview_trade_ship', 'trade')

	# Get the default amount (50 t, which is more than all available) of everything
	gui.trigger('buy_sell_goods', 'inventory_entry_0')
	gui.trigger('buy_sell_goods', 'inventory_entry_1')
	gui.trigger('buy_sell_goods', 'inventory_entry_2')
	gui.trigger('buy_sell_goods', 'inventory_entry_3')

	# Create the second settlement
	found_settlement(gui, (27, 28), (28, 22))

	# Open the configure trade route widget
	gui.trigger('overview_trade_ship', 'configure_route')

	# The trade route widget is visible
	assert gui.find(name='configure_route')
	route_widget = gui.session.ingame_gui._old_menu.current_tab.route_menu

	assert not ship.route.wait_at_load
	assert not ship.route.wait_at_unload
	assert not ship.route.waypoints

	# Select the first waypoint for the trade route
	event = Mock()
	event.getButton.return_value = fife.MouseEvent.LEFT
	event.map_coords = 38, 39
	route_widget.on_map_click(event, False)

	# Select the other waypoint for the trade route
	event = Mock()
	event.getButton.return_value = fife.MouseEvent.LEFT
	event.map_coords = 28, 22
	route_widget.on_map_click(event, False)

	# Set the resources to be loaded from settlement on the left and the amount
	gui.trigger('configure_route/container_1/slot_0', 'button', mouse='left') # Select the second warehouse's first slot
	gui.trigger('configure_route', 'resource_%d' % RES.FOOD)
	gui.find('configure_route/container_1/slot_0/slider').slide(120)

	# Check if the ship obeys the state of "Wait at load" and "Wait at unload"
	gui.trigger('configure_route', 'wait_at_load')
	gui.trigger('configure_route', 'wait_at_unload')

	assert ship.route.wait_at_load
	assert ship.route.wait_at_unload
	assert len(ship.route.waypoints) == 2
	assert Point(38, 39) in ship.route.waypoints[0]['warehouse'].position
	assert Point(28, 22) in ship.route.waypoints[1]['warehouse'].position
	assert ship.route.waypoints[1]['resource_list'] == {RES.FOOD: 120}

########NEW FILE########
__FILENAME__ = test_warehouse
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.gui import gui_test


@gui_test(use_fixture='boatbuilder', timeout=60)
def test_production_overview(gui):

	# select warehouse
	gui.cursor_click(52, 12, 'left')

	# open production overview
	gui.trigger('tab_account', 'show_production_overview')

	# leave it open for a while to let a refresh happen
	gui.run(seconds=2)

	gui.trigger('production_overview', 'okButton')

########NEW FILE########
__FILENAME__ = test_windows
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.gui import gui_test


@gui_test(use_dev_map=True, timeout=60)
def test_settings_dialog_crash(gui):
	"""Opening&closing the settings dialog in two different games crashes."""

	# open pause menu
	gui.trigger('mainhud', 'gameMenuButton')

	# open & close settings
	gui.trigger('menu', 'settingsLink')
	gui.trigger('settings_window', 'okButton')

	# open pause menu, quit session
	def func1():
		gui.trigger('popup_window', 'okButton')

	with gui.handler(func1):
		gui.trigger('menu', 'closeButton')

	# start a new game (development map)
	gui.trigger('menu', 'single_button')
	gui.trigger('singleplayermenu', 'free_maps')
	gui.find('maplist').select(u'development')
	gui.trigger('singleplayermenu', 'okay')

	# open pause menu
	gui.trigger('mainhud', 'gameMenuButton')

	# open & close settings
	gui.trigger('menu', 'settingsLink')
	gui.trigger('settings_window', 'okButton')  # this crashes


@gui_test(timeout=60)
def test_settings_dialog_crash2(gui):
	# open settings in main menu
	gui.trigger('menu', 'settings_button')
	gui.trigger('settings_window', 'cancelButton')

	# start game
	gui.trigger('menu', 'single_button')
	gui.trigger('singleplayermenu', 'free_maps')
	gui.trigger('singleplayermenu', 'okay')

	gui.press_key(gui.Key.ESCAPE)
	# open & close settings
	gui.trigger('menu', 'settingsLink')
	gui.press_key(gui.Key.ESCAPE)

########NEW FILE########
__FILENAME__ = logger
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

"""
When activated, several hooks are installed into pychan/guichan and catch
key presses and widget interactions.
The results are formatted as code that can be used for writing GUI tests.
"""

import logging
from functools import wraps

from horizons.gui import mousetools
from horizons.gui.keylisteners.ingamekeylistener import IngameKeyListener
from horizons.gui.windows import Dialog

from fife import fife
from fife.extensions.pychan import tools, widgets
from fife.extensions.pychan.events import EventMapper


log = logging.getLogger(__name__)


# Lookup from fife.Key objects to keynames
KEY_NAME_LOOKUP = {}
for keyname in [k for k in dir(fife.Key) if k.upper() == k]:
	KEY_NAME_LOOKUP[getattr(fife.Key, keyname)] = keyname


class GuiHooks(object):
	"""
	Install hooks for several events and pass events to a logger.
	"""
	def __init__(self, logger):
		self.logger = logger
		self._setup_widget_events()
		self._setup_key_events()
		self._setup_mousetool_events()
		self._setup_dialog_detector()

	def _setup_widget_events(self):
		"""Capture events on widgets.

		We log events by wrapping callbacks before they are registered at a widget.
		"""
		log = self.logger.new_widget_event

		def deco2(func):
			@wraps(func)
			def wrapper(self, *args, **kwargs):
				func(self, *args, **kwargs)

				def callback(event, widget):
					# this can be a no-op because we're patching addEvent below, which
					# handles the logging
					pass

				# Provide a default callback for listboxes. Some will never have a
				# callback installed because their selection is just read later.
				# But we depend on event callbacks to detect events.
				if isinstance(self.widget_ref(), widgets.ListBox):
					self.capture('action', callback, 'default')
				# We can't detect keypresses on textfields yet, but at least capture
				# the event when we select the widget
				elif isinstance(self.widget_ref(), widgets.TextField):
					self.capture('mouseClicked', callback, 'default')

			return wrapper

		EventMapper.__init__ = deco2(EventMapper.__init__)

		def deco(func):
			@wraps(func)
			def wrapper(self, event_name, callback, group_name):
				# filter out mouse events (too much noise)
				if 'mouse' in event_name and event_name != 'mouseClicked':
					return func(self, event_name, callback, group_name)

				def new_callback(event, widget):
					"""
					pychan will pass the callback event and widget keyword arguments if expected.
					We do not know if callback expected these, so we use tools.applyOnlySuitable -
					which is what pychan does.
					"""
					log(widget, event_name, group_name)
					return tools.applyOnlySuitable(callback, event=event, widget=widget)

				return func(self, event_name, new_callback, group_name)

			return wrapper

		EventMapper.addEvent = deco(EventMapper.addEvent)

	def _setup_key_events(self):
		"""
		Catch events when a key is released.
		"""
		log = self.logger.new_key_event

		def deco2(func):
			@wraps(func)
			def wrapper(self, evt):
				data = {
					'keycode': evt.getKey().getValue(),
					'shift': evt.isShiftPressed(),
					'ctrl': evt.isControlPressed()
				}
				log(**data)
				return func(self, evt)

			return wrapper

		IngameKeyListener.keyReleased = deco2(IngameKeyListener.keyReleased)

	def _setup_mousetool_events(self):
		"""
		Catch mouse events of the various mouse tools.
		"""
		log = self.logger.new_mousetool_event

		mouse_button = {
			fife.MouseEvent.LEFT: 'left', fife.MouseEvent.RIGHT: 'right',
		}

		def deco3(func):
			@wraps(func)
			def wrapper(self, evt):
				x, y = self.get_world_location(evt).to_tuple()
				button = mouse_button.get(evt.getButton())
				data = {
					'tool_name': self.__class__.__name__,
					'event_name': func.__name__,
					'x': x, 'y': y, 'button': button
				}

				log(**data)

				return func(self, evt)

			return wrapper

		# no mouseMoved support yet
		targets = {
			mousetools.BuildingTool: ('mousePressed', 'mouseReleased', 'mouseDragged', ),
			mousetools.SelectionTool: ('mousePressed', 'mouseReleased', 'mouseDragged', ),
			mousetools.TearingTool: ('mousePressed', 'mouseReleased', 'mouseDragged', ),
			mousetools.PipetteTool: ('mousePressed', ),
			mousetools.TileLayingTool: ('mousePressed', 'mouseReleased', 'mouseDragged', ),
		}

		for tool, events in targets.items():
			for event in events:
				original = getattr(tool, event)
				setattr(tool, event, deco3(original))

	def _setup_dialog_detector(self):
		"""
		Catch dialog execution.
		"""
		logger = self.logger

		def deco4(func):
			@wraps(func)
			def wrapper(self, *args, **kwargs):
				logger.dialog_opened()
				result = func(self, *args, **kwargs)
				logger.dialog_closed()
				return result
			return wrapper

		Dialog._execute = deco4(Dialog._execute)


class TestCodeGenerator(object):
	"""
	Receives events from GuiHooks and creates test code from it.
	"""
	def __init__(self):
		# Keep a list of events to detect mouse clicks (pressed and released)
		# Clicks are what we're interested in, we don't support mouseMoved
		self._mousetool_events = []

		self._dialog_active = False
		self._dialog_opener = []	# the code that triggered the dialog

		# The generator will not print out new code immediately, because the event might
		# have triggered a dialog (and we don't know yet). Therefore we need to store it
		# until we either receive a new event or know that a dialog was opened.
		self._last_command = []
		self._handler_count = 1

		# Keep track of the last slider event. When moving the slider, many events are
		# emitted. We will generate code for the last value.
		self._last_slider_event = None

	def _add(self, code):
		if self._dialog_active:
			# when a dialog is active, we emit the code right away
			self._emit(code)
			return

		if self._last_command:
			self._emit(self._last_command)
		self._last_command = code

	def _emit(self, lines):
		for line in lines:
			if self._dialog_active:
				print '\t',
			print line

	def _find_container(self, widget):
		"""
		Walk up the tree to find the container the given widget is in.

		Returns the container and a path of widget names collected when traversing
		the tree.
		"""
		path = [widget.name]
		while widget.parent:
			widget = widget.parent
			path.append(widget.name)

		path.reverse()
		return widget, '/'.join(map(str, path))

	def new_widget_event(self, widget, event_name, group_name):
		"""
		Output test code to trigger an event on a widget.
		"""
		container, path = self._find_container(widget)

		if container.name == '__unnamed__':
			print '# FIXME this container needs a name to identify it!'
			print '# Path: %s' % path
		elif event_name == 'action' and group_name == 'action_listener':
			# this is a custom event defined in engine.pychan_util to play click sounds
			# for widgets
			pass
		else:
			log.debug('# %s' % path)
			code = None

			# Emit code for the last slider that was manipulated, but only if the current
			# event is from a different widget. This is a work around to avoid generating
			# lots of code for every small mouse move.
			if self._last_slider_event:
				w = self._last_slider_event
				if w.name != widget.name:
					self._add(["gui.find('%s').slide(%f)" % (w.name, w.value), ""])
					self._last_slider_event = None

			if isinstance(widget, widgets.ListBox):
				selection = widget.items[widget.selected]
				code = "gui.find('%s').select(u'%s')" % (widget.name, selection)
			elif isinstance(widget, widgets.TextField):
				code = "gui.find('%s').write(TODO)" % widget.name
			elif isinstance(widget, widgets.Slider):
				self._last_slider_event = widget
			else:
				if group_name == 'default':
					if event_name in ('action', 'mouseClicked'):
						code = "gui.trigger('%s', '%s')" % (container.name, widget.name)
					else:
						code = "gui.trigger('%s', '%s/%s')" % (container.name, widget.name, event_name)
				else:
					code = "gui.trigger('%s', '%s/%s/%s')" % (container.name, widget.name, event_name, group_name)

			if code:
				self._add([code, ''])
				code = None

	def new_key_event(self, keycode, shift=False, ctrl=False):
		"""
		Output test code to press the key.
		"""
		try:
			args = ['gui.Key.%s' % KEY_NAME_LOOKUP[keycode]]
			if shift:
				args.append('shift=True')
			if ctrl:
				args.append('ctrl=True')

			code = 'gui.press_key(%s)' % ', '.join(args)
		except KeyError:
			code = '# Unknown key (code %s)' % keycode

		self._add([code, ''])

	def new_mousetool_event(self, tool_name, event_name, x, y, button):
		"""
		Prints out debug information for all captured events. Tries to detect mouse clicks
		(button pressed and released after) and emit test code for those.
		"""
		if event_name == 'mouseReleased':
			last_event = self._mousetool_events[-1]
			# simple click
			if last_event == ('mousePressed', x, y, button):
				self._add(["gui.cursor_click(%s, %s, '%s')" % (x, y, button)])
				self._mousetool_events.pop()
			# mouse dragged
			elif (last_event[0], last_event[-1]) == ('mousePressed', button):
				start = last_event[1], last_event[2]
				end = x, y
				self._add(["gui.cursor_drag((%s, %s), (%s, %s), '%s')" % (
					start[0], start[1], end[0], end[1], button
				)])
		elif event_name == 'mousePressed':
			self._mousetool_events.append((event_name, x, y, button))
		elif event_name == 'mouseDragged':
			# TODO for now we ignore these events, if the position between mousePressed
			# and mouseReleased changed, we assume the mouse was moved and generate a
			# drage event
			pass
		else:
			raise Exception("Event '%s' not supported." % event_name)

		# Output debug information, no test code yet
		if button:
			log.debug("# %s.%s(%d, %d, '%s')" % (tool_name, event_name, x, y, button))
		else:
			log.debug("# %s.%s(%d, %d)" % (tool_name, event_name, x, y))

	def dialog_opened(self):
		"""
		Start the dialog handler:

			def func1():
				# code for new events will follow
		"""
		self._dialog_opener = self._last_command
		self._last_command = []
		self._emit(['def func%d():' % self._handler_count])
		self._dialog_active = True

	def dialog_closed(self):
		"""
		Emits code like this when the dialog was closed. `func` is the handler code
		that is started in `dialog_opened` and will contain all events in the dialog's
		lifetime.

		    with gui.handler(func):
			    # code that triggered the dialog
				gui.cursor_click(2, 3, 'left')
		"""
		self._dialog_active = False
		self._emit(['with gui.handler(func%d):' % self._handler_count])
		for line in self._dialog_opener:
			self._emit(['\t' + line])
		self._last_command = []
		self._handler_count += 1


def setup_gui_logger():
	GuiHooks(logger=TestCodeGenerator())

########NEW FILE########
__FILENAME__ = test_mainmenu
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.gui import gui_test


@gui_test(timeout=60)
def test_credits(gui):
	"""Test that the credits page shows up."""

	gui.trigger('menu', 'credits_button')
	gui.trigger('credits_window', 'okButton')
	assert not gui.find('credits_window')


@gui_test(timeout=60)
def test_help(gui):
	"""Test that the help page shows up."""

	gui.trigger('menu', 'help_button')
	gui.trigger('help_window', 'okButton')
	assert not gui.find('help_window')


@gui_test(timeout=60)
def test_settings(gui):
	gui.trigger('menu', 'settings_button')
	gui.trigger('settings_window', 'cancelButton')

########NEW FILE########
__FILENAME__ = test_multiplayer
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import functools
import subprocess
import sys

from nose.tools import with_setup

from horizons.network.networkinterface import NetworkInterface
from tests.gui import gui_test


# Start our own master server for the multiplayer test because the official one
# is probably too old.

_master_server = None

def start_server():
	global _master_server
	args = [sys.executable, "run_server.py", "-h", "localhost", "-p", "2002"]
	_master_server = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)


def stop_server():
	global _master_server
	_master_server.terminate()


mpmenu_test = functools.partial(gui_test, additional_cmdline=["--mp-master", "localhost:2002"])


@with_setup(start_server, stop_server)
@mpmenu_test()
def test_show_menu(gui):
	"""Test that the multiplayer page shows up and closes correctly."""
	gui.trigger('menu', 'multi_button')
	gui.trigger('multiplayermenu', 'cancel')


@with_setup(start_server, stop_server)
@mpmenu_test()
def test_games_list(gui):
	"""Test refreshing of active games list."""
	# TODO add some games so this test does something more useful

	gui.trigger('menu', 'multi_button')

	gui.trigger('multiplayermenu', 'refresh')


@with_setup(start_server, stop_server)
@mpmenu_test()
def test_create_game(gui):
	"""Create a game, join the lobby, change player details, send chat message."""
	gui.trigger('menu', 'multi_button')

	games = NetworkInterface().get_active_games()
	assert len(games) == 0

	# create a game and enter lobby
	gui.trigger('multiplayermenu', 'create')
	gui.find('maplist').select('quattro')
	gui.find('playerlimit').select(2)
	gui.trigger('multiplayer_creategame', 'create')

	games = NetworkInterface().get_active_games()
	assert len(games) == 1

	# send a chat message
	gui.find('chatTextField').write(u'Text').enter()

	# change player color (click on color)
	gui.trigger('multiplayer_gamelobby', 'pcolor_' + NetworkInterface().get_client_name())
	gui.trigger('set_player_details_dialog_window', 'cyan')
	gui.trigger('set_player_details_dialog_window', 'okButton')

	gui.run(1)
	# change player name (click on name)
	gui.trigger('multiplayer_gamelobby', 'pname_' + NetworkInterface().get_client_name())
	gui.find('playername').write(u'Darkwing')
	gui.trigger('set_player_details_dialog_window', 'okButton')

	# run some time to wait for the server's acknowledgment of the new name
	gui.run(2)
	assert NetworkInterface().get_client_name() == 'Darkwing'

	gui.trigger('multiplayer_gamelobby', 'cancel')

	games = NetworkInterface().get_active_games()
	assert len(games) == 0

########NEW FILE########
__FILENAME__ = test_saveload
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os
import shutil

import mock

from horizons.savegamemanager import SavegameManager
from tests.gui import gui_test, TEST_FIXTURES_DIR


def _copy_savegame(filename='boatbuilder'):
	"""Copy fixture savegame into user dir."""
	source = os.path.join(TEST_FIXTURES_DIR, filename + '.sqlite')
	shutil.copy(source, SavegameManager.savegame_dir)


@gui_test(timeout=60, cleanup_userdir=True)
def test_load_game(gui):
	"""Test loading a game from the mainmenu."""

	# need to put a savegame otherwise we just get an error popup
	_copy_savegame()

	def func1():
		gui.find('savegamelist').select(u'boatbuilder')

		with mock.patch('horizons.main.start_singleplayer') as start_mock:
			gui.trigger('load_game_window', 'okButton')

			# we need to run the game for a bit, because start_singleplayer isn't
			# called right away, probably because load/save is a dialog
			gui.run(1)
			options = start_mock.call_args[0][0]

			assert options.game_identifier == SavegameManager.create_filename('boatbuilder')

	with gui.handler(func1):
		gui.trigger('menu', 'load_button')


@gui_test(timeout=60)
def test_load_game_no_savegames(gui):
	"""Trying to load a game with no save games available will show a popup."""
	def func1():
		gui.trigger('popup_window', 'okButton')

	with gui.handler(func1):
		gui.trigger('menu', 'load_button')


@gui_test(timeout=60, use_dev_map=True, cleanup_userdir=True)
def test_save_game_new_file(gui):
	"""Test saving a game."""

	# FIXME escape doesn't work
	#gui.press_key(gui.Key.ESCAPE)
	gui.trigger('mainhud', 'gameMenuButton')

	def func1():
		gui.find('savegamefile').write('testsave')
		gui.trigger('load_game_window', 'okButton')

	with gui.handler(func1):
		gui.trigger('menu', 'savegameButton')

	assert os.path.exists(SavegameManager.create_filename('testsave'))


@gui_test(timeout=60, use_dev_map=True, cleanup_userdir=True)
def test_save_game_override(gui):
	"""Test saving a game."""

	_copy_savegame()
	old_size = os.path.getsize(SavegameManager.create_filename('boatbuilder'))

	# FIXME escape doesn't work
	#gui.press_key(gui.Key.ESCAPE)
	gui.trigger('mainhud', 'gameMenuButton')

	def func1():
		gui.find('savegamelist').select(u'boatbuilder')

		# handle "do you want to override file" popup
		def func2():
			gui.trigger('popup_window', 'okButton')

		with gui.handler(func2):
			gui.trigger('load_game_window', 'okButton')

	with gui.handler(func1):
		gui.trigger('menu', 'savegameButton')

	assert os.path.exists(SavegameManager.create_filename('boatbuilder'))
	new_size = os.path.getsize(SavegameManager.create_filename('boatbuilder'))
	assert old_size != new_size


@gui_test(timeout=60, cleanup_userdir=True)
def test_delete_game(gui):
	"""Test deleting a savegame."""

	_copy_savegame('boatbuilder')
	_copy_savegame('ai_settlement')
	assert os.path.exists(SavegameManager.create_filename('boatbuilder'))
	assert os.path.exists(SavegameManager.create_filename('ai_settlement'))

	def confirm_deletion():
		def close_dialog():
			gui.trigger('load_game_window', 'cancelButton')

		with gui.handler(close_dialog):
			gui.trigger('popup_window', 'okButton')

	def func1():
		gui.find('savegamelist').select(u'boatbuilder')

		with gui.handler(confirm_deletion):
			gui.trigger('load_game_window', 'deleteButton')

	with gui.handler(func1):
		gui.trigger('menu', 'load_button')

	assert not os.path.exists(SavegameManager.create_filename('boatbuilder'))
	assert os.path.exists(SavegameManager.create_filename('ai_settlement'))


@gui_test(timeout=60, cleanup_userdir=True)
def test_delete_game_abort(gui):
	"""Try to delete a game, but abort when ask for confirmation."""

	_copy_savegame('boatbuilder')
	assert os.path.exists(SavegameManager.create_filename('boatbuilder'))

	def confirm_deletion():
		def close_dialog():
			gui.trigger('load_game_window', 'cancelButton')

		with gui.handler(close_dialog):
			gui.trigger('popup_window', 'cancelButton')

	def func1():
		gui.find('savegamelist').select(u'boatbuilder')

		with gui.handler(confirm_deletion):
			gui.trigger('load_game_window', 'deleteButton')

	with gui.handler(func1):
		gui.trigger('menu', 'load_button')

	assert os.path.exists(SavegameManager.create_filename('boatbuilder'))

########NEW FILE########
__FILENAME__ = test_singleplayer
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import mock

from tests.gui import gui_test


@gui_test()
def test_show_menu(gui):
	"""Test that the singleplayer page shows up and closes correctly."""
	gui.trigger('menu', 'single_button')
	gui.trigger('singleplayermenu', 'cancel')


def _start_game(gui):
	"""Starts the game from the menu and returns the game options used."""
	with mock.patch('horizons.main.start_singleplayer') as start_mock:
		gui.trigger('singleplayermenu', 'okay')

		return start_mock.call_args[0][0]


@gui_test()
def test_start_scenario(gui):
	"""Test starting a scenario."""
	gui.trigger('menu', 'single_button')
	gui.trigger('singleplayermenu', 'scenario')

	# trigger update of scenario infos
	gui.find('maplist').select('tutorial')
	gui.find('uni_langlist').select('English')

	options = _start_game(gui)
	assert options.is_scenario
	assert options.game_identifier.endswith('tutorial_en.yaml')


@gui_test()
def test_start_random_map(gui):
	"""Test starting a new random map."""
	gui.trigger('menu', 'single_button')
	gui.trigger('singleplayermenu', 'random')

	# disable pirates and disasters
	gui.trigger('singleplayermenu', 'lbl_pirates')
	gui.trigger('singleplayermenu', 'lbl_disasters')

	gui.find('ai_players').select('3')
	gui.find('resource_density_slider').slide(4)

	options = _start_game(gui)
	assert not options.is_scenario
	assert not options.pirate_enabled
	assert not options.disasters_enabled
	assert options.trader_enabled
	assert options.ai_players == 3
	assert options.natural_resource_multiplier == 2


@gui_test()
def test_start_map(gui):
	"""Test starting an existing map."""
	gui.trigger('menu', 'single_button')
	gui.trigger('singleplayermenu', 'free_maps')

	# trigger update of map info
	gui.find('maplist').select('development')

	gui.find('ai_players').select('1')

	# disable pirates and trader
	gui.trigger('singleplayermenu', 'lbl_pirates')
	gui.trigger('singleplayermenu', 'lbl_free_trader')

	options = _start_game(gui)
	assert options.game_identifier.endswith('development.sqlite')
	assert not options.is_scenario
	assert not options.pirate_enabled
	assert not options.trader_enabled
	assert options.disasters_enabled
	assert options.ai_players == 1

########NEW FILE########
__FILENAME__ = helper
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.scenario import CONDITIONS


var_eq = CONDITIONS.get('var_eq')
settlement_res_stored_greater = CONDITIONS.get('settlement_res_stored_greater')
settler_level_greater = CONDITIONS.get('settler_level_greater')


def assert_win(gui):
	"""Returns once the scenario was won."""
	while True:
		if getattr(gui.session, '_scenariotest_won', False):
			break
		gui.run()


def assert_defeat(gui):
	"""Returns once the scenario was lost."""
	while True:
		if getattr(gui.session, '_scenariotest_lose', False):
			break
		gui.run()


def assert_goal_reached(gui, goal):
	"""Returns once a certain goal was reached."""
	while True:
		if (hasattr(gui.session, '_scenariotest_goals') and
			gui.session._scenariotest_goals and
			gui.session._scenariotest_goals[-1] == goal):
			break
		gui.run()


def wait_and_close_logbook(gui):
	"""Wait for the logbook to show and close it immediately."""
	while not gui.find('captains_log'):
		gui.run()

	gui.trigger('captains_log', 'okButton')

########NEW FILE########
__FILENAME__ = test_simple
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from tests.gui import gui_test
from tests.gui.helper import get_player_ship, move_ship
from tests.gui.scenarios.helper import assert_win, assert_defeat, assert_goal_reached

# Example tests

@gui_test(use_scenario='tests/gui/scenarios/win', timeout=20)
def test_win(gui):
	"""Simple test that detects a win in a game."""

	assert_win(gui)


@gui_test(use_scenario='tests/gui/scenarios/defeat', timeout=20)
def test_defeat(gui):
	"""Simple test that detects a defeat in a game."""

	assert_defeat(gui)


@gui_test(use_scenario='tests/gui/scenarios/mission1', timeout=40)
def test_mission1(gui):
	"""Sample mission which requires multiple buildings to win."""

	# Move ship to coast
	ship = get_player_ship(gui.session)
	gui.select([ship])
	move_ship(gui, ship, (7, 3))

	# Build warehouse
	gui.select([ship])
	gui.trigger('overview_trade_ship', 'found_settlement')
	gui.cursor_click(10, 5, 'left')
	assert_goal_reached(gui, 'warehouse')

	# Build main square
	gui.trigger('mainhud', 'build')
	gui.trigger('tab', 'button_02')
	gui.cursor_click(9, 11, 'left')
	assert_goal_reached(gui, 'mainsquare')

	# Build fisher
	gui.trigger('tab', 'button_33')
	gui.cursor_click(7, 7, 'left')

	assert_win(gui)

########NEW FILE########
__FILENAME__ = test_tutorial
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.constants import RES, TIER

from tests.gui import gui_test
from tests.gui.helper import get_player_ship, move_ship, saveload
from tests.gui.scenarios.helper import (assert_win, var_eq, wait_and_close_logbook,
                                        settlement_res_stored_greater, settler_level_greater)


@gui_test(use_scenario='content/scenarios/tutorial_en', timeout=7*60)
def test_tutorial(gui):
	"""Test the tutorial scenario."""

	# FIXME disable disasters (this should be an option for a scenario)
	gui.session.world.disaster_manager.disabled = True

	def assert_progress(progress):
		wait_and_close_logbook(gui)
		assert var_eq(gui.session, 'tutorial_progress', progress)

	# Tutorial start
	assert_progress(16)

	# Goal: Build warehouse
	ship = get_player_ship(gui.session)
	gui.select([ship])
	move_ship(gui, ship, (11, 1))

	# Save and reload scenario (1/3)
	saveload(gui)

	gui.trigger('overview_trade_ship', 'found_settlement')
	gui.cursor_click(11, 6, 'left')

	# Goal: Build a lumberjack
	assert_progress(19)

	# lumberjack (2)
	gui.trigger('mainhud', 'build')
	gui.trigger('tab', 'button_03')
	gui.cursor_click(8, 10, 'left', shift=True)
	gui.cursor_click(13, 10, 'left')
	gui.cursor_click(13, 10, 'right')

	# plant some extra trees around the lumberjacks
	gui.trigger('tab', 'button_13')
	gui.cursor_drag((6, 13), (15, 8), 'left')

	# roads (no dragging to trigger the 'you can drag roads' hint)
	gui.trigger('tab', 'button_21')
	gui.cursor_multi_click((10, 8), (10, 9), (10, 10), (11, 10))

	# Goal: Build hunter and fisher
	assert_progress(22)

	# fisher
	gui.trigger('tab', 'button_33')
	gui.cursor_click(13, 6, 'left')

	# hunter
	gui.trigger('tab', 'button_23')
	gui.cursor_click(8, 8, 'left')

	# Goal: Mainsquare
	assert_progress(25)

	gui.trigger('tab', 'button_02')
	gui.cursor_click(15, 18, 'left')

	# Goal: first tent
	assert_progress(28)

	# roads
	gui.trigger('tab', 'button_21')
	gui.cursor_drag((13, 15), (20, 15), 'left')
	gui.cursor_click(20, 15, 'right')

	# tent
	gui.trigger('tab', 'button_01')
	gui.cursor_click(13, 13, 'left')

	# Goal: 4 tents
	assert_progress(31)

	gui.trigger('tab', 'button_01')
	gui.cursor_multi_click((15, 13), (17, 13), (19, 13))

	# Goal: Build a signal fire
	assert_progress(34)

	# Save and reload scenario (2/3)
	saveload(gui)

	# Open build menu again (it is not reloaded, unlike selected instances)
	gui.trigger('mainhud', 'build')
	gui.trigger('tab_base', '0')

	# wait until we have enough boards
	while not settlement_res_stored_greater(gui.session, RES.BOARDS, 5):
		gui.run()

	gui.trigger('tab', 'button_22')
	gui.cursor_click(9, 5, 'left')

	# Goal: Trading
	assert_progress(37)

	# Buy tools from the trader (put the resource on the buy list)
	gui.cursor_click(11, 6, 'left')
	gui.trigger('tab_base', '2')
	gui.trigger('buysellmenu/slot_0', 'button', mouse='left')
	gui.trigger('select_trade_resource', 'resource_%d' % RES.TOOLS)
	gui.find('buysellmenu/slot_0/slider').slide(30)

	# Goal: Pavilion
	assert_progress(40)

	# wait until we have enough boards
	while not settlement_res_stored_greater(gui.session, RES.BOARDS, 5):
		gui.run()

	gui.trigger('mainhud', 'build')
	gui.trigger('tab', 'button_12')
	gui.cursor_click(19, 16, 'left')

	# Goal: Next tier
	assert_progress(43)

	# Adjust settler taxes (using mainsquare)
	gui.cursor_click(16, 18, 'left')
	gui.trigger('tab_base', '1')
	gui.find('tax_slider').slide(0)
	gui.trigger('mainhud', 'build')

	# wait until settlers upgraded
	while not settler_level_greater(gui.session, TIER.SAILORS):
		gui.run()

	# Goal: Farm
	assert_progress(46)

	# wait until we have enough boards
	while not settlement_res_stored_greater(gui.session, RES.BOARDS, 10):
		gui.run()

	gui.trigger('tab_base', '1') # FIXME this sometimes fails
	gui.trigger('tab', 'button_02')
	gui.cursor_click(25, 12, 'left')

	# Goal: Fields
	assert_progress(49)

	gui.trigger('tab_base', '1')

	# potato
	gui.trigger('tab', 'button_12')
	gui.cursor_click(23, 11, 'left')

	# Save and reload scenario (3/3)
	saveload(gui)

	# Open build menu again
	gui.trigger('mainhud', 'build')
	gui.trigger('tab_base', '1')

	# pasture
	gui.trigger('tab', 'button_22')
	gui.cursor_click(21, 10, 'left')

	# Goal: Storage
	assert_progress(52)

	# remove a tree to connect to farm
	gui.trigger('mainhud', 'destroy_tool')
	gui.cursor_click(21, 15, 'left')

	# roads
	gui.trigger('mainhud', 'build')
	gui.trigger('tab_base', '0')
	gui.trigger('tab', 'button_21')
	gui.cursor_drag((21, 15), (24, 14), 'left')
	gui.cursor_click(24, 14, 'right')

	# storage tent
	gui.trigger('tab', 'button_11')
	gui.cursor_click(21, 16, 'left')

	# Goal: Weaver
	assert_progress(55)

	# wait until we have enough boards
	while not settlement_res_stored_greater(gui.session, RES.BOARDS, 10):
		gui.run()

	gui.trigger('tab_base', '1')
	gui.trigger('tab', 'button_21')
	gui.cursor_click(25, 14, 'left')

	# Goal: 50 inhabitants, positive balance
	assert_progress(58)

	# more potato fields
	gui.trigger('tab_base', '1')
	gui.trigger('tab', 'button_12')
	gui.cursor_multi_click((24, 9), (27, 8), (27, 11))

	# lumberjack (more wood for upgrades)
	gui.trigger('tab_base', '0')
	gui.trigger('tab', 'button_03')
	gui.cursor_click(19, 18, 'left')

	# wait until we have enough boards
	while not settlement_res_stored_greater(gui.session, RES.BOARDS, 39):
		gui.run()

	# tents
	gui.trigger('tab', 'button_01')
	gui.cursor_multi_click(
		(11, 14), (11, 15), (12, 17), (11, 20),
		(12, 22), (14, 22), (16, 22), (18, 22),
		(19, 20), (22, 15)
	)

	# Goal: Won
	assert_progress(61)

	assert_win(gui)

########NEW FILE########
__FILENAME__ = test_editor
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import os

from horizons.constants import PATHS, GROUND
from tests.gui import gui_test


editor_test = gui_test(additional_cmdline=["--edit-map", "development"])


@editor_test
def test_place_tiles(gui):
	"""Place different tiles with different tile sizes."""

	gui.trigger('editor_settings', 'water')
	gui.cursor_click(27, 36, 'left')
	gui.cursor_click(27, 37, 'left')
	gui.cursor_click(27, 38, 'left')

	gui.trigger('editor_settings', 'size_2')
	gui.trigger('editor_settings', 'sand')
	gui.cursor_click(34, 34, 'left')

	gui.trigger('editor_settings', 'size_3')
	gui.trigger('editor_settings', 'default_land')
	gui.cursor_click(34, 27, 'left')

	# Map edge and largest brush size
	gui.trigger('editor_settings', 'size_5')
	gui.cursor_click(-8, 78, 'left')


@editor_test
def test_save_map(gui):
	"""Save a map in the editor."""

	# FIXME escape doesn't work
	#gui.press_key(gui.Key.ESCAPE)
	gui.trigger('mainhud', 'gameMenuButton')

	def func1():
		gui.find('savegamefile').write('test_map')
		gui.trigger('load_game_window', 'okButton')

	with gui.handler(func1):
		gui.trigger('menu', 'savegameButton')

	assert os.path.exists(os.path.join(PATHS.USER_MAPS_DIR, u"test_map.sqlite"))


@editor_test
def test_drag_mouse(gui):
	"""Test that tiles are placed while dragging the mouse."""
	# TODO This is a really simple demonstration of mouse drag support in tests.
	# TODO We should add better tests to show that the tile algorithm really works.

	gui.trigger('editor_settings', 'water')
	gui.cursor_drag((30, 30), (30, 37), 'left')

	# quick check if the mouse drag had any effect on the map
	for y in range(30, 36):
		tile = gui.session.world.full_map[(30, y)]
		assert (tile.id, tile.shape, tile.rotation + 45) == GROUND.DEEP_WATER_SOUTH

########NEW FILE########
__FILENAME__ = test_example
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.gui import gui_test


# The `gui_test` decorator is needed to identify gui tests. You can use it
# without argument, but is has to be `@gui_test()` (notice the parantheses).
#
# It accepts either one of these arguments:
#
# 	use_dev_map=True		- Game launches with --start-dev-map (no main menu)
# 	use_fixture='name'		- Game launches with --load-game=tests/gui/ingame/fixtures/name.sqlite
# 	ai_players=1			- Game launches with --ai-players=1
# 	timeout=3				- Game will be killed after 3 seconds
#
@gui_test(timeout=60)
def test_example(gui):
	"""
	Documented example test.

	Every gui test has to accept one argument, an instance of `tests.gui.GuiHelper`.
	"""

	gui.disable_autoscroll()

	# Main menu
	main_menu = gui.find(name='menu')
	gui.trigger(main_menu, 'single_button')
	gui.trigger('singleplayermenu', 'okay')

	# Hopefully we're ingame now
	assert gui.active_widgets
	gold_label = gui.find(name='gold_available')
	assert gold_label.text == '' # will upate only later

	# All commands above run sequentially, neither the engine nor the timer
	# will be run. If you need the game to run for some time (or have to wait for
	# something to happen), make multiple gui.run() calls.

	# Game will run for 2 seconds
	gui.run(seconds=2)

	"""
	while not condition:
		gui.run()
	"""

	# When you call `gui.run()` the engine is allowed to run, therefore updating the display.
	# You can also interact with the game as normal, but please don't mess with the test. :)
	#
	# TIP: You can watch the test in slow-motion if you insert these waits between
	# interactions.

	# Open game menu
	gui.trigger('mainhud', 'gameMenuButton')

	# gui.trigger accepts both a string (container name), or a object returned by gui.find

	# Cancel current game
	def dialog():
		gui.trigger('popup_window', 'okButton')

	# Dialog handling has to be done by a separate generator.
	with gui.handler(dialog):
		gui.trigger('menu', 'quit')

	# Code execution will continue here once `dialog` has ended.

	# Back at the main menu
	assert gui.find(name='menu')

	# If a test returns None (either implicitly or explicitly) the game will exit, return
	# something else and it will continue to run. Useful if you want to check your test's
	# action.

    # TODO not yet supported, use gui.run(2**10)
	#return 1

########NEW FILE########
__FILENAME__ = test_internal
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import functools
import os

from horizons.scheduler import Scheduler

from tests.gui import gui_test


@gui_test(use_dev_map=True)
def test_trivial(gui):
	"""Does nothing to see if test setup works."""
	pass

@gui_test(use_dev_map=True, _user_dir=os.path.join("test_settings",".unknown-horizons"))
def test_update_settings(gui):
	"""Does nothing to see if the settings update works."""
	pass

@gui_test(use_dev_map=True)
def test_run_for_x_seconds(gui):
	"""Test that running the game X seconds works."""

	start_tick = Scheduler().cur_tick
	gui.run(seconds=20)
	difference = Scheduler().cur_tick - start_tick

	expected = Scheduler().get_ticks(20)

	assert (difference - expected) / difference < 0.05


def expected_failure(func):
	@functools.wraps(func)
	def wrapper(*args, **kwargs):
		try:
			func(*args, **kwargs)
		except Exception:
			pass
		else:
			raise AssertionError('Expected failure')
	wrapper.__original__ = func.__original__
	return wrapper


@expected_failure
@gui_test(use_dev_map=True)
def test_expected_failure(gui):
	"""Test that failures in tests are detected."""

	1 / 0


@gui_test(use_fixture='boatbuilder')
def test_trigger(gui):
	"""Test the different ways to trigger an action in a gui."""

	assert not gui.find('captains_log')

	# Specify event name and group name
	gui.trigger('mainhud', 'logbook/action/default')
	assert gui.find('captains_log')
	gui.trigger('captains_log', 'okButton/action/default')
	assert not gui.find('captains_log')

	# Leave out group name
	gui.trigger('mainhud', 'logbook/action')
	assert gui.find('captains_log')
	gui.trigger('captains_log', 'okButton/action')
	assert not gui.find('captains_log')

	# Leave out event name
	gui.trigger('mainhud', 'logbook')
	assert gui.find('captains_log')
	gui.trigger('captains_log', 'okButton')
	assert not gui.find('captains_log')

	# Select mainsquare and show production overview to test
	# if mouseClicked and action are handled the same
	assert not gui.find('production_overview')

	gui.cursor_click(53, 12, 'left')
	gui.trigger('tab_account', 'show_production_overview/mouseClicked')
	assert gui.find('production_overview')
	gui.trigger('production_overview', 'okButton/action')
	assert not gui.find('production_overview')

	# Leave out event name, it will try action at first and fallback
	# to mouseClicked
	gui.trigger('tab_account', 'show_production_overview')
	assert gui.find('production_overview')
	gui.trigger('production_overview', 'okButton')
	assert not gui.find('production_overview')


@gui_test(timeout=60)
def test_dialog(gui):
	"""Test handling of a dialog."""

	assert not gui.find('popup_window')

	def func():
		assert gui.find('popup_window')
		gui.trigger('popup_window', 'okButton')

	with gui.handler(func):
		gui.trigger('menu', 'quit_button')

########NEW FILE########
__FILENAME__ = test_mousetools
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.gui import gui_test
from tests.gui.helper import found_settlement


@gui_test(use_dev_map=True)
def test_tearing(gui):
	found_settlement(gui, (11, 1), (11, 6))

	# remove some trees
	gui.trigger('mainhud', 'destroy_tool')
	gui.cursor_drag((5, 7), (11, 16), 'left')

	# build 4 tents
	gui.trigger('mainhud', 'build')
	gui.trigger('tab', 'button_01')
	gui.cursor_drag((7, 9), (10, 12), 'left')

	# try to remove an area that includes the tents, some trees and
	# the warehouse
	gui.trigger('mainhud', 'destroy_tool')
	gui.cursor_drag((5, 15), (15, 3), 'left')


@gui_test(use_dev_map=True)
def test_pipette(gui):
	found_settlement(gui, (11, 1), (11, 6))

	# select mountain, can not be build
	gui.press_key(gui.Key.O)
	gui.cursor_click(6, 18, 'left')
	assert not gui.find('place_building')

	# build signal fire
	gui.trigger('mainhud', 'build')
	gui.trigger('tab', 'button_22')
	gui.cursor_click(7, 7, 'left')

	# activate pipette, select signal fire, place it next to the other
	gui.press_key(gui.Key.O)
	gui.cursor_click(7, 7, 'left')
	gui.cursor_click(6, 7, 'left')

	# select signal fire, check if it's actually there
	gui.cursor_click(6, 7, 'left')
	assert gui.find('overview_signalfire')

########NEW FILE########
__FILENAME__ = test_unicode
# encoding=utf-8

# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import shutil
import tempfile

from tests.gui import gui_test


USER_DIR = None

def setup():
	global USER_DIR
	USER_DIR = tempfile.mkdtemp(suffix=u'H߀ｒìｚｏԉｓ')


def teardown():
	global USER_DIR
	try:
		shutil.rmtree(USER_DIR)
	except:
		pass
	USER_DIR = None


def dummy(gui):
	"""This test will end the game immediately."""
	pass
dummy.__original__ = dummy


def test_user_dir_contains_non_ascii():
	# NOTE we have to create the test this way because if it were defined globally,
	# USER_DIR would not be defined yet at the time the decorator is evaluated
	yield gui_test(timeout=60, use_dev_map=True, _user_dir=USER_DIR)(dummy)
test_user_dir_contains_non_ascii.gui = True

########NEW FILE########
__FILENAME__ = test_window_manager
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import unittest

from horizons.gui.windows import WindowManager, Window


class DummyWindow(Window):

	def __init__(self, windows):
		Window.__init__(self, windows)
		self.visible = False

	def show(self):
		self.visible = True

	def hide(self):
		self.visible = False


class TestWindowManager(unittest.TestCase):

	def setUp(self):
		self.windows = WindowManager()

	def test_trivial(self):
		assert not self.windows.visible

	def test_open_hide(self):
		window1 = DummyWindow(self.windows)
		self.windows.open(window1)
		assert self.windows.visible
		assert window1.visible

		window2 = DummyWindow(self.windows)
		self.windows.open(window2)
		assert self.windows.visible
		assert not window1.visible
		assert window2.visible

	def test_close(self):
		window1 = DummyWindow(self.windows)
		window2 = DummyWindow(self.windows)
		self.windows.open(window1)
		self.windows.open(window2)
		assert not window1.visible
		assert window2.visible

		self.windows.close()
		assert window1.visible
		assert not window2.visible

		self.windows.close()
		assert not window1.visible
		assert not window2.visible
		assert not self.windows.visible

	def test_toggle_single_window(self):
		window1 = DummyWindow(self.windows)
		assert not window1.visible

		self.windows.toggle(window1)
		assert window1.visible
		self.windows.toggle(window1)
		assert not window1.visible

	def test_toggle_multiple(self):
		"""
		Alternately toggle two windows and make sure we have only
		once instance of each window in the stack.
		"""
		window1 = DummyWindow(self.windows)
		window2 = DummyWindow(self.windows)
		assert not window1.visible
		assert not window2.visible

		self.windows.toggle(window1)
		assert window1.visible
		assert not window2.visible

		self.windows.toggle(window2)
		assert not window1.visible
		assert window2.visible

		self.windows.toggle(window1)
		assert window1.visible
		assert not window2.visible

		self.windows.close()
		self.windows.close()
		assert not self.windows.visible

########NEW FILE########
__FILENAME__ = test_paths
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from unittest import TestCase

import tempfile
import shutil
import os

from run_uh import create_user_dirs
from horizons.constants import PATHS
from horizons.savegamemanager import SavegameManager


class TestPaths(TestCase):
	odd_characters = u"u\xfc\xdf\xfau"

	def test_normal(self):

		create_user_dirs()

	def test_special_character(self):
		"""Make paths have special characters and check some basic operations"""

		outer = tempfile.mkdtemp( self.__class__.odd_characters )
		inner = unicode(os.path.join(outer, self.__class__.odd_characters))
		inner2 = unicode(os.path.join(outer, self.__class__.odd_characters+u"2"))

		PATHS.USER_DIR = inner

		create_user_dirs()

		scenario_file = os.listdir(SavegameManager.scenarios_dir)[0]
		shutil.copy(os.path.join(SavegameManager.scenarios_dir, scenario_file),
		            inner)

		SavegameManager.scenarios_dir = inner
		SavegameManager.autosave_dir = inner2
		SavegameManager.init()

		# try to read scenario files
		SavegameManager.get_available_scenarios()

		os.remove(os.path.join(inner, scenario_file))

		SavegameManager.create_autosave_filename()

		os.rmdir(inner)
		os.rmdir(inner2)
		os.rmdir(outer)








########NEW FILE########
__FILENAME__ = test_messages
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.

# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import unittest

from horizons.messaging import Message

import mock


class ExampleMessage(Message):
	pass

class FooMessage(Message):
	arguments = ('a', 'b', )


class TestMessageBus(unittest.TestCase):

	def setUp(self):
		self.cb = mock.Mock()

	def assert_called_once_with(self, cb, message_type, **arguments):
		assert cb.call_count == 1
		msg = cb.call_args[0][0]
		for name, value in arguments.items():
			assert getattr(msg, name) == value

	def test_global_subscribe(self):
		ExampleMessage.subscribe(self.cb)

		# correct message type, cb is called
		ExampleMessage.broadcast(self)
		self.assert_called_once_with(self.cb, ExampleMessage, sender=self)
		self.cb.reset_mock()

		# wrong message type, cb is not called
		Message.broadcast(self)
		self.assertFalse(self.cb.called)

	def test_local_subscribe(self):
		ExampleMessage.subscribe(self.cb, sender=self)

		# correct message type, correct sender, cb is called
		ExampleMessage.broadcast(self)
		self.assert_called_once_with(self.cb, ExampleMessage, sender=self)
		self.cb.reset_mock()

		# correct message type, wrong sender, cb is not called
		ExampleMessage.broadcast(1)
		self.assertFalse(self.cb.called)
		self.cb.reset_mock()

		# wrong message type, correct sender, cb is not called
		Message.broadcast(self)
		self.assertFalse(self.cb.called)

	def test_unsubscribe(self):
		ExampleMessage.subscribe(self.cb)
		Message.subscribe(self.cb, sender=self)

		# broadcast local and global message, cb called two times
		ExampleMessage.broadcast(self)
		Message.broadcast(self)
		assert self.cb.call_count == 2
		self.cb.reset_mock()

		# after unsubscribing globally, only the local message is received
		ExampleMessage.unsubscribe(self.cb)
		ExampleMessage.broadcast(self)
		Message.broadcast(self)
		self.assert_called_once_with(self.cb, Message, sender=self)
		self.cb.reset_mock()

		# after unsubscribing locally, all subscriptions should be gone, cb not called
		Message.unsubscribe(self.cb, sender=self)
		ExampleMessage.broadcast(self)
		Message.broadcast(self)
		self.assertFalse(self.cb.called)


class TestMessage(unittest.TestCase):

	def test_sender_argument(self):
		msg = Message(self)
		self.assertEqual(msg.sender, self)

	def test_additional_arguments(self):
		msg = FooMessage(self, 1, 2)
		self.assertEqual(msg.sender, self)
		self.assertEqual(msg.a, 1)
		self.assertEqual(msg.b, 2)

	def test_wrong_arguments(self):
		self.assertRaises(Exception, FooMessage, self, 1)

########NEW FILE########
__FILENAME__ = test_network
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import subprocess
import sys
import time


def test_run_server():
	"""Test if the multiplayer server can be started.

	Runs the server for 2 seconds and checks if anything was printed on stderr.
	"""
	proc = subprocess.Popen([sys.executable, "server.py", "-h", "127.0.0.1"],
	                        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

	time.sleep(2)
	proc.terminate()

	# By default logging prints to stderr, which makes it difficult to detect
	# errors. This solution isn't great, but works for now.
	stderr = proc.stderr.read()
	if stderr and 'Traceback' in stderr:
		raise Exception("\n\n" + stderr)

########NEW FILE########
__FILENAME__ = test_scheduler
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from unittest import TestCase
from mock import Mock

from horizons.scheduler import Scheduler

class TestScheduler(TestCase):

	def setUp(self):
		self.callback = Mock()
		self.timer = Mock()
		Scheduler.create_instance(self.timer)
		self.scheduler = Scheduler()
		self.timer.reset_mock()

	def tearDown(self):
		Scheduler.destroy_instance()

	def test_create_then_register_with_timer(self):
		# create a new scheduler but do not reset timer mock
		Scheduler.destroy_instance()
		Scheduler.create_instance(self.timer)
		self.scheduler = Scheduler()
		self.timer.add_call.assert_called_once_with(self.scheduler.tick)

	def test_end_then_unregister_from_timer(self):
		self.scheduler.end()
		self.timer.remove_call.assert_called_once_with(self.scheduler.tick)

	def test_multiple_sequential_ticks(self):
		self.scheduler.before_ticking()
		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.assertEqual(Scheduler.FIRST_TICK_ID, self.scheduler.cur_tick)
		self.scheduler.tick(Scheduler.FIRST_TICK_ID+1)
		self.assertEqual(Scheduler.FIRST_TICK_ID+1, self.scheduler.cur_tick)
		self.scheduler.tick(Scheduler.FIRST_TICK_ID+2)
		self.assertEqual(Scheduler.FIRST_TICK_ID+2, self.scheduler.cur_tick)

	def test_fail_when_missing_start_tick(self):
		def tick():
			self.scheduler.tick(Scheduler.FIRST_TICK_ID+1)
		self.scheduler.before_ticking()
		self.assertRaises(Exception, tick)

	def test_fail_when_same_tick_twice(self):
		def tick():
			self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.scheduler.before_ticking()
		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.assertRaises(Exception, tick)

	def test_add_callback_before_first_tick(self):
		self.scheduler.add_new_object(self.callback, None, run_in=0)
		self.scheduler.before_ticking()
		self.callback.assert_called_once_with()

	def test_add_callback_run_in_1_on_first_tick(self):
		self.scheduler.add_new_object(self.callback, None, run_in=1)
		self.scheduler.before_ticking()
		self.assertFalse(self.callback.called)

		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.callback.assert_called_once_with()

	def test_add_callback_only_triggered_once(self):
		self.scheduler.before_ticking()
		self.scheduler.add_new_object(self.callback, None, run_in=2)
		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.assertFalse(self.callback.called)

		self.scheduler.tick(Scheduler.FIRST_TICK_ID+1) # callback called here
		self.callback.reset_mock()

		self.scheduler.tick(Scheduler.FIRST_TICK_ID+2)
		self.assertFalse(self.callback.called)

	def test_started_ticking_then_add_callback_for_next_tick(self):
		self.scheduler.before_ticking()
		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.scheduler.add_new_object(self.callback, None, run_in=0)
		self.assertFalse(self.callback.called)

		self.scheduler.tick(Scheduler.FIRST_TICK_ID+1)
		self.callback.assert_called_once_with()

	def test_started_ticking_then_add_callback_for_future(self):
		self.scheduler.before_ticking()
		self.scheduler.add_new_object(self.callback, None, run_in=2)
		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.assertFalse(self.callback.called)

		self.scheduler.tick(Scheduler.FIRST_TICK_ID+1)
		self.callback.assert_called_once_with()

	def test_within_callback_add_new_callback_for_same_tick(self):
		self.scheduler.before_ticking()
		callback2 = Mock()
		def add_callback():
			self.scheduler.add_new_object(callback2, None, run_in=0)
		self.callback.side_effect = add_callback

		self.scheduler.add_new_object(self.callback, None, run_in=1)
		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		callback2.assert_called_once_with()

	def test_within_callback_add_new_callback_for_future_tick(self):
		self.scheduler.before_ticking()
		callback2 = Mock()
		def add_callback():
			self.scheduler.add_new_object(callback2, None, run_in=1)
		self.callback.side_effect = add_callback

		self.scheduler.add_new_object(self.callback, None, run_in=1)
		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.assertFalse(callback2.called)
		self.scheduler.tick(Scheduler.FIRST_TICK_ID+1)
		callback2.assert_called_once_with()

	def test_add_periodic_callback_called_every_tick_3_times(self):
		self.scheduler.before_ticking()
		self.scheduler.add_new_object(self.callback, None, run_in=1, loops=4)
		for i in xrange(Scheduler.FIRST_TICK_ID, 4):
			self.scheduler.tick(i)
			self.callback.assert_called_once_with()
			self.callback.reset_mock()

		self.scheduler.tick(4)
		self.assertFalse(self.callback.called)

	def test_add_periodic_callback_run_every_other_tick_3_times(self):
		self.scheduler.before_ticking()
		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.scheduler.add_new_object(self.callback, None, run_in=1, loops=3, loop_interval=2)

		for i in xrange(Scheduler.FIRST_TICK_ID+1, 7):
			self.scheduler.tick(i)
			if (i % 2 - 1 == 0):
				self.callback.assert_called_once_with()
				self.callback.reset_mock()
			else:
				self.assertFalse(self.callback.called)

		self.scheduler.tick(7)
		self.assertFalse(self.callback.called)

	def test_remove_call_from_instance(self):
		self.scheduler.before_ticking()
		instance1 = Mock()
		instance2 = Mock()
		self.scheduler.add_new_object(self.callback, instance1, run_in=1)
		self.scheduler.add_new_object(self.callback, instance2, run_in=1)
		self.scheduler.rem_call(instance1, self.callback)
		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.callback.assert_called_once_with() # instance2 callback kept

	def test_list_and_manually_remove_all_classinstance_callbacks(self):
		self.scheduler.before_ticking()
		instance1 = Mock()
		self.scheduler.add_new_object(self.callback, instance1, run_in=1)
		self.scheduler.add_new_object(self.callback, instance1, run_in=1)

		callbacks = self.scheduler.get_classinst_calls(instance1)
		for callback in callbacks:
			self.scheduler.rem_object(callback)
		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.assertFalse(self.callback.called)

	def test_remove_all_classinstance_callbacks(self):
		self.scheduler.before_ticking()
		instance1 = Mock()
		self.scheduler.add_new_object(self.callback, instance1, run_in=1)
		self.scheduler.add_new_object(self.callback, instance1, run_in=1)

		self.scheduler.rem_all_classinst_calls(instance1)
		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.assertFalse(self.callback.called)

	def test_get_remaining_tick_until_callback(self):
		self.scheduler.before_ticking()
		instance = Mock()
		self.scheduler.add_new_object(self.callback, instance, run_in=2)
		self.assertEqual(2, self.scheduler.get_remaining_ticks(instance, self.callback))

		self.scheduler.tick(Scheduler.FIRST_TICK_ID)
		self.assertEqual(1, self.scheduler.get_remaining_ticks(instance, self.callback))

	def test_get_remaining_tick_periodic_callback(self):
		self.scheduler.before_ticking()
		instance = Mock()
		self.scheduler.add_new_object(self.callback, instance, run_in=1, loops=2, loop_interval=3)
		self.assertEqual(1, self.scheduler.get_remaining_ticks(instance, self.callback))

		self.scheduler.tick(Scheduler.FIRST_TICK_ID) # first time fired
		self.assertEqual(3, self.scheduler.get_remaining_ticks(instance, self.callback))
		self.scheduler.tick(Scheduler.FIRST_TICK_ID+1)
		self.assertEqual(2, self.scheduler.get_remaining_ticks(instance, self.callback))
		self.scheduler.tick(Scheduler.FIRST_TICK_ID+2)
		self.assertEqual(1, self.scheduler.get_remaining_ticks(instance, self.callback))

########NEW FILE########
__FILENAME__ = test_timer
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from unittest import TestCase
from mock import Mock, MagicMock, patch

from horizons.timer import Timer
from horizons.scheduler import Scheduler
from horizons.constants import GAME_SPEED

class TestTimer(TestCase):

	TICK_START = Scheduler.FIRST_TICK_ID
	TICK_PER_SEC = GAME_SPEED.TICKS_PER_SECOND

	TIME_START = 1000
	TIME_TICK = 1.0 / TICK_PER_SEC

	def setUp(self):
		self.callback = Mock()
		self.test = Mock()
		# Mock fife
		self.fife = Mock()
		self.pump = MagicMock()
		self.fife.pump = self.pump
		self.fifePatcher = patch('horizons.globals.fife', self.fife)
		self.fifePatcher.start()
		# Mock system time
		self.timePatcher = patch('time.time')
		self.clock = self.timePatcher.start()
		self.clock.return_value = self.TIME_START
		# Create timer
		self.timer = Timer(freeze_protection=False)
		self.timer.ticks_per_second = self.TICK_PER_SEC
		self.timer.add_call(self.callback)

	def tearDown(self):
		self.fifePatcher.stop()
		self.timePatcher.stop()

	def test_activate_register_end_unregister_from_pump(self):
		self.timer.activate()
		self.fife.pump.append.assert_called_once_with(self.timer.check_tick)
		self.fife.pump.__contains__.return_value = True
		self.timer.end()
		self.fife.pump.remove.assert_called_once_with(self.timer.check_tick)

	def test_first_pump_then_one_tick(self):
		self.timer.check_tick()
		self.callback.assert_called_once_with(TestTimer.TICK_START)

	def test_two_pump_same_time_only_one_tick(self):
		self.timer.check_tick()
		self.timer.check_tick()
		self.callback.assert_called_once_with(TestTimer.TICK_START)

	def test_two_pump_with_delay_then_two_ticks(self):
		self.timer.check_tick()
		self.callback.reset_mock()
		self.clock.return_value = self.TIME_START + self.TIME_TICK
		self.timer.check_tick()
		self.callback.assert_called_once_with(TestTimer.TICK_START + 1)

	def test_two_pump_close_in_time_then_only_one_tick(self):
		self.timer.check_tick()
		self.callback.reset_mock()
		self.clock.return_value = self.TIME_START + (self.TIME_TICK / 2)
		self.timer.check_tick()
		self.assertFalse(self.callback.called)

	def test_fast_pumping_only_tick_alternately(self):
		# tick 1
		self.timer.check_tick()
		self.clock.return_value = self.TIME_START + (0.5 * self.TIME_TICK)
		self.timer.check_tick()
		# tick 2
		self.callback.reset_mock()
		self.clock.return_value = self.TIME_START + (1.0 * self.TIME_TICK)
		self.timer.check_tick()
		self.callback.assert_called_once_with(TestTimer.TICK_START + 1)
		self.callback.reset_mock()
		self.clock.return_value = self.TIME_START + (1.5 * self.TIME_TICK)
		self.timer.check_tick()
		self.assertFalse(self.callback.called)

	def test_slow_pump_multiple_ticks(self):
		self.timer.check_tick()
		self.clock.return_value = self.TIME_START + (3.0 * self.TIME_TICK)
		self.callback.reset_mock()
		self.timer.check_tick()
		expected = [((self.TICK_START + 1,),), ((self.TICK_START + 2,),), ((self.TICK_START + 3,),)]
		self.assertEquals(expected, self.callback.call_args_list)

	def test_paused_pump_then_no_ticks(self):
		self.timer.check_tick()
		self.callback.reset_mock()
		self.timer.ticks_per_second = 0
		self.clock.return_value = self.TIME_START + self.TIME_TICK
		self.timer.check_tick()
		self.assertFalse(self.callback.called)

	def test_pause_pump_unpack_pump(self):
		self.timer.check_tick()
		self.timer.ticks_per_second = 0
		self.clock.return_value = self.TIME_START + (1.0 * self.TIME_TICK)
		self.timer.check_tick()

		self.timer.ticks_per_second = self.TICK_PER_SEC
		self.clock.return_value = self.TIME_START + (1.0 * self.TIME_TICK)
		self.callback.reset_mock()
		self.timer.check_tick()
		self.callback.assert_called_once_with(TestTimer.TICK_START + 1)

	def test_pause_on_callback(self):
		def set_paused(tick_id):
			self.timer.ticks_per_second = 0
		self.callback.side_effect = set_paused
		self.timer.check_tick()

		self.clock.return_value = self.TIME_START + (1.0 * self.TIME_TICK)
		self.callback.side_effect = None
		self.callback.reset_mock()
		self.timer.check_tick()
		self.assertFalse(self.callback.called)

	def test_freeze_protection(self):
		self.timer = Timer(freeze_protection=True)
		self.timer.ticks_per_second = self.TICK_PER_SEC
		self.timer.add_call(self.callback)
		self.timer.check_tick()
		self.callback.reset_mock()

		self.clock.return_value = self.TIME_START + (1.01 * self.TIME_TICK) + Timer.ACCEPTABLE_TICK_DELAY
		self.timer.check_tick()
		self.assertTrue(self.callback.called) # some number of ticks depending on tick delay
		self.callback.reset_mock()

		# will tick once after defer timeout
		self.clock.return_value = self.TIME_START + (2.02 * self.TIME_TICK) + Timer.DEFER_TICK_ON_DELAY_BY
		self.timer.check_tick()
		self.callback.assert_called_once_with(TestTimer.TICK_START + 2)

	def test_pump_test_func_pass(self):
		self.test.return_value = Timer.TEST_PASS
		self.timer.add_test(self.test)
		self.timer.check_tick()
		self.assertTrue(self.callback.called)

	def test_pump_test_func_skip(self):
		self.test.return_value = Timer.TEST_SKIP
		self.timer.add_test(self.test)
		self.timer.check_tick()
		self.assertFalse(self.callback.called)

########NEW FILE########
__FILENAME__ = test_color
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from horizons.util.color import Color
from tests.unittests import TestCase


class TestColor(TestCase):

	def setUp(self):
		super(TestColor, self).setUp()

		self.db.execute_many(
			"INSERT INTO colors VALUES(?, ?, ?, ?, ?, ?)",
			[('black', 0, 0, 0, 255, 1),
			 ('red', 255, 0, 0, 255, 2)]
		)

	def test_iter(self):
		colors = list(Color)
		self.assertEqual(len(colors), 2)
		self.assertTrue(all(c.is_default_color for c in colors))
		self.assertEqual(colors[0], Color(0, 0, 0, 255))
		self.assertEqual(colors[1], Color(255, 0, 0, 255))

	def test_default_color(self):
		self.assertTrue(Color(0, 0, 0, 255).is_default_color)
		self.assertFalse(Color(1, 2, 3, 255).is_default_color)

	def test_comparison(self):
		self.assertEqual(Color(0, 0, 0, 255), Color(0, 0, 0, 255))
		self.assertNotEqual(Color(0, 0, 0, 255), Color(1, 2, 3, 255))

	def test_indexing(self):
		self.assertEqual(Color[1], Color(0, 0, 0, 255))
		self.assertEqual(Color['black'], Color(0, 0, 0, 255))

########NEW FILE########
__FILENAME__ = test_registry
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import unittest

from horizons.util.python.registry import Registry


class RegistryTest(unittest.TestCase):

	def test_simple(self):
		class Example(object):
			__metaclass__ = Registry
			@classmethod
			def register_function(cls, func):
				cls.registry[func.__name__] = func

		self.assertRaises(KeyError, Example.get, 'foo')

		@Example.register()
		def foo(a, b):
			return a + b

		self.assertEqual(Example.get('foo'), foo)

	def test_with_arguments(self):
		"""Test arguments in the register decorator."""
		class Example(object):
			__metaclass__ = Registry
			@classmethod
			def register_function(cls, func, name):
				cls.registry[name] = func

		self.assertRaises(KeyError, Example.get, 'foo')

		@Example.register(name='bar')
		def foo(a, b):
			return a + b

		self.assertRaises(KeyError, Example.get, 'foo')
		self.assertEqual(Example.get('bar'), foo)

########NEW FILE########
__FILENAME__ = test_shapes
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import unittest

from horizons.util.shapes import Circle, Point, Rect

class TestPathfinding(unittest.TestCase):

	def testPoint(self):
		p1 = Point(0,0)
		p2 = Point(0,2)
		self.assertEqual(p1.distance(p2), 2)
		self.assertEqual(p1.distance((0,1)), 1)
		self.assertEqual(p1.get_coordinates(), [(0,0)])
		self.assertEqual(p1, p1.copy())

	def testRect(self):
		r1 = Rect(Point(0,0), 1, 1)
		r2 = Rect(0, 0, 1, 1)
		r3 = Rect(Point(2, 2), 1, 1)
		self.assertEqual(r1, r2)
		self.assertTrue(r1 == r2)
		self.assertFalse(r1.contains(Point(-1,-1)))
		self.assertTrue(r2.contains(Point(0,0)))
		self.assertTrue(r2.contains(Point(1,1)))
		self.assertTrue(r1.intersects(r2))
		self.assertFalse(r1.intersects(r3))

	def testCircle(self):
		c1 = Circle(Point(0,0), 1)
		c2 = Circle(Point(0,0), 2)
		c3 = Circle(Point(0,0), 0)
		self.assertFalse(c1 == c2)
		self.assertTrue(c1 != c2)
		self.assertNotEqual(c1, c2)
		self.assertEqual(c1.get_coordinates(), [(-1, 0), (0, -1), (0, 0), (0, 1), (1, 0)])
		self.assertEqual(c3.get_coordinates(), [(0,0)])

########NEW FILE########
__FILENAME__ = test_connectedareacache
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.unittests import TestCase

from horizons.world.buildability.connectedareacache import ConnectedAreaCache

class TestConnectedAreaCache(TestCase):
	def test(self):
		cache = ConnectedAreaCache()
		self.assertEquals(0, len(cache.areas))

		cache.add_area([(0, 0), (1, 1)])
		self.assertEquals(2, len(cache.areas))
		self.assertEquals(set([(0, 0)]), cache.areas[cache.area_numbers[(0, 0)]])
		self.assertEquals(set([(1, 1)]), cache.areas[cache.area_numbers[(1, 1)]])

		cache.add_area([(1, 4), (1, 3), (1, 2)])
		self.assertEquals(2, len(cache.areas))
		self.assertEquals(set([(0, 0)]), cache.areas[cache.area_numbers[(0, 0)]])
		self.assertEquals(set([(1, 1), (1, 2), (1, 3), (1, 4)]), cache.areas[cache.area_numbers[(1, 1)]])

		cache.add_area([(0, 1)])
		self.assertEquals(1, len(cache.areas))
		self.assertEquals(set([(0, 0), (0, 1), (1, 1), (1, 2), (1, 3), (1, 4)]), cache.areas[cache.area_numbers[(0, 0)]])

		cache.remove_area([(0, 1)])
		self.assertEquals(2, len(cache.areas))
		self.assertEquals(set([(0, 0)]), cache.areas[cache.area_numbers[(0, 0)]])
		self.assertEquals(set([(1, 1), (1, 2), (1, 3), (1, 4)]), cache.areas[cache.area_numbers[(1, 1)]])

		cache.remove_area([(0, 0)])
		self.assertFalse((0, 0) in cache.area_numbers)
		self.assertEquals(1, len(cache.areas))
		self.assertEquals(set([(1, 1), (1, 2), (1, 3), (1, 4)]), cache.areas[cache.area_numbers[(1, 1)]])

		cache.remove_area([(1, 2), (1, 3)])
		self.assertEquals(2, len(cache.areas))
		self.assertEquals(set([(1, 1)]), cache.areas[cache.area_numbers[(1, 1)]])
		self.assertEquals(set([(1, 4)]), cache.areas[cache.area_numbers[(1, 4)]])

		cache.remove_area([(1, 1), (1, 4)])
		self.assertEquals(0, len(cache.areas))

########NEW FILE########
__FILENAME__ = test_partialbinarycache
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.unittests import TestCase

from horizons.world.buildability.partialbinarycache import PartialBinaryBuildabilityCache
from horizons.world.buildability.terraincache import TerrainBuildabilityCache

class MockTerrainBuildabilityCache(object):
	sizes = TerrainBuildabilityCache.sizes

	def __init__(self, land_or_coast):
		self.land_or_coast = land_or_coast

class TestPartialBinaryBuildabilityCache(TestCase):
	def setUp(self):
		super(TestPartialBinaryBuildabilityCache, self).setUp()
		coords_list = []
		for x in xrange(10):
			for y in xrange(10):
				coords_list.append((x, y))
		self.terrain_cache = MockTerrainBuildabilityCache(coords_list)
		self.buildability_cache = PartialBinaryBuildabilityCache(self.terrain_cache)

	def test_horizontal_row2(self):
		bc = self.buildability_cache
		self.assertEquals(bc._row2, set())

		# ..... -> ..#..
		bc.add_area([(2, 1)])
		self.assertEquals(bc._row2, set([(1, 1), (2, 1)]))

		# ..#.. -> ..##.
		bc.add_area([(3, 1)])
		self.assertEquals(bc._row2, set([(1, 1), (2, 1), (3, 1)]))

		# ..##. -> .###.
		bc.add_area([(1, 1)])
		self.assertEquals(bc._row2, set([(0, 1), (1, 1), (2, 1), (3, 1)]))

		# .###. -> .#.#.
		bc.remove_area([(2, 1)])
		self.assertEquals(bc._row2, set([(0, 1), (1, 1), (2, 1), (3, 1)]))

		# .#.#. -> ...#.
		bc.remove_area([(1, 1)])
		self.assertEquals(bc._row2, set([(2, 1), (3, 1)]))

		# ...#. -> .....
		bc.remove_area([(3, 1)])
		self.assertEquals(bc._row2, set())

	def test_vertical_row2(self):
		bc = self.buildability_cache
		self.assertEquals(bc._row2, set())

		bc.add_area([(1, 1)])
		self.assertEquals(bc._row2, set([(0, 1), (1, 1)]))

		bc.add_area([(2, 2)])
		self.assertEquals(bc._row2, set([(0, 1), (1, 1), (1, 2), (2, 2)]))

		bc.add_area([(2, 3)])
		self.assertEquals(bc._row2, set([(0, 1), (1, 1), (1, 2), (2, 2), (1, 3), (2, 3)]))

		bc.remove_area([(2, 3)])
		self.assertEquals(bc._row2, set([(0, 1), (1, 1), (1, 2), (2, 2)]))

		bc.remove_area([(2, 2)])
		self.assertEquals(bc._row2, set([(0, 1), (1, 1)]))

		bc.remove_area([(1, 1)])
		self.assertEquals(bc._row2, set())

	def test_r2x2(self):
		bc = self.buildability_cache
		r2x2 = bc.cache[(2, 2)]
		self.assertEquals(r2x2, set())

		bc.add_area([(1, 1)])
		self.assertEquals(r2x2, set([(0, 0), (0, 1), (1, 0), (1, 1)]))

		bc.add_area([(2, 1)])
		self.assertEquals(r2x2, set([(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]))

		bc.add_area([(3, 2)])
		self.assertEquals(r2x2, set([(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (3, 1), (3, 2)]))

		bc.remove_area([(2, 1)])
		self.assertEquals(r2x2, set([(0, 0), (0, 1), (1, 0), (1, 1), (2, 1), (2, 2), (3, 1), (3, 2)]))

		bc.remove_area([(3, 2)])
		self.assertEquals(r2x2, set([(0, 0), (0, 1), (1, 0), (1, 1)]))

		bc.remove_area([(1, 1)])
		self.assertEquals(r2x2, set())

	@classmethod
	def _get_coords_set(cls, x, y, width, height):
		res = set()
		for dx in xrange(width):
			for dy in xrange(height):
				res.add((x - dx, y - dy))
		return res

	def test_convenience_get_coords_list(self):
		self.assertEquals(self._get_coords_set(1, 1, 2, 1), set([(0, 1), (1, 1)]))
		self.assertEquals(self._get_coords_set(1, 1, 1, 2), set([(1, 0), (1, 1)]))
		self.assertEquals(self._get_coords_set(1, 1, 2, 2), set([(0, 0), (0, 1), (1, 0), (1, 1)]))

	def test_r6x6(self):
		bc = self.buildability_cache
		r6x6 = bc.cache[(6, 6)]
		self.assertEquals(r6x6, set())

		bc.add_area([(7, 7)])
		self.assertEquals(r6x6, self._get_coords_set(7, 7, 6, 6))

		bc.add_area([(8, 7)])
		self.assertEquals(r6x6, self._get_coords_set(7, 7, 6, 6).union(self._get_coords_set(8, 7, 6, 6)))

		bc.add_area([(5, 5)])
		self.assertEquals(r6x6, self._get_coords_set(7, 7, 6, 6).union(self._get_coords_set(8, 7, 6, 6), self._get_coords_set(5, 5, 6, 6)))

		bc.remove_area([(5, 5), (7, 7)])
		self.assertEquals(r6x6, self._get_coords_set(8, 7, 6, 6))

		bc.remove_area([(8, 7)])
		self.assertEquals(r6x6, set())

########NEW FILE########
__FILENAME__ = test_healthcomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from unittest import TestCase

from horizons.ext.dummy import Dummy
from horizons.component.healthcomponent import HealthComponent

from mock import Mock


class TestHealthComponent(TestCase):

	def setUp(self):
		self.instance = Mock()
		self.instance.session = Dummy()

		self.component = HealthComponent(20)
		self.component.instance = self.instance
		self.component.initialize()

	def test_trivial(self):
		self.assertEqual(self.component.health, 20)
		self.assertEqual(self.component.max_health, 20)

	def test_maxhealth_required(self):
		self.assertRaises(AssertionError, HealthComponent, None)

	def test_damage(self):
		self.component.deal_damage(1, 19)
		self.assertEqual(self.component.health, 1)
		self.assertEqual(self.component.max_health, 20)
		self.assertFalse(self.instance.remove.called)

	def test_damage_zero_health(self):
		self.component.deal_damage(1, 20)
		self.assertEqual(self.component.health, 0)
		self.assertEqual(self.component.max_health, 20)
		self.assertTrue(self.instance.remove.called)

	def test_huge_damage(self):
		self.component.deal_damage(1, 300)
		self.assertEqual(self.component.health, 0)
		self.assertEqual(self.component.max_health, 20)
		self.assertTrue(self.instance.remove.called)

########NEW FILE########
__FILENAME__ = test_namedcomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from unittest import TestCase

from horizons.component.namedcomponent import NamedComponent

class MockNameComponent(NamedComponent):
	def _possible_names(self):
		return [u'Test']

class TestNamedComponent(TestCase):
	def tearDown(self):
		NamedComponent.reset()

	@classmethod
	def make_component(cls, name=None):
		class Instance(object):
			def __init__(self):
				super(Instance, self).__init__()
				self.instance = self
				self.session = self
				self.random = self

			def choice(self, seq):
				return seq[0]

		component = MockNameComponent(name)
		component.instance = Instance()
		component.initialize()
		return component

	def test_new_default_name(self):
		component = self.make_component()
		self.assertEquals(component.name, u'Test')
		component2 = self.make_component()
		self.assertEquals(component2.name, u'Test 2')
		component3 = self.make_component()
		self.assertEquals(component3.name, u'Test 3')

	def test_duplicates(self):
		component = self.make_component()
		self.assertEquals(component.name, u'Test')
		component2 = self.make_component()
		self.assertEquals(component2.name, u'Test 2')
		component2.set_name('Test')
		self.assertEquals(component.name, u'Test')
		self.assertEquals(component2.name, u'Test')

		component.set_name(u'Test name')
		component3 = self.make_component()
		self.assertEquals(component3.name, u'Test 2')

		component2.set_name(u'Test name')
		component4 = self.make_component()
		self.assertEqual(component4.name, u'Test')

	def test_rename_none(self):
		component = self.make_component()
		self.assertEquals(component.name, u'Test')
		component.set_name(u'Test name')
		self.assertEquals(component.name, u'Test name')
		component.set_name(None)
		self.assertEquals(component.name, u'Test')

	def test_new_named_object(self):
		component = self.make_component(u'Test name')
		self.assertEquals(component.name, u'Test name')
		component2 = self.make_component(u'Test name')
		self.assertEqual(component2.name, u'Test name')

	def test_unchanged_rename(self):
		component = self.make_component()
		self.assertEquals(component.name, u'Test')
		component.set_name(u'Test')
		self.assertEquals(component.name, u'Test')
		component2 = self.make_component()
		self.assertEquals(component2.name, u'Test 2')

########NEW FILE########
__FILENAME__ = test_tradepostcomponent
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from unittest import TestCase

from horizons.constants import RES
from horizons.scheduler import Scheduler
from horizons.world.storage import GenericStorage
from horizons.component.tradepostcomponent import TradePostComponent

class TestTradePostComponent(TestCase):
	"""
	TODO: buy_resource, sell_resource (needs ships and player concept)
	"""

	def setUp(self):
		self.inventory = GenericStorage()
		self.owner_inventory = GenericStorage()

		class Instance(object):
			def __init__(self, comp):
				self.comp = comp
			def get_component(self, x):
				class Comp(object):
					inventory = self.comp
				return Comp()

		self.tradepost = TradePostComponent()
		self.tradepost.instance = Instance(self.inventory)
		self.tradepost.instance.owner = Instance(self.owner_inventory)
		self.tradepost.initialize()

		class Timer(object):
			def add_call(self, x):
				pass
			def get_ticks(self, x):
				return 100
		Scheduler.create_instance(timer=Timer())

	def tearDown(self):
		Scheduler.destroy_instance()

	def test_buy(self):
		self.owner_inventory.alter(RES.GOLD, 1)
		self.assertFalse(self.tradepost.buy(1, 1, 1, 100))
		self.tradepost.set_slot(0, 1, False, 2)
		self.assertTrue(self.tradepost.buy(1, 1, 1, 100))
		self.assertEqual(self.tradepost.buy_expenses, 1)

		Scheduler().cur_tick += 1

		# ran out of money
		self.assertFalse(self.tradepost.buy(1, 1, 1, 100))

		self.owner_inventory.alter(RES.GOLD, 2)
		self.assertTrue(self.tradepost.buy(1, 1, 1, 100))

		Scheduler().cur_tick += 1

		# only wanted to buy 2
		self.assertFalse(self.tradepost.buy(1, 1, 1, 100))

		self.inventory.alter(1, -2)
		self.assertTrue(self.tradepost.buy(1, 1, 1, 100))

		self.tradepost.clear_slot(0, True)
		# not buying any more
		self.assertFalse(self.tradepost.buy(1, 1, 1, 100))
		self.assertEqual(self.tradepost.buy_expenses, 3)
		self.assertEqual(self.tradepost.total_expenses, 3)

	def test_sell(self):
		self.inventory.alter(1, 1)
		self.assertFalse(self.tradepost.sell(1, 1, 1, 100))
		self.tradepost.set_slot(0, 1, True, 0) # sell until 0
		self.assertTrue(self.tradepost.sell(1, 1, 1, 100))
		self.assertEqual(self.tradepost.sell_income, 1)

		Scheduler().cur_tick += 1

		# ran out of res
		self.assertFalse(self.tradepost.sell(1, 1, 1, 100))

		Scheduler().cur_tick += 1

		self.inventory.alter(1, 1)
		self.assertTrue(self.tradepost.sell(1, 1, 1, 100))


		self.tradepost.clear_slot(0, True)
		# not selling any more
		self.assertFalse(self.tradepost.sell(1, 1, 1, 100))
		self.assertEqual(self.tradepost.sell_income, 2)
		self.assertEqual(self.tradepost.total_earnings, 2)

########NEW FILE########
__FILENAME__ = test_productionline
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.unittests import TestCase

from horizons.world.production.productionline import ProductionLine


class TestBase(TestCase):

	def add_line(self, ident, units=None):
		"""Add a new production line
		@param ident: numeric value
		@param time: production time
		@param changes_animation: bool
		@param resources: mapping of {resource: amount}
		@param units: mapping of {unit: amount}
		"""
		if units:
			self.db.execute_many(
				'INSERT INTO unit_production (production_line, unit, amount) \
				 VALUES (?, ?, ?)',
				[(ident, unit, amount) for (unit, amount) in units.items()]
			)


class TestProductionLineData(TestBase):

	def test_init(self):
		# NOTE: this has been broken by optimizations and will soon be moved to yaml, therefore not fixing it now
		#self.add_line(1, {10: 4, 12: 8})

		data = {'enabled_by_default': False,
		        'time': 90,
		        'level': [0, 1, 2],
		        'changes_animation': False,
		        'produces': [[14, 1]],
		        'consumes': [[19, -1]]
		}
		data = ProductionLine(1, data)
		self.assertEqual(data.time, 90)
		self.assertEqual(data.changes_animation, False)
		self.assertEqual(data.production, {14: 1, 19: -1})
		self.assertEqual(data.produced_res, {14: 1})
		self.assertEqual(data.consumed_res, {19: -1})
		#self.assertEqual(data.unit_production, {10: 4, 12: 8})

class TestProductionLine(TestBase):

	def setUp(self):
		"""Clear ProductionLine cache."""
		super(TestProductionLine, self).setUp()

	def test_alter_production_time(self):
		data = { 'time': 10 }
		line = ProductionLine(1, data)

		self.assertEqual(line.time, 10)

		line.alter_production_time(2)
		self.assertEqual(line.time, 20)

		# Test that it modifies the original value (10)
		line.alter_production_time(2)
		self.assertEqual(line.time, 20)

		line.alter_production_time(1.5)
		self.assertEqual(line.time, 15.0)

		# should this throw an error?
		# line.alter_production_time(0)

	def test_change_amount(self):
		data = {
		        'time': 10,
		        'produces': [[2, 3]],
		        'consumes': [[4, -5]]
		}
		line = ProductionLine(1, data)

		line.change_amount(2, 10)
		self.assertEqual(line.production, {2: 10, 4: -5})
		self.assertEqual(line.produced_res, {2: 10})
		self.assertEqual(line.consumed_res, {4: -5})

		line.change_amount(4, -1)
		self.assertEqual(line.production, {2: 10, 4: -1})
		self.assertEqual(line.produced_res, {2: 10})
		self.assertEqual(line.consumed_res, {4: -1})

		# should these throw an error?
		# line.change_amount(X, 0)
		# line.change_amount(2, -3) - produced becomes consumed
		# line.change_amount(4, 3)  - consumed becomes produced

########NEW FILE########
__FILENAME__ = test_component
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################


from unittest import TestCase

from horizons.component import Component


class A(Component):
	NAME = 'A'

class B(Component):
	NAME = 'B'
	DEPENDENCIES = [A]

class C(Component):
	NAME = 'C'


class TestComponent(TestCase):

	def test_dependencysorting(self):
		a = A()
		b = B()
		components = [b, C(), a]
		components.sort()
		self.assertTrue(components.index(b) > components.index(a))
		# Trigger __lt__
		self.assertFalse(b < a)
		self.assertTrue(a < b)
		# Trigger __gt__
		self.assertTrue(b > a)
		self.assertFalse(a > b)

########NEW FILE########
__FILENAME__ = test_storage
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import sys
from unittest import TestCase

from horizons.world.storage import (GenericStorage, SpecializedStorage, SizedSpecializedStorage,
                                    TotalStorage, GlobalLimitStorage, PositiveStorage,
                                    PositiveTotalStorage, PositiveSizedSlotStorage,
                                    PositiveSizedNumSlotStorage)


class TestGenericStorage(TestCase):

	def test_alter(self):
		s = GenericStorage()
		self.assertEqual(s.alter(1, 5), 0)
		self.assertEqual(s.alter(2, 3), 0)
		self.assertEqual(s[1], 5)
		self.assertEqual(s[2], 3)

		self.assertEqual(s.alter(1, 10), 0)
		self.assertEqual(s[1], 15)

	def test_reset(self):
		s = GenericStorage()
		s.alter(1, 5)
		s.alter(2, 3)
		s.reset(1)
		self.assertEqual(s[1], 0)
		self.assertEqual(s[2], 3)

	def test_reset_all(self):
		s = GenericStorage()
		s.alter(1, 5)
		s.alter(2, 3)
		s.reset_all()
		self.assertEqual(s[1], 0)
		self.assertEqual(s[2], 0)

	def test_limit(self):
		s = GenericStorage()
		self.assertEqual(s.get_limit(), sys.maxint)
		self.assertEqual(s.get_limit(1), sys.maxint)

	def test_sum_of_stored_resources(self):
		s = GenericStorage()
		s.alter(1, 5)
		s.alter(2, 3)
		self.assertEqual(s.get_sum_of_stored_resources(), 8)

	def test_get_item(self):
		s = GenericStorage()
		s.alter(1, 5)
		self.assertEqual(s[1], 5)
		self.assertEqual(s[2], 0)


class TestSpecializedStorages(TestCase):

	def test_specialized(self):
		s = SpecializedStorage()

		self.assertEqual(s.alter(1, 3), 3)
		self.assertEqual(s.alter(1, -3), -3)

		self.assertFalse(s.has_resource_slot(1))
		s.add_resource_slot(1)
		self.assertTrue(s.has_resource_slot(1))

		self.assertEqual(s.alter(1, 3), 0)
		self.assertEqual(s.alter(1, -3), 0)

	def test_sized_specialized(self):
		s = SizedSpecializedStorage()

		self.assertEqual(s.alter(1, 3), 3)
		self.assertEqual(s.alter(1, -3), -3)
		self.assertEqual(s.get_limit(1), 0)

		self.assertFalse(s.has_resource_slot(1))
		s.add_resource_slot(1, 10)
		self.assertTrue(s.has_resource_slot(1))
		self.assertEqual(s.get_limit(1), 10)

		self.assertEqual(s.get_free_space_for(1), 10)
		self.assertEqual(s.alter(1, 3), 0)
		self.assertEqual(s.get_free_space_for(1), 7)
		self.assertEqual(s.alter(1, -3), 0)
		self.assertEqual(s.get_free_space_for(1), 10)

		self.assertEqual(s.alter(1, 12), 2)


class TestGlobalLimitStorage(TestCase):

	def test_adjust_limit(self):
		s = GlobalLimitStorage(10)
		self.assertEqual(s.get_limit(), 10)

		s.alter(1, 10)
		self.assertEqual(s[1], 10)
		s.adjust_limit(-5)
		self.assertEqual(s.get_limit(), 5)
		self.assertEqual(s[1], 5)

		s.adjust_limit(-10)
		self.assertEqual(s.get_limit(), 0)


class TestOtherStorages(TestCase):

	def test_total(self, s=TotalStorage(10)):

		self.assertEqual(s.get_limit(), 10)
		self.assertEqual(s.get_limit(1), 10)
		self.assertEqual(s.get_free_space_for(1), 10)
		self.assertEqual(s.get_free_space_for(2), 10)

		self.assertEqual(s.alter(2, 2), 0)

		self.assertEqual(s.get_limit(), 10)
		self.assertEqual(s.get_limit(1), 10)
		self.assertEqual(s.get_free_space_for(1), 8)
		self.assertEqual(s.get_free_space_for(2), 8)

		self.assertEqual(s.alter(2, 10), 2)

		self.assertEqual(s.get_free_space_for(1), 0)
		self.assertEqual(s.get_free_space_for(2), 0)

	def test_positive(self, s=PositiveStorage()):

		self.assertEqual(s.alter(1, -2), -2)
		self.assertEqual(s.alter(1, 2), 0)
		self.assertEqual(s.alter(1, -2), 0)
		self.assertEqual(s.alter(1, -1), -1)

	def test_positive_total(self):
		s = PositiveTotalStorage(10)
		self.test_positive(s)
		self.test_total(s)

	def test_sized_slotted(self):
		s = PositiveSizedSlotStorage(10)

		self.assertEqual(s.alter(1, 6), 0)
		self.assertEqual(s.alter(1, 6), 2)
		self.assertEqual(s.alter(1, -20), -10)

	def test_positive_sized_num_slot(self):
		s = PositiveSizedNumSlotStorage(10, 3)
		self.assertEqual(s.get_limit(), 10)
		self.assertEqual(s.get_limit(1), 10)

		self.assertEqual(s.alter(1, 10), 0)
		self.assertEqual(s.alter(1, 2), 2)

		self.assertEqual(s.alter(2, 0), 0)

		self.assertEqual(s.alter(2, 5), 0)
		self.assertEqual(s.alter(3, 5), 0)

		self.assertEqual(s.alter(4, 1), 1)

########NEW FILE########
__FILENAME__ = test_world
#!/usr/bin/env python2

# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from unittest import TestCase

from horizons.ext.dummy import Dummy

from horizons.world import World


class TestWorld(TestCase):

	def setUp(self):
		self.session = Dummy()

	def test_world_end(self):
		w = World(self.session)
		w.end()

########NEW FILE########
__FILENAME__ = test_collector
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

from tests.unittests import TestCase

from horizons.constants import RES, BUILDINGS
from horizons.world.building.production import ProductionBuilding
from horizons.world.island import Island
from horizons.world.units.collectors.collector import Job, JobList
from horizons.util.shapes import Point, Rect

class TestJobList(TestCase):

	def distance(self, test_list, ident):
		return test_list.collector.position.distance(test_list[ident].object.loading_area)

	def create_list(self, order):
		test_list = JobList(TestCollector(0, 0), order)
		test_list.append(Job(TestObject(1, 3, 3), [Job.ResListEntry(3, 4, False)]))
		test_list.append(Job(TestObject(2, 1, 1), [Job.ResListEntry(1, 2, False)]))
		test_list.append(Job(TestObject(3, 2, 2), [Job.ResListEntry(2, 3, False)]))
		return test_list

	def test_sort_distance(self):
		test_list = self.create_list(JobList.order_by.distance)
		test_list.sort_jobs()

		self.assertTrue(self.distance(test_list, 0) <= self.distance(test_list, 1))
		self.assertTrue(self.distance(test_list, 1) <= self.distance(test_list, 2))

		# Make sure everything was sorted in order
		self.assertEqual(test_list[0].object.id, 2)
		self.assertEqual(test_list[1].object.id, 3)
		self.assertEqual(test_list[2].object.id, 1)

	def test_sort_fewest_available(self):
		test_list = self.create_list(JobList.order_by.fewest_available)
		test_list._sort_jobs_fewest_available(False)

		# Make sure everything was sorted in order
		self.assertEqual(test_list[0].object.id, 3)
		self.assertEqual(test_list[1].object.id, 1)
		self.assertEqual(test_list[2].object.id, 2)

	def test_sort_fewest_available_and_distance(self):
		test_list = JobList(TestCollector(0, 0), JobList.order_by.fewest_available_and_distance)

		test_list.append(Job(TestObject(1, 3, 3), [Job.ResListEntry(2, 4, False)]))
		test_list.append(Job(TestObject(2, 1, 1), [Job.ResListEntry(1, 2, False)]))
		test_list.append(Job(TestObject(3, 2, 2), [Job.ResListEntry(2, 3, False)]))
		test_list._sort_jobs_fewest_available_and_distance()

		# Make sure everything was sorted in order of distance with secondary
		# sorting by fewest available
		self.assertEqual(test_list[0].object.id, 2)
		self.assertEqual(test_list[1].object.id, 3)
		self.assertEqual(test_list[2].object.id, 1)

	def test_sort_for_storage(self):
		test_list = JobList(TestCollector(0, 0), JobList.order_by.for_storage_collector)

		test_list.append(Job(TestObject(1, 3, 3), [Job.ResListEntry(2, 4, False)]))
		test_list.append(Job(TestObject(2, 1, 1), [Job.ResListEntry(1, 2, False)]))
		test_list.append(Job(TestObject(3, 2, 2), [Job.ResListEntry(2, 3, False)]))
		test_list.append(Job(TestObject(4, 9, 0), [Job.ResListEntry(4, 9, target_inventory_full=True)]))
		test_list.append(Job(TestObject(BUILDINGS.CLAY_DEPOSIT, 10, 5), [Job.ResListEntry(4, 9, False)]))
		test_list.sort_jobs()

		# Make sure everything was sorted in order of distance with secondary
		# sorting by fewest available and as last the clay deposit as it has a producer in range
		self.assertEqual(test_list[0].object.id, 4)
		self.assertEqual(test_list[1].object.id, 2)
		self.assertEqual(test_list[2].object.id, 3)
		self.assertEqual(test_list[3].object.id, 1)
		self.assertEqual(test_list[4].object.id, BUILDINGS.CLAY_DEPOSIT)

		# Both give res 2, but TestObject with id 3 is closer
		self.assertTrue(self.distance(test_list, 1) <= self.distance(test_list, 2))


class TestCollector(object):
	"""Dummy collector that only provides what we need to run the tests."""

	def __init__(self, x, y):
		self.position = Point(x, y)

	def get_home_inventory(self):
		"""Return a dummy inventory"""
		return {1: 3,
		        2: 1,
		        3: 2,
		        4: 8,
		        5: 4}


class TestObject(ProductionBuilding):
	"""Dummy object that acts as building as far as we need it to"""

	def __init__(self, id, x, y):
		self.id = id
		self.loading_area = Point(x, y)
		self.island = TestIsland()
		self.position = Rect(x, y, 10, 10)

	def get_produced_resources(self):
		return (RES.RAW_CLAY,)


class ClayPit(ProductionBuilding):
	"""Dummy object that acts as building as far as we need it to"""

	def __init__(self, id, x, y):
		self.id = id
		self.loading_area = Point(x, y)
		self.position = Rect(x, y, 10, 10)
		self.radius = 11

	def get_needed_resources(self):
		return (RES.RAW_CLAY,)


class TestIsland(Island):
	def __init__(self):
		self.buildings = [ClayPit(BUILDINGS.CLAY_PIT, 10, 6)]

########NEW FILE########
__FILENAME__ = utils
# ###################################################
# Copyright (C) 2008-2014 The Unknown Horizons Team
# team@unknown-horizons.org
# This file is part of Unknown Horizons.
#
# Unknown Horizons is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# ###################################################

import signal

from nose.plugins import Plugin
from nose.util import ln

# check if SIGALRM is supported, this is not the case on Windows
# we might provide an alternative later, but for now, this will do
try:
	from signal import SIGALRM
	SUPPORTED = True
except ImportError:
	SUPPORTED = False


class Timer(object):
	"""
	Example

		def handler(signum, frame):
			print 'Timer triggered'

		t = Timer(handler)
		# handler will be called after 2 seconds
		t.start(2)

		# if 2 seconds have not passed, this will stop the timer
		t.stop()

	Note: if SIGALRM is not supported, this class does nothing
	"""

	def __init__(self, handler):
		"""Install the passed function as handler that is called when the signal
		triggers.
		"""
		if not SUPPORTED:
			return

		signal.signal(signal.SIGALRM, handler)

	def start(self, timeout):
		"""Start the timer. A timeout of 0 means that the signal will never trigger."""
		if not SUPPORTED or timeout == 0:
			return

		signal.alarm(timeout)

	@classmethod
	def stop(cls):
		"""Stop the timer. This can be called on both the instance and class (when you
		have no access to the instance for example).
		"""
		if not SUPPORTED:
			return

		signal.alarm(0)


class ReRunInfoPlugin(Plugin):
	"""Print information on how to rerun a test after each failed test.

	Code to add additional output taken from the Collect plugin.
	"""
	name = 'reruninfo'
	enabled = True

	def configure(self, options, conf):
		pass

	def formatError(self, test, err):
		_, module, call = test.address()

		output = ['python2', 'run_tests.py', u'%s:%s' % (module, call)]

		# add necessary flags
		if 'tests.gui' in module:
			output.append('-a gui')
		elif 'tests.game.long' in module:
			output.append('-a long')

		output = u' '.join(output)

		ec, ev, tb = err
		return (ec, self.addOutputToErr(ev, output), tb)

	def formatFailure(self, test, err):
		return self.formatError(test, err)

	def addOutputToErr(self, ev, output):
		if isinstance(ev, Exception):
			ev = unicode(ev)
		return u'\n'.join([ev, u'', ln(u'>> rerun the test <<'), output])

########NEW FILE########
