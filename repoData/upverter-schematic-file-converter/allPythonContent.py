__FILENAME__ = LOLOLOL
import xml.etree.ElementTree as et

class eagleSchematic:
  def __init__(self, file_path):
    xml_contents = et.ElementTree()
    xml_contents.parse(file_path)
    self.json_contents
if __name__ == "__main__":
  sch = et.ElementTree()
  sch.parse('./mintyboostv3.sch')
  for thing in sch.getiterator():
    print dict({thing.tag:thing.attrib})

########NEW FILE########
__FILENAME__ = eaglet
#!/usr/bin/env python
import json,copy
eagle = json.loads(open("eagle.json").read())
a = copy.deepcopy(eagle)
basic = ["int","char","string","real"]

# Yes this is generated at import time
# Yes I know it's evil to do this much processing at import time
types = {}
for atype,members in a.items():
  for member,memtype in members.items():
    if memtype not in basic and member != memtype:
      if member not in types:
        types[member] = memtype
      elif types[member] != memtype:
        print "Error, fatal assumption broken (any given member name has exactly one type)"
        exit(1)

header = """// json.ulp - Export an EagleCAD file into JSON
// Generated by the codez in this wonderful github repo:
// http://github.com/ajray/schematic-file-converter
// Alex Ray (2011) <ajray@ncsu.edu>
"""
misc = """
string esc(string s) { // JSON string escapes
    string out = "\\""; // open quote
    for (int i = 0; s[i]; ++i) {
        switch(s[i]) {
            case '"': out += "\\""; break;
            case '\\\\': out += "\\\\\\\\"; break;
            case '/': out += "\\\\/"; break;
            case '\\b': out += "\\\\b"; break;
            case '\\f': out += "\\\\f"; break;
            case '\\n': out += "\\\\n"; break;
            case '\\r': out += "\\\\r"; break;
            case '\\t': out += "\\\\t"; break;
            default: out += s[i];
        }
    }
    out += "\\""; // close quote
    return out;
}
void print__opener (string name) { // start of an object
  printf("\\"%s\\" : {\\n",name); 
}
void print__closer () { // end of an object
  printf("}\\n"); 
}
void pl(string a) { printf("%s:[",a); } // start of a list
void ln()         { printf("]"); }      // end of a list
void print_string (string a, string b)  { printf("%s:%s",a,esc(b)); }
void print_int    (string a, int b)     { printf("%s:%d",a,b); }
void print_real   (string a, real b)    { printf("%s:%g",esc(a),b); }
"""



########NEW FILE########
__FILENAME__ = json-ulp
#!/usr/bin/env python
# json-ulp.py - generate json.ulp, which exports Eagle to JSON
# http://github.com/ajray/schematic-file-converter
# Alex Ray (2011) <ajray@ncsu.edu>
# TODO handle loop members
import copy
from eaglet import eagle, types, basic, header, misc
def typ(a):
    """ 
    Given a member name, return it's type
    Basically 'types' is a reverse-lookup for all the members
    in 'eagle.json' that is made at runtime by 'import eaglet'
    """
    if a in basic: return a
    if a in types: return types[a]
    return "UL_"+a.upper()


def printfuncheader(name):
    """ return the header to a printfunc with the given name """
    s = """
    void print_%s(%s %s_arg) {
        int a;
        print__opening("%s");
    """ % (name, typ(name), name, name)
    return s

def printfunccloser():
    """ return the closer to a printfunc """
    s = """
        print__closing();
    }
    """
    return s

def printfunc(name,members): 
    """ 
    Make a print_<type>() function for a type given it's members
    and their types

    This is code that generates code. Nasty shit 
    Basically it puts a head and a tail on it, and iterates over
    every "member" of the type, printing it.
    The end result is print functions for every type that call 
    print functions for every type within it.
    ...Like a recursive descent barfer.
    """
    print printfuncheader(name) # print the header

    com = False                     # Keeping track of commas
    for mem,mtyp in members.items(): # Member fields of each type
        if not com: com = True # Taking care of commas
        else: print 'printf(",\n");'
        if mtyp not in basic and mem != mtyp: # loop member
            loop = mem+'_loop'
            print '\tpl(%s);a=0;%s.%s(%s){'%(mem,arg,mem,loop)
            print '\t\tif(a==0)a=1;else cn();%s("%s",%s);}'%(fun,mem,loop),
        else: # Normal data member
            print '\t%s("%s",%s.%s);'%(fun,mem,mem,mem), # data member
    print printfunccloser()

if __name__ == "__main__":
    print header
    print misc
    # print functions by dependencies
    found = True
    dependencies = {"string","int","real"}
    while found:
        found = False
        for name,member in eagle.items():
            good = True
            for mem,mtyp in member.items():
                if mtyp not in dependencies:
                    good = False
            if good: # all dependencies met
                found = True
                dependencies.add(name)
                del eagle[name]
                print name
    print "=====notfound====="
    for name in eagle.iterkeys(): print name
    #for name,members in eagle.items(): printfunc(name,members)

########NEW FILE########
__FILENAME__ = orderformat
import json
from pprint import pprint

def magic_sort(fmt_dict):
    # Hold JSON representation of these objects
    rdcd_dict = {}
    dep_list = {}
    for obj,body in fmt_dict.iteritems():
        tmp_obj = {'string':json.dumps({obj:body})}
        for attr,egl_type in body.iteritems():
            if egl_type not in ('int','string','real'):
                tmp_obj[attr] = egl_type
                if attr not in dep_list:
                    dep_list[attr] = []
                dep_list[attr].append(obj)
        rdcd_dict[obj] = tmp_obj

    # Hold dependency ordering of eagle objects
    tmp_list = []
    multi = {}
    for obj,deps in dep_list.iteritems():
        if len(deps) == 1:
            if deps[0] in tmp_list:
                tmp_list.insert(tmp_list.index(deps[0])+1, obj)
            else:
                tmp_list.insert(0,obj)
        else:
            multi[obj] = deps

    for obj,deps in multi.iteritems():
        final_index = 0
        for i in deps:
            if i in tmp_list and i > final_index:
                final_index = tmp_list.index(i)

        if final_index > 0:
            final_index += 1
        tmp_list.insert(final_index, obj)

    return tmp_list, dep_list

if __name__ == '__main__':
    eagle_fmt = ''
    with open('eagle.json', 'r') as fmt_file:
        eagle_fmt = json.loads(''.join(fmt_file.readlines()))

    pprint(magic_sort(eagle_fmt))

########NEW FILE########
__FILENAME__ = render
#!/usr/bin/env python
""" quick and dirty script to try rendering JSON format """

# render.py - quick and dirty script to try rendering JSON format
# TODO: this does no error checking of the input file, that'd be nice mkay?
# TODO: class-ify this, instead of handing the 'draw' instance around

import json, sys
from PIL import Image, ImageDraw


def drawCircuit(circuit, draw):
    """ draw a circuit to a draw instance """
    sheet = circuit["sheet"]
    drawSheet(sheet, draw)
    components = circuit["components"]
    instances = circuit["instances"]
    drawComponents(components,instances,draw)

def drawSheet(sheet, draw):
    """ draw the 'sheet' part of a circuit """
    # Draw annotations (notes)
    for name,note in sheet["annotations"].items():
        value = sheet["attributes"][name]
        position = ( int(note["x"]), int(note["y"]) )
        drawNote(position, value, draw)
    # Draw shapes
    for name,shape in sheet["shapes"].items():
        drawShape((0,0),shape,draw) # Everything in sheet relative to origin

def drawNote(pt, text, draw):
    """ draw an annotation at a point """
    #TODO align other than top left, rotation other than normal
    draw.text(pt, text, fill=(255,255,0))

def drawShape(pt, shape,draw):
    """ draw from a set of shapes relative to a point """
    if     shape["type"] == "line":
        pos = [int(i) for i in (shape["x1"],shape["y1"],shape["x2"],shape["y2"])]
        pos = (pos[0]+ pt[0],pos[1]+pt[1], pos[2]+pt[0],pos[3]+pt[1])
        draw.line(pos)
    elif shape["type"] == "rect":
        pos = [int(i) for i in (shape["x1"],shape["y1"],shape["x2"],shape["y2"])]
        pos = (pos[0]+ pt[0],pos[1]+pt[1], pos[2]+pt[0],pos[3]+pt[1])
        draw.rectangle(pos)

def drawComponents(comps, inst, draw):
    """ draw instances of components """
    # TODO: yeah my variable names sometimes suck
    for name,comp in inst.items(): # iterate over instances
        symb = comp["symbol"]
        for na,body in comp["bodies"].items(): # iterate over bodies
            #TODO: support annotations, rotation and other fun stuff
            pos = [int(i) for i in (body["x"],body["y"])]
            drawBody(pos, comps[name], symb, na, draw)

def drawBody(pt, comp, symb, body, draw):
    """ draw a body of a component """
    body = comp["symbols"][symb]["bodies"][body]
    # Draw annotations (notes)
    for name,note in body["annotations"].items():
        value = body["attributes"][name]
        pos = ( int(note["x"]), int(note["y"]) )
        pos = (pos[0]+ pt[0],pos[1]+pt[1])
        drawNote(pos, value, draw)
    # Draw shapes
    for name,shape in body["shapes"].items():
        drawShape(pt,shape,draw) # Everything in sheet relative to origin


if __name__ == "__main__":
    ckt = json.loads(open("example.json").read())

    # Draw circuit to an image, then save it out
    im = Image.new("RGB",(100,100))
    draw = ImageDraw.Draw(im)
    drawCircuit(ckt,draw)
    im.save("example.png", "PNG")

########NEW FILE########
__FILENAME__ = lightning_inventory
title = 'LIGHTNING DETECTOR'
author = 'techman@dingoblue.net.au'
revision = '1.00'
filename = 'lightning.sch'
components = [
    {
        'refdes': 'L1',
        'filename': 'inductor-1.sym',
        'value': '10mH',
        'device': 'INDUCTOR',
        'symversion': '0.1',
    },
    {
        'filename': 'inductor-1.sym',
        'refdes': 'L2',
        'value': '10mH',
        'device': 'INDUCTOR',
        'symversion': '0.1',
    },
    {
        'filename': 'title-A4.sym',
    },
    {
        'filename': 'capacitor-2.sym',
        'refdes': 'C2',
        'value': '0.01uF',
        'device': 'POLARIZED_CAPACITOR',
        'symversion': '0.1',
    },
    {
        'filename': 'capacitor-2.sym',
        'refdes': 'C1',
        'value': '680pf',
        'device': 'POLARIZED_CAPACITOR',
        'symversion': '0.1',
    },
    {
        'filename': 'capacitor-2.sym',
        'refdes': 'C3',
        'value': '.01uF',
        'device': 'POLARIZED_CAPACITOR',
        'symversion': '0.1',
    },
    {
        'filename': 'capacitor-2.sym',
        'value': '100uF',
        'refdes': 'C4',
        'device': 'POLARIZED_CAPACITOR',
        'symversion': '0.1',
    },
    {
        'filename': 'capacitor-2.sym',
        'value': '.005uF',
        'refdes': 'C5',
        'device': 'POLARIZED_CAPACITOR',
        'symversion': '0.1',
    },
    {
        'filename': 'resistor-1.sym',
        'refdes': 'R1',
        'value': '180k',
        'device': 'RESISTOR',
    },
    {
        'filename': 'resistor-1.sym',
        'refdes': 'R2',
        'value': '3.9k',
        'device': 'RESISTOR',
    },
    {
        'filename': 'resistor-1.sym',
        'refdes': 'R7',
        'value': '47R',
        'device': 'RESISTOR',
    },
    {
        'filename': 'resistor-1.sym',
        'refdes': 'R3',
        'value': '22k',
        'device': 'RESISTOR',
    },
    {
        'filename': 'resistor-1.sym',
        'refdes': 'R5',
        'value': '2.2K',
        'device': 'RESISTOR',
    },
    {
        'filename': 'resistor-1.sym',
        'refdes': 'R6',
        'value': '2.7k',
        'device': 'RESISTOR',
    },
    {
        'filename': 'resistor-variable-1.sym',
        'refdes': 'R4',
        'value': '20k',
        'device': 'VARIABLE_RESISTOR',
    },
    {
        'filename': 'out-1.sym',
        'refdes': 'lamp(1)',
        'device': 'OUTPUT',
    },
    {
        'filename': 'out-1.sym',
        'refdes': 'lamp(2)',
        'device': 'OUTPUT',
    },
    {
        'filename': 'in-1.sym',
        'refdes': 'bat(+3v)',
        'device': 'INPUT',
    },
    {
        'filename': 'in-1.sym',
        'refdes': 'bat(0v)',
        'device': 'INPUT',
    },
    {
        'filename': 'in-1.sym',
        'refdes': 'A1',
        'device': 'INPUT',
    },
    {
        'filename': 'capacitor-2.sym',
        'value': '1uF',
        'refdes': 'C6',
        'device': 'POLARIZED_CAPACITOR',
        'symversion': '0.1',
    },
    {
        'filename': 'diode-1.sym',
        'refdes': 'D1',
        'value': '1N914',
        'device': 'DIODE',
    },
    {
        'filename': '2N4401.sym',
        'refdes': 'Q1',
        'value': '2N4401',
    },
    {
        'filename': '2N4403.sym',
        'refdes': 'Q2',
        'value': '2N4403',
    },
    {
        'filename': '2N4401.sym',
        'value': '2N4401',
        'refdes': 'Q3',
    },
    {
        'filename': '2N4401.sym',
        'refdes': 'Q4',
        'value': '2N4401',
    },
]
#N 53000 63100 53000 61500 4
#N 53000 60600 53000 60000 4
#N 53500 61100 53500 61600 4
#N 53500 60200 53500 60000 4
#N 53500 61600 53000 61600 4
#N 54400 61600 54500 61600 4
#N 55200 63900 55200 62100 4
#N 53000 64700 53000 64000 4
#N 62000 60000 53000 60000 4
#N 55200 61100 55200 60000 4
#N 55200 60000 60200 60000 4
#N 54400 63500 54400 63300 4
#N 54400 62400 54400 61600 4
#N 61700 60500 61700 60000 4
#N 62000 66000 55200 66000 4
#N 55200 66000 55200 64800 4
#N 61500 65800 61500 66000 4
#N 61500 63000 61500 64900 4
#N 61500 63000 61900 63000 4
#N 54400 63500 55200 63500 4
#N 61000 61000 56500 61000 4
#N 56500 61000 56500 61600 4
#N 60200 60900 60200 61000 4
#N 60200 62000 60200 61000 4
#N 60200 63000 60200 64800 4
#N 55200 63000 55600 63000 4
#N 56500 62500 56500 63600 4
#N 56000 64100 56000 64800 4
#N 56000 64800 61500 64800 4
#N 58200 62500 57500 62500 4
#N 61900 62000 61700 62000 4
#N 61700 62000 61700 61500 4
#N 59400 62500 59400 62100 4
#N 59400 61200 59400 61000 4
#N 57500 63500 58000 63500 4
#N 58000 63500 58000 62100 4
#N 58000 61200 58000 61000 4
#N 60800 64100 60800 66000 4
#N 60800 63200 60800 60000 4
#N 59100 62500 59500 62500 4
#N 56500 63000 56800 63000 4
#N 56500 64500 56500 64800 4
#N 57500 64700 57500 64800 4
#N 57500 63500 57500 63800 4


header = ['device', 'value', 'footprint', 'quantity', 'refdes']
data = [
    ['DIODE', '1N914', 'unknown', 1, ['D1']],
    ['INDUCTOR', '10mH', 'unknown', 2, ['L1', 'L2']],
    ['INPUT', 'unknown', 'unknown', 3, ['A1', 'bat(+3v)', 'bat(0v)']],
    ['OUTPUT', 'unknown', 'unknown', 2, ['lamp(1)', 'lamp(2)']],
    ['POLARIZED_CAPACITOR', '.005uF', 'unknown', 1, ['C5']],
    ['POLARIZED_CAPACITOR', '.01uF', 'unknown', 1, ['C3']],
    ['POLARIZED_CAPACITOR', '0.01uF', 'unknown', 1, ['C2']],
    ['POLARIZED_CAPACITOR', '100uF', 'unknown', 1, ['C4']],
    ['POLARIZED_CAPACITOR', '1uF', 'unknown', 1, ['C6']],
    ['POLARIZED_CAPACITOR', '680pf', 'unknown', 1, ['C1']],
    ['RESISTOR', '180k', 'unknown', 1, ['R1']],
    ['RESISTOR', '2.2K', 'unknown', 1, ['R5']],
    ['RESISTOR', '2.7k', 'unknown', 1, ['R6']],
    ['RESISTOR', '22k', 'unknown', 1, ['R3']],
    ['RESISTOR', '3.9k', 'unknown', 1, ['R2']],
    ['RESISTOR', '47R', 'unknown', 1, ['R7']],
    ['unknown', '2N4401', 'unknown', 3, ['Q1', 'Q3', 'Q4']],
    ['unknown', '2N4403', 'unknown', 1, ['Q2']],
    ['VARIABLE_RESISTOR', '20k', 'unknown', 1, ['R4']],
]

bom = []
for item in data:
    bom.append(dict(zip(header, data)))

########NEW FILE########
__FILENAME__ = test
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The regression test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import unittest
import os
import sys
import re
import logging
import subprocess
import tempfile

from upconvert.upconverter import Upconverter
from upconvert.utils.verify_json import verify_json

from os.path import splitext


sch_re = re.compile(r'.*\.sch$')
def filter_sch(arg, top, names):
    for name in names:
        if sch_re.match(os.path.join(top, name)):
            arg.append(os.path.join(top, name))


fz_re = re.compile(r'.*\.fz$')
def filter_fz(arg, top, names):
    for name in names:
        if fz_re.match(os.path.join(top, name)):
            arg.append(os.path.join(top, name))


fzz_re = re.compile(r'.*\.fzz$')
def filter_fzz(arg, top, names):
    for name in names:
        if fzz_re.match(os.path.join(top, name)):
            arg.append(os.path.join(top, name))


ger_re = re.compile(r'.*\.ger$')
def filter_ger(arg, top, names):
    if os.path.basename(top) == 'unittest':
        return
    for name in names:
        if ger_re.match(os.path.join(top, name)):
            arg.append(os.path.join(top, name))


upv_re = re.compile(r'.*\.upv$')
def filter_upv(arg, top, names):
    for name in names:
        if upv_re.match(os.path.join(top, name)):
            arg.append(os.path.join(top, name))

dsn_re = re.compile(r'.*\.dsn$')
def filter_dsn(arg, top, names):
    for name in names:
        if dsn_re.match(os.path.join(top, name)):
            arg.append(os.path.join(top, name))

def get_file_diff_ratio(file1, file2):
    """ Return the ratio of differences to the total
    number of lines in file1 and file2. """
    with open(file1) as f:
        num_lines1 = sum(1 for _ in f)
    with open(file2) as f:
        num_lines2 = sum(1 for _ in f)

    p = subprocess.Popen(('diff', '--speed-large-files', file1, file2),
                         stdout=subprocess.PIPE)

    num_diffs = sum(1 for line in p.stdout if line and line[0] in '<>')

    p.wait()

    return float(num_diffs) / (num_lines1 + num_lines2)


def get_file_contents(tmp_path):
    with open(tmp_path, 'r') as final:
        return final.read()


def test_auto_detect_generator(file_path, format):
    """ Test the autodetection of files. """
    def test(self):
        self.assertEqual(Upconverter.autodetect(file_path), format)
    return test


def test_parse_generator(file_path, format):
    """ Test the parsing of files. """
    def test(self):
        data = Upconverter.parse(file_path, format)
        self.assertTrue(data != None)

        if format not in ['gerber']:
            verify_json(data.json())

        tmp_fd, tmp_path = tempfile.mkstemp()
        os.close(tmp_fd)
        Upconverter.write(data, tmp_path, 'openjson')
        self.assertTrue(get_file_contents(tmp_path) != '')
        os.remove(tmp_path)
    return test


max_diff_ratios = {
    'geda': 0.30,
    'kicad': 0.049,
    'openjson': 0.0
    }

def test_diff_generator(file_path, format):
    """ Parse the file, write to both openjson and to the given
    format. Then parse the new file in the same format and write that
    to openjson. Test the differences between the two openjson files
    and fail if they differ by more than 5 percent.

    This tests that the parser and writer together preserve as much
    information as the parser by itself.

    Given a file F in format X, written as F.X, do the following
    conversions:

      F.X --> F1.upv --> F2.X --> F3.upv

    Then compare F1 and F3 using the 'diff' program and compute the
    ratio of the number of differences to the total number of lines in
    both files. Assert the ratio is below a given threshold.
    """
    def test(self):
        try:
            data = Upconverter.parse(file_path, format)
            self.assertNotEqual(data, None)

            tmp_fd, json_path_1 = tempfile.mkstemp(prefix='test.1.', suffix='.upv')
            os.close(tmp_fd)
            Upconverter.write(data, json_path_1, 'openjson')
            self.assertNotEqual(get_file_contents(json_path_1), '')

            tmp_fd, tmp_path = tempfile.mkstemp(suffix='.' + format)
            os.close(tmp_fd)
            Upconverter.write(data, tmp_path, format)
            self.assertNotEqual(get_file_contents(tmp_path), '')

            data = Upconverter.parse(tmp_path, format)
            self.assertNotEqual(data, None)

            tmp_fd, json_path_2 = tempfile.mkstemp(prefix='test.2.', suffix='.upv')
            os.close(tmp_fd)
            Upconverter.write(data, json_path_2, 'openjson')
            self.assertNotEqual(get_file_contents(json_path_2), '')

            ratio = get_file_diff_ratio(json_path_1, json_path_2)

            self.assertTrue(ratio <= max_diff_ratios[format],
                            (file_path, tmp_path, json_path_1, json_path_2, ratio))
        finally:
            # need to remove each file if a failure occured.
            # tries handle variables that have not yet been instantiated.
            try:
                os.remove(json_path_1)
            except:
                pass
            try:
                os.remove(json_path_2)
            except:
                pass
            try:
                os.remove(splitext(tmp_path)[0] + '-cache.lib')
            except:
                pass
            try:
                os.remove(tmp_path)
            except:
                pass
        
    return test


def test_write_generator(json_file_path, format):
    """ Test the writing files. """
    def test(self):
        data = Upconverter.parse(json_file_path, 'openjson')
        self.assertTrue(data != None)

        tmp_fd, tmp_path = tempfile.mkstemp()
        os.close(tmp_fd)
        Upconverter.write(data, tmp_path, format)
        self.assertTrue(get_file_contents(tmp_path) != '')
        os.remove(tmp_path)
    return test


def main():
    desc = 'Run the upconverter regression tests'
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('--fail-fast', action='store_true', default=False)
    parser.add_argument('--unsupported', action='store_true', default=False)
    parser.add_argument('--test-type', dest='test_types', action='append')
    parser.add_argument('file_types', metavar='input-type', nargs='*')

    args = parser.parse_args()

    if not args.test_types:
        args.test_types = ['parse', 'write', 'autodetect', 'diff']

    if 'all' in args.file_types:
        args.file_types = None

    # Fail if strict and wrong python version
    if sys.version_info[0] > 2 or sys.version_info[1] > 6:
        print 'WARNING: RUNNING UNSUPPORTED VERSION OF PYTHON (%s.%s > 2.6)' % (sys.version_info[0],
            sys.version_info[1])
        if not args.unsupported:
            sys.exit(-1)

    # Hide logging
    logging.getLogger("main").setLevel(logging.ERROR)
    logging.getLogger("parser.geda").setLevel(logging.ERROR)

    eagle_sch_files = []
    os.path.walk('./test/eagle', filter_sch, eagle_sch_files)

    eaglexml_sch_files = []
    os.path.walk('./test/eaglexml', filter_sch, eaglexml_sch_files)

    fritzing_fz_files = []
    os.path.walk('./test/fritzing', filter_fz, fritzing_fz_files)

    fritzing_fzz_files = []
    os.path.walk('./test/fritzing', filter_fzz, fritzing_fzz_files)

    fritzing_sch_files = []
    fritzing_sch_files.extend([str(t) for t in fritzing_fz_files])
    fritzing_sch_files.extend([str(t) for t in fritzing_fzz_files])

    geda_sch_files = []
    os.path.walk('./test/geda', filter_sch, geda_sch_files)

    gerber_ger_files = []
    os.path.walk('./test/gerber', filter_ger, gerber_ger_files)

    kicad_sch_files = []
    os.path.walk('./test/kicad', filter_sch, kicad_sch_files)

    upverter_upv_files = []
    os.path.walk('./test/openjson', filter_upv, upverter_upv_files)

    specctra_dsn_files = []
    os.path.walk('./test/specctra', filter_dsn, specctra_dsn_files)

    l = {'eagle': eagle_sch_files,
         'eaglexml': eaglexml_sch_files,
         'fritzing': fritzing_sch_files,
         'geda': geda_sch_files,
         'gerber': gerber_ger_files,
         'kicad': kicad_sch_files,
         'openjson': upverter_upv_files,
         'specctra': specctra_dsn_files,
        #'image': image_files,
    }

    test_classes = {}

    for format, files in l.iteritems():
        test_class = type('RegressionTest_' + format, (unittest.TestCase,), {})
        test_classes[format] = test_class

        for f in files:
            base = os.path.basename(f)

            if 'autodetect' in args.test_types:
                test_name = 'test_%s_%s_%s' % (format, base, 'detect')
                test = test_auto_detect_generator(f, format)
                setattr(test_class, test_name, test)

            if 'parse' in args.test_types:
                test_name = 'test_%s_%s_%s' % (format, base, 'parse')
                test = test_parse_generator(f, format)
                setattr(test_class, test_name, test)

            if 'diff' in args.test_types and format in max_diff_ratios:
                test_name = 'test_%s_%s_%s' % (format, base, 'diff')
                test = test_diff_generator(f, format)
                setattr(test_class, test_name, test)

        for f in upverter_upv_files:
            base = os.path.basename(f)

            if 'write' in args.test_types \
                    and format not in ['fritzing', 'gerber']:
                test_name = 'test_%s_%s_%s' % (format, base, 'write')
                test = test_write_generator(f, format)
                setattr(test_class, test_name, test)

    for format, c in test_classes.iteritems():
        if not args.file_types or format in args.file_types:
            print '=============================\n\n\nTesting: %s >>>' % format
            s = unittest.TestLoader().loadTestsFromTestCase(c)
            if args.fail_fast:
                unittest.TextTestRunner(failfast=args.fail_fast).run(s)
            else:
                unittest.TextTestRunner().run(s)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = test_imported
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" Handle imported files """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import os
import sys
import re
import logging
import tempfile
import traceback
from upconvert.upconverter import Upconverter


def filter_all(arg, top, names):
    for name in names:
        arg.append(os.path.join(top, name))


def main():
    imported_files = []
    os.path.walk('./test/imported', filter_all, imported_files)

    failed_to_autodetect = []
    failed_to_parse = []

    for file_path in imported_files:
        try:
            # test autodetection
            format = Upconverter.autodetect(file_path)
            
            try:
                # test conversion
                data = Upconverter.parse(file_path, format)

            except Exception, e:
                failed_to_parse.append(file_path)
                print traceback.print_exc()
                
        except Exception, e:
            failed_to_autodetect.append(file_path)
            print traceback.print_exc()

    print '\n\n'

    print 'failed to autodetect: %s' % (len(failed_to_autodetect))
    print '--'
    for f in failed_to_autodetect:
        print '%s' % (f)

    print '\n'

    print 'failed to parse:      %s' % (len(failed_to_parse))
    print '--'
    for f in failed_to_parse:
        print '%s' % (f)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = annotation
#!/usr/bin/env python2
""" The annotation class """

# upconverty - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.shape import Point


class Annotation:
    """ The Annotation class represents all cases of annotations """

    def __init__(self, value, x, y, rotation, visible, layer='default', flip_horizontal=False, label=None): # pylint: disable=R0913
        self.value = value
        self.x = x
        self.y = y
        self.flip_horizontal = flip_horizontal
        self.label = label
        self.layer = layer
        self.rotation = rotation
        self.visible = visible


    def bounds(self):
        """ Return the bounding points of an annotation """
        return [Point(self.x - 10, self.y - 10),
                Point(self.x + 10, self.y + 10)]


    def ranges(self):
        """ Return the min - max x range, and the min - max y range of the bounding box """
        minpt, maxpt = self.bounds()
        return [minpt.x, maxpt.x], [minpt.y, maxpt.y]


    def scale(self, factor):
        """ Scale the x & y coordinates in the annotation. """
        self.x *= factor
        self.y *= factor


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the annotation. """
        self.x += dx
        self.y += dy


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the annotation. """
        self.y = height - self.y


    def json(self):
        """ Return an annotation as JSON """
        anno_json =  {
            "value": self.value,
            "x": int(self.x),
            "y": int(self.y),
            "layer": self.layer,
            "flip": self.flip_horizontal,
            "rotation": self.rotation,
            "visible": self.visible
            }
        if self.label is not None:
            anno_json["label"] = self.label.json()
        return anno_json

########NEW FILE########
__FILENAME__ = components
#!/usr/bin/env python2
""" The component class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.shape import Point
from upconvert.utils.stringify import stringify_attributes


class Components:
    """ Container class for individual 'Component's.
    Only used for add_component and json() (export) """

    def __init__(self):
        self.components = dict()


    def add_component(self, library_id, component):
        """ Add a component to the library """
        self.components[library_id] = component


    def scale(self, factor):
        """ Scale the x & y coordinates in the library. """
        for component in self.components.values():
            component.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the library. """
        for component in self.components.values():
            component.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the library. """
        for component in self.components.values():
            component.rebase_y_axis(height)


    def json(self):
        """ Copy to a new dictionary to return """
        ret = dict()
        for library_id, component in self.components.items():
            ret[library_id] = component.json()
        return ret


class Component:
    """ The Component class represents a single kind of part (component).
    It can have multiple graphical representations (Symbols), each with
    multiple sections (Bodies).
    The 'components' of a design is basically its library of available
    parts.  The actual placed parts on the design are 'Instances' of
    components, and reference their respective component via a unique
    library_id.
    """

    def __init__(self, name):
        self.name = name
        self.attributes = dict()
        self.symbols = list()
        self.footprints = list()


    def add_attribute(self, key, value):
        """ Add an attribute to a component """
        self.attributes[key] = value


    def add_symbol(self, symbol):
        """ Add a symbol to a component """
        self.symbols.append(symbol)


    def add_footprint(self, footprint):
        """ Add a footprint to a component """
        self.footprints.append(footprint)


    def scale(self, factor):
        """ Scale the x & y coordinates in the component. """
        for symbol in self.symbols:
            symbol.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the component. """
        for symbol in self.symbols:
            symbol.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the component. """
        for symbol in self.symbols:
            symbol.rebase_y_axis(height)


    def json(self):
        """ Return a component as JSON """
        return {
            "symbols": [s.json() for s in self.symbols],
            "footprints": [s.json() for s in self.footprints],
            "attributes": stringify_attributes(self.attributes),
            "name": self.name
            }


class Symbol:
    """ This is a graphical representation of a Component.
    A Component can have many Symbols, and each Symbol can have
    multiple Bodies """

    def __init__(self):
        self.bodies = list()


    def add_body(self, body):
        """ Add a body to a symbol """
        self.bodies.append(body)


    def scale(self, factor):
        """ Scale the x & y coordinates in the symbol. """
        for body in self.bodies:
            body.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the symbol. """
        for body in self.bodies:
            body.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the symbol. """
        for body in self.bodies:
            body.rebase_y_axis(height)


    def json(self):
        """ Return a symbol as JSON """
        return {"bodies":[b.json() for b in self.bodies]}


class Footprint:
    """ This is the physical representation of a Component.
    A Component can have many Footprints, and each Footprint can have
    multiple Bodies """

    def __init__(self):
        self.bodies = list()
        self.gen_objs = list()


    def add_body(self, body):
        """ Add a body to a footprint """
        self.bodies.append(body)


    def add_gen_obj(self, gen_obj):
        """ Add a generated object to a footprint """
        self.gen_objs.append(gen_obj)


    def scale(self, factor):
        """ Scale the x & y coordinates in the footprint. """
        for body in self.bodies:
            body.scale(factor)
        for gen_obj in self.gen_objs:
            gen_obj.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the footprint. """
        for body in self.bodies:
            body.shift(dx, dy)
        for gen_obj in self.gen_objs:
            gen_obj.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the footprint. """
        for body in self.bodies:
            body.rebase_y_axis(height)
        for gen_obj in self.gen_objs:
            gen_obj.rebase_y_axis(height)


    def json(self):
        """ Return a footprint as JSON """
        return {"bodies":[b.json() for b in self.bodies],
                "gen_objs": [go.json() for go in self.gen_objs]}


class SBody:
    """ A body of a Symbol of a Component """

    def __init__(self):
        self.shapes = list()
        self.pins = list()


    def bounds(self):
        """ Return the min and max points of the bounding box around a body """
        points = sum([s.bounds() for s in self.shapes + self.pins], [])
        x_values = [pt.x for pt in points]
        y_values = [pt.y for pt in points]
        if len(x_values) == 0:
            # Empty body includes just the origin
            x_values = [0]
            y_values = [0]
        return [Point(min(x_values), min(y_values)),
                Point(max(x_values), max(y_values))]


    def add_pin(self, pin):
        """ Add a pin to a symbol """
        self.pins.append(pin)


    def add_shape(self, shape):
        """ Add a shape to a symbol """
        self.shapes.append(shape)


    def scale(self, factor):
        """ Scale the x & y coordinates in the symbol. """
        for shape in self.shapes:
            shape.scale(factor)
        for pin in self.pins:
            pin.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the symbol. """
        for shape in self.shapes:
            shape.shift(dx, dy)
        for pin in self.pins:
            pin.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the symbol. """
        for shape in self.shapes:
            shape.rebase_y_axis(height)
        for pin in self.pins:
            pin.rebase_y_axis(height)


    def json(self):
        """ Return a symbol as JSON """
        return {
            "shapes":[s.json() for s in self.shapes],
            "pins"  :[p.json() for p in self.pins]
            }


class FBody:
    """ A body of a footprint of a Component """

    def __init__(self):
        self.shapes = list()
        self.layer = None
        self.rotation = 0
        self.flip_horizontal = False


    def bounds(self):
        """ Return the min and max points of the bounding box around a body """
        points = sum([s.bounds() for s in self.shapes], [])
        x_values = [pt.x for pt in points]
        y_values = [pt.y for pt in points]
        if len(x_values) == 0:
            # Empty body includes just the origin
            x_values = [0]
            y_values = [0]
        return [Point(min(x_values), min(y_values)),
                Point(max(x_values), max(y_values))]


    def add_shape(self, shape):
        """ Add a shape to a footprint """
        self.shapes.append(shape)


    def scale(self, factor):
        """ Scale the x & y coordinates in the footprint. """
        for shape in self.shapes:
            shape.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the footprint. """
        for shape in self.shapes:
            shape.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the footprint. """
        for shape in self.shapes:
            shape.rebase_y_axis(height)


    def json(self):
        """ Return a footprint as JSON """
        return {
            "shapes":[s.json() for s in self.shapes],
            "rotation": self.rotation,
            "flip": self.flip_horizontal,
            "layer": self.layer
            }


    def rotate(self, rotation):
        self.rotation = (self.rotation + rotation) % 2
        for shape in self.shapes:
            shape.rotate(rotation)


class Pin:
    """ Pins are the parts of SBodies (/symbols/components) that connect
    to nets. Basically a line segment, with a null end and a connect end
    """

    def __init__(self, pin_number, p1, p2, label=None):
        self.label = label # is a Label
        self.p1 = Point(p1) # null end
        self.p2 = Point(p2) # connect end
        self.pin_number = pin_number
        self.attributes = dict()
        self.styles = dict()


    def add_attribute(self, key, value):
        """ Add attribute to a pin """
        self.attributes[key] = value


    def bounds(self):
        """ Return the min and max points of a pin """
        x_values = [self.p1.x, self.p2.x]
        y_values = [self.p1.y, self.p2.y]
        if self.label is not None:
            x_values.extend([pt.x for pt in self.label.bounds()])
            y_values.extend([pt.y for pt in self.label.bounds()])
        return [Point(min(x_values), min(y_values)),
                Point(max(x_values), max(y_values))]


    def scale(self, factor):
        """ Scale the x & y coordinates in the pin. """
        if self.label is not None:
            self.label.scale(factor)
        self.p1.scale(factor)
        self.p2.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the pin. """
        if self.label is not None:
            self.label.shift(dx, dy)
        self.p1.shift(dx, dy)
        self.p2.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the pin. """
        if self.label is not None:
            self.label.rebase_y_axis(height)
        self.p1.rebase_y_axis(height)
        self.p2.rebase_y_axis(height)


    def json(self):
        """ Return a pin as JSON """
        ret = {
            "pin_number": self.pin_number,
            "p1": self.p1.json(),
            "p2": self.p2.json(),
            "attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }
        if self.label is not None:
            ret["label"] = self.label.json()
        return ret


class Pad:
    """ Pads are the parts of FBodies (/footprints/components) that connect
    to traces. Basically a set of shapes.
    """

    def __init__(self, pin_number, p, shapes, label=None):
        self.label = label # is a Label
        self.p = Point(p)
        self.pin_number = pin_number
        self.shapes = shapes
        self.attributes = dict()
        self.styles = dict()


    def add_attribute(self, key, value):
        """ Add attribute to a pin """
        self.attributes[key] = value


    def bounds(self):
        """ Return the min and max points of a pin """
        pass


    def scale(self, factor):
        """ Scale the x & y coordinates in the pin. """
        pass


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the pin. """
        pass


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the pin. """
        pass


    def json(self):
        """ Return a pin as JSON """
        ret = {
            "pin_number": self.pin_number,
            "p": self.p.json(),
            "shapes": [s.json() for s in self.shapes],
            "attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }
        if self.label is not None:
            ret["label"] = self.label.json()
        return ret

########NEW FILE########
__FILENAME__ = component_instance
#!/usr/bin/env python2
""" The instance class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.utils.stringify import stringify_attributes


class ComponentInstance:
    """ An instance of a component with a specific symbol """

    def __init__(self, instance_id, library_component, library_id, symbol_index, footprint_index=0):
        self.instance_id = instance_id
        self.library_id = library_id
        self.library_component = library_component
        self.symbol_index = symbol_index
        self.symbol_attributes = list()
        self.footprint_index = footprint_index
        self.footprint_attributes = list()
        self.gen_obj_attributes = list()
        self.footprint_pos = None
        self.attributes = dict()


    def add_attribute(self, key, value):
        """ Add attribute to a component """
        self.attributes[key] = value


    def get_attribute(self, key):
        if key in self.attributes:
            return self.attributes[key]

        elif key in self.library_component.attributes:
            return self.library_component.attributes[key]

        else:
            return '??'


    def add_symbol_attribute(self, symbol_attribute):
        """ Add attribute to a components symbol """
        self.symbol_attributes.append(symbol_attribute)


    def add_footprint_attribute(self, footprint_attribute):
        """ Add attribute to a components footprint """
        self.footprint_attributes.append(footprint_attribute)


    def add_gen_obj_attribute(self, gen_obj_attribute):
        """ Add a generated object to the component instance. """
        self.gen_obj_attributes.append(gen_obj_attribute)


    def set_footprint_pos(self, footprint_pos):
        self.footprint_pos = footprint_pos


    def get_instance_id(self):
        """ Return the instance id """
        return self.instance_id


    def scale(self, factor):
        """ Scale the x & y coordinates in the instance. """
        for attr in self.symbol_attributes:
            attr.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the instance. """
        for attr in self.symbol_attributes:
            attr.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the instance. """
        for attr in self.symbol_attributes:
            attr.rebase_y_axis(height)


    def json(self):
        """ Return a component as JSON """
        json = {
            "instance_id" : self.instance_id,
            "library_id" : self.library_id,
            "symbol_index" : self.symbol_index,
            "symbol_attributes":[s.json() for s in self.symbol_attributes],
            "footprint_index" : self.footprint_index,
            "footprint_attributes":[s.json() for s in self.footprint_attributes],
            "gen_obj_attributes":[s.json() for s in self.gen_obj_attributes],
            "attributes" : stringify_attributes(self.attributes)
            }
        if self.footprint_pos is not None:
            json["footprint_pos"] = self.footprint_pos.json()
        return json


    def __repr__(self):
        return '''<ComponentInstance('{0}', '{1}', {2}, {3})>'''.format(self.instance_id, self.library_id, self.symbol_index, self.footprint_index)


class SymbolAttribute:
    """ The instance of a single body.  There should be a SymbolAttribute
    for every body in the symbol that ComponentInstance is an instance of.
    """

    def __init__(self, x, y, rotation, flip=False):
        self.x = x
        self.y = y
        self.rotation = rotation
        self.flip = flip
        self.annotations = []


    def add_annotation(self, annotation):
        """ Add annotations to the body """
        self.annotations.append(annotation)


    def scale(self, factor):
        """ Scale the x & y coordinates in the attributes. """
        self.x *= factor
        self.y *= factor
        for anno in self.annotations:
            anno.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the attributes. """
        self.x += dx
        self.y += dy
        for anno in self.annotations:
            anno.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the attributes. """
        self.y = height - self.y
        for anno in self.annotations:
            anno.rebase_y_axis(height)


    def json(self):
        """ Return the body as JSON """

        if self.flip:
            flip = "true"
        else:
            flip = "false"

        return {
            "x": int(self.x),
            "y": int(self.y),
            "rotation": self.rotation,
            "flip": flip,
            "annotations": [a.json() for a in self.annotations]
            }


class FootprintAttribute:
    """ The instance of a single body.  There should be a FootprintAttribute
    for every body in the footprint that ComponentInstance is an instance of.
    """

    def __init__(self, x, y, rotation, flip_horizontal, layer):
        self.x = x
        self.y = y
        self.rotation = rotation
        self.flip_horizontal = flip_horizontal
        self.layer = layer


    def scale(self, factor):
        """ Scale the x & y coordinates in the attributes. """
        self.x *= factor
        self.y *= factor


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the attributes. """
        self.x += dx
        self.y += dy


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the attributes. """
        self.y = height - self.y


    def json(self):
        """ Return the body as JSON """

        return {
            "x": int(self.x),
            "y": int(self.y),
            "rotation": self.rotation,
            "flip_horizontal": self.flip_horizontal,
            "layer": self.layer,
            }

    def __repr__(self):
        return '''<FootprintAttribute({0}, {1}, {2}, {3}, '{4}')>'''.format(self.x, self.y, self.rotation, self.flip_horizontal, self.layer)


class GenObjAttribute:
    """ The instance of a single generated object. """

    def __init__(self, x, y, rotation, flip, layer):
        self.x = x
        self.y = y
        self.rotation = rotation
        self.flip = flip
        self.layer = layer
        self.attributes = {}


    def add_attribute(self, key, value):
        self.attributes[key] = value


    def scale(self, factor):
        """ Scale the x & y coordinates in the attributes. """
        self.x *= factor
        self.y *= factor


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the attributes. """
        self.x += dx
        self.y += dy


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the attributes. """
        self.y = height - self.y


    def json(self):
        """ Return the body as JSON """

        return {
            "x": int(self.x),
            "y": int(self.y),
            "rotation": self.rotation,
            "flip": self.flip,
            "layer": self.layer,
            "attributes" : stringify_attributes(self.attributes)
            }

    def __repr__(self):
        return '''<GenObjAttribute({0}, {1}, {2}, {3}, '{4}', {5})>'''.format(self.x, self.y, self.rotation, self.flip, self.layer, self.attributes)


class FootprintPos:
    """ The footprint position. """

    def __init__(self, x, y, rotation, flip, side):
        self.x = x
        self.y = y
        self.rotation = rotation
        self.flip_horizontal = flip
        self.side = side


    def scale(self, factor):
        """ Scale the x & y coordinates in the attributes. """
        self.x *= factor
        self.y *= factor


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the attributes. """
        self.x += dx
        self.y += dy


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the attributes. """
        self.y = height - self.y

    def __repr__(self):
        return '''<FootprintPos(x={0}, y={1}, rotation={2}, flip={3}, side='{4}')>'''.format(self.x, self.y, self.rotation, self.flip_horizontal, self.side)

    def json(self):
        """ Return the body as JSON """

        return {
            "x": int(self.x),
            "y": int(self.y),
            "rotation": self.rotation,
            "flip": self.flip_horizontal,
            "side": self.side
            }


########NEW FILE########
__FILENAME__ = design
#!/usr/bin/env python2
""" The design class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.design_attributes import DesignAttributes
from upconvert.core.components import Components
from upconvert.core.shape import Point


class Design:
    """ The Design class represents the whole schematic, which is also
    the top level of the output format.  The internal structure of this
    class closely matches the JSON output."""

    def __init__(self):
        self.nets = list()
        self.components = Components()
        self.component_instances = list()
        self.shapes = list()
        self.pins = list()
        self.design_attributes = DesignAttributes()

        # layout specific aspects of the design
        self.layout_units = 'mm'         # Core units for layout placement are in nano meters
        self.layer_options = list()
        self.trace_segments = list()
        self.paths = list()
        self.pours = list()
        self.pcb_text = list()
        self.layout_objects = list() # vias, plated through holes...
        #self.layout = Layout()


        self.version = dict()
        self.set_version('0.1.0', 'Upverter converter')


    def bounds(self):
        """ Return the min and max point of a design """
        bounds = [net.bounds() for net in self.nets]
        bounds.extend([anno.bounds() for anno in self.design_attributes.annotations])
        offset_bounds = lambda (p1, p2), (xo, yo): [Point(p1.x + xo, p1.y + yo),
                                                    Point(p2.x + xo, p2.y + yo)]
        for comp in self.component_instances:
            offsets = [(att.x, att.y) for att in comp.symbol_attributes]
            lib_comp = self.components.components[comp.library_id]
            bodybounds = [b.bounds() for b in lib_comp.symbols[comp.symbol_index].bodies]
            # the offsets in symbol_attributes will align and apply to the
            # library components bodies
            bounds.extend([offset_bounds(b, o) for b, o in zip(bodybounds, offsets)])
        # flatten out bounds to just a list of Points
        bounds = sum(bounds, [])
        x_values = [pt.x for pt in bounds]
        y_values = [pt.y for pt in bounds]
        # by convention, an empty design will bound just the origin
        if len(x_values) == 0:
            x_values = [0]
            y_values = [0]
        return [Point(min(x_values), min(y_values)),
                Point(max(x_values), max(y_values))]


    def set_version(self, file_version, exporter):
        """ Set the file version and exporter """
        self.version['file_version'] = file_version
        self.version['exporter'] = exporter


    def get_attribute(self, attr_name):
        return self.design_attributes.attributes.get(attr_name, '??')


    def add_component_instance(self, component_instance):
        """ Add an instance """
        self.component_instances.append(component_instance)


    def add_component(self, library_id, component):
        """ Add a library part """
        self.components.add_component(library_id, component)


    def add_net(self, net):
        """ Add a net """
        self.nets.append(net)


    def add_pin(self, pin):
        """ Add a pin to the schematic sheet """
        self.pins.append(pin)


    def add_shape(self, shape):
        """ Add a shape to the schematic sheet """
        self.shapes.append(shape)


    def set_design_attributes(self, design_attributes):
        """ Add design level attributes """
        self.design_attributes = design_attributes


    def scale(self, factor):
        """ Scale the x & y coordinates in the core. """
        for net in self.nets:
            net.scale(factor)
        self.components.scale(factor)
        for instance in self.component_instances:
            instance.scale(factor)
        for shape in self.shapes:
            shape.scale(factor)
        for pin in self.pins:
            pin.scale(factor)
        self.design_attributes.scale(factor)


    def shift(self, dx, dy):
        """ Shift the design dx to all x & dy to all y coordinates in the core. """
        for net in self.nets:
            net.shift(dx, dy)
        self.components.shift(dx, dy)
        for instance in self.component_instances:
            instance.shift(dx, dy)
        for shape in self.shapes:
            shape.shift(dx, dy)
        for pin in self.pins:
            pin.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinates in the core. """
        for net in self.nets:
            net.rebase_y_axis(height)
        self.components.rebase_y_axis(height)
        for instance in self.component_instances:
            instance.rebase_y_axis(height)
        for shape in self.shapes:
            shape.rebase_y_axis(height)
        for pin in self.pins:
            pin.rebase_y_axis(height)


    def generate_netlist(self):
        """ The netlist as generated from the schematic. """
        pass


    def generate_bom(self):
        """ The bill of materials as generated from the schematic. """
        pass


    def json(self):
        """ Return a design as JSON """
        return {
            "version": self.version,
            "nets": [n.json() for n in self.nets],
            "components": self.components.json(),
            "component_instances": [i.json() for i in self.component_instances],
            "shapes": [s.json() for s in self.shapes],
            "pins": [s.json() for s in self.pins],
            "design_attributes": self.design_attributes.json(),
            # TODO(shamer): write out:
            # Trace segments
            # generated objects
            #"layout": self.layout.json() if self.layout is not None else None
            }

########NEW FILE########
__FILENAME__ = design_attributes
#!/usr/bin/env python2
""" The attributes class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import time
from upconvert.utils.stringify import stringify_attributes


class DesignAttributes:
    """ The DesignAttributes class corresponds to the design_attributes
    object in the Open JSON format """

    def __init__(self):
        self.annotations = []
        self.attributes = dict()
        self.metadata = Metadata()

    def add_annotation(self, annotation):
        """ Add an annotation """
        self.annotations.append(annotation)


    def add_attribute(self, key, value):
        """ Add an attribute """
        self.attributes[key] = value


    def set_metadata(self, metadata):
        """ Set the metadata """
        self.metadata = metadata


    def scale(self, factor):
        """ Scale the x & y coordinates of the design attributes. """
        for ann in self.annotations:
            ann.scale(factor)


    def json(self):
        """ Return the design attributes as JSON """
        return {
            "annotations" : [a.json() for a in self.annotations],
            "metadata" : self.metadata.json(),
            "attributes" : stringify_attributes(self.attributes),
            }


class Metadata:
    """ The metadata of a DesignAttributes object """

    def __init__(self):
        self.name = "" # TODO: make this name reflect the name from eagle
        self.license = "" # TODO: add license selection to upconvert.py
        self.owner = ""
        self.updated_timestamp = int(time.time())
        self.design_id = ""
        self.description = ""
        self.slug = self.name.replace(' ','-')
        self.attached_urls = list()


    def set_name(self, name):
        """ Set the name """
        self.name = name


    def set_license(self, lic):
        """ Set the licence """
        self.license = lic


    def set_owner(self, owner):
        """ Set the owner """
        self.owner = owner


    def set_updated_timestamp(self, updated_timestamp):
        """ Set the timestamp """
        self.updated_timestamp = int(updated_timestamp)


    def set_design_id(self, design_id):
        """ Set the design id """
        self.design_id = design_id


    def set_description(self, description):
        """ Set the description """
        self.description = description


    def set_slug(self, slug):
        """ Set the slug """
        self.slug = slug


    def add_attached_url(self, attached_url):
        """ Attach a url """
        self.attached_urls.append(attached_url)


    def json(self):
        """ Return the metadata as JSON """
        return {
            "name": self.name,
            "license": self.license,
            "owner": self.owner,
            "updated_timestamp": self.updated_timestamp,
            "design_id": self.design_id,
            "description": self.description,
            "slug": self.slug,
            "attached_urls": []
            }

########NEW FILE########
__FILENAME__ = generated_object
#!/usr/bin/env python2
""" Generated objects """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2012 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging

from upconvert.core.shape import Circle, Point, Rectangle, RoundedRectangle
from upconvert.core.components import FBody
from upconvert.core.component_instance import FootprintAttribute

log = logging.getLogger('core.generated_object')
_parser_types = {}


def parse_gen_obj_json(gen_obj_json):
    obj_type = gen_obj_json['attributes']['type']
    if obj_type not in _parser_types:
        raise ValueError('No parser for generated object json')
    return _parser_types[obj_type](gen_obj_json)


class GeneratedObject(object):

    def __init__(self, x, y, layer, rotation, flip, attributes):
        self.x = x
        self.y = y
        self.layer = layer
        self.rotation = rotation
        self.flip = flip
        self.attributes = attributes

    def get_attr(self, name, default, instance_attributes):
        return self.attributes.get(name, instance_attributes.get(name, default))

    def get_float_attr(self, name, default, instance_attributes):
        return float(self.get_attr(name, default, instance_attributes))

    def get_int_attr(self, name, default, instance_attributes):
        return int(self.get_attr(name, default, instance_attributes))

    def json(self):
        return {'x': self.x,
                'y': self.y,
                'layer': self.layer,
                'rotation': self.rotation,
                'flip': self.flip,
                'attributes': self.attributes}




class PadStack(GeneratedObject):
    type_name = 'padstack'

    @classmethod
    def parse_gen_obj_json(cls, gen_obj_json):
        return PadStack(int(gen_obj_json['x']),
                        int(gen_obj_json['y']),
                        gen_obj_json['layer'],
                        float(gen_obj_json['rotation']),
                        gen_obj_json['flip'],
                        gen_obj_json['attributes'])


    def bodies(self, offset, instance_attributes):
        bodies = []

        attached_layers = self.get_attr('attached_layers', '', instance_attributes).split(',')
        width = self.get_int_attr('width', 0, instance_attributes)
        height = self.get_int_attr('height', 0, instance_attributes)
        radius = self.get_int_attr('radius', 0, instance_attributes)
        shape_type = self.get_attr('shape', '', instance_attributes)

        pos = Point(self.x, self.y)

        for layer_name in attached_layers:
            layer_name = layer_name
            pad = FBody()
            # invert top/bottom if the footprint is on the bottom of the board
            if offset.side == 'bottom':
                rev_sides = {'top': 'bottom', 'bottom': 'top'}
                layer_name = ' '.join([rev_sides.get(piece, piece) for piece in layer_name.split(' ')])

            if shape_type == 'rectangle':
                pad.add_shape(Rectangle((width / 2), -(height / 2), width, height))
            elif shape_type == 'rounded rectangle':
                pad.add_shape(RoundedRectangle((width / 2), -(height / 2), width, height, radius))
            elif shape_type == 'circle':
                pad.add_shape(Circle(0, 0, radius))
            else:
                raise ValueError('unexpected shape type for padstack')

            pad.rotate(self.rotation)
            pad.shift(pos.x, pos.y)
            bodies.append((FootprintAttribute(0, 0, 0, False, layer_name), pad))

        return bodies


    def __repr__(self):
        return '''<Padstack({0}, {1}, '{2}', {3}, {4}, {5})>'''.format(self.x, self.y, self.layer, self.rotation, self.flip, self.attributes)
_parser_types[PadStack.type_name] = PadStack.parse_gen_obj_json



class PlatedThroughHole(GeneratedObject):
    type_name = 'plated through hole'

    @classmethod
    def parse_gen_obj_json(cls, gen_obj_json):
        return PlatedThroughHole(int(gen_obj_json['x']),
                                 int(gen_obj_json['y']),
                                 gen_obj_json['layer'],
                                 float(gen_obj_json['rotation']),
                                 gen_obj_json['flip'],
                                 gen_obj_json['attributes'])

    def bodies(self, offset, instance_attributes):
        """ Generated the bodies for the Via with instance attribute overrides. Returns placment attribute and body
            pairs.

        """
        attached_layers = self.get_attr('attached_layers', '', instance_attributes).split(',')
        internal_diameter = self.get_float_attr('internal_diameter', 0, instance_attributes)
        plating_shape = self.get_attr('plating_shape', '', instance_attributes)

        # Local vars for use in closures to generate shapes
        # XXX(shamer): The assignment of width and lenght are reversed from the javascript. Not sure why this is.
        plating_width = self.get_float_attr('plating_length', 0, instance_attributes)
        plating_height = self.get_float_attr('plating_width', 0, instance_attributes)
        plating_radius = self.get_float_attr('plating_radius', 0, instance_attributes)
        plating_diameter = self.get_float_attr('plating_diameter', 0, instance_attributes)

        solder_mask_expansion = self.get_float_attr('solder_mask_expansion', 0, instance_attributes)
        #thermal_inner_diameter = self.get_float_attr('thermal_inner_diameter', 0, instance_attributes)
        #thermal_spoke_width = self.get_float_attr('thermal_spoke_width', 0, instance_attributes)
        #antipad_diameter = self.get_float_attr('antipad_diameter', 0, instance_attributes)

        # placment attribute + body pairs making up the generated object
        bodies = []

        pad_pos = Point(self.x, self.y)
        sme_pos = Point(self.x, self.y)

        # Debugging marker for displaying the placment position for generated objects.
        #marker = FBody()
        #marker.add_shape(Circle(pad_pos.x, pad_pos.y, 1000000))
        #bodies.append((FootprintAttribute(0, 0, 0, False, 'top silkscreen'), marker))

        if plating_shape == 'square':
            solder_mask_width = (solder_mask_expansion * 2) + plating_diameter

            create_shape = lambda : Rectangle(pad_pos.x, pad_pos.y, plating_diameter, plating_diameter)
            create_solder_mask_expansion = lambda : Rectangle(sme_pos.x, sme_pos.y, solder_mask_width, solder_mask_width)

        elif plating_shape == 'circle':
            create_shape = lambda : Circle(pad_pos.x, pad_pos.y, plating_diameter / 2)

            solder_mask_radius = solder_mask_expansion + (plating_diameter / 2)
            create_solder_mask_expansion = lambda : Circle(sme_pos.x, sme_pos.y, solder_mask_radius)

        elif plating_shape == 'rectangle':
            solder_mask_width = (solder_mask_expansion * 2) + plating_width
            solder_mask_height = (solder_mask_expansion * 2) + plating_height

            create_shape = lambda : Rectangle(pad_pos.x, pad_pos.y, plating_width, plating_height)
            create_solder_mask_expansion = lambda : Rectangle(sme_pos.x, sme_pos.y, solder_mask_width, solder_mask_height)

        elif plating_shape == 'rounded rectangle':
            solder_mask_width = (solder_mask_expansion * 2) + plating_width
            solder_mask_height = (solder_mask_expansion * 2) + plating_height

            create_shape = lambda : RoundedRectangle(pad_pos.x, pad_pos.y, plating_width, plating_height, plating_radius)
            create_solder_mask_expansion = lambda : RoundedRectangle(sme_pos.x, sme_pos.y, solder_mask_width, solder_mask_height, plating_radius)

        else:
            raise ValueError('unexpected shape for plated through hole "{0}"'.format(plating_shape))

        # cirle of radius 'solder_mask_expansion' + ('plating_diameter' / 2) in the top and bottom silkscreen layers
        solder_mask_radius = solder_mask_expansion + (plating_diameter / 2)
        top_solder_mask = FBody()
        top_solder_mask.add_shape(create_solder_mask_expansion())
        bodies.append((FootprintAttribute(0, 0, 0, False, 'top solder mask'), top_solder_mask))

        bottom_solder_mask = FBody()
        bottom_solder_mask.add_shape(create_solder_mask_expansion())
        bodies.append((FootprintAttribute(0, 0, 0, False, 'bottom solder mask'), bottom_solder_mask))

        # circle of diameter 'internal_diameter' on the hole layer
        hole = FBody()
        hole.add_shape(Circle(pad_pos.x, pad_pos.y, internal_diameter / 2))
        bodies.append((FootprintAttribute(0, 0, 0, False, 'hole'), hole))

        # circles of diameter 'plating_diameter' on each connection layer
        for layer_name in attached_layers:
            connected_layer = FBody()
            if layer_name == 'top copper' or layer_name == 'bottom copper':
                connected_layer.add_shape(create_shape())
            else:
                connected_layer.add_shape(Circle(pad_pos.x, pad_pos.y, plating_diameter / 2))
            bodies.append((FootprintAttribute(0, 0, 0, False, layer_name), connected_layer))

        return bodies

    def __repr__(self):
        return '''<PlatedThroughHole({0}, {1}, '{2}', {3}, {4}, {5})>'''.format(self.x, self.y, self.layer, self.rotation, self.flip, self.attributes)
_parser_types[PlatedThroughHole.type_name] = PlatedThroughHole.parse_gen_obj_json


class Via(GeneratedObject):
    type_name = 'via'

    @classmethod
    def parse_gen_obj_json(cls, gen_obj_json):
        return Via(int(gen_obj_json['x']),
                   int(gen_obj_json['y']),
                   gen_obj_json['layer'],
                   float(gen_obj_json['rotation']),
                   gen_obj_json['flip'],
                   gen_obj_json['attributes'])

    def bodies(self, offset, instance_attributes):
        """ Generated the bodies for the Via with instance attribute overrides. Returns placment attribute and body
            pairs.

        """
        pos = Point(self.x, self.y)

        attached_layers = self.get_attr('attached_layers', '', instance_attributes).split(',')
        solder_mask_expansion = self.get_int_attr('solder_mask_expansion', 0, instance_attributes)
        plating_diameter = self.get_int_attr('plating_diameter', 0, instance_attributes)
        internal_diameter = self.get_int_attr('internal_diameter', 0, instance_attributes)
        solder_mask_radius = solder_mask_expansion + (plating_diameter / 2)

        # placment attribute + body pairs making up the generated object
        bodies = []

        top_solder_mask = FBody()
        top_solder_mask.add_shape(Circle(pos.x, pos.y, solder_mask_radius))
        bodies.append((FootprintAttribute(0, 0, 0, False, 'top solder mask'), top_solder_mask))

        bottom_solder_mask = FBody()
        bottom_solder_mask.add_shape(Circle(pos.x, pos.y, solder_mask_radius))
        bodies.append((FootprintAttribute(0, 0, 0, False, 'bottom solder mask'), bottom_solder_mask))

        # circle of diameter 'internal_diameter' on the hole layer
        hole = FBody()
        hole.add_shape(Circle(pos.x, pos.y, internal_diameter / 2))
        bodies.append((FootprintAttribute(0, 0, 0, False, 'hole'), hole))

        # circles of diameter 'plating_diameter' on each connection layer
        for layer_name in attached_layers:
            connected_layer = FBody()
            connected_layer.add_shape(Circle(pos.x, pos.y, plating_diameter / 2))
            bodies.append((FootprintAttribute(0, 0, 0, False, layer_name), connected_layer))

        return bodies

    def __repr__(self):
        return '''<Via({0}, {1}, '{2}', {3}, {4}, {5})>'''.format(self.x, self.y, self.layer, self.rotation, self.flip, self.attributes)
_parser_types[Via.type_name] = Via.parse_gen_obj_json



class CenterCross(GeneratedObject):
    type_name = 'center cross'

    @classmethod
    def parse_gen_obj_json(cls, gen_obj_json):
        return CenterCross(int(gen_obj_json['x']),
                           int(gen_obj_json['y']),
                           gen_obj_json['layer'],
                           float(gen_obj_json['rotation']),
                           gen_obj_json['flip'],
                           gen_obj_json['attributes'])


    def bodies(self, offset, instance_attributes):
        return []
_parser_types[CenterCross.type_name] = CenterCross.parse_gen_obj_json



class Path(object):
    """ A path formed from connected points. """

    def __init__(self, layer, points, width, is_closed):
        self.layer = layer
        self.points = points
        self.width = width
        self.is_closed = is_closed


    def min_point(self):
        """ Return the min point of the shape """
        if len(self.points) < 1:
            # by convention
            x, y = 0, 0
        else:
            x = min([pt.x for pt in self.points])
            y = min([pt.y for pt in self.points])
        return Point(x, y)


    def max_point(self):
        """ Return the max point of the shape """
        if len(self.points) < 1:
            # by convention
            x, y = 0, 0
        else:
            x = max([pt.x for pt in self.points])
            y = max([pt.y for pt in self.points])
        return Point(x, y)


    def move(self, x, y):
        """ Move the polygon to an explicit position. """
        dx = x - self.point[0].x
        dy = y - self.point[0].y

        for point in self.points:
            point.x -= dx
            point.y -= dy


    def add_point(self, x, y=None):
        """ Add a point to the polygon """
        self.points.append(Point(x, y))


    def scale(self, factor):
        """ Scale the x & y coordinates in the polygon. """
        for point in self.points:
            point.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the polygon. """
        for point in self.points:
            point.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the polygon. """
        for point in self.points:
            point.rebase_y_axis(height)


    def json(self):
        """ Return the polygon as JSON """
        return {
            "points": [point.json() for point in self.points],
            "layer": self.layer,
            "width": self.width,
            "is_closed": self.is_closed,
            }



class Pour(object):
    """ A pour formed from connected points with additive and subtractive shapes. """

    def __init__(self, layer, points, subtractive_shapes, readded_shapes):
        self.layer = layer
        self.points = points
        self.subtractive_shapes = subtractive_shapes
        self.readded_shapes = readded_shapes


    def min_point(self):
        """ Return the min point of the shape """
        if len(self.points) < 1:
            # by convention
            x, y = 0, 0
        else:
            x = min([pt.x for pt in self.points])
            y = min([pt.y for pt in self.points])
        return Point(x, y)


    def max_point(self):
        """ Return the max point of the shape """
        if len(self.points) < 1:
            # by convention
            x, y = 0, 0
        else:
            x = max([pt.x for pt in self.points])
            y = max([pt.y for pt in self.points])
        return Point(x, y)


    def move(self, x, y):
        """ Move the polygon to an explicit position. """
        dx = x - self.point[0].x
        dy = y - self.point[0].y

        for point in self.points:
            point.x -= dx
            point.y -= dy


    def add_point(self, x, y=None):
        """ Add a point to the polygon """
        self.points.append(Point(x, y))


    def scale(self, factor):
        """ Scale the x & y coordinates in the pour. """
        for point in self.points:
            point.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the pour. """
        for point in self.points:
            point.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the pour. """
        for point in self.points:
            point.rebase_y_axis(height)


    def json(self):
        """ Return the polygon as JSON """
        return {
            "points": [point.json() for point in self.points],
            "layer": self.layer,
            "subtractive_shapes": [subtractive_shape.json() for subtractive_shape in self.subtractive_shapes],
            "readded_shapes": [readded_shape.json() for readded_shape in self.readded_shapes],
            }



########NEW FILE########
__FILENAME__ = layout
#!/usr/bin/env python2
""" The layout class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import copy
import freetype
import logging
import re

from upconvert.core.shape import Circle, Label, Line, Point, Rectangle, RoundedRectangle

log = logging.getLogger('core.layout')


class Layout:
    """ Represents the design schematic as a PCB Layout. """

    def __init__(self):
        self.layers = list()


class Layer:
    """ A layer in the gerber (not a layer in the design). """

    def __init__(self, name='', polarity='dark'):
        self.name = name
        self.polarity = polarity
        self.images = list()
        self.apertures = dict()
        self.macros = dict()


class Image:
    """
    An image layer (not a PCB layer).

    Image layers can be additive or subtractive. Therefore they
    must be applied successively to build up a final image
    representing a single layer of the PCB (ie, a single gerber
    file).

    Image layers will be applied in the order they appear in the
    layer[n].images list of the Layout. Subtractive image layers
    only subtract from previous image layers - not subsequent
    image layers.

    Example
    =======
    For a ground plane that is partly negated to make room for
    traces, define three image layers in the following order:

        1. the ground plane
        2. the area(s) to be negated (as a subtractive image)
        3. the traces to be laid within the negated area(s)
    """
    attr_re = re.compile(r'{{[^}]*}}')


    def __init__(self, name='Untitled Image', is_additive=True, font_renderer=None):
        self.name = name
        self.is_additive = is_additive
        self.x_repeats = 1
        self.x_step = None
        self.y_repeats = 1
        self.y_step = None
        self.fills = list()
        self.smears = list()
        self.shape_instances = list()
        self.complex_instances = list()
        self.face = font_renderer

    def not_empty(self):
        """ True if image contains only metadata. """
        return (self.fills or self.smears or self.shape_instances or self.complex_instances) and True or False


    def resolve_text(self, text, attr_source):
        ''' Resolve attribute placeholders in a piece of text using an attr_source method. '''
        for attr in self.attr_re.findall(text):
            text = text.replace(attr, attr_source(attr[2:-2]), 1)
        return text


    def add_shape(self, shape, parent, parent_offset, offset):
        """ Add a shape to the image. (might be added as a smear or fill) """
        # Copy the shape so it can be mutated without affecting other instances
        shapecpy = copy.deepcopy(shape)

        # XXX(shamer): a label needs to be rendered before in-place rotations are made so the bounding box for the shape
        # are known
        if isinstance(shapecpy, Label):
            self.face.set_char_size(int(shapecpy.font_size))

            label_contours = []

            x_offset = 0
            y_offset = 0
            label_text = self.resolve_text(shapecpy.text, parent.get_attribute)
            for i, c in enumerate(label_text):
                self.face.load_char(c, flags=freetype.ft_enums.FT_LOAD_NO_BITMAP)
                slot = self.face.glyph
                outline = slot.outline

                glyph_contours = []

                start, end = 0, 0
                # Iterate over each contour separately. Characters like 'g' have multiple contours as they cannot be
                # walked with a contiguous set of arcs. The contours list contains the index of the point that the
                # contour starts on.
                for contour_idx in range(len(outline.contours)):
                    end = outline.contours[contour_idx]
                    points = [Point(t[0], t[1]) for t in outline.points[start:end+1]]
                    tags = outline.tags[start:end+1]
                    # Close the contour by repeating the last point.
                    points.append(copy.deepcopy(points[0]))
                    tags.append(copy.deepcopy(tags[0]))

                    segments = [[points[0], ], ]
                    # Group points into segments. The tag identifies real vs control points.
                    for point_idx in range(1, len(points) ):
                        segments[-1].append(points[point_idx])
                        if tags[point_idx] & (1 << 0) and point_idx < (len(points)-1):
                            segments.append([copy.deepcopy(points[point_idx]),])

                    # take the fist and last points of each segment (the non-control points). To approximate the curves
                    # using straight lines.
                    glyph_contours.append([[segment[0], segment[-1]] for segment in segments])

                    start = end+1

                # update the segments in the glyph with the x_offset
                for contour_segments in glyph_contours:
                    for segments in contour_segments:
                        for point in segments:
                            point.x += x_offset
                            point.y += y_offset
                label_contours.extend(glyph_contours)

                x_offset += slot.advance.x
                # adjust amount to advance with kerning offset
                if i + 1 < len(label_text):
                    next_c = label_text[i + 1]
                    x_offset += self.face.get_kerning(c, next_c).x

            # Update the segments for pre-render shifts, rotates, alignment
            for contour_segments in label_contours:
                for segments in contour_segments:
                    if shapecpy.align == 'center':
                        segments[0].shift(-(x_offset / 2), 0)
                        segments[1].shift(-(x_offset / 2), 0)

                    if shapecpy.rotation:
                        segments[0].rotate(shapecpy.rotation)
                        segments[1].rotate(shapecpy.rotation)

                    if shapecpy.flip_horizontal:
                        segments[0].flip(shapecpy.flip_horizontal)
                        segments[1].flip(shapecpy.flip_horizontal)

                    shapecpy._segments.append(segments)

            # Calculate the bounding fox the label from the segments
            min_point = [2**100, 2**100]
            max_point = [-2**100, -2**100]
            for contour_segments in label_contours:
                for segments in contour_segments:
                    min_point[0] = min(segments[0].x, segments[1].x, min_point[0])
                    max_point[0] = max(segments[0].x, segments[1].x, max_point[0])
                    min_point[1] = min(segments[0].y, segments[1].y, min_point[1])
                    max_point[1] = max(segments[0].y, segments[1].y, max_point[1])
            shapecpy._min_point = Point(min_point[0], min_point[1])
            shapecpy._max_point = Point(max_point[0], max_point[1])


        shapecpy.shift(offset.x, offset.y)
        if parent_offset.rotation != 0:
            shapecpy.rotate(parent_offset.rotation)
        if parent_offset.flip_horizontal:
            shapecpy.flip(parent_offset.flip_horizontal)
        shapecpy.shift(parent_offset.x, parent_offset.y)

        if offset.rotation != 0:
            if parent_offset.flip_horizontal:
                shapecpy.rotate(-offset.rotation, in_place=True)
            else:
                shapecpy.rotate(offset.rotation, in_place=True)
        if offset.flip_horizontal:
            shapecpy.flip(offset.flip_horizontal)

        if isinstance(shapecpy, Line):
            # FIXME(shamer): line  doesn't have an explicit width. Gets used for outlines. Defaulted to 0.15mm
            self.smears.append(Smear(shapecpy, Circle(0, 0, 0.15 * 1000000)))

        elif isinstance(shapecpy, Circle):
            self.shape_instances.append(ShapeInstance(Point(shapecpy.x, shapecpy.y), Aperture(None, shapecpy, None)))

        elif isinstance(shapecpy, Rectangle):
            #shapecpy.x += shapecpy.width
            #shapecpy.y -= shapecpy.height / 2
            shapecpy.width = abs(shapecpy.width)
            shapecpy.height = abs(shapecpy.height)
            if shapecpy.rotation != 0:
                instance_name = 'Rect-W{width}-H{height}-RO{rotation}'.format(height=shapecpy.height,
                                                                              width=shapecpy.width,
                                                                              rotation=shapecpy.rotation)
                if shapecpy.flip_horizontal:
                    instance_name += '-F'

                # XXX(shamer): additional copy is made so the x, y can be reset for use as a ComplexInstance
                shapecpycpy = copy.deepcopy(shapecpy)
                shapecpycpy.x = 0
                shapecpycpy.y = 0
                shapecpycpy.is_centered = True
                primitives = [Primitive(1, 0.0, shapecpycpy)]
                self.complex_instances.append(ComplexInstance(instance_name, Point(shapecpy.x, shapecpy.y), primitives))
            else:
                self.shape_instances.append(ShapeInstance(Point(shapecpy.x, shapecpy.y), Aperture(None, shapecpy, None)))

        elif isinstance(shapecpy, RoundedRectangle):
            # Rounded rectangle is added as a macro with two rectangles to fill out the body and four circles to make up
            # the corners. `roundrect` is assumed to already be centered.
            primitives = []
            radius = abs(shapecpy.radius)
            inner_height = abs(shapecpy.height) - (radius * 2)
            inner_width = abs(shapecpy.width) - (radius * 2)
            half_width = inner_width / 2.0
            half_height = inner_height / 2.0

            high_rect = Rectangle(0, 0, abs(inner_width), abs(shapecpy.height), is_centered=True)
            wide_rect = Rectangle(0, 0, abs(shapecpy.width), abs(inner_height), is_centered=True)
            primitives.append(Primitive(1, 0.0, high_rect))
            primitives.append(Primitive(1, 0.0, wide_rect))
            primitives.append(Primitive(1, 0.0, Circle(-half_width, half_height, shapecpy.radius)))
            primitives.append(Primitive(1, 0.0, Circle(half_width, half_height, shapecpy.radius)))
            primitives.append(Primitive(1, 0.0, Circle(half_width, -half_height, shapecpy.radius)))
            primitives.append(Primitive(1, 0.0, Circle(-half_width, -half_height, shapecpy.radius)))

            # rotate the positioning of the rounded corners (the circles)
            for primitive in primitives:
                primitive.shape.rotate(shapecpy.rotation)

            instance_name = 'RR-H{height}-W{width}-R{radius}-RO{rotation}'.format(height=abs(shapecpy.height),
                                                                                  width=abs(shapecpy.width),
                                                                                  radius=radius,
                                                                                  rotation=shapecpy.rotation)
            if shapecpy.flip_horizontal:
                instance_name += '-F'

            self.complex_instances.append(ComplexInstance(instance_name,
                                                          Point(shapecpy.x, shapecpy.y),
                                                          primitives))

        elif isinstance(shapecpy, Label):
            # TODO(shamer): cache positions segments for glyphs
            # FIXME((shamer): make baseline shift

            # TODO(shamer) select the correct font based off of the label.font_family

            # Debugging, used to show the anchor point of the label
            #self.shape_instances.append(ShapeInstance(Point(shapecpy.x, shapecpy.y), Aperture(None, Circle(0, 0, 1000000 / 5), None)))

            for segments in shapecpy._segments:
                line = Line(segments[0], segments[1])
                line.shift(shapecpy.x, shapecpy.y)
                self.smears.append(Smear(line, Circle(0, 0, 0.1016 * 1000000))) # 4 Mils


class Segment:
    """ A single segment of a trace. """

    def __init__(self, layer, p1, p2, width):
        self.layer = layer
        self.p1 = p1
        self.p2 = p2
        self.width = width

    def __repr__(self):
        return '''<Segment(layer='{0}', p1={1}, p2={2}, width{3})>'''.format(self.layer, self.p1, self.p2, self.width)


class Fill:
    """
    A closed loop of connected segments (lines/arcs).

    The outline points define the outline of the fill. They
    must be contiguous, listed in order (ie, each point
    connects with the previous point and the next point)
    and not intersect each other.
    """

    def __init__(self, outline_points=None):
        self.outline_points = outline_points or list()


class Smear:
    """ A line drawn by a rectangular aperture. """

    def __init__(self, line, shape):
        self.line = line
        self.shape = shape


class ShapeInstance:
    """
    An instance of a shape defined by an aperture.

    Instead of wrapping the aperture itself, we wrap
    its constituent shape and hole defs, because
    gerber does not prohibit an aperture from being
    redefined at some arbitrary point in the file.

    x and y attributes serve as an offset.
    """

    def __init__(self, point, aperture):
        self.x = point.x
        self.y = point.y
        self.shape = aperture.shape
        self.hole = aperture.hole


class ComplexInstance:
    """
    A complex instance of a collection of primitive shapes.

    """

    def __init__(self, name, point, primitives):
        self.name = name
        self.x = point.x
        self.y = point.y
        self.primitives = primitives


class Aperture:
    """
    A simple shape, with or without a hole.

    If the shape is not defined by a macro, its class
    must be one of Circle, Rectangle, Obround or
    RegularPolygon.

    If the shape is not defined by a macro, it may have
    a hole. The class of the hole must be either Circle
    or Rectangle. Shape and hole are both centered on
    the origin. Placement is handled by metadata
    connected to the aperture when it used.

    Holes must be fully contained within the shape.

    Holes never rotate, even if the shape is rotatable
    (ie, a RegularPolygon).
    """

    def __init__(self, code, shape, hole):
        self.code = code

        #XXX(shamer): aperture doesn't include the offset/placement of the shape
        shapecpy = copy.deepcopy(shape)
        shapecpy.x = 0
        shapecpy.y = 0

        self.shape = shapecpy
        self.hole = hole


    def __eq__(self, other):
        """ Compare 2 apertures. """
        if not isinstance(other, Aperture):
            return False

        same_shape = self.shape.__dict__ == other.shape.__dict__
        same_hole = (self.hole == other.hole or
                     (self.hole and other.hole and
                      self.hole.__dict__ == other.hole.__dict__))
        return same_shape and same_hole


    def __repr__(self):
        return '<Aperture(code={0}, shape={1}, hole={2})>'.format(self.code, self.shape, self.hole)


class Macro:
    """
    Complex shape built from multiple primitives.

    Primitive shapes are added together in the order they
    appear in the list. Subtractive shapes subtract only
    from prior shapes, not subsequent shapes.

    """
    # TODO(shamer): How can parameters get stored?
    def __init__(self, name, primitives):
        self.name = name
        self.primitives = primitives

    def __eq__(self, other):
        return self.primitives == other.primitives



class MacroAperture:
    """ An aperture utilizing a macro with specific parameters. """

    def __init__(self, code, name, params=None):
        self.code = code
        self.name = name
        self.params = params


    def __eq__(self, other):
        if not isinstance(other, MacroAperture):
            return False

        return (self.name == other.name and self.params == other.params)


class Primitive:
    """ A shape with rotation and exposure modifiers. """

    def __init__(self, is_additive, rotation, shape):
        self.is_additive = is_additive
        self.rotation = rotation
        self.shape = shape

    def __eq__(self, other):
        return (self.is_additive == other.is_additive and
                self.rotation == other.rotation and
                self.shape == other.shape)

########NEW FILE########
__FILENAME__ = net
#!/usr/bin/env python2
""" The net class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.shape import Point
from upconvert.utils.stringify import stringify_attributes


class Net:
    """ a Net with metadata and a list of points (with connections)
    Internal representation of a net, closely matches JSON net """

    def __init__(self, net_id):
        self.net_id = net_id
        self.points = dict()
        self.attributes = dict()
        self.annotations = list()


    def bounds(self):
        """ Return the min and max points of the bounding box """
        x_values = [p.x for p in self.points.values()]
        y_values = [p.y for p in self.points.values()]
        # get a list of all the bounding points for annotations
        bounds = sum([ann.bounds() for ann in self.annotations], [])
        x_values.extend([pt.x for pt in bounds])
        y_values.extend([pt.y for pt in bounds])
        return [Point(min(x_values), min(y_values)),
                Point(max(x_values), max(y_values))]


    def add_annotation(self, annotation):
        """ Add an annotation """
        self.annotations.append(annotation)


    def add_attribute(self, key, value):
        """ Add an attribute """
        self.attributes[key] = value


    def add_point(self, point):
        """ Add a point p to the net """
        self.points[point.point_id] = point


    def conn_point(self, point_a, point_b):
        """ connect point b to point a """
        self.points[point_a.point_id].connected_points.append(point_b.point_id)


    def connected(self, seg):
        """ is segment connected to this net """
        point_a, point_b = seg
        return point_a.point_id in self.points or point_b.point_id in self.points


    def connect(self, seg):
        """ connect segment to this net """
        point_a, point_b = seg
        if point_a.point_id not in self.points:
            self.add_point(point_a)
        self.conn_point(point_a, point_b)
        if point_b.point_id not in self.points:
            self.add_point(point_b)
        self.conn_point(point_b, point_a)


    def scale(self, factor):
        """ Scale the x & y coordinates in the net. """
        for point in self.points.values():
            point.scale(factor)
        for anno in self.annotations:
            anno.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the net. """
        for point in self.points.values():
            point.shift(dx, dy)
        for anno in self.annotations:
            anno.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the net. """
        for point in self.points.values():
            point.rebase_y_axis(height)
        for anno in self.annotations:
            anno.rebase_y_axis(height)


    def json(self):
        """ Return a net as JSON """
        return {
            "net_id": self.net_id,
            "attributes": stringify_attributes(self.attributes),
            "annotations": [ann.json() for ann in self.annotations],
            "points": sorted([point.json() for point in self.points.values()],
                             key=lambda point : point.get('point_id'))
            }


class NetPoint:
    """ A point, basic element in a net """

    def __init__(self, point_id, x, y):
        self.point_id = point_id
        self.x = x
        self.y = y
        self.connected_points = list()
        self.connected_components = list()


    def add_connected_point(self, point_id):
        """ Add a connected point """
        self.connected_points.append(point_id)


    def add_connected_component(self, connected_component):
        """ Add a connected component """
        self.connected_components.append(connected_component)


    def scale(self, factor):
        """ Scale the x & y coordinates in the point. """
        self.x *= factor
        self.y *= factor


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the point. """
        self.x += dx
        self.y += dy


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the point. """
        self.y = height - self.y


    def json(self):
        """ Return a netpoint as JSON """
        return {
            "point_id": self.point_id,
            "x": int(self.x),
            "y": int(self.y),
            "connected_points": sorted(self.connected_points),
            "connected_components": [comp.json() for comp in self.connected_components]
            }


class ConnectedComponent:
    """ Object representing a component connected to a net """

    def __init__(self, instance_id, pin_number):
        self.instance_id = instance_id
        self.pin_number = pin_number


    def json(self):
        """ Return a connected component as JSON """
        return {
            "instance_id": self.instance_id,
            "pin_number": self.pin_number
            }

########NEW FILE########
__FILENAME__ = shape
#!/usr/bin/env python2
""" The shape class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import logging
from math import sqrt, pi, sin, cos, asin, acos

log = logging.getLogger('core.shape')


class Shape(object):
    """a Shape with metadata and a list of shape parts
    Internal representation of the shapes closely matches JSON shapes """

    def __init__(self):
        self.type = None
        self.attributes = dict()
        self.styles = dict()
        self.rotation = 0
        self.flip_horizontal = False
        self.x = 0
        self.y = 0

    def rotate(self, rotation, in_place=False):
        self.rotation += rotation

        if not in_place:
            self.x, self.y = self.y, self.x
            if rotation == 0.5 or rotation == -1.5:
                self.y = -self.y;
            elif rotation == -0.5 or rotation == 1.5:
                self.x = -self.x;
            elif rotation == 1 or rotation == -1:
                self.x, self.y = -self.y, -self.x
            else:
                # p'x = cos(theta) * px - sin(theta) * py
                # p'y = sin(theta) * px + cos(theta) * py
                # (reversed to reverse the first reversal.)
                theta = rotation * pi;
                x = sin(theta) * self.x + cos(theta) * self.y;
                y = cos(theta) * self.x - sin(theta) * self.y;
                self.x = x;
                self.y = y;


    def __eq__(self, other):
        return (self.x == other.x and
                self.y == other.y and
                self.rotation == other.rotation and
                self.flip_horizontal == other.flip_horizontal)


    def flip(self):
        self.flip_horizontal = not self.flip_horizontal


    def add_attribute(self, key, value):
        """ Add attribute to a shape """
        self.attributes[key] = value


    def shift(self, dx, dy):
        """ Shift the x & y coordinates of the shape. """
        self.x += dx
        self.y += dy


    def bounds(self):
        """ Return the min and max points of the bounding box """
        return [self.min_point(), self.max_point()]


    def ranges(self):
        """ Return the min - max x and y ranges of the bounding box """
        minpt, maxpt = self.bounds()
        return [minpt.x, maxpt.x], [minpt.y, maxpt.y]


    def min_point(self):
        """ Return the min point of the shape """
        raise NotImplementedError("Not implemented")


    def max_point(self):
        """ Return the max point of the shape """
        raise NotImplementedError("Not implemented")


class Rectangle(Shape):
    """ A rectangle, defined by x, y of top left corner and width, height"""

    def __init__(self, x, y, width, height, is_centered=False):
        super(Rectangle, self).__init__()
        self.type = "rectangle"
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.is_centered = is_centered


    def __eq__(self, other):
        return (super(Rectangle, self).__eq__(other) and
                (self.type == other.type and
                 self.width == other.width and
                 self.height == other.height and
                 self.is_centered == other.is_centered))


    def min_point(self):
        """ Return the min point of the shape """
        return Point(min(self.x, self.x + self.width),
                     min(self.y, self.y + self.height))


    def max_point(self):
        """ Return the max point of the shape """
        return Point(max(self.x, self.x + self.width),
                     max(self.y, self.y + self.height))


    def move(self, x, y):
        """ Move the circle to an explicit position. """
        self.x = x
        self.y = y


    @classmethod
    def from_corners(cls, x, y, x2, y2):
        """ (x, y) is the top left corner, (x2, y2) is the bottom right """
        width = x2 - x
        height = y2 - y
        return cls(x, y, width, height)


    def scale(self, factor):
        """ Scale the x & y coordinates in the rectangle. """
        self.x *= factor
        self.y *= factor
        self.width *= factor
        self.height *= factor


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the rectangle. """
        self.x += dx
        self.y += dy


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the rectangle. """
        self.y = height - self.y


    def json(self):
        """ Return the rectangle as JSON """
        return {
            "height": int(self.height),
            "type": self.type,
            "width": int(self.width),
            "x": int(self.x),
            "y": int(self.y),
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            "is_centered": self.is_centered,
            }


    def rotate(self, rotation, in_place=False):
        if rotation == 0:
          return

        super(Rectangle, self).rotate(rotation, in_place)

        """
        self.width, self.height = self.height, self.width
        if rotation == 0.5 or rotation == -1.5:
          self.height = -self.height;
        elif rotation == -0.5 or rotation == 1.5:
          self.width = -self.width;
        elif rotation == 1 or rotation == -1:
          self.width, self.height = -self.height, -self.width
        else:
          raise ValueError('non 0.5 multiple rotation')
        """


    def flip(self, do_flip, about=None):
        super(Rectangle, self).flip()
        if not about:
            about = Point(0, 0)
        self.width = -self.width
        self.x = -(self.x - about.x) + about.x


class RoundedRectangle(Shape):
    """ A rectangle with rounded corners, defined by x, y of top left corner
    and width, height and corner radius"""

    def __init__(self, x, y, width, height, radius): # pylint: disable=R0913
        super(RoundedRectangle, self).__init__()
        self.type = "rounded_rectangle"
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.radius = radius


    def __eq__(self, other):
        return (super(RoundedRectangle, self).__eq__(other) and
                (self.type == other.type and
                 self.width == other.width and
                 self.height == other.height and
                 self.radius == other.radius))


    def min_point(self):
        """ Return the min point of the shape """
        return Point(min(self.x, self.x + self.width),
                     min(self.y, self.y + self.height))


    def max_point(self):
        """ Return the max point of the shape """
        return Point(max(self.x, self.x + self.width),
                     max(self.y, self.y + self.height))


    def move(self, x, y):
        """ Move the rounded rectangle to an explicit position. """
        self.x = x
        self.y = y


    @classmethod
    def from_corners(cls, x, y, x2, y2, radius): # pylint: disable=R0913
        """ x and y are the top left corner of the rectangle, x2 and y2 are the
        bottom right corner of the rectangle """
        width = x2-x
        height = y2-y
        return cls(x, y, width, height, radius)


    def as_arcs_lines(self):
        """ a list of arcs and lines that trace out the rectangle """
        x, y, h, w = self.x, self.y, self.height, self.width
        rad, dia = self.radius, self.radius * 2

        hor = [(px, py) for py in [y, y - h] for px in [x + rad, x + w - rad]]
        ver = [(px, py) for px in [x, x + w] for py in [y - rad, y - h + rad]]
        lines = [Line(Point(p0), Point(p1)) for (p1, p0) in
                 [hor[:2], hor[2:], ver[:2], ver[2:]]]

        arc_pts = [(cx, cy) for cx in [x + rad, x + w - rad]
                            for cy in [y - rad, y - h + rad]]
        arcs = [Arc(cx, cy, ang, (ang+0.5) % 2, rad) for ((cx, cy), ang) in
                zip(arc_pts, [1, 0.5, 1.5, 0])]

        return arcs + lines


    def scale(self, factor):
        """ Scale the x & y coordinates in the rounded rectangle. """
        self.x *= factor
        self.y *= factor
        self.width *= factor
        self.height *= factor
        self.radius *= factor


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the rectangle. """
        self.y = height - self.y


    def json(self):
        """ Return the rounded rectangle as JSON """
        return {
            "height": int(self.height),
            "type": self.type,
            "width": int(self.width),
            "x": int(self.x),
            "y": int(self.y),
            "radius": int(self.radius),
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }


    def rotate(self, rotation, in_place=False):
        if rotation == 0:
          return

        super(RoundedRectangle, self).rotate(rotation, in_place)

        """
        self.width, self.height = self.height, self.width
        if rotation == 0.5 or rotation == -1.5:
          self.height = -self.height;
        elif rotation == -0.5 or rotation == 1.5:
          self.width = -self.width;
        elif rotation == 1 or rotation == -1:
          self.width, self.height = -self.height, -self.width
        else:
          raise ValueError('non 0.5 multiple rotation')
        """


    def flip(self, do_flip, about=None):
        if not about:
            about = Point(0, 0)
        self.width = -self.width
        self.x = -(self.x - about.x) + about.x


class Arc(Shape):
    """ arc defined by center point x, y, two angles between which an
    arc is drawn, and a radius """

    def __init__(self, x, y, start_angle, end_angle, radius): # pylint: disable=R0913
        super(Arc, self).__init__()
        self.type = "arc"
        self.x = x
        self.y = y
        self.start_angle = start_angle
        self.end_angle = end_angle
        self.radius = radius


    def __eq__(self, other):
        return (super(Arc, self).__eq__(other) and
                (self.type == other.type and
                 self.start_angle == other.start_angle and
                 self.end_angle == other.end_angle and
                 self.radius == other.radius))


    def _contains_angle(self, theta):
        """Return True iff tracing the arc passes through theta"""
        if abs(self.start_angle - self.end_angle) >= 2:
            # ha ha I'm actually a circle!
            return True
        # normalize angles to the interval [0, 2)
        start = self.start_angle % 2.0
        end = self.end_angle % 2.0
        theta = theta % 2.0

        if start == end:
            # arc is really a dot, I suppose?
            return theta == start
        elif start < end:
            return start <= theta and theta <= end
        else:
            # arc spans [start, 2.0), wraps around, and also spans [0, end]
            return start <= theta or theta <= end


    def min_point(self):
        """ Return the min point of the shape """
        start, end = (self.start_angle % 2.0) * pi, (self.end_angle % 2.0) * pi
        if self._contains_angle(1.5):
            # the top of the circle is included
            y = self.y - self.radius
        else:
            y = self.y + min([sin(start), sin(end)]) * self.radius
        if self._contains_angle(1):
            x = self.x - self.radius
        else:
            x = self.x + min([cos(start), cos(end)]) * self.radius
        return Point(int(round(x)), int(round(y)))


    def max_point(self):
        """ Return the max point of the shape """
        # assuming angle is in radians/pi, such that an angle of 1.0 is 180
        # degrees, assuming 0 is 3 o'clock, and angles increase clockwise.
        # normalize angles to the interval [0, 2)
        start, end = (self.start_angle % 2.0) * pi, (self.end_angle % 2.0) * pi
        if self._contains_angle(0.5):
            # the bottom of the circle is included
            y = self.y + self.radius
        else:
            y = self.y + max([sin(start), sin(end)]) * self.radius
        if self._contains_angle(0):
            x = self.x + self.radius
        else:
            x = self.x + max([cos(start), cos(end)]) * self.radius
        return Point(int(round(x)), int(round(y)))


    def move(self, x, y):
        """ Move the arc to an explicit position. """
        self.x = x
        self.y = y


    def ends(self):
        """ Calculate arc endpoints. """
        points = {}
        for ord_ in ('start', 'end'):
            opp = sin(getattr(self, ord_ + '_angle') * pi) * self.radius
            adj = cos(getattr(self, ord_ + '_angle') * pi) * self.radius
            points[ord_] = Point(self.x + adj, self.y - opp)
        return (points['start'], points['end'])


    def scale(self, factor):
        """ Scale the x & y coordinates in the arc. """
        self.x *= factor
        self.y *= factor
        self.radius *= factor


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the arc. """
        self.y = height - self.y


    def json(self):
        """ Return the arc as JSON """
        return {
            "start_angle": self.start_angle,
            "end_angle": self.end_angle,
            "type": self.type,
            "radius": int(self.radius),
            "x": int(self.x),
            "y": int(self.y),
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }


class Circle(Shape):
    """ circle defined by center point x, y and radius """

    def __init__(self, x, y, radius):
        super(Circle, self).__init__()
        self.type = "circle"
        self.x = x
        self.y = y
        self.radius = abs(radius)


    def __eq__(self, other):
        return (super(Circle, self).__eq__(other) and
                (self.type == other.type and
                 self.x == other.x and self.y == other.y and
                 self.radius == other.radius))


    def min_point(self):
        """ Return the min point of the shape """
        x = self.x - self.radius
        y = self.y - self.radius
        return Point(x, y)


    def max_point(self):
        """ Return the max point of the shape """
        x = self.x + self.radius
        y = self.y + self.radius
        return Point(x, y)


    def move(self, x, y):
        """ Move the circle to an explicit position. """
        self.x = x
        self.y = y


    def rotate(self, rotation, in_place=False):
        super(Circle, self).rotate(rotation, in_place)


    def flip(self, do_flip, about=None):
        if not about:
            about = Point(0, 0)
        self.x = -(self.x - about.x) + about.x


    def scale(self, factor):
        """ Scale the x & y coordinates in the circle. """
        self.x *= factor
        self.y *= factor
        self.radius *= factor


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the circle. """
        self.y = height - self.y


    def json(self):
        """ Return the circle as JSON """
        return {
            "radius": int(self.radius),
            "type": self.type,
            "x": int(self.x),
            "y": int(self.y),
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }

    def __repr__(self):
        return '<Circle(x={0}, y={1}, radius={2})>'.format(self.x, self.y, self.radius)


class Label(Shape):
    """ Text label with x, y location, alignment, rotation and text.
    Alignment can be 'left','right', or 'center'. """
    # pylint: disable=W0223

    def __init__(self, x, y, text, font_size=10, font_family='sans-serif', align='left', baseline='alphabetic', rotation=0.0, flip=False):
        super(Label, self).__init__()
        self.type = "label"
        self.x = x
        self.y = y
        self.text = text

        self.baseline = baseline
        self.font_size = font_size
        self.font_family = font_family

        self._min_point = None
        self._max_point = None
        self._segments = []

        # Parse , TODO maybe clean this up some, dont need to accept
        #   all of these inputs, converting to lowercase would be enough
        if align in ["left", "Left"]:
            self.align = "left"
        elif align in ["right", "Right"]:
            self.align = "right"
        elif align in ["center", "Center", "centered", "Centered", "middle"]:
            self.align = "center"
        else:
            raise ValueError('Label requires the align to be either "left", "right", or "center"')


    def __eq__(self, other):
        return (super(Label, self).__eq__(other) and
                (self.type == other.type and
                 self.text == other.text and
                 self.font_size == other.font_size and
                 self.font_family == other.font_family and
                 self.align == other.align and
                 self.baseline == other.baseline))


    def min_point(self):
        """ As a hack, return the label's position. """
        return Point(self.x, self.y)


    def max_point(self):
        """ As a hack, return the label's position. """
        return Point(self.x, self.y)


    def move(self, x, y):
        """ Move the label to an explicit position. """
        self.x = x
        self.y = y


    def rotate(self, rotation, in_place=False):
        if rotation == 0 or rotation == 2:
            return
        self.rotation += rotation

        # FIXME(shamer) use base class rotation

        if in_place:
            assert self._min_point
            assert self._max_point
            assert self._segments

            # Calculate the absolute midpoint of the shape
            mid_x = ((self._max_point.x - self._min_point.x) / 2) + self._min_point.x
            mid_y = ((self._max_point.y - self._min_point.y) / 2) + self._min_point.y

            # Rotate the segments in the label about the midpoint of the shape
            for segments in self._segments:
                segments[0].shift(-mid_x, -mid_y)
                segments[1].shift(-mid_x, -mid_y)
                segments[0].rotate(rotation)
                segments[1].rotate(rotation)
                segments[0].shift(mid_x, mid_y)
                segments[1].shift(mid_x, mid_y)

        else:
            if self._segments:
                for segments in self._segments:
                    segments[0].rotate(rotation)
                    segments[1].rotate(rotation)
                self._min_point.rotate(rotation)
                self._max_point.rotate(rotation)

            self.x, self.y = self.y, self.x
            if rotation == 0.5 or rotation == -1.5:
              self.y = -self.y;
            elif rotation == -0.5 or rotation == 1.5:
              self.x = -self.x;
            elif rotation == 1 or rotation == -1:
              self.x, self.y = -self.y, -self.x
            else:
                # p'x = cos(theta) * px - sin(theta) * py
                # p'y = sin(theta) * px + cos(theta) * py
                # (reversed to reverse the first reversal.)
                theta = rotation * pi;
                x = sin(theta) * self.x + cos(theta) * self.y;
                y = cos(theta) * self.x - sin(theta) * self.y;
                self.x = x;
                self.y = y;


    def flip(self, do_flip, about=None):
        if not about:
            about = Point(0, 0)
        self.x = -(self.x - about.x) + about.x
        self.flip_horizontal ^= do_flip
        if self._segments:
            for segments in self._segments:
                segments[0].flip(do_flip, about)
                segments[1].flip(do_flip, about)
            self._min_point.flip(do_flip, about)
            self._max_point.flip(do_flip, about)


    def scale(self, factor):
        """ Scale the x & y coordinates in the label. """
        self.x *= factor
        self.y *= factor

        if self._min_point:
            self._min_point.scale(factor)
        if self._max_point:
            self._max_point.scale(factor)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the label. """
        self.y = height - self.y


    def json(self):
        """ Return the label as JSON """
        return {
            "type": self.type,
            "font_family": self.font_family,
            "font_size": self.font_size,
            "align": self.align,
            "baseline": self.align,
            "rotation": self.rotation,
            "text": self.text,
            "x": int(self.x),
            "y": int(self.y),
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }


    def __repr__(self):
        return '<Label(x={x}, y={y}, text="{text}", font_size={font_size}, font_family="{font_family}", align="{align}", baseline="{baseline}", rotation={rotation})>'.format(**self.__dict__)



class Line(Shape):
    """ line segment from point1 to point2 """

    def __init__(self, p1, p2):
        super(Line, self).__init__()
        self.type = "line"
        self.p1 = Point(p1)
        self.p2 = Point(p2)


    def __eq__(self, other):
        return (super(Line, self).__eq__(other) and
                (self.type == other.type and
                 self.p1 == other.p1 and
                 self.p2 == other.p2))


    def min_point(self):
        """ Return the min point of the shape """
        x = self.p1.x
        if self.p2.x < x:
            x = self.p2.x
        y = self.p1.y
        if self.p2.y < y:
            y = self.p2.y
        return Point(x, y)


    def max_point(self):
        """ Return the max point of the shape """
        x = self.p1.x
        if self.p2.x > x:
            x = self.p2.x
        y = self.p1.y
        if self.p2.y > y:
            y = self.p2.y
        return Point(x, y)


    def move(self, x, y):
        """ Move the line to an explicit position. """
        dx = x - self.p1.x
        dy = y - self.p1.y

        self.p1.x += dx
        self.p2.x += dx
        self.p1.y += dy
        self.p2.y += dy


    def rotate(self, rotation, in_place=False):
        self.rotation += rotation

        dx = self.p1.x
        dy = self.p1.y
        if in_place:
            self.shift(-dx, -dy)

        self.p1.rotate(rotation)
        self.p2.rotate(rotation)

        if in_place:
            self.shift(dx, dy)


    def flip(self, do_flip, about=None):
        if not about:
            about = Point(0, 0)
        self.p1.flip(do_flip, about)
        self.p2.flip(do_flip, about)


    def scale(self, factor):
        """ Scale the x & y coordinates in the line. """
        self.p1.scale(factor)
        self.p2.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the line. """
        self.p1.shift(dx, dy)
        self.p2.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the line. """
        self.p1.rebase_y_axis(height)
        self.p2.rebase_y_axis(height)


    def json(self):
        """ Return the line as JSON """
        return {
            "type": self.type,
            "p1": self.p1.json(),
            "p2": self.p2.json(),
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }

    def __repr__(self):
        return 'Line(Point(x={0}, y={1}), Point(x={2}, y={3}))'.format(self.p1.x, self.p1.y, self.p2.x, self.p2.y)


class Polygon(Shape):
    """ A polygon is just a list of points, drawn as connected in order """

    def __init__(self, points=None):
        super(Polygon, self).__init__()
        self.type = "polygon"
        self.points = points or list()


    def __eq__(self, other):
        return (super(Polygon, self).__eq__(other) and
                (self.type == other.type and
                 self.points == other.points))


    def min_point(self):
        """ Return the min point of the shape """
        if len(self.points) < 1:
            # by convention
            x, y = 0, 0
        else:
            x = min([pt.x for pt in self.points])
            y = min([pt.y for pt in self.points])
        return Point(x, y)


    def max_point(self):
        """ Return the max point of the shape """
        if len(self.points) < 1:
            # by convention
            x, y = 0, 0
        else:
            x = max([pt.x for pt in self.points])
            y = max([pt.y for pt in self.points])
        return Point(x, y)


    def move(self, x, y):
        """ Move the polygon to an explicit position. """
        dx = x - self.point[0].x
        dy = y - self.point[0].y

        for point in self.points:
            point.x -= dx
            point.y -= dy


    def add_point(self, x, y=None):
        """ Add a point to the polygon """
        self.points.append(Point(x, y))


    def scale(self, factor):
        """ Scale the x & y coordinates in the polygon. """
        for point in self.points:
            point.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the polygon. """
        for point in self.points:
            point.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the polygon. """
        for point in self.points:
            point.rebase_y_axis(height)


    def json(self):
        """ Return the polygon as JSON """
        return {
            "type": self.type,
            "points": [point.json() for point in self.points],
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }


class BezierCurve(Shape):
    """ A parametric curved line """

    def __init__(self, control1, control2, p1, p2):
        super(BezierCurve, self).__init__()
        self.type = "bezier"
        self.control1 = Point(control1)
        self.control2 = Point(control2)
        self.p1 = Point(p1)
        self.p2 = Point(p2)
        self._memo_cache = {'min_point': {}, 'max_point': {}}


    def __eq__(self, other):
        return (super(BezierCurve, self).__eq__(other) and
                (self.type == other.type and
                 self.control1 == other.control1 and
                 self.control2 == other.control2 and
                 self.p1 == other.p1 and
                 self.p2 == other.p2))


    def _line(self):
        """ Convert the curve into a set of points. """
        segments = [(self.p1, self.control1),
                    (self.control1, self.control2),
                    (self.control2, self.p1)]
        # calculate maximum path length as straight lines between each point,
        # (think the curve itself can be no longer than that) then double it so
        # as not to skip points, and use that to decide t step size. Quite
        # possible too many points will result.
        maxpath = sum([sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2) for
                       p1, p2 in segments]) * 2
        # textbook Bezier interpolation
        bzx = lambda t: int(round((1-t) * (1-t) * (1-t) * self.p1.x +
                                 3 * (1-t) * (1-t) * t * self.control1.x +
                                 3 * (1-t) * t * t * self.control2.x +
                                 t * t * t * self.p2.x))
        bzy = lambda t: int(round((1-t) * (1-t) * (1-t) * self.p1.y +
                                 3 * (1-t) * (1-t) * t * self.control1.y +
                                 3 * (1-t) * t * t * self.control2.y +
                                 t * t * t * self.p2.y))
        points = [Point(bzx(t), bzy(t)) for t in [float(s)/maxpath for s in
                                                range(int(maxpath) + 1)]]
        return points


    def min_point(self):
        """ Return the min point of the shape """
        # key the memoization cache on the actual (x,y) co-ords of our points
        cache_key = tuple([(p.x, p.y) for p in [self.p1, self.control1,
                                                self.control2, self.p2]])
        if cache_key not in self._memo_cache['min_point']:
            pts = self._line()
            x_pts = [pt.x for pt in pts]
            y_pts = [pt.y for pt in pts]
            self._memo_cache['min_point'][cache_key] = (min(x_pts), min(y_pts))
        # create a new Point each time, in case the caller modifies them
        return Point(self._memo_cache['min_point'][cache_key])


    def max_point(self):
        """ Return the max point of the shape """
        cache_key = tuple([(p.x, p.y) for p in [self.p1, self.control1,
                                                self.control2, self.p2]])
        if cache_key not in self._memo_cache['max_point']:
            pts = self._line()
            x_pts = [pt.x for pt in pts]
            y_pts = [pt.y for pt in pts]
            self._memo_cache['max_point'][cache_key] = (max(x_pts), max(y_pts))
        return Point(self._memo_cache['max_point'][cache_key])


    def move(self, x, y):
        """ Move the bezier to an explicit position. """
        dx = self.p1.x - x
        dy = self.p1.y - y

        self.p1.x += dx
        self.p2.x += dx
        self.control1.x += dx
        self.control2.x += dx
        self.p1.y += dy
        self.p2.y += dy
        self.control1.y += dy
        self.control2.y += dy


    def build(self, control1x, control1y, control2x, control2y, p1x, # pylint: disable=R0913
            p1y, p2x, p2y):
        """ Build the bezier curve """
        self.type = "bezier"
        self.control1 = {"x":control1x, "y":control1y}
        self.control2 = {"x":control2x, "y":control2y}
        self.p1 = {"x":p1x, "y":p1y}
        self.p2 = {"x":p2x, "y":p2y}


    def scale(self, factor):
        """ Scale the x & y coordinates in the curve. """
        self.control1.scale(factor)
        self.control2.scale(factor)
        self.p1.scale(factor)
        self.p2.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the curve. """
        self.control1.shift(dx, dy)
        self.control2.shift(dx, dy)
        self.p1.shift(dx, dy)
        self.p2.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the curve. """
        self.control1.rebase_y_axis(height)
        self.control2.rebase_y_axis(height)
        self.p1.rebase_y_axis(height)
        self.p2.rebase_y_axis(height)


    def json(self):
        """ Return the bezier curve as JSON """
        return {
            "type": self.type,
            "control1": self.control1.json(),
            "control2": self.control2.json(),
            "p1": self.p1.json(),
            "p2": self.p2.json(),
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }


class Moire(Shape):
    """
    A target of concentric rings with crosshairs.

    Without rotation, the crosshairs are aligned to
    the axes. Rotation is in radians / pi, clockwise
    positive.

    """
    def __init__(self, x, y, outer, ring_thickness, gap, max_rings, # pylint: disable=R0913
                 hair_thickness, hair_length, rotation):
        super(Moire, self).__init__()
        self.type = "moire"
        self.x = x
        self.y = y
        self.outer_diameter = outer
        self.ring_thickness = ring_thickness
        self.gap_thickness = gap
        self.max_rings = max_rings
        self.hair_thickness = hair_thickness
        self.hair_length = hair_length


    def min_point(self):
        """ Return the min point of the shape """
        x = self.x - self._half_box()
        y = self.y - self._half_box()
        return Point(x, y)


    def max_point(self):
        """ Return the max point of the shape """
        x = self.x + self._half_box()
        y = self.y + self._half_box()
        return Point(x, y)


    def move(self, x, y):
        """ Move the moire to an explicit position. """
        self.x = x
        self.y = y


    def _half_box(self):
        """ Return half the width of the bounding square. """
        rad = self.outer_diameter / 2.0
        opp = abs(sin(self.rotation * pi) * rad)
        adj = abs(cos(self.rotation * pi) * rad)
        return max(opp, adj, rad)


    def scale(self, factor):
        """ Scale the x & y coordinates in the moire. """
        self.x *= factor
        self.y *= factor


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the moire. """
        self.x += dx
        self.y += dy


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the moire. """
        self.y = height - self.y


    def json(self):
        """ Return the moire as JSON """
        return {
            "x": int(self.x),
            "y": int(self.y),
            "outer_diameter": self.outer_diameter,
            "ring_thickness": self.ring_thickness,
            "gap_thickness": self.gap_thickness,
            "max_rings": self.max_rings,
            "hair_thickness": self.hair_thickness,
            "hair_length": self.hair_length,
            "rotation": self.rotation,
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }


class Thermal(Shape):
    """
    A ring with 4 gaps, each separated by 0.5 rad/pi.

    Without rotation, the gaps are at the cardinal points.
    Rotation is in rad/pi, clockwise positive.

    """
    def __init__(self, x, y, outer, inner, gap, rotation=0): # pylint: disable=R0913
        super(Thermal, self).__init__()
        self.type = "thermal"
        self.x = x
        self.y = y
        self.outer_diameter = outer
        self.inner_diameter = inner
        self.gap_thickness = gap
        self.rotation = rotation


    def min_point(self):
        """ Return the min point of the shape """
        x = self.x - self._half_box()
        y = self.y - self._half_box()
        return Point(x, y)


    def max_point(self):
        """ Return the max point of the shape """
        x = self.x + self._half_box()
        y = self.y + self._half_box()
        return Point(x, y)


    def move(self, x, y):
        """ Move the thernal to an explicit position. """
        self.x = x
        self.y = y


    def _half_box(self):
        """ Return half the width of the bounding box. """
        hyp = self.outer_diameter / 2.0
        opp = self.gap_thickness / 2.0
        norm_theta = asin(opp / hyp) / pi
        rot = self.rotation % 0.5
        if rot < norm_theta:
            hwid = cos((norm_theta - rot) * pi) * hyp
        elif (0.5 - rot) < norm_theta:
            hwid = cos((norm_theta - (0.5 - rot)) * pi) * hyp
        else:
            hwid = hyp
        return hwid


    def scale(self, factor):
        """ Scale the x & y coordinates in the thermal. """
        self.x *= factor
        self.y *= factor


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the thermal. """
        self.x += dx
        self.y += dy


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the thermal. """
        self.y = height - self.y


    def json(self):
        """ Return the thermal as JSON """
        return {
            "x": int(self.x),
            "y": int(self.y),
            "outer_diameter": self.outer_diameter,
            "inner_diameter": self.inner_diameter,
            "gap_thickness": self.gap_thickness,
            "rotation": self.rotation,
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }


class RegularPolygon(Shape):
    """
    A polygon with sides of equal length.

    Without rotation, the first vertex is at 3 o'clock.
    Rotation is in rad/pi, clockwise positive.

    """
    def __init__(self, x, y, outer, vertices, rotation=0): # pylint: disable=R0913
        super(RegularPolygon, self).__init__()
        self.type = "regular polygon"
        self.x = x
        self.y = y
        self.outer_diameter = outer
        self.vertices = vertices
        self.rotation = rotation


    def __eq__(self, other):
        return (super(RegularPolygon, self).__eq__(other) and
                (self.type == other.type and
                 self.outter_diameter == other.outter_diameter and
                 self.vertices == other.vertices))


    def min_point(self):
        """ Return the min point of the shape """
        x = self.x + self._max_dist(1)
        y = self.y + self._max_dist(0.5)
        return Point(x, y)


    def max_point(self):
        """ Return the max point of the shape """
        x = self.x + self._max_dist(0)
        y = self.y + self._max_dist(1.5)
        return Point(x, y)


    def move(self, x, y):
        """ Move the polygon to an explicit position. """
        self.x = x
        self.y = y


    def _max_dist(self, axis_rads):
        """ Return max reach of the shape along an axis. """
        v_rads = 2.0 / self.vertices
        if self.vertices % 2 == 0:
            hyp = self.outer_diameter / 2.0
        else:
            hyp = self.outer_diameter - acos(v_rads / 2.0)
        start_angle = (axis_rads + self.rotation) % v_rads
        this_v = abs(cos(start_angle * pi) * hyp)
        next_v = abs(cos((start_angle - v_rads) * pi) * hyp)
        return max(this_v, next_v)


    def scale(self, factor):
        """ Scale the x & y coordinates in the polygon. """
        self.x *= factor
        self.y *= factor
        for v in self.vertices:
            v.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the polygon. """
        self.x += dx
        self.y += dy
        for v in self.vertices:
            v.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the polygon. """
        self.y = height - self.y
        for v in self.vertices:
            v.rebase_y_axis(height)


    def json(self):
        """ Return the regular polygon as JSON """
        return {
            "x": int(self.x),
            "y": int(self.y),
            "outer_diameter": self.outer_diameter,
            "vertices": self.vertices,
            "rotation": self.rotation,
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }


class Point:
    """ Simple x, y coordinate. Different from the 'Point' in Nets """

    def __init__(self, x, y=None):
        if y is not None:
            self.x = x
            self.y = y
        # Do a copy of a Point if passed
        elif isinstance(x, Point):
            self.x = x.x
            self.y = x.y
        # Allow for instantiation from a tuple
        else:
            self.x, self.y = x


    def __repr__(self):
        return 'Point(x=%d, y=%d)' % (self.x, self.y)


    def __eq__(self, other):
        """
        Compare with another point. eg: p1 == p2

        Points are considered equal if they are equal when
        rounded to maximum gerber precision (ie, 6 decimal
        places).

        """
        snap = True
        precision = 6
        if snap:
            equal = (isinstance(other, Point) and
                     round(self.x, precision) == round(other.x, precision) and
                     round(self.y, precision) == round(other.y, precision))
        else:
            equal = self.__dict__ == other.__dict__
        return equal


    def dist(self, other):
        """ Calculate the distance to another point. """
        delta_x = self.x - other.x
        delta_y = self.y - other.y
        return sqrt(delta_x**2 + delta_y**2)


    def rotate(self, rotation, about=None):
        if rotation == 0 or rotation == 2:
          return

        if about:
            self.shift(-about.x, -about.y)

        self.x, self.y = self.y, self.x
        if rotation == 0.5 or rotation == -1.5:
            self.y = -self.y;
        elif rotation == -0.5 or rotation == 1.5:
            self.x = -self.x;
        elif rotation == 1 or rotation == -1:
            self.x, self.y = -self.y, -self.x
        else:
            # p'x = cos(theta) * px - sin(theta) * py
            # p'y = sin(theta) * px + cos(theta) * py
            # (reversed to reverse the first reversal.)
            theta = rotation * pi;
            x = sin(theta) * self.x + cos(theta) * self.y;
            y = cos(theta) * self.x - sin(theta) * self.y;
            self.x = x;
            self.y = y;

        if about:
            self.shift(about.x, about.y)


    def flip(self, do_flip, about=None):
        if not about:
            about = Point(0, 0)
        self.x = -(self.x - about.x) + about.x


    def scale(self, factor):
        """ Scale the x & y coordinates in the point. """
        self.x *= factor
        self.y *= factor


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the point. """
        self.x += dx
        self.y += dy


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the point. """
        self.y = height - self.y


    def json(self):
        """ Return the point as JSON """
        return {
            "x": int(self.x),
            "y": int(self.y),
            }


class Obround(Shape):
    """ An oval, defined by x, y at center and width, height"""

    def __init__(self, x, y, width, height):
        super(Obround, self).__init__()
        self.type = "obround"
        self.x = x
        self.y = y
        self.width = width
        self.height = height


    def __eq__(self, other):
        return (super(Obround, self).__eq__(other) and
                (self.type == other.type and
                 self.width == other.width and
                 self.height == other.height))


    def min_point(self):
        """ Return the min point of the shape """
        x = self.x - self.width / 2.0
        y = self.y - self.height / 2.0
        return Point(x, y)


    def max_point(self):
        """ Return the max point of the shape """
        x = self.x + self.width / 2.0
        y = self.y + self.height / 2.0
        return Point(x, y)


    def move(self, x, y):
        """ Move the oval to an explicit position. """
        self.x = x
        self.y = y


    def scale(self, factor):
        """ Scale the x & y coordinates in the oval. """
        self.x *= factor
        self.y *= factor
        self.width *= factor
        self.height *= factor


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the oval. """
        self.y = height - self.y


    def json(self):
        """ Return the oval as JSON """
        return {
            "height": int(self.height),
            "type": self.type,
            "width": int(self.width),
            "x": int(self.x),
            "y": int(self.y),
            #"attributes": stringify_attributes(self.attributes),
            "styles": self.styles,
            }


class RoundedSegment(Shape):
    """ A segment with rounded ends. """

    def __init__(self, p1, p2, width):
        super(RoundedSegment, self).__init__()
        self.type = "rounded_segment"
        self.p1 = p1
        self.p2 = p2
        self.width = width


    def __eq__(self, other):
        return (super(RoundedSegment, self).__eq__(other) and
                (self.type == other.type and
                 self.p1 == other.p1 and
                 self.p2 == other.p2))


    def min_point(self):
        """ Return the min point of the shape """
        raise NotImplemented('RoundedSegment.min_point() not implemented')


    def max_point(self):
        """ Return the max point of the shape """
        raise NotImplemented('RoundedSegment.max_point() not implemented')


    def move(self, x, y):
        """ Move the bezier to an explicit position. """
        dx = self.p1.x - x
        dy = self.p1.y - y

        self.p1.x += dx
        self.p2.x += dx
        self.p1.y += dy
        self.p2.y += dy


    def scale(self, factor):
        """ Scale the x & y coordinates in the rounded segment. """
        self.p1.scale(factor)
        self.p2.scale(factor)
        self.width *= factor


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the rounded segment. """
        self.p1.x += dx
        self.p1.y += dy
        self.p2.x += dx
        self.p2.y += dy


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the segment. """
        self.p1.y = height - self.p1.y
        self.p2.y = height - self.p2.y


    def json(self):
        """ Return the rounded segment as JSON """
        return {
            "type": self.type,
            "width": int(self.width),
            "p1": self.p1.json(),
            "p2": self.p2.json()
            }



########NEW FILE########
__FILENAME__ = annotation_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The annotation test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.annotation import Annotation
import unittest


class AnnotationTests(unittest.TestCase):
    """ The tests of the core module annotation feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_annotation(self):
        """ Test the creation of a new empty annotation. """
        anno = Annotation('abc', 0, 1, 2, False)
        assert anno.value == 'abc'
        assert anno.x == 0
        assert anno.y == 1
        assert anno.rotation == 2
        assert anno.visible != True

    def test_annotation_bounds(self):
        '''Test .bounds()'''
        annot = Annotation('foo', 3, 6, 0, True)
        top_left, bottom_right = annot.bounds()
        # bounds() will give a square with sides 20 units long, centered on the
        # annotation
        self.assertEqual(top_left.x, 3 - 10)
        self.assertEqual(top_left.y, 6 - 10)
        self.assertEqual(bottom_right.x, 3 + 10)
        self.assertEqual(bottom_right.y, 6 + 10)

########NEW FILE########
__FILENAME__ = components_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The component test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.components import Components
from upconvert.core.components import Component
from upconvert.core.components import Symbol
from upconvert.core.components import SBody
from upconvert.core.components import Pin
from upconvert.core.shape import Point, Shape, Label
import unittest


def mkbounds(obj, left, top, right, bot):
    """ Helper function for testing bounds. """
    def newbounds():
        """ Function that gets returned"""
        return [Point(left, top), Point(right, bot)]
    obj.bounds = newbounds


class ComponentsTests(unittest.TestCase):
    """ The tests of the core module library feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_components(self):
        """ Test the creation of a new empty library. """
        lib = Components()
        assert len(lib.components) == 0


class ComponentTests(unittest.TestCase):
    """ The tests of the core module component feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_component(self):
        """ Test the creation of a new empty component. """
        comp = Component('abc')
        assert comp.name == 'abc'


class SymbolTests(unittest.TestCase):
    """ The tests of the core module symbol feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_symbol(self):
        """ Test the creation of a new empty symbol. """
        symb = Symbol()
        assert len(symb.bodies) == 0


class SBodyTests(unittest.TestCase):
    """ The tests of the core module body feature """

    def setUp(self):
        """ Setup the test case. """
        self.bod = SBody()

    def tearDown(self):
        """ Teardown the test case. """
        self.bod = SBody()

    def test_create_new_body(self):
        """ Test the creation of a new empty body. """
        assert len(self.bod.shapes) == 0
        assert len(self.bod.pins) == 0

    def test_empty_bounds(self):
        '''Test that an empty body only bounds the local origin'''
        top_left, bottom_right = self.bod.bounds()
        self.assertEqual(top_left.x, 0)
        self.assertEqual(top_left.y, 0)
        self.assertEqual(bottom_right.x, 0)
        self.assertEqual(bottom_right.y, 0)

    def test_bounds_pins(self):
        '''Test bounds() with just pins included'''
        pins = [Pin(str(i), Point(0, 0), Point(0, 0)) for i in range(4)]
        # checking body.bounds(), not the pins, so override their bounds()
        # methods
        for i, pin in enumerate(pins):
            bounds = [3, 3, 3, 3]
            bounds[i] = 2 * i
            mkbounds(pin, bounds[0], bounds[1], bounds[2], bounds[3])
            self.bod.add_pin(pin)

        top_left, bottom_right = self.bod.bounds()
        self.assertEqual(top_left.x, 0)
        self.assertEqual(top_left.y, 2)
        self.assertEqual(bottom_right.x, 4)
        self.assertEqual(bottom_right.y, 6)

    def test_bounds_shapes(self):
        '''Test SBody.bounds() when the body only consists of shapes'''
        shapes = [Shape() for i in range(4)]
        for i, shape in enumerate(shapes):
            bounds = [3, 3, 3, 3]
            bounds[i] = 2 * i
            mkbounds(shape, bounds[0], bounds[1], bounds[2], bounds[3])
            self.bod.add_shape(shape)

        top_left, bottom_right = self.bod.bounds()
        self.assertEqual(top_left.x, 0)
        self.assertEqual(top_left.y, 2)
        self.assertEqual(bottom_right.x, 4)
        self.assertEqual(bottom_right.y, 6)

    def test_bounds_pins_shapes(self):
        '''Test SBody.bounds() when some extremes are from pins, others shapes'''
        point = Point(0, 0)
        pin1 = Pin('foo', point, point)
        pin2 = Pin('bar', point, point)
        sh1 = Shape()
        sh2 = Shape()
        mkbounds(pin1, 3, 2, 3, 3)
        mkbounds(pin2, 3, 3, 5, 3)
        mkbounds(sh1,  3, 3, 3, 4)
        mkbounds(sh2,  1, 3, 3, 3)
        self.bod.add_pin(pin1)
        self.bod.add_pin(pin2)
        self.bod.add_shape(sh1)
        self.bod.add_shape(sh2)

        top_left, bottom_right = self.bod.bounds()
        self.assertEqual(top_left.x, 1)
        self.assertEqual(top_left.y, 2)
        self.assertEqual(bottom_right.x, 5)
        self.assertEqual(bottom_right.y, 4)


class PinTests(unittest.TestCase):
    """ The tests of the core module pin feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_pin(self):
        """ Test the creation of a new empty pin. """
        p1 = Point(0, 1)
        p2 = Point(2, 3)
        pin = Pin(0, p1, p2, 'abc')
        assert pin.label == 'abc'
        assert pin.p1.x == p1.x
        assert pin.p1.y == p1.y
        assert pin.p2.x == p2.x
        assert pin.p2.y == p2.y
        assert pin.pin_number == 0

    def test_pin_bounds(self):
        '''Test bounds() for individual pins'''
        pin = Pin(0, Point(2, 5), Point(4, 3))
        top_left, bottom_right = pin.bounds()
        self.assertEqual(top_left.x, 2)
        self.assertEqual(top_left.y, 3)
        self.assertEqual(bottom_right.x, 4)
        self.assertEqual(bottom_right.y, 5)

    def test_pin_label_bounds(self):
        '''Test bounds() for a pin with a label'''
        lab = Label(0, 0, 'foo', align='left', rotation=0)
        mkbounds(lab, 1, 3, 2, 6)
        pin = Pin(0, Point(2, 2), Point(4, 3), lab)
        top_left, bottom_right = pin.bounds()
        self.assertEqual(top_left.x, 1)
        self.assertEqual(top_left.y, 2)
        self.assertEqual(bottom_right.x, 4)
        self.assertEqual(bottom_right.y, 6)

########NEW FILE########
__FILENAME__ = component_instance_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The annotation test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.component_instance import ComponentInstance
from upconvert.core.component_instance import SymbolAttribute
import unittest


class ComponentInstanceTests(unittest.TestCase):
    """ The tests of the core module instance feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_instance(self):
        """ Test the creation of a new empty instance. """
        inst = ComponentInstance('001', None, '002', '003')
        assert inst.instance_id == '001'
        assert inst.library_id == '002'
        assert inst.symbol_index == '003'
        assert len(inst.symbol_attributes) == 0
        assert len(inst.attributes) == 0


class SymbolAttributeTests(unittest.TestCase):
    """ The tests of the core module symbol feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_attribute(self):
        """ Test the creation of a new empty symbol. """
        attr = SymbolAttribute(0, 1, 2, False)
        assert attr.x == 0
        assert attr.y == 1
        assert attr.rotation == 2
        assert len(attr.annotations) == 0

########NEW FILE########
__FILENAME__ = design_attributes_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The design attribute test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.design_attributes import DesignAttributes
from upconvert.core.design_attributes import Metadata
import unittest


class DesignAttributesTests(unittest.TestCase):
    """ The tests of the core module attribute feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_attributes(self):
        """ Test the creation of a new empty design. """
        desattrs = DesignAttributes()
        assert len(desattrs.annotations) == 0


class MetadataTests(unittest.TestCase):
    """ The tests of the core module metadata feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_metadata(self):
        """ Test the creation of a new empty metatdata container. """
        meta = Metadata()
        assert meta.name == ''

########NEW FILE########
__FILENAME__ = design_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The design test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.design import Design
from upconvert.core.net import Net
from upconvert.core.shape import Point
from upconvert.core.annotation import Annotation
from upconvert.core.components import Component, Symbol, SBody
from upconvert.core.component_instance import ComponentInstance, SymbolAttribute
import unittest


def mkbounds(obj, left, top, right, bot):
    """ Helper function for testing bounds. """
    def newbounds():
        """ Function that gets returned"""
        return [Point(left, top), Point(right, bot)]
    obj.bounds = newbounds


class DesignTests(unittest.TestCase):
    """ The tests of the core module design feature """

    def setUp(self):
        """ Setup the test case. """
        self.des = Design()

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_design(self):
        """ Test the creation of a new empty design. """
        self.assertEqual(len(self.des.nets), 0)

    def test_empty_bounds(self):
        '''bounds() on an empty design is to include just the origin'''
        for point in self.des.bounds():
            self.assertEqual(point.x, 0)
            self.assertEqual(point.y, 0)

    def test_bounds_nets(self):
        '''Test bounds() with just the design's nets'''
        leftnet = Net('foo1')
        topnet = Net('foo2')
        rightnet = Net('foo3')
        botnet = Net('foo4')
        # limits minx=2, miny=1, maxx=7, maxy=9
        mkbounds(leftnet, 2, 3, 3, 3)
        mkbounds(topnet, 3, 1, 3, 3)
        mkbounds(rightnet, 3, 3, 7, 3)
        mkbounds(botnet, 3, 3, 3, 9)
        self.des.add_net(topnet)
        self.des.add_net(rightnet)
        self.des.add_net(leftnet)
        self.des.add_net(botnet)

        top_left, btm_right = self.des.bounds()
        self.assertEqual(top_left.x, 2)
        self.assertEqual(top_left.y, 1)
        self.assertEqual(btm_right.x, 7)
        self.assertEqual(btm_right.y, 9)

    def test_bounds_annots(self):
        '''Test bounds() with just Annotations added as design attributes'''
        left = Annotation('foo1', 3, 3, 0, True)
        top = Annotation('foo2', 3, 3, 0, True)
        right = Annotation('foo3', 3, 3, 0, True)
        bot = Annotation('foo4', 3, 3, 0, True)
        mkbounds(left, 2, 3, 3, 3)
        mkbounds(top, 3, 2, 3, 3)
        mkbounds(right, 3, 3, 5, 3)
        mkbounds(bot, 3, 3, 3, 6)
        for anno in (left, right, bot, top):
            self.des.design_attributes.add_annotation(anno)

        top_left, btm_right = self.des.bounds()
        self.assertEqual(top_left.x, 2)
        self.assertEqual(top_left.y, 2)
        self.assertEqual(btm_right.x, 5)
        self.assertEqual(btm_right.y, 6)

    def test_bounds_parts(self):
        '''test bounds() with just components in the design'''
        libcomp = Component('bar')
        libcomp.add_symbol(Symbol())
        libcomp.symbols[0].add_body(SBody())
        mkbounds(libcomp.symbols[0].bodies[0], 0, 0, 10, 10)
        self.des.add_component('foo', libcomp)
        for (x, y) in ((1, 3), (3, 2), (5, 3), (3, 7)):
            compinst = ComponentInstance(str((x, y)), libcomp, 'foo', 0)
            compinst.add_symbol_attribute(SymbolAttribute(x, y, 0, False))
            self.des.add_component_instance(compinst)

        top_left, btm_right = self.des.bounds()
        self.assertEqual(top_left.x, 1)
        self.assertEqual(top_left.y, 2)
        self.assertEqual(btm_right.x, 15)
        self.assertEqual(btm_right.y, 17)

    def test_bounds_neg_coords(self):
        '''Test bounds() when the schematic is all negative coordinates'''
        net = Net('foo')
        mkbounds(net, -1, -2, -3, -4)
        self.des.add_net(net)

        top_left, btm_right = self.des.bounds()
        self.assertEqual(top_left.x, -3)
        self.assertEqual(top_left.y, -4)
        self.assertEqual(btm_right.x, -1)
        self.assertEqual(btm_right.y, -2)

    def test_bounds_all_elts(self):
        '''bounds() with all the elements competing'''
        net = Net('foo')
        mkbounds(net, 3, 3, -1, -2)
        self.des.add_net(net)

        annot = Annotation('foo', 3, 3, 0, True)
        mkbounds(annot, 3, 3, 3, 5)
        self.des.design_attributes.add_annotation(annot)

        libcomp = Component('bar')
        libcomp.add_symbol(Symbol())
        libcomp.symbols[0].add_body(SBody())
        mkbounds(libcomp.symbols[0].bodies[0], 0, 0, 3, 3)
        self.des.add_component('foo', libcomp)

        compinst = ComponentInstance('bar', libcomp, 'foo', 0)
        compinst.add_symbol_attribute(SymbolAttribute(3, 0, 0, False))
        self.des.add_component_instance(compinst)

        top_left, btm_right = self.des.bounds()
        self.assertEqual(top_left.x, -1)
        self.assertEqual(top_left.y, -2)
        self.assertEqual(btm_right.x, 6)
        self.assertEqual(btm_right.y, 5)

########NEW FILE########
__FILENAME__ = layout_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The layout test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.shape import Circle
from upconvert.core.layout import Aperture
import unittest


class ApertureTests(unittest.TestCase):
    """ Tests of core.layout.Aperture """

    def test_eq(self):
        circle1 = Circle(0, 0, 5)
        circle2 = Circle(0, 0, 1)

        self.assertEqual(Aperture('a', circle1, circle1),
                         Aperture('b', circle1, circle1))

        self.assertEqual(Aperture('a', circle1, circle2),
                         Aperture('b', circle1, circle2))

        self.assertEqual(Aperture('a', circle1, None),
                         Aperture('b', circle1, None))

        self.assertNotEqual(Aperture('a', circle1, None),
                            Aperture('b', circle2, None))

        self.assertNotEqual(Aperture('a', circle1, circle1),
                            Aperture('b', circle1, circle2))

        self.assertNotEqual(Aperture('a', circle1, None),
                            Aperture('b', circle1, circle2))

        self.assertNotEqual(Aperture('a', circle1, circle1),
                            Aperture('b', circle1, None))

########NEW FILE########
__FILENAME__ = net_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The net test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.net import Net
from upconvert.core.net import NetPoint
from upconvert.core.net import ConnectedComponent
import unittest


class NetTests(unittest.TestCase):
    """ The tests of the core module net feature """

    def setUp(self):
        """ Setup the test case. """
        self.net = Net('001')

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_net(self):
        """ Test the creation of a new empty net. """
        assert self.net.net_id == '001'

    def test_bounds_simple(self):
        '''Make sure bounds() uses all the included NetPoints'''
        for (x, y) in ((1, 3), (3, 2), (4, 3), (3, 5)):
            net_pt = NetPoint(str((x, y)), x, y)
            self.net.add_point(net_pt)
            # NetPoints don't actually need to be connected to affect bounds()

        top_left, btm_right = self.net.bounds()
        self.assertEqual(top_left.x, 1)
        self.assertEqual(top_left.y, 2)
        self.assertEqual(btm_right.x, 4)
        self.assertEqual(btm_right.y, 5)


class NetPointTests(unittest.TestCase):
    """ The tests of the core module net point feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_net_point(self):
        """ Test the creation of a new empty net point. """
        point = NetPoint('001', 0, 1)
        assert point.point_id == '001'


class ConnectedComponentTests(unittest.TestCase):
    """ The tests of the core module connected component feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_component(self):
        """ Test the creation of a new empty connected component. """
        comp = ConnectedComponent('001', '002')
        assert comp.instance_id == '001'

########NEW FILE########
__FILENAME__ = shape_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The shape test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.shape import Shape
from upconvert.core.shape import Rectangle
from upconvert.core.shape import RoundedRectangle
from upconvert.core.shape import Arc
from upconvert.core.shape import Circle
from upconvert.core.shape import Label
from upconvert.core.shape import Line
from upconvert.core.shape import Polygon
from upconvert.core.shape import RegularPolygon
from upconvert.core.shape import Moire
from upconvert.core.shape import Thermal
from upconvert.core.shape import BezierCurve
from upconvert.core.shape import Point
import unittest
from math import sin, cos, pi


class ShapeTests(unittest.TestCase):
    """ The tests of the core module shape feature """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_shape(self):
        """ Test the creation of a new empty shape. """
        shp = Shape()
        assert shp.type == None


class RectangleTests(unittest.TestCase):
    """ The tests of the core module rectangle shape """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_rectangle(self):
        """ Test the creation of a new empty rectangle. """
        rect = Rectangle(0, 1, 2, 3)
        assert rect.x == 0
        assert rect.y == 1
        assert rect.width == 2
        assert rect.height == 3

    def test_create_rect_from_corners(self):
        '''Test for Rectangle.from_corners()'''
        rect = Rectangle.from_corners(0, 1, 2, 4)
        self.assertEqual(rect.x, 0)
        self.assertEqual(rect.y, 1)
        self.assertEqual(rect.width, 2)
        self.assertEqual(rect.height, 3)

    def test_rectangle_min_point(self):
        '''Test Rectangle.min_point()'''
        rect = Rectangle(-2, -3, 8, 5)
        top_left = rect.min_point()
        self.assertEqual(top_left.x, -2)
        self.assertEqual(top_left.y, -3)

    def test_rectangle_max_point(self):
        '''Test Rectangle.max_point()'''
        rect = Rectangle(-2, -3, 8, 5)
        bottom_right = rect.max_point()
        self.assertEqual(bottom_right.x, 6)
        self.assertEqual(bottom_right.y, 2)

class RoundedRectangleTests(unittest.TestCase):
    """ The tests of the core module rounded rectangle shape """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_rounded(self):
        """ Test the creation of a new empty rounded rectangle. """
        rrect = RoundedRectangle(0, 1, 2, 3, 4)
        assert rrect.x == 0
        assert rrect.y == 1
        assert rrect.width == 2
        assert rrect.height == 3
        assert rrect.radius == 4

    def test_create_rnd_frm_corners(self):
        '''Test for RoundedRectangle.from_corners()'''
        rrect = RoundedRectangle.from_corners(0, 1, 2, 4, 5)
        self.assertEqual(rrect.x, 0)
        self.assertEqual(rrect.y, 1)
        self.assertEqual(rrect.width, 2)
        self.assertEqual(rrect.height, 3)
        self.assertEqual(rrect.radius, 5)

    def test_rrectangle_min_point(self):
        '''Test RoundedRectangle.min_point()'''
        rrect = RoundedRectangle(-2, -3, 8, 5, 6)
        top_left = rrect.min_point()
        self.assertEqual(top_left.x, -2)
        self.assertEqual(top_left.y, -3)

    def test_rrectangle_max_point(self):
        '''Test RoundedRectangle.max_point()'''
        rrect = RoundedRectangle(-2, -3, 8, 5, 6)
        bottom_right = rrect.max_point()
        self.assertEqual(bottom_right.x, 6)
        self.assertEqual(bottom_right.y, 2)

class ArcTests(unittest.TestCase):
    """ The tests of the core module arc shape """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_arc(self):
        """ Test the creation of a new empty arc. """
        arc = Arc(0, 1, 2, 3, 4)
        assert arc.x == 0
        assert arc.y == 1
        assert arc.start_angle == 2
        assert arc.end_angle == 3
        assert arc.radius == 4

    def test_min_point_arc_is_circle(self):
        '''min_point() when an arc actually traces out a full circle'''
        arc = Arc(2, 3, 0, 2, 5)
        self.assertEqual(arc.min_point().x, -3)
        self.assertEqual(arc.min_point().y, -2)

    def test_max_point_arc_is_circle(self):
        '''max_point() when an arc actually traces out a full circle'''
        arc = Arc(2, 3, 0, 2, 5)
        self.assertEqual(arc.max_point().x, 7)
        self.assertEqual(arc.max_point().y, 8)

    def test_min_point_arc(self):
        """min_point() of an arc tracing top-left quarter"""
        arc = Arc(2, 3, 1, 1.5, 5)
        self.assertEqual(arc.min_point().x, -3)
        self.assertEqual(arc.min_point().y, -2)

    def test_max_point_arc(self):
        """max_point() of an arc tracing bottom-right quarter"""
        arc = Arc(2, 3, 0, 0.5, 5)
        self.assertEqual(arc.max_point().x, 7)
        self.assertEqual(arc.max_point().y, 8)
        
    def test_min_point_arc_wraparound(self):
        """min_point() of an arc that traces through 0 degrees"""
        arc = Arc(2, 3, 1.75, 0.25, 5)
        self.assertEqual(arc.min_point().x, int(round(cos(1.75 * pi) * 5 + 2)))
        self.assertEqual(arc.min_point().y, int(round(sin(1.75 * pi) * 5 + 3)))

    def test_max_point_arc_wraparound(self):
        """max_point() of an arc that traces through 0 degrees"""
        arc = Arc(2, 3, 1.75, 0.25, 5)
        self.assertEqual(arc.max_point().x, 5 + 2)
        self.assertEqual(arc.max_point().y, int(round(sin(0.25 * pi) * 5 + 3)))

class CircleTests(unittest.TestCase):
    """ The tests of the core module circle shape """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_circle(self):
        """ Test the creation of a new empty circle. """
        cir = Circle(0, 1, 2)
        assert cir.x == 0
        assert cir.y == 1
        assert cir.radius == 2

    def test_circle_min_point(self):
        '''Test Circle.min_point()'''
        cir = Circle(2, 3, 4)
        top_left = cir.min_point()
        self.assertEqual(top_left.x, -2)
        self.assertEqual(top_left.y, -1)

    def test_circle_max_point(self):
        '''Test Circle.max_point()'''
        cir = Circle(2, 3, 4)
        bottom_right = cir.max_point()
        self.assertEqual(bottom_right.x, 6)
        self.assertEqual(bottom_right.y, 7)


class LabelTests(unittest.TestCase):
    """ The tests of the core module label shape """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_label(self):
        """ Test the creation of a new empty label. """
        lbl = Label(0, 1, 'abc', align='left', rotation=2)
        assert lbl.x == 0
        assert lbl.y == 1
        assert lbl.text == 'abc'
        assert lbl.align == 'left'
        assert lbl._rotation == 2

    def test_label_min_point(self):
        '''Test Label.min_point()'''
        #lbl = Label(2, 1, 'foo', 'left', 0)
        # this will fail, until Labels get min/max_point() methods
        #top_left = lbl.min_point()
        # TODO change this to work with however Label.min_point() does
        #self.assertTrue(False)

    def test_label_max_point(self):
        '''Test Label.max_point()'''
        #lbl = Label(2, 1, 'foo', 'left', 0)
        # this will fail, until Labels get min/max_point() methods
        #top_left = lbl.max_point()
        # TODO change this to work with however Label.max_point() does
        #self.assertTrue(False)

class LineTests(unittest.TestCase):
    """ The tests of the core module line shape """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_line(self):
        """ Test the creation of a new empty line. """
        p1 = Point(0, 1)
        p2 = Point(2, 3)
        line = Line(p1, p2)
        assert line.p1.x == p1.x
        assert line.p1.y == p1.y
        assert line.p2.x == p2.x
        assert line.p2.y == p2.y

    def test_line_min_point(self):
        '''Test Line.min_point() in different situations'''
        line = Line(Point(2, 3), Point(4, 5))
        top_left = line.min_point()
        self.assertEqual(top_left.x, 2)
        self.assertEqual(top_left.y, 3)

        line = Line(Point(2, 3), Point(-1, 4))
        top_left = line.min_point()
        self.assertEqual(top_left.x, -1)
        self.assertEqual(top_left.y, 3)

    def test_line_max_point(self):
        '''Test Line.max_point() in different situations'''
        line = Line(Point(2, 3), Point(4, 5))
        bottom_right = line.max_point()
        self.assertEqual(bottom_right.x, 4)
        self.assertEqual(bottom_right.y, 5)

        line = Line(Point(2, 3), Point(-1, 4))
        bottom_right = line.max_point()
        self.assertEqual(bottom_right.x, 2)
        self.assertEqual(bottom_right.y, 4)

class PolygonTests(unittest.TestCase):
    """ The tests of the core module polygon shape """

    def setUp(self):
        """ Setup the test case. """
        self.poly = Polygon()

    def tearDown(self):
        """ Teardown the test case. """
        del self.poly

    def test_create_new_polygon(self):
        """ Test the creation of a new empty polygon. """
        assert len(self.poly.points) == 0

    def test_empty_min_point(self):
        '''Test Polygon.min_point() for a Polygon with no points at all'''
        self.assertEqual(self.poly.min_point().x, 0)
        self.assertEqual(self.poly.min_point().y, 0)

    def test_empty_max_point(self):
        '''Test Polygon.max_point() for a Polygon with no points at all'''
        self.assertEqual(self.poly.max_point().x, 0)
        self.assertEqual(self.poly.max_point().y, 0)

    def test_min_point(self):
        '''Test Polygon.min_point() for complex case'''
        for _xy in [(1, 3), (3, 7), (4, 3), (3, -2)]:
            self.poly.add_point(_xy)
        self.assertEqual(self.poly.min_point().x, 1)
        self.assertEqual(self.poly.min_point().y, -2)

    def test_max_point(self):
        '''Test Polygon.max_point() for complex case'''
        for _xy in [(1, 3), (3, 7), (4, 3), (3, -2)]:
            self.poly.add_point(_xy)
        self.assertEqual(self.poly.max_point().x, 4)
        self.assertEqual(self.poly.max_point().y, 7)


class RegularPolygonTests(unittest.TestCase):
    """ The tests of the core module regular polygon shape. """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_regular_polygon(self):
        """ Test creating a new regular polygon. """
        rpoly = RegularPolygon(x=0,
                               y=0,
                               outer=5,
                               vertices=5)
        assert rpoly.x == 0
        assert rpoly.y == 0
        assert rpoly.outer_diameter == 5
        assert rpoly.vertices == 5
        assert rpoly.rotation == 0


class MoireTests(unittest.TestCase):
    """ The tests of the core module moire shape. """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_moire(self):
        """ Test the creation of a new Moire. """
        moire = Moire(x=0,
                      y=0,
                      outer=6,
                      ring_thickness=1.5,
                      gap=1,
                      max_rings=2,
                      hair_thickness=0.2,
                      hair_length=6,
                      rotation=0)
        assert moire.x == 0
        assert moire.y == 0
        assert moire.outer_diameter == 6
        assert moire.ring_thickness == 1.5
        assert moire.gap_thickness == 1
        assert moire.max_rings == 2
        assert moire.hair_thickness == 0.2
        assert moire.hair_length == 6
        assert moire.rotation == 0


class ThermalTests(unittest.TestCase):
    """ The tests of the core module thermal shape. """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_thermal(self):
        """ Test the creation of a new thermal. """
        thermal = Thermal(x=0,
                          y=0,
                          outer=5,
                          inner=3,
                          gap=2)
        assert thermal.x == 0
        assert thermal.y == 0
        assert thermal.outer_diameter == 5
        assert thermal.inner_diameter == 3
        assert thermal.gap_thickness == 2
        assert thermal.rotation == 0


class BezierCurveTests(unittest.TestCase):
    """ The tests of the core module bezier shape """

    def setUp(self):
        """ Setup the test case. """
        self.curve = BezierCurve((2, 9), (9, 8), (1, 1), (7, 2))

    def tearDown(self):
        """ Teardown the test case. """
        del self.curve

    def test_create_new_bezier_curve(self):
        """ Test the creation of a new empty bezier. """
        control1 = Point(2, 9)
        control2 = Point(9, 8)
        p1 = Point(1, 1)
        p2 = Point(7, 2)
        assert self.curve.control1.x == control1.x
        assert self.curve.control1.y == control1.y
        assert self.curve.control2.x == control2.x
        assert self.curve.control2.y == control2.y
        assert self.curve.p1.x == p1.x
        assert self.curve.p1.y == p1.y
        assert self.curve.p2.x == p2.x
        assert self.curve.p2.y == p2.y


    def interp_bezier(self, points, typ):
        return tuple([int(round(((1 - typ) ** 3) * pts[0]
                                + 3 * ((1 - typ) ** 2) * typ * pts[1]
                                + 3 * (1 - typ) * (typ ** 2) * pts[2]
                                + (typ ** 3) * pts[3]))
                      for pts in ([pt.x for pt in points],
                                  [pt.y for pt in points])])
    

    def bez_recurse(self, pts, lo, hi):
        """Helper method to draw a bezier curve"""
        # kind of important that we don't just copy how it's done in the method
        # to be tested, so do it by recusively bisecting the curve until we hit
        # the necessary resolution
        [plo, phi] = [self.interp_bezier(pts, typ) for typ in (lo, hi)]
        if abs(plo[0] - phi[0]) <= 1 and abs(plo[1] - phi[1]) <= 1:
            return [plo, phi]
        mid = (lo + hi) / 2.
        bot_half = self.bez_recurse(pts, lo, mid)
        top_half = self.bez_recurse(pts, mid, hi)
        if bot_half[-1] == top_half[0]:
            bot_half = bot_half[:-1]
        return bot_half + top_half


    def test_bezier_min_point(self):
        points = self.bez_recurse([self.curve.p1, self.curve.control1,
                                   self.curve.control2, self.curve.p2], 0., 1.)
        x = min([pt[0] for pt in points])
        y = min([pt[1] for pt in points])
        min_pt = self.curve.min_point()
        self.assertEqual(min_pt.x, x)
        self.assertEqual(min_pt.y, y)


    def test_bezier_max_point(self):
        points = self.bez_recurse([self.curve.p1, self.curve.control1,
                                   self.curve.control2, self.curve.p2], 0., 1.)
        x = max([pt[0] for pt in points])
        y = max([pt[1] for pt in points])
        max_pt = self.curve.max_point()
        self.assertEqual(max_pt.x, x)
        self.assertEqual(max_pt.y, y)


class PointTests(unittest.TestCase):
    """ The tests of the core module point feature. """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_point(self):
        """ Test the creation of a new empty point. """
        pnt = Point(0, 1)
        assert pnt.x == 0
        assert pnt.y == 1

    def test_create_point_from_tuple(self):
        '''Test Point constructor using a tuple as only argument'''
        pnt = Point((2, 3))
        self.assertEqual(pnt.x, 2)
        self.assertEqual(pnt.y, 3)

    def test_create_point_from_point(self):
        '''Test Point constructor when cloning another point'''
        oldpnt = Point(2, 3)
        newpnt = Point(oldpnt)
        self.assertFalse(oldpnt is newpnt)
        self.assertEqual(oldpnt.x, newpnt.x)
        self.assertEqual(oldpnt.y, newpnt.y)
        oldpnt.x = 4
        oldpnt.y = 5
        self.assertEqual(newpnt.x, 2)
        self.assertEqual(newpnt.y, 3)

    def test_point_equality(self):
        '''pt1 == pt2 iff (pt1.x == pt2.x and pt1.y == pt2.y)'''
        pta = Point(2, 3)
        ptb = Point(2, 3)
        ptc = Point(2, 4)
        ptd = Point(4, 3)
        pte = Point(4, 5)
        self.assertEqual(pta, ptb)
        for pt in (ptc, ptd, pte):
            self.assertNotEqual(pta, pt)

    def test_point_repr(self):
        '''repr(Point) --> Point($x, $y)'''
        pt = Point(8, 7)
        self.assertEqual(repr(pt), 'Point(x=8, y=7)')
        pt = Point(-3, -4)
        self.assertEqual(repr(pt), 'Point(x=-3, y=-4)')

########NEW FILE########
__FILENAME__ = trace
#!/usr/bin/env python2
""" The trace class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.shape import Point
from upconvert.utils.stringify import stringify_attributes


class Trace:
    """ a Trace with metadata and a pair of points """

    def __init__(self, trace_id):
        self.trace_id = trace_id
        self.p1 = None
        self.p2 = None
        self.attributes = dict()
        self.annotations = list()


    def bounds(self):
        """ Return the min and max points of the bounding box """
        pass


    def add_annotation(self, annotation):
        """ Add an annotation """
        self.annotations.append(annotation)


    def add_attribute(self, key, value):
        """ Add an attribute """
        self.attributes[key] = value


    def scale(self, factor):
        """ Scale the x & y coordinates in the trace. """
        self.p1.scale(factor)
        self.p2.scale(factor)
        for anno in self.annotations:
            anno.scale(factor)


    def shift(self, dx, dy):
        """ Shift the x & y coordinates in the trace. """
        self.p1.shift(factor)
        self.p2.shift(factor)
        for anno in self.annotations:
            anno.shift(dx, dy)


    def rebase_y_axis(self, height):
        """ Rebase the y coordinate in the trace. """
        self.p1.rebase_y_axis(factor)
        self.p2.rebase_y_axis(factor)
        for anno in self.annotations:
            anno.rebase_y_axis(height)


    def json(self):
        """ Return a trace as JSON """
        return {
            "trace_id": self.trace_id,
            "p1": self.p1.json(),
            "p2": self.p2.json(),
            "attributes": stringify_attributes(self.attributes),
            "annotations": [ann.json() for ann in self.annotations]
            }

########NEW FILE########
__FILENAME__ = fritzing_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The fritzing library test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.library.fritzing import lookup_part

from unittest import TestCase
from os.path import basename, exists


class FritzingTests(TestCase):
    """ The tests of the fritzing library """

    def test_lookup_present(self):
        """ Test looking up a part that is present """

        path = '/some/path/to/fritzing/parts/core/SMD_Diode_REC_DO.fzp'
        version = '0.6.4b.12.16.5683'

        found = lookup_part(path, version)

        self.assertEqual(basename(found), basename(path))
        self.assertTrue(exists(found))

    def test_lookup_missing(self):
        """ Test looking up a part that is missing """

        path = '/some/path/to/fritzing/parts/core/notthere.fzp'
        version = '0.6.4b.12.16.5683'

        found = lookup_part(path, version)

        self.assertEqual(found, None)

########NEW FILE########
__FILENAME__ = kicad_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The kicad library test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.library.kicad import lookup_part
from upconvert.core.components import Component

from unittest import TestCase


class KicadTests(TestCase):
    """ The tests of the kicad library """

    def test_lookup_present(self):
        """ Test looking up a part that is present """

        name = 'DS18B20Z'
        libs = ['jensen', '1wire']

        found = lookup_part(name, libs)

        self.assertTrue(isinstance(found, Component))
        self.assertEqual(found.name, name)

    def test_lookup_missing(self):
        """ Test looking up a part that is missing """

        name = 'nosuchpart'
        libs = ['nosuchlib', 'jensen', '1wire']

        found = lookup_part(name, libs)

        self.assertEqual(found, None)

########NEW FILE########
__FILENAME__ = altium
#!/usr/bin/env python2
""" The Altium Format Parser """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Note: starting at 0x200 bytes, then 0x10200, 0x20200, etc., there is a 0x200-byte block starting
# with FD FF FF FF and then a series of sequential 4-byte values.  I don't know the purpose of
# these interrupting blocks, but when I read the file, I simply pass over them.  Disregarding them,
# here is the Altium schematic file structure:
# 
# FILE HEADERS (some contain unicode titles followed by unknown binary data)
# - 0x200 bytes whose meaning is yet unknown
# - 0x80 bytes for "Root Entry"
# - 0x80 bytes for "File Header"
# - 0x80 bytes for "Storage"
# - 0x80 bytes for "Additional"
# - 0x200 more unknown bytes 
#
# PARTS (sequential, variable number of parts, each having the following format)
#   - 4-byte little-endian integer describing the length of data to follow (including ending null)
#   - (length from above) bytes of data of the format |PROPERTY=VALUE
#      - except the "TEXT" property which seems to have "==" as its separator
#   - one null byte (0x00)
#
# FILE FOOTERS
# - Variable length of zero-padding following the last part
# - 0x600 bytes related to icon storage
# - 0x200 bytes for the last file footer

# The struct library makes it easy to read stored 4-byte integers.
import struct

from upconvert.core.design import Design


# This is the primary class.  Its members will be the various elements of an Altium schematic file.
class Altium:
    """ The Altium Format Parser """

    def __init__(self):
        self.last_header = None
        self.file_header = None
        self.first_header = None
        self.root_entry = None
        self.storage = None
        self.parts = None
        self.additional = None


    @staticmethod
    def auto_detect(filename):
        """ Return our confidence that the given file is an altium schematic """
        with open(filename, 'r') as f:
            data = f.read()
        confidence = 0
        if 'altium' in data:
            confidence += 0.5
        return confidence


    # A simple string method to show off what has been parsed and stored.  It moves the easily-
    # identifiable blocks NAME and TEXT to the top of the printout for each part.
    def __str__(self):
        result = ""
        for part in self.parts:
            if "NAME" in part:
                result += "NAME: " + part["NAME"] + "\n"
            elif "TEXT" in part:
                result += "TEXT: " + part["TEXT"] + "\n"
            for key in part:
                if (key != "NAME") and (key != "TEXT"):
                    result += key + ": " + part[key] + "\n"
            result += "\n"
        return result


    def parse(self, file_path):
        """ Parse an Altium file into a design """
        design = Design()

        # Open the file in read-binary mode and only proceed if it was properly opened.
        in_file = open(file_path, "rb")
        if in_file:
            # Read the entire contents, omitting the interrupting blocks.
            input = in_file.read(0x200)
            # Skip the first 0x200 interrupting block.
            temp = in_file.read(0x200)
            while temp:
                # Read the next 0x10000 minus 0x200.
                temp = in_file.read(0xFE00)
                input += temp
                # Skip the next 0x200 interrupting block.
                temp = in_file.read(0x200)
            in_file.close()
            # Store all the headers, though they are not used.
            cursor_start = 0
            self.first_header = input[cursor_start:cursor_start+0x200]
            cursor_start += 0x200
            self.root_entry = input[cursor_start:cursor_start+0x80]
            cursor_start += 0x80
            self.file_header = input[cursor_start:cursor_start+0x80]
            cursor_start += 0x80
            self.storage = input[cursor_start:cursor_start+0x80]
            cursor_start += 0x80
            self.additional = input[cursor_start:cursor_start+0x80]
            cursor_start += 0x80
            self.last_header = input[cursor_start:cursor_start+0x200]
            cursor_start += 0x200
            # Now prepare to read each of the parts.  Initialize an "end" cursor.
            cursor_end = 0
            # Get the size of the next part block.
            next_size = struct.unpack("<I", input[cursor_start:cursor_start+4])[0]
            # Advance the "start" cursor.
            cursor_start += 4
            # Create a list to store all the parts.
            self.parts = []
            # Loop through until the "next size" is 0, which is the end of the parts list.
            while next_size != 0:
                cursor_end = input.find("\x00", cursor_start)
                # Create a dictionary to store all the property:value pairs.
                result = {}
                # Get a list of pairs by splitting on the separator character "|".
                property_list = input[cursor_start:cursor_end].split("|")
                # For each one, copy out whatever is before any "=" as property, and whatever is
                # after any "=" as value.
                for prop in property_list:
                    if prop:
                        property_val = prop.split("=")[0]
                        # The negative list index is to handle the cases with "==" instead of "=".
                        value = prop.split("=")[-1]
                        # Add the property to the result dictionary.
                        result[property_val] = value
                # Add the dictionary to the list of parts.
                self.parts.append(result)
                # Set things up for the next iteration of the loop.
                cursor_start = cursor_end + 1
                next_size = struct.unpack("<I", input[cursor_start:cursor_start+4])[0]
                cursor_start += 4
            # Here the footers could be found and stored, but I don't think they're important.

        return design

########NEW FILE########
__FILENAME__ = eagle
#!/usr/bin/env python2
""" The Eagle Format Parser """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Note: It parses a file of an Eagle format of version up to 5.11.
# Default values are used for fields missed in files of previous versions.
#

import struct
import math

from upconvert.core.annotation import Annotation
from upconvert.core.component_instance import ComponentInstance, SymbolAttribute
from upconvert.core.design import Design
from upconvert.core.net import Net, NetPoint, ConnectedComponent
from upconvert.core.components import Component, Symbol, SBody, Pin
from upconvert.core.shape import Point, Line, Label, Arc, Circle, Rectangle, Polygon

#class EagleBinConsts:
#    """ Just a set of constants to be used by both parser and writer
#    """
#    pass# pylint: disable=R0902


EAGLE_SCALE = 1/0.127


class Eagle:
    """ The Eagle Format Parser """

    @staticmethod
    def _do_ojs(value):
        """ Represents a string as required by upconvert core """
        return value.decode('latin-1').encode('utf-8') if None != value else None
# or maybe we need to have a unicode object in openjson?..
#  (in that case all strings in maps have to be created as unicode ones as well)
#        return unicode(value, 'latin-1') if None != value else None

    class Header:
        """ A struct that represents a header """
        constant = 0x10
        template = "=4BI4B3I"

        def __init__(self, version="5.11", numofblocks=0):
            """ Just a constructor
            """
            self.version = version # has to be of x.y (dot-separated) format
            self.numofblocks = numofblocks
            return

        @staticmethod
        def parse(chunk):
            """ Parses header block
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Header.template, chunk)

            _ret_val = Eagle.Header(
                                version=Eagle._do_ojs('%d.%d' % (_dta[5], _dta[6])),
                                numofblocks=_dta[4], # including this one
                                      )
# [13] -- some number / counter ; changed on each 'save as' (even with no changes)
            return _ret_val

    class Settings:
        """ A struct that represents ?? settings ??
        """
        constant = 0x11
        template = "=4BI4BII4B"

        # TODO if i need to synchronize access?..
        counter = 0

        def __init__(self, copyno=0, seqno=None):
            """ Just a constructor
            """
            if None == seqno:
                seqno = Eagle.Settings.counter
                Eagle.Settings.counter += 1
            else:
                Eagle.Settings.counter = 1 + seqno
            self.seqno = seqno # looks like first and second blocks
                               #  starts with the same byte set
                               #  but then the second set starts to evolve
            self.copyno = copyno # holds No of a 'Save As..' copy
            return

        @staticmethod
        def parse(chunk):
            """ Parses ?? settings ?? block
                TODO synchronization could be needed
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Settings.template, chunk)

# [11] -- sequence number of a copy (incremented on each 'save as', even with no changes)
#          (for first "settings" block only; second one contains 0 there)
            _ret_val = Eagle.Settings(seqno=Eagle.Settings.counter,
                                         copyno=_dta[8]
                                        )
            Eagle.Settings.counter += 1
            return _ret_val

    class Grid:
        """ A struct that represents a grid
        """
        constant = 0x12
        template = "=4B5I"

        unitmask = 0x0f
        units = {
                 0x0f: "inch",
                 0x00: "mic",
                 0x05: "mm",
                 0x0a: "mil",
                }
        lookmask = 2
        look = {
                0: "lines",
                2: "dots",
               }
        showmask = 1
        show = {
                0: False,
                1: True,
               }

        def __init__(self, distance=0.1, unitdist="inch", unit="inch",  # pylint: disable=R0913
                style="lines", multiple=1, display=False, altdistance=0.01,
                altunitdist="inch", altunit="inch"):
            """ Just a constructor
            """
            self.distance = distance
            self.unitdist = unitdist
            self.unit = unit
            self.style = style
            self.multiple = multiple
            self.display = display
            self.altdistance = altdistance
            self.altunitdist = altunitdist
            self.altunit = altunit
            return

        @staticmethod
        def parse(chunk):
            """ Parses grid block
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Grid.template, chunk)

            try:
                _unit = Eagle.Grid.units[Eagle.Grid.unitmask & _dta[3]]
            except KeyError: # unknown grid measure units
                _unit = "n/a"

            try:
                _altunit = Eagle.Grid.units[Eagle.Grid.unitmask &
                                               (_dta[3] >> 4)]
            except KeyError: # unknown grid alt measure units
                _altunit = "n/a"

# strage float format here: 8 bytes ; no idea yet
# thus proceeding in 6.0.0 way: default values are used
# (but units are preserved; 6.0.0 uses default set -- with inches)
            _ret_val = Eagle.Grid(
                                     distance=0.1, # <--- here [7:15]
                                     unitdist=_unit,
                                     unit=_unit,
                                     style=Eagle.Grid.look[
                                            Eagle.Grid.lookmask & _dta[2]],
                                     multiple=_dta[4],
                                     display=Eagle.Grid.show[
                                            Eagle.Grid.showmask & _dta[2]],
                                     altdistance=0.01, # <--- here [15:23]
                                     altunitdist=_altunit,
                                     altunit=_altunit
                                    )
            return _ret_val

    class Layer:
        """ A struct that represents a layer
        """
        constant = 0x13
        template = "=7B2I9s"

        linkedsignmask = 0x10

        visactmask = 0x0e
        visact = 0x0e
        nvisact = 0x02

        max_embed_len = 9
        no_embed_str = b'\x7f'

#        colors = ['unknown','darkblue','darkgreen','darkcyan',
#                'darkred','unknown','khaki','grey',
## light variants x8
#                 ]
#        fill = ['none','filled',
## total 16; different line and dot patterns
#               ]

        def __init__(self, number, name, color, fill, visible, active, # pylint: disable=R0913
                     linkednumber=None, linkedsign=0):
            """ Just a constructor
            """
            self.number = number
            self.name = name
            self.color = color
            self.fill = fill
            self.visible = visible
            self.active = active
            self.linkedsign = linkedsign
            if None == linkednumber:
                linkednumber = number
            self.linkednumber = linkednumber
            return

        @staticmethod
        def parse(chunk):
            """ Parses single layer block
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Layer.template, chunk)

            _linked = False # a kind of a "twin" layer
# these visible / active signs looks like legacy ones
#  and older format files have other values for this octet
            _visible = False
            _active = False
            if Eagle.Layer.nvisact == Eagle.Layer.visactmask & _dta[2]:
                _visible = False
                _active = True
            elif Eagle.Layer.visact == Eagle.Layer.visactmask & _dta[2]:
                _visible = True
                _active = True
            else:
                pass # unknown layer visibility sign

            if (Eagle.Layer.linkedsignmask ==
                    Eagle.Layer.linkedsignmask & _dta[2]):
                _linked = True

            _name = None
            if Eagle.Layer.no_embed_str != _dta[9][0]:
                _name = Eagle._do_ojs(_dta[9].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.Layer(number=_dta[3],
                                   name=_name,
                                   color=_dta[6],
                                   fill=_dta[5],
                                   visible=_visible,
                                   active=_active,
                                   linkednumber=_dta[4],
                                   linkedsign=_linked
                                  )
            return _ret_val

    class ShapeSet(object):
        """ A struct that represents a bunch of shapes
        """

        def __init__(self, numofshapes=0, shapes=None):
            """ Just a constructor
            """
            self.numofshapes = numofshapes
            if None == shapes:
                shapes = []
            self.shapes = shapes
            return

    class NamedShapeSet(ShapeSet):
        """ A struct that represents a *named* bunch of shapes
        """

        def __init__(self, name, numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.NamedShapeSet, self).__init__(numofshapes, shapes)
            self.name = name
            return

    class Web(object):
        """ A base struct for a bunch of shapesets
            It's needed to uniform parsing and counting of members
        """

        def __init__(self, name, numofblocks=0, numofshapesets=0,
                     shapesets=None):
            """ Just a constructor
            """
            self.name = name
            self.numofblocks = numofblocks
            self.numofshapesets = numofshapesets
            if None == shapesets:
                shapesets = []
            self.shapesets = shapesets
            return

    class AttributeHeader:
        """ A struct that represents a header of attributes
        """
        constant = 0x14
        template = "=4B3I3B5s"

        max_embed_len = 5
        no_embed_str = b'\x7f'

        defxreflabel = ":%F%N/%S.%C%R"
        defxrefpart = "/%S.%C%R"
        delimeter = b'\t'

        def __init__(self, schematic, numofshapes=0, numofattributes=0):
            """ Just a constructor
            """
            self.schematic = schematic
            self.numofshapes = numofshapes # to be validated!
            self.numofattributes = numofattributes # to be validated!
            return

        @staticmethod
        def parse(chunk):
            """ Parses attribute header block
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.AttributeHeader.template, chunk)

            _schematic = None
            if Eagle.AttributeHeader.no_embed_str != _dta[10][0]:
                _schematic = Eagle._do_ojs(_dta[10].rstrip(r'\0'))
            else: # from external string block
                _schematic = Eagle.attr_jar_list.next().name

# number of shapes + header of shapes
# number of attributes, excluding this line
# name can be of length 0 for versions prior to 5.x
#  name==None means a long name stored separately
            _ret_val = Eagle.AttributeHeader(schematic=_schematic,
                                             numofshapes=(-1 + _dta[5]),
                                             numofattributes=_dta[6]
                                            )
            return _ret_val

    class Library:
        """ A struct that represents a library
        """
        constant = 0x15
        template = "=4B3I8s"

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, name, numofdevsetblocks=0, devsets=None, # pylint: disable=R0913
                     numofsymbolblocks=0, symbols=None,
                     numofpackageblocks=0, packages=None,):
            """ Just a constructor
            """
            self.name = name

            self.numofdevsetblocks = numofdevsetblocks
            if None == devsets:
                devsets = []
            self.devsets = devsets

            self.numofsymbolblocks = numofsymbolblocks
            if None == symbols:
                symbols = []
            self.symbols = symbols

            self.numofpackageblocks = numofpackageblocks
            if None == packages:
                packages = []
            self.packages = packages
            return

        @staticmethod
        def parse(chunk):
            """ Parses library block
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Library.template, chunk)

            _name = None
            if Eagle.Library.no_embed_str != _dta[7][0]:
                _name = Eagle._do_ojs(_dta[7].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

# three ints are counters, have to recheck
            _ret_val = Eagle.Library(name=_name,
                                     numofdevsetblocks=_dta[4],
                                     numofsymbolblocks=_dta[5],
                                     numofpackageblocks=_dta[6],
                                    )
            return _ret_val

    class DeviceSetHeader(Web):
        """ Not a real "Web" but with a like structure
        """
        constant = 0x17
        template = "=4B3I8s"

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, name, numofblocks=0, numofshapesets=0,
                     shapesets=None):
            """ Just a constructor
            """
            super(Eagle.DeviceSetHeader, self).__init__(name, numofblocks,
                        numofshapesets, shapesets)
            return

        @staticmethod
        def parse(chunk):
            """ Parses deviceset block
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.DeviceSetHeader.template, chunk)

            _name = None
            if Eagle.DeviceSetHeader.no_embed_str != _dta[7][0]:
                _name = Eagle._do_ojs(_dta[7].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.DeviceSetHeader(name=_name,
                                       numofblocks=_dta[4],
                                       numofshapesets=_dta[5],
                                      )
            return _ret_val

    class SymbolHeader(Web):
        """ A struct that represents a header of symbols
        """
        constant = 0x18
        template = "=4B3I8s"

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, name, numofblocks=0, numofshapesets=0,
                     shapesets=None):
            """ Just a constructor
            """
            super(Eagle.SymbolHeader, self).__init__(name, numofblocks,
                        numofshapesets, shapesets)
            return

        @staticmethod
        def parse(chunk):
            """ Parses symbolheader block
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.SymbolHeader.template, chunk)

            _name = None
            if Eagle.SymbolHeader.no_embed_str != _dta[7][0]:
                _name = Eagle._do_ojs(_dta[7].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.SymbolHeader(name=_name,
                                          numofblocks=_dta[4],
                                          numofshapesets=_dta[5],
                                         )
            return _ret_val

    class PackageHeader(Web):
        """ A struct that represents a header of packages
        """
        constant = 0x19
        template = "=4B3I8s"

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, name, numofblocks=0, numofshapesets=0,
                     shapesets=None):
            """ Just a constructor
            """
            super(Eagle.PackageHeader, self).__init__(name, numofblocks,
                        numofshapesets, shapesets)
            return

        @staticmethod
        def parse(chunk):
            """ Parses packageheader block
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.PackageHeader.template, chunk)

            _name = None
            if Eagle.PackageHeader.no_embed_str != _dta[7][0]:
                _name = Eagle._do_ojs(_dta[7].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.PackageHeader(name=_name,
                                           numofblocks=_dta[4],
                                           numofshapesets=_dta[5],
                                          )
            return _ret_val

    class Symbol(NamedShapeSet):
        """ A struct that represents a symbol
        """
        constant = 0x1d
        template = "=2BHI4BI8s"

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, libid, name, numofshapes=0, shapes=None):
            """ Just a constructor; shown for a sake of clarity
            """
            super(Eagle.Symbol, self).__init__(name, numofshapes, shapes)
            self.libid = libid
            return

        @staticmethod
        def parse(chunk):
            """ Parses symbol block
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Symbol.template, chunk)

            _name = None
            if Eagle.Symbol.no_embed_str != _dta[9][0]:
                _name = Eagle._do_ojs(_dta[9].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

# number of shapes, excluding this line
            _ret_val = Eagle.Symbol(libid=_dta[5],
                                    name=_name,
                                    numofshapes=_dta[2],
                                   )
            return _ret_val

    class Package(NamedShapeSet):
        """ A struct that represents a package
        """
        constant = 0x1e
        template = "=2BH2IB5s6s"

        max_embed_nlen = 5
        max_embed_dlen = 6
        no_embed_str = b'\x7f'

        def __init__(self, name, desc, numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.Package, self).__init__(name, numofshapes, shapes)
            self.desc = desc
            return

        @staticmethod
        def parse(chunk):
            """ Parses package block
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Package.template, chunk)

            _name = None
            if Eagle.Package.no_embed_str != _dta[6][0]:
                _name = Eagle._do_ojs(_dta[6].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _desc = None
            if Eagle.Package.no_embed_str != _dta[7][0]:
                _desc = Eagle._do_ojs(_dta[7].rstrip(r'\0'))
            else: # from external string block
                _desc = Eagle.attr_jar_list.next().name

# number of shapes, excluding this line
            _ret_val = Eagle.Package(name=_name,
                                     desc=_desc,
                                     numofshapes=_dta[2],
                                    )
            return _ret_val

    class Net(NamedShapeSet):
        """ A struct that represents a net
        """
        constant = 0x1f
        template = "=2BH2I4B8s"

        constantmid1 = 0x7fff7fff
        constantmid2 = 0x80008000

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, name, nclass, numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.Net, self).__init__(name, numofshapes, shapes)
            self.nclass = nclass
            return

        @staticmethod
        def parse(chunk):
            """ Parses net
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Net.template, chunk)

            if (Eagle.Net.constantmid1 != _dta[3] or
                    Eagle.Net.constantmid2 != _dta[4]):
                pass # strange mid-constants in net

            _name = None
            if Eagle.Net.no_embed_str != _dta[9][0]:
                _name = Eagle._do_ojs(_dta[9].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.Net(name=_name,
                                 nclass=_dta[6],
                                 numofshapes=_dta[2],
                                )
            return _ret_val

    class Part(NamedShapeSet):
        """ A struct that represents a part
        """
        constant = 0x38
        template = "=2B3H3B5s8s"

        max_embed_len1 = 5
        max_embed_len2 = 8
        no_embed_str = b'\x7f'

        val_sign_mask = 0x01

        def __init__(self, name, libid, devsetndx, symvar, techno, value='', # pylint: disable=R0913
                     numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.Part, self).__init__(name, numofshapes, shapes)
            self.value = value
            self.libid = libid
            self.devsetndx = devsetndx
            self.symvar = symvar # within a devset!
            self.techno = techno
            return

        @staticmethod
        def parse(chunk):
            """ Parses part
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Part.template, chunk)

            _name = None
            if Eagle.Part.no_embed_str != _dta[8][0]:
                _name = Eagle._do_ojs(_dta[8].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _value = None
            if Eagle.Part.no_embed_str != _dta[9][0]:
                _value = Eagle._do_ojs(_dta[9].rstrip(r'\0'))
            else: # from external string block
                _value = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.Part(name=_name,
                                 libid=_dta[3],
                                 devsetndx=_dta[4],
                                 symvar=_dta[5],
                                 techno=_dta[6],
#                                 valpresence =
#                                    True if _dta[7] & Eagle.Part.val_sign_mask
#                                            else False,
                                 value=_value,
                                 numofshapes=_dta[2],
                                )
            return _ret_val

    class DeviceSet(NamedShapeSet):
        """ A struct that represents a deviceset
        """
        constant = 0x37
        template = "=2B2H2B5s5s6s"

        max_embed_len1 = 5
        max_embed_len2 = 5
        max_embed_len3 = 6
        no_embed_str = b'\x7f'

        nopref_sign_mask = 0x02
        uservalue_sign_mask = 0x01

        def __init__(self, name, prefix, description, uservalue, # pylint: disable=R0913
                     numofshapes=0, shapes=None,
                     numofconnblocks=0, connblocks=None):
            """ Just a constructor
            """
            super(Eagle.DeviceSet, self).__init__(name, numofshapes, shapes)
            self.prefix = prefix
            self.description = description
            self.uservalue = uservalue

            self.numofconnblocks = numofconnblocks
            if None == connblocks:
                connblocks = []
            self.connblocks = connblocks
            return

        @staticmethod
        def parse(chunk):
            """ Parses deviceset
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.DeviceSet.template, chunk)

            _prefix = None
            if Eagle.DeviceSet.no_embed_str != _dta[6][0]:
                _prefix = Eagle._do_ojs(_dta[6].rstrip(r'\0'))
            else: # from external string block
                _prefix = Eagle.attr_jar_list.next().name

            _desc = None
            if Eagle.DeviceSet.no_embed_str != _dta[7][0]:
                _desc = Eagle._do_ojs(_dta[7].rstrip(r'\0'))
            else: # from external string block
                _desc = Eagle.attr_jar_list.next().name

            _name = None
            if Eagle.DeviceSet.no_embed_str != _dta[8][0]:
                _name = Eagle._do_ojs(_dta[8].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

# numofshapes excludes connections-related info
# their num is numofconnblocks
            _ret_val = Eagle.DeviceSet(name=_name,
                                       prefix=_prefix,
                                       description=_desc,
#                                 prefpresence =
#                                    False if _dta[4] & Eagle.DeviceSet.nopref_sign_mask
#                                            else True,
                                        uservalue =
                                           True if _dta[4] &
                                                    Eagle.DeviceSet.uservalue_sign_mask
                                                else False,
                                        numofshapes=_dta[2],
                                        numofconnblocks=_dta[3],
                                       )
            return _ret_val

    class Bus(NamedShapeSet):
        """ A struct that represents a bus
        """
        constant = 0x3a
        template = "=2BH20s"

        max_embed_len = 20
        no_embed_str = b'\x7f'

        def __init__(self, name, numofshapes=0, shapes=None):
            """ Just a constructor; shown for a sake of clarity
            """
            super(Eagle.Bus, self).__init__(name, numofshapes, shapes)
            return

        @staticmethod
        def parse(chunk):
            """ Parses bus
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Bus.template, chunk)

            _name = None
            if Eagle.Package.no_embed_str != _dta[3][0]:
                _name = Eagle._do_ojs(_dta[3].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.Bus(name=_name,
                                 numofshapes=_dta[2],
                                )
            return _ret_val

    class ShapeHeader(ShapeSet):
        """ A struct that represents a header of shapes
        """
        constant = 0x1a
        template = "=2BH5I"

        def __init__(self, numofshapes=0, shapes=None, # pylint: disable=R0913
                     numofpartblocks=0, parts=None,
                     numofbusblocks=0, buses=None,
                     numofnetblocks=0, nets=None,):
            """ Just a constructor
            """
            super(Eagle.ShapeHeader, self).__init__(numofshapes, shapes)

            self.numofpartblocks = numofpartblocks
            if None == parts:
                parts = []
            self.parts = parts

            self.numofbusblocks = numofbusblocks
            if None == buses:
                buses = []
            self.buses = buses

            self.numofnetblocks = numofnetblocks
            if None == nets:
                nets = []
            self.nets = nets
            return

        @staticmethod
        def parse(chunk):
            """ Parses shape header block
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.ShapeHeader.template, chunk)

# number of shapes, excluding this header block
            _ret_val = Eagle.ShapeHeader(numofshapes=_dta[2],
                                         numofpartblocks=_dta[5],
                                         numofbusblocks=_dta[6],
                                         numofnetblocks=_dta[7],
                                        )
            return _ret_val

    class Segment(ShapeSet):
        """ A struct that represents a segment
        """
        constant = 0x20
        template = "=2BHI4B3I"

        def __init__(self, numofshapes=0, shapes=None,
                     cumulativenumofshapes=0):
            """ Just a constructor
            """
            super(Eagle.Segment, self).__init__(numofshapes, shapes)
            self.cumulativenumofshapes = cumulativenumofshapes
            return

        @staticmethod
        def parse(chunk):
            """ Parses segment
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Segment.template, chunk)

            _ret_val = Eagle.Segment(numofshapes=_dta[2],
                                     cumulativenumofshapes=_dta[5], # TODO recheck
                                    )
            return _ret_val

    class ConnectionHeader(NamedShapeSet):
        """ A struct that represents a header for 'connections' blocks
        """
        constant = 0x36
        template = "=2B2H13s5s"

        constantmid_def = "''"

        no_embed_str = b'\x7f'
        max_embed_len = 13

        delim_techs = b'\x04'
        delim_namesvals = b'\x04'
        delim_names = b'\x01'
        delim_vals = b'\x02'

        def __init__(self, sindex, attributes, technologies, name, # pylint: disable=R0913
                     numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.ConnectionHeader, self).__init__(name, numofshapes,
                                                                        shapes)
            self.sindex = sindex

            if None == technologies:
                technologies = []
            self.technologies = technologies

            if None == attributes:
                attributes = []
            self.attributes = attributes
            return

        @staticmethod
        def parse(chunk):
            """ Parses header for 'connections' blocks
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.ConnectionHeader.template, chunk)

            if Eagle.ConnectionHeader.no_embed_str != _dta[4][0]:
                _attrstr = Eagle._do_ojs(_dta[4].rstrip(r'\0'))
            else: # from external string block
                _attrstr = Eagle.attr_jar_list.next().name

            _attrs = []
            _techs = []

            if 0 < len(_attrstr):
                if Eagle.ConnectionHeader.delim_techs == _attrstr[0]:
                    for _tt in _attrstr.split(
                                Eagle.ConnectionHeader.delim_techs)[1:]:
                        _techs.append(Eagle._do_ojs(_tt))
                elif Eagle.ConnectionHeader.delim_names == _attrstr[0]:
                    _attrparts = _attrstr.split(
                                Eagle.ConnectionHeader.delim_namesvals)
                    if 1 < len(_attrparts): # got a correct str
                        for _nn, _vv in zip(
                                (Eagle._do_ojs(x) for x in _attrparts[0].split(
                                        Eagle.ConnectionHeader.delim_names)[1:]),
                                (Eagle._do_ojs(x) for x in _attrparts[1].split(
                                        Eagle.ConnectionHeader.delim_vals)[1:])):
                            _attrs.append((_nn, _vv))

            if Eagle.ConnectionHeader.no_embed_str != _dta[5][0]:
                _name = Eagle._do_ojs(_dta[5].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name
            if Eagle.ConnectionHeader.constantmid_def == _name:
                _name = ''

            _ret_val = Eagle.ConnectionHeader(numofshapes=_dta[2],
                                              sindex=_dta[3],
                                              technologies=_techs,
                                              attributes=_attrs,
                                              name=_name,
                                             )
            return _ret_val

    class Connections:
        """ A struct that represents a set of connection indexes
        """
        constant = 0x3c
        template = "=2B22B"

        connset_len = 22

        def __init__(self, connections=None):
            """ Just a constructor
            """
            if None == connections:
                connections = []
            self.connections = connections
            return

        @staticmethod
        def parse(chunk):
            """ Parses connection indexes set
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Connections.template, chunk)

            _ret_val = Eagle.Connections(connections=[x for x in _dta[2:]
                                                                if 0 != x],
                                        )
            return _ret_val

    class Shape(object):
        """ A base struct for shapes, provides common codecs
             Although it provides two scaling methods, #2 has
             to be used all the time
        """

        scale1a = 1000000.0
        scale1b = 2
        scale2 = 10000.0

        width_xscale = 2
        size_xscale = 2
        ratio_sscale = 2

        rotatemask = 0x0c # in some cases 0x0f works as well
        rotatemask2 = 0x0f # R40 is possible in text...
        rotates = {
                   0x00: None,
                   0x01: "R40",
                   0x02: "R45",
                   0x04: "R90",
                   0x06: "R135",
                   0x08: "R180",
                   0x0a: "R225",
                   0x0c: "R270",
                   0x0e: "R315",
# ones below are possible for text & frame -- don't apply the mask there
#                   0x10: "MR0",
#                   0x12: "MR45",
#                   0x14: "MR90",
#                   0x16: "MR135",
#                   0x18: "MR180",
#                   0x1a: "MR225",
#                   0x1c: "MR270",
#                   0x1e: "MR315",

#                   0x40: "SR0", #...
                  }

        rotate_r0 = "R0" # used in SR0, MR0 cases

        rotateprefixmask = 0x70
        rotate_prefixes = {
                   0x00: '',
                   0x10: 'M',
                   0x40: 'S',
                }

        fonts = {
                  0x00: "vector",
                  0x01: None, # "proportional",
                  0x02: "fixed",
                 }

        def __init__(self, layer):
            """ Just a constructor
            """
            self.layer = layer
            return

        @staticmethod
        def decode_real(number, algo=2):
            """ Transforms given binary array to a float
            """
            _ret_val = 0
            if 1 == algo:
                _ret_val = ((number << Eagle.Shape.scale1b) /
                                                Eagle.Shape.scale1a)
            elif 2 == algo:
                _ret_val = number / Eagle.Shape.scale2
            return _ret_val

        @staticmethod
        def rotate2piradians(rotate):
            """ Converts 'rotates' string into pi radians.
                It could be implemented as a map, but a special handling for
                 None as 0. would be needed..
            """
            _ret_val = 0.

            if 'R90' == rotate:
                _ret_val = 0.5
            elif 'R180' == rotate:
                _ret_val = 1.
            elif 'R270' == rotate:
                _ret_val = 1.5
            return _ret_val

        @staticmethod
        def _ext_rotate(rotate_octet):
            """ Constructs extanded rotate mark
            """
            _rotate = (
                    Eagle.Text.rotate_prefixes[
                                Eagle.Text.rotateprefixmask & rotate_octet],
                    Eagle.Text.rotates[Eagle.Text.rotatemask2 & rotate_octet],
                    )
            if None == _rotate[1]: # SR0, MR0, None (R0) cases
                if 0 < len(_rotate[0]): # SR0, MR0
                    _ret_val = _rotate[0] + Eagle.Text.rotate_r0
                else: # None
                    _ret_val = None
            else: # R > 0
                _ret_val = _rotate[0] + _rotate[1]
            return _ret_val

    class Polygon(ShapeSet, Shape):
        """ A struct that represents a polygon
        """
        constant = 0x21
        template = "=2BH2I2H4BI"

        def __init__(self, width, layer, numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.Polygon, self).__init__(numofshapes, shapes)
            self.layer = layer # no Shape constructor will be called
            self.width = width
            return

        @staticmethod
        def parse(chunk):
            """ Parses segment
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Polygon.template, chunk)

            _ret_val = Eagle.Polygon(numofshapes=_dta[2],
                                     width=(Eagle.Polygon.width_xscale *
                                             Eagle.Shape.decode_real(
                                                                    _dta[5])),
                                     layer=_dta[9],
                                    )
            return _ret_val

    class Instance(ShapeSet, Shape):
        """ A struct that represents an instance
        """
        constant = 0x30
        template = "=2BH2iH6BI"

        smashed_mask = 0x01 # IC, +PART
        smashed2_mask = 0x02 #??

        constantmid = 0xffff

        def __init__(self, x, y, smashed, rotate, numofshapes=0, # pylint: disable=R0913
                     shapes=None):
            """ Just a constructor
            """
            super(Eagle.Instance, self).__init__(numofshapes, shapes)
#            super(Eagle.Shape, self).__init__(-1)
            self.x = x
            self.y = y
            self.smashed = smashed
            self.rotate = rotate
            return

        @staticmethod
        def parse(chunk):
            """ Parses instance
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Instance.template, chunk)

            _ret_val = Eagle.Instance(numofshapes=_dta[2],
                                     x=Eagle.Instance.decode_real(_dta[3]),
                                     y=Eagle.Instance.decode_real(_dta[4]),
                                     smashed=True
                                        if Eagle.Instance.smashed_mask ==
                                            (Eagle.Instance.smashed_mask &
                                                _dta[10]) or
                                            Eagle.Instance.smashed2_mask ==
                                            (Eagle.Instance.smashed2_mask &
                                                _dta[10]) else False,
                                     rotate=Eagle.Instance.rotates[
                                         Eagle.Instance.rotatemask & _dta[9]],
                                    )
            return _ret_val

    class Circle(Shape):
        """ A struct that represents a circle
        """
        constant = 0x25
        template = "=4B2i2IH2B"

        def __init__(self, x, y, radius, width, layer): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.Circle, self).__init__(layer)
            self.x = x
            self.y = y
            self.radius = radius
            self.width = width
            return

        @staticmethod
        def parse(chunk):
            """ Parses rectangle
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Circle.template, chunk)

            _ret_val = Eagle.Circle(
                                      x=Eagle.Shape.decode_real(_dta[4]),
                                      y=Eagle.Shape.decode_real(_dta[5]),
                                      radius=Eagle.Shape.decode_real(_dta[6]), # the same as [7]
                                      layer=_dta[3],
                                      width=(Eagle.Circle.width_xscale *
                                             Eagle.Shape.decode_real(
                                                                    _dta[8]))
                                         )
            return _ret_val

    class Rectangle(Shape):
        """ A struct that represents a rectangle
        """
        constant = 0x26
        template = "=4B4i4B"

        def __init__(self, x1, y1, x2, y2, layer, rotate): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.Rectangle, self).__init__(layer)
            self.x1 = x1 # bottom left corner
            self.y1 = y1
            self.x2 = x2 # upper right corner
            self.y2 = y2
            self.rotate = rotate
            return

        @staticmethod
        def parse(chunk):
            """ Parses rectangle
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Rectangle.template, chunk)

            _ret_val = Eagle.Rectangle(
                                      x1=Eagle.Shape.decode_real(_dta[4]),
                                      y1=Eagle.Shape.decode_real(_dta[5]),
                                      x2=Eagle.Shape.decode_real(_dta[6]),
                                      y2=Eagle.Shape.decode_real(_dta[7]),
                                      layer=_dta[3],
                                      rotate=Eagle.Rectangle.rotates[_dta[9]]
                                         )
            return _ret_val

    class Wire(Shape):
        """ A struct that represents a wire
        """
        constant = 0x22
        template = "=4B4iH2B"

        stylemask = 0x0f
        styles = {
                  0x00: "Continuous",
                  0x01: "LongDash",
                  0x02: "ShortDash",
                  0x03: "DashDot",
                 }

        wire_sign = 0x00
        arc_preset1 = (0x78, 0x79, ) # -90: q1, q2
        arc_preset2 = (0x7a, 0x7b, ) # +90: q3, q4
        arc_preset3 = (0x7c, 0x7e, ) # -180: q41, q12
        arc_preset4 = (0x7d, 0x7f, ) # +180: q23, q34
        arc_sign = 0x81

        def __init__(self, x1, y1, x2, y2, style, layer, width): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.Wire, self).__init__(layer)
            self.x1 = x1
            self.y1 = y1
            self.x2 = x2
            self.y2 = y2
            self.width = width
            self.style = style
            return

        @staticmethod
        def parse(chunk):
            """ Parses wire
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Wire.template, chunk)

            if Eagle.Wire.wire_sign == _dta[10]:
                _ret_val = Eagle.Wire(
                                      x1=Eagle.Shape.decode_real(_dta[4]),
                                      y1=Eagle.Shape.decode_real(_dta[5]),
                                      x2=Eagle.Shape.decode_real(_dta[6]),
                                      y2=Eagle.Shape.decode_real(_dta[7]),
                                      style=Eagle.Wire.styles[
                                          Eagle.Wire.stylemask & _dta[9]],
                                      layer=_dta[3],
                                      width=(Eagle.Wire.width_xscale *
                                             Eagle.Shape.decode_real(
                                                                    _dta[8]))
                                         )
            elif _dta[10] in (Eagle.Wire.arc_preset1 + Eagle.Wire.arc_preset2 +
                            Eagle.Wire.arc_preset3 + Eagle.Wire.arc_preset4):
                _ret_val = Eagle.FixedArc.parse(chunk)
            elif Eagle.Wire.arc_sign == _dta[10]: # Arc features "packed" coordinates...
                _ret_val = Eagle.Arc.parse(chunk)
            else:
                raise ValueError("unknown wire sign = x%x" % _dta[10])

            return _ret_val

    class Junction(Shape):
        """ A struct that represents a junction
        """
        constant = 0x27
        template = "=4B5I"

        constantmid = 0x000013d8

        def __init__(self, x, y, layer):
            """ Just a constructor
            """
            super(Eagle.Junction, self).__init__(layer)
            self.x = x
            self.y = y
            return

        @staticmethod
        def parse(chunk):
            """ Parses junction
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Junction.template, chunk)

            _ret_val = Eagle.Junction(x=Eagle.Shape.decode_real(_dta[4]),
                                         y=Eagle.Shape.decode_real(_dta[5]),
                                         layer=_dta[3],
                                        )
            return _ret_val

    class Hole(Shape):
        """ A struct that represents a hole
            (no layer is available for hole ; base Shape class
            is used both for uniformity and convertors)
        """
        constant = 0x28
        template = "=4B5I"

        def __init__(self, x, y, drill):
            """ Just a constructor
            """
            super(Eagle.Hole, self).__init__(-1)
            self.x = x
            self.y = y
            self.drill = drill
            return

        @staticmethod
        def parse(chunk):
            """ Parses junction
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Hole.template, chunk)

            _ret_val = Eagle.Hole(x=Eagle.Shape.decode_real(_dta[4]),
                                  y=Eagle.Shape.decode_real(_dta[5]),
                                  drill=(Eagle.Hole.width_xscale *
                                      Eagle.Shape.decode_real(_dta[6])),
                                 )
            return _ret_val

    class SMD(Shape):
        """ A struct that represents an SMD (Surface Mount Device)
        """
        constant = 0x2b
        template = "=4B2i2H3B5s"

        max_embed_len = 5
        no_embed_str = b'\x7f'

        def __init__(self, name, x, y, dx, dy, layer): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.SMD, self).__init__(layer)
            self.name = name
            self.x = x
            self.y = y
            self.dx = dx
            self.dy = dy
            return

        @staticmethod
        def parse(chunk):
            """ Parses junction
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.SMD.template, chunk)

            _name = None
            if Eagle.SMD.no_embed_str != _dta[11][0]:
                _name = Eagle._do_ojs(_dta[11].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.SMD(name=_name,
                                 x=Eagle.Shape.decode_real(_dta[4]),
                                 y=Eagle.Shape.decode_real(_dta[5]),
                                 dx=(Eagle.Hole.width_xscale *
                                      Eagle.Shape.decode_real(_dta[6])),
                                 dy=(Eagle.Hole.width_xscale *
                                      Eagle.Shape.decode_real(_dta[7])),
                                 layer=_dta[3],
                                )
            return _ret_val

    class FixedArc(Wire):
        """ A struct that represents a fixed angle arc
        """
        capmask = 0x10
        caps = {
                0x00: None,
                0x10: "flat",
               }
        directionmask = 0x20
        directions = {
                      0x00: "clockwise",        # == negative curve (angle)
                      0x20: "counterclockwise", # == positive curve (angle)
                     }

        def __init__(self, x1, y1, x2, y2, style, layer, width, # pylint: disable=R0913
                        curve, cap, direction):
            """ Just a constructor
            """
            super(Eagle.FixedArc, self).__init__(x1, y1, x2, y2, style, layer, width)
            self.curve = curve
            self.cap = cap
            self.direction = direction
            return

        @staticmethod
        def parse(chunk):
            """ Parses arc
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.FixedArc.template, chunk)

            _curve = None
            if _dta[10] in Eagle.Wire.arc_preset1:
                _curve = -90.
            elif _dta[10] in Eagle.Wire.arc_preset2:
                _curve = 90.
            elif _dta[10] in Eagle.Wire.arc_preset3:
                _curve = -180.
            elif _dta[10] in Eagle.Wire.arc_preset4:
                _curve = 180.

            _ret_val = Eagle.FixedArc(
                          x1=Eagle.Shape.decode_real(_dta[4]),
                          y1=Eagle.Shape.decode_real(_dta[5]),
                          x2=Eagle.Shape.decode_real(_dta[6]),
                          y2=Eagle.Shape.decode_real(_dta[7]),
                          layer=_dta[3],
                          width=(Eagle.Wire.width_xscale *
                                 Eagle.Shape.decode_real(
                                                        _dta[8])),
                          style=Eagle.Wire.styles[
                              Eagle.Wire.stylemask & _dta[9]],
                          curve=_curve,
                          cap=Eagle.Arc.caps[_dta[9] & Eagle.Arc.capmask],
                          direction=Eagle.Arc.directions[_dta[9] &
                                                Eagle.Arc.directionmask]
                                     )
            return _ret_val


    class Arc(FixedArc):
        """ A struct that represents a free angle arc
        """
        template = "=4B4IH2B" # 3-bytes long coords here..

        @staticmethod
        def parse(chunk):
            """ Parses arc
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Arc.template, chunk)

            # sign propogation by hand
            _x1 = (Eagle.Shape.decode_real(_dta[4] & 0xffffff)
                    if 0 == (0x800000 & _dta[4])
                    else (-1 *
                        Eagle.Shape.decode_real(0x1000000 - (_dta[4] & 0xffffff))))
            _y1 = (Eagle.Shape.decode_real(_dta[5] & 0xffffff)
                    if 0 == (0x800000 & _dta[5])
                    else (-1 *
                        Eagle.Shape.decode_real(0x1000000 - (_dta[5] & 0xffffff))))
            _x2 = (Eagle.Shape.decode_real(_dta[6] & 0xffffff)
                    if 0 == (0x800000 & _dta[6])
                    else (-1 *
                        Eagle.Shape.decode_real(0x1000000 - (_dta[6] & 0xffffff))))
            _y2 = (Eagle.Shape.decode_real(_dta[7] & 0xffffff)
                    if 0 == (0x800000 & _dta[7])
                    else (-1 *
                        Eagle.Shape.decode_real(0x1000000 - (_dta[7] & 0xffffff))))

# _coord is a single (either x or y) coordinate of a circle's center
            _coord = (Eagle.Shape.decode_real(
                      (((_dta[4] & 0xff000000) >> 24) & 0xff) +
                      (((_dta[5] & 0xff000000) >> 16) & 0xff00) +
                      (((_dta[6] & 0xff000000) >> 8) & 0xff0000))
                    if 0 == (0x80000000 & _dta[6])
                    else (-1 *
                      Eagle.Shape.decode_real((0x1000000 - (
                              (((_dta[4] & 0xff000000) >> 24) & 0xff) +
                              (((_dta[5] & 0xff000000) >> 16) & 0xff00) +
                              (((_dta[6] & 0xff000000) >> 8) & 0xff0000))))))

# have to determine which coord is given
            _dx = math.pow(_coord - _y2, 2) - math.pow(_coord - _y1, 2)
            _dy = math.pow(_coord - _x1, 2) - math.pow(_coord - _x2, 2)

            if abs(_x2 - _x1) < abs(_y2 - _y1): # X is given
                _x3 = _coord
                _y3 = (_dy - _y2 * _y2 + _y1 * _y1) / (2 * (_y1 - _y2))
            else: # Y is given
                _x3 = (_dx - _x1 * _x1 + _x2 * _x2) / (2 * (_x2 - _x1))
                _y3 = _coord

            _curve = math.degrees(math.acos((math.pow(_x1 - _x3, 2) + math.pow(_y1 - _y3, 2) +
                                             math.pow(_x2 - _x3, 2) + math.pow(_y2 - _y3, 2) +
                                             - math.pow(_x1 - _x2, 2) - math.pow(_y1 - _y2, 2)) /
                                    (2 * math.sqrt(math.pow(_x1 - _x3, 2) + math.pow(_y1 - _y3, 2)) *
                                         math.sqrt(math.pow(_x2 - _x3, 2) + math.pow(_y2 - _y3, 2)))))
            if not (_dta[9] & Eagle.Arc.directionmask):
                _curve *= -1

            _ret_val = Eagle.Arc( # sign propogation by hand
                          x1=_x1, y1=_y1, x2=_x2, y2=_y2,
                          layer=_dta[3],
                          width=(Eagle.Wire.width_xscale *
                                 Eagle.Shape.decode_real(
                                                        _dta[8])),
                          style=Eagle.Wire.styles[
                              Eagle.Wire.stylemask & _dta[9]],
                          curve=int((_curve + 0.005) * 100) / 100., # rounding
                          cap=Eagle.Arc.caps[_dta[9] & Eagle.Arc.capmask],
                          direction=Eagle.Arc.directions[_dta[9] &
                                                Eagle.Arc.directionmask]
                                     )
            return _ret_val

    class Pad(Shape):
        """ A struct that represents a pad
            (no layer is available for pad ; base Shape class
            is used both for uniformity and convertors)
        """
        constant = 0x2a
        template = "=4B3I3B5s"

        max_embed_len = 5
        no_embed_str = b'\x7f'

        def __init__(self, name, x, y, drill):
            """ Just a constructor
            """
            super(Eagle.Pad, self).__init__(layer=-1)
            self.name = name
            self.x = x
            self.y = y
            self.drill = drill
# TODO shape (3:1==normal,3==long)
            return

        @staticmethod
        def parse(chunk):
            """ Parses pad
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Pad.template, chunk)

            _name = None
            if Eagle.Pad.no_embed_str != _dta[10][0]:
                _name = Eagle._do_ojs(_dta[10].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.Pad(name=_name,
                                 x=Eagle.Shape.decode_real(_dta[4]),
                                 y=Eagle.Shape.decode_real(_dta[5]),
                                 drill=Eagle.Shape.decode_real(_dta[6]),
                                )
            return _ret_val

    class Pin(Shape):
        """ A struct that represents a pin
            (no layer is available for pin ; base Shape class
            is used both for uniformity and convertors)
        """
        constant = 0x2c
        template = "=4B2i2B10s"

        max_embed_len = 10
        no_embed_str = b'\x7f'

        visiblemask = 0xf0
        visibles = {
                    0x00: "off",
                    0x40: "pad",
                    0x80: "pin",
                    0xc0: None, # default
                   }
        dirmask = 0x0f
        directions = {
                      0x00: "nc",
                      0x01: "in",
                      0x02: "out",
                      0x03: None, # default
                      0x04: "oc",
                      0x05: "pwr",
                      0x06: "pas",
                      0x07: "hiz",
                      0x08: "sup",
                     }
        lengthmask = 0x30
        lengths = {
                   0x00: "point",
                   0x10: "short",
                   0x20: "middle",
                   0x30: None, # default
                  }
        funcmask = 0x0f
        functions = {
                     0x00: None, # default
                     0x01: "dot",
                     0x02: "clk",
                     0x03: "dotclk",
                    }

        def __init__(self, name, x, y, visible, direction, rotate, length, # pylint: disable=R0913
                     function=None, swaplevel=0):
            """ Just a constructor
            """
            super(Eagle.Pin, self).__init__(layer=-1)
            self.name = name
            self.x = x
            self.y = y
            self.visible = visible
            self.direction = direction # signal direction
# rotation codes line direction: R0 means left, R90 - down, R180 - right, R270 - up
            self.rotate = rotate
            self.length = length # not a number
            self.function = function
            self.swaplevel = swaplevel
            return

        @staticmethod
        def parse(chunk):
            """ Parses pin
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Pin.template, chunk)

            _name = None
            if Eagle.Pin.no_embed_str != _dta[8][0]:
                _name = Eagle._do_ojs(_dta[8].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.Pin(name=_name,
                                 x=Eagle.Shape.decode_real(_dta[4]),
                                 y=Eagle.Shape.decode_real(_dta[5]),
                                 visible=Eagle.Pin.visibles[_dta[2] &
                                                Eagle.Pin.visiblemask],
                                 direction=Eagle.Pin.directions[_dta[6] &
                                                Eagle.Pin.dirmask],
                                 rotate=Eagle.Pin.rotates[
                                              ((Eagle.Pin.rotatemask << 4) &
                                              _dta[6]) >> 4],
                                 length=Eagle.Pin.lengths[_dta[6] &
                                                Eagle.Pin.lengthmask],
                                 function=Eagle.Pin.functions[_dta[2] &
                                                Eagle.Pin.funcmask],
                                 swaplevel=_dta[7],
                                )
            return _ret_val

    class Gate(Shape):
        """ A struct that represents a gate
            (no layer is available for gate ; base Shape class
            is used both for uniformity and convertors)
        """
        constant = 0x2d
        template = "=4B2i2BH8s"

        addlevels = {
                     0x00: "must",
                     0x02: None,
                     0x03: "request",
                     0x04: "always",
                    }

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, x, y, name, sindex, addlevel): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.Gate, self).__init__(-1)
            self.x = x
            self.y = y
            self.name = name
            self.sindex = sindex # symbol index
            self.addlevel = addlevel
            return

        @staticmethod
        def parse(chunk):
            """ Parses junction
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Gate.template, chunk)

            _name = None
            if Eagle.Gate.no_embed_str != _dta[9][0]:
                _name = Eagle._do_ojs(_dta[9].rstrip(r'\0'))
            else: # from external string block
                _name = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.Gate(x=Eagle.Shape.decode_real(_dta[4]),
                                  y=Eagle.Shape.decode_real(_dta[5]),
                                  name=_name,
                                  sindex=_dta[8],
                                  addlevel=Eagle.Gate.addlevels[_dta[6]],
                                 )
            return _ret_val

    class Text(Shape):
        """ A struct that represents a text
        """
        constant = 0x31
        template = "=4B2iH4B6s"

        max_embed_len = 5
        delimeter = b'!'
        no_embed_str = b'\x7f'

        def __init__(self, value, x, y, size, layer, rotate, font, ratio): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.Text, self).__init__(layer)
            self.value = value
            self.x = x
            self.y = y
            self.size = size
            self.rotate = rotate
            self.font = font
            self.ratio = ratio
            return

        @staticmethod
        def parse(chunk):
            """ Parses text
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Text.template, chunk)

            _value = None
            if Eagle.Text.no_embed_str != _dta[11][0]:
                _value = Eagle._do_ojs(_dta[11].rstrip(r'\0'))
            else: # from external string block
                _value = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.Text(value=_value,
                                     x=Eagle.Shape.decode_real(_dta[4]),
                                     y=Eagle.Shape.decode_real(_dta[5]),
                                     size=Eagle.Text.size_xscale *
                                          Eagle.Shape.decode_real(_dta[6]),
                                     layer=_dta[3],
                                     rotate=Eagle.Text._ext_rotate(_dta[10]),
                                     font=Eagle.Text.fonts[_dta[2]],
                                     ratio=_dta[7] >> Eagle.Text.ratio_sscale,
                                    )
            return _ret_val

        @staticmethod
        def parse2(chunk):
            """ Parses string name
            """
            _ret_val = None

            _parts = chunk.split(Eagle.Text.delimeter)
            if 1 < len(_parts):
                pass # too many extra values for Text

            _ret_val = _parts[0]

            return _ret_val

    class Label(Shape):
        """ A struct that represents a label
        """
        constant = 0x33
        template = "=4B2I2H4BI"

        mirroredmask = 0x10
        onoffmask = 0x01

        def __init__(self, x, y, size, layer, rotate, ratio, font,  # pylint: disable=R0913
                     onoff, mirrored):
            """ Just a constructor
                Note: 6.0.0's xref is an other name for onoff
            """
            super(Eagle.Label, self).__init__(layer)
            self.x = x
            self.y = y
            self.size = size
            self.xref = onoff
            self.rotate = rotate
            self.ratio = ratio
            self.font = font
            self.onoff = onoff
            self.mirrored = mirrored
            return

        @staticmethod
        def parse(chunk):
            """ Parses label
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Label.template, chunk)

            _ret_val = Eagle.Label(x=Eagle.Shape.decode_real(_dta[4]),
                                      y=Eagle.Shape.decode_real(_dta[5]),
                                      size=Eagle.Label.size_xscale *
                                           Eagle.Shape.decode_real(_dta[6]),
                                      layer=_dta[3],
#                                      xref=0,
                                      rotate=Eagle.Label.rotates[
                                              Eagle.Label.rotatemask &
                                              _dta[9]],
                                      ratio=_dta[7] >> Eagle.Text.ratio_sscale,
                                      font=Eagle.Label.fonts[_dta[2]],
                                      onoff=(True if 0 !=
                                             _dta[10] & Eagle.Label.onoffmask
                                             else False),
                                      mirrored=(True if 0 !=
                                                _dta[9] & Eagle.Label.mirroredmask
                                                else False),
                                     )
            return _ret_val

    class Frame(Shape):
        """ A struct that represents a frame
        """
        constant = 0x43
        template = "=4B4i4B"

        bleftmask = 0x08
        btopmask = 0x04
        brightmask = 0x02
        bbottommask = 0x01

        def __init__(self, x1, y1, x2, y2, columns, rows, # pylint: disable=R0913
                    layer, bleft=True, btop=True, bright=True, bbottom=True):
            """ Just a constructor
            """
            super(Eagle.Frame, self).__init__(layer)
            self.x1 = x1
            self.y1 = y1
            self.x2 = x2
            self.y2 = y2

            self.columns = columns
            self.rows = rows

            self.bleft = bleft
            self.btop = btop
            self.bright = bright
            self.bbottom = bbottom
            return

        @staticmethod
        def parse(chunk):
            """ Parses frame
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.Frame.template, chunk)

            _ret_val = Eagle.Frame(x1=Eagle.Shape.decode_real(_dta[4]),
                                      y1=Eagle.Shape.decode_real(_dta[5]),
                                      x2=Eagle.Shape.decode_real(_dta[6]),
                                      y2=Eagle.Shape.decode_real(_dta[7]),
                                      columns=_dta[8],
                                      rows=_dta[9],
                                      bleft=(0 != Eagle.Frame.bleftmask & _dta[10]),
                                      btop=(0 != Eagle.Frame.btopmask & _dta[10]),
                                      bright=(0 != Eagle.Frame.brightmask & _dta[10]),
                                      bbottom=(0 != Eagle.Frame.bbottommask & _dta[10]),
                                      layer=_dta[3],
                                  )
            return _ret_val

    class AttributeNam(Shape):
        """ A struct that represents a part's NAME attribute
        """
        constant = 0x34
        template = "=4B2i2H4B4s"

        def __init__(self, x, y, size, layer, rotate, font, name="NAME"): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.AttributeNam, self).__init__(layer)
            self.name = name
            self.x = x
            self.y = y
            self.size = size
            self.font = font
            self.rotate = rotate
            return

        @staticmethod
        def parse(chunk):
            """ Parses attribute-name
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.AttributeNam.template, chunk)

            _ret_val = Eagle.AttributeNam(x=Eagle.Shape.decode_real(_dta[4]),
                                          y=Eagle.Shape.decode_real(_dta[5]),
                                          size=Eagle.Shape.size_xscale *
                                               Eagle.Shape.decode_real(_dta[6]),
                                          layer=_dta[3],
                                          rotate=Eagle.AttributeNam.rotates[
                                              Eagle.AttributeNam.rotatemask &
                                              _dta[9]],
                                          font=Eagle.AttributeNam.fonts[_dta[2]],
                                         )
            return _ret_val

    class AttributeVal(AttributeNam):
        """ A struct that represents a part's VALUE attribute
        """
        constant = 0x35

        def __init__(self, x, y, size, layer, rotate, font, name="VALUE"): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.AttributeVal, self).__init__(x, y,
                                        size, layer, rotate, font, name)
            return

        @staticmethod
        def parse(chunk):
            """ Parses attribute-name
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.AttributeVal.template, chunk)

            _ret_val = Eagle.AttributeVal(x=Eagle.Shape.decode_real(_dta[4]),
                                          y=Eagle.Shape.decode_real(_dta[5]),
                                          size=Eagle.Shape.size_xscale *
                                               Eagle.Shape.decode_real(_dta[6]),
                                          layer=_dta[3],
                                          rotate=Eagle.AttributeVal.rotates[
                                              Eagle.AttributeVal.rotatemask &
                                              _dta[9]],
                                          font=Eagle.AttributeVal.fonts[_dta[2]],
                                         )
            return _ret_val

    class AttributePrt(AttributeNam):
        """ A struct that represents a part's PART attribute
        """
        constant = 0x3f

        def __init__(self, x, y, size, layer, rotate, font, name="PART"): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.AttributePrt, self).__init__(x, y,
                                        size, layer, rotate, font, name)
            return

        @staticmethod
        def parse(chunk):
            """ Parses attribute-name
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.AttributePrt.template, chunk)

# [7] ?
            _ret_val = Eagle.AttributePrt(x=Eagle.Shape.decode_real(_dta[4]),
                                          y=Eagle.Shape.decode_real(_dta[5]),
                                          size=Eagle.Shape.size_xscale *
                                               Eagle.Shape.decode_real(_dta[6]),
                                          layer=_dta[3],
                                          rotate=Eagle.AttributePrt._ext_rotate(_dta[9]), # no mask: like Text!
                                          font=Eagle.AttributePrt.fonts[_dta[2]],
                                         )
            return _ret_val

    class PinRef(Shape):
        """ A struct that represents a pinref
            (no layer is available for pinref ; base Shape class
            is used both for uniformity and convertors)
        """
        constant = 0x3d
        template = "=4B3H14s"

        def __init__(self, partno, gateno, pinno):
            """ Just a constructor
            """
            super(Eagle.PinRef, self).__init__(-1)
            self.partno = partno
            self.gateno = gateno
            self.pinno = pinno
            return

        @staticmethod
        def parse(chunk):
            """ Parses attribute-name
            """
            _ret_val = None

            _dta = struct.unpack(Eagle.PinRef.template, chunk)

            _ret_val = Eagle.PinRef(partno=_dta[4],
                                    gateno=_dta[5],
                                    pinno=_dta[6],
                                   )
            return _ret_val

    class Attribute:
        """ A struct that represents an attribute
        """
        constant = 0x42
        template = "=3BI17s"

        max_embed_len = 17
        delimeter = b'!'
        no_embed_str = b'\x7f'

        def __init__(self, name, value):
            """ Just a constructor
            """
            self.name = name
            self.value = value
            return

        @staticmethod
        def _parse(string):
            """ Splits string in parts
            """
            (_name, _value) = (None, None)

            _parts = string.split(Eagle.Attribute.delimeter)

            _name = Eagle._do_ojs(_parts[0])
            if 2 > len(_parts):
                pass # strange embedded attribute
            else:
                _value = Eagle.Attribute.delimeter.join(
                                        Eagle._do_ojs(x) for x in _parts[1:])

            return (_name, _value)

        @staticmethod
        def parse(chunk):
            """ Parses block attribute
            """
            _ret_val = None
            (_name, _value) = (None, None)

            _dta = struct.unpack(Eagle.Attribute.template, chunk)

            if Eagle.Attribute.no_embed_str != _dta[4][0]: # embedded attr
                (_name, _value) = Eagle.Attribute._parse(_dta[4].rstrip('\x00'))
            else: # from external string block
# TODO decode [8] [9] [10]
# [11] -- a kind of a marker, 0x09 / 0x08; 4 bytes long int, changed on each save as, even with no changes
#  probably just a random int, no any pattern was discovered
                _name = Eagle.attr_jar_list.next().name

            _ret_val = Eagle.Attribute(name=_name,
                                          value=_value
                                         )
            return _ret_val

        @staticmethod
        def parse2(chunk):
            """ Parses string attribute
            """
            _ret_val = None

            (_name, _value) = Eagle.Attribute._parse(chunk)
            _ret_val = Eagle.Attribute(name=_name,
                                          value=_value
                                         )
            return _ret_val

    class Schematic:
        """ A struct that represents "schematic"
        """
        defxreflabel = ":%F%N/%S.%C%R"
        defxrefpart = "/%S.%C%R"

        delimeter = b'\t'

        def __init__(self, xreflabel=None, xrefpart=None):
            """ Just a constructor
            """
            if None == xreflabel:
                xreflabel = Eagle.Schematic.defxreflabel
            if None == xrefpart:
                xrefpart = Eagle.Schematic.defxrefpart

            self.xreflabel = xreflabel
            self.xrefpart = xrefpart
            return

        @staticmethod
        def parse(chunk):
            """ Parses string attribute
            """
            _ret_val = None
            (_xreflabel, _xrefpart) = (None, None)

            _parts = chunk.split(Eagle.Schematic.delimeter)
            _xreflabel = Eagle._do_ojs(_parts[0])

            if 2 != len(_parts):
                pass # strange schematic string
            else:
                _xrefpart = Eagle._do_ojs(_parts[1])

            _ret_val = Eagle.Schematic(xreflabel=_xreflabel,
                                          xrefpart=_xrefpart
                                         )
            return _ret_val

    class NetClass:
        """ A struct that represents a net class
        """
        template0 = "=3I" # header part read by _parse_file
        template1 = "=13I" # unpack the rest of chunk
        template2x = "=3I%ss13I" # pack the whole thing

        scale1 = 10000.0

        constant = 0x20000425
        constantmid = 0x87654321
        constantend = 0x89abcdef

        endmarker = 0x99999999

        def __init__(self, num, name='', width=0, drill=0, clearances=None, # pylint: disable=R0913
                     leadint=0):
            """ Just a constructor
            """
            self.num = num
            self.name = name
            self.width = width
            self.drill = drill
            if None == clearances:
                clearances = []
            self.clearances = clearances

            self.leadint = leadint # TODO decypher it..
            return

        @staticmethod
        def decode_real(number):
            """ Transforms given binary array to a float
            """
            _ret_val = 0
            _ret_val = number / Eagle.NetClass.scale1
            return _ret_val

        @staticmethod
        def parse(leadint, ncconst, chunk):
            """ Parses netclass
            """
            _ret_val = None

            if Eagle.NetClass.constant == ncconst and None != chunk:
                _name = Eagle._do_ojs(chunk.split(r'\0')[0])
                _foff = 1 + len(_name)

# number of clearance intervals (and thus block length) depends on a format version
                _template, _cl_block_len = None, -1
                if 52 == len(chunk[_foff:]):
                    _template = "13I"
                elif 24 == len(chunk[_foff:]):
                    _template = "6I"
                    _cl_block_len = 1
                else:
                    raise ValueError("unexpected netclass block length")

                _dta = struct.unpack(_template, chunk[_foff:])
                if "13I" == _template:
                    _cl_block_len = 1 + _dta[0]

                if (Eagle.NetClass.constantmid == _dta[1] and
                        Eagle.NetClass.constantend == _dta[-1]):
                    if 0 < len(_name): # used netclass
                        _ret_val = Eagle.NetClass(
                                 num=_dta[0],
                                 name=_name,
                                 width=Eagle.NetClass.decode_real(_dta[2]),
                                 drill=Eagle.NetClass.decode_real(_dta[3]),
                                 clearances = [
                                     (_nn,
                                      Eagle.NetClass.decode_real(
                                                                _dta[4 + _nn])
                                     )
                                     for _nn in range(_cl_block_len)
                                     if 0 != _dta[4 + _nn]
                                 ],
                                 leadint=leadint
                                                    )
                    else: # unused netclass
                        _ret_val = Eagle.NetClass(num=_dta[0],
                                                     leadint=leadint)
                else:
                    pass # bad constants or/and data in netclasses
            elif Eagle.NetClass.constantend == ncconst and None == chunk:
                pass # nothing to do: final entry ; never hit though
            else:
                pass # bad constants or/and data in netclasses
            return _ret_val

    blocksize = 24
    noregblockconst = b'\x13\x12\x99\x19'
    noregdelimeter = r'\0'

    def __init__(self):
        """ Basic initilaization
        """
        self.header = None
        self.layers = []
        self.settings = []
        self.grid = None
        self.attributeheader = None
        self.attributes = []
        self.libraries = []
        self.shapeheader = None
#        self.parts = []
        self.texts = []
        self.netclasses = []

        self.noname_counter = self.noname_def_counter
        return


    @staticmethod
    def auto_detect(filename):
        """ Return our confidence that the given file is an eagle schematic """
        with open(filename, 'r') as f:
            data = f.read(4096)
        confidence = 0
        if ('\x10' == data[0x00] and '\x11' == data[0x18] and
                '\x11' == data[0x30] and '\x12' == data[0x48]):
            confidence += 0.9
        return confidence


    def _parse_blocks(self, filehandle, numofblocks): # pylint: disable=R0912
        """ Parse fixed length block part of a file
        """
# to keep parsing position
        _cur_lib = None
        _cur_web = None # consists of one or more shapesets/segments
        _cur_segment = None # consists of one or more shapes
        _prev_segment = None # for polygons only
        _cur_connset = None # consists of one or more shapes (deviceset shows two types)

# loop through 24 byte long blocks
        for _nn in range(numofblocks):
            _dta = filehandle.read(self.blocksize)

#            print"d>",' '.join([x.encode('hex') for x in _dta])

            _type = struct.unpack("24B", _dta)[0]
            if Eagle.Settings.constant == _type:
                self.settings.append(self.Settings.parse(_dta))
            elif Eagle.Grid.constant == _type:
                self.grid = self.Grid.parse(_dta)
            elif Eagle.Layer.constant == _type:
                self.layers.append(self.Layer.parse(_dta))
            elif Eagle.AttributeHeader.constant == _type:
                self.attributeheader = self.AttributeHeader.parse(_dta)
            elif Eagle.Library.constant == _type:
                _cur_lib = self.Library.parse(_dta)
                self.libraries.append(_cur_lib)
            elif Eagle.DeviceSetHeader.constant == _type:
                _cur_web = self.DeviceSetHeader.parse(_dta)
                _cur_lib.devsets.append(_cur_web)
            elif Eagle.SymbolHeader.constant == _type:
                _cur_web = self.SymbolHeader.parse(_dta)
                _cur_lib.symbols.append(_cur_web)
            elif Eagle.PackageHeader.constant == _type:
                _cur_web = self.PackageHeader.parse(_dta)
                _cur_lib.packages.append(_cur_web)
            elif Eagle.Symbol.constant == _type:
                _cur_segment = self.Symbol.parse(_dta)
                _cur_web.shapesets.append(_cur_segment)
                _prev_segment = None
            elif Eagle.Package.constant == _type:
                _cur_segment = self.Package.parse(_dta)
                _cur_web.shapesets.append(_cur_segment)
                _prev_segment = None
            elif Eagle.ShapeHeader.constant == _type:
                self.shapeheader = self.ShapeHeader.parse(_dta)
                _cur_segment = self.shapeheader
            elif Eagle.Bus.constant == _type:
                _cur_web = self.Bus.parse(_dta)
                self.shapeheader.buses.append(_cur_web)
            elif Eagle.Net.constant == _type:
                _cur_web = self.Net.parse(_dta)
                self.shapeheader.nets.append(_cur_web)
            elif Eagle.Segment.constant == _type:
                _cur_segment = self.Segment.parse(_dta)
                _cur_web.shapes.append(_cur_segment)
                _prev_segment = None
            elif Eagle.DeviceSet.constant == _type:
                _cur_segment = self.DeviceSet.parse(_dta)
                _cur_web.shapesets.append(_cur_segment)
                _prev_segment = None
            elif Eagle.ConnectionHeader.constant == _type:
                _cur_connset = self.ConnectionHeader.parse(_dta)
                _cur_segment.connblocks.append(_cur_connset)
                _prev_segment = None
            elif Eagle.Part.constant == _type:
                _cur_web = self.Part.parse(_dta)
                self.shapeheader.parts.append(_cur_web)
            elif Eagle.Polygon.constant == _type:
                if None == _prev_segment: # next polygon in the same segment
                    _prev_segment = _cur_segment
                _cur_segment = self.Polygon.parse(_dta)
                _prev_segment.shapes.append(_cur_segment)
            elif Eagle.Instance.constant == _type:
                _cur_segment = self.Instance.parse(_dta)
                _cur_web.shapes.append(_cur_segment)
                _prev_segment = None
            elif Eagle.Connections.constant == _type:
                _cur_connset.shapes.append(self.Connections.parse(_dta))
            elif Eagle.Gate.constant == _type:
                _cur_segment.shapes.append(self.Gate.parse(_dta))
            elif Eagle.Circle.constant == _type:
                _cur_segment.shapes.append(self.Circle.parse(_dta))
            elif Eagle.Rectangle.constant == _type:
                _cur_segment.shapes.append(self.Rectangle.parse(_dta))
            elif Eagle.Wire.constant == _type:
                _cur_segment.shapes.append(self.Wire.parse(_dta))
            elif Eagle.Hole.constant == _type:
                _cur_segment.shapes.append(self.Hole.parse(_dta))
            elif Eagle.SMD.constant == _type:
                _cur_segment.shapes.append(self.SMD.parse(_dta))
            elif Eagle.PinRef.constant == _type:
                _cur_segment.shapes.append(self.PinRef.parse(_dta))
            elif Eagle.Junction.constant == _type:
                _cur_segment.shapes.append(self.Junction.parse(_dta))
            elif Eagle.Pad.constant == _type:
                _cur_segment.shapes.append(self.Pad.parse(_dta))
            elif Eagle.Pin.constant == _type:
                _cur_segment.shapes.append(self.Pin.parse(_dta))
            elif Eagle.Label.constant == _type:
                _cur_segment.shapes.append(self.Label.parse(_dta))
            elif Eagle.AttributeNam.constant == _type:
                _cur_segment.shapes.append(self.AttributeNam.parse(_dta))
            elif Eagle.AttributeVal.constant == _type:
                _cur_segment.shapes.append(self.AttributeVal.parse(_dta))
            elif Eagle.AttributePrt.constant == _type:
                _cur_segment.shapes.append(self.AttributePrt.parse(_dta))
            elif Eagle.Text.constant == _type:
                _cur_segment.shapes.append(self.Text.parse(_dta))
            elif Eagle.Frame.constant == _type:
                _cur_segment.shapes.append(self.Frame.parse(_dta))
            elif Eagle.Attribute.constant == _type:
                self.attributes.append(self.Attribute.parse(_dta))
            else:
# TODO remove
                print("unknown block tag %s" % hex(_type))

        return

    def _parse_netclasses(self, filehandle):
        """ Parse netclasses part (fixed part + length + data part)
        """

        while True: # netclasses ## 0..7
            (_some_int, _ncconst, _nclen) = struct.unpack(
                    self.NetClass.template0,
                    filehandle.read(struct.calcsize(self.NetClass.template0)))
            _ncdta = None
            if 0 < _nclen:
                _ncdta = filehandle.read(_nclen)
            else:
                break # should leadnum of a final 3I block be saved?..
            self.netclasses.append(self.NetClass.parse(_some_int,
                                                       _ncconst, _ncdta))
        return

    noname_def_counter = 10000
    noname_def_prefix = 'EagleINR/'

    def get_unique_string(self):
        """ Gives a name when it's required; 
            not a random one to get the same schematic on subsequent runs
        """
        _ret_val = '%s%d' % (self.noname_def_prefix, self.noname_counter)
        self.noname_counter += 1
        return _ret_val

    attr_jar = [] # attribute list

    @classmethod
    def attr_jar_iter(cls):
        """ Returns next attribute on each call
        """
        for _aa in cls.attr_jar:
            yield _aa

    def _parse(self, filehandle):
        """ Parse an Eagle file into a set of Eagle objects
        """
# headers (constant block size driven)
        self.header = self.Header.parse(filehandle.read(self.blocksize))

# parsing of external attributes beforehand helps its placing
        filehandle.seek(self.header.numofblocks * self.blocksize)
        filehandle.read(4) # noregblockheader
        _unreg_dta = filehandle.read(struct.unpack("I",
                        filehandle.read(4))[0]).split(self.noregdelimeter)
        filehandle.seek(1 * self.blocksize)
        for _aa in _unreg_dta:
            if 0 < len(_aa):
                Eagle.attr_jar.append(Eagle.Attribute.parse2(_aa))
        Eagle.attr_jar_list = Eagle.attr_jar_iter()

        self._parse_blocks(filehandle, -1 + self.header.numofblocks)

# desc (length driven)
        filehandle.read(4) # noregblockheader
## TODO remove
#        if Eagle.noregblockconst != _noregblockheader:
#            print("bad constant follows headers!")

        # read len in bytes, then read corrsponding number of bytes
        #  -- just to skip since external attributes were parsed earlier
        _unreg_dta = filehandle.read(struct.unpack("I",
                            filehandle.read(4))[0]).split(self.noregdelimeter)

# just to note: the list above ends with two zero bytes

        self._parse_netclasses(filehandle)
        return

    @staticmethod
    def _convert_arc(sarc):
        """ Converts a Eagle's Arc / FixedArc objects into Arc
        """
        _ret_val = None

# calculate radius
        _xm, _ym = (sarc.x1 + sarc.x2) / 2, (sarc.y1 + sarc.y2) / 2
        _dm = math.sqrt(math.pow(sarc.x1 - _xm, 2) +
                math.pow(sarc.y1 -_ym, 2))
        _radius = abs(_dm / math.sin(math.radians(sarc.curve / 2)))

# calculate start and end angles, beginning
        _xu = sarc.x1 if sarc.y1 > sarc.y2 else sarc.x2 # upper point's x
        _am = (math.pi / 2 - math.acos((_xm - _xu) / _dm) + # middle
                0 if True else (math.pi / 2))
        if 0 > _am:
            _am += math.pi

# calculate center
        (_x1, _y1, _x2, _y2) = ((sarc.x1, sarc.y1, sarc.x2, sarc.y2)
                                    if 'counterclockwise' == sarc.direction else
                                    (sarc.x2, sarc.y2, sarc.x1, sarc.y1))
        _mm = _radius * math.cos(math.radians(abs(sarc.curve / 2)))
        _xcc, _ycc = (abs(abs(_y1) - abs(_ym)) * abs(_mm / _dm),
                        abs(abs(_x1) - abs(_xm)) * abs(_mm / _dm)) # x <-> y, for an orthogonal vector

        _xc, _yc = -1., -1.
        if _x1 >= _xm and _y1 <= _ym: # different operations for an each quadrant
            _xc, _yc = _xm - _xcc, _ym - _ycc
        elif _x1 >= _xm and _y1 >= _ym:
            _xc, _yc = _xm + _xcc, _ym - _ycc
        elif _x1 <= _xm and _y1 >= _ym:
            _xc, _yc = _xm + _xcc, _ym + _ycc
        elif _x1 <= _xm and _y1 <= _ym:
            _xc, _yc = _xm - _xcc, _ym + _ycc

# calculate start and end angles, end
        if _x1 <= _xm: # 3rd and 4th quadrants
            _am += math.pi
        _astart = _am - math.radians(abs(sarc.curve / 2))
        _aend = _astart + math.radians(abs(sarc.curve))

        _ret_val = Arc(x=_xc, y=_yc,
                    start_angle=(_astart / math.pi),
                    end_angle=(_aend / math.pi),
                    radius=_radius,
                    )
        return _ret_val

    def _convert(self):
        """ Converts a set of Eagle objects into Design
        """
        design = Design()

# File Version is applied by Design itself

# Component Instances (Array) / Components (Array)
        value_names = []
        for _pp in self.shapeheader.parts:
            _libid = ':'.join((self.libraries[-1 + _pp.libid].name,
                               _pp.value if _pp.value not in value_names else 
                                   self.get_unique_string())) # to avoid same name collisions
            value_names.append(_pp.value)
            _ci = ComponentInstance(instance_id=_pp.name,
                                    library_component=None, # FIXME(shamer): where is the actual library component?
                                    library_id=_libid,
                                    symbol_index=0)    # There appears to only have the possibility
                                                                # 1 symbol per component, so I will
                                                                # hardcode this to 0 while
                                                                # figuring out how to make get the
                                                                # correct component symbol index
                                    #symbol_index=_pp.symvar)    # other candidate is devsetndx:
                                                                #  'devsets' contains all variants
                                                                #  used in this schematic
            _sa = SymbolAttribute(x=_pp.shapes[0].x, # shapes' len is always 1 here
                                  y=_pp.shapes[0].y,
                                  rotation=Eagle.Shape.rotate2piradians(
                                        _pp.shapes[0].rotate),
                                  flip=False
                                 )

            _dd = self.libraries[-1 + _pp.libid].devsets[0].shapesets[-1 + _pp.devsetndx]
            _sym = self.libraries[-1 + _pp.libid].symbols[0].shapesets[
                                                    -1 + _dd.shapes[0].sindex]

            if 0 != len(_dd.connblocks[0].technologies):
                _ci.add_attribute("technology",
                        _dd.connblocks[0].technologies[-1 + _pp.techno])

            _co = None
            if not _libid in design.components.components:
                _co = Component(_sym.name)
                _sy = Symbol()
                _bd = SBody()
                _pc = 1 # Eagle counts from 1

                if 0 != len(_dd.connblocks[0].attributes):
                    for _aa in _dd.connblocks[0].attributes:
                        _co.add_attribute(_aa[0], _aa[1])
                _co.add_attribute("prefix", _dd.prefix)
                _co.add_attribute("description", _dd.description)

            for _ss in _sym.shapes:
                if isinstance(_ss, Eagle.Text):
                    _val = 'undef'
                    if r'>NAME' == _ss.value:
                        _val = _pp.name
                    elif r'>VALUE' == _ss.value:
                        _val = _pp.value
                    _an = Annotation(value=_val, # value from symbol
                                     x=(_ss.x),
                                     y=(_ss.y),
                                     rotation=((
                                         Eagle.Shape.rotate2piradians(
                                                    _pp.shapes[0].rotate) +
                                         Eagle.Shape.rotate2piradians(
                                                    _ss.rotate)) % 2),
                                     visible='true',
                                    )
                    _sa.add_annotation(_an)
                else:
                    if None != _co:
                        if isinstance(_ss, Eagle.Pin):

                            _opx, _lx = _ss.x, _ss.x
                            _opy, _ly = _ss.y, _ss.y
                            _lrot = 0.
                            if None == _ss.rotate: # left
                                _opx += 20/EAGLE_SCALE
                                _lx = (_ss.x + _opx) / 2
                                _ly += 20/EAGLE_SCALE
                            elif "R90" == _ss.rotate: # down
                                _opy += 20/EAGLE_SCALE
                                _lx += 20/EAGLE_SCALE
                                _ly = (_ss.y + _opy) / 2
                                #_lrot = 0.5 or 1.5 if label rotation is required
                            elif "R180" == _ss.rotate: # right
                                _opx -= 20/EAGLE_SCALE
                                _lx = (_ss.x + _opx) / 2
                                _ly += 20/EAGLE_SCALE
                            elif "R270" == _ss.rotate: # up
                                _opy -= 20/EAGLE_SCALE
                                _lx += 20/EAGLE_SCALE
                                _ly = (_ss.y + _opy) / 2
                                #_lrot = 0.5 or 1.5 if label rotation is required

                            _label = Label (x=_lx, y=_ly,
                                            text=_ss.name,
                                            align='center', rotation=_lrot)
                            _pn = Pin(label=_label,
                                      p1=Point(_opx, _opy), # just 10pix in an opposite direction
                                      p2=Point(_ss.x, _ss.y),
                                      pin_number=_pc)

                            _pn.add_attribute('visible', _ss.visible)
                            _pn.add_attribute('direction', _ss.direction) # signal direction
                            _pn.add_attribute('length', _ss.length) # not a number
                            _pn.add_attribute('function', _ss.function)
                            _pn.add_attribute('swaplevel', _ss.swaplevel)

                            _bd.add_pin(_pn)
                            _pc += 1
                        else:
                            _sp = None
                            if isinstance(_ss, Eagle.FixedArc): # including Arc
                                _sp = Eagle._convert_arc(_ss)
                                _sp.add_attribute('style', _ss.style)
                                _sp.add_attribute('width', _ss.width)
                            elif isinstance(_ss, Eagle.Wire):
                                _sp = Line(p1=Point(_ss.x1, _ss.y1),
                                           p2=Point(_ss.x2, _ss.y2))
                                _sp.add_attribute('style', _ss.style)
                                _sp.add_attribute('width', _ss.width)
                            elif isinstance(_ss, Eagle.Circle):
                                _sp = Circle(x=_ss.x, y=_ss.y, 
                                                radius=_ss.radius)
                                _sp.add_attribute('width', _ss.width)
                            elif isinstance(_ss, Eagle.Rectangle):
                                _width = abs(_ss.x2 - _ss.x1)
                                _height = abs(_ss.y2 - _ss.y1)
                                if None == _ss.rotate or "R180" == _ss.rotate: # normal position
                                    _x = _ss.x1
                                    _y = _ss.y1 + _height # bottom left vs upper left
                                elif "R90" == _ss.rotate or "R270" == _ss.rotate: # pi/2 rotation
                                    _width, _height = _height, _width
                                    _x = (_ss.x1 + _ss.x2 - _width) / 2 
                                    _y = (_ss.y1 + _ss.y2 + _height) / 2
                                _sp = Rectangle(x=_x, y=_y, width=_width, height=_height)
                            elif isinstance(_ss, Eagle.Polygon):
# second point for an every Eagle.Wire can be skipped since it'll be the first one
#  for the next Wire
# some Eagle.Wires are actually Eagle.FixedArcs, but processed as Wires, i.e. with no
#  curve
# also it can include Eagle.Text. It's just skipped
                                _pts = [Point(s.x1, s.y1) for s in _ss.shapes
                                        if isinstance(_ss, Eagle.Wire)]
                                _sp = Polygon(points=_pts)
                            elif isinstance(_ss, Eagle.Frame):
                                pass # a kind of a box around a schematic
                            else:
# TODO remove
                                print("unexpected block %s in shapeset" % _ss.__class__.__name__)

                            if None != _sp: # i.e. label (!= text), hole, ..
                                _sp.add_attribute('layer', _ss.layer)
                                _bd.add_shape(_sp)

            _ci.add_symbol_attribute(_sa)
            design.add_component_instance(_ci)
            if None != _co:
                _sy.add_body(_bd)
                _co.add_symbol(_sy)
                design.add_component(_libid, _co)

# Nets (Array)
        for _bb in self.shapeheader.buses + self.shapeheader.nets:
            for _nn, _sg in enumerate(_bb.shapes): # segments, they don't share any common points
                _net = Net('%s-%d' % (_bb.name, _nn))
                if isinstance(_bb, Eagle.Bus):
                    _net.add_attribute(u'type', u'bus')
                else: # Net
                    _net.add_attribute(u'type', u'net')
                    _net.add_attribute(u'netclass', _bb.nclass)

                    _nc = self.netclasses[_bb.nclass] # yes, info will be duplicated
                    _net.add_attribute(u'netname', _nc.name)
                    _net.add_attribute(u'netwidth', _nc.width)
                    _net.add_attribute(u'netdrill', _nc.drill)
                    for _cc in _nc.clearances:
                        _net.add_attribute(u'netclearance' + str(_cc[0]), _cc[1])
                for _ss in _sg.shapes: # wires only for buses, wires + pinrefs + junctions for nets
                    if isinstance(_ss, Eagle.FixedArc): # including Eagle.Arc
                        Eagle._convert_arc(_ss)

# now it's the same as wire, but probably some interpolation is required
                        _p1name = "%s-%s" % (str(_ss.x1), str(_ss.y1))
                        _p2name = "%s-%s" % (str(_ss.x2), str(_ss.y2))

                        if not _p1name in _net.points:
                            _net.add_point(NetPoint(_p1name, _ss.x1, _ss.y1))
                        if not _p2name in _net.points:
                            _net.add_point(NetPoint(_p2name, _ss.x2, _ss.y2))

                        if not _p2name in _net.points[_p1name].connected_points:
                            _net.points[_p1name].add_connected_point(_p2name)
                        if not _p1name in _net.points[_p2name].connected_points:
                            _net.points[_p2name].add_connected_point(_p1name)
                    elif isinstance(_ss, Eagle.Wire):
                        _p1name = "%s-%s" % (str(_ss.x1), str(_ss.y1))
                        _p2name = "%s-%s" % (str(_ss.x2), str(_ss.y2))

                        if not _p1name in _net.points:
                            _net.add_point(NetPoint(_p1name, _ss.x1, _ss.y1))
                        if not _p2name in _net.points:
                            _net.add_point(NetPoint(_p2name, _ss.x2, _ss.y2))

                        if not _p2name in _net.points[_p1name].connected_points:
                            _net.points[_p1name].add_connected_point(_p2name)
                        if not _p1name in _net.points[_p2name].connected_points:
                            _net.points[_p2name].add_connected_point(_p1name)
                    elif isinstance(_ss, Eagle.PinRef):
                        _prt = self.shapeheader.parts[-1 + _ss.partno]
                        _dst = self.libraries[-1 + _prt.libid].devsets[0
                                    ].shapesets[-1 + _prt.devsetndx]
                        _sym = self.libraries[-1 + _prt.libid].symbols[0
                                    ].shapesets[-1 + _dst.shapes[0].sindex]
                        _prno = 1
                        for _yy in _sym.shapes:
                            if isinstance(_yy, Eagle.Pin):
                                if _ss.pinno == _prno:
                                    _pname = "%s-%s" % (str(_prt.shapes[0].x + _yy.x),
                                                str(_prt.shapes[0].y + _yy.y))
                                    if not _pname in _net.points:
                                        _net.add_point(NetPoint(_pname,
                                                        _prt.shapes[0].x + _yy.x,
                                                        _prt.shapes[0].y + _yy.y))
                                    _net.points[_pname].add_connected_component(
                                            ConnectedComponent(_prt.name, _ss.pinno))
                                _prno += 1
                    elif isinstance(_ss, Eagle.Junction):
                        pass # has to be skipped: junction points are implemented as
                             #  connected_points arrays in OJSON
                    elif isinstance(_ss, Eagle.Label):
                        pass # has to be skipped: no use here
                    else:
# TODO remove
                        print("unexpected block %s in bus/net" % _ss.__class__.__name__)
                design.add_net(_net)

# Components (Array) -- above
#        for _ll in self.libraries:
#            for _ss in _ll.symbols[0].shapesets:
#                _co = Component(_ss.name)
#                pass
#                design.add_component(str(_ss.libid) + 'xx', _co)


        return design

    def parse(self, filename):
        """ Parse an Eagle file into a design """
        design = None

        with open(filename, 'rb') as _if:
            self._parse(_if)

        design = self._convert()
        design.scale(EAGLE_SCALE)

        return design



########NEW FILE########
__FILENAME__ = generated_g
#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Sat Jun  2 21:19:53 2012 by generateDS.py version 2.7b.
#

import sys
import re as re_

etree = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    import lxml.etree
    etree = lxml.etree
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree
        etree = xml.etree.cElementTree
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree
            etree = xml.etree.ElementTree
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree
                etree = cElementTree
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree
                    etree = elementtree.ElementTree
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree.ETCompatXMLParser()
    doc = etree.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    import generatedssuper
    GeneratedsSuper = generatedssuper.Generatedssuper
except ImportError:
    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    string1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    string1 = string1.replace('&', '&amp;')
    string1 = string1.replace('<', '&lt;')
    string1 = string1.replace('>', '&gt;')
    return string1

def quote_attrib(inStr):
    string1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    string1 = string1.replace('&', '&amp;')
    string1 = string1.replace('<', '&lt;')
    string1 = string1.replace('>', '&gt;')
    if '"' in string1:
        if "'" in string1:
            string1 = '"%s"' % string1.replace('"', "&quot;")
        else:
            string1 = "'%s'" % string1
    else:
        string1 = '"%s"' % string1
    return string1

def quote_python(inStr):
    string1 = inStr
    if string1.find("'") == -1:
        if string1.find('\n') == -1:
            return "'%s'" % string1
        else:
            return "'''%s'''" % string1
    else:
        if string1.find('"') != -1:
            string1 = string1.replace('"', '\\"')
        if string1.find('\n') == -1:
            return '"%s"' % string1
        else:
            return '"""%s"""' % string1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name)
    def exportSimple(self, outfile, level):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name):
        self.name = name
    def get_name(self):
        return self.name
    def set_data_type(self, data_type):
        self.data_type = data_type
    def get_data_type_chain(self):
        return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container):
        self.container = container
    def get_container(self):
        return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class eagle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, compatibility=None, drawing=None):
        self.version = _cast(None, version)
        self.compatibility = compatibility
        self.drawing = drawing
    def factory(*args_, **kwargs_):
        if eagle.subclass:
            return eagle.subclass(*args_, **kwargs_)
        else:
            return eagle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_compatibility(self):
        return self.compatibility
    def set_compatibility(self, compatibility):
        self.compatibility = compatibility
    def get_drawing(self):
        return self.drawing
    def set_drawing(self, drawing):
        self.drawing = drawing
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def export(self, outfile, level, namespace_='t:', name_='eagle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eagle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='eagle'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), 
                input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='eagle', fromsubclass_=False):
        if self.compatibility is not None:
            self.compatibility.export(outfile, level, namespace_, name_='compatibility')
        if self.drawing is not None:
            self.drawing.export(outfile, level, namespace_, name_='drawing', )
    def hasContent_(self):
        if (
            self.compatibility is not None or
            self.drawing is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='eagle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.compatibility is not None:
            showIndent(outfile, level)
            outfile.write('compatibility=model_.compatibility(\n')
            self.compatibility.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.drawing is not None:
            showIndent(outfile, level)
            outfile.write('drawing=model_.drawing(\n')
            self.drawing.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'compatibility':
            obj_ = compatibility.factory()
            obj_.build(child_)
            self.set_compatibility(obj_)
        elif nodeName_ == 'drawing':
            obj_ = drawing.factory()
            obj_.build(child_)
            self.set_drawing(obj_)
# end class eagle


class compatibility(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, note=None):
        if note is None:
            self.note = []
        else:
            self.note = note
    def factory(*args_, **kwargs_):
        if compatibility.subclass:
            return compatibility.subclass(*args_, **kwargs_)
        else:
            return compatibility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_note(self):
        return self.note
    def set_note(self, note):
        self.note = note
    def add_note(self, value):
        self.note.append(value)
    def insert_note(self, index, value):
        self.note[index] = value
    def export(self, outfile, level, namespace_='t:', name_='compatibility', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='compatibility')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='compatibility'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='compatibility', fromsubclass_=False):
        for note_ in self.note:
            note_.export(outfile, level, namespace_, name_='note')
    def hasContent_(self):
        if (
            self.note
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='compatibility'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('model_.note(\n')
            note_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'note':
            obj_ = note.factory()
            obj_.build(child_)
            self.note.append(obj_)
# end class compatibility


class note(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, severity=None, valueOf_=None, mixedclass_=None, content_=None):
        self.version = _cast(None, version)
        self.severity = _cast(None, severity)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if note.subclass:
            return note.subclass(*args_, **kwargs_)
        else:
            return note(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_severity(self):
        return self.severity
    def set_severity(self, severity):
        self.severity = severity
    def get_valueOf_(self):
        return self.valueOf_
    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='t:', name_='note', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='note')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='note'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' 
                % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding),
                    input_name='version'), ))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            outfile.write(' severity=%s' 
                % (self.gds_format_string(quote_attrib(self.severity).encode(ExternalEncoding),
                    input_name='severity'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='note', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='note'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            showIndent(outfile, level)
            outfile.write('severity = "%s",\n' % (self.severity,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            self.severity = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class note


class drawing(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, settings=None, grid=None, layers=None, library=None, schematic=None, board=None):
        self.settings = settings
        self.grid = grid
        self.layers = layers
        self.library = library
        self.schematic = schematic
        self.board = board
    def factory(*args_, **kwargs_):
        if drawing.subclass:
            return drawing.subclass(*args_, **kwargs_)
        else:
            return drawing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settings(self):
        return self.settings
    def set_settings(self, settings):
        self.settings = settings
    def get_grid(self):
        return self.grid
    def set_grid(self, grid):
        self.grid = grid
    def get_layers(self):
        return self.layers
    def set_layers(self, layers):
        self.layers = layers
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_schematic(self):
        return self.schematic
    def set_schematic(self, schematic):
        self.schematic = schematic
    def get_board(self):
        return self.board
    def set_board(self, board):
        self.board = board
    def export(self, outfile, level, namespace_='t:', name_='drawing', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drawing')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='drawing'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='drawing', fromsubclass_=False):
        if self.settings is not None:
            self.settings.export(outfile, level, namespace_, name_='settings')
        if self.grid is not None:
            self.grid.export(outfile, level, namespace_, name_='grid')
        if self.layers is not None:
            self.layers.export(outfile, level, namespace_, name_='layers', )
        if self.library is not None:
            self.library.export(outfile, level, namespace_, name_='library', )
        if self.schematic is not None:
            self.schematic.export(outfile, level, namespace_, name_='schematic', )
        if self.board is not None:
            self.board.export(outfile, level, namespace_, name_='board', )
    def hasContent_(self):
        if (
            self.settings is not None or
            self.grid is not None or
            self.layers is not None or
            self.library is not None or
            self.schematic is not None or
            self.board is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='drawing'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.settings is not None:
            showIndent(outfile, level)
            outfile.write('settings=model_.settings(\n')
            self.settings.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.grid is not None:
            showIndent(outfile, level)
            outfile.write('grid=model_.grid(\n')
            self.grid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.layers is not None:
            showIndent(outfile, level)
            outfile.write('layers=model_.layers(\n')
            self.layers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.library is not None:
            showIndent(outfile, level)
            outfile.write('library=model_.library(\n')
            self.library.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.schematic is not None:
            showIndent(outfile, level)
            outfile.write('schematic=model_.schematic(\n')
            self.schematic.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.board is not None:
            showIndent(outfile, level)
            outfile.write('board=model_.board(\n')
            self.board.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settings':
            obj_ = settings.factory()
            obj_.build(child_)
            self.set_settings(obj_)
        elif nodeName_ == 'grid':
            obj_ = grid.factory()
            obj_.build(child_)
            self.set_grid(obj_)
        elif nodeName_ == 'layers':
            obj_ = layers.factory()
            obj_.build(child_)
            self.set_layers(obj_)
        elif nodeName_ == 'library':
            obj_ = library.factory()
            obj_.build(child_)
            self.set_library(obj_)
        elif nodeName_ == 'schematic':
            obj_ = schematic.factory()
            obj_.build(child_)
            self.set_schematic(obj_)
        elif nodeName_ == 'board':
            obj_ = board.factory()
            obj_.build(child_)
            self.set_board(obj_)
# end class drawing


class library(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None, packages=None, symbols=None, devicesets=None):
        self.name = _cast(None, name)
        self.description = description
        self.packages = packages
        self.symbols = symbols
        self.devicesets = devicesets
    def factory(*args_, **kwargs_):
        if library.subclass:
            return library.subclass(*args_, **kwargs_)
        else:
            return library(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_packages(self):
        return self.packages
    def set_packages(self, packages):
        self.packages = packages
    def get_symbols(self):
        return self.symbols
    def set_symbols(self, symbols):
        self.symbols = symbols
    def get_devicesets(self):
        return self.devicesets
    def set_devicesets(self, devicesets):
        self.devicesets = devicesets
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def export(self, outfile, level, namespace_='t:', name_='library', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='library')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='library'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='library', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.packages is not None:
            self.packages.export(outfile, level, namespace_, name_='packages')
        if self.symbols is not None:
            self.symbols.export(outfile, level, namespace_, name_='symbols')
        if self.devicesets is not None:
            self.devicesets.export(outfile, level, namespace_, name_='devicesets')
    def hasContent_(self):
        if (
            self.description is not None or
            self.packages is not None or
            self.symbols is not None or
            self.devicesets is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='library'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.packages is not None:
            showIndent(outfile, level)
            outfile.write('packages=model_.packages(\n')
            self.packages.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.symbols is not None:
            showIndent(outfile, level)
            outfile.write('symbols=model_.symbols(\n')
            self.symbols.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.devicesets is not None:
            showIndent(outfile, level)
            outfile.write('devicesets=model_.devicesets(\n')
            self.devicesets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'packages':
            obj_ = packages.factory()
            obj_.build(child_)
            self.set_packages(obj_)
        elif nodeName_ == 'symbols':
            obj_ = symbols.factory()
            obj_.build(child_)
            self.set_symbols(obj_)
        elif nodeName_ == 'devicesets':
            obj_ = devicesets.factory()
            obj_.build(child_)
            self.set_devicesets(obj_)
# end class library


class schematic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, xrefpart=None, xreflabel=None, description=None, libraries=None, attributes=None, variantdefs=None, classes=None, parts=None, sheets=None, errors=None):
        self.xrefpart = _cast(None, xrefpart)
        self.xreflabel = _cast(None, xreflabel)
        self.description = description
        self.libraries = libraries
        self.attributes = attributes
        self.variantdefs = variantdefs
        self.classes = classes
        self.parts = parts
        self.sheets = sheets
        self.errors = errors
    def factory(*args_, **kwargs_):
        if schematic.subclass:
            return schematic.subclass(*args_, **kwargs_)
        else:
            return schematic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_libraries(self):
        return self.libraries
    def set_libraries(self, libraries):
        self.libraries = libraries
    def get_attributes(self):
        return self.attributes
    def set_attributes(self, attributes):
        self.attributes = attributes
    def get_variantdefs(self):
        return self.variantdefs
    def set_variantdefs(self, variantdefs):
        self.variantdefs = variantdefs
    def get_classes(self):
        return self.classes
    def set_classes(self, classes):
        self.classes = classes
    def get_parts(self):
        return self.parts
    def set_parts(self, parts):
        self.parts = parts
    def get_sheets(self):
        return self.sheets
    def set_sheets(self, sheets):
        self.sheets = sheets
    def get_errors(self):
        return self.errors
    def set_errors(self, errors):
        self.errors = errors
    def get_xrefpart(self):
        return self.xrefpart
    def set_xrefpart(self, xrefpart):
        self.xrefpart = xrefpart
    def get_xreflabel(self):
        return self.xreflabel
    def set_xreflabel(self, xreflabel):
        self.xreflabel = xreflabel
    def export(self, outfile, level, namespace_='t:', name_='schematic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='schematic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='schematic'):
        if self.xrefpart is not None and 'xrefpart' not in already_processed:
            already_processed.append('xrefpart')
            outfile.write(' xrefpart=%s' 
                % (self.gds_format_string(quote_attrib(self.xrefpart).encode(ExternalEncoding),
                    input_name='xrefpart'), ))
        if self.xreflabel is not None and 'xreflabel' not in already_processed:
            already_processed.append('xreflabel')
            outfile.write(' xreflabel=%s' 
                % (self.gds_format_string(quote_attrib(self.xreflabel).encode(ExternalEncoding),
                    input_name='xreflabel'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='schematic', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.libraries is not None:
            self.libraries.export(outfile, level, namespace_, name_='libraries')
        if self.attributes is not None:
            self.attributes.export(outfile, level, namespace_, name_='attributes')
        if self.variantdefs is not None:
            self.variantdefs.export(outfile, level, namespace_, name_='variantdefs')
        if self.classes is not None:
            self.classes.export(outfile, level, namespace_, name_='classes')
        if self.parts is not None:
            self.parts.export(outfile, level, namespace_, name_='parts')
        if self.sheets is not None:
            self.sheets.export(outfile, level, namespace_, name_='sheets')
        if self.errors is not None:
            self.errors.export(outfile, level, namespace_, name_='errors')
    def hasContent_(self):
        if (
            self.description is not None or
            self.libraries is not None or
            self.attributes is not None or
            self.variantdefs is not None or
            self.classes is not None or
            self.parts is not None or
            self.sheets is not None or
            self.errors is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='schematic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.xrefpart is not None and 'xrefpart' not in already_processed:
            already_processed.append('xrefpart')
            showIndent(outfile, level)
            outfile.write('xrefpart = "%s",\n' % (self.xrefpart,))
        if self.xreflabel is not None and 'xreflabel' not in already_processed:
            already_processed.append('xreflabel')
            showIndent(outfile, level)
            outfile.write('xreflabel = "%s",\n' % (self.xreflabel,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.libraries is not None:
            showIndent(outfile, level)
            outfile.write('libraries=model_.libraries(\n')
            self.libraries.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.attributes is not None:
            showIndent(outfile, level)
            outfile.write('attributes=model_.attributes(\n')
            self.attributes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variantdefs is not None:
            showIndent(outfile, level)
            outfile.write('variantdefs=model_.variantdefs(\n')
            self.variantdefs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.classes is not None:
            showIndent(outfile, level)
            outfile.write('classes=model_.classes(\n')
            self.classes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.parts is not None:
            showIndent(outfile, level)
            outfile.write('parts=model_.parts(\n')
            self.parts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sheets is not None:
            showIndent(outfile, level)
            outfile.write('sheets=model_.sheets(\n')
            self.sheets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.errors is not None:
            showIndent(outfile, level)
            outfile.write('errors=model_.errors(\n')
            self.errors.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xrefpart', node)
        if value is not None and 'xrefpart' not in already_processed:
            already_processed.append('xrefpart')
            self.xrefpart = value
        value = find_attr_value_('xreflabel', node)
        if value is not None and 'xreflabel' not in already_processed:
            already_processed.append('xreflabel')
            self.xreflabel = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'libraries':
            obj_ = libraries.factory()
            obj_.build(child_)
            self.set_libraries(obj_)
        elif nodeName_ == 'attributes':
            obj_ = attributes.factory()
            obj_.build(child_)
            self.set_attributes(obj_)
        elif nodeName_ == 'variantdefs':
            obj_ = variantdefs.factory()
            obj_.build(child_)
            self.set_variantdefs(obj_)
        elif nodeName_ == 'classes':
            obj_ = classes.factory()
            obj_.build(child_)
            self.set_classes(obj_)
        elif nodeName_ == 'parts':
            obj_ = parts.factory()
            obj_.build(child_)
            self.set_parts(obj_)
        elif nodeName_ == 'sheets':
            obj_ = sheets.factory()
            obj_.build(child_)
            self.set_sheets(obj_)
        elif nodeName_ == 'errors':
            obj_ = errors.factory()
            obj_.build(child_)
            self.set_errors(obj_)
# end class schematic


class board(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, plain=None, libraries=None, attributes=None, variantdefs=None, classes=None, designrules=None, autorouter=None, elements=None, signals=None, errors=None):
        self.description = description
        self.plain = plain
        self.libraries = libraries
        self.attributes = attributes
        self.variantdefs = variantdefs
        self.classes = classes
        self.designrules = designrules
        self.autorouter = autorouter
        self.elements = elements
        self.signals = signals
        self.errors = errors
    def factory(*args_, **kwargs_):
        if board.subclass:
            return board.subclass(*args_, **kwargs_)
        else:
            return board(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_plain(self):
        return self.plain
    def set_plain(self, plain):
        self.plain = plain
    def get_libraries(self):
        return self.libraries
    def set_libraries(self, libraries):
        self.libraries = libraries
    def get_attributes(self):
        return self.attributes
    def set_attributes(self, attributes):
        self.attributes = attributes
    def get_variantdefs(self):
        return self.variantdefs
    def set_variantdefs(self, variantdefs):
        self.variantdefs = variantdefs
    def get_classes(self):
        return self.classes
    def set_classes(self, classes):
        self.classes = classes
    def get_designrules(self):
        return self.designrules
    def set_designrules(self, designrules):
        self.designrules = designrules
    def get_autorouter(self):
        return self.autorouter
    def set_autorouter(self, autorouter):
        self.autorouter = autorouter
    def get_elements(self):
        return self.elements
    def set_elements(self, elements):
        self.elements = elements
    def get_signals(self):
        return self.signals
    def set_signals(self, signals):
        self.signals = signals
    def get_errors(self):
        return self.errors
    def set_errors(self, errors):
        self.errors = errors
    def export(self, outfile, level, namespace_='t:', name_='board', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='board')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='board'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='board', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.plain is not None:
            self.plain.export(outfile, level, namespace_, name_='plain')
        if self.libraries is not None:
            self.libraries.export(outfile, level, namespace_, name_='libraries')
        if self.attributes is not None:
            self.attributes.export(outfile, level, namespace_, name_='attributes')
        if self.variantdefs is not None:
            self.variantdefs.export(outfile, level, namespace_, name_='variantdefs')
        if self.classes is not None:
            self.classes.export(outfile, level, namespace_, name_='classes')
        if self.designrules is not None:
            self.designrules.export(outfile, level, namespace_, name_='designrules')
        if self.autorouter is not None:
            self.autorouter.export(outfile, level, namespace_, name_='autorouter')
        if self.elements is not None:
            self.elements.export(outfile, level, namespace_, name_='elements')
        if self.signals is not None:
            self.signals.export(outfile, level, namespace_, name_='signals')
        if self.errors is not None:
            self.errors.export(outfile, level, namespace_, name_='errors')
    def hasContent_(self):
        if (
            self.description is not None or
            self.plain is not None or
            self.libraries is not None or
            self.attributes is not None or
            self.variantdefs is not None or
            self.classes is not None or
            self.designrules is not None or
            self.autorouter is not None or
            self.elements is not None or
            self.signals is not None or
            self.errors is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='board'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.plain is not None:
            showIndent(outfile, level)
            outfile.write('plain=model_.plain(\n')
            self.plain.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.libraries is not None:
            showIndent(outfile, level)
            outfile.write('libraries=model_.libraries(\n')
            self.libraries.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.attributes is not None:
            showIndent(outfile, level)
            outfile.write('attributes=model_.attributes(\n')
            self.attributes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variantdefs is not None:
            showIndent(outfile, level)
            outfile.write('variantdefs=model_.variantdefs(\n')
            self.variantdefs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.classes is not None:
            showIndent(outfile, level)
            outfile.write('classes=model_.classes(\n')
            self.classes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.designrules is not None:
            showIndent(outfile, level)
            outfile.write('designrules=model_.designrules(\n')
            self.designrules.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.autorouter is not None:
            showIndent(outfile, level)
            outfile.write('autorouter=model_.autorouter(\n')
            self.autorouter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.elements is not None:
            showIndent(outfile, level)
            outfile.write('elements=model_.elements(\n')
            self.elements.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.signals is not None:
            showIndent(outfile, level)
            outfile.write('signals=model_.signals(\n')
            self.signals.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.errors is not None:
            showIndent(outfile, level)
            outfile.write('errors=model_.errors(\n')
            self.errors.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'plain':
            obj_ = plain.factory()
            obj_.build(child_)
            self.set_plain(obj_)
        elif nodeName_ == 'libraries':
            obj_ = libraries.factory()
            obj_.build(child_)
            self.set_libraries(obj_)
        elif nodeName_ == 'attributes':
            obj_ = attributes.factory()
            obj_.build(child_)
            self.set_attributes(obj_)
        elif nodeName_ == 'variantdefs':
            obj_ = variantdefs.factory()
            obj_.build(child_)
            self.set_variantdefs(obj_)
        elif nodeName_ == 'classes':
            obj_ = classes.factory()
            obj_.build(child_)
            self.set_classes(obj_)
        elif nodeName_ == 'designrules':
            obj_ = designrules.factory()
            obj_.build(child_)
            self.set_designrules(obj_)
        elif nodeName_ == 'autorouter':
            obj_ = autorouter.factory()
            obj_.build(child_)
            self.set_autorouter(obj_)
        elif nodeName_ == 'elements':
            obj_ = elements.factory()
            obj_.build(child_)
            self.set_elements(obj_)
        elif nodeName_ == 'signals':
            obj_ = signals.factory()
            obj_.build(child_)
            self.set_signals(obj_)
        elif nodeName_ == 'errors':
            obj_ = errors.factory()
            obj_.build(child_)
            self.set_errors(obj_)
# end class board


class sheet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, plain=None, instances=None, busses=None, nets=None):
        self.description = description
        self.plain = plain
        self.instances = instances
        self.busses = busses
        self.nets = nets
    def factory(*args_, **kwargs_):
        if sheet.subclass:
            return sheet.subclass(*args_, **kwargs_)
        else:
            return sheet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_plain(self):
        return self.plain
    def set_plain(self, plain):
        self.plain = plain
    def get_instances(self):
        return self.instances
    def set_instances(self, instances):
        self.instances = instances
    def get_busses(self):
        return self.busses
    def set_busses(self, busses):
        self.busses = busses
    def get_nets(self):
        return self.nets
    def set_nets(self, nets):
        self.nets = nets
    def export(self, outfile, level, namespace_='t:', name_='sheet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sheet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='sheet'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='sheet', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.plain is not None:
            self.plain.export(outfile, level, namespace_, name_='plain')
        if self.instances is not None:
            self.instances.export(outfile, level, namespace_, name_='instances')
        if self.busses is not None:
            self.busses.export(outfile, level, namespace_, name_='busses')
        if self.nets is not None:
            self.nets.export(outfile, level, namespace_, name_='nets')
    def hasContent_(self):
        if (
            self.description is not None or
            self.plain is not None or
            self.instances is not None or
            self.busses is not None or
            self.nets is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sheet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.plain is not None:
            showIndent(outfile, level)
            outfile.write('plain=model_.plain(\n')
            self.plain.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.instances is not None:
            showIndent(outfile, level)
            outfile.write('instances=model_.instances(\n')
            self.instances.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.busses is not None:
            showIndent(outfile, level)
            outfile.write('busses=model_.busses(\n')
            self.busses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.nets is not None:
            showIndent(outfile, level)
            outfile.write('nets=model_.nets(\n')
            self.nets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'plain':
            obj_ = plain.factory()
            obj_.build(child_)
            self.set_plain(obj_)
        elif nodeName_ == 'instances':
            obj_ = instances.factory()
            obj_.build(child_)
            self.set_instances(obj_)
        elif nodeName_ == 'busses':
            obj_ = busses.factory()
            obj_.build(child_)
            self.set_busses(obj_)
        elif nodeName_ == 'nets':
            obj_ = nets.factory()
            obj_.build(child_)
            self.set_nets(obj_)
# end class sheet


class package(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None, polygon=None, wire=None, text=None, circle=None, rectangle=None, frame=None, hole=None, pad=None, smd=None):
        self.name = _cast(None, name)
        self.description = description
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
        if wire is None:
            self.wire = []
        else:
            self.wire = wire
        if text is None:
            self.text = []
        else:
            self.text = text
        if circle is None:
            self.circle = []
        else:
            self.circle = circle
        if rectangle is None:
            self.rectangle = []
        else:
            self.rectangle = rectangle
        if frame is None:
            self.frame = []
        else:
            self.frame = frame
        if hole is None:
            self.hole = []
        else:
            self.hole = hole
        if pad is None:
            self.pad = []
        else:
            self.pad = pad
        if smd is None:
            self.smd = []
        else:
            self.smd = smd
    def factory(*args_, **kwargs_):
        if package.subclass:
            return package.subclass(*args_, **kwargs_)
        else:
            return package(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_polygon(self):
        return self.polygon
    def set_polygon(self, polygon):
        self.polygon = polygon
    def add_polygon(self, value):
        self.polygon.append(value)
    def insert_polygon(self, index, value):
        self.polygon[index] = value
    def get_wire(self):
        return self.wire
    def set_wire(self, wire):
        self.wire = wire
    def add_wire(self, value):
        self.wire.append(value)
    def insert_wire(self, index, value):
        self.wire[index] = value
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def add_text(self, value):
        self.text.append(value)
    def insert_text(self, index, value):
        self.text[index] = value
    def get_circle(self):
        return self.circle
    def set_circle(self, circle):
        self.circle = circle
    def add_circle(self, value):
        self.circle.append(value)
    def insert_circle(self, index, value):
        self.circle[index] = value
    def get_rectangle(self):
        return self.rectangle
    def set_rectangle(self, rectangle):
        self.rectangle = rectangle
    def add_rectangle(self, value):
        self.rectangle.append(value)
    def insert_rectangle(self, index, value):
        self.rectangle[index] = value
    def get_frame(self):
        return self.frame
    def set_frame(self, frame):
        self.frame = frame
    def add_frame(self, value):
        self.frame.append(value)
    def insert_frame(self, index, value):
        self.frame[index] = value
    def get_hole(self):
        return self.hole
    def set_hole(self, hole):
        self.hole = hole
    def add_hole(self, value):
        self.hole.append(value)
    def insert_hole(self, index, value):
        self.hole[index] = value
    def get_pad(self):
        return self.pad
    def set_pad(self, pad):
        self.pad = pad
    def add_pad(self, value):
        self.pad.append(value)
    def insert_pad(self, index, value):
        self.pad[index] = value
    def get_smd(self):
        return self.smd
    def set_smd(self, smd):
        self.smd = smd
    def add_smd(self, value):
        self.smd.append(value)
    def insert_smd(self, index, value):
        self.smd[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def export(self, outfile, level, namespace_='t:', name_='package', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='package')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='package'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='package', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
        for wire_ in self.wire:
            wire_.export(outfile, level, namespace_, name_='wire')
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text')
        for circle_ in self.circle:
            circle_.export(outfile, level, namespace_, name_='circle')
        for rectangle_ in self.rectangle:
            rectangle_.export(outfile, level, namespace_, name_='rectangle')
        for frame_ in self.frame:
            frame_.export(outfile, level, namespace_, name_='frame')
        for hole_ in self.hole:
            hole_.export(outfile, level, namespace_, name_='hole')
        for pad_ in self.pad:
            pad_.export(outfile, level, namespace_, name_='pad')
        for smd_ in self.smd:
            smd_.export(outfile, level, namespace_, name_='smd')
    def hasContent_(self):
        if (
            self.description is not None or
            self.polygon or
            self.wire or
            self.text or
            self.circle or
            self.rectangle or
            self.frame or
            self.hole or
            self.pad or
            self.smd
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='package'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.polygon(\n')
            polygon_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wire=[\n')
        level += 1
        for wire_ in self.wire:
            showIndent(outfile, level)
            outfile.write('model_.wire(\n')
            wire_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('text=[\n')
        level += 1
        for text_ in self.text:
            showIndent(outfile, level)
            outfile.write('model_.text(\n')
            text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('circle=[\n')
        level += 1
        for circle_ in self.circle:
            showIndent(outfile, level)
            outfile.write('model_.circle(\n')
            circle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('rectangle=[\n')
        level += 1
        for rectangle_ in self.rectangle:
            showIndent(outfile, level)
            outfile.write('model_.rectangle(\n')
            rectangle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('frame=[\n')
        level += 1
        for frame_ in self.frame:
            showIndent(outfile, level)
            outfile.write('model_.frame(\n')
            frame_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('hole=[\n')
        level += 1
        for hole_ in self.hole:
            showIndent(outfile, level)
            outfile.write('model_.hole(\n')
            hole_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pad=[\n')
        level += 1
        for pad_ in self.pad:
            showIndent(outfile, level)
            outfile.write('model_.pad(\n')
            pad_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('smd=[\n')
        level += 1
        for smd_ in self.smd:
            showIndent(outfile, level)
            outfile.write('model_.smd(\n')
            smd_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'polygon':
            obj_ = polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
        elif nodeName_ == 'wire':
            obj_ = wire.factory()
            obj_.build(child_)
            self.wire.append(obj_)
        elif nodeName_ == 'text':
            obj_ = text.factory()
            obj_.build(child_)
            self.text.append(obj_)
        elif nodeName_ == 'circle':
            obj_ = circle.factory()
            obj_.build(child_)
            self.circle.append(obj_)
        elif nodeName_ == 'rectangle':
            obj_ = rectangle.factory()
            obj_.build(child_)
            self.rectangle.append(obj_)
        elif nodeName_ == 'frame':
            obj_ = frame.factory()
            obj_.build(child_)
            self.frame.append(obj_)
        elif nodeName_ == 'hole':
            obj_ = hole.factory()
            obj_.build(child_)
            self.hole.append(obj_)
        elif nodeName_ == 'pad':
            obj_ = pad.factory()
            obj_.build(child_)
            self.pad.append(obj_)
        elif nodeName_ == 'smd':
            obj_ = smd.factory()
            obj_.build(child_)
            self.smd.append(obj_)
# end class package


class symbol(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None, polygon=None, wire=None, text=None, pin=None, circle=None, rectangle=None, frame=None):
        self.name = _cast(None, name)
        self.description = description
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
        if wire is None:
            self.wire = []
        else:
            self.wire = wire
        if text is None:
            self.text = []
        else:
            self.text = text
        if pin is None:
            self.pin = []
        else:
            self.pin = pin
        if circle is None:
            self.circle = []
        else:
            self.circle = circle
        if rectangle is None:
            self.rectangle = []
        else:
            self.rectangle = rectangle
        if frame is None:
            self.frame = []
        else:
            self.frame = frame
    def factory(*args_, **kwargs_):
        if symbol.subclass:
            return symbol.subclass(*args_, **kwargs_)
        else:
            return symbol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_polygon(self):
        return self.polygon
    def set_polygon(self, polygon):
        self.polygon = polygon
    def add_polygon(self, value):
        self.polygon.append(value)
    def insert_polygon(self, index, value):
        self.polygon[index] = value
    def get_wire(self):
        return self.wire
    def set_wire(self, wire):
        self.wire = wire
    def add_wire(self, value):
        self.wire.append(value)
    def insert_wire(self, index, value):
        self.wire[index] = value
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def add_text(self, value):
        self.text.append(value)
    def insert_text(self, index, value):
        self.text[index] = value
    def get_pin(self):
        return self.pin
    def set_pin(self, pin):
        self.pin = pin
    def add_pin(self, value):
        self.pin.append(value)
    def insert_pin(self, index, value):
        self.pin[index] = value
    def get_circle(self):
        return self.circle
    def set_circle(self, circle):
        self.circle = circle
    def add_circle(self, value):
        self.circle.append(value)
    def insert_circle(self, index, value):
        self.circle[index] = value
    def get_rectangle(self):
        return self.rectangle
    def set_rectangle(self, rectangle):
        self.rectangle = rectangle
    def add_rectangle(self, value):
        self.rectangle.append(value)
    def insert_rectangle(self, index, value):
        self.rectangle[index] = value
    def get_frame(self):
        return self.frame
    def set_frame(self, frame):
        self.frame = frame
    def add_frame(self, value):
        self.frame.append(value)
    def insert_frame(self, index, value):
        self.frame[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def export(self, outfile, level, namespace_='t:', name_='symbol', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='symbol')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='symbol'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='symbol', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
        for wire_ in self.wire:
            wire_.export(outfile, level, namespace_, name_='wire')
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text')
        for pin_ in self.pin:
            pin_.export(outfile, level, namespace_, name_='pin')
        for circle_ in self.circle:
            circle_.export(outfile, level, namespace_, name_='circle')
        for rectangle_ in self.rectangle:
            rectangle_.export(outfile, level, namespace_, name_='rectangle')
        for frame_ in self.frame:
            frame_.export(outfile, level, namespace_, name_='frame')
    def hasContent_(self):
        if (
            self.description is not None or
            self.polygon or
            self.wire or
            self.text or
            self.pin or
            self.circle or
            self.rectangle or
            self.frame
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='symbol'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.polygon(\n')
            polygon_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wire=[\n')
        level += 1
        for wire_ in self.wire:
            showIndent(outfile, level)
            outfile.write('model_.wire(\n')
            wire_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('text=[\n')
        level += 1
        for text_ in self.text:
            showIndent(outfile, level)
            outfile.write('model_.text(\n')
            text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pin=[\n')
        level += 1
        for pin_ in self.pin:
            showIndent(outfile, level)
            outfile.write('model_.pin(\n')
            pin_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('circle=[\n')
        level += 1
        for circle_ in self.circle:
            showIndent(outfile, level)
            outfile.write('model_.circle(\n')
            circle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('rectangle=[\n')
        level += 1
        for rectangle_ in self.rectangle:
            showIndent(outfile, level)
            outfile.write('model_.rectangle(\n')
            rectangle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('frame=[\n')
        level += 1
        for frame_ in self.frame:
            showIndent(outfile, level)
            outfile.write('model_.frame(\n')
            frame_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'polygon':
            obj_ = polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
        elif nodeName_ == 'wire':
            obj_ = wire.factory()
            obj_.build(child_)
            self.wire.append(obj_)
        elif nodeName_ == 'text':
            obj_ = text.factory()
            obj_.build(child_)
            self.text.append(obj_)
        elif nodeName_ == 'pin':
            obj_ = pin.factory()
            obj_.build(child_)
            self.pin.append(obj_)
        elif nodeName_ == 'circle':
            obj_ = circle.factory()
            obj_.build(child_)
            self.circle.append(obj_)
        elif nodeName_ == 'rectangle':
            obj_ = rectangle.factory()
            obj_.build(child_)
            self.rectangle.append(obj_)
        elif nodeName_ == 'frame':
            obj_ = frame.factory()
            obj_.build(child_)
            self.frame.append(obj_)
# end class symbol


class deviceset(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uservalue=None, prefix=None, name=None, description=None, gates=None, devices=None):
        self.uservalue = _cast(None, uservalue)
        self.prefix = _cast(None, prefix)
        self.name = _cast(None, name)
        self.description = description
        self.gates = gates
        self.devices = devices
    def factory(*args_, **kwargs_):
        if deviceset.subclass:
            return deviceset.subclass(*args_, **kwargs_)
        else:
            return deviceset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_gates(self):
        return self.gates
    def set_gates(self, gates):
        self.gates = gates
    def get_devices(self):
        return self.devices
    def set_devices(self, devices):
        self.devices = devices
    def get_uservalue(self):
        return self.uservalue
    def set_uservalue(self, uservalue):
        self.uservalue = uservalue
    def get_prefix(self):
        return self.prefix
    def set_prefix(self, prefix):
        self.prefix = prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def export(self, outfile, level, namespace_='t:', name_='deviceset', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='deviceset')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='deviceset'):
        if self.uservalue is not None and 'uservalue' not in already_processed:
            already_processed.append('uservalue')
            outfile.write(' uservalue=%s' 
                % (self.gds_format_string(quote_attrib(self.uservalue).encode(ExternalEncoding),
                    input_name='uservalue'), ))
        if self.prefix is not None and 'prefix' not in already_processed:
            already_processed.append('prefix')
            outfile.write(' prefix=%s' % (self.gds_format_string(quote_attrib(self.prefix).encode(ExternalEncoding),
                input_name='prefix'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='deviceset', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.gates is not None:
            self.gates.export(outfile, level, namespace_, name_='gates', )
        if self.devices is not None:
            self.devices.export(outfile, level, namespace_, name_='devices', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.gates is not None or
            self.devices is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='deviceset'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uservalue is not None and 'uservalue' not in already_processed:
            already_processed.append('uservalue')
            showIndent(outfile, level)
            outfile.write('uservalue = "%s",\n' % (self.uservalue,))
        if self.prefix is not None and 'prefix' not in already_processed:
            already_processed.append('prefix')
            showIndent(outfile, level)
            outfile.write('prefix = "%s",\n' % (self.prefix,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gates is not None:
            showIndent(outfile, level)
            outfile.write('gates=model_.gates(\n')
            self.gates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.devices is not None:
            showIndent(outfile, level)
            outfile.write('devices=model_.devices(\n')
            self.devices.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uservalue', node)
        if value is not None and 'uservalue' not in already_processed:
            already_processed.append('uservalue')
            self.uservalue = value
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.append('prefix')
            self.prefix = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'gates':
            obj_ = gates.factory()
            obj_.build(child_)
            self.set_gates(obj_)
        elif nodeName_ == 'devices':
            obj_ = devices.factory()
            obj_.build(child_)
            self.set_devices(obj_)
# end class deviceset


class device(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, package=None, connects=None, technologies=None):
        self.name = _cast(None, name)
        self.package = _cast(None, package)
        self.connects = connects
        self.technologies = technologies
    def factory(*args_, **kwargs_):
        if device.subclass:
            return device.subclass(*args_, **kwargs_)
        else:
            return device(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connects(self):
        return self.connects
    def set_connects(self, connects):
        self.connects = connects
    def get_technologies(self):
        return self.technologies
    def set_technologies(self, technologies):
        self.technologies = technologies
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_package(self):
        return self.package
    def set_package(self, package):
        self.package = package
    def export(self, outfile, level, namespace_='t:', name_='device', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='device')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='device'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.package is not None and 'package' not in already_processed:
            already_processed.append('package')
            outfile.write(' package=%s' % (self.gds_format_string(quote_attrib(self.package).encode(ExternalEncoding),
                input_name='package'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='device', fromsubclass_=False):
        if self.connects is not None:
            self.connects.export(outfile, level, namespace_, name_='connects')
        if self.technologies is not None:
            self.technologies.export(outfile, level, namespace_, name_='technologies')
    def hasContent_(self):
        if (
            self.connects is not None or
            self.technologies is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='device'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.package is not None and 'package' not in already_processed:
            already_processed.append('package')
            showIndent(outfile, level)
            outfile.write('package = "%s",\n' % (self.package,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.connects is not None:
            showIndent(outfile, level)
            outfile.write('connects=model_.connects(\n')
            self.connects.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.technologies is not None:
            showIndent(outfile, level)
            outfile.write('technologies=model_.technologies(\n')
            self.technologies.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('package', node)
        if value is not None and 'package' not in already_processed:
            already_processed.append('package')
            self.package = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'connects':
            obj_ = connects.factory()
            obj_.build(child_)
            self.set_connects(obj_)
        elif nodeName_ == 'technologies':
            obj_ = technologies.factory()
            obj_.build(child_)
            self.set_technologies(obj_)
# end class device


class bus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, segment=None):
        self.name = _cast(None, name)
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
    def factory(*args_, **kwargs_):
        if bus.subclass:
            return bus.subclass(*args_, **kwargs_)
        else:
            return bus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_segment(self):
        return self.segment
    def set_segment(self, segment):
        self.segment = segment
    def add_segment(self, value):
        self.segment.append(value)
    def insert_segment(self, index, value):
        self.segment[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def export(self, outfile, level, namespace_='t:', name_='bus', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bus')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='bus'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='bus', fromsubclass_=False):
        for segment_ in self.segment:
            segment_.export(outfile, level, namespace_, name_='segment')
    def hasContent_(self):
        if (
            self.segment
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='bus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('segment=[\n')
        level += 1
        for segment_ in self.segment:
            showIndent(outfile, level)
            outfile.write('model_.segment(\n')
            segment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'segment':
            obj_ = segment.factory()
            obj_.build(child_)
            self.segment.append(obj_)
# end class bus


class net(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, classxx=None, segment=None):
        self.name = _cast(None, name)
        self.classxx = _cast(None, classxx)
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
    def factory(*args_, **kwargs_):
        if net.subclass:
            return net.subclass(*args_, **kwargs_)
        else:
            return net(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_segment(self):
        return self.segment
    def set_segment(self, segment):
        self.segment = segment
    def add_segment(self, value):
        self.segment.append(value)
    def insert_segment(self, index, value):
        self.segment[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name): 
        self.name = name
    def get_class(self):
        return self.classxx
    def set_class(self, classxx):
        self.classxx = classxx
    def export(self, outfile, level, namespace_='t:', name_='net', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='net')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='net'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding),
                input_name='class'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='net', fromsubclass_=False):
        for segment_ in self.segment:
            segment_.export(outfile, level, namespace_, name_='segment')
    def hasContent_(self):
        if (
            self.segment
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='net'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('segment=[\n')
        level += 1
        for segment_ in self.segment:
            showIndent(outfile, level)
            outfile.write('model_.segment(\n')
            segment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'segment':
            obj_ = segment.factory()
            obj_.build(child_)
            self.segment.append(obj_)
# end class net


class segment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pinref=None, wire=None, junction=None, label=None):
        if pinref is None:
            self.pinref = []
        else:
            self.pinref = pinref
        if wire is None:
            self.wire = []
        else:
            self.wire = wire
        if junction is None:
            self.junction = []
        else:
            self.junction = junction
        if label is None:
            self.label = []
        else:
            self.label = label
    def factory(*args_, **kwargs_):
        if segment.subclass:
            return segment.subclass(*args_, **kwargs_)
        else:
            return segment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pinref(self):
        return self.pinref
    def set_pinref(self, pinref):
        self.pinref = pinref
    def add_pinref(self, value):
        self.pinref.append(value)
    def insert_pinref(self, index, value):
        self.pinref[index] = value
    def get_wire(self):
        return self.wire
    def set_wire(self, wire):
        self.wire = wire
    def add_wire(self, value):
        self.wire.append(value)
    def insert_wire(self, index, value):
        self.wire[index] = value
    def get_junction(self):
        return self.junction
    def set_junction(self, junction):
        self.junction = junction
    def add_junction(self, value):
        self.junction.append(value)
    def insert_junction(self, index, value):
        self.junction[index] = value
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def add_label(self, value):
        self.label.append(value)
    def insert_label(self, index, value):
        self.label[index] = value
    def export(self, outfile, level, namespace_='t:', name_='segment', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='segment')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='segment'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='segment', fromsubclass_=False):
        for pinref_ in self.pinref:
            pinref_.export(outfile, level, namespace_, name_='pinref')
        for wire_ in self.wire:
            wire_.export(outfile, level, namespace_, name_='wire')
        for junction_ in self.junction:
            junction_.export(outfile, level, namespace_, name_='junction')
        for label_ in self.label:
            label_.export(outfile, level, namespace_, name_='label')
    def hasContent_(self):
        if (
            self.pinref or
            self.wire or
            self.junction or
            self.label
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='segment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pinref=[\n')
        level += 1
        for pinref_ in self.pinref:
            showIndent(outfile, level)
            outfile.write('model_.pinref(\n')
            pinref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wire=[\n')
        level += 1
        for wire_ in self.wire:
            showIndent(outfile, level)
            outfile.write('model_.wire(\n')
            wire_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('junction=[\n')
        level += 1
        for junction_ in self.junction:
            showIndent(outfile, level)
            outfile.write('model_.junction(\n')
            junction_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('label=[\n')
        level += 1
        for label_ in self.label:
            showIndent(outfile, level)
            outfile.write('model_.label(\n')
            label_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pinref':
            obj_ = pinref.factory()
            obj_.build(child_)
            self.pinref.append(obj_)
        elif nodeName_ == 'wire':
            obj_ = wire.factory()
            obj_.build(child_)
            self.wire.append(obj_)
        elif nodeName_ == 'junction':
            obj_ = junction.factory()
            obj_.build(child_)
            self.junction.append(obj_)
        elif nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.label.append(obj_)
# end class segment


class signal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, airwireshidden=None, name=None, classxx=None, contactref=None, polygon=None, wire=None, via=None):
        self.airwireshidden = _cast(None, airwireshidden)
        self.name = _cast(None, name)
        self.classxx = _cast(None, classxx)
        if contactref is None:
            self.contactref = []
        else:
            self.contactref = contactref
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
        if wire is None:
            self.wire = []
        else:
            self.wire = wire
        if via is None:
            self.via = []
        else:
            self.via = via
    def factory(*args_, **kwargs_):
        if signal.subclass:
            return signal.subclass(*args_, **kwargs_)
        else:
            return signal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contactref(self):
        return self.contactref
    def set_contactref(self, contactref):
        self.contactref = contactref
    def add_contactref(self, value):
        self.contactref.append(value)
    def insert_contactref(self, index, value):
        self.contactref[index] = value
    def get_polygon(self):
        return self.polygon
    def set_polygon(self, polygon):
        self.polygon = polygon
    def add_polygon(self, value):
        self.polygon.append(value)
    def insert_polygon(self, index, value):
        self.polygon[index] = value
    def get_wire(self):
        return self.wire
    def set_wire(self, wire):
        self.wire = wire
    def add_wire(self, value):
        self.wire.append(value)
    def insert_wire(self, index, value):
        self.wire[index] = value
    def get_via(self):
        return self.via
    def set_via(self, via):
        self.via = via
    def add_via(self, value):
        self.via.append(value)
    def insert_via(self, index, value):
        self.via[index] = value
    def get_airwireshidden(self):
        return self.airwireshidden
    def set_airwireshidden(self, airwireshidden):
        self.airwireshidden = airwireshidden
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_class(self):
        return self.classxx
    def set_class(self, classxx):
        self.classxx = classxx
    def export(self, outfile, level, namespace_='t:', name_='signal', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='signal')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='signal'):
        if self.airwireshidden is not None and 'airwireshidden' not in already_processed:
            already_processed.append('airwireshidden')
            outfile.write(' airwireshidden=%s' 
                % (self.gds_format_string(quote_attrib(self.airwireshidden).encode(ExternalEncoding),
                    input_name='airwireshidden'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding),
                input_name='class'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='signal', fromsubclass_=False):
        for contactref_ in self.contactref:
            contactref_.export(outfile, level, namespace_, name_='contactref')
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
        for wire_ in self.wire:
            wire_.export(outfile, level, namespace_, name_='wire')
        for via_ in self.via:
            via_.export(outfile, level, namespace_, name_='via')
    def hasContent_(self):
        if (
            self.contactref or
            self.polygon or
            self.wire or
            self.via
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='signal'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.airwireshidden is not None and 'airwireshidden' not in already_processed:
            already_processed.append('airwireshidden')
            showIndent(outfile, level)
            outfile.write('airwireshidden = "%s",\n' % (self.airwireshidden,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('contactref=[\n')
        level += 1
        for contactref_ in self.contactref:
            showIndent(outfile, level)
            outfile.write('model_.contactref(\n')
            contactref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.polygon(\n')
            polygon_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wire=[\n')
        level += 1
        for wire_ in self.wire:
            showIndent(outfile, level)
            outfile.write('model_.wire(\n')
            wire_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('via=[\n')
        level += 1
        for via_ in self.via:
            showIndent(outfile, level)
            outfile.write('model_.via(\n')
            via_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('airwireshidden', node)
        if value is not None and 'airwireshidden' not in already_processed:
            already_processed.append('airwireshidden')
            self.airwireshidden = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contactref':
            obj_ = contactref.factory()
            obj_.build(child_)
            self.contactref.append(obj_)
        elif nodeName_ == 'polygon':
            obj_ = polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
        elif nodeName_ == 'wire':
            obj_ = wire.factory()
            obj_.build(child_)
            self.wire.append(obj_)
        elif nodeName_ == 'via':
            obj_ = via.factory()
            obj_.build(child_)
            self.via.append(obj_)
# end class signal


class variantdef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if variantdef.subclass:
            return variantdef.subclass(*args_, **kwargs_)
        else:
            return variantdef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='t:', name_='variantdef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='variantdef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='variantdef'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='variantdef', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='variantdef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class variantdef


class variant(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, technology=None, name=None, populate=None):
        self.value = _cast(None, value)
        self.technology = _cast(None, technology)
        self.name = _cast(None, name)
        self.populate = _cast(None, populate)
        pass
    def factory(*args_, **kwargs_):
        if variant.subclass:
            return variant.subclass(*args_, **kwargs_)
        else:
            return variant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_technology(self):
        return self.technology
    def set_technology(self, technology):
        self.technology = technology
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_populate(self):
        return self.populate
    def set_populate(self, populate):
        self.populate = populate
    def export(self, outfile, level, namespace_='t:', name_='variant', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='variant')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='variant'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding),
                input_name='value'), ))
        if self.technology is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            outfile.write(' technology=%s' 
                % (self.gds_format_string(quote_attrib(self.technology).encode(ExternalEncoding),
                    input_name='technology'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.populate is not None and 'populate' not in already_processed:
            already_processed.append('populate')
            outfile.write(' populate=%s' 
                % (self.gds_format_string(quote_attrib(self.populate).encode(ExternalEncoding),
                    input_name='populate'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='variant', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='variant'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        if self.technology is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            showIndent(outfile, level)
            outfile.write('technology = "%s",\n' % (self.technology,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.populate is not None and 'populate' not in already_processed:
            already_processed.append('populate')
            showIndent(outfile, level)
            outfile.write('populate = "%s",\n' % (self.populate,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('technology', node)
        if value is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            self.technology = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('populate', node)
        if value is not None and 'populate' not in already_processed:
            already_processed.append('populate')
            self.populate = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class variant


class gate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, symbol=None, swaplevel=None, addlevel=None, y=None, x=None):
        self.name = _cast(None, name)
        self.symbol = _cast(None, symbol)
        self.swaplevel = _cast(None, swaplevel)
        self.addlevel = _cast(None, addlevel)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        pass
    def factory(*args_, **kwargs_):
        if gate.subclass:
            return gate.subclass(*args_, **kwargs_)
        else:
            return gate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_symbol(self):
        return self.symbol
    def set_symbol(self, symbol):
        self.symbol = symbol
    def get_swaplevel(self):
        return self.swaplevel
    def set_swaplevel(self, swaplevel):
        self.swaplevel = swaplevel
    def get_addlevel(self):
        return self.addlevel
    def set_addlevel(self, addlevel):
        self.addlevel = addlevel
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def export(self, outfile, level, namespace_='t:', name_='gate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='gate'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            outfile.write(' symbol=%s' % (self.gds_format_string(quote_attrib(self.symbol).encode(ExternalEncoding),
                input_name='symbol'), ))
        if self.swaplevel is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            outfile.write(' swaplevel=%s' 
                % (self.gds_format_string(quote_attrib(self.swaplevel).encode(ExternalEncoding),
                    input_name='swaplevel'), ))
        if self.addlevel is not None and 'addlevel' not in already_processed:
            already_processed.append('addlevel')
            outfile.write(' addlevel=%s' 
                % (self.gds_format_string(quote_attrib(self.addlevel).encode(ExternalEncoding),
                    input_name='addlevel'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='gate', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            showIndent(outfile, level)
            outfile.write('symbol = "%s",\n' % (self.symbol,))
        if self.swaplevel is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            showIndent(outfile, level)
            outfile.write('swaplevel = "%s",\n' % (self.swaplevel,))
        if self.addlevel is not None and 'addlevel' not in already_processed:
            already_processed.append('addlevel')
            showIndent(outfile, level)
            outfile.write('addlevel = "%s",\n' % (self.addlevel,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('symbol', node)
        if value is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            self.symbol = value
        value = find_attr_value_('swaplevel', node)
        if value is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            self.swaplevel = value
        value = find_attr_value_('addlevel', node)
        if value is not None and 'addlevel' not in already_processed:
            already_processed.append('addlevel')
            self.addlevel = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gate


class wire(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, y2=None, width=None, cap=None, curve=None, style=None, x2=None, extent=None, y1=None, x1=None):
        self.layer = _cast(None, layer)
        self.y2 = _cast(None, y2)
        self.width = _cast(None, width)
        self.cap = _cast(None, cap)
        self.curve = _cast(None, curve)
        self.style = _cast(None, style)
        self.x2 = _cast(None, x2)
        self.extent = _cast(None, extent)
        self.y1 = _cast(None, y1)
        self.x1 = _cast(None, x1)
        pass
    def factory(*args_, **kwargs_):
        if wire.subclass:
            return wire.subclass(*args_, **kwargs_)
        else:
            return wire(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self):
        return self.layer
    def set_layer(self, layer):
        self.layer = layer
    def get_y2(self):
        return self.y2
    def set_y2(self, y2):
        self.y2 = y2
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_cap(self):
        return self.cap
    def set_cap(self, cap):
        self.cap = cap
    def get_curve(self):
        return self.curve
    def set_curve(self, curve):
        self.curve = curve
    def get_style(self):
        return self.style
    def set_style(self, style):
        self.style = style
    def get_x2(self):
        return self.x2
    def set_x2(self, x2):
        self.x2 = x2
    def get_extent(self):
        return self.extent
    def set_extent(self, extent):
        self.extent = extent
    def get_y1(self):
        return self.y1
    def set_y1(self, y1):
        self.y1 = y1
    def get_x1(self):
        return self.x1
    def set_x1(self, x1):
        self.x1 = x1
    def export(self, outfile, level, namespace_='t:', name_='wire', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wire')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='wire'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding),
                input_name='layer'), ))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            outfile.write(' y2=%s' % (self.gds_format_string(quote_attrib(self.y2).encode(ExternalEncoding),
                input_name='y2'), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width=%s' % (self.gds_format_string(quote_attrib(self.width).encode(ExternalEncoding),
                input_name='width'), ))
        if self.cap is not None and 'cap' not in already_processed:
            already_processed.append('cap')
            outfile.write(' cap=%s' % (self.gds_format_string(quote_attrib(self.cap).encode(ExternalEncoding),
                input_name='cap'), ))
        if self.curve is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            outfile.write(' curve=%s' % (self.gds_format_string(quote_attrib(self.curve).encode(ExternalEncoding),
                input_name='curve'), ))
        if self.style is not None and 'style' not in already_processed:
            already_processed.append('style')
            outfile.write(' style=%s' % (self.gds_format_string(quote_attrib(self.style).encode(ExternalEncoding),
                input_name='style'), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            outfile.write(' x2=%s' % (self.gds_format_string(quote_attrib(self.x2).encode(ExternalEncoding),
                input_name='x2'), ))
        if self.extent is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            outfile.write(' extent=%s' % (self.gds_format_string(quote_attrib(self.extent).encode(ExternalEncoding),
                input_name='extent'), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            outfile.write(' y1=%s' % (self.gds_format_string(quote_attrib(self.y1).encode(ExternalEncoding),
                input_name='y1'), ))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            outfile.write(' x1=%s' % (self.gds_format_string(quote_attrib(self.x1).encode(ExternalEncoding),
                input_name='x1'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='wire', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wire'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            showIndent(outfile, level)
            outfile.write('y2 = "%s",\n' % (self.y2,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = "%s",\n' % (self.width,))
        if self.cap is not None and 'cap' not in already_processed:
            already_processed.append('cap')
            showIndent(outfile, level)
            outfile.write('cap = "%s",\n' % (self.cap,))
        if self.curve is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            showIndent(outfile, level)
            outfile.write('curve = "%s",\n' % (self.curve,))
        if self.style is not None and 'style' not in already_processed:
            already_processed.append('style')
            showIndent(outfile, level)
            outfile.write('style = "%s",\n' % (self.style,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            showIndent(outfile, level)
            outfile.write('x2 = "%s",\n' % (self.x2,))
        if self.extent is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            showIndent(outfile, level)
            outfile.write('extent = "%s",\n' % (self.extent,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            showIndent(outfile, level)
            outfile.write('y1 = "%s",\n' % (self.y1,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            showIndent(outfile, level)
            outfile.write('x1 = "%s",\n' % (self.x1,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            self.y2 = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            self.width = value
        value = find_attr_value_('cap', node)
        if value is not None and 'cap' not in already_processed:
            already_processed.append('cap')
            self.cap = value
        value = find_attr_value_('curve', node)
        if value is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            self.curve = value
        value = find_attr_value_('style', node)
        if value is not None and 'style' not in already_processed:
            already_processed.append('style')
            self.style = value
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            self.x2 = value
        value = find_attr_value_('extent', node)
        if value is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            self.extent = value
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            self.y1 = value
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            self.x1 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class wire


class dimension(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, y2=None, dtype=None, x2=None, y1=None, x3=None, y3=None, x1=None):
        self.layer = _cast(None, layer)
        self.y2 = _cast(None, y2)
        self.dtype = _cast(None, dtype)
        self.x2 = _cast(None, x2)
        self.y1 = _cast(None, y1)
        self.x3 = _cast(None, x3)
        self.y3 = _cast(None, y3)
        self.x1 = _cast(None, x1)
        pass
    def factory(*args_, **kwargs_):
        if dimension.subclass:
            return dimension.subclass(*args_, **kwargs_)
        else:
            return dimension(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self):
        return self.layer
    def set_layer(self, layer):
        self.layer = layer
    def get_y2(self):
        return self.y2
    def set_y2(self, y2):
        self.y2 = y2
    def get_dtype(self):
        return self.dtype
    def set_dtype(self, dtype):
        self.dtype = dtype
    def get_x2(self):
        return self.x2
    def set_x2(self, x2):
        self.x2 = x2
    def get_y1(self):
        return self.y1
    def set_y1(self, y1):
        self.y1 = y1
    def get_x3(self):
        return self.x3
    def set_x3(self, x3):
        self.x3 = x3
    def get_y3(self):
        return self.y3
    def set_y3(self, y3):
        self.y3 = y3
    def get_x1(self):
        return self.x1
    def set_x1(self, x1):
        self.x1 = x1
    def export(self, outfile, level, namespace_='t:', name_='dimension', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dimension')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='dimension'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding),
                input_name='layer'), ))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            outfile.write(' y2=%s' % (self.gds_format_string(quote_attrib(self.y2).encode(ExternalEncoding),
                input_name='y2'), ))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            outfile.write(' dtype=%s' % (self.gds_format_string(quote_attrib(self.dtype).encode(ExternalEncoding),
                input_name='dtype'), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            outfile.write(' x2=%s' % (self.gds_format_string(quote_attrib(self.x2).encode(ExternalEncoding),
                input_name='x2'), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            outfile.write(' y1=%s' % (self.gds_format_string(quote_attrib(self.y1).encode(ExternalEncoding),
                input_name='y1'), ))
        if self.x3 is not None and 'x3' not in already_processed:
            already_processed.append('x3')
            outfile.write(' x3=%s' % (self.gds_format_string(quote_attrib(self.x3).encode(ExternalEncoding),
                input_name='x3'), ))
        if self.y3 is not None and 'y3' not in already_processed:
            already_processed.append('y3')
            outfile.write(' y3=%s' % (self.gds_format_string(quote_attrib(self.y3).encode(ExternalEncoding),
                input_name='y3'), ))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            outfile.write(' x1=%s' % (self.gds_format_string(quote_attrib(self.x1).encode(ExternalEncoding),
                input_name='x1'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='dimension', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dimension'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            showIndent(outfile, level)
            outfile.write('y2 = "%s",\n' % (self.y2,))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            showIndent(outfile, level)
            outfile.write('x2 = "%s",\n' % (self.x2,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            showIndent(outfile, level)
            outfile.write('y1 = "%s",\n' % (self.y1,))
        if self.x3 is not None and 'x3' not in already_processed:
            already_processed.append('x3')
            showIndent(outfile, level)
            outfile.write('x3 = "%s",\n' % (self.x3,))
        if self.y3 is not None and 'y3' not in already_processed:
            already_processed.append('y3')
            showIndent(outfile, level)
            outfile.write('y3 = "%s",\n' % (self.y3,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            showIndent(outfile, level)
            outfile.write('x1 = "%s",\n' % (self.x1,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            self.y2 = value
        value = find_attr_value_('dtype', node)
        if value is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            self.dtype = value
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            self.x2 = value
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            self.y1 = value
        value = find_attr_value_('x3', node)
        if value is not None and 'x3' not in already_processed:
            already_processed.append('x3')
            self.x3 = value
        value = find_attr_value_('y3', node)
        if value is not None and 'y3' not in already_processed:
            already_processed.append('y3')
            self.y3 = value
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            self.x1 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dimension


class text(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, ratio=None, align=None, y=None, x=None, font=None, rot=None, size=None, valueOf_=None, mixedclass_=None, content_=None):
        self.layer = _cast(None, layer)
        self.ratio = _cast(None, ratio)
        self.align = _cast(None, align)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.font = _cast(None, font)
        self.rot = _cast(None, rot)
        self.size = _cast(None, size)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if text.subclass:
            return text.subclass(*args_, **kwargs_)
        else:
            return text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self):
        return self.layer
    def set_layer(self, layer):
        self.layer = layer
    def get_ratio(self):
        return self.ratio
    def set_ratio(self, ratio):
        self.ratio = ratio
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_font(self):
        return self.font
    def set_font(self, font):
        self.font = font
    def get_rot(self):
        return self.rot
    def set_rot(self, rot):
        self.rot = rot
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_valueOf_(self):
        return self.valueOf_
    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='t:', name_='text', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='text')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='text'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding),
                input_name='layer'), ))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            outfile.write(' ratio=%s' % (self.gds_format_string(quote_attrib(self.ratio).encode(ExternalEncoding),
                input_name='ratio'), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.append('align')
            outfile.write(' align=%s' % (self.gds_format_string(quote_attrib(self.align).encode(ExternalEncoding),
                input_name='align'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            outfile.write(' font=%s' % (self.gds_format_string(quote_attrib(self.font).encode(ExternalEncoding),
                input_name='font'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding),
                input_name='rot'), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            outfile.write(' size=%s' % (self.gds_format_string(quote_attrib(self.size).encode(ExternalEncoding),
                input_name='size'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='text', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='text'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            showIndent(outfile, level)
            outfile.write('ratio = "%s",\n' % (self.ratio,))
        if self.align is not None and 'align' not in already_processed:
            already_processed.append('align')
            showIndent(outfile, level)
            outfile.write('align = "%s",\n' % (self.align,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            showIndent(outfile, level)
            outfile.write('font = "%s",\n' % (self.font,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            showIndent(outfile, level)
            outfile.write('size = "%s",\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('ratio', node)
        if value is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            self.ratio = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.append('align')
            self.align = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('font', node)
        if value is not None and 'font' not in already_processed:
            already_processed.append('font')
            self.font = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.append('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class text


class circle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, layer=None, radius=None, width=None):
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.layer = _cast(None, layer)
        self.radius = _cast(None, radius)
        self.width = _cast(None, width)
        pass
    def factory(*args_, **kwargs_):
        if circle.subclass:
            return circle.subclass(*args_, **kwargs_)
        else:
            return circle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_layer(self):
        return self.layer
    def set_layer(self, layer):
        self.layer = layer
    def get_radius(self):
        return self.radius
    def set_radius(self, radius):
        self.radius = radius
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def export(self, outfile, level, namespace_='t:', name_='circle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='circle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='circle'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding),
                input_name='layer'), ))
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.append('radius')
            outfile.write(' radius=%s' % (self.gds_format_string(quote_attrib(self.radius).encode(ExternalEncoding),
                input_name='radius'), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width=%s' % (self.gds_format_string(quote_attrib(self.width).encode(ExternalEncoding),
                input_name='width'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='circle', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='circle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.append('radius')
            showIndent(outfile, level)
            outfile.write('radius = "%s",\n' % (self.radius,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = "%s",\n' % (self.width,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('radius', node)
        if value is not None and 'radius' not in already_processed:
            already_processed.append('radius')
            self.radius = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            self.width = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class circle


class rectangle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, y2=None, x2=None, y1=None, x1=None, rot=None):
        self.layer = _cast(None, layer)
        self.y2 = _cast(None, y2)
        self.x2 = _cast(None, x2)
        self.y1 = _cast(None, y1)
        self.x1 = _cast(None, x1)
        self.rot = _cast(None, rot)
        pass
    def factory(*args_, **kwargs_):
        if rectangle.subclass:
            return rectangle.subclass(*args_, **kwargs_)
        else:
            return rectangle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self):
        return self.layer
    def set_layer(self, layer): self.layer = layer
    def get_y2(self):
        return self.y2
    def set_y2(self, y2):
        self.y2 = y2
    def get_x2(self):
        return self.x2
    def set_x2(self, x2):
        self.x2 = x2
    def get_y1(self):
        return self.y1
    def set_y1(self, y1):
        self.y1 = y1
    def get_x1(self):
        return self.x1
    def set_x1(self, x1):
        self.x1 = x1
    def get_rot(self):
        return self.rot
    def set_rot(self, rot):
        self.rot = rot
    def export(self, outfile, level, namespace_='t:', name_='rectangle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rectangle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='rectangle'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding),
                input_name='layer'), ))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            outfile.write(' y2=%s' % (self.gds_format_string(quote_attrib(self.y2).encode(ExternalEncoding),
                input_name='y2'), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            outfile.write(' x2=%s' % (self.gds_format_string(quote_attrib(self.x2).encode(ExternalEncoding),
                input_name='x2'), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            outfile.write(' y1=%s' % (self.gds_format_string(quote_attrib(self.y1).encode(ExternalEncoding),
                input_name='y1'), ))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            outfile.write(' x1=%s' % (self.gds_format_string(quote_attrib(self.x1).encode(ExternalEncoding),
                input_name='x1'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding),
                input_name='rot'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='rectangle', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rectangle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            showIndent(outfile, level)
            outfile.write('y2 = "%s",\n' % (self.y2,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            showIndent(outfile, level)
            outfile.write('x2 = "%s",\n' % (self.x2,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            showIndent(outfile, level)
            outfile.write('y1 = "%s",\n' % (self.y1,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            showIndent(outfile, level)
            outfile.write('x1 = "%s",\n' % (self.x1,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            self.y2 = value
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            self.x2 = value
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            self.y1 = value
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            self.x1 = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rectangle


class frame(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y2=None, layer=None, rows=None, border_right=None, border_bottom=None, x2=None, border_top=None, border_left=None, y1=None, x1=None, columns=None):
        self.y2 = _cast(None, y2)
        self.layer = _cast(None, layer)
        self.rows = _cast(None, rows)
        self.border_right = _cast(None, border_right)
        self.border_bottom = _cast(None, border_bottom)
        self.x2 = _cast(None, x2)
        self.border_top = _cast(None, border_top)
        self.border_left = _cast(None, border_left)
        self.y1 = _cast(None, y1)
        self.x1 = _cast(None, x1)
        self.columns = _cast(None, columns)
        pass
    def factory(*args_, **kwargs_):
        if frame.subclass:
            return frame.subclass(*args_, **kwargs_)
        else:
            return frame(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y2(self):
        return self.y2
    def set_y2(self, y2):
        self.y2 = y2
    def get_layer(self):
        return self.layer
    def set_layer(self, layer):
        self.layer = layer
    def get_rows(self):
        return self.rows
    def set_rows(self, rows):
        self.rows = rows
    def get_border_right(self):
        return self.border_right
    def set_border_right(self, border_right):
        self.border_right = border_right
    def get_border_bottom(self):
        return self.border_bottom
    def set_border_bottom(self, border_bottom):
        self.border_bottom = border_bottom
    def get_x2(self):
        return self.x2
    def set_x2(self, x2):
        self.x2 = x2
    def get_border_top(self):
        return self.border_top
    def set_border_top(self, border_top):
        self.border_top = border_top
    def get_border_left(self):
        return self.border_left
    def set_border_left(self, border_left):
        self.border_left = border_left
    def get_y1(self):
        return self.y1
    def set_y1(self, y1):
        self.y1 = y1
    def get_x1(self):
        return self.x1
    def set_x1(self, x1):
        self.x1 = x1
    def get_columns(self):
        return self.columns
    def set_columns(self, columns):
        self.columns = columns
    def export(self, outfile, level, namespace_='t:', name_='frame', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='frame')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='frame'):
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            outfile.write(' y2=%s' % (self.gds_format_string(quote_attrib(self.y2).encode(ExternalEncoding),
                input_name='y2'), ))
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding),
                input_name='layer'), ))
        if self.rows is not None and 'rows' not in already_processed:
            already_processed.append('rows')
            outfile.write(' rows=%s' % (self.gds_format_string(quote_attrib(self.rows).encode(ExternalEncoding),
                input_name='rows'), ))
        if self.border_right is not None and 'border_right' not in already_processed:
            already_processed.append('border_right')
            outfile.write(' border-right=%s' 
                % (self.gds_format_string(quote_attrib(self.border_right).encode(ExternalEncoding),
                    input_name='border-right'), ))
        if self.border_bottom is not None and 'border_bottom' not in already_processed:
            already_processed.append('border_bottom')
            outfile.write(' border-bottom=%s' 
                % (self.gds_format_string(quote_attrib(self.border_bottom).encode(ExternalEncoding),
                    input_name='border-bottom'), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            outfile.write(' x2=%s' % (self.gds_format_string(quote_attrib(self.x2).encode(ExternalEncoding),
                input_name='x2'), ))
        if self.border_top is not None and 'border_top' not in already_processed:
            already_processed.append('border_top')
            outfile.write(' border-top=%s' 
                % (self.gds_format_string(quote_attrib(self.border_top).encode(ExternalEncoding),
                    input_name='border-top'), ))
        if self.border_left is not None and 'border_left' not in already_processed:
            already_processed.append('border_left')
            outfile.write(' border-left=%s' 
                % (self.gds_format_string(quote_attrib(self.border_left).encode(ExternalEncoding),
                    input_name='border-left'), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            outfile.write(' y1=%s' % (self.gds_format_string(quote_attrib(self.y1).encode(ExternalEncoding),
                input_name='y1'), ))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            outfile.write(' x1=%s' % (self.gds_format_string(quote_attrib(self.x1).encode(ExternalEncoding),
                input_name='x1'), ))
        if self.columns is not None and 'columns' not in already_processed:
            already_processed.append('columns')
            outfile.write(' columns=%s' % (self.gds_format_string(quote_attrib(self.columns).encode(ExternalEncoding), input_name='columns'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='frame', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='frame'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            showIndent(outfile, level)
            outfile.write('y2 = "%s",\n' % (self.y2,))
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.rows is not None and 'rows' not in already_processed:
            already_processed.append('rows')
            showIndent(outfile, level)
            outfile.write('rows = "%s",\n' % (self.rows,))
        if self.border_right is not None and 'border_right' not in already_processed:
            already_processed.append('border_right')
            showIndent(outfile, level)
            outfile.write('border_right = "%s",\n' % (self.border_right,))
        if self.border_bottom is not None and 'border_bottom' not in already_processed:
            already_processed.append('border_bottom')
            showIndent(outfile, level)
            outfile.write('border_bottom = "%s",\n' % (self.border_bottom,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            showIndent(outfile, level)
            outfile.write('x2 = "%s",\n' % (self.x2,))
        if self.border_top is not None and 'border_top' not in already_processed:
            already_processed.append('border_top')
            showIndent(outfile, level)
            outfile.write('border_top = "%s",\n' % (self.border_top,))
        if self.border_left is not None and 'border_left' not in already_processed:
            already_processed.append('border_left')
            showIndent(outfile, level)
            outfile.write('border_left = "%s",\n' % (self.border_left,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            showIndent(outfile, level)
            outfile.write('y1 = "%s",\n' % (self.y1,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            showIndent(outfile, level)
            outfile.write('x1 = "%s",\n' % (self.x1,))
        if self.columns is not None and 'columns' not in already_processed:
            already_processed.append('columns')
            showIndent(outfile, level)
            outfile.write('columns = "%s",\n' % (self.columns,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            self.y2 = value
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('rows', node)
        if value is not None and 'rows' not in already_processed:
            already_processed.append('rows')
            self.rows = value
        value = find_attr_value_('border-right', node)
        if value is not None and 'border-right' not in already_processed:
            already_processed.append('border-right')
            self.border_right = value
        value = find_attr_value_('border-bottom', node)
        if value is not None and 'border-bottom' not in already_processed:
            already_processed.append('border-bottom')
            self.border_bottom = value
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            self.x2 = value
        value = find_attr_value_('border-top', node)
        if value is not None and 'border-top' not in already_processed:
            already_processed.append('border-top')
            self.border_top = value
        value = find_attr_value_('border-left', node)
        if value is not None and 'border-left' not in already_processed:
            already_processed.append('border-left')
            self.border_left = value
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            self.y1 = value
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            self.x1 = value
        value = find_attr_value_('columns', node)
        if value is not None and 'columns' not in already_processed:
            already_processed.append('columns')
            self.columns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class frame


class hole(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, drill=None):
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.drill = _cast(None, drill)
        pass
    def factory(*args_, **kwargs_):
        if hole.subclass:
            return hole.subclass(*args_, **kwargs_)
        else:
            return hole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_drill(self):
        return self.drill
    def set_drill(self, drill):
        self.drill = drill
    def export(self, outfile, level, namespace_='t:', name_='hole', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hole')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='hole'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            outfile.write(' drill=%s' % (self.gds_format_string(quote_attrib(self.drill).encode(ExternalEncoding),
                input_name='drill'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='hole', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='hole'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            showIndent(outfile, level)
            outfile.write('drill = "%s",\n' % (self.drill,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('drill', node)
        if value is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            self.drill = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class hole


class pad(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, diameter=None, thermals=None, name=None, stop=None, shape=None, drill=None, y=None, x=None, rot=None, first=None):
        self.diameter = _cast(None, diameter)
        self.thermals = _cast(None, thermals)
        self.name = _cast(None, name)
        self.stop = _cast(None, stop)
        self.shape = _cast(None, shape)
        self.drill = _cast(None, drill)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.rot = _cast(None, rot)
        self.first = _cast(None, first)
        pass
    def factory(*args_, **kwargs_):
        if pad.subclass:
            return pad.subclass(*args_, **kwargs_)
        else:
            return pad(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_diameter(self):
        return self.diameter
    def set_diameter(self, diameter):
        self.diameter = diameter
    def get_thermals(self):
        return self.thermals
    def set_thermals(self, thermals):
        self.thermals = thermals
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_stop(self):
        return self.stop
    def set_stop(self, stop):
        self.stop = stop
    def get_shape(self):
        return self.shape
    def set_shape(self, shape):
        self.shape = shape
    def get_drill(self):
        return self.drill
    def set_drill(self, drill):
        self.drill = drill
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_rot(self):
        return self.rot
    def set_rot(self, rot):
        self.rot = rot
    def get_first(self):
        return self.first
    def set_first(self, first):
        self.first = first
    def export(self, outfile, level, namespace_='t:', name_='pad', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pad')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='pad'):
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            outfile.write(' diameter=%s' 
                % (self.gds_format_string(quote_attrib(self.diameter).encode(ExternalEncoding),
                    input_name='diameter'), ))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            outfile.write(' thermals=%s' 
                % (self.gds_format_string(quote_attrib(self.thermals).encode(ExternalEncoding),
                input_name='thermals'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            outfile.write(' stop=%s' % (self.gds_format_string(quote_attrib(self.stop).encode(ExternalEncoding),
                input_name='stop'), ))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            outfile.write(' shape=%s' % (self.gds_format_string(quote_attrib(self.shape).encode(ExternalEncoding),
                input_name='shape'), ))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            outfile.write(' drill=%s' % (self.gds_format_string(quote_attrib(self.drill).encode(ExternalEncoding),
                input_name='drill'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding),
                input_name='rot'), ))
        if self.first is not None and 'first' not in already_processed:
            already_processed.append('first')
            outfile.write(' first=%s' % (self.gds_format_string(quote_attrib(self.first).encode(ExternalEncoding),
                input_name='first'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='pad', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pad'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            showIndent(outfile, level)
            outfile.write('diameter = "%s",\n' % (self.diameter,))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            showIndent(outfile, level)
            outfile.write('thermals = "%s",\n' % (self.thermals,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            showIndent(outfile, level)
            outfile.write('stop = "%s",\n' % (self.stop,))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            showIndent(outfile, level)
            outfile.write('shape = "%s",\n' % (self.shape,))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            showIndent(outfile, level)
            outfile.write('drill = "%s",\n' % (self.drill,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.first is not None and 'first' not in already_processed:
            already_processed.append('first')
            showIndent(outfile, level)
            outfile.write('first = "%s",\n' % (self.first,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('diameter', node)
        if value is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            self.diameter = value
        value = find_attr_value_('thermals', node)
        if value is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            self.thermals = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('stop', node)
        if value is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            self.stop = value
        value = find_attr_value_('shape', node)
        if value is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            self.shape = value
        value = find_attr_value_('drill', node)
        if value is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            self.drill = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('first', node)
        if value is not None and 'first' not in already_processed:
            already_processed.append('first')
            self.first = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pad


class smd(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, thermals=None, name=None, stop=None, roundness=None, dx=None, dy=None, y=None, x=None, rot=None, cream=None):
        self.layer = _cast(None, layer)
        self.thermals = _cast(None, thermals)
        self.name = _cast(None, name)
        self.stop = _cast(None, stop)
        self.roundness = _cast(None, roundness)
        self.dx = _cast(None, dx)
        self.dy = _cast(None, dy)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.rot = _cast(None, rot)
        self.cream = _cast(None, cream)
        pass
    def factory(*args_, **kwargs_):
        if smd.subclass:
            return smd.subclass(*args_, **kwargs_)
        else:
            return smd(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self):
        return self.layer
    def set_layer(self, layer):
        self.layer = layer
    def get_thermals(self):
        return self.thermals
    def set_thermals(self, thermals):
        self.thermals = thermals
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_stop(self):
        return self.stop
    def set_stop(self, stop):
        self.stop = stop
    def get_roundness(self):
        return self.roundness
    def set_roundness(self, roundness):
        self.roundness = roundness
    def get_dx(self):
        return self.dx
    def set_dx(self, dx):
        self.dx = dx
    def get_dy(self):
        return self.dy
    def set_dy(self, dy):
        self.dy = dy
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_rot(self):
        return self.rot
    def set_rot(self, rot):
        self.rot = rot
    def get_cream(self):
        return self.cream
    def set_cream(self, cream):
        self.cream = cream
    def export(self, outfile, level, namespace_='t:', name_='smd', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='smd')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='smd'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding),
                input_name='layer'), ))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            outfile.write(' thermals=%s' 
                % (self.gds_format_string(quote_attrib(self.thermals).encode(ExternalEncoding),
                    input_name='thermals'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            outfile.write(' stop=%s' % (self.gds_format_string(quote_attrib(self.stop).encode(ExternalEncoding),
                input_name='stop'), ))
        if self.roundness is not None and 'roundness' not in already_processed:
            already_processed.append('roundness')
            outfile.write(' roundness=%s' 
                % (self.gds_format_string(quote_attrib(self.roundness).encode(ExternalEncoding),
                    input_name='roundness'), ))
        if self.dx is not None and 'dx' not in already_processed:
            already_processed.append('dx')
            outfile.write(' dx=%s' % (self.gds_format_string(quote_attrib(self.dx).encode(ExternalEncoding),
                input_name='dx'), ))
        if self.dy is not None and 'dy' not in already_processed:
            already_processed.append('dy')
            outfile.write(' dy=%s' % (self.gds_format_string(quote_attrib(self.dy).encode(ExternalEncoding),
                input_name='dy'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding),
                input_name='rot'), ))
        if self.cream is not None and 'cream' not in already_processed:
            already_processed.append('cream')
            outfile.write(' cream=%s' % (self.gds_format_string(quote_attrib(self.cream).encode(ExternalEncoding),
                input_name='cream'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='smd', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='smd'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            showIndent(outfile, level)
            outfile.write('thermals = "%s",\n' % (self.thermals,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            showIndent(outfile, level)
            outfile.write('stop = "%s",\n' % (self.stop,))
        if self.roundness is not None and 'roundness' not in already_processed:
            already_processed.append('roundness')
            showIndent(outfile, level)
            outfile.write('roundness = "%s",\n' % (self.roundness,))
        if self.dx is not None and 'dx' not in already_processed:
            already_processed.append('dx')
            showIndent(outfile, level)
            outfile.write('dx = "%s",\n' % (self.dx,))
        if self.dy is not None and 'dy' not in already_processed:
            already_processed.append('dy')
            showIndent(outfile, level)
            outfile.write('dy = "%s",\n' % (self.dy,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.cream is not None and 'cream' not in already_processed:
            already_processed.append('cream')
            showIndent(outfile, level)
            outfile.write('cream = "%s",\n' % (self.cream,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('thermals', node)
        if value is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            self.thermals = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('stop', node)
        if value is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            self.stop = value
        value = find_attr_value_('roundness', node)
        if value is not None and 'roundness' not in already_processed:
            already_processed.append('roundness')
            self.roundness = value
        value = find_attr_value_('dx', node)
        if value is not None and 'dx' not in already_processed:
            already_processed.append('dx')
            self.dx = value
        value = find_attr_value_('dy', node)
        if value is not None and 'dy' not in already_processed:
            already_processed.append('dy')
            self.dy = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('cream', node)
        if value is not None and 'cream' not in already_processed:
            already_processed.append('cream')
            self.cream = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class smd


class element(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, locked=None, name=None, package=None, value=None, smashed=None, library=None, y=None, x=None, rot=None, attribute=None, variant=None):
        self.locked = _cast(None, locked)
        self.name = _cast(None, name)
        self.package = _cast(None, package)
        self.value = _cast(None, value)
        self.smashed = _cast(None, smashed)
        self.library = _cast(None, library)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.rot = _cast(None, rot)
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        if variant is None:
            self.variant = []
        else:
            self.variant = variant
    def factory(*args_, **kwargs_):
        if element.subclass:
            return element.subclass(*args_, **kwargs_)
        else:
            return element(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute(self, index, value):
        self.attribute[index] = value
    def get_variant(self):
        return self.variant
    def set_variant(self, variant):
        self.variant = variant
    def add_variant(self, value):
        self.variant.append(value)
    def insert_variant(self, index, value):
        self.variant[index] = value
    def get_locked(self):
        return self.locked
    def set_locked(self, locked):
        self.locked = locked
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_package(self):
        return self.package
    def set_package(self, package):
        self.package = package
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_smashed(self):
        return self.smashed
    def set_smashed(self, smashed):
        self.smashed = smashed
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_rot(self):
        return self.rot
    def set_rot(self, rot):
        self.rot = rot
    def export(self, outfile, level, namespace_='t:', name_='element', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='element')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='element'):
        if self.locked is not None and 'locked' not in already_processed:
            already_processed.append('locked')
            outfile.write(' locked=%s' % (self.gds_format_string(quote_attrib(self.locked).encode(ExternalEncoding),
                input_name='locked'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.package is not None and 'package' not in already_processed:
            already_processed.append('package')
            outfile.write(' package=%s' % (self.gds_format_string(quote_attrib(self.package).encode(ExternalEncoding),
                input_name='package'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding),
                input_name='value'), ))
        if self.smashed is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            outfile.write(' smashed=%s' % (self.gds_format_string(quote_attrib(self.smashed).encode(ExternalEncoding),
                input_name='smashed'), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.append('library')
            outfile.write(' library=%s' % (self.gds_format_string(quote_attrib(self.library).encode(ExternalEncoding),
                input_name='library'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding),
                input_name='rot'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='element', fromsubclass_=False):
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute')
        for variant_ in self.variant:
            variant_.export(outfile, level, namespace_, name_='variant')
    def hasContent_(self):
        if (
            self.attribute or
            self.variant
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='element'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.locked is not None and 'locked' not in already_processed:
            already_processed.append('locked')
            showIndent(outfile, level)
            outfile.write('locked = "%s",\n' % (self.locked,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.package is not None and 'package' not in already_processed:
            already_processed.append('package')
            showIndent(outfile, level)
            outfile.write('package = "%s",\n' % (self.package,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        if self.smashed is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            showIndent(outfile, level)
            outfile.write('smashed = "%s",\n' % (self.smashed,))
        if self.library is not None and 'library' not in already_processed:
            already_processed.append('library')
            showIndent(outfile, level)
            outfile.write('library = "%s",\n' % (self.library,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variant=[\n')
        level += 1
        for variant_ in self.variant:
            showIndent(outfile, level)
            outfile.write('model_.variant(\n')
            variant_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locked', node)
        if value is not None and 'locked' not in already_processed:
            already_processed.append('locked')
            self.locked = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('package', node)
        if value is not None and 'package' not in already_processed:
            already_processed.append('package')
            self.package = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('smashed', node)
        if value is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            self.smashed = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.append('library')
            self.library = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
        elif nodeName_ == 'variant':
            obj_ = variant.factory()
            obj_.build(child_)
            self.variant.append(obj_)
# end class element


class via(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, diameter=None, extent=None, shape=None, alwaysstop=None, drill=None, y=None, x=None):
        self.diameter = _cast(None, diameter)
        self.extent = _cast(None, extent)
        self.shape = _cast(None, shape)
        self.alwaysstop = _cast(None, alwaysstop)
        self.drill = _cast(None, drill)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        pass
    def factory(*args_, **kwargs_):
        if via.subclass:
            return via.subclass(*args_, **kwargs_)
        else:
            return via(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_diameter(self):
        return self.diameter
    def set_diameter(self, diameter):
        self.diameter = diameter
    def get_extent(self):
        return self.extent
    def set_extent(self, extent):
        self.extent = extent
    def get_shape(self):
        return self.shape
    def set_shape(self, shape):
        self.shape = shape
    def get_alwaysstop(self):
        return self.alwaysstop
    def set_alwaysstop(self, alwaysstop):
        self.alwaysstop = alwaysstop
    def get_drill(self):
        return self.drill
    def set_drill(self, drill):
        self.drill = drill
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def export(self, outfile, level, namespace_='t:', name_='via', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='via')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='via'):
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            outfile.write(' diameter=%s' 
                % (self.gds_format_string(quote_attrib(self.diameter).encode(ExternalEncoding),
                    input_name='diameter'), ))
        if self.extent is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            outfile.write(' extent=%s' % (self.gds_format_string(quote_attrib(self.extent).encode(ExternalEncoding),
                input_name='extent'), ))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            outfile.write(' shape=%s' % (self.gds_format_string(quote_attrib(self.shape).encode(ExternalEncoding),
                input_name='shape'), ))
        if self.alwaysstop is not None and 'alwaysstop' not in already_processed:
            already_processed.append('alwaysstop')
            outfile.write(' alwaysstop=%s' 
                % (self.gds_format_string(quote_attrib(self.alwaysstop).encode(ExternalEncoding),
                    input_name='alwaysstop'), ))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            outfile.write(' drill=%s' % (self.gds_format_string(quote_attrib(self.drill).encode(ExternalEncoding),
                input_name='drill'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='via', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='via'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            showIndent(outfile, level)
            outfile.write('diameter = "%s",\n' % (self.diameter,))
        if self.extent is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            showIndent(outfile, level)
            outfile.write('extent = "%s",\n' % (self.extent,))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            showIndent(outfile, level)
            outfile.write('shape = "%s",\n' % (self.shape,))
        if self.alwaysstop is not None and 'alwaysstop' not in already_processed:
            already_processed.append('alwaysstop')
            showIndent(outfile, level)
            outfile.write('alwaysstop = "%s",\n' % (self.alwaysstop,))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            showIndent(outfile, level)
            outfile.write('drill = "%s",\n' % (self.drill,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('diameter', node)
        if value is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            self.diameter = value
        value = find_attr_value_('extent', node)
        if value is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            self.extent = value
        value = find_attr_value_('shape', node)
        if value is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            self.shape = value
        value = find_attr_value_('alwaysstop', node)
        if value is not None and 'alwaysstop' not in already_processed:
            already_processed.append('alwaysstop')
            self.alwaysstop = value
        value = find_attr_value_('drill', node)
        if value is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            self.drill = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class via


class polygon(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, thermals=None, spacing=None, orphans=None, isolate=None, pour=None, width=None, rank=None, vertex=None):
        self.layer = _cast(None, layer)
        self.thermals = _cast(None, thermals)
        self.spacing = _cast(None, spacing)
        self.orphans = _cast(None, orphans)
        self.isolate = _cast(None, isolate)
        self.pour = _cast(None, pour)
        self.width = _cast(None, width)
        self.rank = _cast(None, rank)
        if vertex is None:
            self.vertex = []
        else:
            self.vertex = vertex
    def factory(*args_, **kwargs_):
        if polygon.subclass:
            return polygon.subclass(*args_, **kwargs_)
        else:
            return polygon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vertex(self):
        return self.vertex
    def set_vertex(self, vertex):
        self.vertex = vertex
    def add_vertex(self, value):
        self.vertex.append(value)
    def insert_vertex(self, index, value):
        self.vertex[index] = value
    def get_layer(self):
        return self.layer
    def set_layer(self, layer):
        self.layer = layer
    def get_thermals(self):
        return self.thermals
    def set_thermals(self, thermals):
        self.thermals = thermals
    def get_spacing(self):
        return self.spacing
    def set_spacing(self, spacing):
        self.spacing = spacing
    def get_orphans(self):
        return self.orphans
    def set_orphans(self, orphans):
        self.orphans = orphans
    def get_isolate(self):
        return self.isolate
    def set_isolate(self, isolate):
        self.isolate = isolate
    def get_pour(self):
        return self.pour
    def set_pour(self, pour):
        self.pour = pour
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_rank(self):
        return self.rank
    def set_rank(self, rank):
        self.rank = rank
    def export(self, outfile, level, namespace_='t:', name_='polygon', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polygon')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='polygon'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding),
                input_name='layer'), ))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            outfile.write(' thermals=%s' 
                % (self.gds_format_string(quote_attrib(self.thermals).encode(ExternalEncoding),
                    input_name='thermals'), ))
        if self.spacing is not None and 'spacing' not in already_processed:
            already_processed.append('spacing')
            outfile.write(' spacing=%s' % (self.gds_format_string(quote_attrib(self.spacing).encode(ExternalEncoding),
                input_name='spacing'), ))
        if self.orphans is not None and 'orphans' not in already_processed:
            already_processed.append('orphans')
            outfile.write(' orphans=%s' % (self.gds_format_string(quote_attrib(self.orphans).encode(ExternalEncoding),
                input_name='orphans'), ))
        if self.isolate is not None and 'isolate' not in already_processed:
            already_processed.append('isolate')
            outfile.write(' isolate=%s' % (self.gds_format_string(quote_attrib(self.isolate).encode(ExternalEncoding),
                input_name='isolate'), ))
        if self.pour is not None and 'pour' not in already_processed:
            already_processed.append('pour')
            outfile.write(' pour=%s' % (self.gds_format_string(quote_attrib(self.pour).encode(ExternalEncoding),
                input_name='pour'), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width=%s' % (self.gds_format_string(quote_attrib(self.width).encode(ExternalEncoding),
                input_name='width'), ))
        if self.rank is not None and 'rank' not in already_processed:
            already_processed.append('rank')
            outfile.write(' rank=%s' % (self.gds_format_string(quote_attrib(self.rank).encode(ExternalEncoding),
                input_name='rank'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='polygon', fromsubclass_=False):
        for vertex_ in self.vertex:
            vertex_.export(outfile, level, namespace_, name_='vertex')
    def hasContent_(self):
        if (
            self.vertex
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='polygon'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            showIndent(outfile, level)
            outfile.write('thermals = "%s",\n' % (self.thermals,))
        if self.spacing is not None and 'spacing' not in already_processed:
            already_processed.append('spacing')
            showIndent(outfile, level)
            outfile.write('spacing = "%s",\n' % (self.spacing,))
        if self.orphans is not None and 'orphans' not in already_processed:
            already_processed.append('orphans')
            showIndent(outfile, level)
            outfile.write('orphans = "%s",\n' % (self.orphans,))
        if self.isolate is not None and 'isolate' not in already_processed:
            already_processed.append('isolate')
            showIndent(outfile, level)
            outfile.write('isolate = "%s",\n' % (self.isolate,))
        if self.pour is not None and 'pour' not in already_processed:
            already_processed.append('pour')
            showIndent(outfile, level)
            outfile.write('pour = "%s",\n' % (self.pour,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = "%s",\n' % (self.width,))
        if self.rank is not None and 'rank' not in already_processed:
            already_processed.append('rank')
            showIndent(outfile, level)
            outfile.write('rank = "%s",\n' % (self.rank,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('vertex=[\n')
        level += 1
        for vertex_ in self.vertex:
            showIndent(outfile, level)
            outfile.write('model_.vertex(\n')
            vertex_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('thermals', node)
        if value is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            self.thermals = value
        value = find_attr_value_('spacing', node)
        if value is not None and 'spacing' not in already_processed:
            already_processed.append('spacing')
            self.spacing = value
        value = find_attr_value_('orphans', node)
        if value is not None and 'orphans' not in already_processed:
            already_processed.append('orphans')
            self.orphans = value
        value = find_attr_value_('isolate', node)
        if value is not None and 'isolate' not in already_processed:
            already_processed.append('isolate')
            self.isolate = value
        value = find_attr_value_('pour', node)
        if value is not None and 'pour' not in already_processed:
            already_processed.append('pour')
            self.pour = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            self.width = value
        value = find_attr_value_('rank', node)
        if value is not None and 'rank' not in already_processed:
            already_processed.append('rank')
            self.rank = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vertex':
            obj_ = vertex.factory()
            obj_.build(child_)
            self.vertex.append(obj_)
# end class polygon


class vertex(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, curve=None):
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.curve = _cast(None, curve)
        pass
    def factory(*args_, **kwargs_):
        if vertex.subclass:
            return vertex.subclass(*args_, **kwargs_)
        else:
            return vertex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_curve(self): return self.curve
    def set_curve(self, curve): self.curve = curve
    def export(self, outfile, level, namespace_='t:', name_='vertex', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vertex')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='vertex'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
        if self.curve is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            outfile.write(' curve=%s' % (self.gds_format_string(quote_attrib(self.curve).encode(ExternalEncoding),
                input_name='curve'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='vertex', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vertex'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.curve is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            showIndent(outfile, level)
            outfile.write('curve = "%s",\n' % (self.curve,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('curve', node)
        if value is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            self.curve = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vertex


class pin(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, function=None, direction=None, name=None, visible=None, length=None, y=None, x=None, rot=None, swaplevel=None):
        self.function = _cast(None, function)
        self.direction = _cast(None, direction)
        self.name = _cast(None, name)
        self.visible = _cast(None, visible)
        self.length = _cast(None, length)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.rot = _cast(None, rot)
        self.swaplevel = _cast(None, swaplevel)
        pass
    def factory(*args_, **kwargs_):
        if pin.subclass:
            return pin.subclass(*args_, **kwargs_)
        else:
            return pin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_function(self):
        return self.function
    def set_function(self, function):
        self.function = function
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_rot(self):
        return self.rot
    def set_rot(self, rot):
        self.rot = rot
    def get_swaplevel(self):
        return self.swaplevel
    def set_swaplevel(self, swaplevel):
        self.swaplevel = swaplevel
    def export(self, outfile, level, namespace_='t:', name_='pin', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pin')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='pin'):
        if self.function is not None and 'function' not in already_processed:
            already_processed.append('function')
            outfile.write(' function=%s' 
                % (self.gds_format_string(quote_attrib(self.function).encode(ExternalEncoding),
                input_name='function'), ))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            outfile.write(' direction=%s' 
                % (self.gds_format_string(quote_attrib(self.direction).encode(ExternalEncoding),
                    input_name='direction'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            outfile.write(' visible=%s' % (self.gds_format_string(quote_attrib(self.visible).encode(ExternalEncoding),
                input_name='visible'), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            outfile.write(' length=%s' % (self.gds_format_string(quote_attrib(self.length).encode(ExternalEncoding),
                input_name='length'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding),
                input_name='rot'), ))
        if self.swaplevel is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            outfile.write(' swaplevel=%s' 
                % (self.gds_format_string(quote_attrib(self.swaplevel).encode(ExternalEncoding),
                input_name='swaplevel'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='pin', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pin'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.function is not None and 'function' not in already_processed:
            already_processed.append('function')
            showIndent(outfile, level)
            outfile.write('function = "%s",\n' % (self.function,))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            showIndent(outfile, level)
            outfile.write('direction = "%s",\n' % (self.direction,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            showIndent(outfile, level)
            outfile.write('visible = "%s",\n' % (self.visible,))
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            showIndent(outfile, level)
            outfile.write('length = "%s",\n' % (self.length,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.swaplevel is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            showIndent(outfile, level)
            outfile.write('swaplevel = "%s",\n' % (self.swaplevel,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('function', node)
        if value is not None and 'function' not in already_processed:
            already_processed.append('function')
            self.function = value
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            self.direction = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            self.visible = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.append('length')
            self.length = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('swaplevel', node)
        if value is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            self.swaplevel = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pin


class part(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, deviceset=None, value=None, library=None, device=None, technology=None, attribute=None, variant=None):
        self.name = _cast(None, name)
        self.deviceset = _cast(None, deviceset)
        self.value = _cast(None, value)
        self.library = _cast(None, library)
        self.device = _cast(None, device)
        self.technology = _cast(None, technology)
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        if variant is None:
            self.variant = []
        else:
            self.variant = variant
    def factory(*args_, **kwargs_):
        if part.subclass:
            return part.subclass(*args_, **kwargs_)
        else:
            return part(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute(self, index, value):
        self.attribute[index] = value
    def get_variant(self):
        return self.variant
    def set_variant(self, variant):
        self.variant = variant
    def add_variant(self, value):
        self.variant.append(value)
    def insert_variant(self, index, value):
        self.variant[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_deviceset(self):
        return self.deviceset
    def set_deviceset(self, deviceset):
        self.deviceset = deviceset
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_device(self):
        return self.device
    def set_device(self, device):
        self.device = device
    def get_technology(self):
        return self.technology
    def set_technology(self, technology):
        self.technology = technology
    def export(self, outfile, level, namespace_='t:', name_='part', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='part')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='part'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.deviceset is not None and 'deviceset' not in already_processed:
            already_processed.append('deviceset')
            outfile.write(' deviceset=%s' 
                % (self.gds_format_string(quote_attrib(self.deviceset).encode(ExternalEncoding),
                input_name='deviceset'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding),
                input_name='value'), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.append('library')
            outfile.write(' library=%s' % (self.gds_format_string(quote_attrib(self.library).encode(ExternalEncoding),
                input_name='library'), ))
        if self.device is not None and 'device' not in already_processed:
            already_processed.append('device')
            outfile.write(' device=%s' % (self.gds_format_string(quote_attrib(self.device).encode(ExternalEncoding),
                input_name='device'), ))
        if self.technology is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            outfile.write(' technology=%s' 
                % (self.gds_format_string(quote_attrib(self.technology).encode(ExternalEncoding),
                input_name='technology'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='part', fromsubclass_=False):
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute')
        for variant_ in self.variant:
            variant_.export(outfile, level, namespace_, name_='variant')
    def hasContent_(self):
        if (
            self.attribute or
            self.variant
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='part'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.deviceset is not None and 'deviceset' not in already_processed:
            already_processed.append('deviceset')
            showIndent(outfile, level)
            outfile.write('deviceset = "%s",\n' % (self.deviceset,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        if self.library is not None and 'library' not in already_processed:
            already_processed.append('library')
            showIndent(outfile, level)
            outfile.write('library = "%s",\n' % (self.library,))
        if self.device is not None and 'device' not in already_processed:
            already_processed.append('device')
            showIndent(outfile, level)
            outfile.write('device = "%s",\n' % (self.device,))
        if self.technology is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            showIndent(outfile, level)
            outfile.write('technology = "%s",\n' % (self.technology,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variant=[\n')
        level += 1
        for variant_ in self.variant:
            showIndent(outfile, level)
            outfile.write('model_.variant(\n')
            variant_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('deviceset', node)
        if value is not None and 'deviceset' not in already_processed:
            already_processed.append('deviceset')
            self.deviceset = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.append('library')
            self.library = value
        value = find_attr_value_('device', node)
        if value is not None and 'device' not in already_processed:
            already_processed.append('device')
            self.device = value
        value = find_attr_value_('technology', node)
        if value is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            self.technology = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
        elif nodeName_ == 'variant':
            obj_ = variant.factory()
            obj_.build(child_)
            self.variant.append(obj_)
# end class part


class instance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, smashed=None, part=None, x=None, y=None, gate=None, rot=None, attribute=None):
        self.smashed = _cast(None, smashed)
        self.part = _cast(None, part)
        self.x = _cast(None, x)
        self.y = _cast(None, y)
        self.gate = _cast(None, gate)
        self.rot = _cast(None, rot)
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if instance.subclass:
            return instance.subclass(*args_, **kwargs_)
        else:
            return instance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute(self, index, value):
        self.attribute[index] = value
    def get_smashed(self):
        return self.smashed
    def set_smashed(self, smashed):
        self.smashed = smashed
    def get_part(self):
        return self.part
    def set_part(self, part):
        self.part = part
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_gate(self):
        return self.gate
    def set_gate(self, gate):
        self.gate = gate
    def get_rot(self):
        return self.rot
    def set_rot(self, rot):
        self.rot = rot
    def export(self, outfile, level, namespace_='t:', name_='instance', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='instance')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='instance'):
        if self.smashed is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            outfile.write(' smashed=%s' % (self.gds_format_string(quote_attrib(self.smashed).encode(ExternalEncoding),
                input_name='smashed'), ))
        if self.part is not None and 'part' not in already_processed:
            already_processed.append('part')
            outfile.write(' part=%s' % (self.gds_format_string(quote_attrib(self.part).encode(ExternalEncoding),
                input_name='part'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            outfile.write(' gate=%s' % (self.gds_format_string(quote_attrib(self.gate).encode(ExternalEncoding),
                input_name='gate'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding),
                input_name='rot'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='instance', fromsubclass_=False):
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute')
    def hasContent_(self):
        if (
            self.attribute
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='instance'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.smashed is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            showIndent(outfile, level)
            outfile.write('smashed = "%s",\n' % (self.smashed,))
        if self.part is not None and 'part' not in already_processed:
            already_processed.append('part')
            showIndent(outfile, level)
            outfile.write('part = "%s",\n' % (self.part,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            showIndent(outfile, level)
            outfile.write('gate = "%s",\n' % (self.gate,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smashed', node)
        if value is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            self.smashed = value
        value = find_attr_value_('part', node)
        if value is not None and 'part' not in already_processed:
            already_processed.append('part')
            self.part = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('gate', node)
        if value is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            self.gate = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
# end class instance


class label(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, xref=None, ratio=None, y=None, x=None, font=None, rot=None, size=None):
        self.layer = _cast(None, layer)
        self.xref = _cast(None, xref)
        self.ratio = _cast(None, ratio)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.font = _cast(None, font)
        self.rot = _cast(None, rot)
        self.size = _cast(None, size)
        pass
    def factory(*args_, **kwargs_):
        if label.subclass:
            return label.subclass(*args_, **kwargs_)
        else:
            return label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self):
        return self.layer
    def set_layer(self, layer):
        self.layer = layer
    def get_xref(self):
        return self.xref
    def set_xref(self, xref):
        self.xref = xref
    def get_ratio(self):
        return self.ratio
    def set_ratio(self, ratio):
        self.ratio = ratio
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_font(self):
        return self.font
    def set_font(self, font):
        self.font = font
    def get_rot(self):
        return self.rot
    def set_rot(self, rot):
        self.rot = rot
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def export(self, outfile, level, namespace_='t:', name_='label', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='label')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='label'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding),
                input_name='layer'), ))
        if self.xref is not None and 'xref' not in already_processed:
            already_processed.append('xref')
            outfile.write(' xref=%s' % (self.gds_format_string(quote_attrib(self.xref).encode(ExternalEncoding),
                input_name='xref'), ))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            outfile.write(' ratio=%s' % (self.gds_format_string(quote_attrib(self.ratio).encode(ExternalEncoding),
                input_name='ratio'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            outfile.write(' font=%s' % (self.gds_format_string(quote_attrib(self.font).encode(ExternalEncoding),
                input_name='font'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding),
                input_name='rot'), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            outfile.write(' size=%s' % (self.gds_format_string(quote_attrib(self.size).encode(ExternalEncoding),
                input_name='size'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='label', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='label'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.xref is not None and 'xref' not in already_processed:
            already_processed.append('xref')
            showIndent(outfile, level)
            outfile.write('xref = "%s",\n' % (self.xref,))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            showIndent(outfile, level)
            outfile.write('ratio = "%s",\n' % (self.ratio,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            showIndent(outfile, level)
            outfile.write('font = "%s",\n' % (self.font,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            showIndent(outfile, level)
            outfile.write('size = "%s",\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('xref', node)
        if value is not None and 'xref' not in already_processed:
            already_processed.append('xref')
            self.xref = value
        value = find_attr_value_('ratio', node)
        if value is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            self.ratio = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('font', node)
        if value is not None and 'font' not in already_processed:
            already_processed.append('font')
            self.font = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.append('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class label


class junction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None):
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        pass
    def factory(*args_, **kwargs_):
        if junction.subclass:
            return junction.subclass(*args_, **kwargs_)
        else:
            return junction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def export(self, outfile, level, namespace_='t:', name_='junction', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='junction')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='junction'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='junction', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='junction'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class junction


class connect(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gate=None, route=None, pad=None, pin=None):
        self.gate = _cast(None, gate)
        self.route = _cast(None, route)
        self.pad = _cast(None, pad)
        self.pin = _cast(None, pin)
        pass
    def factory(*args_, **kwargs_):
        if connect.subclass:
            return connect.subclass(*args_, **kwargs_)
        else:
            return connect(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gate(self): return self.gate
    def set_gate(self, gate): self.gate = gate
    def get_route(self): return self.route
    def set_route(self, route): self.route = route
    def get_pad(self): return self.pad
    def set_pad(self, pad): self.pad = pad
    def get_pin(self): return self.pin
    def set_pin(self, pin): self.pin = pin
    def export(self, outfile, level, namespace_='t:', name_='connect', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='connect')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='connect'):
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            outfile.write(' gate=%s' % (self.gds_format_string(quote_attrib(self.gate).encode(ExternalEncoding),
                input_name='gate'), ))
        if self.route is not None and 'route' not in already_processed:
            already_processed.append('route')
            outfile.write(' route=%s' % (self.gds_format_string(quote_attrib(self.route).encode(ExternalEncoding),
                input_name='route'), ))
        if self.pad is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            outfile.write(' pad=%s' % (self.gds_format_string(quote_attrib(self.pad).encode(ExternalEncoding),
                input_name='pad'), ))
        if self.pin is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            outfile.write(' pin=%s' % (self.gds_format_string(quote_attrib(self.pin).encode(ExternalEncoding),
                input_name='pin'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='connect', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connect'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            showIndent(outfile, level)
            outfile.write('gate = "%s",\n' % (self.gate,))
        if self.route is not None and 'route' not in already_processed:
            already_processed.append('route')
            showIndent(outfile, level)
            outfile.write('route = "%s",\n' % (self.route,))
        if self.pad is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            showIndent(outfile, level)
            outfile.write('pad = "%s",\n' % (self.pad,))
        if self.pin is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            showIndent(outfile, level)
            outfile.write('pin = "%s",\n' % (self.pin,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gate', node)
        if value is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            self.gate = value
        value = find_attr_value_('route', node)
        if value is not None and 'route' not in already_processed:
            already_processed.append('route')
            self.route = value
        value = find_attr_value_('pad', node)
        if value is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            self.pad = value
        value = find_attr_value_('pin', node)
        if value is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            self.pin = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class connect


class technology(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, attribute=None):
        self.name = _cast(None, name)
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if technology.subclass:
            return technology.subclass(*args_, **kwargs_)
        else:
            return technology(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute(self, index, value):
        self.attribute[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def export(self, outfile, level, namespace_='t:', name_='technology', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='technology')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='technology'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='technology', fromsubclass_=False):
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute')
    def hasContent_(self):
        if (
            self.attribute
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='technology'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
# end class technology


class attribute(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, ratio=None, name=None, value=None, y=None, x=None, constant=None, font=None, rot=None, display=None, size=None):
        self.layer = _cast(None, layer)
        self.ratio = _cast(None, ratio)
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.constant = _cast(None, constant)
        self.font = _cast(None, font)
        self.rot = _cast(None, rot)
        self.display = _cast(None, display)
        self.size = _cast(None, size)
        pass
    def factory(*args_, **kwargs_):
        if attribute.subclass:
            return attribute.subclass(*args_, **kwargs_)
        else:
            return attribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self):
        return self.layer
    def set_layer(self, layer):
        self.layer = layer
    def get_ratio(self):
        return self.ratio
    def set_ratio(self, ratio):
        self.ratio = ratio
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_constant(self):
        return self.constant
    def set_constant(self, constant):
        self.constant = constant
    def get_font(self):
        return self.font
    def set_font(self, font):
        self.font = font
    def get_rot(self):
        return self.rot
    def set_rot(self, rot):
        self.rot = rot
    def get_display(self):
        return self.display
    def set_display(self, display):
        self.display = display
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def export(self, outfile, level, namespace_='t:', name_='attribute', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='attribute'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding),
                input_name='layer'), ))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            outfile.write(' ratio=%s' % (self.gds_format_string(quote_attrib(self.ratio).encode(ExternalEncoding),
                input_name='ratio'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding),
                input_name='value'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding),
                input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding),
                input_name='x'), ))
        if self.constant is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            outfile.write(' constant=%s' % (self.gds_format_string(quote_attrib(self.constant).encode(ExternalEncoding), input_name='constant'), ))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            outfile.write(' font=%s' % (self.gds_format_string(quote_attrib(self.font).encode(ExternalEncoding),
                input_name='font'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding),
                input_name='rot'), ))
        if self.display is not None and 'display' not in already_processed:
            already_processed.append('display')
            outfile.write(' display=%s' % (self.gds_format_string(quote_attrib(self.display).encode(ExternalEncoding),
                input_name='display'), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            outfile.write(' size=%s' % (self.gds_format_string(quote_attrib(self.size).encode(ExternalEncoding),
                input_name='size'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='attribute', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='attribute'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            showIndent(outfile, level)
            outfile.write('ratio = "%s",\n' % (self.ratio,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.constant is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            showIndent(outfile, level)
            outfile.write('constant = "%s",\n' % (self.constant,))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            showIndent(outfile, level)
            outfile.write('font = "%s",\n' % (self.font,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.display is not None and 'display' not in already_processed:
            already_processed.append('display')
            showIndent(outfile, level)
            outfile.write('display = "%s",\n' % (self.display,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            showIndent(outfile, level)
            outfile.write('size = "%s",\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('ratio', node)
        if value is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            self.ratio = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('constant', node)
        if value is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            self.constant = value
        value = find_attr_value_('font', node)
        if value is not None and 'font' not in already_processed:
            already_processed.append('font')
            self.font = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('display', node)
        if value is not None and 'display' not in already_processed:
            already_processed.append('display')
            self.display = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.append('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class attribute


class pinref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gate=None, part=None, pin=None):
        self.gate = _cast(None, gate)
        self.part = _cast(None, part)
        self.pin = _cast(None, pin)
        pass
    def factory(*args_, **kwargs_):
        if pinref.subclass:
            return pinref.subclass(*args_, **kwargs_)
        else:
            return pinref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gate(self):
        return self.gate
    def set_gate(self, gate):
        self.gate = gate
    def get_part(self):
        return self.part
    def set_part(self, part):
        self.part = part
    def get_pin(self):
        return self.pin
    def set_pin(self, pin):
        self.pin = pin
    def export(self, outfile, level, namespace_='t:', name_='pinref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pinref')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='pinref'):
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            outfile.write(' gate=%s' % (self.gds_format_string(quote_attrib(self.gate).encode(ExternalEncoding),
                input_name='gate'), ))
        if self.part is not None and 'part' not in already_processed:
            already_processed.append('part')
            outfile.write(' part=%s' % (self.gds_format_string(quote_attrib(self.part).encode(ExternalEncoding),
                input_name='part'), ))
        if self.pin is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            outfile.write(' pin=%s' % (self.gds_format_string(quote_attrib(self.pin).encode(ExternalEncoding),
                input_name='pin'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='pinref', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pinref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            showIndent(outfile, level)
            outfile.write('gate = "%s",\n' % (self.gate,))
        if self.part is not None and 'part' not in already_processed:
            already_processed.append('part')
            showIndent(outfile, level)
            outfile.write('part = "%s",\n' % (self.part,))
        if self.pin is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            showIndent(outfile, level)
            outfile.write('pin = "%s",\n' % (self.pin,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gate', node)
        if value is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            self.gate = value
        value = find_attr_value_('part', node)
        if value is not None and 'part' not in already_processed:
            already_processed.append('part')
            self.part = value
        value = find_attr_value_('pin', node)
        if value is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            self.pin = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pinref


class contactref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, routetag=None, route=None, pad=None, element=None):
        self.routetag = _cast(None, routetag)
        self.route = _cast(None, route)
        self.pad = _cast(None, pad)
        self.element = _cast(None, element)
        pass
    def factory(*args_, **kwargs_):
        if contactref.subclass:
            return contactref.subclass(*args_, **kwargs_)
        else:
            return contactref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routetag(self):
        return self.routetag
    def set_routetag(self, routetag):
        self.routetag = routetag
    def get_route(self):
        return self.route
    def set_route(self, route):
        self.route = route
    def get_pad(self):
        return self.pad
    def set_pad(self, pad):
        self.pad = pad
    def get_element(self):
        return self.element
    def set_element(self, element):
        self.element = element
    def export(self, outfile, level, namespace_='t:', name_='contactref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contactref')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='contactref'):
        if self.routetag is not None and 'routetag' not in already_processed:
            already_processed.append('routetag')
            outfile.write(' routetag=%s' % (self.gds_format_string(quote_attrib(self.routetag).encode(ExternalEncoding),
                input_name='routetag'), ))
        if self.route is not None and 'route' not in already_processed:
            already_processed.append('route')
            outfile.write(' route=%s' % (self.gds_format_string(quote_attrib(self.route).encode(ExternalEncoding),
                input_name='route'), ))
        if self.pad is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            outfile.write(' pad=%s' % (self.gds_format_string(quote_attrib(self.pad).encode(ExternalEncoding),
                input_name='pad'), ))
        if self.element is not None and 'element' not in already_processed:
            already_processed.append('element')
            outfile.write(' element=%s' % (self.gds_format_string(quote_attrib(self.element).encode(ExternalEncoding),
                input_name='element'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='contactref', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='contactref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.routetag is not None and 'routetag' not in already_processed:
            already_processed.append('routetag')
            showIndent(outfile, level)
            outfile.write('routetag = "%s",\n' % (self.routetag,))
        if self.route is not None and 'route' not in already_processed:
            already_processed.append('route')
            showIndent(outfile, level)
            outfile.write('route = "%s",\n' % (self.route,))
        if self.pad is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            showIndent(outfile, level)
            outfile.write('pad = "%s",\n' % (self.pad,))
        if self.element is not None and 'element' not in already_processed:
            already_processed.append('element')
            showIndent(outfile, level)
            outfile.write('element = "%s",\n' % (self.element,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('routetag', node)
        if value is not None and 'routetag' not in already_processed:
            already_processed.append('routetag')
            self.routetag = value
        value = find_attr_value_('route', node)
        if value is not None and 'route' not in already_processed:
            already_processed.append('route')
            self.route = value
        value = find_attr_value_('pad', node)
        if value is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            self.pad = value
        value = find_attr_value_('element', node)
        if value is not None and 'element' not in already_processed:
            already_processed.append('element')
            self.element = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contactref


class variantdefs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variantdef=None):
        if variantdef is None:
            self.variantdef = []
        else:
            self.variantdef = variantdef
    def factory(*args_, **kwargs_):
        if variantdefs.subclass:
            return variantdefs.subclass(*args_, **kwargs_)
        else:
            return variantdefs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_variantdef(self):
        return self.variantdef
    def set_variantdef(self, variantdef):
        self.variantdef = variantdef
    def add_variantdef(self, value):
        self.variantdef.append(value)
    def insert_variantdef(self, index, value):
        self.variantdef[index] = value
    def export(self, outfile, level, namespace_='t:', name_='variantdefs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='variantdefs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='variantdefs'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='variantdefs', fromsubclass_=False):
        for variantdef_ in self.variantdef:
            variantdef_.export(outfile, level, namespace_, name_='variantdef')
    def hasContent_(self):
        if (
            self.variantdef
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='variantdefs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('variantdef=[\n')
        level += 1
        for variantdef_ in self.variantdef:
            showIndent(outfile, level)
            outfile.write('model_.variantdef(\n')
            variantdef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'variantdef':
            obj_ = variantdef.factory()
            obj_.build(child_)
            self.variantdef.append(obj_)
# end class variantdefs


class settings(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, setting=None):
        if setting is None:
            self.setting = []
        else:
            self.setting = setting
    def factory(*args_, **kwargs_):
        if settings.subclass:
            return settings.subclass(*args_, **kwargs_)
        else:
            return settings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_setting(self):
        return self.setting
    def set_setting(self, setting):
        self.setting = setting
    def add_setting(self, value):
        self.setting.append(value)
    def insert_setting(self, index, value):
        self.setting[index] = value
    def export(self, outfile, level, namespace_='t:', name_='settings', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='settings')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='settings'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='settings', fromsubclass_=False):
        for setting_ in self.setting:
            setting_.export(outfile, level, namespace_, name_='setting')
    def hasContent_(self):
        if (
            self.setting
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='settings'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('setting=[\n')
        level += 1
        for setting_ in self.setting:
            showIndent(outfile, level)
            outfile.write('model_.setting(\n')
            setting_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'setting':
            obj_ = setting.factory()
            obj_.build(child_)
            self.setting.append(obj_)
# end class settings


class sheets(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sheet=None):
        if sheet is None:
            self.sheet = []
        else:
            self.sheet = sheet
    def factory(*args_, **kwargs_):
        if sheets.subclass:
            return sheets.subclass(*args_, **kwargs_)
        else:
            return sheets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sheet(self):
        return self.sheet
    def set_sheet(self, sheet):
        self.sheet = sheet
    def add_sheet(self, value):
        self.sheet.append(value)
    def insert_sheet(self, index, value):
        self.sheet[index] = value
    def export(self, outfile, level, namespace_='t:', name_='sheets', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sheets')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='sheets'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='sheets', fromsubclass_=False):
        for sheet_ in self.sheet:
            sheet_.export(outfile, level, namespace_, name_='sheet')
    def hasContent_(self):
        if (
            self.sheet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sheets'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('sheet=[\n')
        level += 1
        for sheet_ in self.sheet:
            showIndent(outfile, level)
            outfile.write('model_.sheet(\n')
            sheet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sheet':
            obj_ = sheet.factory()
            obj_.build(child_)
            self.sheet.append(obj_)
# end class sheets


class layers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None):
        if layer is None:
            self.layer = []
        else:
            self.layer = layer
    def factory(*args_, **kwargs_):
        if layers.subclass:
            return layers.subclass(*args_, **kwargs_)
        else:
            return layers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self):
        return self.layer
    def set_layer(self, layer):
        self.layer = layer
    def add_layer(self, value):
        self.layer.append(value)
    def insert_layer(self, index, value):
        self.layer[index] = value
    def export(self, outfile, level, namespace_='t:', name_='layers', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='layers')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='layers'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='layers', fromsubclass_=False):
        for layer_ in self.layer:
            layer_.export(outfile, level, namespace_, name_='layer')
    def hasContent_(self):
        if (
            self.layer
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='layers'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('layer=[\n')
        level += 1
        for layer_ in self.layer:
            showIndent(outfile, level)
            outfile.write('model_.layer(\n')
            layer_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'layer':
            obj_ = layer.factory()
            obj_.build(child_)
            self.layer.append(obj_)
# end class layers


class packages(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, package=None):
        if package is None:
            self.package = []
        else:
            self.package = package
    def factory(*args_, **kwargs_):
        if packages.subclass:
            return packages.subclass(*args_, **kwargs_)
        else:
            return packages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_package(self): return self.package
    def set_package(self, package): self.package = package
    def add_package(self, value): self.package.append(value)
    def insert_package(self, index, value): self.package[index] = value
    def export(self, outfile, level, namespace_='t:', name_='packages', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='packages')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='packages'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='packages', fromsubclass_=False):
        for package_ in self.package:
            package_.export(outfile, level, namespace_, name_='package')
    def hasContent_(self):
        if (
            self.package
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='packages'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('package=[\n')
        level += 1
        for package_ in self.package:
            showIndent(outfile, level)
            outfile.write('model_.package(\n')
            package_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'package':
            obj_ = package.factory()
            obj_.build(child_)
            self.package.append(obj_)
# end class packages


class symbols(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, symbol=None):
        if symbol is None:
            self.symbol = []
        else:
            self.symbol = symbol
    def factory(*args_, **kwargs_):
        if symbols.subclass:
            return symbols.subclass(*args_, **kwargs_)
        else:
            return symbols(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_symbol(self):
        return self.symbol
    def set_symbol(self, symbol):
        self.symbol = symbol
    def add_symbol(self, value):
        self.symbol.append(value)
    def insert_symbol(self, index, value):
        self.symbol[index] = value
    def export(self, outfile, level, namespace_='t:', name_='symbols', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='symbols')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='symbols'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='symbols', fromsubclass_=False):
        for symbol_ in self.symbol:
            symbol_.export(outfile, level, namespace_, name_='symbol')
    def hasContent_(self):
        if (
            self.symbol
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='symbols'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('symbol=[\n')
        level += 1
        for symbol_ in self.symbol:
            showIndent(outfile, level)
            outfile.write('model_.symbol(\n')
            symbol_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'symbol':
            obj_ = symbol.factory()
            obj_.build(child_)
            self.symbol.append(obj_)
# end class symbols


class devicesets(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, deviceset=None):
        if deviceset is None:
            self.deviceset = []
        else:
            self.deviceset = deviceset
    def factory(*args_, **kwargs_):
        if devicesets.subclass:
            return devicesets.subclass(*args_, **kwargs_)
        else:
            return devicesets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deviceset(self):
        return self.deviceset
    def set_deviceset(self, deviceset):
        self.deviceset = deviceset
    def add_deviceset(self, value):
        self.deviceset.append(value)
    def insert_deviceset(self, index, value):
        self.deviceset[index] = value
    def export(self, outfile, level, namespace_='t:', name_='devicesets', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='devicesets')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='devicesets'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='devicesets', fromsubclass_=False):
        for deviceset_ in self.deviceset:
            deviceset_.export(outfile, level, namespace_, name_='deviceset')
    def hasContent_(self):
        if (
            self.deviceset
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='devicesets'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('deviceset=[\n')
        level += 1
        for deviceset_ in self.deviceset:
            showIndent(outfile, level)
            outfile.write('model_.deviceset(\n')
            deviceset_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deviceset':
            obj_ = deviceset.factory()
            obj_.build(child_)
            self.deviceset.append(obj_)
# end class devicesets


class gates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gate=None):
        if gate is None:
            self.gate = []
        else:
            self.gate = gate
    def factory(*args_, **kwargs_):
        if gates.subclass:
            return gates.subclass(*args_, **kwargs_)
        else:
            return gates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gate(self):
        return self.gate
    def set_gate(self, gate):
        self.gate = gate
    def add_gate(self, value):
        self.gate.append(value)
    def insert_gate(self, index, value):
        self.gate[index] = value
    def export(self, outfile, level, namespace_='t:', name_='gates', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gates')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='gates'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='gates', fromsubclass_=False):
        for gate_ in self.gate:
            gate_.export(outfile, level, namespace_, name_='gate')
    def hasContent_(self):
        if (
            self.gate
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gates'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('gate=[\n')
        level += 1
        for gate_ in self.gate:
            showIndent(outfile, level)
            outfile.write('model_.gate(\n')
            gate_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gate':
            obj_ = gate.factory()
            obj_.build(child_)
            self.gate.append(obj_)
# end class gates


class devices(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, device=None):
        if device is None:
            self.device = []
        else:
            self.device = device
    def factory(*args_, **kwargs_):
        if devices.subclass:
            return devices.subclass(*args_, **kwargs_)
        else:
            return devices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_device(self):
        return self.device
    def set_device(self, device):
        self.device = device
    def add_device(self, value):
        self.device.append(value)
    def insert_device(self, index, value):
        self.device[index] = value
    def export(self, outfile, level, namespace_='t:', name_='devices', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='devices')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='devices'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='devices', fromsubclass_=False):
        for device_ in self.device:
            device_.export(outfile, level, namespace_, name_='device')
    def hasContent_(self):
        if (
            self.device
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='devices'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('device=[\n')
        level += 1
        for device_ in self.device:
            showIndent(outfile, level)
            outfile.write('model_.device(\n')
            device_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'device':
            obj_ = device.factory()
            obj_.build(child_)
            self.device.append(obj_)
# end class devices


class libraries(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, library=None):
        if library is None:
            self.library = []
        else:
            self.library = library
    def factory(*args_, **kwargs_):
        if libraries.subclass:
            return libraries.subclass(*args_, **kwargs_)
        else:
            return libraries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def add_library(self, value):
        self.library.append(value)
    def insert_library(self, index, value):
        self.library[index] = value
    def export(self, outfile, level, namespace_='t:', name_='libraries', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='libraries')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='libraries'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='libraries', fromsubclass_=False):
        for library_ in self.library:
            library_.export(outfile, level, namespace_, name_='library')
    def hasContent_(self):
        if (
            self.library
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='libraries'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('library=[\n')
        level += 1
        for library_ in self.library:
            showIndent(outfile, level)
            outfile.write('model_.library(\n')
            library_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'library':
            obj_ = library.factory()
            obj_.build(child_)
            self.library.append(obj_)
# end class libraries


class connects(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, connect=None):
        if connect is None:
            self.connect = []
        else:
            self.connect = connect
    def factory(*args_, **kwargs_):
        if connects.subclass:
            return connects.subclass(*args_, **kwargs_)
        else:
            return connects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connect(self):
        return self.connect
    def set_connect(self, connect):
        self.connect = connect
    def add_connect(self, value):
        self.connect.append(value)
    def insert_connect(self, index, value):
        self.connect[index] = value
    def export(self, outfile, level, namespace_='t:', name_='connects', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='connects')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='connects'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='connects', fromsubclass_=False):
        for connect_ in self.connect:
            connect_.export(outfile, level, namespace_, name_='connect')
    def hasContent_(self):
        if (
            self.connect
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connects'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('connect=[\n')
        level += 1
        for connect_ in self.connect:
            showIndent(outfile, level)
            outfile.write('model_.connect(\n')
            connect_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'connect':
            obj_ = connect.factory()
            obj_.build(child_)
            self.connect.append(obj_)
# end class connects


class technologies(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, technology=None):
        if technology is None:
            self.technology = []
        else:
            self.technology = technology
    def factory(*args_, **kwargs_):
        if technologies.subclass:
            return technologies.subclass(*args_, **kwargs_)
        else:
            return technologies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_technology(self):
        return self.technology
    def set_technology(self, technology):
        self.technology = technology
    def add_technology(self, value):
        self.technology.append(value)
    def insert_technology(self, index, value):
        self.technology[index] = value
    def export(self, outfile, level, namespace_='t:', name_='technologies', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='technologies')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='technologies'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='technologies', fromsubclass_=False):
        for technology_ in self.technology:
            technology_.export(outfile, level, namespace_, name_='technology')
    def hasContent_(self):
        if (
            self.technology
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='technologies'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('technology=[\n')
        level += 1
        for technology_ in self.technology:
            showIndent(outfile, level)
            outfile.write('model_.technology(\n')
            technology_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'technology':
            obj_ = technology.factory()
            obj_.build(child_)
            self.technology.append(obj_)
# end class technologies


class attributes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attribute=None):
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if attributes.subclass:
            return attributes.subclass(*args_, **kwargs_)
        else:
            return attributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute(self, index, value):
        self.attribute[index] = value
    def export(self, outfile, level, namespace_='t:', name_='attributes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attributes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='attributes'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='attributes', fromsubclass_=False):
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute')
    def hasContent_(self):
        if (
            self.attribute
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='attributes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
# end class attributes


class classes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classxx=None):
        if classxx is None:
            self.classxx = []
        else:
            self.classxx = classxx
    def factory(*args_, **kwargs_):
        if classes.subclass:
            return classes.subclass(*args_, **kwargs_)
        else:
            return classes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_class(self):
        return self.classxx
    def set_class(self, classxx):
        self.classxx = classxx
    def add_class(self, value):
        self.classxx.append(value)
    def insert_class(self, index, value):
        self.classxx[index] = value
    def export(self, outfile, level, namespace_='t:', name_='classes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='classes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='classes'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='classes', fromsubclass_=False):
        for class_ in self.classxx:
            class_.export(outfile, level, namespace_, name_='class')
    def hasContent_(self):
        if (
            self.classxx
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='classes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('classxx=[\n')
        level += 1
        for class_ in self.classxx:
            showIndent(outfile, level)
            outfile.write('model_.classxx(\n')
            class_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'class':
            obj_ = classxx.factory()
            obj_.build(child_)
            self.classxx.append(obj_)
# end class classes


class parts(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, part=None):
        if part is None:
            self.part = []
        else:
            self.part = part
    def factory(*args_, **kwargs_):
        if parts.subclass:
            return parts.subclass(*args_, **kwargs_)
        else:
            return parts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_part(self):
        return self.part
    def set_part(self, part):
        self.part = part
    def add_part(self, value):
        self.part.append(value)
    def insert_part(self, index, value):
        self.part[index] = value
    def export(self, outfile, level, namespace_='t:', name_='parts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='parts'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='parts', fromsubclass_=False):
        for part_ in self.part:
            part_.export(outfile, level, namespace_, name_='part')
    def hasContent_(self):
        if (
            self.part
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='parts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('part=[\n')
        level += 1
        for part_ in self.part:
            showIndent(outfile, level)
            outfile.write('model_.part(\n')
            part_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'part':
            obj_ = part.factory()
            obj_.build(child_)
            self.part.append(obj_)
# end class parts


class instances(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, instance=None):
        if instance is None:
            self.instance = []
        else:
            self.instance = instance
    def factory(*args_, **kwargs_):
        if instances.subclass:
            return instances.subclass(*args_, **kwargs_)
        else:
            return instances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instance(self):
        return self.instance
    def set_instance(self, instance):
        self.instance = instance
    def add_instance(self, value):
        self.instance.append(value)
    def insert_instance(self, index, value):
        self.instance[index] = value
    def export(self, outfile, level, namespace_='t:', name_='instances', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='instances')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='instances'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='instances', fromsubclass_=False):
        for instance_ in self.instance:
            instance_.export(outfile, level, namespace_, name_='instance')
    def hasContent_(self):
        if (
            self.instance
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='instances'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('instance=[\n')
        level += 1
        for instance_ in self.instance:
            showIndent(outfile, level)
            outfile.write('model_.instance(\n')
            instance_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instance':
            obj_ = instance.factory()
            obj_.build(child_)
            self.instance.append(obj_)
# end class instances


class errors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approved=None):
        if approved is None:
            self.approved = []
        else:
            self.approved = approved
    def factory(*args_, **kwargs_):
        if errors.subclass:
            return errors.subclass(*args_, **kwargs_)
        else:
            return errors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approved(self):
        return self.approved
    def set_approved(self, approved):
        self.approved = approved
    def add_approved(self, value):
        self.approved.append(value)
    def insert_approved(self, index, value):
        self.approved[index] = value
    def export(self, outfile, level, namespace_='t:', name_='errors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='errors')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='errors'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='errors', fromsubclass_=False):
        for approved_ in self.approved:
            approved_.export(outfile, level, namespace_, name_='approved')
    def hasContent_(self):
        if (
            self.approved
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='errors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('approved=[\n')
        level += 1
        for approved_ in self.approved:
            showIndent(outfile, level)
            outfile.write('model_.approved(\n')
            approved_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'approved':
            obj_ = approved.factory()
            obj_.build(child_)
            self.approved.append(obj_)
# end class errors


class plain(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, polygon=None, wire=None, text=None, circle=None, rectangle=None, frame=None, hole=None):
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
        if wire is None:
            self.wire = []
        else:
            self.wire = wire
        if text is None:
            self.text = []
        else:
            self.text = text
        if circle is None:
            self.circle = []
        else:
            self.circle = circle
        if rectangle is None:
            self.rectangle = []
        else:
            self.rectangle = rectangle
        if frame is None:
            self.frame = []
        else:
            self.frame = frame
        if hole is None:
            self.hole = []
        else:
            self.hole = hole
    def factory(*args_, **kwargs_):
        if plain.subclass:
            return plain.subclass(*args_, **kwargs_)
        else:
            return plain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_polygon(self):
        return self.polygon
    def set_polygon(self, polygon):
        self.polygon = polygon
    def add_polygon(self, value):
        self.polygon.append(value)
    def insert_polygon(self, index, value):
        self.polygon[index] = value
    def get_wire(self):
        return self.wire
    def set_wire(self, wire):
        self.wire = wire
    def add_wire(self, value):
        self.wire.append(value)
    def insert_wire(self, index, value):
        self.wire[index] = value
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def add_text(self, value):
        self.text.append(value)
    def insert_text(self, index, value):
        self.text[index] = value
    def get_circle(self):
        return self.circle
    def set_circle(self, circle):
        self.circle = circle
    def add_circle(self, value):
        self.circle.append(value)
    def insert_circle(self, index, value):
        self.circle[index] = value
    def get_rectangle(self):
        return self.rectangle
    def set_rectangle(self, rectangle):
        self.rectangle = rectangle
    def add_rectangle(self, value):
        self.rectangle.append(value)
    def insert_rectangle(self, index, value):
        self.rectangle[index] = value
    def get_frame(self):
        return self.frame
    def set_frame(self, frame):
        self.frame = frame
    def add_frame(self, value):
        self.frame.append(value)
    def insert_frame(self, index, value):
        self.frame[index] = value
    def get_hole(self):
        return self.hole
    def set_hole(self, hole):
        self.hole = hole
    def add_hole(self, value):
        self.hole.append(value)
    def insert_hole(self, index, value):
        self.hole[index] = value
    def export(self, outfile, level, namespace_='t:', name_='plain', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='plain')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='plain'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='plain', fromsubclass_=False):
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
        for wire_ in self.wire:
            wire_.export(outfile, level, namespace_, name_='wire')
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text')
        for circle_ in self.circle:
            circle_.export(outfile, level, namespace_, name_='circle')
        for rectangle_ in self.rectangle:
            rectangle_.export(outfile, level, namespace_, name_='rectangle')
        for frame_ in self.frame:
            frame_.export(outfile, level, namespace_, name_='frame')
        for hole_ in self.hole:
            hole_.export(outfile, level, namespace_, name_='hole')
    def hasContent_(self):
        if (
            self.polygon or
            self.wire or
            self.text or
            self.circle or
            self.rectangle or
            self.frame or
            self.hole
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='plain'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.polygon(\n')
            polygon_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wire=[\n')
        level += 1
        for wire_ in self.wire:
            showIndent(outfile, level)
            outfile.write('model_.wire(\n')
            wire_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('text=[\n')
        level += 1
        for text_ in self.text:
            showIndent(outfile, level)
            outfile.write('model_.text(\n')
            text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('circle=[\n')
        level += 1
        for circle_ in self.circle:
            showIndent(outfile, level)
            outfile.write('model_.circle(\n')
            circle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('rectangle=[\n')
        level += 1
        for rectangle_ in self.rectangle:
            showIndent(outfile, level)
            outfile.write('model_.rectangle(\n')
            rectangle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('frame=[\n')
        level += 1
        for frame_ in self.frame:
            showIndent(outfile, level)
            outfile.write('model_.frame(\n')
            frame_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('hole=[\n')
        level += 1
        for hole_ in self.hole:
            showIndent(outfile, level)
            outfile.write('model_.hole(\n')
            hole_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polygon':
            obj_ = polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
        elif nodeName_ == 'wire':
            obj_ = wire.factory()
            obj_.build(child_)
            self.wire.append(obj_)
        elif nodeName_ == 'text':
            obj_ = text.factory()
            obj_.build(child_)
            self.text.append(obj_)
        elif nodeName_ == 'circle':
            obj_ = circle.factory()
            obj_.build(child_)
            self.circle.append(obj_)
        elif nodeName_ == 'rectangle':
            obj_ = rectangle.factory()
            obj_.build(child_)
            self.rectangle.append(obj_)
        elif nodeName_ == 'frame':
            obj_ = frame.factory()
            obj_.build(child_)
            self.frame.append(obj_)
        elif nodeName_ == 'hole':
            obj_ = hole.factory()
            obj_.build(child_)
            self.hole.append(obj_)
# end class plain


class designrules(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, param=None):
        if description is None:
            self.description = []
        else:
            self.description = description
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if designrules.subclass:
            return designrules.subclass(*args_, **kwargs_)
        else:
            return designrules(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def add_description(self, value):
        self.description.append(value)
    def insert_description(self, index, value):
        self.description[index] = value
    def get_param(self):
        return self.param
    def set_param(self, param):
        self.param = param
    def add_param(self, value):
        self.param.append(value)
    def insert_param(self, index, value):
        self.param[index] = value
    def export(self, outfile, level, namespace_='t:', name_='designrules', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='designrules')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='designrules'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='designrules', fromsubclass_=False):
        for description_ in self.description:
            description_.export(outfile, level, namespace_, name_='description')
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param')
    def hasContent_(self):
        if (
            self.description or
            self.param
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='designrules'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('model_.description(\n')
            description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('param=[\n')
        level += 1
        for param_ in self.param:
            showIndent(outfile, level)
            outfile.write('model_.param(\n')
            param_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.description.append(obj_)
        elif nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.param.append(obj_)
# end class designrules


class autorouter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, passxx=None):
        if passxx is None:
            self.passxx = []
        else:
            self.passxx = passxx
    def factory(*args_, **kwargs_):
        if autorouter.subclass:
            return autorouter.subclass(*args_, **kwargs_)
        else:
            return autorouter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pass(self):
        return self.passxx
    def set_pass(self, passxx):
        self.passxx = passxx
    def add_pass(self, value):
        self.passxx.append(value)
    def insert_pass(self, index, value):
        self.passxx[index] = value
    def export(self, outfile, level, namespace_='t:', name_='autorouter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='autorouter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='autorouter'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='autorouter', fromsubclass_=False):
        for pass_ in self.passxx:
            pass_.export(outfile, level, namespace_, name_='pass')
    def hasContent_(self):
        if (
            self.passxx
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='autorouter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('passxx=[\n')
        level += 1
        for pass_ in self.passxx:
            showIndent(outfile, level)
            outfile.write('model_.passxx(\n')
            pass_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pass':
            obj_ = passxx.factory()
            obj_.build(child_)
            self.passxx.append(obj_)
# end class autorouter


class elements(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, element=None):
        if element is None:
            self.element = []
        else:
            self.element = element
    def factory(*args_, **kwargs_):
        if elements.subclass:
            return elements.subclass(*args_, **kwargs_)
        else:
            return elements(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_element(self):
        return self.element
    def set_element(self, element):
        self.element = element
    def add_element(self, value):
        self.element.append(value)
    def insert_element(self, index, value):
        self.element[index] = value
    def export(self, outfile, level, namespace_='t:', name_='elements', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='elements')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='elements'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='elements', fromsubclass_=False):
        for element_ in self.element:
            element_.export(outfile, level, namespace_, name_='element')
    def hasContent_(self):
        if (
            self.element
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='elements'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('element=[\n')
        level += 1
        for element_ in self.element:
            showIndent(outfile, level)
            outfile.write('model_.element(\n')
            element_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'element':
            obj_ = element.factory()
            obj_.build(child_)
            self.element.append(obj_)
# end class elements


class signals(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, signal=None):
        if signal is None:
            self.signal = []
        else:
            self.signal = signal
    def factory(*args_, **kwargs_):
        if signals.subclass:
            return signals.subclass(*args_, **kwargs_)
        else:
            return signals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_signal(self):
        return self.signal
    def set_signal(self, signal):
        self.signal = signal
    def add_signal(self, value):
        self.signal.append(value)
    def insert_signal(self, index, value):
        self.signal[index] = value
    def export(self, outfile, level, namespace_='t:', name_='signals', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='signals')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='signals'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='signals', fromsubclass_=False):
        for signal_ in self.signal:
            signal_.export(outfile, level, namespace_, name_='signal')
    def hasContent_(self):
        if (
            self.signal
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='signals'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('signal=[\n')
        level += 1
        for signal_ in self.signal:
            showIndent(outfile, level)
            outfile.write('model_.signal(\n')
            signal_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'signal':
            obj_ = signal.factory()
            obj_.build(child_)
            self.signal.append(obj_)
# end class signals


class busses(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bus=None):
        if bus is None:
            self.bus = []
        else:
            self.bus = bus
    def factory(*args_, **kwargs_):
        if busses.subclass:
            return busses.subclass(*args_, **kwargs_)
        else:
            return busses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bus(self):
        return self.bus
    def set_bus(self, bus):
        self.bus = bus
    def add_bus(self, value):
        self.bus.append(value)
    def insert_bus(self, index, value):
        self.bus[index] = value
    def export(self, outfile, level, namespace_='t:', name_='busses', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='busses')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='busses'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='busses', fromsubclass_=False):
        for bus_ in self.bus:
            bus_.export(outfile, level, namespace_, name_='bus')
    def hasContent_(self):
        if (
            self.bus
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='busses'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bus=[\n')
        level += 1
        for bus_ in self.bus:
            showIndent(outfile, level)
            outfile.write('model_.bus(\n')
            bus_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bus':
            obj_ = bus.factory()
            obj_.build(child_)
            self.bus.append(obj_)
# end class busses


class nets(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, net=None):
        if net is None:
            self.net = []
        else:
            self.net = net
    def factory(*args_, **kwargs_):
        if nets.subclass:
            return nets.subclass(*args_, **kwargs_)
        else:
            return nets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_net(self):
        return self.net
    def set_net(self, net):
        self.net = net
    def add_net(self, value):
        self.net.append(value)
    def insert_net(self, index, value):
        self.net[index] = value
    def export(self, outfile, level, namespace_='t:', name_='nets', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nets')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='nets'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='nets', fromsubclass_=False):
        for net_ in self.net:
            net_.export(outfile, level, namespace_, name_='net')
    def hasContent_(self):
        if (
            self.net
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nets'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('net=[\n')
        level += 1
        for net_ in self.net:
            showIndent(outfile, level)
            outfile.write('model_.net(\n')
            net_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'net':
            obj_ = net.factory()
            obj_.build(child_)
            self.net.append(obj_)
# end class nets


class setting(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, alwaysvectorfont=None, verticaltext=None):
        self.alwaysvectorfont = _cast(None, alwaysvectorfont)
        self.verticaltext = _cast(None, verticaltext)
        pass
    def factory(*args_, **kwargs_):
        if setting.subclass:
            return setting.subclass(*args_, **kwargs_)
        else:
            return setting(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_alwaysvectorfont(self):
        return self.alwaysvectorfont
    def set_alwaysvectorfont(self, alwaysvectorfont):
        self.alwaysvectorfont = alwaysvectorfont
    def get_verticaltext(self):
        return self.verticaltext
    def set_verticaltext(self, verticaltext):
        self.verticaltext = verticaltext
    def export(self, outfile, level, namespace_='t:', name_='setting', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='setting')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='setting'):
        if self.alwaysvectorfont is not None and 'alwaysvectorfont' not in already_processed:
            already_processed.append('alwaysvectorfont')
            outfile.write(' alwaysvectorfont=%s' 
                % (self.gds_format_string(quote_attrib(self.alwaysvectorfont).encode(ExternalEncoding),
                input_name='alwaysvectorfont'), ))
        if self.verticaltext is not None and 'verticaltext' not in already_processed:
            already_processed.append('verticaltext')
            outfile.write(' verticaltext=%s' 
                % (self.gds_format_string(quote_attrib(self.verticaltext).encode(ExternalEncoding),
                input_name='verticaltext'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='setting', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='setting'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.alwaysvectorfont is not None and 'alwaysvectorfont' not in already_processed:
            already_processed.append('alwaysvectorfont')
            showIndent(outfile, level)
            outfile.write('alwaysvectorfont = "%s",\n' % (self.alwaysvectorfont,))
        if self.verticaltext is not None and 'verticaltext' not in already_processed:
            already_processed.append('verticaltext')
            showIndent(outfile, level)
            outfile.write('verticaltext = "%s",\n' % (self.verticaltext,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alwaysvectorfont', node)
        if value is not None and 'alwaysvectorfont' not in already_processed:
            already_processed.append('alwaysvectorfont')
            self.alwaysvectorfont = value
        value = find_attr_value_('verticaltext', node)
        if value is not None and 'verticaltext' not in already_processed:
            already_processed.append('verticaltext')
            self.verticaltext = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class setting


class grid(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, distance=None, style=None, multiple=None, altdistance=None, altunit=None, unitdist=None, altunitdist=None, display=None, unit=None):
        self.distance = _cast(None, distance)
        self.style = _cast(None, style)
        self.multiple = _cast(None, multiple)
        self.altdistance = _cast(None, altdistance)
        self.altunit = _cast(None, altunit)
        self.unitdist = _cast(None, unitdist)
        self.altunitdist = _cast(None, altunitdist)
        self.display = _cast(None, display)
        self.unit = _cast(None, unit)
        pass
    def factory(*args_, **kwargs_):
        if grid.subclass:
            return grid.subclass(*args_, **kwargs_)
        else:
            return grid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_distance(self):
        return self.distance
    def set_distance(self, distance):
        self.distance = distance
    def get_style(self):
        return self.style
    def set_style(self, style):
        self.style = style
    def get_multiple(self):
        return self.multiple
    def set_multiple(self, multiple):
        self.multiple = multiple
    def get_altdistance(self):
        return self.altdistance
    def set_altdistance(self, altdistance):
        self.altdistance = altdistance
    def get_altunit(self):
        return self.altunit
    def set_altunit(self, altunit):
        self.altunit = altunit
    def get_unitdist(self):
        return self.unitdist
    def set_unitdist(self, unitdist):
        self.unitdist = unitdist
    def get_altunitdist(self):
        return self.altunitdist
    def set_altunitdist(self, altunitdist):
        self.altunitdist = altunitdist
    def get_display(self):
        return self.display
    def set_display(self, display):
        self.display = display
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def export(self, outfile, level, namespace_='t:', name_='grid', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='grid')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='grid'):
        if self.distance is not None and 'distance' not in already_processed:
            already_processed.append('distance')
            outfile.write(' distance=%s' % (self.gds_format_string(quote_attrib(self.distance).encode(ExternalEncoding),
                input_name='distance'), ))
        if self.style is not None and 'style' not in already_processed:
            already_processed.append('style')
            outfile.write(' style=%s' % (self.gds_format_string(quote_attrib(self.style).encode(ExternalEncoding),
                input_name='style'), ))
        if self.multiple is not None and 'multiple' not in already_processed:
            already_processed.append('multiple')
            outfile.write(' multiple=%s' % (self.gds_format_string(quote_attrib(self.multiple).encode(ExternalEncoding),
                input_name='multiple'), ))
        if self.altdistance is not None and 'altdistance' not in already_processed:
            already_processed.append('altdistance')
            outfile.write(' altdistance=%s' % (self.gds_format_string(quote_attrib(self.altdistance).encode(ExternalEncoding),
                input_name='altdistance'), ))
        if self.altunit is not None and 'altunit' not in already_processed:
            already_processed.append('altunit')
            outfile.write(' altunit=%s' % (self.gds_format_string(quote_attrib(self.altunit).encode(ExternalEncoding),
                input_name='altunit'), ))
        if self.unitdist is not None and 'unitdist' not in already_processed:
            already_processed.append('unitdist')
            outfile.write(' unitdist=%s' % (self.gds_format_string(quote_attrib(self.unitdist).encode(ExternalEncoding),
                input_name='unitdist'), ))
        if self.altunitdist is not None and 'altunitdist' not in already_processed:
            already_processed.append('altunitdist')
            outfile.write(' altunitdist=%s' % (self.gds_format_string(quote_attrib(self.altunitdist).encode(ExternalEncoding),
                input_name='altunitdist'), ))
        if self.display is not None and 'display' not in already_processed:
            already_processed.append('display')
            outfile.write(' display=%s' % (self.gds_format_string(quote_attrib(self.display).encode(ExternalEncoding),
                input_name='display'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding),
                input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='grid', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='grid'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.distance is not None and 'distance' not in already_processed:
            already_processed.append('distance')
            showIndent(outfile, level)
            outfile.write('distance = "%s",\n' % (self.distance,))
        if self.style is not None and 'style' not in already_processed:
            already_processed.append('style')
            showIndent(outfile, level)
            outfile.write('style = "%s",\n' % (self.style,))
        if self.multiple is not None and 'multiple' not in already_processed:
            already_processed.append('multiple')
            showIndent(outfile, level)
            outfile.write('multiple = "%s",\n' % (self.multiple,))
        if self.altdistance is not None and 'altdistance' not in already_processed:
            already_processed.append('altdistance')
            showIndent(outfile, level)
            outfile.write('altdistance = "%s",\n' % (self.altdistance,))
        if self.altunit is not None and 'altunit' not in already_processed:
            already_processed.append('altunit')
            showIndent(outfile, level)
            outfile.write('altunit = "%s",\n' % (self.altunit,))
        if self.unitdist is not None and 'unitdist' not in already_processed:
            already_processed.append('unitdist')
            showIndent(outfile, level)
            outfile.write('unitdist = "%s",\n' % (self.unitdist,))
        if self.altunitdist is not None and 'altunitdist' not in already_processed:
            already_processed.append('altunitdist')
            showIndent(outfile, level)
            outfile.write('altunitdist = "%s",\n' % (self.altunitdist,))
        if self.display is not None and 'display' not in already_processed:
            already_processed.append('display')
            showIndent(outfile, level)
            outfile.write('display = "%s",\n' % (self.display,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distance', node)
        if value is not None and 'distance' not in already_processed:
            already_processed.append('distance')
            self.distance = value
        value = find_attr_value_('style', node)
        if value is not None and 'style' not in already_processed:
            already_processed.append('style')
            self.style = value
        value = find_attr_value_('multiple', node)
        if value is not None and 'multiple' not in already_processed:
            already_processed.append('multiple')
            self.multiple = value
        value = find_attr_value_('altdistance', node)
        if value is not None and 'altdistance' not in already_processed:
            already_processed.append('altdistance')
            self.altdistance = value
        value = find_attr_value_('altunit', node)
        if value is not None and 'altunit' not in already_processed:
            already_processed.append('altunit')
            self.altunit = value
        value = find_attr_value_('unitdist', node)
        if value is not None and 'unitdist' not in already_processed:
            already_processed.append('unitdist')
            self.unitdist = value
        value = find_attr_value_('altunitdist', node)
        if value is not None and 'altunitdist' not in already_processed:
            already_processed.append('altunitdist')
            self.altunitdist = value
        value = find_attr_value_('display', node)
        if value is not None and 'display' not in already_processed:
            already_processed.append('display')
            self.display = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class grid


class layer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, color=None, number=None, visible=None, active=None, fill=None):
        self.name = _cast(None, name)
        self.color = _cast(None, color)
        self.number = _cast(None, number)
        self.visible = _cast(None, visible)
        self.active = _cast(None, active)
        self.fill = _cast(None, fill)
        pass
    def factory(*args_, **kwargs_):
        if layer.subclass:
            return layer.subclass(*args_, **kwargs_)
        else:
            return layer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_active(self):
        return self.active
    def set_active(self, active):
        self.active = active
    def get_fill(self):
        return self.fill
    def set_fill(self, fill):
        self.fill = fill
    def export(self, outfile, level, namespace_='t:', name_='layer', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='layer')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='layer'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.append('color')
            outfile.write(' color=%s' % (self.gds_format_string(quote_attrib(self.color).encode(ExternalEncoding),
                input_name='color'), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            outfile.write(' number=%s' % (self.gds_format_string(quote_attrib(self.number).encode(ExternalEncoding),
                input_name='number'), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            outfile.write(' visible=%s' % (self.gds_format_string(quote_attrib(self.visible).encode(ExternalEncoding),
                input_name='visible'), ))
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            outfile.write(' active=%s' % (self.gds_format_string(quote_attrib(self.active).encode(ExternalEncoding),
                input_name='active'), ))
        if self.fill is not None and 'fill' not in already_processed:
            already_processed.append('fill')
            outfile.write(' fill=%s' % (self.gds_format_string(quote_attrib(self.fill).encode(ExternalEncoding),
                input_name='fill'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='layer', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='layer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.color is not None and 'color' not in already_processed:
            already_processed.append('color')
            showIndent(outfile, level)
            outfile.write('color = "%s",\n' % (self.color,))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            showIndent(outfile, level)
            outfile.write('number = "%s",\n' % (self.number,))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            showIndent(outfile, level)
            outfile.write('visible = "%s",\n' % (self.visible,))
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            showIndent(outfile, level)
            outfile.write('active = "%s",\n' % (self.active,))
        if self.fill is not None and 'fill' not in already_processed:
            already_processed.append('fill')
            showIndent(outfile, level)
            outfile.write('fill = "%s",\n' % (self.fill,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.append('color')
            self.color = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.append('number')
            self.number = value
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            self.visible = value
        value = find_attr_value_('active', node)
        if value is not None and 'active' not in already_processed:
            already_processed.append('active')
            self.active = value
        value = find_attr_value_('fill', node)
        if value is not None and 'fill' not in already_processed:
            already_processed.append('fill')
            self.fill = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class layer


class classxx(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, width=None, number=None, drill=None, name=None, clearance=None):
        self.width = _cast(None, width)
        self.number = _cast(None, number)
        self.drill = _cast(None, drill)
        self.name = _cast(None, name)
        if clearance is None:
            self.clearance = []
        else:
            self.clearance = clearance
    def factory(*args_, **kwargs_):
        if classxx.subclass:
            return classxx.subclass(*args_, **kwargs_)
        else:
            return classxx(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clearance(self):
        return self.clearance
    def set_clearance(self, clearance):
        self.clearance = clearance
    def add_clearance(self, value):
        self.clearance.append(value)
    def insert_clearance(self, index, value):
        self.clearance[index] = value
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_drill(self):
        return self.drill
    def set_drill(self, drill):
        self.drill = drill
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def export(self, outfile, level, namespace_='t:', name_='class', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='class')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='class'):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width=%s' % (self.gds_format_string(quote_attrib(self.width).encode(ExternalEncoding),
                input_name='width'), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            outfile.write(' number=%s' % (self.gds_format_string(quote_attrib(self.number).encode(ExternalEncoding),
                input_name='number'), ))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            outfile.write(' drill=%s' % (self.gds_format_string(quote_attrib(self.drill).encode(ExternalEncoding),
                input_name='drill'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='class', fromsubclass_=False):
        for clearance_ in self.clearance:
            clearance_.export(outfile, level, namespace_, name_='clearance')
    def hasContent_(self):
        if (
            self.clearance
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='class'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = "%s",\n' % (self.width,))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            showIndent(outfile, level)
            outfile.write('number = "%s",\n' % (self.number,))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            showIndent(outfile, level)
            outfile.write('drill = "%s",\n' % (self.drill,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('clearance=[\n')
        level += 1
        for clearance_ in self.clearance:
            showIndent(outfile, level)
            outfile.write('model_.clearance(\n')
            clearance_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            self.width = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.append('number')
            self.number = value
        value = find_attr_value_('drill', node)
        if value is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            self.drill = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'clearance':
            obj_ = clearance.factory()
            obj_.build(child_)
            self.clearance.append(obj_)
# end class classxx


class clearance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classxx=None, value=None):
        self.classxx = _cast(None, classxx)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if clearance.subclass:
            return clearance.subclass(*args_, **kwargs_)
        else:
            return clearance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_class(self):
        return self.classxx
    def set_class(self, classxx):
        self.classxx = classxx
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def export(self, outfile, level, namespace_='t:', name_='clearance', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='clearance')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='clearance'):
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding),
                input_name='class'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding),
                input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='clearance', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='clearance'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class clearance


class description(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, language=None, valueOf_=None, mixedclass_=None, content_=None):
        self.language = _cast(None, language)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_valueOf_(self):
        return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='t:', name_='description', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='description')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='description'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.append('language')
            outfile.write(' language=%s' % (self.gds_format_string(quote_attrib(self.language).encode(ExternalEncoding),
                input_name='language'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='description', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='description'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.language is not None and 'language' not in already_processed:
            already_processed.append('language')
            showIndent(outfile, level)
            outfile.write('language = "%s",\n' % (self.language,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.append('language')
            self.language = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class description


class param(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if param.subclass:
            return param.subclass(*args_, **kwargs_)
        else:
            return param(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def export(self, outfile, level, namespace_='t:', name_='param', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='param')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='param'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding),
                input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='param', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='param'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class param


class passxx(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, active=None, name=None, refer=None, param=None):
        self.active = _cast(None, active)
        self.name = _cast(None, name)
        self.refer = _cast(None, refer)
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if passxx.subclass:
            return passxx.subclass(*args_, **kwargs_)
        else:
            return passxx(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_param(self):
        return self.param
    def set_param(self, param):
        self.param = param
    def add_param(self, value):
        self.param.append(value)
    def insert_param(self, index, value):
        self.param[index] = value
    def get_active(self):
        return self.active
    def set_active(self, active):
        self.active = active
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_refer(self):
        return self.refer
    def set_refer(self, refer):
        self.refer = refer
    def export(self, outfile, level, namespace_='t:', name_='pass', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pass')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='pass'):
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            outfile.write(' active=%s' % (self.gds_format_string(quote_attrib(self.active).encode(ExternalEncoding),
                input_name='active'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding),
                input_name='name'), ))
        if self.refer is not None and 'refer' not in already_processed:
            already_processed.append('refer')
            outfile.write(' refer=%s' % (self.gds_format_string(quote_attrib(self.refer).encode(ExternalEncoding),
                input_name='refer'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='pass', fromsubclass_=False):
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param')
    def hasContent_(self):
        if (
            self.param
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pass'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            showIndent(outfile, level)
            outfile.write('active = "%s",\n' % (self.active,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.refer is not None and 'refer' not in already_processed:
            already_processed.append('refer')
            showIndent(outfile, level)
            outfile.write('refer = "%s",\n' % (self.refer,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('param=[\n')
        level += 1
        for param_ in self.param:
            showIndent(outfile, level)
            outfile.write('model_.param(\n')
            param_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('active', node)
        if value is not None and 'active' not in already_processed:
            already_processed.append('active')
            self.active = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('refer', node)
        if value is not None and 'refer' not in already_processed:
            already_processed.append('refer')
            self.refer = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.param.append(obj_)
# end class passxx


class approved(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hash=None):
        self.hash = _cast(None, hash)
        pass
    def factory(*args_, **kwargs_):
        if approved.subclass:
            return approved.subclass(*args_, **kwargs_)
        else:
            return approved(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hash(self): return self.hash
    def set_hash(self, hash): self.hash = hash
    def export(self, outfile, level, namespace_='t:', name_='approved', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='approved')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='approved'):
        if self.hash is not None and 'hash' not in already_processed:
            already_processed.append('hash')
            outfile.write(' hash=%s' % (self.gds_format_string(quote_attrib(self.hash).encode(ExternalEncoding),
                input_name='hash'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='approved', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='approved'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hash is not None and 'hash' not in already_processed:
            already_processed.append('hash')
            showIndent(outfile, level)
            outfile.write('hash = "%s",\n' % (self.hash,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hash', node)
        if value is not None and 'hash' not in already_processed:
            already_processed.append('hash')
            self.hash = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class approved


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eagle'
        rootClass = eagle
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_=rootTag, 
##         namespacedef_='')
    del rootTag
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eagle'
        rootClass = eagle
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="eagle",
##         namespacedef_='')
    del rootTag
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eagle'
        rootClass = eagle
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from generated import *\n\n')
##     sys.stdout.write('import generated as model_\n\n')
##     sys.stdout.write('rootObj = model_.rootTag(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##     sys.stdout.write(')\n')
    del rootTag
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "approved",
    "attribute",
    "attributes",
    "autorouter",
    "board",
    "bus",
    "busses",
    "circle",
    "classes",
    "classxx",
    "clearance",
    "compatibility",
    "connect",
    "connects",
    "contactref",
    "description",
    "designrules",
    "device",
    "devices",
    "deviceset",
    "devicesets",
    "dimension",
    "drawing",
    "eagle",
    "element",
    "elements",
    "errors",
    "frame",
    "gate",
    "gates",
    "grid",
    "hole",
    "instance",
    "instances",
    "junction",
    "label",
    "layer",
    "layers",
    "libraries",
    "library",
    "net",
    "nets",
    "note",
    "package",
    "packages",
    "pad",
    "param",
    "part",
    "parts",
    "passxx",
    "pin",
    "pinref",
    "plain",
    "polygon",
    "rectangle",
    "schematic",
    "segment",
    "setting",
    "settings",
    "sheet",
    "sheets",
    "signal",
    "signals",
    "smd",
    "symbol",
    "symbols",
    "technologies",
    "technology",
    "text",
    "variant",
    "variantdef",
    "variantdefs",
    "vertex",
    "via",
    "wire"
    ]

########NEW FILE########
__FILENAME__ = fritzing
#!/usr/bin/env python2
""" The Fritzing Format Parser """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from upconvert.core.design import Design
from upconvert.core.components import Component, Symbol, SBody, Pin
from upconvert.core.component_instance import ComponentInstance, SymbolAttribute
from upconvert.core.shape import Circle, Line, Polygon, Rectangle, BezierCurve
from upconvert.core.net import Net, NetPoint, ConnectedComponent

from upconvert.library.fritzing import lookup_part

from xml.etree.ElementTree import ElementTree

from os.path import basename, dirname, exists, join

import re, zipfile


class Fritzing(object):
    """ The Fritzing Format Parser

    Connection points in a fritzing file are identified by a 'module
    index' which references a component instance or a wire, and a
    'connector id' which references a specific pin. Together the
    (index, connid) tuple uniquely identifies a connection point.
    """

    def __init__(self):
        self.design = Design()
        self.body = None

        # This maps fritzing connector keys to (x, y) coordinates
        self.connkey2xy = {} # (index, connid) -> (x, y)

        # This maps fritzing component indices to ComponentInstances
        self.component_instances = {} # index -> ComponentInstance

        # Map connector keys to the list of connector keys they
        # are connected to.
        self.connects = {} # (index, connid) -> [(index, connid)]

        self.components = {} # idref -> ComponentParser

        self.fritzing_version = None
        self.fzz_zipfile = None # The ZipFile if we are parsing an fzz


    @staticmethod
    def auto_detect(filename):
        """ Return our confidence that the given file is an fritzing file """
        with open(filename, 'r') as f:
            data = f.read(4096)
        confidence = 0
        if 'fritzingVersion' in data:
            confidence += 0.9
        elif filename.endswith('.fzz'):
            confidence += 0.9
        if confidence == 0 and zipfile.is_zipfile(filename):
            zip_file = zipfile.ZipFile(filename)
            for name in zip_file.namelist():
                if name.endswith('.fz'):
                    confidence += 0.9
                    break
            zip_file.close()
        return confidence


    def parse(self, filename):
        """ Parse a Fritzing file into a design """

        tree = self.make_tree(filename)

        self.fritzing_version = tree.getroot().get('fritzingVersion', '0')

        for element in tree.findall('instances/instance'):
            self.parse_instance(element)

        for idref, cpt_parser in self.components.iteritems():
            self.design.add_component(idref, cpt_parser.component)

        for cptinst in self.component_instances.itervalues():
            self.design.add_component_instance(cptinst)

        for net in self.build_nets():
            self.design.add_net(net)

        return self.design


    def make_tree(self, filename):
        """
        Return an ElementTree for the given file name.
        """

        if zipfile.is_zipfile(filename):
            self.fzz_zipfile = zipfile.ZipFile(filename)
            fz_name = [name for name in self.fzz_zipfile.namelist()
                       if name.endswith('.fz')][0]
            fz_file = self.fzz_zipfile.open(fz_name)
        else:
            fz_file = filename

        return ElementTree(file=fz_file)

    def parse_instance(self, instance):
        """ Parse a Fritzing instance block """

        if instance.get('moduleIdRef') == 'WireModuleID':
            self.parse_wire(instance)
        else:
            self.parse_component_instance(instance)


    def parse_wire(self, inst):
        """ Parse a Fritzing wire instance """

        view = inst.find('views/schematicView')

        if view is None:
            return

        index = inst.get('modelIndex')
        geom = view.find('geometry')

        origin_x, origin_y = get_x(geom), get_y(geom)

        conn_keys = []

        for connects in view.findall('connectors/connector/connects/connect'):
            if connects.get('layer') == 'breadboardbreadboard':
                return

        for i, connector in enumerate(view.findall('connectors/connector'), 1):
            cid = connector.get('connectorId')
            self.connkey2xy[index, cid] = (origin_x + get_x(geom, 'x%d' % i),
                                           origin_y + get_y(geom, 'y%d' % i))

            conn_keys.append((index, cid))

            self.connects[index, cid] = \
                [(c.get('modelIndex'), c.get('connectorId'))
                 for c in connector.findall('connects/connect')]

        # connect wire ends to each other
        if len(conn_keys) >= 2:
            self.connects[conn_keys[0]].append(conn_keys[1])
            self.connects[conn_keys[1]].append(conn_keys[0])


    def ensure_component(self, inst):
        """ If we have not already done so, create the Component the
        given Fritzing instance is an instance of. Return the
        Component, or None if we cannot load it"""

        idref = inst.get('moduleIdRef')

        if idref in self.components:
            return self.components[idref]

        fzp_path = inst.get('path')
        if not fzp_path:
            return None

        if exists(fzp_path):
            fzp_file = fzp_path
        else:
            fzp_file = self.lookup_fzz_file(fzp_path, 'part')

        if not fzp_file:
            fzp_file = lookup_part(fzp_path, self.fritzing_version)
            if fzp_file is not None:
                fzp_path = fzp_file

        if not fzp_file:
            return None

        parser = ComponentParser(idref)
        parser.parse_fzp(fzp_file)

        if parser.image is not None:
            svg_file = self.lookup_fzz_file(parser.image, 'svg.schematic')

            if svg_file is None:
                fzp_dir = dirname(fzp_path)
                parts_dir = dirname(fzp_dir)
                svg_path = join(parts_dir, 'svg', basename(fzp_dir),
                                parser.image)

                if exists(svg_path):
                    svg_file = svg_path

            if svg_file is not None:
                parser.parse_svg(svg_file)

        self.components[idref] = parser

        return parser


    def lookup_fzz_file(self, path, prefix):
        """ Find a file in our fzz archive, if any """

        if not self.fzz_zipfile:
            return None

        fzz_name = prefix + '.' + basename(path)

        try:
            self.fzz_zipfile.getinfo(fzz_name)
        except KeyError:
            return None
        else:
            return self.fzz_zipfile.open(fzz_name)


    def parse_component_instance(self, inst):
        """ Parse a Fritzing non-wire instance into a ComponentInstance """

        view = inst.find('views/schematicView')

        if view is None:
            return

        if view.get('layer') == 'breadboardbreadboard':
            return

        cpt = self.ensure_component(inst)

        if cpt is None:
            return

        index = inst.get('modelIndex')
        idref = inst.get('moduleIdRef')
        title = inst.find('title').text
        geom = view.find('geometry')
        xform = geom.find('transform')

        x, y = float(geom.get('x', 0)), float(geom.get('y', 0))

        if xform is None:
            rotation = 0.0
        else:
            matrix = tuple(int(float(xform.get(key, 0)))
                           for key in ('m11', 'm12', 'm21', 'm22'))
            x, y = rotate_component(cpt, matrix, x, y)
            rotation = MATRIX2ROTATION.get(matrix, 0.0)

        compinst = ComponentInstance(title, cpt, idref, 0)

        compinst.add_symbol_attribute(
            SymbolAttribute(make_x(x), make_y(y), rotation, False))

        self.component_instances[index] = compinst


    def build_nets(self):
        """ Build the nets from the connects, points, and instances """

        xy2point = {} # x, y -> NetPoint

        def get_point(connkey):
            """ Return a new or existing NetPoint for an (x,y) coordinate """
            x, y = self.connkey2xy[connkey]
            if (x, y) not in xy2point:
                xy2point[x, y] = NetPoint('%da%d' % (x, y), x, y)
            return xy2point[x, y]

        # connector key -> NetPoint
        connkey2point = dict((ck, get_point(ck)) for ck in self.connkey2xy)

        todo = set(self.connects) # set([(connector  key)])
        point2net = {} # NetPoint -> Net
        nets = set()

        def get_net(point):
            """ Return a new or existing Net for a NetPoint. """
            if point not in point2net:
                point2net[point] = Net(str(len(nets)))
                nets.add(point2net[point])
            return point2net[point]

        def combine_nets(n1, n2):
            """Add net n2 into n1, get rid of n1."""
            for point in n2.points.itervalues():
                n1.add_point(point)
                point2net[point] = n1
            nets.discard(n2)

        def connect(p1, p2):
            """ Connect two points in a net, maybe the same point """

            net = get_net(p1)
            point2net[p1] = net
            net.add_point(p1)

            if point2net.get(p2, net) is not net:
                combine_nets(net, point2net[p2])
            else:
                net.add_point(p2)
                point2net[p2] = net

            if p1 is p2:
                return

            if p2.point_id not in p1.connected_points:
                p1.connected_points.append(p2.point_id)
            if p1.point_id not in p2.connected_points:
                p2.connected_points.append(p1.point_id)

        def add_to_net(main_key):
            """ Update a net with a new set of connects """

            todo.discard(main_key)

            main_point = connkey2point[main_key]
            connect(main_point, main_point)

            remaining = []

            for conn_key in self.connects[main_key]:
                if conn_key in todo:
                    remaining.append(conn_key)

                if conn_key in connkey2point:
                    connect(main_point, connkey2point[conn_key])
                elif conn_key[0] in self.component_instances:
                    inst = self.component_instances[conn_key[0]]
                    cpt_parser = self.components[inst.library_id]
                    cpt_parser.connect_point(conn_key[1], inst, main_point)

            return remaining

        while todo:
            remaining = [todo.pop()]
            while remaining:
                remaining.extend(add_to_net(remaining.pop(0)))

        nets = sorted(nets, key = lambda n : int(n.net_id))

        for i, net in enumerate(nets):
            net.net_id = str(i)

        return nets


# map fritzing rotation matrices to pi radians
MATRIX2ROTATION = {(1, 0, 0, 1): 0,
                   (0, 1, -1, 0): 0.5,
                   (-1, 0, 0, -1): 1,
                   (0, -1, 1, 0): 1.5}


class ComponentParser(object):
    """I parse components from Fritzing libraries."""

    # The svg files in fritzing libraries are specified in pixels that
    # are 72dpi. The schematics are in 90dpi.
    svg_mult = 90.0 / 72.0

    def __init__(self, idref):
        self.component = Component(idref)
        self.next_pin_number = 0
        self.cid2termid = {} # connid -> termid
        self.termid2pin = {} # termid -> Pin
        self.terminals = set()
        self.width = 0.0
        self.height = 0.0


    def parse_fzp(self, fzp_file):
        """ Parse the Fritzing component file """

        tree = ElementTree(file=fzp_file)

        try:
            prefix = tree.find('label').text
        except AttributeError:
            pass
        else:
            self.component.add_attribute('_prefix', prefix)

        symbol = Symbol()
        self.component.add_symbol(symbol)

        self.body = SBody()
        symbol.add_body(self.body)

        self.cid2termid.update(self.parse_terminals(tree))
        self.terminals.update(self.cid2termid.values())

        layers = tree.find('views/schematicView/layers')
        if layers is None:
            self.image = None
        else:
            self.image = layers.get('image')


    def connect_point(self, cid, inst, point):
        """ Given a connector id, instance id, and a NetPoint,
        add the appropriate ConnectedComponent to the point """

        termid = self.cid2termid.get(cid)
        pin = self.termid2pin.get(termid)

        if pin is not None:
            ccpt = ConnectedComponent(inst.instance_id, pin.pin_number)
            point.add_connected_component(ccpt)


    def get_next_pin_number(self):
        """ Return the next pin number """

        nextpn = self.next_pin_number
        self.next_pin_number += 1
        return str(nextpn)


    def parse_terminals(self, tree):
        """ Return a dictionary mapping connector id's to terminal id's """

        cid2termid = {}

        for conn in tree.findall('connectors/connector'):
            plug = conn.find('views/schematicView/p')
            if plug is None:
                continue

            termid = plug.get('terminalId')
            if termid is None:
                termid = plug.get('svgId')

            if termid is not None:
                cid2termid[conn.get('id')] = termid

        return cid2termid


    def parse_svg(self, svg_file):
        """ Parse the shapes and pins from an svg file """

        tree = ElementTree(file=svg_file)
        viewbox = tree.getroot().get('viewBox')

        if viewbox != None:
            self.width, self.height = [float(v) for v in viewbox.split()[-2:]]
            self.width *= self.svg_mult
            self.height *= self.svg_mult

        _iter = tree.getroot().getiterator()
        for element in _iter:
            for shape in self.parse_shapes(element):
                self.body.add_shape(shape)
                if element.get('id') in self.terminals:
                    pin = get_pin(shape)
                    if pin is not None:
                        pin.pin_number = self.get_next_pin_number()
                        self.termid2pin[element.get('id')] = pin
                        self.body.add_pin(pin)


    def parse_shapes(self, element):
        """ Parse a list of shapes from an svg element """

        tag = element.tag.rsplit('}', -1)[-1]

        if tag == 'circle':
            return self.parse_circle(element)
        elif tag == 'rect':
            return self.parse_rect(element)
        elif tag == 'line':
            return self.parse_line(element)
        elif tag == 'path':
            return self.parse_path(element)
        elif tag == 'polygon':
            return self.parse_polygon(element)
        elif tag == 'polyline':
            return self.parse_polyline(element)
        else:
            return []

    def parse_rect(self, rect):
        """ Parse a rect element """

        x, y = (get_x(rect, mult=self.svg_mult),
                get_y(rect, mult=self.svg_mult))
        width, height = (get_length(rect, 'width', self.svg_mult),
                         get_length(rect, 'height', self.svg_mult))
        return [Rectangle(x, y, width, height)]


    def parse_line(self, rect):
        """ Parse a line element """

        return [Line((get_x(rect, 'x1', self.svg_mult),
                      get_y(rect, 'y1', self.svg_mult)),
                     (get_x(rect, 'x2', self.svg_mult),
                      get_y(rect, 'y2', self.svg_mult)))]


    def parse_path(self, path):
        """ Parse a path element """

        return PathParser(path).parse()


    def parse_polygon(self, poly):
        """ Parse a polygon element """

        shape = Polygon()

        for point in poly.get('points', '').split():
            if point:
                x, y = point.split(',')
                shape.add_point(make_x(x, self.svg_mult),
                                make_y(y, self.svg_mult))

        if shape.points:
            shape.add_point(shape.points[0].x, shape.points[0].y)

        return [shape]


    def parse_polyline(self, poly):
        """ Parse a polyline element """

        shapes = []
        last_point = None

        for point in poly.get('points', '').split():
            if point:
                x, y = point.split(',')
                point = (make_x(x, self.svg_mult), make_y(y, self.svg_mult))
                if last_point is not None:
                    shapes.append(Line(last_point, point))
                last_point = point

        return shapes


    def parse_circle(self, circle):
        """ Parse a circle element """

        return [Circle(get_x(circle, 'cx', self.svg_mult),
                       get_y(circle, 'cy', self.svg_mult),
                       get_length(circle, 'r', self.svg_mult))]


def get_pin(shape):
    """ Return a Pin for the given shape, or None """

    if shape.type == 'rectangle':
        x = shape.x + shape.width / 2
        y = shape.y + shape.height / 2
    elif shape.type == 'circle':
        x, y = shape.x, shape.y
    else:
        return None

    return Pin('', (x, y), (x, y))


def rotate_component(cpt, matrix, x, y):
    """ Given a ComponentParser, a rotation matrix, and x/y points
    referencing the upper left edge of the Fritzing component (in
    Fritzing space), return a new pair of x/y points referencing the
    component after it is rotated about its center. Fritzing rotations
    are applied to the center of the component bounding boxes."""

    # upper left corner when origin is at center
    x1, y1 = -cpt.width / 2, -cpt.height / 2

    # rotate upper left corner
    x2, y2 = (matrix[0] * x1 + matrix[2] * y1,
              matrix[1] * x1 + matrix[3] * y1)

    # translate original coordinate
    return (x + (x2 - x1), y + (y2 - y1))


class PathParser(object):
    """ A parser for svg path elements. """

    num_re = re.compile(r'\s*(-?\d+(?:\.\d+)?)\s*,?\s*')

    svg_mult = ComponentParser.svg_mult

    def __init__(self, path):
        self.path = path
        self.shapes = []
        self.cur_point = (0, 0) # (x, y) of current point
        self.start_point = (0, 0) # (x, y) of start of current subpath
        self.prev_cmd = '' # previous path command letter
        self.prev_ctl = None # previous control point

    def parse(self):
        """ Parse the path element and return a list of shapes. """

        data = self.path.get('d', '').strip()

        while data:
            cmd = data[0].lower()
            is_relative = data[0] == cmd
            handler = getattr(self, 'parse_' + cmd, None)
            if handler is None:
                break
            else:
                data = handler(data[1:], is_relative)
                self.prev_cmd = cmd

        def is_empty_line(shape):
            """ Return True if the shape is an empty line """
            return shape.type == 'line' and shape.p1 == shape.p2

        return [s for s in self.shapes if not is_empty_line(s)]

    def parse_nums(self, data):
        """ Parse a series of numbers in an svg path. Return the
        list of numbers and the remaining portion of the path. """

        nums = []

        while data:
            match = self.num_re.match(data)

            if match is None:
                break
            else:
                nums.append(float(match.group(1)))
                data = data[len(match.group(0)):]

        return nums, data

    def parse_points(self, data):
        """ Parse a series of points in an svg path. Return the
        list of points and the remaining portion of the path """

        nums, data = self.parse_nums(data)

        return zip(nums[::2], nums[1::2]), data

    def get_path_point(self, base_point, is_relative):
        """ Return a path point given a base point and whether we
        are in relative path mode. """

        if is_relative:
            return (base_point[0] + self.cur_point[0],
                    base_point[1] + self.cur_point[1])
        else:
            return base_point

    def parse_m(self, data, is_relative):
        """ Parse an M or m (moveto) segment. """

        points, data = self.parse_points(data)

        for i, point in enumerate(points):
            point = self.get_path_point(point, is_relative)
            if i == 0:
                self.start_point = self.cur_point = point
            else: # subsequent moves are lineto's
                self.shapes.append(
                    Line(make_point(self.cur_point, self.svg_mult),
                         make_point(point, self.svg_mult)))
                self.cur_point = point

        return data


    def parse_z(self, data, is_relative):
        """ Parse a Z or z (closepath) segment. """

        self.shapes.append(
            Line(make_point(self.cur_point, self.svg_mult),
                 make_point(self.start_point, self.svg_mult)))
        self.cur_point = self.start_point

        return data


    def parse_l(self, data, is_relative):
        """ Parse an L or l (lineto) segment. """

        points, data = self.parse_points(data)

        for point in points:
            point = self.get_path_point(point, is_relative)
            self.shapes.append(
                Line(make_point(self.cur_point, self.svg_mult),
                     make_point(point, self.svg_mult)))
            self.cur_point = point

        return data


    def parse_h(self, data, is_relative):
        """ Parse an H or h (horizontal line) segment. """

        nums, data = self.parse_nums(data)

        for num in nums:
            point = (num, 0 if is_relative else self.cur_point[1])
            point = self.get_path_point(point, is_relative)
            self.shapes.append(
                Line(make_point(self.cur_point, self.svg_mult),
                     make_point(point, self.svg_mult)))
            self.cur_point = point

        return data


    def parse_v(self, data, is_relative):
        """ Parse a V or v (vertical line) segment. """

        nums, data = self.parse_nums(data)

        for num in nums:
            point = (0 if is_relative else self.cur_point[0], num)
            point = self.get_path_point(point, is_relative)
            self.shapes.append(
                Line(make_point(self.cur_point, self.svg_mult),
                     make_point(point, self.svg_mult)))
            self.cur_point = point

        return data


    def parse_c(self, data, is_relative):
        """ Parse a C or c (cubic bezier) segment. """

        points, data = self.parse_points(data)

        while points:
            start = self.cur_point

            (ctl1, ctl2, end), points = points[:3], points[3:]

            self.cur_point = ctl1 = self.get_path_point(ctl1, is_relative)
            self.cur_point = ctl2 = self.get_path_point(ctl2, is_relative)
            self.cur_point = end = self.get_path_point(end, is_relative)

            self.prev_ctl = ctl2

            self.shapes.append(
                BezierCurve(make_point(ctl1, self.svg_mult),
                            make_point(ctl2, self.svg_mult),
                            make_point(start, self.svg_mult),
                            make_point(end, self.svg_mult)))

        return data


    def parse_s(self, data, is_relative):
        """ Parse an S or s (cubic shorthand bezier) segment. """

        points, data = self.parse_points(data)

        while points:
            start = self.cur_point

            (ctl2, end), points = points[:2], points[2:]

            self.cur_point = ctl2 = self.get_path_point(ctl2, is_relative)
            self.cur_point = end = self.get_path_point(end, is_relative)

            if self.prev_cmd not in 'cs' or not self.prev_ctl:
                ctl1 = start
            else:
                ctl1 = (start[0] - (self.prev_ctl[0] - start[0]),
                        start[1] - (self.prev_ctl[1] - start[1]))

            self.prev_ctl = ctl2

            self.shapes.append(
                BezierCurve(make_point(ctl1, self.svg_mult),
                            make_point(ctl2, self.svg_mult),
                            make_point(start, self.svg_mult),
                            make_point(end, self.svg_mult)))

        return data


    def parse_q(self, data, is_relative):
        """ Parse a Q or q (quadratic bezier) segment. """

        points, data = self.parse_points(data)

        while points:
            start = self.cur_point

            (ctl, end), points = points[:2], points[2:]

            self.cur_point = ctl = self.get_path_point(ctl, is_relative)
            self.cur_point = end = self.get_path_point(end, is_relative)

            self.prev_ctl = ctl

            ctl1 = (start[0] + (2.0 / 3.0 * (ctl[0] - start[0])),
                    start[1] + (2.0 / 3.0 * (ctl[1] - start[1])))

            ctl2 = (end[0] + (2.0 / 3.0 * (ctl[0] - end[0])),
                    end[1] + (2.0 / 3.0 * (ctl[1] - end[1])))

            self.shapes.append(
                BezierCurve(make_point(ctl1, self.svg_mult),
                            make_point(ctl2, self.svg_mult),
                            make_point(start, self.svg_mult),
                            make_point(end, self.svg_mult)))

        return data


    def parse_t(self, data, is_relative):
        """ Parse a T or t (quadratic shorthand bezier) segment. """

        points, data = self.parse_points(data)

        while points:
            start = self.cur_point

            end, points = points[0], points[1:]

            self.cur_point = end = self.get_path_point(end, is_relative)

            if self.prev_cmd not in 'qt' or not self.prev_ctl:
                ctl = start
            else:
                ctl = (start[0] - (self.prev_ctl[0] - start[0]),
                       start[1] - (self.prev_ctl[1] - start[1]))

            self.prev_ctl = ctl

            ctl1 = (start[0] + (2.0 / 3.0 * (ctl[0] - start[0])),
                    start[1] + (2.0 / 3.0 * (ctl[1] - start[1])))

            ctl2 = (end[0] + (2.0 / 3.0 * (ctl[0] - end[0])),
                    end[1] + (2.0 / 3.0 * (ctl[1] - end[1])))

            self.shapes.append(
                BezierCurve(make_point(ctl1, self.svg_mult),
                            make_point(ctl2, self.svg_mult),
                            make_point(start, self.svg_mult),
                            make_point(end, self.svg_mult)))

        return data


def make_x(x, mult=1.0):
    """ Make an openjson x coordinate from a fritzing x coordinate """
    return int(round(float(x) * mult))

def make_y(y, mult=1.0):
    """ Make an openjson y coordinate from a fritzing y coordinate """
    return -int(round(float(y) * mult))

def make_length(value, mult=1.0):
    """ Make a length measurement from a fritzing measurement """
    return int(round(float(value) * mult))

def make_point(point, mult=1.0):
    """ Make a point from a fritzing point """
    return (make_x(point[0], mult=mult), make_y(point[1], mult=mult))

def get_x(element, name='x', mult=1.0):
    """ Get an openjson x coordinate from a fritzing element """
    return make_x(element.get(name, 0), mult)

def get_y(element, name='y', mult=1.0):
    """ Get an openjson y coordinate from a fritzing element """
    return make_y(element.get(name, 0), mult)

def get_length(element, name, mult=1.0):
    """ Get an openjson length from a fritzing element """
    return make_length(element.get(name, 0), mult)

########NEW FILE########
__FILENAME__ = geda
#! /usr/bin/env python2
# pylint: disable=C0302
""" This module provides a parser for the gEDA format into a
    OpenJSON design. The OpenJSON format does not provide
    color/style settings, hence, color/style data from the
    gEDA format is ignored.
    The module provides a parser class :py:class:GEDA that
    implements all parsing functionality. To parse a gEDA
    schematic file into a design do the following:

    >>> parser = GEDA()
    >>> design = parser.parse('example_geda_file.sch')

    The gEDA format relies highly on referencing symbol files
    that are mostly provided in an installation directory of
    the gEDA tool chain. To parse these symbol files it is
    required to provide the symbol directories. Specify symbol
    directories as follows:

    >>> symbol_directories = ['/usr/share/gEDA/sym', './sym']
    >>> parser = GEDA(symbol_dirs=symbol_directories)
    >>> design = parser.parse('example_geda_file.sch')
"""

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Basic Strategy
# 0) Extracting ONLY relevant data from gEDA format. ALL
#   color/style data is ignored
# 1) Parsing the schematic file to extract components & instances
# 2) Create components and instances as they occur in the file
# 2.1) Parse referenced symbol files (components) into components
# 2.2) Parse EMBEDDED symbols into components
# 3) Store net segments for later processing
# 4) Calculate nets from segments
#
# NOTE: The gEDA format is based on a 100x100 MILS grid where
# 1 MILS is equal to 1/1000 of an inch. In a vanilla gEDA file
# a blueprint-style frame is present with origin at
# (40'000, 40'000).

import os
import zipfile
import logging
import tempfile
import itertools

from collections import defaultdict
from math import pi, cos, sin
from StringIO import StringIO

from upconvert.core import shape
from upconvert.core import components
from upconvert.core import net

from upconvert.core.design import Design
from upconvert.core.annotation import Annotation
from upconvert.core.component_instance import ComponentInstance
from upconvert.core.component_instance import SymbolAttribute

from upconvert.parser import geda_commands

# pylint: disable=R0904

# Logging
log = logging.getLogger('parser.geda') # pylint: disable=C0103

UNKNOWN_COMPONENT = """v 20110115 2
T 0 0 9 3 1 0 0 0 1
Symbol Unknown '%s'"""

class GEDAText(object):
    """ Class representation of text as in GEDA format. """

    def __init__(self, content, attribute=None, params=None):
        self.attribute = attribute
        self.content = content
        self.params = params or {}

    def is_attribute(self):
        """ Returns True when text is attribute. """
        return bool(self.attribute is not None)

    def is_text(self):
        """ Returns True when text is regular text. """
        return bool(self.attribute is None)

    def store_styles_in_label(self, label):
        """
        Store all available style parameters in ``styles``
        property of ``label``. Returns ``label``.
        """
        for key, value in self.params.items():
            if key.startswith(geda_commands.GEDAStyleParameter.TYPE):
                label.styles[key] = value
        return label

    def as_label(self):
        """
        Generate label from text object using parsed parameters.

        Returns ``Label`` instance.
        """
        text_x = self.params.get('x', 0)

        if self.params.get('mirrored', False):
            text_x = 0 - text_x

        label = shape.Label(
            text_x,
            self.params.get('y', 0),
            self.content,
            align='left',
            rotation=self.params.get('angle', 0),
        )
        return self.store_styles_in_label(label)

    @classmethod
    def from_command(cls, stream, params):
        """
        Create a ``GEDAText`` instance from *stream* and previously
        parse *params*. The stream is expected to be as long as the
        ``numb_lines`` property in *params*. The same amount of lines
        are parsed in stream to make up the *attribute*, *content*
        properties of the ``GEDAText`` instance.

        Returns a newly created ``GEDAText`` instance.
        """
        num_lines = params['num_lines']

        attribute = None
        content = [stream.readline() for _ in range(int(num_lines))]
        content = ''.join(content).strip()

        ## escape special parameter sequence '\_'
        content = content.replace("\_", '')

        if num_lines == 1 and '=' in content:
            attribute, content = content.split('=', 1)

            if attribute == 'refdes':
                return cls(content, attribute=attribute, params=params)

            ## prefix attributes that are marked as invisible
            if params['visibility'] == 0:
                attribute = "_" + attribute
            ## these are special attributes that are treated differently
            elif attribute in ['netname', 'pinnumber', 'pinlabel']:
                attribute = "_" + attribute

        return cls(content, attribute=attribute, params=params)


class GEDAError(Exception):
    """ Exception class for gEDA parser errors """
    pass


class GEDA:
    """ The GEDA Format Parser """
    # pylint: disable=R0902

    DELIMITER = ' '
    SCALE_FACTOR = 10.0  # maps 1000 MILS to 10 pixels

    OBJECT_TYPES = {
        'v': geda_commands.GEDAVersionCommand(),
        'L': geda_commands.GEDALineCommand(),
        'B': geda_commands.GEDABoxCommand(),
        'V': geda_commands.GEDACircleCommand(),
        'A': geda_commands.GEDAArcCommand(),
        'T': geda_commands.GEDATextCommand(),
        'N': geda_commands.GEDASegmentCommand(),
        'U': geda_commands.GEDABusCommand(),
        'P': geda_commands.GEDAPinCommand(),
        'C': geda_commands.GEDAComponentCommand(),
        'H': geda_commands.GEDAPathCommand(),
        ## valid types but are ignored
        'G': geda_commands.GEDAPictureCommand(),
        ## environments
        '{': geda_commands.GEDAEmbeddedEnvironmentCommand(),
        '}': [],  # attributes
        '[': geda_commands.GEDAAttributeEnvironmentCommand(),
        ']': [],  # embedded component
    }

    def __init__(self, symbol_dirs=None):
        """ Constuct a gEDA parser object. Specifying a list of symbol
            directories in *symbol_dir* will provide a symbol file
            lookup in the specified directories. The lookup will be
            generated instantly examining each directory (if it exists).

            Kwargs:
                symbol_dirs (list): List of directories containing .sym
                    files
        """
        self.offset = shape.Point(40000, 40000)
        ## Initialise frame size with largest possible size
        self.frame_width = 0
        self.frame_height = 0

        # initialise PIN counter
        self.pin_counter = itertools.count(0)
        # initialise  PATH counter
        self.path_counter = itertools.count(0)

        if symbol_dirs is None:
            symbol_dirs = []
        ## add flag to allow for auto inclusion
        symbol_dirs = symbol_dirs + \
            [os.path.join(os.path.dirname(__file__), '..', 'library', 'geda')]

        self.known_symbols = find_symbols(symbol_dirs)

        self.design = None
        self.segments = None
        self.net_points = None
        self.component_pins = None
        self.net_names = None
        self.geda_zip = None
        self.instance_ids = None
        self.instance_counter = None

    @staticmethod
    def auto_detect(filename):
        """ Return our confidence that the given file is an geda schematic """
        with open(filename, 'rU') as f:  # pylint: disable=C0103
            data = f.read()
        confidence = 0
        if data[0:2] == 'v ':
            confidence += 0.51
        if 'package=' in data:
            confidence += 0.25
        if 'footprint=' in data:
            confidence += 0.25
        if 'refdes=' in data:
            confidence += 0.25
        if 'netname=' in data:
            confidence += 0.25
        return confidence

    def set_offset(self, point):
        """ Set the offset point for the gEDA output. As OpenJSON
            positions the origin in the center of the viewport and
            gEDA usually uses (40'000, 40'000) as page origin, this
            allows for translating from one coordinate system to
            another. It expects a *point* object providing a *x* and
            *y* attribute.
        """
        ## create an offset of 5 grid squares from origin (0,0)
        self.offset.x = point.x
        self.offset.y = point.y

    def parse(self, inputfile):
        """ Parse a gEDA file into a design.

            Returns the design corresponding to the gEDA file.
        """
        directory, _ = os.path.split(inputfile)

        for dir_file in os.listdir(directory):
            if dir_file.endswith('.sym'):
                lib_name, _, _ = dir_file.partition('.sym')
                self.known_symbols[lib_name.lower()] = directory + '/' + dir_file

        inputfiles = []

        ## check if inputfile is in ZIP format
        if zipfile.is_zipfile(inputfile):
            self.geda_zip = zipfile.ZipFile(inputfile)
            for filename in self.geda_zip.namelist():
                if filename.endswith('.sch'):
                    inputfiles.append(filename)
        else:
            inputfiles = [inputfile]

        self.design = Design()

        ## parse frame data of first schematic to extract
        ## page size (assumes same frame for all files)
        with self._open_file_or_zip(inputfiles[0]) as stream:
            self._check_version(stream)

            for line in stream.readlines():
                if 'title' in line and line.startswith('C'):
                    obj_type, params = self._parse_command(StringIO(line))
                    assert(obj_type == 'C')

                    params['basename'], _ = os.path.splitext(params['basename'])

                    log.debug("using title file: %s", params['basename'])

                    self._parse_title_frame(params)

        ## store offset values in design attributes
        self.design.design_attributes.attributes.update({
            '_geda_offset_x': str(self.offset.x),
            '_geda_offset_y': str(self.offset.y),
            '_geda_frame_width': str(self.frame_width),
            '_geda_frame_height': str(self.frame_height),
        })

        for filename in inputfiles:
            f_in = self._open_file_or_zip(filename)
            self._check_version(f_in)

            self.parse_schematic(f_in)

            basename, _ = os.path.splitext(os.path.basename(filename))
            self.design.design_attributes.metadata.set_name(basename)

            ## modify offset for next page to be shifted to the right
            self.offset.x = self.offset.x - self.frame_width

            f_in.close()

        return self.design

    def _parse_v(self, stream, params):  # pylint: disable=W0613,R0201
        """
        Only required to be callable when 'v' command is found.
        Returns without any processing.
        """
        return

    def _parse_G(self, stream, params):  # pylint: disable=W0613,R0201,C0103
        """
        Parse picture command 'G'. Returns without any processing but
        logs a warning.
        """
        log.warn("ignoring picture/font in gEDA file. Not supported!")
        return

    def parse_setup(self):
        """ Set up class data structures for parsing
        """
        # pylint: disable=R0912
        if self.design is None:
            self.design = Design()

        self.segments = set()
        self.net_points = dict()
        self.component_pins = defaultdict(list) # (x, y) -> [NetPoint]
        self.net_names = dict()
        self.instance_ids = []
        self.instance_counter = itertools.count(0)

    def parse_schematic(self, stream):
        """ Parse a gEDA schematic provided as a *stream* object into a
            design.

            Returns the design corresponding to the schematic.
        """
        self.parse_setup()

        obj_type, params = self._parse_command(stream)

        while obj_type is not None:
            objects = getattr(self, "_parse_%s" % obj_type)(stream, params)

            attributes = self._parse_environment(stream)
            self.design.design_attributes.attributes.update(attributes or {})

            self.add_objects_to_design(self.design, objects)

            obj_type, params = self._parse_command(stream)

        ## process net segments into nets & net points and add to design
        self.divide_segments()

        for cnet in sorted(self.calculate_nets(), key=lambda n: n.net_id):
            self.design.add_net(cnet)

        return self.design

    def _parse_title_frame(self, params):
        """ Parse the frame component in *params* to extract the
            page size to be used in the design. The offset is adjusted
            according to the bottom-left position of the frame.
        """
        ## set offset based on bottom-left corner of frame
        self.offset.x = params['x']
        self.offset.y = params['y']

        filename = self.known_symbols.get(params['basename'].lower())
        if not filename or not os.path.exists(filename):
            log.warn("could not find title symbol '%s'" % params['basename'])
            self.frame_width = 46800
            self.frame_height = 34000
            return

        ## store title component name in design
        self.design.design_attributes.add_attribute(
            '_geda_titleframe', params['basename'],
        )

        with open(filename, 'rU') as stream:
            obj_type, params = self._parse_command(stream)

            while obj_type is not None:

                if obj_type == 'B':
                    if params['width'] > self.frame_width:
                        self.frame_width = params['width']

                    if params['height'] > self.frame_height:
                        self.frame_height = params['height']

                ## skip commands covering multiple lines
                elif obj_type in ['T', 'H']:
                    for _ in range(params['num_lines']):
                        stream.readline()

                obj_type, params = self._parse_command(stream)

            ## set width to estimated max value when no box was found
            if self.frame_width == 0:
                self.frame_width = 46800

            ## set height to estimated max value when no box was found
            if self.frame_height == 0:
                self.frame_height = 34000

    def _create_ripper_segment(self, params):
        """ Creates a new segment from the busripper provided
            in gEDA. The busripper is a graphical feature that
            provides a nicer look for a part of a net. The bus
            rippers are turned into net segments according to the
            length and orientation in *params*.

            Returns a tuple of two NetPoint objects for the segment.
        """
        # pylint: disable=C0103
        x, y = params['x'], params['y']
        angle, mirror = params['angle'], params['mirror']

        if mirror:
            angle = (angle + 90) % 360

        x, y = self.conv_coords(x, y)
        pt_a = self.get_netpoint(x, y)

        ripper_size = self.to_px(200)

        ## create second point for busripper segment on bus
        if angle == 0:
            pt_b = self.get_netpoint(
                pt_a.x + ripper_size,
                pt_a.y + ripper_size
            )
        elif angle == 90:
            pt_b = self.get_netpoint(
                pt_a.x - ripper_size,
                pt_a.y + ripper_size
            )
        elif angle == 180:
            pt_b = self.get_netpoint(
                pt_a.x - ripper_size,
                pt_a.y - ripper_size
            )
        elif angle == 270:
            pt_b = self.get_netpoint(
                pt_a.x + ripper_size,
                pt_a.y - ripper_size
            )
        else:
            raise GEDAError(
                "invalid angle in component '%s'" % params['basename']
            )

        return pt_a, pt_b

    def _parse_component(self, stream, params):
        """ Creates a component instance according to the component *params*.
            If the component is not known in the library, a the component
            will be created according to its description in the embedded
            environment ``[]`` or a symbol file. The component is added
            to the library automatically if necessary.
            An instance of this component will be created and added to
            the design.
            A GEDAError is raised when either the component file
            is invalid or the referenced symbol file cannot be found
            in the known directories.

            Returns a tuple of Component and ComponentInstance objects.
        """
        # pylint: disable=C0103,R0914,R0912
        basename, _ = os.path.splitext(params['basename'])

        component_name = basename
        if params.get('mirror'):
            component_name += '_MIRRORED'

        if component_name in self.design.components.components:
            component = self.design.components.components[component_name]

            ## skipping embedded data might be required
            self.skip_embedded_section(stream)
        else:
            ##check if sym file is embedded or referenced
            if basename.startswith('EMBEDDED'):
                ## embedded only has to be processed when NOT in symbol lookup
                if basename.lower() not in self.known_symbols:
                    component = self.parse_component_data(stream, params)
            else:
                if basename.lower() not in self.known_symbols:
                    log.warn("referenced symbol file '%s' unknown" % basename)
                    ## create a unknown symbol reference
                    component = self.parse_component_data(
                        StringIO(UNKNOWN_COMPONENT % basename),
                        params
                    )
                    ## parse optional attached environment before continuing
                    self._parse_environment(stream)
                    return None, None

                ## requires parsing of referenced symbol file
                with open(self.known_symbols[basename.lower()], "rU") as f_in:
                    self._check_version(f_in)
                    component = self.parse_component_data(f_in, params)

            self.design.add_component(component_name, component)

        ## get all attributes assigned to component instance
        attributes = self._parse_environment(stream)

        def get_instance_id(name):
            """ Get unique instance ID based on *name*. If *name* already
                exists, a numeric value is appended based on the instance
                counter.
            """
            if name in self.instance_ids:
                name += '-%d' % self.instance_counter.next()

            self.instance_ids.append(name)
            return name
        ## refdes attribute is name of component (mandatory as of gEDA doc)
        ## examples if gaf repo have components without refdes, use part of
        ## basename
        if attributes is not None:
            instance = ComponentInstance(
                get_instance_id(attributes.get('refdes', component.name)),
                component,
                component.name,
                0
            )
            for key, value in attributes.items():
                instance.add_attribute(key, value)
        else:
            instance = ComponentInstance(
                get_instance_id(component.name),
                component,
                component.name,
                0
            )

        ## generate a component instance using attributes
        self.design.add_component_instance(instance)

        symbol = SymbolAttribute(
            self.x_to_px(params['x']),
            self.y_to_px(params['y']),
            self.conv_angle(params['angle']),
            False)
        instance.add_symbol_attribute(symbol)

        ## add annotation for special attributes
        for idx, attribute_key in enumerate(['refdes', 'device']):
            if attribute_key in component.attributes:
                symbol.add_annotation(
                    Annotation(
                        component.attributes[attribute_key],
                        0, (0 + idx * 10), 0.0, 'true'
                    )
                    )
            elif attribute_key in instance.attributes:
                symbol.add_annotation(
                    Annotation(
                        instance.attributes[attribute_key],
                        0, (0 + idx * 10), 0.0, 'true'
                    )
                    )

        ## parse all bodies of this component for pins and add them
        ## to the lookup with their corresponding instance. This is
        ## required to connect net points with components later on
        ## during the calculation of the nets.
        for index, body in enumerate(component.symbols[0].bodies):
            try:
                sym_attr = instance.symbol_attributes[index]
            except IndexError:
                continue

            for pin in body.pins:
                x, y = self.translate_coords(
                    pin.p2.x,
                    pin.p2.y,
                    sym_attr.rotation
                )

                coords = (sym_attr.x + x, sym_attr.y + y)

                pt = self.get_netpoint(*coords)
                pt.add_connected_component(
                    net.ConnectedComponent(instance.instance_id,
                                           pin.pin_number))

                self.component_pins[coords].append(pt)

        return component, instance

    def _check_version(self, stream):
        """ Check next line in *stream* for gEDA version data
            starting with ``v``. Raises ``GEDAError`` when no version
            data can be found.
        """
        typ, _ = self._parse_command(stream)
        if typ != 'v':
            raise GEDAError(
                "cannot convert file, not in gEDA format"
            )
        return True

    def _is_mirrored_command(self, params):  # pylint: disable=R0201
        """ Returns boolean value for 'mirror' in *params*, False by default.
        """
        return bool(params.get('mirror', False))

    def parse_component_data(self, stream, params):
        """ Creates a component from the component *params* and the
            following commands in the stream. If the component data
            is embedded in the schematic file, all coordinates will
            be translated into the origin first.
            Only a single symbol/body is created for each component
            since gEDA symbols contain exactly one description.

            Returns the newly created Component object.
        """
        # pylint: disable=R0912
        basename = os.path.splitext(params['basename'])[0]

        saved_offset = self.offset
        self.offset = shape.Point(0, 0)

        ## retrieve if component is mirrored around Y-axis
        mirror = self._is_mirrored_command(params)
        if mirror:
            basename += '_MIRRORED'

        move_to = None
        if basename.startswith('EMBEDDED'):
            move_to = (params['x'], params['y'])

        ## grab next line (should be '['
        typ, params = self._parse_command(stream, move_to)

        if typ == '[':
            typ, params = self._parse_command(stream, move_to)

        component = components.Component(basename)
        symbol = components.Symbol()
        component.add_symbol(symbol)
        body = components.SBody()
        symbol.add_body(body)

        ##NOTE: adding this attribute to make parsing UPV data easier
        ## when using re-exported UPV.
        component.add_attribute('_geda_imported', 'true')
        self.pin_counter = itertools.count(0)

        while typ is not None:
            params['mirror'] = mirror
            objects = getattr(self, "_parse_%s" % typ)(stream, params)

            attributes = self._parse_environment(stream)
            component.attributes.update(attributes or {})

            self.add_objects_to_component(component, objects)

            typ, params = self._parse_command(stream, move_to)

        self.offset = saved_offset

        return component

    def divide_segments(self):
        """ Checks all net segments for intersecting points of
            all other net segments. If an intersection is detected
            the net segment is divided into two segments with the
            intersecting point. This method has been adapted from
            a similar method in the kiCAD parser.
        """
        ## check if segments need to be divided
        add_segs = set()
        rem_segs = set()
        for segment in self.segments:
            for point in self.net_points.values():
                if self.intersects_segment(segment, point):
                    pt_a, pt_b = segment
                    rem_segs.add(segment)
                    add_segs.add((pt_a, point))
                    add_segs.add((point, pt_b))

        self.segments -= rem_segs
        self.segments |= add_segs

    def skip_embedded_section(self, stream):
        """ Reads the *stream* line by line until the end of an
            embedded section (``]``) is found. This method is used
            to skip over embedded sections of already known
            components.
        """
        pos = stream.tell()
        typ = stream.readline().split(self.DELIMITER, 1)[0].strip()

        ## return with stream reset to previous position if not
        ## an embedded section
        if typ != '[':
            stream.seek(pos)
            return

        while typ != ']':
            typ = stream.readline().split(self.DELIMITER, 1)[0].strip()

    def get_netpoint(self, x, y):  # pylint: disable=C0103
        """ Creates a new NetPoint at coordinates *x*,*y* and stores
            it in the net point lookup table. If a NetPoint does already
            exist, the existing point is returned.
            Returns a NetPoint object at coordinates *x*,*y*
        """
        if (x, y) not in self.net_points:
            self.net_points[(x, y)] = net.NetPoint('%da%d' % (x, y), x, y)
        return self.net_points[(x, y)]

    @staticmethod
    def intersects_segment(segment, pt_c):
        """ Checks if point *pt_c* lays on the *segment*. This code is
            adapted from the kiCAD parser.
            Returns True if *pt_c* is on *segment*, False otherwise.
        """
        pt_a, pt_b = segment

        #check vertical segment
        if pt_a.x == pt_b.x == pt_c.x:
            if min(pt_a.y, pt_b.y) < pt_c.y < max(pt_a.y, pt_b.y):
                return True
        #check vertical segment
        elif pt_a.y == pt_b.y == pt_c.y:
            if min(pt_a.x, pt_b.x) < pt_c.x < max(pt_a.x, pt_b.x):
                return True
        #check diagonal segment
        elif (pt_c.x - pt_a.x) * (pt_b.y - pt_a.y) \
              == (pt_b.x - pt_a.x) * (pt_c.y - pt_a.y):
            if min(pt_a.x, pt_b.x) < pt_c.x < max(pt_a.x, pt_b.x):
                return True
        ## point C not on segment
        return False

    def _parse_environment(self, stream):
        """ Checks if attribute environment starts in the next line
            (marked by '{'). Environment only contains text elements
            interpreted as text.
            Returns a dictionary of attributes.
        """
        current_pos = stream.tell()
        typ, params = self._parse_command(stream)

        #go back to previous position when no environment in stream
        if typ != '{':
            stream.seek(current_pos)
            return None

        typ, params = self._parse_command(stream)

        attributes = {}
        while typ is not None:
            if typ == 'T':
                geda_text = self._parse_T(stream, params)

                if geda_text.is_attribute():
                    attributes[geda_text.attribute] = geda_text.content
                else:
                    log.warn(
                        "normal text in environment does not comply "
                        "with GEDA format specification: %s",
                        geda_text.content
                    )

            typ, params = self._parse_command(stream)

        return attributes

    def calculate_nets(self):  # pylint: disable=R0912
        """ Calculate connected nets from previously stored segments
            and netpoints. The code has been adapted from the kiCAD
            parser since the definition of segments in the schematic
            file are similar. The segments are checked against
            existing nets and added when they touch it. For this
            to work, it is required that intersecting segments are
            divided prior to this method.

            Returns a list of valid nets and its net points.
        """
        nets = []

        used_points = set() # set([NetPoint])

        # Iterate over the segments, removing segments when added to a net
        while self.segments:
            seg = self.segments.pop()  # pick a point

            net_name = ''
            pt_a, pt_b = seg
            if pt_a.point_id in self.net_names:
                net_name = self.net_names[pt_a.point_id]
            elif pt_b.point_id in self.net_names:
                net_name = self.net_names[pt_b.point_id]

            new_net = net.Net(net_name)
            map(used_points.add, seg)
            new_net.connect(seg)
            found = True

            if net_name:
                new_net.attributes['name'] = net_name

            while found:
                found = set()

                for seg in self.segments:  # iterate over segments
                    if new_net.connected(seg):  # segment touching the net
                        map(used_points.add, seg)
                        new_net.connect(seg)  # add the segment
                        found.add(seg)

                for seg in found:
                    self.segments.remove(seg)

            nets.append(new_net)

        # check if names are available for calculated nets
        for net_obj in nets:
            for point_id, point in net_obj.points.items():
                ## check for stored net names based on pointIDs
                if point_id in self.net_names:
                    net_obj.net_id = self.net_names[point_id]
                    net_obj.attributes['name'] = self.net_names[point_id]

            if 'name' in net_obj.attributes:
                annotation = Annotation(
                    "name",  # annotation referencing attribute 'name'
                    0, 0,
                    self.conv_angle(0.0),
                    self.conv_bool(1),
                )
                net_obj.add_annotation(annotation)

        # add single-point nets for overlapping pins that are not
        # already in other nets
        for point in set(self.net_points.itervalues()) - used_points:
            if len(point.connected_components) > 1:
                new_net = net.Net('')
                new_net.add_point(point)
                nets.append(new_net)

        for net_obj in nets:
            if not net_obj.net_id:
                net_obj.net_id = min(net_obj.points)

        return nets

    def _open_file_or_zip(self, filename, mode='rU'):
        """
        Open the file with *filename* and return a file
        handle for it. If the current file is a ZIP file
        the filename will be treated as compressed file in
        this ZIP file.
        """
        if self.geda_zip is not None:
            temp_dir = tempfile.mkdtemp()
            self.geda_zip.extract(filename, temp_dir)
            filename = os.path.join(temp_dir, filename)

        return open(filename, mode)

    def add_text_to_component(self, component, geda_text):
        """
        Add the content of a ``GEDAText`` instance to the
        component. If *geda_text* contains ``refdes``, ``prefix``
        or ``suffix`` attributes it will be stored as special
        attribute in the component. *geda_text* that is not an
        attribute will be added as ``Label`` to the components
        body.
        """
        # pylint: disable=R0201
        if geda_text.is_text():
            component.symbols[0].bodies[0].add_shape(geda_text.as_label())

        elif geda_text.attribute == 'refdes' \
             and '?' in geda_text.content:
            prefix, suffix = geda_text.content.split('?')
            component.add_attribute('_prefix', prefix)
            component.add_attribute('_suffix', suffix)
        else:
            component.add_attribute(
                geda_text.attribute,
                geda_text.content
            )

    def add_objects_to_component(self, component, objs):
        """
        Add a GEDA object to the component. Valid
        objects are subclasses of ``Shape``, ``Pin`` or
        ``GEDAText``. *objs* is expected to be an iterable
        and will be added to the correct component properties
        according to their type.
        """
        if not objs:
            return

        try:
            iter(objs)
        except TypeError:
            objs = [objs]

        for obj in objs:
            obj_cls = obj.__class__
            if issubclass(obj_cls, shape.Shape):
                component.symbols[0].bodies[0].add_shape(obj)
            elif issubclass(obj_cls, components.Pin):
                component.symbols[0].bodies[0].add_pin(obj)
            elif issubclass(obj_cls, GEDAText):
                self.add_text_to_component(component, obj)

    def add_text_to_design(self, design, geda_text):
        """
        Add the content of a ``GEDAText`` instance to the
        design. If *geda_text* contains ``use_license`` it will
        be added to the design's metadata ``license`` other
        attributes are added to ``design_attributes``.
        *geda_text* that is not an attribute will be added as
        ``Label`` to the components body.
        """
        # pylint: disable=R0201
        if geda_text.is_text():
            design.add_shape(geda_text.as_label())
        elif geda_text.attribute == 'use_license':
            metadata = design.design_attributes.metadata
            metadata.license = geda_text.content
        else:
            design.design_attributes.add_attribute(
                geda_text.attribute,
                geda_text.content,
            )

    def add_objects_to_design(self, design, objs):
        """
        Add a GEDA object to the design. Valid
        objects are subclasses of ``Shape``, ``Pin`` or
        ``GEDAText``. *objs* is expected to be an iterable
        and will be added to the correct component properties
        according to their type.
        """
        if not objs:
            return

        try:
            iter(objs)
        except TypeError:
            objs = [objs]

        for obj in objs:
            obj_cls = obj.__class__
            if issubclass(obj_cls, shape.Shape):
                design.add_shape(obj)
            elif issubclass(obj_cls, components.Pin):
                design.add_pin(obj)
            elif issubclass(obj_cls, GEDAText):
                self.add_text_to_design(design, obj)

    def _parse_U(self, stream, params):  # pylint: disable=W0613,C0103
        """ Processing a bus instance with start end end coordinates
            at (x1, y1) and (x2, y2). *color* is ignored. *ripperdir*
            defines the direction in which the bus rippers are oriented
            relative to the direction of the bus.
        """
        # pylint: disable=C0103
        x1, x2 = params['x1'], params['x2']
        y1, y2 = params['y1'], params['y2']

        ## ignore bus when length is zero
        if x1 == x2 and y1 == y2:
            return

        pta_x, pta_y = self.conv_coords(x1, y1)
        ptb_x, ptb_y = self.conv_coords(x2, y2)

        self.segments.add((
            self.get_netpoint(pta_x, pta_y),
            self.get_netpoint(ptb_x, ptb_y)
        ))

    def _parse_L(self, stream, params):  # pylint: disable=W0613,C0103
        """ Creates a Line object from the parameters in *params*. All
            style related parameters are ignored.
            Returns a Line object.
        """
        line_x1 = params['x1']
        line_x2 = params['x2']

        if self._is_mirrored_command(params):
            line_x1 = 0 - params['x1']
            line_x2 = 0 - params['x2']

        line = shape.Line(
            self.conv_coords(line_x1, params['y1']),
            self.conv_coords(line_x2, params['y2']),
        )
        ## store style data for line in 'style' dict
        self._save_parameters_to_object(line, params)
        return line

    def _parse_B(self, stream, params):  # pylint: disable=W0613,C0103
        """ Creates rectangle from gEDA box with origin in bottom left
            corner. All style related values are ignored.
            Returns a Rectangle object.
        """
        rect_x = params['x']
        if self._is_mirrored_command(params):
            rect_x = 0 - (rect_x + params['width'])

        rect = shape.Rectangle(
            self.x_to_px(rect_x),
            self.y_to_px(params['y'] + params['height']),
            self.to_px(params['width']),
            self.to_px(params['height'])
        )
        ## store style data for rect in 'style' dict
        self._save_parameters_to_object(rect, params)
        return rect

    def _parse_V(self, stream, params):  # pylint: disable=W0613,C0103
        """ Creates a Circle object from the gEDA parameters in *params. All
            style related parameters are ignored.
            Returns a Circle object.
        """
        vertex_x = params['x']
        if self._is_mirrored_command(params):
            vertex_x = 0 - vertex_x

        circle = shape.Circle(
            self.x_to_px(vertex_x),
            self.y_to_px(params['y']),
            self.to_px(params['radius']),
        )
        ## store style data for arc in 'style' dict
        self._save_parameters_to_object(circle, params)
        return circle

    def _parse_A(self, stream, params):  # pylint: disable=W0613,C0103
        """ Creates an Arc object from the parameter in *params*. All
            style related parameters are ignored.
            Returns Arc object.
        """
        arc_x = params['x']
        start_angle = params['startangle']
        sweep_angle = params['sweepangle']

        if self._is_mirrored_command(params):
            arc_x = 0 - arc_x

            start_angle = start_angle + sweep_angle
            if start_angle <= 180:
                start_angle = 180 - start_angle
            else:
                start_angle = (360 - start_angle) + 180

        arc = shape.Arc(
            self.x_to_px(arc_x),
            self.y_to_px(params['y']),
            self.conv_angle(start_angle),
            self.conv_angle(start_angle + sweep_angle),
            self.to_px(params['radius']),
        )
        ## store style data for arc in 'style' dict
        self._save_parameters_to_object(arc, params)
        return arc

    def _parse_T(self, stream, params):  # pylint: disable=W0613,C0103
        """ Parses text element and determins if text is a text object
            or an attribute.
            Returns a tuple (key, value). If text is an annotation key is None.
        """
        params['x'] = self.x_to_px(params['x'])
        params['y'] = self.y_to_px(params['y'])
        params['angle'] = self.conv_angle(params['angle'])

        geda_text = GEDAText.from_command(stream, params)

        ## text can have environment attached: parse & ignore
        self._parse_environment(stream)
        return geda_text

    def _parse_N(self, stream, params):  # pylint: disable=W0613,C0103
        """ Creates a segment from the command *params* and
            stores it in the global segment list for further
            processing in :py:method:divide_segments and
            :py:method:calculate_nets. It also extracts the
            net name from the attribute environment if
            present.
        """
        # pylint: disable=C0103
        ## store segement for processing later
        x1, y1 = self.conv_coords(params['x1'], params['y1'])
        x2, y2 = self.conv_coords(params['x2'], params['y2'])

        ## store segment points in global point list
        pt_a = self.get_netpoint(x1, y1)
        pt_b = self.get_netpoint(x2, y2)

        ## add segment to global list for later processing
        self.segments.add((pt_a, pt_b))

        attributes = self._parse_environment(stream)
        if attributes is not None:
            ## create net with name in attributes
            if '_netname' in attributes:
                net_name = attributes['_netname']
                if net_name not in self.net_names.values():
                    self.net_names[pt_a.point_id] = net_name

    def _parse_P(self, stream, params, pinnumber=0):
        """ Creates a Pin object from the parameters in *param* and
            text attributes provided in the following environment. The
            environment is enclosed in ``{}`` and is required. If no
            attributes can be extracted form *stream* an GEDAError
            is raised.
            The *pin_id* is retrieved from the 'pinnumber' attribute and
            all other attributes are ignored. The conneted end of the
            pin is taken from the 'whichend' parameter as defined in
            the gEDA documentation.

            Returns a Pin object.
        """
        # pylint: disable=C0103,W0613,R0201
        ## pin requires an attribute enviroment, so parse it first
        attributes = self._parse_environment(stream)

        if attributes is None:
            log.warn('mandatory pin attributes missing')
            attributes = {
                '_pinnumber': pinnumber,
            }

        if '_pinnumber' not in attributes:
            attributes['_pinnumber'] = pinnumber
            log.warn("mandatory attribute '_pinnumber' not assigned to pin")

        whichend = params['whichend']

        pin_x1, pin_x2 = params['x1'], params['x2']
        if self._is_mirrored_command(params):
            pin_x1 = 0 - pin_x1
            pin_x2 = 0 - pin_x2

        ## determine wich end of the pin is the connected end
        ## 0: first point is connector
        ## 1: second point is connector
        if whichend == 0:
            connect_end = self.conv_coords(pin_x1, params['y1'])
            null_end = self.conv_coords(pin_x2, params['y2'])
        else:
            null_end = self.conv_coords(pin_x1, params['y1'])
            connect_end = self.conv_coords(pin_x2, params['y2'])

        label = None
        if '_pinlabel' in attributes:
            label = shape.Label(
                connect_end[0],
                connect_end[1],
                attributes.get('_pinlabel'),
                align='left',
                rotation=0.0
            )

        pin = components.Pin(
            attributes['_pinnumber'],  # pin number
            null_end,
            connect_end,
            label=label
        )
        ## store style parameters in shape's style dict
        self._save_parameters_to_object(pin, params)
        return pin

    def _parse_C(self, stream, params):  # pylint: disable=W0613,R0201,C0103
        """
        Parse component command 'C'. *stream* is the file stream
        pointing to the line after the component command. *params*
        are the parsed parameters from the component command.
        The method checks if component is a title and ignores it
        if that is the case due to previous processing. If the
        component is a busripper, it is converted into a net
        segment. Otherwise, the component is parsed as a regular
        component and added to the library and design.
        """
        ## ignore title since it only defines the blueprint frame
        if params['basename'].startswith('title'):
            self._parse_environment(stream)

        ## busripper are virtual components that need separate
        ## processing
        elif 'busripper' in params['basename']:
            self.segments.add(self._create_ripper_segment(params))

            ## make sure following environments are ignored
            self.skip_embedded_section(stream)
            self._parse_environment(stream)
        else:
            self._parse_component(stream, params)

    def _parse_H(self, stream, params):  # pylint: disable=W0613,R0201
        """ Parses a SVG-like path provided path into a list
            of simple shapes. The gEDA formats allows only line
            and curve segments with absolute coordinates. Hence,
            shapes are either Line or BezierCurve objects.
            The method processes the stream data according to
            the number of lines in *params*.
            Returns a list of Line and BezierCurve shapes.
        """
        # pylint: disable=C0103
        params['extra_id'] = self.path_counter.next()
        num_lines = params['num_lines']
        mirrored = self._is_mirrored_command(params)
        command = stream.readline().strip().split(self.DELIMITER)

        if command[0] != 'M':
            raise GEDAError('found invalid path in gEDA file')

        def get_coords(string, mirrored):
            """ Get coordinates from string with comma-sparated notation."""
            x, y = [int(value) for value in string.strip().split(',')]

            if mirrored:
                x = -x

            return (self.x_to_px(x), self.y_to_px(y))

        shapes = []
        current_pos = initial_pos = (get_coords(command[1], mirrored))

        ## loop over the remaining lines of commands (after 'M')
        for _ in range(num_lines - 1):
            command = stream.readline().strip().split(self.DELIMITER)

            ## draw line from current to given position
            if command[0] == 'L':
                assert(len(command) == 2)
                end_pos = get_coords(command[1], mirrored)

                shape_ = shape.Line(current_pos, end_pos)
                current_pos = end_pos

            ## draw curve from current to given position
            elif command[0] == 'C':
                assert(len(command) == 4)
                control1 = get_coords(command[1], mirrored)
                control2 = get_coords(command[2], mirrored)
                end_pos = get_coords(command[3], mirrored)

                shape_ = shape.BezierCurve(
                    control1,
                    control2,
                    current_pos,
                    end_pos
                )
                current_pos = end_pos

            ## end of sub-path, straight line from current to initial position
            elif command[0] in ['z', 'Z']:
                shape_ = shape.Line(current_pos, initial_pos)

            else:
                raise GEDAError(
                    "invalid command type in path '%s'" % command[0]
                )

            ## store style parameters in shape's style dict
            self._save_parameters_to_object(shape_, params)
            shapes.append(shape_)

        return shapes

    def _save_parameters_to_object(self, obj, params):
        """
        Save all ``style`` and ``extra`` parameters to the
        objects ``styles`` dictionary. If *obj* does not have
        a ``styles`` property, a ``GEDAError`` is raised.
        """
        # pylint: disable=R0201
        parameter_types = [
            geda_commands.GEDAStyleParameter.TYPE,
            geda_commands.GEDAExtraParameter.TYPE,
        ]

        try:
            for key, value in params.items():
                if key.split('_')[0] in parameter_types:
                    obj.styles[key] = value
        except AttributeError:
            log.exception(
                "tried saving style data to '%s' without styles dict.",
                obj.__class__.__name__
            )

    def _parse_command(self, stream, move_to=None):
        """ Parse the next command in *stream*. The object type is check
            for validity and its parameters are parsed and converted to
            the expected typs in the parsers lookup table. If *move_to*
            is provided it is used to translate all coordinates into by
            the given coordinate.
            Returns a tuple (*object type*, *parameters*) where *parameters*
                is a dictionary of paramter name and value.

            Raises GEDAError when object type is not known.
        """
        line = stream.readline()

        while line.startswith('#') or line == '\n':
            line = stream.readline()

        command_data = line.strip().split(self.DELIMITER)

        if len(command_data[0]) == 0 or command_data[0] in [']', '}']:
            return None, []

        object_type, command_data = command_data[0].strip(), command_data[1:]

        if object_type not in self.OBJECT_TYPES:
            raise GEDAError("unknown type '%s' in file" % object_type)

        params = {}
        geda_command = self.OBJECT_TYPES[object_type]
        for idx, parameter in enumerate(geda_command.parameters()):
            if idx >= len(command_data):
                ## prevent text commands of version 1 from breaking
                params[parameter.name] = parameter.default
            else:
                datatype = parameter.datatype
                params[parameter.name] = datatype(command_data[idx])

        assert(len(params) == len(geda_command.parameters()))

        if move_to is not None:
            ## element in EMBEDDED component need to be moved
            ## to origin (0, 0) from component origin
            if object_type in ['T', 'B', 'C', 'A']:
                params['x'] = params['x'] - move_to[0]
                params['y'] = params['y'] - move_to[1]
            elif object_type in ['L', 'P']:
                params['x1'] = params['x1'] - move_to[0]
                params['y1'] = params['y1'] - move_to[1]
                params['x2'] = params['x2'] - move_to[0]
                params['y2'] = params['y2'] - move_to[1]

        return object_type, params

    @classmethod
    def to_px(cls, value):
        """ Converts value in MILS to pixels using the parsers
            scale factor.
            Returns an integer value converted to pixels.
        """
        return int(value / cls.SCALE_FACTOR)

    def x_to_px(self, x_mils):
        """ Convert *px* from MILS to pixels using the scale
            factor and translating it allong the X-axis in
            offset.

            Returns translated and converted X coordinate.
        """
        return int(float(x_mils - self.offset.x) / self.SCALE_FACTOR)

    def y_to_px(self, y_mils):
        """ Convert *py* from MILS to pixels using the scale
            factor and translating it allong the Y-axis in
            offset.

            Returns translated and converted Y coordinate.
        """
        return int(float(y_mils - self.offset.y) / self.SCALE_FACTOR)

    def conv_coords(self, orig_x, orig_y):
        """ Converts coordinats *orig_x* and *orig_y* from MILS
            to pixel units based on scale factor. The converted
            coordinates are in multiples of 10px.
        """
        orig_x, orig_y = int(orig_x), int(orig_y)
        return (
            self.x_to_px(orig_x),
            self.y_to_px(orig_y)
        )

    @classmethod
    def translate_coords(cls, x, y, angle):
        """ Translate a coordinate *x*, *y* accroding to the given
            *angle* in OpenJSON coordinates.
        """
        angle = (-angle % 2.0) * pi
        xn = int(round(x * cos(angle) - y * sin(angle)))
        yn = int(round(y * cos(angle) + x * sin(angle)))
        return xn, yn

    @staticmethod
    def conv_bool(value):
        """ Converts *value* into string representing boolean
            'true' or 'false'. *value* can be of any numeric or
            boolean type.
        """
        if value in ['true', 'false']:
            return value
        return str(bool(int(value)) is True).lower()

    @staticmethod
    def conv_angle(angle):
        """ Converts *angle* (in degrees) to pi radians. gEDA
            sets degree angles counter-clockwise whereas upverter
            uses pi radians clockwise. Therefore the direction of
            *angle* is therefore adjusted first.
        """
        angle = angle % 360.0
        if angle > 0:
            angle = abs(360 - angle)
        return round(angle / 180.0, 1)


def find_symbols(symbol_dirs):
    """ Parses each directory in *symbol_dirs* searching for
        gEDA symbol files based on its extension (extension: .sym).
        It creates a symbol file lookup of basename (without
        extension) and absolute path to the symbol file.

        Returns a dictionary of file basename and absolute path.
    """
    known_symbols = {}
    for symbol_dir in symbol_dirs:
        if os.path.exists(symbol_dir):
            for dirpath, dirnames, filenames in os.walk(symbol_dir):
                dirnames.sort()
                for filename in filenames:
                    if filename.endswith('.sym'):
                        filepath = os.path.join(dirpath, filename)
                        filename, _ = os.path.splitext(filename)
                        if filename.lower() not in known_symbols:
                            known_symbols[filename.lower()] = filepath

    return known_symbols

########NEW FILE########
__FILENAME__ = geda_commands
class GEDAColor:
    """ Enumeration of gEDA colors """
    BACKGROUND_COLOR = 0
    PIN_COLOR = 1
    NET_ENDPOINT_COLOR = 2
    GRAPHIC_COLOR = 3
    NET_COLOR = 4
    ATTRIBUTE_COLOR = 5
    LOGIC_BUBBLE_COLOR = 6
    DOTS_GRID_COLOR = 7
    DETACHED_ATTRIBUTE_COLOR = 8
    TEXT_COLOR = 9
    BUS_COLOR = 10
    SELECT_COLOR = 11
    BOUNDINGBOX_COLOR = 12
    ZOOM_BOX_COLOR = 13
    STROKE_COLOR = 14
    LOCK_COLOR = 15


class GEDAParameter(object):
    TYPE = ''

    def __init__(self, name, datatype=int, default=None):
        self._name = name
        self.datatype = datatype
        self.default = default

    @property
    def name(self):
        if self.TYPE:
            return "%s_%s" % (self.TYPE, self._name)
        return self._name


class GEDAStyleParameter(GEDAParameter):
    """ Style parameter """
    TYPE = 'style'


class GEDAExtraParameter(GEDAParameter):
    """ Extra parameter """
    TYPE = 'extra'


class GEDACommand(object):
    """ Command """
    TYPE = None
    PARAMETERS = ()
    EXTRA_PARAMETERS = ()

    def parameters(self):
        return self.PARAMETERS + self.EXTRA_PARAMETERS

    def get_style_keywords(self):
        style_type = GEDAStyleParameter.TYPE
        return [p.name for p in self.PARAMETERS
                        if p.name.startswith(style_type)]

    def update_default_kwargs(self, **kwargs):
        default_kwargs = {}
        for parameter in self.parameters():
            default_kwargs[parameter.name] = parameter.default
        default_kwargs.update(kwargs)
        return default_kwargs

    def generate_command(self, **kwargs):
        kwargs = self.update_default_kwargs(**kwargs)
        command = [self.TYPE]
        for parameter in self.PARAMETERS:
            command.append("%%(%s)s" % parameter.name)
        return [" ".join(command) % kwargs]


class GEDALineCommand(GEDACommand):
    """ Line command """
    TYPE = 'L'
    PARAMETERS = (
        GEDAParameter('x1'),
        GEDAParameter('y1'),
        GEDAParameter('x2'),
        GEDAParameter('y2'),
        GEDAStyleParameter('color', default=GEDAColor.GRAPHIC_COLOR),
        GEDAStyleParameter('width', default=10),
        GEDAStyleParameter('capstyle', default=0),
        GEDAStyleParameter('dashstyle', default=0),
        GEDAStyleParameter('dashlength', default=-1),
        GEDAStyleParameter('dashspace', default=-1),
    )


class GEDABoxCommand(GEDACommand):
    """ Box command """
    TYPE = "B"
    PARAMETERS = (
        GEDAParameter('x'),
        GEDAParameter('y'),
        GEDAParameter('width'),
        GEDAParameter('height'),
        GEDAStyleParameter('color', default=GEDAColor.GRAPHIC_COLOR),
        GEDAStyleParameter('width', default=10),
        GEDAStyleParameter('capstyle', default=0),
        GEDAStyleParameter('dashstyle', default=0),
        GEDAStyleParameter('dashlength', default=-1),
        GEDAStyleParameter('dashspace', default=-1),
        GEDAStyleParameter('filltype', default=0),
        GEDAStyleParameter('fillwidth', default=-1),
        GEDAStyleParameter('angle1', default=-1),
        GEDAStyleParameter('pitch1', default=-1),
        GEDAStyleParameter('angle2', default=-1),
        GEDAStyleParameter('pitch2', default=-1),
    )


class GEDACircleCommand(GEDACommand):
    """ Circle command """
    TYPE = 'V'
    PARAMETERS = (
        GEDAParameter('x'),
        GEDAParameter('y'),
        GEDAParameter('radius'),
        GEDAStyleParameter('color', default=GEDAColor.GRAPHIC_COLOR),
        GEDAStyleParameter('width', default=10),
        GEDAStyleParameter('capstyle', default=0),
        GEDAStyleParameter('dashstyle', default=0),
        GEDAStyleParameter('dashlength', default=-1),
        GEDAStyleParameter('dashspace', default=-1),
        GEDAStyleParameter('filltype', default=0),
        GEDAStyleParameter('fillwidth', default=-1),
        GEDAStyleParameter('angle1', default=-1),
        GEDAStyleParameter('pitch1', default=-1),
        GEDAStyleParameter('angle2', default=-1),
        GEDAStyleParameter('pitch2', default=-1),
    )


class GEDAArcCommand(GEDACommand):
    """ Arc command """
    TYPE = 'A'
    PARAMETERS = (
        GEDAParameter('x'),
        GEDAParameter('y'),
        GEDAParameter('radius'),
        GEDAParameter('startangle'),
        GEDAParameter('sweepangle'),
        GEDAStyleParameter('color', default=GEDAColor.GRAPHIC_COLOR),
        GEDAStyleParameter('width', default=10),
        GEDAStyleParameter('capstyle', default=0),
        GEDAStyleParameter('dashstyle', default=0),
        GEDAStyleParameter('dashlength', default=-1),
        GEDAStyleParameter('dashspace', default=-1),
    )


class GEDATextCommand(GEDACommand):
    """ Text command """
    TYPE = 'T'
    PARAMETERS = (
        GEDAParameter('x'),
        GEDAParameter('y'),
        GEDAStyleParameter('color', default=GEDAColor.TEXT_COLOR),
        GEDAStyleParameter('size', default=10),
        GEDAParameter('visibility', default=1),
        GEDAParameter('show_name_value', default=1),
        GEDAParameter('angle', default=0),
        GEDAParameter('alignment', default=0),
        GEDAParameter('num_lines', default=1),
    )


class GEDASegmentCommand(GEDACommand):
    """ Segment command """
    TYPE = 'N'
    PARAMETERS = (
        GEDAParameter('x1'),
        GEDAParameter('y1'),
        GEDAParameter('x2'),
        GEDAParameter('y2'),
        GEDAStyleParameter('color', default=GEDAColor.NET_COLOR),
    )


class GEDAPinCommand(GEDACommand):
    """ Pin command """
    TYPE = 'P'
    PARAMETERS = (
        GEDAParameter('x1'),
        GEDAParameter('y1'),
        GEDAParameter('x2'),
        GEDAParameter('y2'),
        GEDAStyleParameter('color', default=GEDAColor.PIN_COLOR),
        # pin type is always 0
        GEDAStyleParameter('pintype', default=0),
        # first point is active/connected pin
        GEDAParameter('whichend', default=0),
    )


class GEDAComponentCommand(GEDACommand):
    """ Component command """
    TYPE = 'C'
    PARAMETERS = (
        GEDAParameter('x'),
        GEDAParameter('y'),
        GEDAParameter('selectable', default=0),
        GEDAParameter('angle'),
        GEDAParameter('mirror'),
        GEDAParameter('basename', datatype=str),
    )


class GEDAPathCommand(GEDACommand):
    """ Path command """
    TYPE = "H"
    PARAMETERS = (
        GEDAStyleParameter('color', default=GEDAColor.GRAPHIC_COLOR),
        GEDAStyleParameter('width', default=10),
        GEDAStyleParameter('capstyle', default=0),
        GEDAStyleParameter('dashstyle', default=0),
        GEDAStyleParameter('dashlength', default=-1),
        GEDAStyleParameter('dashspace', default=-1),
        GEDAStyleParameter('filltype', default=0),
        GEDAStyleParameter('fillwidth', default=-1),
        GEDAStyleParameter('angle1', default=-1),
        GEDAStyleParameter('pitch1', default=-1),
        GEDAStyleParameter('angle2', default=-1),
        GEDAStyleParameter('pitch2', default=-1),
        GEDAParameter('num_lines'),
    )
    EXTRA_PARAMERTERS = (
        GEDAExtraParameter('id'),
    )


class GEDAVersionCommand(GEDACommand):
    """ Version command """
    TYPE = 'v'
    PARAMETERS = (
        GEDAParameter('version'),
        GEDAParameter('fileformat_version'),
    )


class GEDABusCommand(GEDACommand):
    """ Bus command """
    TYPE = 'U'
    PARAMETERS = (
        GEDAParameter('x1'),
        GEDAParameter('y1'),
        GEDAParameter('x2'),
        GEDAParameter('y2'),
        GEDAStyleParameter('color', default=GEDAColor.BUS_COLOR),
        GEDAParameter('ripperdir', default=0),
    )


class GEDAPictureCommand(GEDACommand):
    """ Picture command """
    TYPE = 'G'
    PARAMETERS = ()


class GEDAEmbeddedEnvironmentCommand(GEDACommand):
    """ Embeded command """
    TYPE = '['
    PARAMETERS = ()


class GEDAAttributeEnvironmentCommand(GEDACommand):
    """ Attribute environment command """
    TYPE = '{'
    PARAMETERS = ()


class GEDACommand(GEDACommand):
    """ Command """
    TYPE = 'U'
    PARAMETERS = ()

########NEW FILE########
__FILENAME__ = gerber
#!/usr/bin/env python2
""" The Gerber RS274-X Format Parser """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re
from math import sqrt, sin, cos, acos, pi
from collections import namedtuple
from zipfile import ZipFile
from tarfile import TarFile, ReadError
import csv
from os import path

from upconvert.core.design import Design
from upconvert.core.layout import Layout, Layer, Image, Macro, Primitive
from upconvert.core.layout import Fill, Smear, ShapeInstance, Aperture
from upconvert.core.shape import Line, Arc, Point, Circle, Rectangle
from upconvert.core.shape import Obround, RegularPolygon, Polygon, Moire, Thermal


# exceptions

class Unparsable(ValueError):
    """ Superclass for all parser errors. """

class ParamError(Unparsable):
    """ Superclass for parameter errors. """

class CoordError(Unparsable):
    """ Superclass for coordinate errors. """

class DelimiterMissing(ParamError):
    """ Missing paramater block delimiter (%). """

class ParamContainsBadData(ParamError):
    """ Non-paramater found within param block. """

class CoordPrecedesFormatSpec(CoordError):
    """ Coordinate data prior to format specification. """

class CoordMalformed(CoordError):
    """ Coordinate block doesn't conform to spec. """

class QuadrantViolation(CoordError):
    """ Single quadrant arc longer than 0.5 radians/pi. """

class OpenFillBoundary(CoordError):
    """ Fill boundary ends do not equate. """

class FileNotTerminated(Unparsable):
    """ M02* was not encountered. """

class DataAfterEOF(Unparsable):
    """ M02* was not the last thing in the file. """

class UnintelligibleDataBlock(Unparsable):
    """ Data block did not conform to any known pattern. """

class IncompatibleAperture(Unparsable):
    """ Attempted to draw non-linear shape with rect. """

class InvalidExpression(Unparsable):
    """ Invalid macro expression. """


# token classes

LayerDef = namedtuple('LayerDef', 'name type filename')             # pylint: disable=C0103
MacroDef = namedtuple('MacroDef', 'name primitive_defs')            # pylint: disable=C0103
Coord = namedtuple('Coord', 'x y i j')                              # pylint: disable=C0103
CoordFmt = namedtuple('CoordFmt', 'int dec')                        # pylint: disable=C0103
AxisDef = namedtuple('AxisDef', 'a b')                              # pylint: disable=C0103
Funct = namedtuple('Funct', 'type_ code')                           # pylint: disable=C0103
FormatSpec = namedtuple('FormatSpec', ['zero_omission',             # pylint: disable=C0103
                        'incremental_coords', 'n_max', 'g_max',
                        'x', 'y', 'd_max', 'm_max'])
Token = namedtuple('Token', 'type value')                           # pylint: disable=C0103


# constants

DEBUG = False
LAYERS_CFG = 'layers.cfg'
PRIMITIVES = {1:'circle',
              2:'line-vector',
              20:'line-vector',
              21:'line-center',
              22:'line-lower-left',
              4:'outline',
              5:'polygon',
              6:'moire',
              7:'thermal'}
D_MAP = {1:'ON', 2:'OFF', 3:'FLASH'}
G_MAP = {1:{'interpolation':'LINEAR'},
         2:{'interpolation':'CLOCKWISE_CIRCULAR'},
         3:{'interpolation':'ANTICLOCKWISE_CIRCULAR'},
         36:{'outline_fill':True},
         37:{'outline_fill':False},
         70:{'units':'IN'},
         71:{'units':'MM'},
         74:{'multi_quadrant':False},
         75:{'multi_quadrant':True},
         90:{'incremental':True},
         91:{'incremental':False}}
IMAGE_POLARITIES = {'C': False,
                    'D': True}
AXIS_PARAMS = ('AS', 'MI', 'OF', 'SF', 'IJ', 'IO')
ALL_PARAMS = ('AS', 'FS', 'MI', 'MO', 'OF', 'SF',
              'IJ', 'IN', 'IO', 'IP', 'IR', 'PF', 'AD',
              'KO', 'LN', 'LP', 'SR')
LAYER_PARAMS = ALL_PARAMS[-4:]
TOK_SPEC = (('MACRO', r'%AM[^%]*%'),
            ('PARAM_DELIM', r'%'),
           ) + tuple([(p, r'%s[^\*]*\*' % p) for p in ALL_PARAMS]) + (
            ('COMMENT', r'G04[^\*]*\*'),
            ('DEPRECATED', r'G54\*?'), # historic crud
            ('FUNCT', r'[GD][^\*]*\*'),# function codes
            ('COORD', r'[XY][^\*]*\*'),# coordinates
            ('EOF', r'M02\*'),         # end of file
            ('SKIP', r'M0[01]\*|N[^\*]*\*|\**\s+'), # historic crud, whitespace
            ('UNKNOWN', r'[^\*]*\*'))  # unintelligble data block
IGNORE = ('SKIP', 'COMMENT', 'DEPRECATED')
REG_EX = '|'.join('(?P<%s>%s)' % pair for pair in TOK_SPEC)
TOK_RE = re.compile(REG_EX, re.MULTILINE)


# parser

class Gerber:
    """ The Gerber Format Parser """

    def __init__(self, ignore_unknown=True):
        self.ignore_unknown = ignore_unknown
        self.layout = Layout()
        self.layer_buff = None
        self.macro_buff = None
        self.img_buff = Image()
        self.trace_buff = TraceBuffer()
        self.fill_buff = []

        # establish gerber defaults
        self.params = {'AS':AxisDef('x', 'y'),# axis select
                       'FS':None,             # format spec
                       'MI':AxisDef(0, 0),    # mirror image
                       'MO':'IN',             # mode: inches/mm
                       'OF':AxisDef(0, 0),    # offset
                       'SF':AxisDef(1, 1),    # scale factor
                       'IJ':AxisDef(('L', 0), # image justify
                                    ('L', 0)),
                       'IO':AxisDef(0, 0),    # image offset
                       'IP':True,             # image polarity
                       'IR':0}                # image rotation

        # simulate a photo plotter
        self.status = {'x':0,
                       'y':0,
                       'draw':'OFF',
                       'interpolation':'LINEAR',
                       'aperture':None,
                       'outline_fill':False,
                       'multi_quadrant':False,
                       'units':None,
                       'incremental_coords':None}


    @staticmethod
    def auto_detect(filename):
        """ Return our confidence that the given file is an gerber file """
        with open(filename, 'r') as f:
            data = f.read(4096)
        confidence = 0
        if '%ADD' in data:
            confidence += 0.2
        if 'D01*' in data:
            confidence += 0.2
        if 'D02*' in data:
            confidence += 0.2
        if 'D03*' in data:
            confidence += 0.2
        if 'M02*' in data:
            confidence += 0.2
        if filename.endswith('.ger'):
            confidence += 0.5
        return confidence


    def parse(self, infile='.'):
        """ Parse tokens from gerber files into a design. """
        is_zip = infile.endswith('.zip')
        openarchive = ZipFile if is_zip else TarFile.open
        archive = batch_member = None
        try:
            # define multiple layers from folder
            if LAYERS_CFG in infile:
                archive = None
                cfg_name = infile
                cfg = open(cfg_name, 'r')

            # define multiple layers from archive
            else:
                archive = openarchive(infile)
                batch = archive.namelist if is_zip else archive.getnames
                batch_member = archive.open if is_zip else archive.extractfile
                cfg_name = [n for n in batch() if LAYERS_CFG in n][0]
                cfg = batch_member(cfg_name)

        # define single layer from single gerber file
        except ReadError:
            name, ext = path.split(infile)[1].rsplit('.', 1)
            layer_defs = [LayerDef(ext.lower() == 'ger' and name or ext,
                                   'unknown', infile)]
            self._gen_layers(layer_defs, None, None)

        # tidy up batch specs
        else:
            layer_defs = [LayerDef(rec[0],
                                   rec[1],
                                   path.join(path.split(cfg_name)[0], rec[2]))
                          for rec in
                          csv.reader(cfg, skipinitialspace=True)]
            cfg.close()
            self._gen_layers(layer_defs, archive, batch_member)

        # tidy up archive
        finally:
            if archive:
                archive.close()

        # compile design
        if DEBUG:
            self._debug_stdout()

        self.layout.units = (self.params['MO'] == 'IN' and 'inch' or 'mm')

        design = Design()
        design.layout = self.layout
        return design


    # primary parser support methods

    def _gen_layers(self, layer_defs, archive, batch_member):
        """ Parse gerbers into a PCB layers. """
        for layer_def in layer_defs:
            self.layer_buff = Layer(layer_def.name, layer_def.type)
            self.macro_buff = {}
            layer_file = (archive and
                          batch_member(layer_def.filename) or
                          open(layer_def.filename, 'r'))
            for block in self._tokenize(layer_file):
                if isinstance(block, MacroDef):
                    self.macro_buff[block.name] = InternalMacro(block)
                    effect = {}
                elif isinstance(block, Funct):
                    effect = self._do_funct(block)
                else:
                    effect = self._move(block)
                self.status.update(effect)
            self.layout.layers.append(self.layer_buff)


    def _do_funct(self, block):
        """ Set drawing modes, fill terminators. """
        code = int(block.code)
        if 'D' in block.type_:
            if code < 10:
                effect = {'draw':D_MAP[code]}

                # flash current pos/aperture
                if 'X' in block.type_:
                    apertures = self.layer_buff.apertures
                    aperture = apertures[self.status['aperture']]
                    pos = Point(self.status['x'], self.status['y'])
                    shape_inst = ShapeInstance(pos, aperture)
                    self.img_buff.shape_instances.append(shape_inst)

                # terminate fill mid mode
                if (self.status['outline_fill'] and
                    code == 2 and self.fill_buff):
                    self.img_buff.fills.append(self._check_fill())

            else:
                effect = {'aperture':block.code}
        else:
            effect = G_MAP[code]
            if code == 37:

                # terminate fill if D02 was not specified
                if self.fill_buff:
                    self.img_buff.fills.append(self._check_fill())

        return effect


    def _move(self, block):
        """ Draw a shape, or a segment of a trace or fill. """
        start = tuple([self.status[k] for k in ('x', 'y')])
        end = self._target_pos(block)
        ends = (Point(start), Point(end))
        apertures = self.layer_buff.apertures

        if self.status['draw'] == 'ON':
            # generate segment
            if self.status['interpolation'] == 'LINEAR':
                seg = Line(start, end)
            else:
                ctr_offset = block[2:]
                seg = self._draw_arc(ends, ctr_offset)

            # append segment to fill
            if self.status['outline_fill']:
                self.fill_buff.append((ends, seg))
            else:
                aperture = apertures[self.status['aperture']]
                if isinstance(aperture.shape, Rectangle):
                    # construct a smear
                    self._check_smear(seg, aperture.shape)
                    self.img_buff.smears.append(Smear(seg, aperture.shape))
                else:
                    wid = aperture.shape.radius * 2
                    trace = self.trace_buff.get_trace(wid, seg)
                    if trace is None:
                        # FIXME(shamer): fill into segments not old Trace class
                        #trace = Trace(wid)
                        self.img_buff.traces.append(trace)
                    trace.segments.append(seg)
                    self.trace_buff.add_segment(seg, trace)

        elif self.status['draw'] == 'FLASH':
            aperture = apertures[self.status['aperture']]
            shape_inst = ShapeInstance(ends[1], aperture)
            self.img_buff.shape_instances.append(shape_inst)

        return {'x':end[0], 'y':end[1]}


    # coordinate interpretation

    def _target_pos(self, block):
        """ Interpret coordinates in a data block. """
        coord = {'x':block.x, 'y':block.y}
        for k in coord:
            if self.params['FS'].incremental_coords:
                if coord[k] is None:
                    coord[k] = 0
                coord[k] = self.status[k] + getattr(block, k)
            else:
                if coord[k] is None:
                    coord[k] = self.status[k]
        return (coord['x'], coord['y'])


    # geometry

    def _draw_arc(self, end_pts, center_offset):
        """ Convert arc path into shape. """
        start, end = end_pts
        offset = {'i':center_offset[0], 'j':center_offset[1]}
        for k in offset:
            if offset[k] is None:
                offset[k] = 0
        center, radius = self._get_ctr_and_radius(end_pts, offset)
        start_angle = self._get_angle(center, start)
        end_angle = self._get_angle(center, end)
        clockwise = 'ANTI' not in self.status['interpolation']
        self._check_mq(start_angle, end_angle, clockwise)
        return Arc(center.x, center.y,
                   start_angle if clockwise else end_angle,
                   end_angle if clockwise else start_angle,
                   radius)


    def _get_ctr_and_radius(self, end_pts, offset):
        """ Apply gerber circular interpolation logic. """
        start, end = end_pts
        radius = sqrt(offset['i']**2 + offset['j']**2)

        centers = [Point(start.x + xsign * offset['i'],
                         start.y + ysign * offset['j'])
                   for xsign in (1, -1) for ysign in (1, -1)]

        center = min(centers, key=lambda c: abs(c.dist(end) - radius))

        return (center, radius)


    def _get_angle(self, arc_center, point):
        """
        Convert 2 points to an angle in radians/pi.

        0 radians = 3 o'clock, in accordance with
        the way arc angles are defined in shape.py

        """
        adj = float(point.x - arc_center.x)
        opp = point.y - arc_center.y
        hyp = arc_center.dist(point)
        if hyp == 0.0:
            return 0.0
        angle = acos(adj/hyp)/pi
        if opp > 0:
            angle = 2 - angle
        return angle


    # tokenizer

    def _tokenize(self, layer_file):
        """ Split gerber file into pythonic tokens. """
        content = layer_file.read()
        layer_file.close()
        param_block = eof = False
        pos = 0
        match = TOK_RE.match(content)
        while pos < len(content):
            if match is None:
                pos += 1
            else:
                typ = match.lastgroup
                tok = match.group(typ)[:-1]
                try:
                    if typ == 'MACRO':
                        yield self._parse_macro(tok)
                    elif typ == 'PARAM_DELIM':
                        param_block = not param_block

                    # params
                    elif len(typ) == 2:
                        self._check_pb(param_block, tok)
                        self.params.update(self._parse_param(tok))

                    # data blocks
                    elif typ not in IGNORE:
                        if typ == 'EOF':
                            self._check_eof(content[match.end():])
                            eof = True
                        elif typ == 'UNKNOWN':
                            if not self.ignore_unknown:
                                raise UnintelligibleDataBlock(tok)
                        else:
                            self._check_pb(param_block, tok, False)
                            # explode self-referential data blocks
                            blocks = self._parse_data_block(tok)
                            for block in blocks:
                                yield block

                except Unparsable:
                    raise
                pos = match.end()
            match = TOK_RE.match(content, pos)
        self._check_eof(eof=eof)
        self.layer_buff.images.append(self.img_buff)


    # tokenizer support - macros

    def _parse_macro(self, tok):
        """ Define a macro, with its component shapes. """
        parts = [part.strip() for part in tok.split('*')]
        name = parts[0][3:]
        prims =  [part.split(',') for part in parts[1:-1] if part]
        int_prims = []

        for prim in prims:
            if prim[0].startswith('$'):
                shape_type = 'ignore'
                mods = prim
            else:
                shape_type = PRIMITIVES[int(prim[0])]
                mods = prim[1:]

            int_prims.append(InternalPrimitive(shape_type, mods))

        return MacroDef(name, int_prims)


    # tokenizer support - params

    def _parse_param(self, tok):
        """ Convert a param specifier into pythonic data. """
        name, tok = (tok[:2], tok[2:])
        if name == 'FS':
            tup = self._extract_fs(tok)
        elif name == 'AD':
            self._extract_ad(tok)
            return {}
        elif name in AXIS_PARAMS:
            tup = self._extract_ap(name, tok)
        elif name in LAYER_PARAMS:
            self._extract_lp(name, tok)
            return {}
        else:
            tup = tok
        return {name:tup}


    def _extract_fs(self, tok):
        """ Extract format spec param parts into tuple. """
        tok, m_max = self._pop_val('M', tok)
        tok, d_max = self._pop_val('D', tok)
        tok, y = self._pop_val('Y', tok, coerce_=False)
        y = CoordFmt(int(y[0]), int(y[1]))
        tok, x = self._pop_val('X', tok, coerce_=False)
        x = CoordFmt(int(x[0]), int(x[1]))
        tok, g_max = self._pop_val('G', tok)
        tok, n_max = self._pop_val('N', tok)
        inc_coords = ('I' in tok)
        z_omit = tok[0]
        return FormatSpec(z_omit, inc_coords, n_max, g_max,
                          x, y, d_max, m_max)


    def _extract_ad(self, tok):
        """ Extract aperture definition into shapes dict. """
        tok = tok if ',' in tok else tok + ','
        code_end = 4 if tok[3].isdigit() else 3
        code = tok[1:code_end]
        ap_type, mods = tok[code_end:].split(',')
        if mods:
            mods = [float(m) for m in mods.split('X') if m]

        # An aperture can use any of the 4 standard types,
        # (with or without a central hole), or a previously
        # defined macro.
        if ap_type == 'C':
            shape = Circle(0, 0, mods[0]/2)
            hole_defs = len(mods) > 1 and mods[1:]
        elif ap_type == 'R':
            if len(mods) == 1:
                shape = Rectangle(-mods[0]/2, mods[0]/2,
                                   mods[0], mods[0])
            else:
                shape = Rectangle(-mods[0]/2, mods[1]/2,
                                   mods[0], mods[1])
            hole_defs = len(mods) > 2 and mods[2:]
        elif ap_type == 'O':
            shape = Obround(0, 0, mods[0], mods[1])
            hole_defs = len(mods) > 2 and mods[2:]
        elif ap_type == 'P':
            if len(mods) < 3:
                mods.append(0)
            shape = RegularPolygon(0, 0, mods[0], mods[1], mods[2])
            hole_defs = len(mods) > 3 and mods[3:]
        else: # macro
            shape = ap_type
            if shape in self.macro_buff:
                macro = self.macro_buff[shape].instantiate(mods)
                counter = 0 # pick a unique name for the macro
                while mods and macro.name in self.layer_buff.macros:
                    macro.name = shape + str(counter)
                    counter += 1
                self.layer_buff.macros[macro.name] = macro
            hole_defs = None

        if hole_defs and (len(hole_defs) > 1):
            hole = Rectangle(-hole_defs[0]/2,
                              hole_defs[1]/2,
                              hole_defs[0],
                              hole_defs[1])
        elif hole_defs:
            hole = Circle(0, 0, hole_defs[0]/2)
        else:
            hole = None

        self.layer_buff.apertures.update({code:Aperture(code, shape, hole)})


    def _extract_ap(self, name, tok):
        """ Extract axis-defining param into tuple. """
        if name in ('AS', 'IJ'):
            coerce_ = False
        else:
            coerce_ = name == 'MI' and 'int' or 'float'
        tok, b_val = self._pop_val('B', tok, coerce_=coerce_)
        tok, a_val = self._pop_val('A', tok, coerce_=coerce_)
        if name == 'IJ':
            tup = AxisDef(self._parse_justify(a_val),
                          self._parse_justify(b_val))
        else:
            tup = AxisDef(a_val, b_val)
        return tup


    def _extract_lp(self, name, tok):
        """ Extract "layer param" and reset image layer. """
        if self.img_buff.not_empty():
            self.layer_buff.images.append(self.img_buff)
            self.img_buff = Image('', self.img_buff.is_additive)
            self.trace_buff = TraceBuffer()
            self.status.update({'x':0,
                                'y':0,
                                'draw':'OFF',
                                'interpolation':'LINEAR',
                                'aperture':None,
                                'outline_fill':False,
                                'multi_quadrant':False,
                                'units':None,
                                'incremental_coords':None})
        if name == 'LN':
            self.img_buff.name = tok
        elif name == 'LP':
            self.img_buff.is_additive = IMAGE_POLARITIES[tok]
        elif name == 'SR':
            tok, j = self._pop_val('J', tok, coerce_='float')
            tok, i = self._pop_val('I', tok, coerce_='float')
            tok, y = self._pop_val('Y', tok)
            tok, x = self._pop_val('X', tok)
            self.img_buff.x_repeats = x
            self.img_buff.x_step = i
            self.img_buff.y_repeats = y
            self.img_buff.y_step = j


    def _parse_justify(self, val):
        """ Make a tuple for each axis (special case). """
        if len(val) > 1 or val not in 'LC':
            ab_tup = ('L', float(val.split('L')[-1]))
        else:
            ab_tup = (val, None)
        return ab_tup


    # tokenizer support - funct/coord

    def _parse_data_block(self, tok):
        """ Convert a non-param into pythonic data. """
        if 'G' in tok:
            g_code = tok[1:3]
            tok = tok[3:]
            if int(g_code) in G_MAP:
                yield Funct('G', g_code)
        tok, d_code = self._pop_val('D', tok, coerce_=False)
        if d_code:

            # identify D03 without coord - flash at current pos
            type_ = (d_code == '03' and not tok) and 'XD' or 'D'

            yield Funct(type_, d_code)
        if tok:
            yield self._parse_coord(tok)


    def _parse_coord(self, tok):
        """ Convert a coordinate set into pythonic data. """
        self._check_fs()
        tok, j = self._pop_val('J', tok, format_=True)
        tok, i = self._pop_val('I', tok, format_=True)
        tok, y = self._pop_val('Y', tok, format_=True)
        tok, x = self._pop_val('X', tok, format_=True)
        result = Coord(x, y, i, j)
        if tok:
            raise CoordMalformed('%s remainder=%s' % (result, tok))
        return result


    def _format_dec(self, num_str, axis):
        """
        Interpret a coordinate value using format spec.

        Params: num_str (the string representation of a number
                         portended by format spec)
                axis (X or Y - not to be confused with A/B)

        Returns: float

        """
        f_spec = self.params['FS']
        sign_wid = num_str[0] in ('-', '+') and 1 or 0
        int_wid = sign_wid + f_spec[axis].int
        wid = int_wid + f_spec[axis].dec

        # pad coordinate to specified width
        if f_spec.zero_omission == 'L':
            num_str = num_str.zfill(wid)
        elif f_spec.zero_omission == 'T':
            num_str = num_str.rjust(wid, '0')
        if len(num_str) != wid:
            raise CoordMalformed('num_str: %s wid: %s' % (num_str, wid))

        # insert decimal point
        num_str = '%s.%s' % (num_str[:int_wid], num_str[int_wid:])

        return float(num_str)


    # general support methods

    def _pop_val(self, key, tok, format_=False, coerce_='int'):
        """ Pop a labelled value from the end of a token. """
        val = None
        if key in tok:
            tok, num_str = tok.split(key)
            if num_str:
                if format_:
                    if key in ('X', 'I'):
                        val = self._format_dec(num_str, 4)
                    else:
                        val = self._format_dec(num_str, 5)
                else:
                    if coerce_ == 'float':
                        if '.' in num_str:
                            val = int(float(num_str))
                        else:
                            val = int(num_str)
                    elif coerce_:
                        val = int(num_str)
                    else:
                        val = num_str

        return (tok, val)


    def _check_fill(self):
        """ Check that a fill is closed. """
        ends = [pair[0] for pair in self.fill_buff]
        fill = [pair[1] for pair in self.fill_buff]
        self.fill_buff = []

        if ends[0][0] == ends[-1][1]:
            return Fill(fill)
        else:
            raise OpenFillBoundary('%s != %s' % (ends[-1][1], ends[0][0]))


    def _check_smear(self, seg, shape):
        """ Enforce linear interpolation constraint. """
        if not isinstance(seg, Line):
            raise IncompatibleAperture('%s cannot draw arc %s' % (shape, seg))


    def _check_mq(self, start_angle, end_angle, clockwise):
        """ Enforce single quadrant arc length restriction. """

        if not self.status['multi_quadrant']:
            if clockwise:
                arc = (2.0 if end_angle == 0.0 else end_angle) - \
                    (0.0 if start_angle == 2.0 else start_angle)
            else:
                arc = (2.0 if start_angle == 0.0 else start_angle) - \
                    (0.0 if end_angle == 2.0 else end_angle)

            if round(abs(arc), 4) > 0.5:
                raise QuadrantViolation('Arc(%s to %s) > 0.5 rad/pi'
                                        % (start_angle, end_angle))


    def _check_pb(self, param_block, tok, should_be=True):
        """ Ensure we are parsing an appropriate block. """
        if should_be and not param_block:
            raise DelimiterMissing
        if param_block and not should_be:
            raise ParamContainsBadData(tok)


    def _check_fs(self):
        """ Ensure coordinate is able to be interpreted. """
        if not self.params['FS']:
            raise CoordPrecedesFormatSpec


    def _check_eof(self, trailing_fragment=None, eof=False):
        """ Ensure file is terminated correctly. """
        if not (trailing_fragment or eof):
            raise FileNotTerminated
        elif (not eof) and trailing_fragment.strip():
            raise DataAfterEOF(trailing_fragment)


    def _debug_stdout(self):
        """ Dump what we know. """
        for layer in self.layout.layers:
            print '-- %s (%s) --' % (layer.name, layer.type)
            for j in layer.apertures:
                print '-- D%s --' % j
                print layer.apertures[j].json()
            for k in layer.macros:
                print '-- %s --' % k
                print layer.macros[k].json()
            for image in layer.images:
                print '-- %s (%s) --' % (image.name,
                                         image.is_additive and
                                         'additive' or 'subtractive')
                print image.json()
        raise Unparsable('deliberate error')


class InternalMacro(object):
    """
    Complex shape built from multiple primitives.

    Primitive shapes are added together in the order they appear in
    the list. Subtractive shapes subtract only from prior shapes, not
    subsequent shapes.
    """

    def __init__(self, block):
        self.name = block.name
        self.primitives = block.primitive_defs

    def instantiate(self, values):
        """ Return a core.layout.Macro given the list of values
        provided in the aperture definition."""

        values = dict(enumerate(values, 1))
        return Macro(self.name, filter(None, [p.instantiate(values)
                                              for p in self.primitives]))


class InternalPrimitive(object):
    """ A shape with modifiers. """

    def __init__(self, shape_type, modifiers):
        self.shape_type = shape_type # string, e.g., ('line', 'rectangle', etc.)
        self.modifiers = [Modifier(m) for m in modifiers]


    def instantiate(self, values):
        """ Return a core.layout.Primitive with a set of fixed shapes
        given a dict mapping variable numbers to values, or None if there
        is no corresponding shape. """

        shape_type = self.shape_type

        mods = [m.evaluate(values) for m in self.modifiers]

        if shape_type == 'ignore':
            return None

        is_additive = True if shape_type in ('moire', 'thermal') \
            else bool(mods[0])

        rotation = 0 if shape_type in ('circle', 'moire', 'thermal') \
            else mods[-1]/180

        if shape_type == 'circle':
            shape = Circle(x=mods[2],
                           y=mods[3],
                           radius=mods[1]/2)
        elif shape_type == 'line-vector':
            shape, rotation = self._vector_to_rect(mods, rotation)
        elif shape_type == 'line-center':
            shape = Rectangle(x=mods[3] - mods[1]/2,
                              y=mods[4] + mods[2]/2,
                              width=mods[1],
                              height=mods[2])
        elif shape_type == 'line-lower-left':
            shape = Rectangle(x=mods[3],
                              y=mods[4] + mods[2],
                              width=mods[1],
                              height=mods[2])
        elif shape_type == 'outline':
            points = [Point(mods[i], mods[i + 1])
                      for i in range(2, len(mods[:-1]), 2)]
            shape = Polygon(points)
        elif shape_type == 'polygon':
            shape = RegularPolygon(x=mods[2],
                                   y=mods[3],
                                   outer=mods[4],
                                   vertices=mods[1])
        elif shape_type == 'moire':
            mods[8] = 2 - mods[8]/180
            shape = Moire(*mods[0:9])
        elif shape_type == 'thermal':
            mods[5] = 2 - mods[5]/180
            shape = Thermal(*mods[0:6])

        return Primitive(is_additive, rotation, shape)


    def _vector_to_rect(self, mods, rotation):
        """
        Convert a vector into a Rectangle.

        Strategy
        ========
        If vect is not horizontal:
            - rotate about the origin until horizontal
            - define it as a normal rectangle
            - incorporate rotated angle into explicit rotation

        """
        start, end = (mods[2:4], mods[4:6])
        start_radius = sqrt(start[0]**2 + start[1]**2)
        end_radius = sqrt(end[0]**2 + end[1]**2)

        # Reverse the vector if its endpoint is closer
        # to the origin than its start point (avoids
        # mucking about with signage later).
        if start_radius > end_radius:
            end, start = (mods[2:4], mods[4:6])
            radius = end_radius
        else:
            radius = start_radius

        # Calc the angle of the vector with respect to the x axis.
        x, y = start
        adj = end[0] - x
        opp = end[1] - y
        hyp = sqrt(adj**2 + opp**2)
        theta = acos(adj/hyp)/pi
        if opp > 0:
            theta = 2 - theta

        # Represent vector angle as a delta.
        d_theta = 2 - theta

        # Calc the angle of the start point of the flattened vector.

        theta = 0.0 if radius == 0.0 else acos(x/radius)/pi 
        if y > 0:
            theta = 2 - theta
        theta += d_theta

        # Redefine x and y at center of the rect's left side.

        y = sin((2 - theta) * pi) * radius
        x = cos((2 - theta) * pi) * radius

        # Calc the composite rotation angle.
        rotation = (rotation + theta) % 2

        return (Rectangle(x=x,
                          y=y + mods[1]/2,
                          width=hyp,
                          height=mods[1]),
                rotation)


class Modifier(object):
    """ An expression in a macro primitive.

    We interpret gerber expressions according to the following
    grammar, rooted at TOP:

      TOP -> number ESUB
      TOP -> minus number ESUB
      TOP -> variable TOPE
      TOPE ->
      TOPE -> equate E
      TOPE -> op E
      E -> variable ESUB
      E -> number ESUB
      E -> minus number ESUB
      ESUB ->
      ESUB -> op E

    All numerical operations are given the same precedence and are
    grouped right to left.
    """

    scanner = re.Scanner([
            (r'\d*\.\d+', lambda s, tok: Token('number', float(tok))),
            (r'\d+', lambda s, tok: Token('number', float(tok))),
            (r'\$\d+', lambda s, tok: Token('variable', int(tok[1:]))),
            (r'[\+xX/-]', lambda s, tok: Token('op', tok.lower())),
            (r'=', lambda s, tok: Token('equate', None)),
            ])

    def __init__(self, expr):
        self.tokens, remainder = self.scanner.scan(expr)
        if remainder:
            raise InvalidExpression(expr)


    def evaluate(self, values):
        """ Evaluate the expression given a values dict and return the
        resulting value. The values dict may be modified in the
        process (by an equate expression). """
        stack = []
        self._evaluate_top(list(self.tokens), stack, values)
        return self._pop_value(stack, values)


    def _evaluate_top(self, tokens, stack, values):
        """ Evaluate the TOP production. """
        token = tokens.pop(0)

        if token.type == 'number':
            stack.append(token)
            self._evaluate_sube(tokens, stack, values)
        elif token.type == 'variable':
            stack.append(token)
            self._evaluate_tope(tokens, stack, values)
        elif token == ('op', '-'):
            if not tokens:
                raise InvalidExpression(token, stack, values)
            num = tokens.pop(0)
            if num.type != 'number':
                raise InvalidExpression(token, num, stack, values)
            stack.append(Token('number', -num.value))
        else:
            raise InvalidExpression(token, tokens)


    def _evaluate_tope(self, tokens, stack, values):
        """ Evaluate the TOPE production. """
        if not tokens:
            return

        token = tokens.pop(0)

        if token.type == 'equate':
            var = stack.pop()
            self._evaluate_e(tokens, stack, values)
            values[var.value] = self._pop_value(stack, values)
            stack.append(Token('number', values[var.value]))
        elif token.type == 'op':
            self._evaluate_e(tokens, stack, values)
            self._evaluate_op(token, stack, values)
        else:
            raise InvalidExpression(token, tokens)


    def _evaluate_e(self, tokens, stack, values):
        """ Evaluate the E production. """
        token = tokens.pop(0)

        if token.type in ('number', 'variable'):
            stack.append(token)
            self._evaluate_sube(tokens, stack, values)
        elif token == ('op', '-'):
            if not tokens:
                raise InvalidExpression(token, stack, values)
            num = tokens.pop(0)
            if num.type != 'number':
                raise InvalidExpression(token, num, stack, values)
            stack.append(Token('number', -num.value))
        else:
            raise InvalidExpression(token, tokens)


    def _evaluate_sube(self, tokens, stack, values):
        """ Evaluate the SUBE production. """
        if not tokens:
            return

        token = tokens.pop(0)

        if token.type == 'op':
            self._evaluate_e(tokens, stack, values)
            self._evaluate_op(token, stack, values)
        else:
            raise InvalidExpression(token, tokens)


    def _evaluate_op(self, operand, stack, values):
        """ Evaluate the given operand and push the value onto the
        stack. """
        val2 = self._pop_value(stack, values)
        val1 = self._pop_value(stack, values)

        if operand.value == '+':
            val = val1 + val2
        elif operand.value == '-':
            val = val1 - val2
        elif operand.value == 'x':
            val = val1 * val2
        elif operand.value == '/':
            val = val1 / val2
        else:
            raise InvalidExpression(operand, stack)

        stack.append(Token('number', val))


    def _pop_value(self, stack, values):
        """ Pop a value from the stack and return it,
        replacing variables with their values. """

        token = stack.pop()

        if token.type == 'number':
            return token.value
        elif token.type == 'variable':
            return values[token.value]
        else:
            raise InvalidExpression(token, stack, values)


class TraceBuffer(object):
    """
    Map precision-rounded points to traces for fast trace lookup.
    """

    precision = 6

    def __init__(self):
        self.pt2trace = {} # (width, (x, y)) -> Trace

    def add_segment(self, segment, trace):
        """ Add a segment to a trace in the cache. """
        for point in self.get_ends(segment):
            self.pt2trace[trace.width, point] = trace

    def get_trace(self, width, segment):
        """ Given a width and a trace segment, return the Trace
        where that segment should go, or None if no Trace matches. """
        for point in self.get_ends(segment):
            trace = self.pt2trace.get((width, point))
            if trace is not None:
                return trace

    def get_ends(self, segment):
        """ Return the endpoints of the segment as a tuple
        of precision-rounded (x,y) tuples. """
        if isinstance(segment, Arc):
            ends = segment.ends()
        else:
            ends = (segment.p1, segment.p2)

        return ((round(point.x, self.precision),
                 round(point.y, self.precision)) for point in ends)

########NEW FILE########
__FILENAME__ = kicad
#!/usr/bin/env python2
""" The KiCAD Format Parser """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Basic Strategy
# 0) Ignore data except the useful
# 1) Read in all of the segments (and junctions and components)
# 2) Divide all the segments by the junctions
# 3) Calculate the nets from the segments
# 4) Read the part library to figure out components and pin connectivity
#
# Note: in a KiCAD schematic, the y coordinates increase downwards. In
# OpenJSON, y coordinates increase upwards, so we negate them. In the
# KiCAD library file (where components are stored) y coordinates
# increase upwards as in OpenJSON and no transformation is needed.
# KiCAD units are mils (1/1000th of an inch)

from upconvert.core.design import Design
from upconvert.core.components import Component, Symbol, SBody, Pin
from upconvert.core.component_instance import ComponentInstance, SymbolAttribute
from upconvert.core.net import Net, NetPoint, ConnectedComponent
from upconvert.core.shape import Arc, Circle, Line, Rectangle, Label
from upconvert.core.annotation import Annotation

from upconvert.library.kicad import lookup_part

from os.path import split
from os import listdir

MULT = 2.0 / 10.0 # mils to 90 dpi


class KiCAD(object):
    """ The KiCAD Format Parser """

    library = None

    @staticmethod
    def auto_detect(filename):
        """ Return our confidence that the given file is an kicad schematic """
        with open(filename, 'r') as f:
            data = f.read(4096)
        confidence = 0
        if 'EESchema Schematic' in data:
            confidence += 0.75
        return confidence


    def parse(self, filename, library_filename=None):
        """ Parse a kicad file into a design """

        design = Design()
        segments = set() # each wire segment
        junctions = set() # wire junction point (connects all wires under it)

        self.instance_names = []

        self.library = KiCADLibrary()

        if library_filename is None:
            directory, _ = split(filename)
            for dir_file in listdir(directory):
                if dir_file.endswith('.lib'):
                    self.library.parse(directory + '/' + dir_file)

        for cpt in self.library.components:
            design.add_component(cpt.name, cpt)

        with open(filename) as f:
            libs = []
            line = f.readline().strip()

            # parse the library references
            while line and line != "$EndDescr":
                if line.startswith('LIBS:'):
                    libs.extend(line.split(':', 1)[1].split(','))
                line = f.readline().strip()

            # Now parse wires and components, ignore connections, we get
            # connectivity from wire segments

            line = f.readline()

            while line:
                prefix = line.split()[0]

                if line.startswith('Wire Wire Line'):
                    self.parse_wire(f, segments)
                elif prefix == "Connection": # Store these to apply later
                    self.parse_connection(line, junctions)
                elif prefix == "Text":
                    design.design_attributes.add_annotation(
                        self.parse_text(f, line))
                elif prefix == "$Comp": # Component Instance
                    inst, comp = self.parse_component_instance(f)
                    design.add_component_instance(inst)
                    if comp is not None:
                        design.add_component(comp.name, comp)
                    self.ensure_component(design, inst.library_id, libs)

                line = f.readline()

        segments = self.divide(segments, junctions)
        design.nets = self.calc_nets(design, segments)

        design.scale(MULT)

        return design


    def ensure_component(self, design, name, libs):
        """
        Add a component to the design, it if is not already present.
        """

        if self.library is not None \
                and self.library.lookup_part(name) is not None:
            return

        cpt = lookup_part(name, libs)

        if cpt is None:
            return

        if cpt.name not in design.components.components:
            design.components.add_component(cpt.name, cpt)


    def parse_wire(self, f, segments):
        """ Parse a Wire segment line """
        x1, y1, x2, y2 = [int(i) for i in f.readline().split()]

        if not(x1 == x2 and y1 == y2): # ignore zero-length segments
            segments.add(((x1, -y1), (x2, -y2)))


    def parse_connection(self, line, junctions):
        """ Parse a Connection line """
        x, y = [int(i) for i in line.split()[2:4]]
        junctions.add((x, -y))


    def parse_text(self, f, line):
        """ Parse a Text line """
        parts = line.split()
        x, y, rotation = int(parts[2]), int(parts[3]), int(parts[4])
        rotation = rotation / 2.0
        value = f.readline().decode('utf-8', 'replace').strip()
        return Annotation(value, x, -y, rotation, 'true')


    def parse_field(self, compx, compy, line):
        """ Parse a field (F) line in a component block """
        parts = line.rsplit('"', 1)
        value = parts[0].split('"', 1)[1].decode('utf-8', 'replace')
        parts = parts[1].strip().split()

        return Annotation(value,
                          int(parts[1]) - compx,
                          -(int(parts[2]) - compy),
                          0 if parts[0] == 'H' else 1, 'true')


    def parse_component_instance(self, f):
        """ Parse a component instance from a $Comp block """
        # pylint: disable=R0914

        # name & reference
        prefix, name, reference = f.readline().split()
        assert prefix == 'L'

        ref_count_idx = 1
        while reference in self.instance_names:
            ref_count_idx += 1
            reference = reference + '-' + str(ref_count_idx)

        self.instance_names.append(reference)

        comp = None
        if self.library is not None:
            library_part = self.library.lookup_part(name)
            if library_part is not None:
                name = library_part.name

        # unit & convert
        prefix, unit, convert, ar_path = f.readline().split(None, 3)
        unit, convert = int(unit), int(convert)
        assert prefix == 'U'

        # position
        prefix, compx, compy = f.readline().split()
        assert prefix == 'P'
        compx, compy = int(compx), int(compy)

        line = f.readline()
        rotation = 0
        flip = False
        annotations = []

        while line.strip() not in ("$EndComp", ''):
            if line.startswith('F '):
                annotations.append(self.parse_field(compx, compy, line))
            elif line.startswith('\t'):
                parts = line.strip().split()
                if len(parts) == 4:
                    rotation, flip = MATRIX2ROTATIONFLIP.get(
                        tuple(int(i) for i in parts), (0, False))
            elif line.startswith('AR Path'):
                if '?' in reference:
                    path_line = line.strip().split()
                    ar_path_check = path_line[1].strip('"')[7:] #removes Path="/
                    if ar_path.strip() == ar_path_check:
                        reference = path_line[2].strip('"')[5:] #removes Ref="

            line = f.readline()

        inst = ComponentInstance(reference, library_part, name.upper(), convert - 1)
        symbattr = SymbolAttribute(compx, -compy, rotation, flip)
        for ann in annotations:
            symbattr.add_annotation(ann)
        inst.add_symbol_attribute(symbattr)

        return inst, comp


    def intersect(self, segment, ptc):
        """ Does point c intersect the segment """
        pta, ptb = segment
        ptax, ptay, ptbx, ptby, ptcx, ptcy = pta + ptb + ptc
        if ptax == ptbx == ptcx: # Vertical
            if min(ptay, ptby) < ptcy < max(ptay, ptby): # between a and b
                return True
        elif ptay == ptby == ptcy: # Horizontal
            if min(ptax, ptbx) < ptcx < max(ptax, ptbx): # between a and b
                return True
        elif (ptcx-ptax)*(ptby-ptay)==(ptbx-ptax)*(ptcy-ptay): # Diagonal
            if min(ptax, ptbx) < ptcx < max(ptax, ptbx): # between a and b
                return True
        return False


    def divide(self, segments, junctions):
        """ Divide segments by junctions """
        for ptc in junctions:
            toremove = set()
            toadd = set()
            for seg in segments:
                if self.intersect(seg, ptc):
                    pta, ptb = seg
                    toremove.add((pta, ptb))
                    toadd.add((pta, ptc))
                    toadd.add((ptc, ptb))
            segments -= toremove
            segments |= toadd
        return segments


    def calc_nets(self, design, segments):
        """ Return a set of Nets from segments """

        coord2point = {} # (x, y) -> NetPoint

        def get_point(coord):
            """ Return a new or existing NetPoint for an (x,y) point """
            coord = (int(coord[0]), int(coord[1]))
            if coord not in coord2point:
                coord2point[coord] = NetPoint('%da%d' % coord, coord[0], coord[1])
            return coord2point[coord]

        # use this to track connected pins not yet added to a net
        self.make_pin_points(design, get_point)

        # set of points connected to pins
        pin_points = set(coord2point.itervalues())

        # turn the (x, y) points into unique NetPoint objects
        segments = set((get_point(p1), get_point(p2)) for p1, p2 in segments)
        nets = []

        # Iterate over the segments, removing segments when added to a net
        while segments:
            seg = segments.pop() # pick a point
            newnet = Net('')
            map(pin_points.discard, seg) # mark points as used
            newnet.connect(seg)
            found = True

            while found:
                found = set()

                for seg in segments: # iterate over segments
                    if newnet.connected(seg): # segment touching the net
                        map(pin_points.discard, seg) # mark points as used
                        newnet.connect(seg) # add the segment
                        found.add(seg)

                for seg in found:
                    segments.remove(seg)

            nets.append(newnet)

        # add single-point nets for overlapping pins that are not
        # already in other nets
        for point in pin_points:
            if len(point.connected_components) > 1:
                net = Net('')
                net.add_point(point)
                nets.append(net)

        for net in nets:
            net.net_id = min(net.points)

        nets.sort(key=lambda net : net.net_id)

        return nets


    def make_pin_points(self, design, point_factory):
        """ Construct a set of NetPoints connected to pins. """

        for inst in design.component_instances:
            if inst.library_id in design.components.components:
                cpt = design.components.components[inst.library_id]
                for symba, body in zip(inst.symbol_attributes,
                                       cpt.symbols[inst.symbol_index].bodies):
                    for pin in body.pins:
                        point = point_factory(self.get_pin_coord(pin, symba))
                        point.add_connected_component(
                            ConnectedComponent(inst.instance_id, pin.pin_number))


    def get_pin_coord(self, pin, symba):
        """ Return the x, y coordinate of a pin on a symbol attribute """

        x, y = pin.p2.x, pin.p2.y

        matrix = ROTFLIP2MATRIX.get((symba.rotation, symba.flip), ROTFLIP2MATRIX[(0, False)])

        x, y = (matrix[0] * x + matrix[1] * y,
                matrix[2] * x + matrix[3] * y)

        return symba.x + x, symba.y - y


# map kicad rotation matrices to pi radians
#TODO: add flip
MATRIX2ROTATIONFLIP = {(1, 0, 0, -1): (0, False),
                   (0, 1, 1, 0): (0.5, False),
                   (-1, 0, 0, 1): (1, False),
                   (0, -1, -1, 0): (1.5, False),
                   (0, 1, -1, 0): (0.5, True),
                   (0, -1, 1, 0): (1.5, True),
                   (1, 0, 0, 1): (1, True),
                   (-1, 0, 0, -1): (0, True)}

# map openjson rotations to rotation matrices
ROTFLIP2MATRIX = dict((v, k) for k, v in MATRIX2ROTATIONFLIP.iteritems())


class KiCADLibrary(object):
    """
    I represent a library of kicad parts.
    """

    def __init__(self):
        self.components = []
        self.name2cpt = {}

    def lookup_part(self, name):
        """
        Return a kicad component by name, or None if not found.
        """

        return self.name2cpt.get(name.upper())

    def __getitem__(self, name):
        return self.lookup_part(name)

    def __contains__(self, name):
        return self.lookup_part(name) != None

    def parse(self, filename):
        """
        Parse the library file, and update the KiCADLibrary.
        """

        new_components = []

        with open(filename) as f:
            for line in f:
                if line.startswith('DEF '):
                    new_components.append(ComponentParser(line).parse(f))

        for new_component in new_components:
            new_component.name = new_component.name.upper()
            if new_component.name not in self.name2cpt:
                self.name2cpt[new_component.name] = new_component
                self.components.append(new_component)
                if 'kicad_alias' in new_component.attributes:
                    for name in new_component.attributes['kicad_alias'].split():
                        self.name2cpt[name.upper()] = new_component


class ComponentParser(object):
    """I parse components from KiCAD libraries."""

    # the column positions of the unit and convert fields
    unit_cols = dict(A=6, C=4, P=2, S=5, T=6, X=9)
    convert_cols = dict((k, v+1) for k, v in unit_cols.items())

    def __init__(self, line):
        parts = line.split()
        name = parts[1]
        if name.startswith('~'):
            name = name[1:]
        self.component = Component(name)
        self.component.add_attribute('_prefix', parts[2])
        self.num_units = max(int(parts[7]), 1)


    def build_symbols(self, has_convert):
        """ Build all Symbols and Bodies for this component. The
        has_convert argument should be True if there are DeMorgan
        convert bodies. """

        for _ in range(2 if has_convert else 1):
            symbol = Symbol()
            for _ in range(self.num_units):
                symbol.add_body(SBody())
            self.component.add_symbol(symbol)


    def iter_bodies(self, unit, convert, has_convert):
        """ Return an iterator over all the bodies implied by the
        given unit and convert options. A unit of 0 means all units
        for the given convert. A convert of 0 means both converts for
        the given unit. If both are 0 it applies to all bodies."""

        if convert == 0 and has_convert:
            symbol_indices = [0, 1] # both regular and convert
        elif convert in (0, 1):
            symbol_indices = [0] # just regular
        else:
            symbol_indices = [1] # just convert

        if unit == 0:
            body_indices = range(self.num_units) # all bodies
        else:
            body_indices = [unit-1] # one body

        for symbol_index in symbol_indices:
            for body_index in body_indices:
                try:
                    yield self.component.symbols[symbol_index].bodies[body_index]
                except IndexError:
                    pass

    def parse(self, f):
        """ Parse a DEF block and return the Component """

        draw_lines = [] # (unit, convert, prefix, parts)

        for line in f:
            parts = line.split()
            prefix = parts[0]

            if prefix in ('A', 'C', 'P', 'S', 'T', 'X'):
                draw_lines.append((int(parts[self.unit_cols[prefix]]),
                                           int(parts[self.convert_cols[prefix]]),
                                           prefix, parts))
            elif prefix == 'ALIAS':
                self.component.add_attribute('kicad_alias', ' '.join(parts[1:]))
            elif prefix == 'ENDDEF':
                break

        has_convert = any(convert == 2 for _, convert, _, _ in draw_lines)

        self.build_symbols(has_convert)

        for unit, convert, prefix, parts in draw_lines:
            method = getattr(self, 'parse_%s_line' % (prefix.lower(),))

            for body in self.iter_bodies(unit, convert, has_convert):
                obj = method(parts)

                if prefix == 'X':
                    body.add_pin(obj)
                else:
                    if isinstance(obj, (list, tuple)):
                        for o in obj:
                            body.add_shape(o)
                    else:
                        body.add_shape(obj)

        for symbol in self.component.symbols:
            for body in symbol.bodies:
                body.pins.sort(key=lambda pin : pin.pin_number)

        return self.component


    def parse_a_line(self, parts):
        """ Parse an A (Arc) line """
        x, y, radius, start, end = [int(i) for i in parts[1:6]]
        # convert tenths of degrees to pi radians
        start = start / 1800.0
        end = end / 1800.0
        return Arc(x, y, end, start, radius)


    def parse_c_line(self, parts):
        """ Parse a C (Circle) line """
        x, y, radius = [int(i) for i in parts[1:4]]
        return Circle(x, y, radius)


    def parse_p_line(self, parts):
        """ Parse a P (Polyline) line """
        num_points = int(parts[1])
        lines = []
        last_point = None
        for i in xrange(num_points):
            point = int(parts[5 + 2 * i]), int(parts[6 + 2 * i])
            if last_point is not None:
                lines.append(Line(last_point, point))
            last_point = point
        return lines


    def parse_s_line(self, parts):
        """ Parse an S (Rectangle) line """
        x, y, x2, y2 = [int(i) for i in parts[1:5]]
        return Rectangle(x, y, x2 - x, y - y2)


    def parse_t_line(self, parts):
        """ Parse a T (Text) line """
        angle, x, y = [int(i) for i in parts[1:4]]
        angle = angle / 1800.0
        text = parts[8].replace('~', ' ')

        if len(parts) >= 12:
            align = {'C': 'center', 'L': 'left', 'R': 'right'}.get(parts[11])
        else:
            align = 'left'

        return Label(x, y, text, align=align, rotation=angle)


    def parse_x_line(self, parts):
        """ Parse an X (Pin) line """
        name, num, direction = parts[1], parts[2], parts[6]
        p2x, p2y, pinlen = int(parts[3]), int(parts[4]), int(parts[5])

        if direction == 'U': # up
            p1x = p2x
            p1y = p2y + pinlen
            label_x = p2x - 20
            label_y = p2y + int(pinlen / 2)
            label_rotation = 1.5
        elif direction == 'D': # down
            p1x = p2x
            p1y = p2y - pinlen
            label_x = p2x - 20
            label_y = p2y - int(pinlen / 2)
            label_rotation = 1.5
        elif direction == 'L': # left
            p1x = p2x - pinlen
            p1y = p2y
            label_x = p2x - int(pinlen / 2)
            label_y = p2y + 20
            label_rotation = 0
        elif direction == 'R': # right
            p1x = p2x + pinlen
            p1y = p2y
            label_x = p2x + int(pinlen / 2)
            label_y = p2y + 20
            label_rotation = 0
        else:
            raise ValueError('unexpected pin direction', direction)

        if name == '~':
            label = None
        else:
            label = Label(label_x, label_y,
                          name, align='center', rotation=label_rotation)

        return Pin(num, (p1x, p1y), (p2x, p2y), label)

########NEW FILE########
__FILENAME__ = openjson
#!/usr/bin/env python2
""" The Open JSON Format Parser """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Basic Strategy
# 0) 1:1 Input of the data model

import json
import logging
from upconvert.core.annotation import Annotation
from upconvert.core.component_instance import ComponentInstance, SymbolAttribute, FootprintAttribute, GenObjAttribute, FootprintPos
from upconvert.core.components import Component, Symbol, SBody, Pin, FBody, Footprint
from upconvert.core.design import Design
from upconvert.core.design_attributes import DesignAttributes, Metadata
from upconvert.core.generated_object import parse_gen_obj_json, Path, Pour
from upconvert.core.shape import Rectangle, RoundedRectangle, Arc, Circle, Label, Line, Polygon, BezierCurve, RoundedSegment, Point
from upconvert.core.net import Net, NetPoint, ConnectedComponent
from upconvert.core.layout import Segment, Layer

log = logging.getLogger('parser.openjson')


class JSON(object):
    """ The Open JSON Format Parser
    This is mostly for sanity checks, it reads in the Open JSON format,
    and then outputs it. """

    def __init__(self):
        self.design = Design()


    @staticmethod
    def auto_detect(filename):
        """ Return our confidence that the given file is an openjson file """
        with open(filename, 'r') as f:
            data = f.read()
        confidence = 0
        if 'component_instances' in data:
            confidence += 0.3
        if 'design_attributes' in data:
            confidence += 0.6
        return confidence


    def parse(self, filename):
        """ Parse the openjson file into the core. """
        log.debug('Starting parse of %s', filename)
        with open(filename) as f:
            read = json.loads(f.read())

        self.parse_components(read.get('components'))
        self.parse_component_instances(read.get('component_instances'))
        if read.get('shapes') is not None:
            self.parse_sch_shapes(read.get('shapes'))
        self.parse_design_attributes(read.get('design_attributes'))
        self.parse_nets(read.get('nets'))
        self.parse_version(read.get('version'))

        # layout aspects
        self.parse_layer_options(read.get('layer_options'))
        self.parse_trace_segments(read.get('trace_segments'))
        self.parse_layout_objects(read.get('gen_objs'))
        self.parse_paths(read.get('paths'))
        self.parse_pours(read.get('pours'))
        self.parse_pcb_text(read.get('text'))

        return self.design


    def parse_version(self, version):
        """ Extract the file version. """
        file_version = version.get('file_version')
        exporter = version.get('exporter')
        self.design.set_version(file_version, exporter)


    def parse_layer_options(self, layer_options_json):
        if layer_options_json is None:
            return None

        for layer_option_json in layer_options_json:
            self.design.layer_options.append(Layer(layer_option_json['name']))


    def parse_trace_segments(self, segments_json):
        if segments_json is None:
            return None

        for segment_json in segments_json:
            p1 = Point(segment_json['p1']['x'], segment_json['p1']['y'])
            p2 = Point(segment_json['p2']['x'], segment_json['p2']['y'])
            segment = Segment(segment_json['layer'], p1, p2, segment_json['width'])
            self.design.trace_segments.append(segment)


    def parse_paths(self, paths_json):
        if paths_json is None:
            return None

        for path_json in paths_json:
            points = [Point(point_json['x'], point_json['y']) for point_json in path_json['points']]
            width = path_json['width']
            is_closed = path_json['is_closed']
            layer = path_json['layer']
            path = Path(layer, points, width, is_closed)
            self.design.paths.append(path)


    def parse_pours(self, pours_json):
        if pours_json is None:
            return None

        for pour_json in pours_json:
            points = [Point(point_json['x'], point_json['y']) for point_json in pour_json['points']]

            layer = pour_json['layer']
            subtractive_shapes = [];
            if 'subtractive_shapes' in pour_json:
                subtractive_shapes = [self.parse_shape(shape_json) for shape_json in pour_json['subtractive_shapes']]
            if 'readded_shapes' in pour_json:
                readded_shapes = [self.parse_shape(shape_json) for shape_json in pour_json['readded_shapes']]

            pour = Pour(layer, points, subtractive_shapes, readded_shapes)
            self.design.pours.append(pour)


    def parse_pcb_text(self, text_json):
        if text_json is None:
            return None

        for text_instance_json in text_json:
            anno = self.parse_annotation(text_instance_json)
            self.design.pcb_text.append(anno)


    def parse_layout_objects(self, gen_objs_json):
        if gen_objs_json is None:
            return None

        for gen_obj_json in gen_objs_json:
            gen_obj = parse_gen_obj_json(gen_obj_json)
            self.design.layout_objects.append(gen_obj)


    def parse_component_instances(self, component_instances):
        """ Extract the component instances. """

        if component_instances is None:
            return None

        for instance in component_instances:
            # Get instance_id, library_id and symbol_index
            instance_id = instance.get('instance_id')
            library_id = instance.get('library_id')
            symbol_index = int(instance.get('symbol_index'))
            footprint_index = int(instance.get('footprint_index'))
            # Make the ComponentInstance()
            inst = ComponentInstance(instance_id, self.design.components.components[library_id], library_id, symbol_index, footprint_index)

            # Get the SymbolAttributes
            for symbol_attribute in instance.get('symbol_attributes', []):
                attr = self.parse_symbol_attribute(symbol_attribute)
                inst.add_symbol_attribute(attr)

            # TODO(shamer) footprint_pos, fleb and genobj positions are relative to the footprint_pos
            for footprint_attribute in instance.get('footprint_attributes', []):
                attr = self.parse_footprint_attribute(footprint_attribute)
                inst.add_footprint_attribute(attr)
            for gen_obj_attribute in instance.get('gen_obj_attributes', []):
                attr = self.parse_gen_obj_attribute(gen_obj_attribute)
                inst.add_gen_obj_attribute(attr)

            footprint_json = instance.get('footprint_pos')
            if footprint_json:
                footprint_pos = self.parse_footprint_pos(footprint_json)
            else:
                footprint_pos = None
            inst.set_footprint_pos(footprint_pos)

            # Get the Attributes
            for key, value in instance.get('attributes').items():
                inst.add_attribute(key, value)

            # Add the ComponentInstance
            self.design.add_component_instance(inst)


    def parse_symbol_attribute(self, symbol_attribute):
        """ Extract attributes from a symbol. """
        x = int(symbol_attribute.get('x') or 0)
        y = int(symbol_attribute.get('y') or 0)

        rotation = float(symbol_attribute.get('rotation'))
        try:
            flip = (symbol_attribute.get('flip').lower() == "true")
        except:
            flip = False

        # Make SymbolAttribute
        symbol_attr = SymbolAttribute(x, y, rotation, flip)

        # Add Annotations
        for annotation in symbol_attribute.get('annotations'):
            anno = self.parse_annotation(annotation)
            symbol_attr.add_annotation(anno)

        # Return SymbolAttribute to be added to its ComponentInstance
        return symbol_attr


    def parse_footprint_attribute(self, footprint_attribute):
        """ Extract attributes from a footprint. """
        x = int(footprint_attribute.get('x') or 0)
        y = int(footprint_attribute.get('y') or 0)

        rotation = float(footprint_attribute.get('rotation'))
        try:
            flip = (footprint_attribute.get('flip').lower() == "true")
        except:
            flip = False

        layer = footprint_attribute.get('layer')

        footprint_attr = FootprintAttribute(x, y, rotation, flip, layer)

        return footprint_attr


    def parse_gen_obj_attribute(self, gen_obj_attribute):
        """ Extract attributes from a gen_obj. """
        x = int(gen_obj_attribute.get('x') or 0)
        y = int(gen_obj_attribute.get('y') or 0)

        rotation = float(gen_obj_attribute.get('rotation'))
        try:
            flip = (gen_obj_attribute.get('flip').lower() == "true")
        except:
            flip = False

        layer = gen_obj_attribute.get('layer')

        gen_obj_attr = GenObjAttribute(x, y, rotation, flip, layer)

        for key, value in gen_obj_attribute.get('attributes').items():
            gen_obj_attr.add_attribute(key, value)

        return gen_obj_attr


    def parse_footprint_pos(self, footprint_pos_json):
        """ Extract footprint pos. """
        x = int(footprint_pos_json.get('x') or 0)
        y = int(footprint_pos_json.get('y') or 0)

        rotation = float(footprint_pos_json.get('rotation', 0))
        flip = footprint_pos_json.get('flip')
        side = footprint_pos_json.get('side')

        return FootprintPos(x, y, rotation, flip, side)


    def parse_annotation(self, annotation):
        """ Extract an annotation. """
        value = annotation.get('value')
        x = int(annotation.get('x'))
        y = int(annotation.get('y'))
        label = self.parse_label(annotation.get('label'))
        layer = annotation.get('layer', 'default')
        rotation = float(annotation.get('rotation'))
        flip_horizontal = annotation.get('flip', False)
        visible = annotation.get('visible')
        if visible is not None and visible.lower() == 'false':
            visible = 'false'
        else:
            visible = 'true'
        return Annotation(value, x, y, rotation, visible, layer=layer, flip_horizontal=flip_horizontal, label=label)


    def parse_components(self, components):
        """ Extract a component library. """
        for library_id, component in components.items():
            name = component.get('name')
            comp = Component(name)
            # Get attributes
            for key, value in component.get('attributes', []).items():
                comp.add_attribute(key, value)
            for symbol_json in component.get('symbols', []):
                symbol = self.parse_symbol(symbol_json)
                comp.add_symbol(symbol)
            for footprint_json in component.get('footprints', []):
                footprint = self.parse_footprint(footprint_json)
                comp.add_footprint(footprint)
            self.design.add_component(library_id, comp)


    def parse_sch_shapes(self, shapes):
        """ Extract shapes drawn directly on the schematic. """
        for shape in shapes:
            self.design.add_shape(self.parse_shape(shape))


    def parse_symbol(self, symbol_json):
        """ Extract a symbol. """
        symb = Symbol()
        for body in symbol_json.get('bodies'):
            bdy = self.parse_symbol_body(body)
            symb.add_body(bdy)
        return symb


    def parse_footprint(self, footprint_json):
        """ Extract the bodies for a footprint. """
        footprint = Footprint()
        for body_json in footprint_json.get('bodies'):
            body = self.parse_footprint_body(body_json)
            footprint.add_body(body)
        for gen_obj_json in footprint_json.get('gen_objs'):
            gen_obj = self.parse_gen_obj(gen_obj_json)
            footprint.add_gen_obj(gen_obj)
        return footprint


    def parse_gen_obj(self, gen_obj_json):
        """ Extract the generated object. """
        gen_obj = parse_gen_obj_json(gen_obj_json)
        return gen_obj


    def parse_footprint_body(self, body_json):
        """ Extract a body of a symbol. """
        body = FBody()
        for shape in body_json.get('shapes'):
            parsed_shape = self.parse_shape(shape)
            body.add_shape(parsed_shape)
        body.layer = body_json.get('layer')
        body.rotation = body_json.get('rotation', 0)
        body.flip_horizontal = body_json.get('flip_horizontal', False)
        return body


    def parse_symbol_body(self, body):
        """ Extract a body of a symbol. """
        bdy = SBody()
        for pin in body.get('pins'):
            parsed_pin = self.parse_pin(pin)
            bdy.add_pin(parsed_pin)
        for shape in body.get('shapes'):
            parsed_shape = self.parse_shape(shape)
            bdy.add_shape(parsed_shape)
        return bdy


    def parse_pin(self, pin):
        """ Extract a pin of a body. """
        pin_number = pin.get('pin_number')
        p1 = self.parse_point(pin.get('p1'))
        p2 = self.parse_point(pin.get('p2'))
        parsed_pin = Pin(pin_number, p1, p2)
        if pin.get('label') is not None:
            parsed_pin.label = self.parse_label(pin.get('label'))
        parsed_pin.styles = pin.get('styles') or {}
        return parsed_pin

    def parse_point(self, point):
        """ Extract a point. """
        x = int(point.get('x'))
        y = int(point.get('y'))
        return Point(x, y)

    def parse_label(self, label):
        """ Extract a label. """
        if label is None:
            return None
        x = int(label.get('x'))
        y = int(label.get('y'))
        text = label.get('text')
        font_size = label.get('font_size')
        font_family = label.get('font_family')
        align = label.get('align')
        baseline = label.get('baseline')
        rotation = float(label.get('rotation'))
        parsed_label = Label(x, y, text, font_size, font_family, align, baseline, rotation)
        parsed_label.styles = label.get('styles') or {}
        return parsed_label

    def parse_shape(self, shape):
        """ Extract a shape. """
        # pylint: disable=R0914
        # pylint: disable=R0911

        rotation = shape.get('rotation', 0.0)
        flip_horizontal = shape.get('flip_horizontal', False)

        shape_type = shape.get('type')
        if 'rectangle' == shape_type:
            x = int(shape.get('x'))
            y = int(shape.get('y'))
            height = int(shape.get('height'))
            width = int(shape.get('width'))
            parsed_shape = Rectangle(x, y, width, height)
        elif 'rounded_rectangle' == shape_type:
            x = int(shape.get('x'))
            y = int(shape.get('y'))
            height = int(shape.get('height'))
            width = int(shape.get('width'))
            radius = int(shape.get('radius'))
            parsed_shape = RoundedRectangle(x, y, width, height, radius)
        elif 'arc' == shape_type:
            x = int(shape.get('x'))
            y = int(shape.get('y'))
            start_angle = float(shape.get('start_angle'))
            end_angle = float(shape.get('end_angle'))
            radius = int(shape.get('radius'))
            parsed_shape = Arc(x, y, start_angle, end_angle, radius)
        elif 'circle' == shape_type:
            x = int(shape.get('x'))
            y = int(shape.get('y'))
            radius = int(shape.get('radius'))
            parsed_shape = Circle(x, y, radius)
        elif 'label' == shape_type:
            parsed_shape = self.parse_label(shape)
        elif 'line' == shape_type:
            p1 = self.parse_point(shape.get('p1'))
            p2 = self.parse_point(shape.get('p2'))
            parsed_shape = Line(p1, p2)
        elif 'polygon' == shape_type:
            parsed_shape = Polygon()
            for point in shape.get('points'):
                parsed_shape.add_point(self.parse_point(point))
        elif 'bezier' == shape_type:
            control1 = self.parse_point(shape.get('control1'))
            control2 = self.parse_point(shape.get('control2'))
            p1 = self.parse_point(shape.get('p1'))
            p2 = self.parse_point(shape.get('p2'))
            parsed_shape = BezierCurve(control1, control2, p1, p2)
        elif 'rounded_segment' == shape_type:
            p1 = self.parse_point(shape.get('p1'))
            p2 = self.parse_point(shape.get('p2'))
            width = int(shape.get('width'))
            parsed_shape = RoundedSegment(p1, p2, width)

        parsed_shape.rotation = rotation
        parsed_shape.flip_horizontal = flip_horizontal

        parsed_shape.styles = shape.get('styles') or {}
        parsed_shape.attributes = shape.get('attributes') or {}
        return parsed_shape

    def parse_design_attributes(self, design_attributes):
        """ Extract design attributes. """
        attrs = DesignAttributes()
        # Get the Annotations
        for annotation in design_attributes.get('annotations'):
            anno = self.parse_annotation(annotation)
            attrs.add_annotation(anno)

        # Get the Attributes
        for key, value in design_attributes.get('attributes').items():
            attrs.add_attribute(key, value)

        # Get the Metadata
        meta = self.parse_metadata(design_attributes.get('metadata'))
        attrs.set_metadata(meta)
        self.design.set_design_attributes(attrs)


    def parse_metadata(self, metadata):
        """ Extract design meta-data. """
        meta = Metadata()
        meta.set_name(metadata.get('name'))
        meta.set_license(metadata.get('license'))
        meta.set_owner(metadata.get('owner'))
        meta.set_updated_timestamp(metadata.get('updated_timestamp'))
        meta.set_design_id(metadata.get('design_id'))
        meta.set_description(metadata.get('description'))
        meta.set_slug(metadata.get('slug'))
        for attached_url in metadata.get('attached_urls'):
            meta.add_attached_url(attached_url)
        return meta


    def parse_nets(self, nets):
        """ Extract nets. """
        for net in nets:
            net_id = net.get('net_id')
            ret_net = Net(net_id)
            # Add Annotations
            for annotation in net.get('annotations'):
                anno = self.parse_annotation(annotation)
                ret_net.add_annotation(anno)
            # Get the Attributes
            for key, value in net.get('attributes').items():
                ret_net.add_attribute(key, value)
            # Get the Points
            for net_point in net.get('points'):
                npnt = self.parse_net_point(net_point)
                ret_net.add_point(npnt)
            self.design.add_net(ret_net)


    def parse_net_point(self, net_point):
        """ Extract a net point. """
        point_id = net_point.get('point_id')
        x = int(net_point.get('x'))
        y = int(net_point.get('y'))
        npnt = NetPoint(point_id, x, y)
        # Get the connected points
        for point in net_point.get('connected_points'):
            npnt.add_connected_point(point)
        # Get the ConnectedComponents
        for connectedcomponent in net_point.get('connected_components'):
            conn_comp = self.parse_connected_component(connectedcomponent)
            npnt.add_connected_component(conn_comp)
        return npnt


    def parse_connected_component(self, connectedcomponent):
        """ Extract a connected component. """
        instance_id = connectedcomponent.get('instance_id')
        pin_number = connectedcomponent.get('pin_number')
        return ConnectedComponent(instance_id, pin_number)


########NEW FILE########
__FILENAME__ = specctra
#!/usr/bin/env python2
""" The Specctra DSN Format Parser """

# upconvert - A universal hardware design file format converter using
# Format: upverter.com/resources/open-json-format/
# Development: github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# TODO: !!! The following is incorrect, need to fix !!!
# Pads can have different shapes in DSN format (padstack), JSON format
# supports only lines. So make all pad shapes part of the component
# both in DSN->UPV and UPV->DSN directions.
#

from upconvert.core.design import Design
from upconvert.core.components import Component, Footprint, FBody, Pad
from upconvert.core.component_instance import ComponentInstance, FootprintAttribute
from upconvert.core.net import Net, NetPoint, ConnectedComponent
from upconvert.core.trace import Trace
from upconvert.core.shape import Circle, Line, Rectangle, Polygon, Point, Arc

from string import whitespace
from sys import maxint

from upconvert.parser import specctraobj 
import math

class Specctra(object):
    """ The Specctra DSN Format Parser """
    def __init__(self):
        self.design = None
        self.resolution = None
        self.nets = {}
        self.net_points = {}
        self._id = 10
        self.min_x = maxint
        self.max_x = -(maxint - 1)
        self.min_y = maxint
        self.max_y = -(maxint - 1)

    @staticmethod
    def auto_detect(filename):
        """ Return our confidence that the given file is an specctra schematic """
        with open(filename, 'r') as f:
            data = f.read(4096)
        confidence = 0
        if '(pcb ' in data or '(PCB ' in data:
            confidence += 0.75
        return confidence

    def parse(self, filename):
        """ Parse a specctra file into a design """

        self.design = Design()

        with open(filename) as f:
            data = f.read()

        tree = DsnParser().parse(data)

        struct = self.walk(tree)
        self.resolution = struct.resolution
        self._convert(struct)

        return self.design

    def _convert(self, struct):
        for bound in struct.structure.boundary:
            if bound.rectangle.layer_id == 'pcb':
                vertex1, vertex2 = bound.rectangle.vertex1, bound.rectangle.vertex2
                self.min_x = self.to_pixels(min(vertex1[0], vertex2[0]))
                self.max_x = self.to_pixels(max(vertex1[0], vertex2[0]))
                self.min_y = self.to_pixels(min(vertex1[1], vertex2[1]))
                self.max_y = self.to_pixels(max(vertex1[1], vertex2[1]))
                break

        self._convert_library(struct)
        self._convert_components(struct)
        self._convert_nets(struct)

    def _convert_library(self, struct):
        """ Convert library """
        for image in struct.library.image:
            component = Component(image.image_id)
            self.design.add_component(image.image_id, component)
            fpt = Footprint()
            body = FBody()
            component.add_footprint(fpt)
            fpt.add_body(body)
            for pad in image.pin:
                body.add_pad(Pad(pad.pad_id, self.to_pixels(pad.vertex), self.to_pixels(pad.vertex)))
                for padstack in struct.library.padstack:
                    if padstack.padstack_id == pad.padstack_id:
                        shapes = [shape.shape for shape in padstack.shape]
                        for shape in self._convert_shapes(shapes, self.to_pixels(pad.vertex)):
                            body.add_shape(shape)
                        break

            for outline in image.outline:
                for shape in self._convert_shapes([outline.shape]):
                    body.add_shape(shape)

    def _convert_components(self, struct):
        """ Convert component """
        for component in struct.placement.component:
            library_id = component.image_id
            for place in component.place:
                # Outside PCB boundary
                if not place.vertex:
                    continue

                mirror = {90:270, 270:90}
                if place.side == 'back':
                    rotation = place.rotation
                else:
                    rotation = mirror.get(int(place.rotation), place.rotation)
                inst = ComponentInstance(place.component_id, component, library_id, 0)
                v = self.to_pixels(place.vertex)
                symbattr = FootprintAttribute(v[0], v[1], to_piradians(rotation), False)
                inst.add_symbol_attribute(symbattr) 
                self.design.add_component_instance(inst)

    def _get_point(self, net_id, point_id, x, y):
        if net_id not in self.nets:
            n = Net(net_id)
            self.design.add_net(n)
            self.nets[n.net_id] = n
        else:
            n = self.nets[net_id]

        key = (x, y)
        if key not in self.net_points:
            if not point_id:
                point_id = str(self._id)
                self._id += 1
            np = NetPoint(net_id + '-' + point_id, x, y)
            n.add_point(np)
            self.net_points[key] = np
        else:
            np = self.net_points[key]

        return np
 
    def _convert_wires(self, struct):
        if struct.wiring:
            for wire in struct.wiring.wire:
                lines = self._convert_shapes([wire.shape], absolute=True)
                for line in lines:
                    try:
                        np1 = self._get_point(wire.net.net_id, None, line.p1.x, line.p1.y)
                        np2 = self._get_point(wire.net.net_id, None, line.p2.x, line.p2.y)

                        np1.add_connected_point(np2.point_id)
                        np2.add_connected_point(np1.point_id)
                    except: 
                        pass

    def _convert_nets(self, struct):
        """ Convert nets """
        # FIXME polyline_path is not documented and no success with reverse engineering yet
        self._convert_wires(struct)

        if struct.network:
            for net in struct.network.net:
                if net.pins is None:
                    continue

                prev_point = None
                for pin_ref in net.pins.pin_reference:
                    # pin_ref like A1-"-" is valid (parsed to A1--)
                    component_id, pin_id = pin_ref[:pin_ref.index('-')], pin_ref[pin_ref.index('-') + 1:]  
                    point = self.get_component_pin(component_id, pin_id)
                    if point is None:
                        print 'Could not find net %s pin ref %s' % (net.net_id, pin_ref)
                        continue
                    cc = ConnectedComponent(component_id, pin_id)
                    np = self._get_point(net.net_id, pin_ref, point[0], point[1])
                    np.add_connected_component(cc)

                    if prev_point is not None:
                        # XXX if point is already connected assume wiring had routed network, don't do it here
                        if len(prev_point.connected_points) == 0:
                            prev_point.add_connected_point(np.point_id)
                        if len(np.connected_points) == 0:
                            np.add_connected_point(prev_point.point_id)
                    prev_point = np

    def get_component_pin(self, component_id, pin_id):
        for component_instance in self.design.component_instances:
            symbattr = component_instance.symbol_attributes[0]
            if component_instance.instance_id == component_id: 
                component = self.design.components.components[component_instance.library_id]
                for pin in component.symbols[0].bodies[0].pins:
                    if pin.pin_number == pin_id:
                        x, y = rotate((pin.p1.x, pin.p1.y), symbattr.rotation)
                        return (symbattr.x + x, symbattr.y + y)

    def _make_line(self, p1, p2, aperture):
        x1, y1 = float(p1[0]), float(p1[1])
        x2, y2 = float(p2[0]), float(p2[1])
        aperture = float(aperture)

        dx = x2 - x1
        dy = y2 - y1
        length = math.sqrt(dx * dx + dy * dy)

        if length == 0.0:
            return []
        result = []

        line1 = Line(
                (x1 - aperture * (y2 - y1) / length,
                y1 - aperture * (x1 - x2) / length),
                (x2 - aperture * (y2 - y1) / length,
                y2 - aperture * (x1 - x2) / length)
            )
        line2 = Line(
                (x1 + aperture * (y2 - y1) / length,
                y1 + aperture * (x1 - x2) / length),
                (x2 + aperture * (y2 - y1) / length,
                y2 + aperture * (x1 - x2) / length)
            )
        result.append(line1)
        result.append(line2)

        def make_arc(p1, p2, p0):
            start_angle = math.atan2(p1.y - p0.y, p1.x - p0.x) / math.pi
            end_angle = math.atan2(p2.y - p0.y, p2.x - p0.x) / math.pi
            return Arc(p0.x, p0.y, start_angle, end_angle, aperture)

        result.append(make_arc(line1.p1, line2.p1, Point(p1)))
        result.append(make_arc(line2.p2, line1.p2, Point(p2)))
        return result
   
    def _convert_path(self, aperture, points):
        """ Convert path """
        result = []
        prev = points[0]
        for point in points[1:]:
            line = self._make_line(prev, point, float(aperture) / 2.0)
            result.extend(line)
            prev = point
        return result

    def _convert_shapes(self, shapes, center = (0, 0), absolute=False):
        """ Convert shapes """
        result = []

        def fix_point(point):
            x, y = (point[0] + center[0], point[1] + center[1])
            if absolute:
                # freerouter often creates points outside boundary, fix it
                if x > self.max_x:
                    x = self.min_x + x - self.max_x
                elif x < self.min_x:
                    x = self.max_x - x - self.min_x
                if y > self.max_y:
                    y = self.min_y + y - self.max_y
                elif y < self.min_y:
                    y = self.max_y - y - self.min_y

            return (x, y)


        for shape in shapes:
            if isinstance(shape, specctraobj.PolylinePath):
                points = [fix_point(self.to_pixels(point)) for point in shape.vertex]
                result.extend(self._convert_path(self.to_pixels(shape.aperture_width), points))

            elif isinstance(shape, specctraobj.Path):
                points = [fix_point(self.to_pixels(point)) for point in shape.vertex]
                # Path has connected start and end points
                if points[0] != points[-1] and len(points) != 2:
                    points.append(points[0])
                result.extend(self._convert_path(self.to_pixels(shape.aperture_width), points))

            elif isinstance(shape, specctraobj.Polygon):
                points = [fix_point(self.to_pixels(point)) for point in shape.vertex]
                points = [Point(point[0], point[1]) for point in points]
                result.append(Polygon(points))

            elif isinstance(shape, specctraobj.Rectangle):
                x1, y1 = self.to_pixels(shape.vertex1)
                x2, y2 = self.to_pixels(shape.vertex2)
                width, height = abs(x1 - x2), abs(y1 - y2)
                x1, y1 = fix_point((min(x1, x2), max(y1, y2)))

                result.append(Rectangle(x1, y1, width, height))
            elif isinstance(shape, specctraobj.Circle):
                point = fix_point(self.to_pixels(shape.vertex))
                result.append(Circle(point[0], point[1], self.to_pixels(shape.diameter / 2.0)))
        return result

    def to_pixels(self, vertex):
        return self.resolution.to_pixels(vertex)

    def walk(self, elem):
        if isinstance(elem, list) and len(elem) > 0:
            elemx = [self.walk(x) for x in elem]
            func = specctraobj.lookup(elemx[0])
            if func:
                f = func()
                f.parse(elemx[1:])
                return f
            else:
#print 'Unhandled element', elemx[0]
                return elemx
        else:
            return elem

def to_piradians(degrees):
    # looks like specctra and upverter rotate in different directions
    return float(degrees) / 180.0

def rotate(point, piradians):
    """ Rotate point around (0, 0) """
    x, y = float(point[0]), float(point[1])
    # Somehow this must rotate in opposite direction than shape, why?
    radians = float(-piradians) * math.pi
    new_x = int(round(x * math.cos(radians) - y * math.sin(radians)))
    new_y = int(round(x * math.sin(radians) + y * math.cos(radians)))
    return (new_x, new_y)

class DsnParser:
    """ Parser for Specctra dialect of lisp """

    # Specctra parser configuration: Disables parentheses as delimiters for text strings.
    string_quote = ''
    # Specctra parser configuration: By default, blank spaces are an absolute delimiter. 
    space_in_quoted_tokens = False

    seperators = whitespace + '()'

    def __init__(self):
        self.pos = 0
        self.length = 0
        self.exp = ''

    def parse(self, exp):
        """ Parses s-expressions and returns them as Python lists """
        self.pos = 0
        self.length = len(exp)
        self.exp = exp
        return self._parse_exp(root=True)[0]

    def _maybe_eval(self, lst):
        """ File format specifies string quoting character:
        this eval configures parser so it can distinguish between
        quote character as atom and quoted string """

        if len(lst) > 1:
            if lst[0] == 'string_quote':
                self.string_quote = lst[1]
            elif lst[0] == 'space_in_quoted_tokens':
                self.space_in_quoted_tokens = lst[1].lower() == 'on'
        return lst

    def _parse_exp(self, root=False):
        """ Parses s-expressions and returns them as Python lists """

        lst = []
        buf = ''

        while self.pos < self.length:
            ch = self.exp[self.pos]
            self.pos += 1

            if ch not in self.seperators and ch != self.string_quote:
                buf += ch
            else:
                if buf and ch != self.string_quote:
                    lst.append(buf)
                    buf = ''

                if ch == '(':
                    lst.append(self._maybe_eval(self._parse_exp()))
                elif ch == ')':
                    return lst
                elif ch == self.string_quote:
                    buf += self._parse_string()

        if not root:
            raise SyntaxError('Closing ) not found')
        return lst

    def _parse_string(self):
        """ Reads string from expression according to current parser configuration """

        buf = ''

        while self.pos < self.length:
            ch = self.exp[self.pos]
            self.pos += 1

            if ch == self.string_quote:
                return buf
            elif ch in whitespace and not self.space_in_quoted_tokens:
                self.pos -= 1
                return buf
            else:
                buf += ch

        raise SyntaxError('Closing string quote %s not found' % (self.string_quote))

########NEW FILE########
__FILENAME__ = specctraobj
#!/usr/bin/env python2
""" Specctra DSN objects """

# upconvert - A universal hardware design file format converter using
# Format: upverter.com/resources/open-json-format/
# Development: github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Specification of file format can be found here:
# http://tech.groups.yahoo.com/group/kicad-users/files/ file "specctra.pdf"

# For writing compose() method always assumes parser configuration:
# (parser
#    (string_quote ")
#    (space_in_quoted_tokens on)
# )

from inspect import isclass

def pop_type(args, ptype):
    """ Reads argument of type from args """
    if len(args) > 0 and isinstance(args[0], ptype):
        return args.pop(0)
    return None

def pop_types(args, ptype):
    """ Reads list of types from args """
    lst = []
    while True:
        arg = pop_type(args, ptype)
        if arg is None: 
            break
        lst.append(arg)
    return lst

def pop_string(args):
    """ Reads string from args """
    return pop_type(args, basestring)

def pop_strings(args):
    """ Reads list of strings from args """
    lst = []
    while True:
        arg = pop_string(args)
        if arg is None: 
            break
        lst.append(arg)
    return lst

def pop_vertex(args):
    """ Reads vertex (2 ints) from args """
    x, y = pop_string(args), pop_string(args)
    if x is None or y is None:
        return None
    return (float(x), float(y))

def pop_vertexes(args):
    """ Reads array of vertexes from args """
    lst = []
    while True:
        arg = pop_vertex(args)
        if arg is None: 
            break
        lst.append(arg)
    return lst

def pop_listtype(args, fname, ptype):
    """ Reads argument of type from args """
    if len(args) > 0 and isinstance(args[0], list):
        if args[0][0] == fname:
            p = ptype()
            p.parse(args.pop(0)[1:])
            return p
    return None

def pop_listtypes(args, fname, ptype):
    """ Reads list of types from args """
    lst = []
    while True:
        arg = pop_listtype(args, fname, ptype)
        if arg is None: 
            break
        lst.append(arg)
    return lst

def assert_empty(obj, args):
    """ Assert if args is empty """
    if len(args) > 0:
        print obj, len(args), args
    assert len(args) == 0

class ShapeBase(object):
    """ Base class for all shapes so we can pop a shape from args """

class Shape:
    """ shape """
    function = 'shape'

    def __init__(self):
        self.shape = None

    def parse(self, args):
        """ parse a shape """
        assert len(args) >= 0
        self.shape = pop_type(args, ShapeBase)
        #assert_empty(self, args)

    def compose(self):
        """ compose a shape """
        return [
            self.function,
            self.shape and self.shape.compose()
        ]

class Ancestor:
    """ ancestor_file_descriptor """
    function = 'ancestor'

    def __init__(self):
        self.file_path_name = None
        self.created_time = None
        self.comment = None

    def parse(self, args):
        """ parse an ancestor """
        assert len(args) in (2, 3)
        assert args[1][0] == 'created_time'

        self.file_path_name = args[0]
        self.created_time = args[1][1]

        if len(args) == 3:
            assert args[2][0] == 'comment'
            self.comment = args[2][1]

class Attach:
    """ attach_descriptor """
    function = 'attach'

    def __init__(self):
        self.attach = None
        self.use_via = None

    def parse(self, args):
        """ parse an attach """
        assert len(args) in (1, 2)
        assert args[0] in ('off', 'on')

        self.attach = args[0]
        if len(args) == 2:
            assert args[1][0] == 'use_via'
            self.use_via = args[1][1]

class Bond:
    """ bond_shape_descriptor """
    function = 'bond'
    
    def __init__(self):
        self.pin_reference = None
        self.padstack_id = None
        self.vertex = None
        self.signal_back = None
        self.bond_shape_rotation = None

    def parse(self, args):
        """ parse a bond """
        assert len(args) == 6
        assert args[4] in ('signal', 'back')

        self.pin_reference = args[0]
        self.padstack_id = args[1]
        self.vertex = (int(args[2]), int(args[3]))
        self.signal_back = args[4]
        self.bond_shape_rotation = args[5]

class Boundary:
    """ boundary_descriptor """
    function = 'boundary'

    def __init__(self):
        self.rectangle = None

    def parse(self, args):
        """ parse a boundry """
        self.rectangle = pop_type(args, Rectangle)

    def compose(self):
        """ compose a boundry """
        return [self.function, self.rectangle and self.rectangle.compose()]

class Bundle:
    """ bundle_descriptor """
    function = 'bundle'

    def __init__(self):
        self.bundle_id = None
        self.nets = None
        self.gap = []

    class Gap:
        """ A Gap """
        function = 'gap'

        def __init__(self):
            self.gap = None
            self.layer = []

        def parse(self, args):
            """ parse a gap """
            assert len(args) >= 1
            self.gap = int(args[0])
            for arg in args[1:]:
                assert arg[0] == 'layer'
                # FIXME
                self.layer = arg[1:]

    def parse(self, args):
        """ parse a bundle """
        assert len(args) >= 2
        assert args[1][0] == 'nets'

        self.bundle_id = args[0]
        self.nets = args[1][1:]
        for arg in args[2:]:
            assert arg[0] == 'gap'
            self.gap.append(Bundle.Gap(arg[1:]))

class CapacitanceResolution:
    """ capacitance_resolution_descriptor """
    function = 'capacitance_resolution'

    def __init__(self):
        self.farad = None
        self.value = None

    def parse(self, args):
        """ parse a capres """
        assert len(args) == 2
        assert args[0] in ('farad', 'mfarad', 'ufarad', 'nfarad', 'pfarad', 'ffarad')

        self.farad = args[0]
        self.value = int(args[1])

class CheckingTrim:
    """ checking_trim_descriptor """
    function = 'checking_trim_by_pin'

    def __init__(self):
        self.checking_trim_by_pin = None

    def parse(self, args):
        """ parse a trim """
        assert len(args) == 1
        self.checking_trim_by_pin = pop_string(args)
        assert self.checking_trim_by_pin in ('on', 'off')
        assert_empty(self, args)

class Circle(ShapeBase):
    """ circle_descriptor """
    function = 'circle'

    def __init__(self):
        self.layer_id = 'signal'
        self.diameter = None
        self.vertex = (0, 0)

    def parse(self, args):
        """ parse a circle """
        assert len(args) in (2, 4)
        self.layer_id = args[0]
        self.diameter = float(args[1])
        if len(args) == 4:
            self.vertex = (float(args[2]), float(args[3]))
        else:
            self.vertex = (0, 0)

    def compose(self):
        """ componse a circle """
        return [
            self.function,
            self.layer_id,
            self.diameter,
            self.vertex[0], self.vertex[1]
        ]

class QArc(ShapeBase):
    """ quarc_descriptor """
    function = 'qarc'

    def __init__(self):
        self.layer_id = 'signal'
        self.aperture_width = 0
        self.vertex1 = (0, 0)
        self.vertex2 = (0, 0)
        self.vertex3 = (0, 0)

    def parse(self, args):
        """ parse a QArc """
        assert len(args) == 5
        self.layer_id = pop_string(args)
        self.aperture_width = pop_string(args)
        self.vertex1 = pop_vertex(args)
        self.vertex2 = pop_vertex(args)
        self.vertex3 = pop_vertex(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a QArc """
        return [
            self.function,
            self.layer_id,
            self.aperture_width,
            self.vertex1[0], self.vertex1[1],
            self.vertex2[0], self.vertex2[1],
            self.vertex3[0], self.vertex3[1],
        ]

class Polygon(ShapeBase):
    """ polygon_descriptor """
    function = 'polygon'

    def __init__(self):
        self.layer_id = 'signal'
        self.aperture_width = 0
        self.vertex = []

    def parse(self, args):
        """ parse a polygon """
        assert len(args) > 3
        self.layer_id = pop_string(args)
        self.aperture_width = pop_type(args, basestring)
        self.vertex = pop_vertexes(args)
        assert_empty(self, args) 

    def compose(self):
        """ compose a polygon """
        result = [
            self.function,
            self.layer_id,
            self.aperture_width,
            ]
        for v in self.vertex:
            result.extend(v)
        return result

class Circuit:
    """ circuit_descriptor """

    def __init__(self):
        self.circuit = None
    
    def parse(self, args):
        """ parse a circuit """
        self.circuit = args

class PlaceControl:
    """ place_control_descriptor """
    function = 'place_control'

    def parse(self, args):
        """ parse a control """
        assert len(args) == 1
        self.flip_style = pop_type(args, FlipStyle)
        assert_empty(self, args)

class FlipStyle:
    """ flip_style_descriptor """
    function = 'flip_style'

    def parse(self, args):
        """ parse a flip """
        assert len(args) == 1
        self.first = pop_string(args)
        assert_empty(self, args)

##############################################################

class Placement:
    """ placement_descriptor """    
    function = 'placement'

    def __init__(self):
        self.place_control = None
        self.component = []

    def parse(self, args):
        """ parse a placement """
        assert len(args) >= 1
        self.place_control = pop_type(args, PlaceControl)
        self.component = pop_types(args, Component)
        assert_empty(self, args)

    def compose(self):
        """ compose a placement """
        return [
            self.function,
            self.place_control and self.place_control.compose(),
        ] + [x.compose() for x in self.component]

class Component:
    """ component_instance """
    function = 'component'

    def __init__(self):
        self.image_id = None
        self.place = None


    def parse(self, args):
        """ parse a component """
        assert len(args) >= 2
        self.image_id = pop_string(args)
        self.place = pop_types(args, Place)
        assert_empty(self, args)

    def compose(self):
        """ compose a component """
        return [
            self.function,
            self.image_id,
            self.place and self.place.compose()
        ]

class Place:
    """ placement_reference """
    function = 'place'

    def __init__(self):
        self.component_id = None
        self.vertex = (None, None)
        self.side = 'front'
        self.rotation = 0
        self.part_number = None

    def parse(self, args):
        """ parse a place """
        assert len(args) >= 1
        self.component_id = pop_string(args)
        self.vertex = pop_vertex(args)
        self.side = pop_string(args)
        self.rotation = int(pop_string(args))
        self.part_number = pop_type(args, PartNumber)
        #  FIXME
        #assert_empty(self, args)

    def compose(self):
        """ compose a place """
        return [
            self.function,
            self.component_id,
            self.vertex[0], self.vertex[1],
            self.side,
            self.rotation,
            self.part_number and self.part_number.compose()
        ]

class PartNumber:
    """ part_number """
    function = 'PN'

    def __init__(self):
        self.part_number = None

    def parse(self, args):
        """ parse a part number """
        assert len(args) == 1
        self.part_number = pop_string(args)
        assert_empty(self, args)

class Net:
    """ net_descriptor """
    function = 'net'

    def __init__(self):
        self.net_id = None
        self.no_idea_what = None
        self.pins = []

    def parse(self, args):
        """ parse a net """
        assert len(args) >= 1
        self.net_id = pop_string(args)
        self.no_idea_what = pop_string(args)
        self.pins = pop_type(args, Pins)
        assert_empty(self, args)

    def compose(self):
        """ compose a net """
        return [self.function, self.net_id] + [x.compose() for x in self.pins]

class Network:
    """ network_descriptor """
    function = 'network'

    def __init__(self):
        self.net = []

    def parse(self, args):
        """ parse a network """
        self.net = pop_types(args, Net)
        #assert_empty(self, args)
        # (via ...

    def compose(self):
        """ compose a network """
        return [self.function] + [x.compose() for x in self.net]

class Pins:
    """ pins """
    function = 'pins'

    def __init__(self):
        self.pin_reference = []

    def parse(self, args):
        """ parse a pin """
        assert len(args) >= 0
        self.pin_reference = pop_strings(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a pin """
        return [self.function] + self.pin_reference

class Library:
    """ library_descriptor """
    function = 'library'

    def __init__(self):
        self.image = []
        self.padstack = []

    def parse(self, args):
        """ parse a library """
        self.image = pop_types(args, Image)
        self.padstack = pop_types(args, Padstack)
        assert_empty(self, args)

    def compose(self):
        """ compose a library """
        return [
            self.function,
        ] + [x.compose() for x in self.image] + [x.compose() for x in self.padstack]

class Padstack:
    """ padstack_descriptor """
    function = 'padstack'

    def __init__(self):
        self.padstack_id = None
        self.shape = []
        self.attach = None
    
    def parse(self, args):
        """ parse a padstack """
        assert len(args) >= 1
        self.padstack_id = pop_string(args)
        self.shape = pop_types(args, Shape)
        self.attach = pop_type(args, Attach)
#assert_empty(self, args)

    def compose(self):
        """ compose a padstack """
        return [
            self.function,
            self.padstack_id,
        ] + [x.compose() for x in self.shape] + [
            self.attach and self.attach.compose()
        ]

class Pin:
    """ pin """
    function = 'pin'

    def __init__(self):
        self.padstack_id = None
        self.rotation = None
        self.pin_id = None
        self.vertex = (None, None)

    def parse(self, args):
        """ parse a pin """
        assert len(args) >= 1

        self.padstack_id = pop_string(args)
        self.rotation = pop_type(args, Rotate)
        self.pin_id = pop_string(args)
        self.vertex = pop_vertex(args)
        #self.array = pop_type(args, Array)
        #self.property = pop_type(args, Property)

    def compose(self):
        """ compose a pin """
        return [
            self.function,
            self.padstack_id,
            self.rotation and self.rotation.compose(),
            self.pin_id,
            self.vertex[0], self.vertex[1],
        ]

class Rotate:
    """ rotate """
    function = 'rotate'

    def __init__(self):
        self.rotation = None

    def parse(self, args):
        """ parse a rotation """
        assert len(args) == 1
        self.rotation = pop_string(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a rotation """
        return [
            self.function,
            self.rotation
        ]

class Image:
    """ image_descriptor """
    function = 'image'

    def __init__(self):
        self.image_id = None
        self.side = None
        self.outline = []
        self.pin = []
        self.keepout = []

    def parse(self, args):
        """ parse an image """
        assert len(args) >= 1
        self.image_id = pop_string(args)
        self.side = pop_type(args, Side)
        self.outline = pop_types(args, Outline)
        self.pin = pop_types(args, Pin)
        self.keepout = pop_types(args, Keepout)
        if not self.outline:
            # XXX sometimes outline and pin come in mixed order
            self.outline = pop_types(args, Outline)
        assert_empty(self, args)

    def compose(self):
        """ compose an image """
        return [
            self.function,
            self.image_id,
            self.side and self.side.compose(),
        ] + [x.compose() for x in self.outline] \
          + [x.compose() for x in self.pin] \
          + [x.compose() for x in self.keepout]

class Keepout(object):
    """ Base class for all keepout_descriptors """
    function = 'keepout'

    def __init__(self):
        self.keepout_id = None
        self.shape = None
        self.junk = None

    def parse(self, args):
        """ parse a keepout """
        assert len(args) >= 1
        self.keepout_id = pop_string(args)
        self.shape = pop_types(args, ShapeBase)
        self.junk = pop_types(args, ClearanceClass)
        assert_empty(self, args)

    def compose(self):
        """ compose a keepout """
        return [
            self.function,
            self.keepout_id,
            self.shape and self.shape.compose(),
            self.junk and self.junk.compose()
        ]

class PlaceKeepout(Keepout):
    """ place_keepout """
    function = 'place_keepout'

class ViaKeepout(Keepout):
    """ via_keepout """
    function = 'via_keepout'

class ClearanceClass:
    """ Something undocumented: [['clearance_class', 'default']] """
    function = 'clearance_class'

    def __init__(self):
        self.value = None

    def parse(self, args):
        """ parse a clearance """
        assert len(args) == 1
        self.value = pop_string(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a clearance """
        return [
            self.function,
            self.value
        ]

class Side:
    """ side """
    function = 'side'

    def __init__(self):
        self.side = None

    def parse(self, args):
        """ parse a side """
        assert len(args) == 1
        self.side = pop_string(args)
        assert self.side in ('front', 'back', 'both')
        assert_empty(self, args)

    def compose(self):
        """ compose a side """
        return [
            self.function,
            self.side
        ]

class Outline:
    """ outline_descriptor """
    function = 'outline'

    def __init__(self):
        self.shape = None

    def parse(self, args):
        """ parse a outline """
        assert len(args) == 1
        self.shape = pop_type(args, ShapeBase)

    def compose(self):
        """ compose a outline """
        return [
            self.function,
            self.shape and self.shape.compose()
        ]

class Rectangle(ShapeBase):
    """ rectangle_descriptor """
    function = 'rect'

    def __init__(self):
        self.layer_id = 'signal'
        self.vertex1 = (None, None)
        self.vertex2 = (None, None)

    def parse(self, args):
        """ parse a rectangle """
        assert len(args) == 5
        self.layer_id = pop_string(args)
        self.vertex1 = pop_vertex(args)
        self.vertex2 = pop_vertex(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a rectangle """
        return [
            self.function,
            self.layer_id,
            self.vertex1[0], self.vertex1[1],
            self.vertex2[0], self.vertex2[1],
        ]

class Path(ShapeBase):
    """ path_descriptor """
    function = 'path'

    def __init__(self):
        self.layer_id = 'signal'
        self.aperture_width = 0
        self.vertex = []
        self.aperture_type = None

    def parse(self, args):
        """ parse a path """
        assert len(args) >= 2
        self.layer_id = pop_string(args)
        self.aperture_width = pop_string(args)
        self.vertex = pop_vertexes(args)
        self.aperture_type = pop_type(args, ApertureType)
        assert_empty(self, args)

    def compose(self):
        """ compose a path """
        result = [
            self.function,
            self.layer_id,
            self.aperture_width,
            ]
        for v in self.vertex:
            result.extend(v)
        result.append(self.aperture_type)
        return result

class PolylinePath(Path):
    """ Undocumented: seems to be the same as path except start & end are NOT connected """
    function = 'polyline_path'

class ApertureType:
    """ aperture_type """
    function = 'aperture_type'

    def __init__(self):
        self.aperture_type = None

    def parse(self, args):
        """ parse a aperture """
        assert len(args) == 1
        assert args[0] in ('round', 'square')

        self.aperture_type = args[0]

    def compose(self):
        """ compose a arpeture """
        return [
            self.function,
            self.aperture_type
        ]

class Pcb:
    """ pcb """
    function = 'pcb'

    def __init__(self):
        self.pcb_id = 'dummy'
        self.parser = Parser()
        self.resolution = None
        self.unit = None
        self.structure = None
        self.placement = None
        self.library = None
        self.network = None
        self.wiring = None
 
    def parse(self, args):
        """ parse a pcb """
        assert len(args) >= 1
        self.pcb_id = pop_string(args)
        self.parser = pop_type(args, Parser)
        self.resolution = pop_type(args, Resolution)
        self.unit = pop_type(args, Unit)
        self.structure = pop_type(args, Structure)
        self.placement = pop_type(args, Placement)
        self.library = pop_type(args, Library)
        self.network = pop_type(args, Network)
        self.wiring = pop_type(args, Wiring)
        assert_empty(self, args)

    def compose(self):
        """ compose a pcb """
        return [
            self.function,
            self.pcb_id,
            self.parser and self.parser.compose(),
            self.resolution and self.resolution.compose(),
            self.unit and self.unit.compose(),
            self.structure and self.structure.compose(),
            self.placement and self.placement.compose(),
            self.library and self.library.compose(),
            self.network and self.network.compose(),
            self.wiring and self.wiring.compose()
        ]

class PCB(Pcb):
    """ pcb """
    function = 'PCB'

class Parser:
    """ parser_descriptor """
    function = 'parser'

    def __init__(self):
        self.string_quote = StringQuote()
        self.space_in_quoted_tokens = SpaceInQuotedTokens()
        self.host_cad = None
        self.host_version = None

    def parse(self, args):
        """ parse a parser """
        self.string_quote = pop_type(args, StringQuote)
        self.space_in_quoted_tokens = pop_type(args, SpaceInQuotedTokens)
        self.host_cad = pop_type(args, HostCad)
        self.host_version = pop_type(args, HostVersion)
        #assert_empty(self, args)
        # (generated_by_freeroute)

    def compose(self):
        """ compose a parser """
        return [
            self.function,
            self.string_quote and self.string_quote.compose(),
            self.space_in_quoted_tokens and self.space_in_quoted_tokens.compose(),
            self.host_cad and self.host_cad.compose(),
            self.host_version and self.host_version.compose()
        ]

class StringQuote:
    function = 'string_quote'

    def __init__(self):
        self.value = '"'

    def parse(self, args):
        """ parse a string """
        assert len(args) == 1
        self.value = pop_string(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a string """
        return [self.function, self.value]

class SpaceInQuotedTokens:
    function = 'space_in_quoted_tokens'

    def __init__(self):
        self.value = 'on'

    def parse(self, args):
        """ parse a space """
        assert len(args) == 1
        self.value = pop_string(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a space """
        return [self.function, self.value]

class Structure:
    """ structure_descriptor """
    function = 'structure'

    def __init__(self):
        self.layer = []
        self.boundary = []

    def parse(self, args):
        """ parse a structure """
        self.layer = [x for x in args if isinstance(x, Layer)]
        self.boundary = [x for x in args if isinstance(x, Boundary)]

    def compose(self):
        """ compose a structure """
        return [
            self.function,
        ] + [x.compose() for x in self.layer] \
          + [x.compose() for x in self.boundary]

class Resolution:
    """ resolution_descriptor """
    function = 'resolution'

    def __init__(self):
        self.dpi = 96.0
        self.unit = None
        self.resolution = 0

    def parse(self, args):
        """ parse a resolution """
        assert len(args) == 2
        self.unit = pop_string(args)
        assert self.unit in ('inch', 'mil', 'cm', 'mm', 'um')
        self.resolution = int(pop_string(args))
        assert_empty(self, args)

    def compose(self):
        """ compose a resolution """
        return [
            self.function,
            self.unit,
            self.resolution
        ]

    def to_pixels(self, point):
        """ convert to pixels """
        if self.unit == 'inch':
            mult = self.dpi / 1.0
        elif self.unit == 'mil':
            mult = self.dpi / 1000.0
        elif self.unit == 'cm':
            mult = self.dpi / 2.54
        elif self.unit == 'mm':
            mult =  self.dpi / 2.54 / 10.0
        elif self.unit == 'um':
            mult =  self.dpi / 2.54 / 1000.0

        #mult *= 3
        if isinstance(point, tuple):
            return (int(round(float(point[0]) * mult)), int(round(float(point[1]) * mult)))
        return int(round(float(point) * mult))

    def from_pixels(self, point):
        """ convert from pixels """
        if self.unit == 'inch':
            mult = 1.0 / self.dpi
        elif self.unit == 'mil':
            mult = 1000.0 / self.dpi
        elif self.unit == 'cm':
            mult = 2.54 / self.dpi
        elif self.unit == 'mm':
            mult =  2.54 / 10.0 / self.dpi
        elif self.unit == 'um':
            mult =  2.54 / 1000.0 / self.dpi

        if isinstance(point, tuple):
            return (float(point[0]) * mult, float(point[1]) * mult)
        return float(point) * mult


class HostCad:
    """ host_cad """
    function = 'host_cad'

    def __init__(self):
        self.value = None

    def parse(self, args):
        """ parse a host """
        assert len(args) == 1
        self.value = pop_string(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a host """
        return [self.function, self.value]

class HostVersion:
    """ host_version """
    function = 'host_version'

    def __init__(self):
        self.value = None

    def parse(self, args):
        """ parse a version """
        assert len(args) == 1
        self.value = pop_string(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a version """
        return [self.function, self.value]

class Absolute:
    """ absolute """
    function = 'absolute'

    def __init__(self):
        self.value = None

    def parse(self, args):
        """ parse a abs """
        assert len(args) == 1
        self.value = pop_string(args)
        assert self.value in ('on', 'off')
        assert_empty(self, args)

    def compose(self):
        """ compose a abs """
        return [self.function, self.value]

class Unit:
    """ unit """
    function = 'unit'

    def __init__(self):
        self.value = None

    def parse(self, args):
        """ parse a unit """
        assert len(args) == 1
        self.value = pop_string(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a unit """
        return [self.function, self.value]

class Wiring:
    """ wiring_descriptor """
    function = 'wiring'

    def __init__(self):
        self.wire = []
        self.via = None

    def parse(self, args):
        """ parse a wiring """
        # Empty seems to be ok
        self.wire = pop_types(args, Wire)
        self.via = pop_listtypes(args, 'via', WireVia)
        self.wire.extend(pop_types(args, Wire))
        assert_empty(self, args)

    def compose(self):
        """ compose a wiring """
        return [
            self.function,
        ] + [x.compose() for x in self.wire] + [
            self.via and self.via.compose()
        ]

class Wire:
    """ wire_descriptor """
    function = 'wire'

    def __init__(self):
        self.shape = None
        self.net = None
        self.clearance = None
        self.wire_type = None

    def parse(self, args):
        """ parse a wire """
        assert len(args) >= 1
        self.shape = pop_type(args, ShapeBase)
        self.net = pop_type(args, Net)
        self.clearance = pop_type(args, ClearanceClass)
        self.wire_type = pop_type(args, Type)
        assert_empty(self, args)

    def compose(self):
        """ compose a wire """
        return [
            self.function,
            self.shape and self.shape.compose(),
            self.net and self.net.compose(),
            self.clearance and self.clearance.compose(),
            self.wire_type and self.wire_type.compose()
        ]

class Type:
    """ type for misc places """
    function = 'type'

    def __init__(self):
        self.value = None

    def parse(self, args):
        """ parse a type """
        assert len(args) == 1
        self.value = pop_string(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a type """
        return [self.function, self.value]

class Property:
    function = 'property'

    def __init__(self):
        self.index = None

    def parse(self, args):
        """ parse a property """
        assert len(args) >= 1
        self.index = pop_type(args, Index)
        assert_empty(self, args)

    def compose(self):
        """ compose a property """
        return [
            self.function,
            self.index and self.index.compose()
        ]

class Index:
    function = 'index'

    def __init__(self):
        self.value = None

    def parse(self, args):
        """ parse a index """
        assert len(args) == 1
        self.value = pop_string(args)
        assert_empty(self, args)

    def compose(self):
        """ compose a index """
        return [self.function, self.value]

class Layer:
    function = 'layer'

    def __init__(self):
        self.layer_id = 'signal'
        self.ltype = None
        self.lproperty = None

    def parse(self, args):
        """ parse a layer """
        assert len(args) >= 1
        self.layer_id = pop_string(args)
        self.ltype = pop_type(args, Type)
        self.lproperty = pop_type(args, Property)
        assert_empty(self, args)

    def compose(self):
        """ compose a layer """
        return [
            self.function,
            self.layer_id,
            self.ltype.compose(),
            self.lproperty and self.lproperty.compose(),
        ]


class WireVia:
    """ wire_via_descriptor """
    #function = 'via'

    def __init__(self):
        self.padstack_id = None
        self.vertex = (None, None)
        self.net = None
        self.via_type = None
        self.clearance = None

    def parse(self, args):
        """ parse a via """
        assert len(args) >= 1
        self.padstack_id = pop_string(args)
        self.vertex = pop_vertex(args)
        self.net = pop_type(args, Net)
        self.via_type = pop_type(args, Type)
        self.clearance = pop_type(args, ClearanceClass)
        assert_empty(self, args)

    def compose(self):
        """ compose a via """
        return [
            'via', 
            self.padstack_id,
            self.vertex[0], self.vertex[1],
            self.net and self.net.compose(),
            self.via_type and self.via_type.compose(),
            self.clearance.compose()
        ]

##############################################################

ALL_FUNCTIONS = dict([(s.function, s) for s in globals().values() if isclass(s) and getattr(s, 'function', None)])

def lookup(funcname):
    """ Return class for given function name """
    return ALL_FUNCTIONS.get(funcname, None)

########NEW FILE########
__FILENAME__ = altium_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The altium parser test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.parser.altium import Altium
import unittest


class AltiumTests(unittest.TestCase):
    """ The tests of the altium parser """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_altium_parser(self):
        """ Test creating an empty parser. """
        parser = Altium()
        assert parser != None

########NEW FILE########
__FILENAME__ = eaglexml_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The eaglexml parser test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from upconvert.parser.eaglexml import EagleXML
from upconvert.parser.eaglexml.generated_g import wire

import unittest

from functools import wraps
from os.path import dirname, join

TEST_DIR = join(dirname(__file__), '..', '..', '..', 'test', 'eaglexml')
EAGLE_SCALE = 10.0/9.0

_cache = {} # filename -> Design

def get_design(filename):
    if filename not in _cache:
        _cache[filename] = EagleXML().parse(join(TEST_DIR, filename))
    return _cache[filename]


def use_file(filename):
    """ Return a decorator which will parse an eaglexml file
    before running the test. """

    def decorator(test_method):
        """ Add params to decorator function. """

        @wraps(test_method)
        def wrapper(self):
            """ Parse file then run test. """
            self.design = get_design(filename)
            test_method(self)

        return wrapper

    return decorator


class EagleXMLTests(unittest.TestCase):
    """ The tests of the eagle-xml parser """

    def setUp(self):
        self.parser = EagleXML()


    def test_create_new_eaglexml_parser(self):
        """ Test creating an empty parser. """
        self.assertNotEqual(self.parser, None)


    def test_make_length(self):
        """ Lengths are converted correctly. """
        parser = EagleXML()
        self.assertEqual(parser.make_length("0"), 0)
        self.assertEqual(parser.make_length("254"), int(900 * 2.0))


    @use_file('E1AA60D5.sch')
    def test_library_components(self):
        """ A deviceset should have a matching component. """
        self.assertTrue('atmel:TINY15L:P'
                        in self.design.components.components)


    @use_file('E1AA60D5.sch')
    def test_component_symbols(self):
        """ A component should have 1 symbol. """
        self.assertEqual(
            len(self.get_component('atmel:TINY15L:P').symbols), 1)


    @use_file('D9CD1423.sch')
    def test_component_bodies(self):
        """ A deviceset with 2 gates should have 2 bodies. """
        cpt = self.get_component('Discrete:010-DUAL-N-MOSFET*:_1206-8')
        self.assertEqual(len(cpt.symbols[0].bodies), 2)


    @use_file('E1AA60D5.sch')
    def test_component_body_lines(self):
        """ The right component Lines are created on SBody objects. """
        cpt = self.get_component('atmel:TINY15L:P')
        lines = [s for s in cpt.symbols[0].bodies[0].shapes
                 if s.type == 'line']
        self.assertEqual(len(lines), 4)
        self.assertEqual(lines[0].p1.x / EAGLE_SCALE, self.make_length("12.7"))
        self.assertEqual(lines[0].p1.y / EAGLE_SCALE, self.make_length("-10.16"))
        self.assertEqual(lines[0].p2.x / EAGLE_SCALE, self.make_length("-12.7"))
        self.assertEqual(lines[0].p2.y / EAGLE_SCALE, self.make_length("-10.16"))


    @use_file('E1AA60D5.sch')
    def test_component_body_rectangles(self):
        """ The right component Rectangles are created on SBody objects. """
        cpt = self.get_component('resistor:CPOL-EU:E2.5-6')
        rects = [s for s in cpt.symbols[0].bodies[0].shapes
                 if s.type == 'rectangle']
        self.assertEqual(len(rects), 1)
        self.assertEqual(rects[0].x / EAGLE_SCALE, self.make_length("-1.651"))
        self.assertEqual(rects[0].y / EAGLE_SCALE, self.make_length("-1.651"))
        self.assertEqual(rects[0].width / EAGLE_SCALE,
                         self.make_length("1.651") - self.make_length("-1.651"))
        self.assertEqual(rects[0].height / EAGLE_SCALE,
                         self.make_length("-1.651") - self.make_length("-2.54"))


    @use_file('S12G_Micro_20EVB_RevA.sch')
    def test_component_body_rectangles_rot(self):
        """ The right rotations are applied to Rectangles on SBody objects. """

        cpt = self.get_component('myLibrary:L:0805')
        rect = [s for s in cpt.symbols[0].bodies[0].shapes
                if s.type == 'rectangle'][0]
        self.assertEqual(rect.x / EAGLE_SCALE, self.make_length("-3.556"))
        self.assertEqual(rect.y / EAGLE_SCALE, self.make_length("1.016"))
        self.assertEqual(rect.width / EAGLE_SCALE,
                         self.make_length("3.556") - self.make_length("-3.556"))
        self.assertEqual(rect.height / EAGLE_SCALE,
                         self.make_length("1.016") - self.make_length("-1.016"))


    @use_file('450B679C.sch')
    def test_component_body_polygons(self):
        """ The right component Rectangles are created on SBody objects. """

        cpt = self.get_component('adafruit:LED:5MM')
        polys = [s for s in cpt.symbols[0].bodies[0].shapes
                 if s.type == 'polygon']
        self.assertEqual(len(polys), 2)
        self.assertEqual(len(polys[0].points), 3)
        self.assertEqual(polys[0].points[0].x / EAGLE_SCALE, self.make_length("-3.429"))
        self.assertEqual(polys[0].points[0].y / EAGLE_SCALE, self.make_length("-2.159"))


    @use_file('D9CD1423.sch')
    def test_component_body_circles(self):
        """ The right component Circles are created on SBody objects. """

        cpt = self.get_component('CONNECTER:HEADER_1X10:DD')
        circs = [s for s in cpt.symbols[0].bodies[0].shapes
                 if s.type == 'circle']
        self.assertEqual(len(circs), 9)
        self.assertEqual(circs[0].x, self.make_length("0"))
        self.assertEqual(circs[0].y / EAGLE_SCALE, self.make_length("8.89"))
        self.assertEqual(circs[0].radius / EAGLE_SCALE, self.make_length("1.016"))
        self.assertEqual(circs[0].attributes['eaglexml_width'], "0.254")


    @use_file('E1AA60D5.sch')
    def test_component_body_labels(self):
        """ The right component Labels are created on SBody objects. """
        cpt = self.get_component('con-berg:PN87520:')
        labels = [s for s in cpt.symbols[0].bodies[0].shapes
                  if s.type == 'label']
        self.assertEqual(len(labels), 1)
        self.assertEqual(labels[0].x / EAGLE_SCALE, self.make_length("5.08"))
        self.assertEqual(labels[0].y / EAGLE_SCALE, self.make_length("-2.54"))
        self.assertEqual(labels[0].text, 'USB')
        self.assertEqual(labels[0]._rotation, 1.5)


    @use_file('msp430_f249_ctk.sch')
    def test_component_body_labels_mirrored(self):
        """ The right component Labels are created on SBody objects. """
        cpt = self.get_component('TI_MSP430_v16:F24[X/10]---PM64:')
        labels = [s for s in cpt.symbols[0].bodies[0].shapes
                  if s.type == 'label' and s.text == 'P4.6/TB6']
        self.assertEqual(len(labels), 1)
        self.assertEqual(labels[0].x / EAGLE_SCALE, self.make_length("36.83"))
        self.assertEqual(labels[0].y / EAGLE_SCALE, self.make_length("0.0"))
        self.assertEqual(labels[0]._rotation, 0.0)
        self.assertEqual(labels[0].align, 'right')


    @use_file('E1AA60D5.sch')
    def test_component_body_pins(self):
        """ The right component Pins are created on SBody objects. """
        cpt = self.get_component('atmel:TINY15L:P')
        pins = cpt.symbols[0].bodies[0].pins
        self.assertEqual(len(pins), 8)
        self.assertEqual(pins[0].p1.x / EAGLE_SCALE, 90)
        self.assertEqual(pins[0].p1.y / EAGLE_SCALE, 18)
        self.assertEqual(pins[0].p2.x / EAGLE_SCALE, self.make_length("17.78"))
        self.assertEqual(pins[0].p2.y / EAGLE_SCALE, self.make_length("2.54"))
        self.assertEqual(pins[0].label.text, '(ADC3)PB4')
        self.assertEqual(pins[0].label.x / EAGLE_SCALE, 85.0)
        self.assertEqual(pins[0].label.y / EAGLE_SCALE, 15.0)
        self.assertEqual(pins[0].label._rotation, 0.0)
        self.assertEqual([p.pin_number for p in pins],
                         ['2', '3', '1', '7', '6', '5', '8', '4'])
        self.assertEqual([p.label.text for p in pins],
                         ['(ADC3)PB4', '(ADC2)PB3', '(ADC0)PB5',
                          '(ADC1)PB2', '(OCP)PB1', '(AREF)PB0',
                          'VCC', 'GND'])
        cpt = self.get_component('diode:ZENER-DIODE:DO35Z10')
        pins = cpt.symbols[0].bodies[0].pins
        self.assertEqual(pins[0].label, None)
        self.assertEqual([p.pin_number for p in pins], ['A', 'C'])


    @use_file('Shock Controller.sch')
    def test_component_body_pin_duplicate_names(self):
        """ Duplicate pin names on different gates are de-duplicated
        with pin numbers. """

        cpt = self.get_component('con-molex:22-?-04:27-2041')
        pin_numbers = [p.pin_number for b in cpt.symbols[0].bodies for p in b.pins]
        self.assertEqual(pin_numbers, ['1', '2', '3', '4'])


    @use_file('E1AA60D5.sch')
    def test_component_instances(self):
        """ The right component instances are created. """
        self.assertEqual(
            set(ci.instance_id for ci in self.design.component_instances),
            set(('Q1', 'X2', 'C2', 'IC1', 'X1', 'R4', 'R1', 'R2', 'R3', 'GND3',
                 'GND2', 'GND1', 'GND7', 'GND6', 'GND5', 'GND4','C1', 'P+2',
                 'P+3', 'P+1', 'P+6', 'P+4','P+5', 'D2', 'D1')))


    @use_file('E1AA60D5.sch')
    def test_component_instance_rotation(self):
        """ Component instance rotation is correct. """
        inst = self.get_instance('GND3')
        self.assertEqual(inst.symbol_attributes[0].rotation, 0)
        inst = self.get_instance('R2')
        self.assertEqual(inst.symbol_attributes[0].rotation, 1.5)


    @use_file('E1AA60D5.sch')
    def test_component_instance_refdes(self):
        """ Component instance refdes is correct. """
        inst = self.get_instance('GND3')
        self.assertEqual(inst.get_attribute('refdes'), 'GND3')


    @use_file('E1AA60D5.sch')
    def test_component_instance_position(self):
        """ Component instance position is correct. """
        inst = self.get_instance('GND3')
        self.assertEqual(len(inst.symbol_attributes), 1)
        self.assertEqual(inst.symbol_attributes[0].x / EAGLE_SCALE, self.make_length("116.84"))
        self.assertEqual(inst.symbol_attributes[0].y / EAGLE_SCALE, self.make_length("55.88"))


    @use_file('E1AA60D5.sch')
    def test_component_instance_value(self):
        """ Component instance value is correct. """
        inst = self.get_instance('R2')
        self.assertEqual(inst.attributes['value'], '68')


    @use_file('E1AA60D5.sch')
    def test_component_instance_annotations(self):
        """ Component instance annotations are correct. """
        inst = self.get_instance('R2')
        anns = inst.symbol_attributes[0].annotations
        self.assertEqual(len(anns), 2)
        self.assertEqual(anns[0].value, 'R2')
        self.assertEqual(anns[0].x / EAGLE_SCALE, -27)
        self.assertEqual(anns[0].y / EAGLE_SCALE, 11)
        self.assertEqual(anns[1].value, '68')
        self.assertEqual(anns[1].x / EAGLE_SCALE, -27)
        self.assertEqual(anns[1].y / EAGLE_SCALE, -23)


    @use_file('WiFi.sch')
    def test_component_instance_annotations_case_insensitive(self):
        """ Component instance annotations are correct. """
        inst = self.get_instance('U$1')
        anns = inst.symbol_attributes[0].annotations
        self.assertEqual(len(anns), 1)
        self.assertEqual(anns[0].value, 'U$1')


    @use_file('pcb_switch_switch.sch')
    def test_component_instance_annotations_multi_gates(self):
        """ Component instance annotations with multiple gates are correct. """
        inst = self.get_instance('X1')
        values = []
        for attr in inst.symbol_attributes:
            for ann in attr.annotations:
                values.append(ann.value)
        self.assertEqual(set(values), set(['SW', 'X1-1', 'X1-2']))


    @use_file('E1AA60D5.sch')
    def test_nets(self):
        """ The right nets are created. """
        self.assertEqual(set(n.net_id for n in self.design.nets),
                         set(['VCC', 'GND', 'N$1', 'N$2', 'N$3',
                              'N$4', 'N$5', 'N$6', 'N$7']))


    @use_file('E1AA60D5.sch')
    def test_net_points(self):
        """ The right net points are created. """
        net = [n for n in self.design.nets if n.net_id == 'GND'][0]
        self.assertEqual(len(net.points), 13)
        self.assertTrue(self.make_point_name("40.64", "63.5") in net.points)


    @use_file('E1AA60D5.sch')
    def test_net_points_connected(self):
        """ The right net points are connected. """
        net = [n for n in self.design.nets if n.net_id == 'N$7'][0]
        pt = net.points[self.make_point_name("83.82", "68.58")]
        self.assertEqual(sorted(pt.connected_points),
                         [self.make_point_name("76.2", "68.58"),
                          self.make_point_name("83.82", "48.26")])


    @use_file('S12G_Micro_20EVB_RevA.sch')
    def test_net_points_connected_rot(self):
        """ The right net points are connected for a rotated part. """
        net = [n for n in self.design.nets if n.net_id == 'GND'][0]
        pt = net.points[self.make_point_name("0", "15.24")]
        self.assertEqual(sorted(pt.connected_points),
                         [self.make_point_name("0", "7.62")])


    @use_file('S12G_Micro_20EVB_RevA.sch')
    def test_net_points_connected_flip_rot(self):
        """ The right net points are connected for a flipped and rotated part. """
        net = [n for n in self.design.nets if n.net_id == 'PT1'][0]
        pt = net.points[self.make_point_name("162.56", "33.02")]
        self.assertEqual(sorted(pt.connected_points),
                         [self.make_point_name("162.56", "30.48")])


    @use_file('E1AA60D5.sch')
    def test_net_points_connected_components(self):
        """ The right net points are connected to the right components. """
        net = [n for n in self.design.nets if n.net_id == 'N$7'][0]
        pt = net.points[self.make_point_name("76.2", "68.58")]
        self.assertEqual(len(pt.connected_components), 1)
        self.assertEqual(pt.connected_components[0].instance_id, 'IC1')
        self.assertEqual(pt.connected_components[0].pin_number, '7')


    @use_file('D9CD1423.sch')
    def test_smashed_annotations(self):
        """ The right annotations are created for smashed components. """
        inst = self.get_instance('U1')
        symattr = inst.symbol_attributes[0]
        self.assertEqual(len(symattr.annotations), 2)
        self.assertEqual(symattr.annotations[0].value, 'U1')
        self.assertEqual(symattr.annotations[0].x / EAGLE_SCALE, self.parser.make_length("22.86"))
        self.assertEqual(symattr.annotations[0].y / EAGLE_SCALE, self.parser.make_length("52.07"))
        self.assertEqual(symattr.annotations[0].rotation, 0.0)
        self.assertEqual(symattr.annotations[1].value, 'ATMEGA328AU')
        self.assertEqual(symattr.annotations[1].x / EAGLE_SCALE, self.parser.make_length("22.86"))
        self.assertEqual(symattr.annotations[1].y / EAGLE_SCALE, self.parser.make_length("43.18"))
        self.assertEqual(symattr.annotations[1].rotation, 0.0)


    @use_file('msp430_f249_ctk.sch')
    def test_smashed_annotations_offset(self):
        """ The right annotations are created for smashed components. """
        inst = self.get_instance('SV3')
        symattr = inst.symbol_attributes[0]
        self.assertEqual(len(symattr.annotations), 2)
        self.assertEqual(symattr.annotations[0].value, '14 PIN JTAG')
        self.assertEqual(symattr.annotations[0].x / EAGLE_SCALE,
                         self.parser.make_length("110.49") - self.parser.make_length('118.11'))
        self.assertEqual(symattr.annotations[0].y / EAGLE_SCALE,
                         self.parser.make_length("127") - self.parser.make_length('139.7'))
        self.assertEqual(symattr.annotations[0].rotation, 0.0)
        self.assertEqual(symattr.annotations[1].value, 'SV3')
        self.assertEqual(symattr.annotations[1].x / EAGLE_SCALE,
                         self.parser.make_length("114.3") - self.parser.make_length('118.11'))
        self.assertEqual(symattr.annotations[1].y / EAGLE_SCALE,
                         self.parser.make_length("150.622") - self.parser.make_length('139.7'))
        self.assertEqual(symattr.annotations[1].rotation, 0.0)


    def test_arc_shape(self):
        """ Arc shapes are generated correctly. """
        parser = EagleXML()

        w = wire(x1='25.4', y1='0', x2='-25.4', y2='0', curve='180')
        s = parser.make_shape_for_wire(w)
        self.assertEqual(s.x, 0)
        self.assertEqual(s.y, 0)
        self.assertEqual(s.start_angle, 0.0)
        self.assertEqual(s.end_angle, 1.0)
        self.assertEqual(s.radius, parser.make_length('25.4'))

        w = wire(x1='-25.4', y1='0', x2='25.4', y2='0', curve='180')
        s = parser.make_shape_for_wire(w)
        self.assertEqual(s.x, 0)
        self.assertEqual(s.y, 0)
        self.assertEqual(s.start_angle, 1.0)
        self.assertEqual(s.end_angle, 0.0)
        self.assertEqual(s.radius, parser.make_length('25.4'))

        w = wire(x1='25.4', y1='0', x2='-25.4', y2='0', curve='90')
        s = parser.make_shape_for_wire(w)
        self.assertEqual(s.x, 0)
        self.assertEqual(s.y, self.make_length('-25.4'))
        self.assertEqual(s.start_angle, 0.25)
        self.assertEqual(s.end_angle, 0.75)
        self.assertEqual(s.radius, parser.make_length('35.915'))

        w = wire(x1='25.4', y1='0', x2='-25.4', y2='0', curve='-90')
        s = parser.make_shape_for_wire(w)
        self.assertEqual(s.x, 0)
        self.assertEqual(s.y, self.make_length('25.4'))
        self.assertEqual(s.start_angle, 1.25)
        self.assertEqual(s.end_angle, 1.75)
        self.assertEqual(s.radius, parser.make_length('35.915'))

        w = wire(x1='0', y1='25.4', x2='0', y2='-25.4', curve='90')
        s = parser.make_shape_for_wire(w)
        self.assertEqual(s.x, self.make_length('25.4'))
        self.assertEqual(s.y, 0)
        self.assertEqual(s.start_angle, 0.75)
        self.assertEqual(s.end_angle, 1.25)
        self.assertEqual(s.radius, parser.make_length('35.915'))

        w = wire(x1='0', y1='25.4', x2='0', y2='-25.4', curve='-180')
        s = parser.make_shape_for_wire(w)
        self.assertEqual(s.x, 0)
        self.assertEqual(s.y, 0)
        self.assertEqual(s.start_angle, 1.5)
        self.assertEqual(s.end_angle, 0.5)
        self.assertEqual(s.radius, parser.make_length('25.4'))

        w = wire(x1='25.4', y1='0', x2='-25.4', y2='0', curve='270')
        s = parser.make_shape_for_wire(w)
        self.assertEqual(s.x, 0)
        self.assertEqual(s.y, self.make_length('25.4'))
        self.assertEqual(s.start_angle, 1.75)
        self.assertEqual(s.end_angle, 1.25)
        self.assertEqual(s.radius, parser.make_length('35.915'))

        w = wire(x1='25.4', y1='0', x2='-25.4', y2='0', curve='-270')
        s = parser.make_shape_for_wire(w)
        self.assertEqual(s.x, 0)
        self.assertEqual(s.y, self.make_length('-25.4'))
        self.assertEqual(s.start_angle, 0.75)
        self.assertEqual(s.end_angle, 0.25)
        self.assertEqual(s.radius, parser.make_length('35.915'))


    def get_component(self, library_id):
        """ Return the component given its id. """
        return self.design.components.components[library_id]


    def get_instance(self, instance_id):
        """ Return the instance given its id. """
        return [ci for ci in self.design.component_instances
                if ci.instance_id == instance_id][0]


    def make_length(self, length):
        """ Return a length from the parser. """
        return self.parser.make_length(length)


    def make_point_name(self, x, y):
        """ Return a point name given an eaglexml point. """
        return '%sa%s' % (self.make_length(x), self.make_length(y))

########NEW FILE########
__FILENAME__ = eagle_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The eagle parser test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import unittest

from upconvert.parser.eagle import Eagle

class EagleTests(unittest.TestCase):
    """ The tests of the eagle parser """

    def setUp(self):
        """ Setup the test case. """
        Eagle.attr_jar = [Eagle.Attribute('name_a', 'value_a'),
                            Eagle.Attribute('name_b', 'value_b'),
                            Eagle.Attribute('name_c', 'value_c'),
                         ]
        Eagle.attr_jar_list = Eagle.attr_jar_iter()

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_eagle_parser(self):
        """ Test creating an empty parser. """
        parser = Eagle()
        assert parser != None

    def test_header_parse(self):
        """ Test Header block parsing """
        
        _valid_chunk = b''.join((b"\x10\x00\x0c\x00\x10\x00\x00\x00", 
                                 b"\x05\x0b\x04\x3c\x00\x2e\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))
        _header = Eagle.Header.parse(_valid_chunk)

        self.assertNotEqual(_header, None)

        self.assertEqual(_header.version, "5.11")
        self.assertEqual(_header.numofblocks, 16)
        return

    def test_settings_parse(self):
        """ Test Settings block parsing """

        _valid_chunk = b''.join((b"\x11\x00\x78\x20\x99\xa0\x1a\x47",
                                 b"\xa9\xcd\x10\x02\x00\x78\x20\x99",
                                 b"\xa0\x1a\x47\xa9\xcd\x10\x00\x00"))
        _settings = Eagle.Settings.parse(_valid_chunk)

        self.assertNotEqual(_settings, None)

        self.assertEqual(_settings.copyno, 2)
        return

    def test_grid_parse(self):
        """ Test Grid block parsing """

        _valid_chunk = b''.join((b"\x12\x00\x02\xaa\x0f\x00\x00\x00",
                                 b"\x7f\xc2\xd9\xad\x65\x32\xd9\x3f",
                                 b"\x00\x00\x00\x00\x00\x00\x24\x40"))
        _grid = Eagle.Grid.parse(_valid_chunk)

        self.assertEqual(_grid.distance, 0.1)
        self.assertEqual(_grid.unitdist, "mil")
        self.assertEqual(_grid.unit, "mil")
        self.assertEqual(_grid.style, "dots")
        self.assertEqual(_grid.multiple, 15)
        self.assertEqual(_grid.display, False)
        self.assertEqual(_grid.altdistance, 0.01)
        self.assertEqual(_grid.altunitdist, "mil")
        self.assertEqual(_grid.altunit, "mil")
        return

    def test_layer_parse(self):
        """ Test Layer block parsing """

        _valid_chunk = b''.join((b"\x13\x00\x0f\x5b\x5b\x01\x02\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x4e",
                                 b"\x65\x74\x73\x00\x00\x00\x00\x00"))
        _layer = Eagle.Layer.parse(_valid_chunk)

        self.assertEqual(_layer.number, 91)
        self.assertEqual(_layer.name, "Nets")
        self.assertEqual(_layer.color, 2)
        self.assertEqual(_layer.fill, 1)
        self.assertEqual(_layer.visible, True)
        self.assertEqual(_layer.active, True)
        self.assertEqual(_layer.linkedsign, False)
        self.assertEqual(_layer.linkednumber, 91)
        return

    def test_attributeheader_parse(self):
        """ Test AttributeHeader block parsing """

        _valid_chunk = b''.join((b"\x14\x80\x01\x00\x00\x00\x00\x00",
                                 b"\x02\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x7f\x10\xfa\x0d\x09"))
        _attrheader = Eagle.AttributeHeader.parse(_valid_chunk)

        self.assertEqual(_attrheader.schematic, 'name_a')
        self.assertEqual(_attrheader.numofshapes, 1)
        self.assertEqual(_attrheader.numofattributes, 0) 
# probably no embedded "schematic" is possible
        return

    def test_library_parse(self):
        """ Test Library block parsing """

# embedded name
        _valid_chunk = b''.join((b"\x15\x80\x00\x00\x09\x00\x00\x00",
                                 b"\x16\x00\x00\x00\x24\x00\x00\x00",
                                 b"\x64\x69\x6f\x64\x65\x00\x00\x00"))
        _library = Eagle.Library.parse(_valid_chunk)

        self.assertEqual(_library.name, "diode")
        self.assertEqual(_library.numofdevsetblocks, 9)
        self.assertEqual(_library.numofsymbolblocks, 22)
        self.assertEqual(_library.numofpackageblocks, 36)

# TODO external name
        return

    def test_devicesetheader_parse(self):
        """ Test DeviceSetHeader block parsing """

# embedded name
        _valid_chunk = b''.join((b"\x17\x80\x00\x00\x08\x00\x00\x00",
                                 b"\x02\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x64\x69\x6f\x64\x65\x00\x00\x00"))
        _devicesetheader = Eagle.DeviceSetHeader.parse(_valid_chunk)

        self.assertEqual(_devicesetheader.name, "diode")
        self.assertEqual(_devicesetheader.numofblocks, 8)
        self.assertEqual(_devicesetheader.numofshapesets, 2)

# TODO external name

        return

    def test_symbolheader_parse(self):
        """ Test SymbolHeader block parsing """

# embedded name
        _valid_chunk = b''.join((b"\x18\x80\x00\x00\x15\x00\x00\x00",
                                 b"\x02\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x64\x69\x6f\x64\x65\x00\x00\x00"))
        _symbolheader = Eagle.SymbolHeader.parse(_valid_chunk)

        self.assertEqual(_symbolheader.name, "diode")
        self.assertEqual(_symbolheader.numofblocks, 21)
        self.assertEqual(_symbolheader.numofshapesets, 2)

# TODO external name

        return

    def test_packageheader_parse(self):
        """ Test PackageHeader block parsing """

# embedded name
        _valid_chunk = b''.join((b"\x19\x80\x00\x00\x23\x00\x00\x00",
                                 b"\x02\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x64\x69\x6f\x64\x65\x00\x00\x00"))
        _packageheader = Eagle.PackageHeader.parse(_valid_chunk)

        self.assertEqual(_packageheader.name, "diode")
        self.assertEqual(_packageheader.numofblocks, 35)
        self.assertEqual(_packageheader.numofshapesets, 2)

# TODO external name

        return

    def test_symbol_parse(self):
        """ Test Symbol block parsing """

# embedded name
        _valid_chunk = b''.join((b"\x1d\x00\x0a\x00\xf4\xfe\x62\xff",
                                 b"\x2e\x01\xa8\x00\x00\x00\x00\x00",
                                 b"\x5a\x44\x00\x00\x00\x00\x00\x00"))
        _symbol = Eagle.Symbol.parse(_valid_chunk)

        self.assertEqual(_symbol.name, "ZD")
        self.assertEqual(_symbol.numofshapes, 10)
        self.assertEqual(_symbol.libid, 1)

# TODO external name
        return

    def test_package_parse(self):
        """ Test Package block parsing """

# TODO embedded name

# external name
        _valid_chunk = b''.join((b"\x1e\x00\x0d\x00\x7c\xfe\xb5\xff",
                                 b"\x84\x01\x97\x00\x00\x7f\x34\xe3",
                                 b"\x2a\x09\x7f\x2b\xe3\x2a\x09\x00"))
        _package = Eagle.Package.parse(_valid_chunk)

        self.assertEqual(_package.name, 'name_a')
        self.assertEqual(_package.desc, 'name_b')
        self.assertEqual(_package.numofshapes, 13)

        return

    def test_net_parse(self):
        """ Test Net block parsing """

# embedded name
        _valid_chunk = b''.join((b"\x1f\x80\x05\x00\xff\x7f\xff\x7f",
                                 b"\x00\x80\x00\x80\x00\x01\x00\x00",
                                 b"\x4e\x24\x31\x00\x00\x00\x00\x00"))
        _net = Eagle.Net.parse(_valid_chunk)

        self.assertEqual(_net.name, "N$1")
        self.assertEqual(_net.nclass, 1)
        self.assertEqual(_net.numofshapes, 5)

# TODO external name
        return

    def test_part_parse(self):
        """ Test Part block parsing """

# embedded name
        _valid_chunk = b''.join((b"\x38\x00\x02\x00\x01\x00\x02\x00",
                                 b"\x01\x01\x01\x49\x43\x39\x00\x00",
                                 b"\x44\x53\x33\x36\x36\x38\x00\x00"))
        _part = Eagle.Part.parse(_valid_chunk)

        self.assertEqual(_part.name, "IC9")
        self.assertEqual(_part.libid, 1)
        self.assertEqual(_part.devsetndx, 2)
        self.assertEqual(_part.symvar, 1)
        self.assertEqual(_part.techno, 1)
        self.assertEqual(_part.value, "DS3668")
        self.assertEqual(_part.numofshapes, 2)

# TODO external name
        return

    def test_deviceset_parse(self):
        """ Test DeviceSet block parsing """

# embedded names (2 of 3)
        _valid_chunk = b''.join((b"\x37\x80\x01\x00\x02\x00\x00\x84",
                                 b"\x44\x00\x00\x00\x00\x7f\xdd\x95",
                                 b"\x3c\x09\x31\x4e\x35\x33\x33\x33"))
        _devset = Eagle.DeviceSet.parse(_valid_chunk)

        self.assertEqual(_devset.name, "1N5333")
        self.assertEqual(_devset.prefix, "D")
        self.assertEqual(_devset.description, 'name_a')
        self.assertEqual(_devset.uservalue, False)
        self.assertEqual(_devset.numofshapes, 1)
        self.assertEqual(_devset.numofconnblocks, 2)

# embedded names (2 of 3)
        _valid_chunk = b''.join((b"\x37\x00\x01\x00\x02\x00\x01\x85",
                                 b"\x4A\x50\x00\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x7f\xc1\xd3\xcf\x08\x00"))
        _devset = Eagle.DeviceSet.parse(_valid_chunk)

        self.assertEqual(_devset.name, 'name_b')
        self.assertEqual(_devset.prefix, "JP")
        self.assertEqual(_devset.description, "")
        self.assertEqual(_devset.uservalue, True)
        self.assertEqual(_devset.numofshapes, 1)
        self.assertEqual(_devset.numofconnblocks, 2)

        return

    def test_bus_parse(self):
        """ Test Bus block parsing """

# embedded name
        _valid_chunk = b''.join((b"\x3a\x80\x04\x00\x42\x24\x33\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))
        _bus = Eagle.Bus.parse(_valid_chunk)

        self.assertEqual(_bus.name, "B$3")
        self.assertEqual(_bus.numofshapes, 4)

# TODO external name
        return

    def test_shapeheader_parse(self):
        """ Test ShapeHeader block parsing """

        _valid_chunk = b''.join((b"\x1a\x00\x03\x00\x33\x01\x05\x0d",
                                 b"\x64\x07\x4b\x10\x04\x00\x00\x00",
                                 b"\x05\x00\x00\x00\x0e\x00\x00\x00"))
        _shapeheader = Eagle.ShapeHeader.parse(_valid_chunk)

        self.assertEqual(_shapeheader.numofshapes, 3)
        self.assertEqual(_shapeheader.numofpartblocks, 4)
        self.assertEqual(_shapeheader.numofbusblocks, 5)
        self.assertEqual(_shapeheader.numofnetblocks, 14)
        return

    def test_segment_parse(self):
        """ Test Segment block parsing """

        _valid_chunk = b''.join((b"\x20\x00\x04\x00\xcd\x05\x9b\x01",
                                 b"\xc8\x13\x0d\x10\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))
        _segment = Eagle.Segment.parse(_valid_chunk)

        self.assertEqual(_segment.numofshapes, 4)
        self.assertEqual(_segment.cumulativenumofshapes, 19)
        return

    def test_polygon_parse(self):
        """ Test Polygon block parsing """

        _valid_chunk = b''.join((b"\x21\x00\x03\x00\x05\xff\xfe\xff",
                                 b"\x27\xff\x34\x00\xfc\x01\xce\x18",
                                 b"\x00\x00\x15\x8e\x00\x00\x00\x00"))
        _polygon = Eagle.Polygon.parse(_valid_chunk)

        self.assertEqual(_polygon.numofshapes, 3)
        self.assertEqual(_polygon.width, 0.1016)
        self.assertEqual(_polygon.layer, 21)
        return

    def test_connectionheader_parse(self):
        """ Test ConnectionHeader block parsing """

        _valid_chunk = b''.join((b"\x36\x00\x01\x00\x04\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x27\x27\x00\x00\x00"))
        _connheader = Eagle.ConnectionHeader.parse(_valid_chunk)

        self.assertEqual(_connheader.numofshapes, 1)
        self.assertEqual(_connheader.sindex, 4)
# TODO technology / attributes check, 'name'
        return

    def test_connections_parse(self):
        """ Test Connections block parsing """

        _valid_chunk = b''.join((b"\x3c\x00\x21\x22\x23\x24\x25\x26",
                                 b"\x27\x28\x29\x2a\x2b\x2c\x2d\x2e",
                                 b"\x2f\x30\x00\x00\x00\x00\x00\x00"))
        _connections = Eagle.Connections.parse(_valid_chunk)

        self.assertEqual(_connections.connections, [33, 34, 35, 36, 37, 38, 
                            39, 40, 41, 42, 43, 44, 45, 46, 47, 48])
        return

    def test_instance_parse(self):
        """ Test Instance block parsing """

        _valid_chunk = b''.join((b"\x30\x00\x02\x00\xd0\x54\x21\x00",
                                 b"\x40\x4d\x09\x00\xff\xff\x01\x00",
                                 b"\x00\x04\x01\x00\x00\x00\x00\x00"))
        _instance = Eagle.Instance.parse(_valid_chunk)

        self.assertEqual(_instance.numofshapes, 2)
        self.assertEqual(_instance.x, 218.44)
        self.assertEqual(_instance.y, 60.96)
        self.assertEqual(_instance.smashed, True)
        self.assertEqual(_instance.rotate, "R90")
        return

    def test_wire_parse(self):
        """ Test Wire block parsing """

        _valid_chunk = b''.join((b"\x22\x00\x00\x5b\xd8\x09\x05\x00",
                                 b"\x40\x4d\x09\x00\xd8\x09\x05\x00",
                                 b"\x60\xc0\x07\x00\xfa\x02\x03\x00"))
        _wire = Eagle.Wire.parse(_valid_chunk)

        self.assertEqual(_wire.x1, 33.02)
        self.assertEqual(_wire.y1, 60.96)
        self.assertEqual(_wire.x2, 33.02)
        self.assertEqual(_wire.y2, 50.8)
        self.assertEqual(_wire.style, "DashDot")
        self.assertEqual(_wire.width, 0.1524)
        self.assertEqual(_wire.layer, 91)
        return

    def test_hole_parse(self):
        """ Test Hole block parsing """

        _valid_chunk = b''.join((b"\x28\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x90\xb4\x01\x00\x7e\x40\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))
        _hole = Eagle.Hole.parse(_valid_chunk)

        self.assertEqual(_hole.x, 0.)
        self.assertEqual(_hole.y, 11.176)
        self.assertEqual(_hole.drill, 3.302)
        return

    def test_smd_parse(self):
        """ Test SMD block parsing """

        _valid_chunk = b''.join((b"\x2b\x80\x00\x01\x96\xb5\xff\xff",
                                 b"\x0e\x78\x00\x00\xe6\x0c\xb0\x27",
                                 b"\x00\x00\x00\x31\x34\x00\x00\x00"))
        _smd = Eagle.SMD.parse(_valid_chunk)

        self.assertEqual(_smd.name, "14")
        self.assertEqual(_smd.x, -1.905)
        self.assertEqual(_smd.y, 3.0734)
        self.assertEqual(_smd.dx, 0.6604)
        self.assertEqual(_smd.dy, 2.032)
        self.assertEqual(_smd.layer, 1)
        return

    def test_arc_parse(self):
        """ Test Arc block parsing """

# fixed angle arc
        _valid_chunk = b''.join((b"\x22\x80\x30\x15\x8c\xba\xff\xff",
                                 b"\xce\x18\x00\x00\x78\xc4\xff\xff",
                                 b"\xba\x22\x00\x00\xfa\x02\x00\x79"))
        _arc = Eagle.Wire.parse(_valid_chunk)

        self.assertEqual(_arc.x1, -1.778)
        self.assertEqual(_arc.y1, 0.635)
        self.assertEqual(_arc.x2, -1.524)
        self.assertEqual(_arc.y2, 0.889)
        self.assertEqual(_arc.width, 0.1524)
        self.assertEqual(_arc.curve, -90.)
        self.assertEqual(_arc.cap, None)
        self.assertEqual(_arc.direction, "clockwise")
        self.assertEqual(_arc.style, "Continuous")
        self.assertEqual(_arc.layer, 21)
 
# free angle arc
        _valid_chunk = b''.join((b"\x22\x00\x00\x5b\xc0\x80\x0f\xd8",
                                 b"\x48\xd0\x05\x70\xa0\x0d\x11\x11",
                                 b"\x40\x4d\x09\x00\xe8\x0b\x32\x81"))
        _arc = Eagle.Wire.parse(_valid_chunk)

        self.assertEqual(_arc.x1, 101.6)
        self.assertEqual(_arc.y1, 38.1)
        self.assertEqual(_arc.x2, 111.76)
        self.assertEqual(_arc.y2, 60.96)
        self.assertEqual(_arc.width, 0.6096)
        self.assertEqual(_arc.curve, 112.62) # rounded a bit
                                             # note: encoded number is 114.3 -- a circle center's X coord
        self.assertEqual(_arc.cap, "flat")
        self.assertEqual(_arc.direction, "counterclockwise")
        self.assertEqual(_arc.style, "ShortDash")
        self.assertEqual(_arc.layer, 91)
        return

    def test_circle_parse(self):
        """ Test Circle block parsing """

        _valid_chunk = b''.join((b"\x25\x00\x00\x5b\x48\x37\x12\x00",
                                 b"\xb0\x13\x0a\x00\xbd\x65\x01\x00",
                                 b"\xbd\x65\x01\x00\xf4\x05\x00\x00"))
        _circle = Eagle.Circle.parse(_valid_chunk)

        self.assertEqual(_circle.x, 119.38)
        self.assertEqual(_circle.y, 66.04)
        self.assertEqual(_circle.radius, 9.1581)
        self.assertEqual(_circle.width, 0.3048)
        self.assertEqual(_circle.layer, 91)
        return

    def test_rectangle_parse(self):
        """ Test Rectangle block parsing """

        _valid_chunk = b''.join((b"\x26\x80\x00\x5c\x50\x53\x02\x00",
                                 b"\xe8\x76\x0a\x00\x08\xea\x08\x00",
                                 b"\xa0\x0d\x11\x00\x00\x00\x00\x00"))
        _rectangle = Eagle.Rectangle.parse(_valid_chunk)

        self.assertEqual(_rectangle.x1, 15.24)
        self.assertEqual(_rectangle.y1, 68.58)
        self.assertEqual(_rectangle.x2, 58.42)
        self.assertEqual(_rectangle.y2, 111.76)
        self.assertEqual(_rectangle.rotate, None)
        self.assertEqual(_rectangle.layer, 92)
        return

    def test_pad_parse(self):
        """ Test Pad block parsing """

# embedded name
        _valid_chunk = b''.join((b"\x2a\x80\x01\x00\x70\xc6\x00\x00",
                                 b"\x00\x00\x00\x00\xd4\x15\x00\x00",
                                 b"\x00\x00\x00\x41\x00\x00\x00\x00"))
        _pad = Eagle.Pad.parse(_valid_chunk)

        self.assertEqual(_pad.name, "A")
        self.assertEqual(_pad.x, 5.08)
        self.assertEqual(_pad.y, 0.)
        self.assertEqual(_pad.drill, 0.5588)

# TODO external name
        return

    def test_pin_parse(self):
        """ Test Pin block parsing """

# embedded name
        _valid_chunk = b''.join((b"\x2c\x80\x00\x00\x38\x63\x00\x00",
                                 b"\x00\x00\x00\x00\x96\x00\x43\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))
        _pin = Eagle.Pin.parse(_valid_chunk)

        self.assertEqual(_pin.name, "C")
        self.assertEqual(_pin.x, 2.54)
        self.assertEqual(_pin.y, 0.)
        self.assertEqual(_pin.visible, "off")
        self.assertEqual(_pin.direction, "pas")
        self.assertEqual(_pin.rotate, "R180")
        self.assertEqual(_pin.length, "short")
        self.assertEqual(_pin.function, None)
        self.assertEqual(_pin.swaplevel, 0)

        _valid_chunk = b''.join((b"\x2c\x80\x41\x00\x90\x39\xff\xff",
                                 b"\x38\x63\x00\x00\x11\x01\x49\x4e",
                                 b"\x2b\x00\x00\x00\x00\x00\x00\x00"))
        _pin = Eagle.Pin.parse(_valid_chunk)

        self.assertEqual(_pin.name, "IN+")
        self.assertEqual(_pin.x, -5.08)
        self.assertEqual(_pin.y, 2.54)
        self.assertEqual(_pin.visible, "pad")
        self.assertEqual(_pin.direction, "in")
        self.assertEqual(_pin.rotate, None)
        self.assertEqual(_pin.length, "short")
        self.assertEqual(_pin.function, "dot")
        self.assertEqual(_pin.swaplevel, 1)

# TODO external name
        return

    def test_gate_parse(self):
        """ Test Gate block parsing """

# embedded name
        _valid_chunk = b''.join((b"\x2d\x00\x00\x00\xd0\x1f\xfc\xff",
                                 b"\x38\x63\x00\x00\x03\x00\x02\x00",
                                 b"\x50\x00\x00\x00\x00\x00\x00\x00"))
        _gate = Eagle.Gate.parse(_valid_chunk)

        self.assertEqual(_gate.name, "P")
        self.assertEqual(_gate.x, -25.4)
        self.assertEqual(_gate.y, 2.54)
        self.assertEqual(_gate.sindex, 2)
        self.assertEqual(_gate.addlevel, "request")

# TODO external name
        return

    def test_text_parse(self):
        """ Test Text block parsing """

# embedded text
        _valid_chunk = b''.join((b"\x31\x80\x02\x5b\x80\x9a\x12\x00",
                                 b"\xc0\x19\x03\x00\x02\x7e\x4c\x00",
                                 b"\x00\x08\x74\x65\x78\x74\x21\x00"))
        _text = Eagle.Text.parse(_valid_chunk)

        self.assertEqual(_text.value, "text!")
        self.assertEqual(_text.x, 121.92)
        self.assertEqual(_text.y, 20.32)
        self.assertEqual(_text.size, 6.4516)
        self.assertEqual(_text.rotate, "R180")
        self.assertEqual(_text.font, "fixed")
        self.assertEqual(_text.ratio, 19)
        self.assertEqual(_text.layer, 91)

# extarnal text
        _valid_chunk = b''.join((b"\x31\x80\x02\x5b\x18\xf0\x01\x00",
                                 b"\x18\x57\x0e\x00\x02\x7e\x4c\x00",
                                 b"\x00\x00\x7f\xf8\xcd\x35\x09\x00"))
        _text = Eagle.Text.parse(_valid_chunk)

        self.assertEqual(_text.value, 'name_a')
        self.assertEqual(_text.x, 12.7)
        self.assertEqual(_text.y, 93.98)
        self.assertEqual(_text.size, 6.4516)
        self.assertEqual(_text.rotate, None)
        self.assertEqual(_text.font, "fixed")
        self.assertEqual(_text.ratio, 19)
        self.assertEqual(_text.layer, 91)
        return
 
    def test_label_parse(self):
        """ Test Label block parsing """

        _valid_chunk = b''.join((b"\x33\x00\x02\x5f\xe0\xf3\x0d\x00",
                                 b"\xa0\xa6\x04\x00\xe0\x0f\x0c\x00",
                                 b"\x00\x1c\x01\x00\x00\x00\x00\x00"))
        _label = Eagle.Label.parse(_valid_chunk)

        self.assertEqual(_label.x, 91.44)
        self.assertEqual(_label.y, 30.48)
        self.assertEqual(_label.size, 0.8128)
        self.assertEqual(_label.rotate, "R270")
        self.assertEqual(_label.font, "fixed")
        self.assertEqual(_label.ratio, 3)
        self.assertEqual(_label.onoff, True)
        self.assertEqual(_label.mirrored, True)
        self.assertEqual(_label.layer, 95)
        return
 
    def test_attributenam_parse(self):
        """ Test AttributeNam block parsing """

        _valid_chunk = b''.join((b"\x34\x00\x01\x5f\xd6\xd0\x21\x00",
                                 b"\x14\xe2\x09\x00\xc4\x1d\x20\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))
        _attrnam = Eagle.AttributeNam.parse(_valid_chunk)

        self.assertEqual(_attrnam.x, 221.615)
        self.assertEqual(_attrnam.y, 64.77)
        self.assertEqual(_attrnam.size, 1.524)
        self.assertEqual(_attrnam.rotate, None)
        self.assertEqual(_attrnam.font, None)
        self.assertEqual(_attrnam.layer, 95)
        return
 
    def test_attributeval_parse(self):
        """ Test AttributeVal block parsing """

        _valid_chunk = b''.join((b"\x35\x00\x01\x60\x3a\x9f\x21\x00",
                                 b"\xbe\x8d\x09\x00\xc4\x1d\x20\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))
        _attrval = Eagle.AttributeVal.parse(_valid_chunk)

        self.assertEqual(_attrval.x, 220.345)
        self.assertEqual(_attrval.y, 62.611)
        self.assertEqual(_attrval.size, 1.524)
        self.assertEqual(_attrval.rotate, None)
        self.assertEqual(_attrval.font, None)
        self.assertEqual(_attrval.layer, 96)
        return

    def test_attributeprt_parse(self):
        """ Test AttributePrt block parsing """

        _valid_chunk = b''.join((b"\x3f\x80\x01\x5f\x18\xf3\x3f\x00",
                                 b"\x40\xe6\xfc\xff\xba\x22\x20\x00",
                                 b"\x00\x10\x00\x00\x00\x00\x00\x00"))
        _attrprt = Eagle.AttributePrt.parse(_valid_chunk)

        self.assertEqual(_attrprt.x, 419.1)
        self.assertEqual(_attrprt.y, -20.32)
        self.assertEqual(_attrprt.size, 1.778)
        self.assertEqual(_attrprt.rotate, 'MR0')
        self.assertEqual(_attrprt.font, None)
        self.assertEqual(_attrprt.layer, 95)
        return

    def test_pinref_parse(self):
        """ Test PinRef block parsing """

        _valid_chunk = b''.join((b"\x3d\x00\x00\x00\x06\x00\x01\x00",
                                 b"\x07\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))
        _pinref = Eagle.PinRef.parse(_valid_chunk)

        self.assertEqual(_pinref.partno, 6)
        self.assertEqual(_pinref.gateno, 1)
        self.assertEqual(_pinref.pinno, 7)
        return

    def test_frame_parse(self):
        """ Test Frame block parsing """

        _valid_chunk = b''.join((b"\x43\x80\x00\x5e\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x30\xe3\x41\x00",
                                 b"\x10\xa2\x2a\x00\x09\x06\x0e\x00"))
        _frame = Eagle.Frame.parse(_valid_chunk)

        self.assertEqual(_frame.x1, 0)
        self.assertEqual(_frame.y1, 0)
        self.assertEqual(_frame.x2, 431.8)
        self.assertEqual(_frame.y2, 279.4)
        self.assertEqual(_frame.columns, 9)
        self.assertEqual(_frame.rows, 6)
        self.assertEqual(_frame.bleft, True)
        self.assertEqual(_frame.btop, True)
        self.assertEqual(_frame.bright, True)
        self.assertEqual(_frame.bbottom, False)
        self.assertEqual(_frame.layer, 94)
        return

    def test_attribute_parse(self):
        """ Test Attribute block parsing """

# embedded text
        _valid_chunk = b''.join((b"\x42\x80\x2a\x00\x00\x00\x00\x31",
                                 b"\x32\x33\x34\x35\x36\x37\x38\x39",
                                 b"\x30\x21\x71\x77\x21\x72\x74\x00"))
        _attr = Eagle.Attribute.parse(_valid_chunk)

        self.assertEqual(_attr.name, "1234567890")
        self.assertEqual(_attr.value, "qw!rt")

# external text
        _valid_chunk = b''.join((b"\x42\x80\x2a\x00\x00\x00\x00\x7f",
                                 b"\x88\x2b\x18\x09\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))
        _attr = Eagle.Attribute.parse(_valid_chunk)
        self.assertEqual(_attr.name, 'name_a')
        self.assertEqual(_attr.value, None)
        return


########NEW FILE########
__FILENAME__ = fritzing_t
# encoding: utf-8
#pylint: disable=R0904
""" The fritzing parser test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.shape import Circle, Rectangle, Shape
from upconvert.parser.fritzing import Fritzing, ComponentParser, PathParser
from upconvert.parser.fritzing import make_x, make_y, make_length, get_pin
from upconvert.parser.fritzing import get_x, get_y, get_length

from unittest import TestCase

from os.path import dirname, join

TEST_DIR = join(dirname(__file__), '..', '..', '..', 'test', 'fritzing')


class FakeElem(dict):
    """ A fake xml element. """

    def __init__(self, tag, **kw):
        self.tag = tag
        super(FakeElem, self).__init__(**kw)


class FritzingTests(TestCase):
    """ The tests of the fritzing parser """

    def load_file(self, basename):
        """ Load a fritzing test file with the given basename """
        parser = Fritzing()
        return parser.parse(join(TEST_DIR, basename))


    def test_autodetect(self):
        """ The fritzing autodetection works. """
        self.assertEqual(Fritzing.auto_detect(join(TEST_DIR, '..', 'kicad',
                                                   'starkadroid_e.sch')), 0.0)
        self.assertEqual(Fritzing.auto_detect(join(TEST_DIR, "Wiring.fzz")), 0.9)
        self.assertEqual(Fritzing.auto_detect(join(TEST_DIR, "Wiring.fz")), 0.9)


    def test_create_new_fritzing_parser(self):
        """ Test creating an empty parser. """
        parser = Fritzing()
        assert parser != None


    def test_make_x(self):
        """ make_x converts x values correctly """
        self.assertEqual(make_x('17.23'), 17)


    def test_make_y(self):
        """ make_y converts y values correctly """
        self.assertEqual(make_y('17.23'), -17)


    def test_make_length(self):
        """ make_length converts other numeric values correctly """
        self.assertEqual(make_length('17.23'), 17)


    def test_get_x(self):
        """ get_x retrieves x values correctly """
        elem = {'x': '4.62', 'x1': '10.2'}
        self.assertEqual(get_x(elem), 5)
        self.assertEqual(get_x(elem, 'x1'), 10)
        self.assertEqual(get_x(elem, 'x2'), 0)


    def test_get_y(self):
        """ get_y retrieves y values correctly """
        elem = {'y': '4.62', 'y1': '10.2'}
        self.assertEqual(get_y(elem), -5)
        self.assertEqual(get_y(elem, 'y1'), -10)
        self.assertEqual(get_y(elem, 'y2'), 0)


    def test_get_length(self):
        """ get_length retrieves other numeric values correctly """
        elem = {'r': '4.62', 'r1': '10.2'}
        self.assertEqual(get_length(elem, 'r'), 5)
        self.assertEqual(get_length(elem, 'r1'), 10)
        self.assertEqual(get_length(elem, 'r2'), 0)


    def test_components(self):
        """ The parser loads Components correctly """

        design = self.load_file('components.fz')
        self.assertEqual(len(design.components.components), 2)

        cpts = design.components.components
        self.assertEqual(set(cpts),
                         set(['ResistorModuleID',
                              '4a300fed-afa9-4e78-a643-ec209be7e3b8']))

        diode = cpts['4a300fed-afa9-4e78-a643-ec209be7e3b8']
        self.assertEqual(diode.name, '4a300fed-afa9-4e78-a643-ec209be7e3b8')
        self.assertEqual(diode.attributes, {'_prefix': 'D'})
        self.assertEqual(len(diode.symbols), 1)

        symb = diode.symbols[0]
        self.assertEqual(len(symb.bodies), 1)

        body = symb.bodies[0]
        self.assertEqual(len(body.shapes), 8)
        self.assertEqual(len(body.pins), 2)

        shape = body.shapes[0]
        self.assertEqual(shape.type, 'rectangle')
        self.assertEqual(shape.x, 15)
        self.assertEqual(shape.y, -1)
        self.assertEqual(shape.width, 0)
        self.assertEqual(shape.height, 0)

        pin = body.pins[0]
        self.assertEqual(pin.pin_number, '0')
        self.assertEqual(pin.p1.x, 15)
        self.assertEqual(pin.p1.y, -1)
        self.assertEqual(pin.p2.x, pin.p1.x)
        self.assertEqual(pin.p2.y, pin.p1.y)


    def test_component_instances(self):
        """ The parser loads ComponentInstances correctly """

        design = self.load_file('components.fz')
        self.assertEqual(len(design.component_instances), 2)
        self.assertEqual(
            set([i.instance_id for i in design.component_instances]),
            set(['D1', 'R1']))

        inst = [i for i in design.component_instances
                if i.instance_id == 'D1'][0]
        self.assertEqual(inst.library_id, "4a300fed-afa9-4e78-a643-ec209be7e3b8")
        self.assertEqual(inst.symbol_index, 0)
        self.assertEqual(len(inst.symbol_attributes), 1)

        symbattr = inst.symbol_attributes[0]
        self.assertEqual(symbattr.x, 288)
        self.assertEqual(symbattr.y, -159)
        self.assertEqual(symbattr.rotation, 1.5)


    def test_get_pin(self):
        """ The get_pin function returns the correct Pins """

        shape = Rectangle(0, 0, 4, 8)
        pin = get_pin(shape)
        self.assertEqual(pin.p1.x, 2)
        self.assertEqual(pin.p1.y, 4)
        self.assertEqual(pin.p2.x, pin.p1.x)
        self.assertEqual(pin.p2.y, pin.p1.y)

        shape = Circle(0, 0, 4)
        pin = get_pin(shape)
        self.assertEqual(pin.p1.x, 0)
        self.assertEqual(pin.p1.y, 0)
        self.assertEqual(pin.p2.x, pin.p1.x)
        self.assertEqual(pin.p2.y, pin.p1.y)

        self.assertEqual(get_pin(Shape()), None)


    def test_missing_p(self):
        """The component parser handles a connector missing a p element """

        parser = ComponentParser(None)

        class FakeConn(object):
            """A fake connector"""

            def __init__(self, missing):
                self.missing = missing

            def find(self, path):
                """ Return None or a fixed element for the p element """
                assert path == 'views/schematicView/p'
                if self.missing:
                    return None
                else:
                    return {'terminalId': 'tid'}

            def get(self, key):
                """ Return 'id' for the 'id' attribute """
                assert key == 'id'
                return 'id'

        class FakeTree(object):
            """A fake tree """

            def findall(self, path):
                """ Return two fake connectors, one missing
                a p element and one not """
                assert path == 'connectors/connector'
                return [FakeConn(missing=True), FakeConn(missing=False)]

        terminals = parser.parse_terminals(FakeTree())

        self.assertEqual(terminals, {'id':'tid'})


    def test_nets(self):
        """ The parser loads Nets correctly """

        design = self.load_file('nets.fz')
        self.assertEqual(len(design.nets), 2)
        self.assertEqual(set(len(net.points) for net in design.nets),
                         set([8, 5]))

        net = [n for n in design.nets if len(n.points) == 5][0]

        p1 = net.points['143a33']
        self.assertEqual(p1.connected_points, ['143a44'])
        self.assertEqual(len(p1.connected_components), 1)
        self.assertEqual(p1.connected_components[0].instance_id, 'L1')
        self.assertEqual(p1.connected_components[0].pin_number, '1')


    def test_parse_circle(self):
        """ We parse svg circles correctly. """

        parser = ComponentParser(None)
        elem = FakeElem('circle', cx='72', cy='144', r='216')
        shapes = parser.parse_shapes(elem)
        self.assertEqual(len(shapes), 1)
        self.assertEqual(shapes[0].type, 'circle')
        self.assertEqual(shapes[0].x, 90)
        self.assertEqual(shapes[0].y, -180)
        self.assertEqual(shapes[0].radius, 270)


    def test_parse_rect(self):
        """ We parse svg rectangles correctly. """

        parser = ComponentParser(None)
        elem = FakeElem('rect', x='0', y='720',
                        width='72', height='144')
        shapes = parser.parse_shapes(elem)
        self.assertEqual(len(shapes), 1)
        self.assertEqual(shapes[0].type, 'rectangle')
        self.assertEqual(shapes[0].x, 0)
        self.assertEqual(shapes[0].y, -900)
        self.assertEqual(shapes[0].width, 90)
        self.assertEqual(shapes[0].height, 180)


    def test_path_num_re(self):
        """ The path point regex correctly matches numbers in a path. """

        num = '1'
        match = PathParser.num_re.match(num)
        self.assertEqual(match.group(0), num)
        self.assertEqual(match.group(1), '1')

        num = ' 1 '
        match = PathParser.num_re.match(num)
        self.assertEqual(match.group(0), num)
        self.assertEqual(match.group(1), '1')

        num = ' 1.2 '
        match = PathParser.num_re.match(num)
        self.assertEqual(match.group(0), num)
        self.assertEqual(match.group(1), '1.2')

        num = ' 1.2 , '
        match = PathParser.num_re.match(num)
        self.assertEqual(match.group(0), num)
        self.assertEqual(match.group(1), '1.2')

        num = ' 10.22 , '
        match = PathParser.num_re.match(num)
        self.assertEqual(match.group(0), num)
        self.assertEqual(match.group(1), '10.22')

        num = '10.22 , 1'
        match = PathParser.num_re.match(num)
        self.assertEqual(match.group(0), num[:-1])
        self.assertEqual(match.group(1), '10.22')

        num = '10.22 , M'
        match = PathParser.num_re.match(num)
        self.assertEqual(match.group(0), num[:-1])
        self.assertEqual(match.group(1), '10.22')

        num = '-1'
        match = PathParser.num_re.match(num)
        self.assertEqual(match.group(0), num)
        self.assertEqual(match.group(1), '-1')


    def test_parse_nums(self):
        """ Numbers are parsed from svg paths. """

        pp = PathParser(None)

        self.assertEqual(pp.parse_nums(''), ([], ''))
        self.assertEqual(pp.parse_nums('1'), ([1.0], ''))
        self.assertEqual(pp.parse_nums('1.2 3.4'),
                         ([1.2, 3.4], ''))
        self.assertEqual(pp.parse_nums('1.2,3.4  5.6'),
                         ([1.2, 3.4, 5.6], ''))
        self.assertEqual(pp.parse_nums('1.2,3.4  5.6L12'),
                         ([1.2, 3.4, 5.6], 'L12'))
        self.assertEqual(pp.parse_nums('1.2,3.4  5.6 L12'),
                         ([1.2, 3.4, 5.6], 'L12'))


    def test_parse_points(self):
        """ Sequences of points are parsed from svg paths. """

        pp = PathParser(None)

        self.assertEqual(pp.parse_points(''), ([], ''))
        self.assertEqual(pp.parse_points('1 2 3.3 4.4 M'),
                         ([(1, 2), (3.3, 4.4)], 'M'))


    def test_get_path_point(self):
        """ get_path_point returns correct points """

        pp = PathParser(None)

        pp.cur_point = (1, 2)

        self.assertEqual(pp.get_path_point((3, 4), False), (3, 4))
        self.assertEqual(pp.get_path_point((3, 4), True), (4, 6))


    def test_parse_m(self):
        """ moveto segments are parsed correctly """

        pp = PathParser(None)

        rest = pp.parse_m('72 720 144 288 0 0 rest', False)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (72.0, 720.0))
        self.assertEqual(pp.cur_point, (0, 0))
        self.assertEqual(len(pp.shapes), 2)
        self.assertEqual(pp.shapes[0].type, 'line')
        self.assertEqual(pp.shapes[0].p1.x, 90)
        self.assertEqual(pp.shapes[0].p1.y, -900)
        self.assertEqual(pp.shapes[0].p2.x, 180)
        self.assertEqual(pp.shapes[0].p2.y, -360)
        self.assertEqual(pp.shapes[1].type, 'line')
        self.assertEqual(pp.shapes[1].p1.x, 180)
        self.assertEqual(pp.shapes[1].p1.y, -360)
        self.assertEqual(pp.shapes[1].p2.x, 0)
        self.assertEqual(pp.shapes[1].p2.y, 0)


        pp = PathParser(None)

        rest = pp.parse_m('72 720 144 288 0 0 rest', True)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (72.0, 720.0))
        self.assertEqual(pp.cur_point, (216.0, 1008.0))
        self.assertEqual(len(pp.shapes), 2)
        self.assertEqual(pp.shapes[0].type, 'line')
        self.assertEqual(pp.shapes[0].p1.x, 90)
        self.assertEqual(pp.shapes[0].p1.y, -900)
        self.assertEqual(pp.shapes[0].p2.x, 270)
        self.assertEqual(pp.shapes[0].p2.y, -1260)
        self.assertEqual(pp.shapes[1].type, 'line')
        self.assertEqual(pp.shapes[1].p1.x, 270)
        self.assertEqual(pp.shapes[1].p1.y, -1260)
        self.assertEqual(pp.shapes[1].p2.x, 270)
        self.assertEqual(pp.shapes[1].p2.y, -1260)


    def test_parse_z(self):
        """ closepath segments are parsed correctly """

        pp = PathParser(None)

        pp.cur_point = (72, 144)
        pp.start_point = (-72, -144)
        rest = pp.parse_z('rest', False)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (-72, -144))
        self.assertEqual(pp.cur_point, (-72, -144))
        self.assertEqual(len(pp.shapes), 1)
        self.assertEqual(pp.shapes[0].type, 'line')
        self.assertEqual(pp.shapes[0].p1.x, 90)
        self.assertEqual(pp.shapes[0].p1.y, -180)
        self.assertEqual(pp.shapes[0].p2.x, -90)
        self.assertEqual(pp.shapes[0].p2.y, 180)


    def test_parse_l(self):
        """ lineto segments are parsed correctly """

        pp = PathParser(None)

        rest = pp.parse_l('72 720 144 288 0 0 rest', False)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (0, 0))
        self.assertEqual(len(pp.shapes), 3)
        self.assertEqual(pp.shapes[0].type, 'line')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].p2.x, 90)
        self.assertEqual(pp.shapes[0].p2.y, -900)
        self.assertEqual(pp.shapes[1].type, 'line')
        self.assertEqual(pp.shapes[1].p1.x, 90)
        self.assertEqual(pp.shapes[1].p1.y, -900)
        self.assertEqual(pp.shapes[1].p2.x, 180)
        self.assertEqual(pp.shapes[1].p2.y, -360)
        self.assertEqual(pp.shapes[2].type, 'line')
        self.assertEqual(pp.shapes[2].p1.x, 180)
        self.assertEqual(pp.shapes[2].p1.y, -360)
        self.assertEqual(pp.shapes[2].p2.x, 0)
        self.assertEqual(pp.shapes[2].p2.y, 0)


        pp = PathParser(None)

        rest = pp.parse_l('72 720 144 288 0 0 rest', True)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (216.0, 1008.0))
        self.assertEqual(len(pp.shapes), 3)
        self.assertEqual(pp.shapes[0].type, 'line')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].p2.x, 90)
        self.assertEqual(pp.shapes[0].p2.y, -900)
        self.assertEqual(pp.shapes[1].type, 'line')
        self.assertEqual(pp.shapes[1].p1.x, 90)
        self.assertEqual(pp.shapes[1].p1.y, -900)
        self.assertEqual(pp.shapes[1].p2.x, 270)
        self.assertEqual(pp.shapes[1].p2.y, -1260)
        self.assertEqual(pp.shapes[2].type, 'line')
        self.assertEqual(pp.shapes[2].p1.x, 270)
        self.assertEqual(pp.shapes[2].p1.y, -1260)
        self.assertEqual(pp.shapes[2].p2.x, 270)
        self.assertEqual(pp.shapes[2].p2.y, -1260)


    def test_parse_h(self):
        """ horizontal lineto segments are parsed correctly """

        pp = PathParser(None)

        rest = pp.parse_h('72 144 288 rest', False)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (288, 0))
        self.assertEqual(len(pp.shapes), 3)
        self.assertEqual(pp.shapes[0].type, 'line')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].p2.x, 90)
        self.assertEqual(pp.shapes[0].p2.y, 0)
        self.assertEqual(pp.shapes[1].type, 'line')
        self.assertEqual(pp.shapes[1].p1.x, 90)
        self.assertEqual(pp.shapes[1].p1.y, 0)
        self.assertEqual(pp.shapes[1].p2.x, 180)
        self.assertEqual(pp.shapes[1].p2.y, 0)
        self.assertEqual(pp.shapes[2].type, 'line')
        self.assertEqual(pp.shapes[2].p1.x, 180)
        self.assertEqual(pp.shapes[2].p1.y, 0)
        self.assertEqual(pp.shapes[2].p2.x, 360)
        self.assertEqual(pp.shapes[2].p2.y, 0)


        pp = PathParser(None)

        rest = pp.parse_h('72 72 72 rest', True)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (216.0, 0.0))
        self.assertEqual(len(pp.shapes), 3)
        self.assertEqual(pp.shapes[0].type, 'line')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].p2.x, 90)
        self.assertEqual(pp.shapes[0].p2.y, 0)
        self.assertEqual(pp.shapes[1].type, 'line')
        self.assertEqual(pp.shapes[1].p1.x, 90)
        self.assertEqual(pp.shapes[1].p1.y, 0)
        self.assertEqual(pp.shapes[1].p2.x, 180)
        self.assertEqual(pp.shapes[1].p2.y, 0)
        self.assertEqual(pp.shapes[2].type, 'line')
        self.assertEqual(pp.shapes[2].p1.x, 180)
        self.assertEqual(pp.shapes[2].p1.y, 0)
        self.assertEqual(pp.shapes[2].p2.x, 270)
        self.assertEqual(pp.shapes[2].p2.y, 0)


    def test_parse_v(self):
        """ vertical lineto segments are parsed correctly """

        pp = PathParser(None)

        rest = pp.parse_v('72 144 288 rest', False)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (0, 288))
        self.assertEqual(len(pp.shapes), 3)
        self.assertEqual(pp.shapes[0].type, 'line')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].p2.x, 0)
        self.assertEqual(pp.shapes[0].p2.y, -90)
        self.assertEqual(pp.shapes[1].type, 'line')
        self.assertEqual(pp.shapes[1].p1.x, 0)
        self.assertEqual(pp.shapes[1].p1.y, -90)
        self.assertEqual(pp.shapes[1].p2.x, 0)
        self.assertEqual(pp.shapes[1].p2.y, -180)
        self.assertEqual(pp.shapes[2].type, 'line')
        self.assertEqual(pp.shapes[2].p1.x, 0)
        self.assertEqual(pp.shapes[2].p1.y, -180)
        self.assertEqual(pp.shapes[2].p2.x, 0)
        self.assertEqual(pp.shapes[2].p2.y, -360)


        pp = PathParser(None)

        rest = pp.parse_v('72 72 72 rest', True)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (0.0, 216.0))
        self.assertEqual(len(pp.shapes), 3)
        self.assertEqual(pp.shapes[0].type, 'line')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].p2.x, 0)
        self.assertEqual(pp.shapes[0].p2.y, -90)
        self.assertEqual(pp.shapes[1].type, 'line')
        self.assertEqual(pp.shapes[1].p1.x, 0)
        self.assertEqual(pp.shapes[1].p1.y, -90)
        self.assertEqual(pp.shapes[1].p2.x, 0)
        self.assertEqual(pp.shapes[1].p2.y, -180)
        self.assertEqual(pp.shapes[2].type, 'line')
        self.assertEqual(pp.shapes[2].p1.x, 0)
        self.assertEqual(pp.shapes[2].p1.y, -180)
        self.assertEqual(pp.shapes[2].p2.x, 0)
        self.assertEqual(pp.shapes[2].p2.y, -270)


    def test_parse_c(self):
        """ cubic bezier segments are parsed correctly """

        pp = PathParser(None)

        rest = pp.parse_c('6 12 12 6 18 24 -6 -12 -12 -24 -36 -42 rest', False)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (-36.0, -42.0))
        self.assertEqual(len(pp.shapes), 2)
        self.assertEqual(pp.shapes[0].type, 'bezier')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].control1.x, 8)
        self.assertEqual(pp.shapes[0].control1.y, -15)
        self.assertEqual(pp.shapes[0].control2.x, 15)
        self.assertEqual(pp.shapes[0].control2.y, -8)
        self.assertEqual(pp.shapes[0].p2.x, 23)
        self.assertEqual(pp.shapes[0].p2.y, -30)
        self.assertEqual(pp.shapes[1].type, 'bezier')
        self.assertEqual(pp.shapes[1].p1.x, 23)
        self.assertEqual(pp.shapes[1].p1.y, -30)
        self.assertEqual(pp.shapes[1].control1.x, -8)
        self.assertEqual(pp.shapes[1].control1.y, 15)
        self.assertEqual(pp.shapes[1].control2.x, -15)
        self.assertEqual(pp.shapes[1].control2.y, 30)
        self.assertEqual(pp.shapes[1].p2.x, -45)
        self.assertEqual(pp.shapes[1].p2.y, 53)

        pp = PathParser(None)

        rest = pp.parse_c('6 12 12 6 18 24 -6 -12 -12 -24 -36 -42 rest', True)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (-18.0, -36.0))
        self.assertEqual(len(pp.shapes), 2)
        self.assertEqual(pp.shapes[0].type, 'bezier')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].control1.x, 8)
        self.assertEqual(pp.shapes[0].control1.y, -15)
        self.assertEqual(pp.shapes[0].control2.x, 23)
        self.assertEqual(pp.shapes[0].control2.y, -23)
        self.assertEqual(pp.shapes[0].p2.x, 45)
        self.assertEqual(pp.shapes[0].p2.y, -53)
        self.assertEqual(pp.shapes[1].type, 'bezier')
        self.assertEqual(pp.shapes[1].p1.x, 45)
        self.assertEqual(pp.shapes[1].p1.y, -53)
        self.assertEqual(pp.shapes[1].control1.x, 38)
        self.assertEqual(pp.shapes[1].control1.y, -38)
        self.assertEqual(pp.shapes[1].control2.x, 23)
        self.assertEqual(pp.shapes[1].control2.y, -8)
        self.assertEqual(pp.shapes[1].p2.x, -23)
        self.assertEqual(pp.shapes[1].p2.y, 45)


    def test_parse_s(self):
        """ shorthand bezier segments are parsed correctly """

        pp = PathParser(None)
        pp.prev_cmd = 's'

        rest = pp.parse_s('6 12 18 24 -6 -12 -36 -42 rest', False)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (-36.0, -42.0))
        self.assertEqual(len(pp.shapes), 2)
        self.assertEqual(pp.shapes[0].type, 'bezier')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].control1.x, 0)
        self.assertEqual(pp.shapes[0].control1.y, 0)
        self.assertEqual(pp.shapes[0].control2.x, 8)
        self.assertEqual(pp.shapes[0].control2.y, -15)
        self.assertEqual(pp.shapes[0].p2.x, 23)
        self.assertEqual(pp.shapes[0].p2.y, -30)
        self.assertEqual(pp.shapes[1].type, 'bezier')
        self.assertEqual(pp.shapes[1].p1.x, 23)
        self.assertEqual(pp.shapes[1].p1.y, -30)
        self.assertEqual(pp.shapes[1].control1.x, 38)
        self.assertEqual(pp.shapes[1].control1.y, -45)
        self.assertEqual(pp.shapes[1].control2.x, -8)
        self.assertEqual(pp.shapes[1].control2.y, 15)
        self.assertEqual(pp.shapes[1].p2.x, -45)
        self.assertEqual(pp.shapes[1].p2.y, 53)

        pp = PathParser(None)

        rest = pp.parse_s('6 12 18 24 -6 -12 -36 -42 rest', True)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (-18.0, -18.0))
        self.assertEqual(len(pp.shapes), 2)
        self.assertEqual(pp.shapes[0].type, 'bezier')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].control1.x, 0)
        self.assertEqual(pp.shapes[0].control1.y, 0)
        self.assertEqual(pp.shapes[0].control2.x, 8)
        self.assertEqual(pp.shapes[0].control2.y, -15)
        self.assertEqual(pp.shapes[0].p2.x, 30)
        self.assertEqual(pp.shapes[0].p2.y, -45)
        self.assertEqual(pp.shapes[1].type, 'bezier')
        self.assertEqual(pp.shapes[1].p1.x, 30)
        self.assertEqual(pp.shapes[1].p1.y, -45)
        self.assertEqual(pp.shapes[1].control1.x, 53)
        self.assertEqual(pp.shapes[1].control1.y, -75)
        self.assertEqual(pp.shapes[1].control2.x, 23)
        self.assertEqual(pp.shapes[1].control2.y, -30)
        self.assertEqual(pp.shapes[1].p2.x, -23)
        self.assertEqual(pp.shapes[1].p2.y, 23)


    def test_parse_q(self):
        """ quadratic bezier segments are parsed correctly """

        pp = PathParser(None)

        rest = pp.parse_q('6 12 18 24 -6 -12 -36 -42 rest', False)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (-36.0, -42.0))
        self.assertEqual(len(pp.shapes), 2)
        self.assertEqual(pp.shapes[0].type, 'bezier')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].control1.x, 5)
        self.assertEqual(pp.shapes[0].control1.y, -10)
        self.assertEqual(pp.shapes[0].control2.x, 13)
        self.assertEqual(pp.shapes[0].control2.y, -20)
        self.assertEqual(pp.shapes[0].p2.x, 23)
        self.assertEqual(pp.shapes[0].p2.y, -30)
        self.assertEqual(pp.shapes[1].type, 'bezier')
        self.assertEqual(pp.shapes[1].p1.x, 23)
        self.assertEqual(pp.shapes[1].p1.y, -30)
        self.assertEqual(pp.shapes[1].control1.x, 3)
        self.assertEqual(pp.shapes[1].control1.y, 0)
        self.assertEqual(pp.shapes[1].control2.x, -20)
        self.assertEqual(pp.shapes[1].control2.y, 28)
        self.assertEqual(pp.shapes[1].p2.x, -45)
        self.assertEqual(pp.shapes[1].p2.y, 53)

        pp = PathParser(None)

        rest = pp.parse_q('6 12 18 24 -6 -12 -36 -42 rest', True)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (-18.0, -18.0))
        self.assertEqual(len(pp.shapes), 2)
        self.assertEqual(pp.shapes[0].type, 'bezier')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].control1.x, 5)
        self.assertEqual(pp.shapes[0].control1.y, -10)
        self.assertEqual(pp.shapes[0].control2.x, 15)
        self.assertEqual(pp.shapes[0].control2.y, -25)
        self.assertEqual(pp.shapes[0].p2.x, 30)
        self.assertEqual(pp.shapes[0].p2.y, -45)
        self.assertEqual(pp.shapes[1].type, 'bezier')
        self.assertEqual(pp.shapes[1].p1.x, 30)
        self.assertEqual(pp.shapes[1].p1.y, -45)
        self.assertEqual(pp.shapes[1].control1.x, 25)
        self.assertEqual(pp.shapes[1].control1.y, -35)
        self.assertEqual(pp.shapes[1].control2.x, 8)
        self.assertEqual(pp.shapes[1].control2.y, -13)
        self.assertEqual(pp.shapes[1].p2.x, -23)
        self.assertEqual(pp.shapes[1].p2.y, 23)


    def test_parse_t(self):
        """ shorthand quadratic bezier segments are parsed correctly """

        pp = PathParser(None)

        rest = pp.parse_t('6 12 -6 -12 rest', False)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (-6.0, -12.0))
        self.assertEqual(len(pp.shapes), 2)
        self.assertEqual(pp.shapes[0].type, 'bezier')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].control1.x, 0)
        self.assertEqual(pp.shapes[0].control1.y, 0)
        self.assertEqual(pp.shapes[0].control2.x, 3)
        self.assertEqual(pp.shapes[0].control2.y, -5)
        self.assertEqual(pp.shapes[0].p2.x, 8)
        self.assertEqual(pp.shapes[0].p2.y, -15)
        self.assertEqual(pp.shapes[1].type, 'bezier')
        self.assertEqual(pp.shapes[1].p1.x, 8)
        self.assertEqual(pp.shapes[1].p1.y, -15)
        self.assertEqual(pp.shapes[1].control1.x, 13)
        self.assertEqual(pp.shapes[1].control1.y, -25)
        self.assertEqual(pp.shapes[1].control2.x, 8)
        self.assertEqual(pp.shapes[1].control2.y, -15)
        self.assertEqual(pp.shapes[1].p2.x, -8)
        self.assertEqual(pp.shapes[1].p2.y, 15)

        pp = PathParser(None)

        rest = pp.parse_t('6 12 -6 -12 rest', True)

        self.assertEqual(rest, 'rest')
        self.assertEqual(pp.start_point, (0.0, 0.0))
        self.assertEqual(pp.cur_point, (-0.0, -0.0))
        self.assertEqual(len(pp.shapes), 2)
        self.assertEqual(pp.shapes[0].type, 'bezier')
        self.assertEqual(pp.shapes[0].p1.x, 0)
        self.assertEqual(pp.shapes[0].p1.y, 0)
        self.assertEqual(pp.shapes[0].control1.x, 0)
        self.assertEqual(pp.shapes[0].control1.y, 0)
        self.assertEqual(pp.shapes[0].control2.x, 3)
        self.assertEqual(pp.shapes[0].control2.y, -5)
        self.assertEqual(pp.shapes[0].p2.x, 8)
        self.assertEqual(pp.shapes[0].p2.y, -15)
        self.assertEqual(pp.shapes[1].type, 'bezier')
        self.assertEqual(pp.shapes[1].p1.x, 8)
        self.assertEqual(pp.shapes[1].p1.y, -15)
        self.assertEqual(pp.shapes[1].control1.x, 13)
        self.assertEqual(pp.shapes[1].control1.y, -25)
        self.assertEqual(pp.shapes[1].control2.x, 10)
        self.assertEqual(pp.shapes[1].control2.y, -20)
        self.assertEqual(pp.shapes[1].p2.x, 0)
        self.assertEqual(pp.shapes[1].p2.y, 0)


    def test_fzz(self):
        """ The parser loads fzz files correctly """

        design = self.load_file('sharePower33.fzz')

        self.assertEqual(len(design.components.components), 2)

        cpt = design.components.components['5369801f2bc46a8d540d4f863544ec31']
        self.assertTrue(len(cpt.symbols[0].bodies[0].pins) > 0)

########NEW FILE########
__FILENAME__ = geda_commands_t
﻿#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The geda parser test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from unittest import TestCase

from upconvert.parser import geda_commands


class GEDACommandTests(TestCase):

    def setUp(self):
        self.command = geda_commands.GEDACommand()
        self.param = geda_commands.GEDAParameter('test')
        self.style_param = geda_commands.GEDAStyleParameter('test')
        self.extra_param = geda_commands.GEDAExtraParameter('test')

        self.command.TYPE = 'X'
        self.command.PARAMETERS = (self.param, self.style_param)
        self.command.EXTRA_PARAMETERS = (self.extra_param,)

    def test_line_command_parameters(self):
        """ Testing line command parameters """
        parameter_names = [
            "x1",
            "y1",
            "x2",
            "y2",
            "style_color",
            "style_width",
            "style_capstyle",
            "style_dashstyle",
            "style_dashlength",
            "style_dashspace",
        ]

        line_command = geda_commands.GEDALineCommand()

        self.assertEqual(
            sorted([p.name for p in line_command.PARAMETERS]),
            sorted(parameter_names)
        )

    def test_getting_parameters(self):
        """ Test getting list of all parameters """
        self.assertEqual(sorted([
                self.param,
                self.style_param,
                self.extra_param,
            ]),
            sorted(self.command.parameters())
        )

    def test_getting_style_keywords(self):
        """ Test getting only style keywords. """
        self.assertEqual(
            ['style_test'],
            self.command.get_style_keywords()
        )

    def test_getting_style_keywords_without_parameters(self):
        """ Test getting style keywords with no parameters """
        self.assertEqual(
            [],
            geda_commands.GEDACommand().get_style_keywords()
        )

    def test_updating_default_kwargs_with_empty_dict(self):
        """ Test updating default keywords with empty dictionary """
        defaults = self.command.update_default_kwargs(**{})
        self.assertEqual(
            sorted(['test', 'style_test', 'extra_test']),
            sorted(defaults.keys())
        )

    def test_updating_default_kwargs(self):
        """ Test updating default keywords with valid dictionary """
        defaults = self.command.update_default_kwargs(**{
            'test': 'test_value',
        })
        self.assertEqual(
            sorted(['test', 'style_test', 'extra_test']),
            sorted(defaults.keys())
        )
        self.assertEquals(defaults['test'], 'test_value')
        self.assertEquals(defaults['style_test'], None)
        self.assertEquals(defaults['extra_test'], None)

    def test_generated_command_with_default_parameters(self):
        """ Test generating GEDA command with default parameters """
        command = self.command.generate_command(**{})
        self.assertEquals(len(command), 1)
        self.assertEquals(
            command[0], 
            "X None None"
        )

    def test_generated_command_with_set_parameters(self):
        """ Test generating GEDA command with custom values for parameters """
        command = self.command.generate_command(**{
            'test': 1,
            'style_test': 5,
            'extra_test': 10
        })
        self.assertEquals(len(command), 1)
        self.assertEquals(
            command[0], 
            "X 1 5"
        )

########NEW FILE########
__FILENAME__ = geda_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The geda parser test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
from os.path import dirname, join
from functools import wraps
from unittest import TestCase
import json
import StringIO
from tempfile import mkstemp

import upconvert.core.design
import upconvert.core.shape
from upconvert.core.shape import Point
from upconvert.parser.geda import GEDA, GEDAError, GEDAText

TEST_DIR = join(dirname(__file__), '..', '..', '..', 'test', 'geda')


_cache = {} # filename -> Design

def get_design(filename):
    if filename not in _cache:
        _cache[filename] = GEDA().parse(join(TEST_DIR, filename))
    return _cache[filename]


def use_file(filename):
    """ Return a decorator which will parse a kicad file
    before running the test. """

    def decorator(test_method):
        """ Add params to decorator function. """

        @wraps(test_method)
        def wrapper(self):
            """ Parse file then run test. """
            self.design = get_design(filename)
            test_method(self)

        return wrapper

    return decorator


class GEDAEmpty(TestCase):
    """ The tests of a blank geda parser """

    def test_create_new_geda_parser(self):
        """ Test creating an empty parser. """
        parser = GEDA()
        assert parser != None


class GEDATextTests(TestCase):

    def test_adding_license_text(self):
        """ Test adding license text to design from GEDAText """
        geda_text = GEDAText('BSD', attribute='use_license')
        parser = GEDA()
        design = upconvert.core.design.Design()
        parser.add_text_to_design(design, geda_text)

        self.assertEquals(
            design.design_attributes.metadata.license,
            'BSD'
        )

    def test_adding_attribute_to_design(self):
        """ Add regular attribute to design from GEDAText """
        geda_text = GEDAText('some text', attribute='test_attr')
        parser = GEDA()
        design = upconvert.core.design.Design()
        parser.add_text_to_design(design, geda_text)

        self.assertEquals(
            design.design_attributes.attributes['test_attr'],
            'some text'
        )

class GEDATestCase(TestCase):

    def setUp(self):
        """
        Set up a new GEDA parser with simplified setting for easier
        testing. The scale factor is 10 and the origin is set to
        (0, 0) for easier calculation of correct/converted values.
        """
        self.geda_parser = GEDA()
        ## for easier validation
        self.geda_parser.SCALE_FACTOR = 10
        self.geda_parser.set_offset(upconvert.core.shape.Point(0, 0))

    def test_parsing_invalid_command(self):
        """ Test parsing a line command into a Line object. """
        invalid_string = "L -400 500 440 560 3 0 0 0 -1 -1",
        stream =  StringIO.StringIO(invalid_string)
        self.assertRaises(
            GEDAError,
            self.geda_parser._parse_command,
            stream
        )


class GEDALineParsingTests(GEDATestCase):

    def test_parsing_lines_from_command(self):
        """ Test parsing a line command into a Line object. """
        test_strings = [
            "L 40800 46600 45700 46600 3 0 0 0 -1 -1",
            "L 42300 45900 42900 45500 3 0 0 0 -1 -1",
            "L -400 500 440 560 3 0 0 0 -1 -1",
        ]

        for line_string in test_strings:
            typ, params =  self.geda_parser._parse_command(
                StringIO.StringIO(line_string)
            )
            self.assertEquals(typ, 'L')
            line_obj = self.geda_parser._parse_L(None, params)
            self.assertEquals(line_obj.type, 'line')
            self.assertEquals(
                line_obj.p1.x,
                params['x1']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                line_obj.p1.y,
                params['y1']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                line_obj.p2.x,
                params['x2']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                line_obj.p2.y,
                params['y2']/self.geda_parser.SCALE_FACTOR
            )

    def test_parsing_mirrored_lines_from_command(self):
        test_strings = [
            "L 40800 46600 45700 46600 3 0 0 0 -1 -1",
            "L 42300 45900 42900 45500 3 0 0 0 -1 -1",
            "L -400 500 440 560 3 0 0 0 -1 -1",
        ]
        for line_string in test_strings:
            typ, params =  self.geda_parser._parse_command(
                StringIO.StringIO(line_string)
            )
            self.assertEquals(typ, 'L')
            params['mirror'] = True
            line_obj = self.geda_parser._parse_L(None, params)
            self.assertEquals(line_obj.type, 'line')
            self.assertEquals(
                line_obj.p1.x,
                0-params['x1']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                line_obj.p1.y,
                params['y1']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                line_obj.p2.x,
                0-params['x2']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                line_obj.p2.y,
                params['y2']/self.geda_parser.SCALE_FACTOR
            )


class GEDATextParsingTest(GEDATestCase):

    def test_parsing_single_line_text_label(self):
        """ Test extracting text commands from input stream. """

        valid_text = """T 16900 35800 3 10 1 0 0 0 1
Text string!"""

        text_stream = StringIO.StringIO(valid_text)
        typ, params =  self.geda_parser._parse_command(text_stream)
        self.assertEquals(typ, 'T')
        geda_text = self.geda_parser._parse_T(text_stream, params)

        self.assertEquals(geda_text.attribute, None)
        self.assertEquals(geda_text.content, "Text string!")

    def test_parsing_multi_line_text_label(self):
        valid_text = """T 16900 35800 3 10 1 0 0 0 4
Text string!
And more ...
and more ...
text!"""
        text_stream = StringIO.StringIO(valid_text)
        typ, params =  self.geda_parser._parse_command(text_stream)
        self.assertEquals(typ, 'T')
        geda_text = self.geda_parser._parse_T(text_stream, params)

        text = """Text string!
And more ...
and more ...
text!"""

        self.assertEquals(geda_text.attribute, None)
        self.assertEquals(geda_text.content, text)


class GEDAEnvironmentParsingTests(GEDATestCase):

    def test_parsing_environment_with_attributes(self):
        """ Tests parsing attribute environments and enclosed attribute
            commands.
        """
        no_env = "P 100 600 200 600 1 0 0"
        stream = StringIO.StringIO(no_env)
        attributes = self.geda_parser._parse_environment(stream)
        self.assertEquals(attributes, None)
        self.assertEquals(stream.tell(), 0)

        valid_env = """{
T 150 650 5 8 1 1 0 6 1
pinnumber=3
T 150 650 5 8 0 1 0 6 1
pinseq=3
T 250 500 9 16 0 1 0 0 1
pinlabel=+=?
T 150 550 5 8 1 1 0 8 1
sometype=in
}"""
        expected_attributes = {
            '_pinnumber': '3',
            '_pinseq': '3',
            '_pinlabel': '+=?',
            'sometype': 'in',
        }
        stream = StringIO.StringIO(valid_env)
        attributes = self.geda_parser._parse_environment(stream)

        self.assertEquals(attributes, expected_attributes)

    def test_parsing_environment_with_invalid_multi_line_attribute(self):
        """ Test parsing environemt with invalid multi-line attribute """
        no_env = "P 100 600 200 600 1 0 0"
        stream = StringIO.StringIO(no_env)
        attributes = self.geda_parser._parse_environment(stream)
        self.assertEquals(attributes, None)
        self.assertEquals(stream.tell(), 0)


class GEDAAngleConversionTests(GEDATestCase):
    """ The tests of the geda parser """
    # pylint: disable=W0212

    def test_conv_angle(self):
        """ Test converting angles from degrees to pi radians. """
        angles = [
            (0, 0),
            (90, 1.5),
            (180, 1.0),
            (220, 0.8),
            (270, 0.5),
            (510, 1.2),
        ]

        for angle, expected in angles:
            converted = self.geda_parser.conv_angle(angle)
            self.assertEquals(expected, converted)


class GEDATests(GEDATestCase):

    def get_all_symbols(self, path):
        symbols = set()
        for dummy, dummy, filenames in os.walk(path):
            for filename in filenames:
                if filename.endswith('.sym'):
                    symbols.add(filename.lower())
        return symbols

    def test_constructor(self):
        """
        Test constructor with different parameters to ensure
        that symbols and symbol directories are handled correctly.
        """
        ## get number of symbols in symbols directory
        symbols = self.get_all_symbols('upconvert/library/geda')
        geda_parser = GEDA(['upconvert/library/geda'])
        self.assertEquals(len(geda_parser.known_symbols), len(symbols))

        geda_parser = GEDA([
            './test/geda/simple_example/symbols',
            '/invalid/dir/gEDA',
        ])

        self.assertEquals(len(geda_parser.known_symbols), len(symbols))
        self.assertEquals(
            geda_parser.known_symbols['opamp'],
            './test/geda/simple_example/symbols/opamp.sym'
        )

        geda_parser = GEDA([
            'test/geda/simple_example/symbols',
            '/invalid/dir/gEDA',
        ])

        self.assertTrue('title-b' in geda_parser.known_symbols)

        geda_parser = GEDA()
        self.assertTrue('title-b' in geda_parser.known_symbols)


class GEDATitleParsingTest(GEDATestCase):

    def test_parse_title_frame(self):
        """ Test parsing title frame components """
        title_frames = {
            'title-e': (44000, 34000),
            'title-bordered-e': (44000, 34000),
            'title-bordered-d': (34000, 22000),
            'title-bordered-a': (11000, 8500),
            'title-bordered-c': (22000, 17000),
            'title-bordered-b': (17000, 11000),
            'title-a0': (46800, 33100),
            'title-a1': (33100, 23300),
            'title-a2': (23300, 16500),
            'title-a3': (16500, 11600),
            'title-a4': (11600, 8200),
            'title-a0-2': (46800, 33100),
            'title-a1-2': (33100, 23300),
            'title-a2-2': (23300, 16500),
            'title-a3-2': (16500, 11600),
            'title-a4-2': (11600, 8200),
            'title-d': (34000, 22000),
            'title-b': (17000, 11000),
            'title-c': (22000, 17000),
            'title-a': (11000, 8500),
            'title-bordered-a4': (11600, 8200),
            'title-bordered-a1': (33100, 23300),
            'title-bordered-a0': (46800, 33100),
            'title-bordered-a3': (16500, 11600),
            'title-bordered-a2': (23300, 16500),
            'title-dg-1': (17000, 11000),
            'title-small-square': (7600, 6900),
            'titleblock': (7500, 1800),
            'titleblock1': (11000, 8500),
            'titleblock2': (22000, 17000),
            'titleblock3': (33000, 25500),
            'titleblock4': (44000, 34000),
            'titleblock_a4-1': (17000, 12000),
            'title-b-nameonedge': (26600, 17000),
            'title-b-cibolo': (26600, 17000),
            'title-block': (7500, 1800),
        }

        params = {
            'x': 3200,
            'y': 3109,
        }

        geda_parser = GEDA()
        for name, filename in geda_parser.known_symbols.items():
            if name.startswith('title'):
                params['basename'] = name

                ## reset geda parser
                geda_parser.frame_width = 0
                geda_parser.frame_height = 0

                geda_parser.design = upconvert.core.design.Design()
                geda_parser._parse_title_frame(params)

                self.assertEquals(geda_parser.offset.x, params['x'])
                self.assertEquals(geda_parser.offset.y, params['y'])

                self.assertEquals(
                    geda_parser.frame_width,
                    title_frames[name][0]
                )
                self.assertEquals(
                    geda_parser.frame_height,
                    title_frames[name][1]
                )

        ## check that method does not break when invalid file is passed
        params['basename'] = 'invalid_symbol.sym'

        geda_parser = GEDA()
        geda_parser._parse_title_frame(params)

        self.assertEquals(geda_parser.offset.x, params['x'])
        self.assertEquals(geda_parser.offset.y, params['y'])

        ## check if default is set correctly
        self.assertEquals(geda_parser.frame_width, 46800)
        self.assertEquals(geda_parser.frame_height, 34000)


class GEDABooleanConversionTests(GEDATestCase):

    def test_converting_boolean_values_equal_to_True(self):
        """
        Tests converting various values equal to ``True`` to boolean.
        """
        for test_bool in ['1', 1, True, 'true']:
            self.assertEquals('true', self.geda_parser.conv_bool(test_bool))

    def test_converting_boolean_values_equal_to_False(self):
        """
        Tests converting various values equal to ``False`` to boolean.
        """
        for test_bool in ['0', 0, False, 'false']:
            self.assertEquals('false', self.geda_parser.conv_bool(test_bool))


class GEDAScaleConversionTests(GEDATestCase):

    def test_converting_mils_to_pixel_scale(self):
        """ Test converting MILS to pixels. """
        test_mils = [
            (2, 0),
            (100, 10),
            (3429, 342),
            (0, 0),
            (-50, -5),
            (-1238, -123),
        ]
        self.geda_parser.set_offset(upconvert.core.shape.Point(0, 0))
        for mils, expected in test_mils:
            self.assertEquals(
                self.geda_parser.y_to_px(mils),
                expected
            )
            self.assertEquals(
                self.geda_parser.x_to_px(mils),
                expected
            )


class GEDANetTests(GEDATestCase):

    def test_calculate_nets(self):
        """ Test calculating and creating nets from net segment
            commands.
        """
        net_sample = """N 52100 44400 54300 44400 4
N 54300 44400 54300 46400 4
{
T 54300 44400 5 8 0 1 0 8 1
netname=test
}
N 53200 45100 53200 43500 4
N 55000 44400 56600 44400 4
{
T 55000 44400 5 8 0 1 0 8 1
netname=another name
}
N 55700 45100 55700 44400 4
{
T 55700 45100 5 8 0 1 0 8 1
netname=another name
}
N 55700 44400 55700 43500 4"""
        stream = StringIO.StringIO(net_sample)
        self.geda_parser.parse_schematic(stream)
        design = self.geda_parser.design

        ## check nets from design
        self.assertEquals(len(design.nets), 3)

        self.assertEqual(
            sorted([net.net_id for net in design.nets]),
            sorted(['another name', 'test', '5320a4350'])
        )
        self.assertEqual(
            sorted([net.attributes.get('name', None) for net in design.nets]),
            sorted(['another name', 'test', None])
        )

        sorted_nets = {}
        for net in design.nets:
            sorted_nets[len(net.points)] = net.points

        self.assertEquals(sorted_nets.keys(), [2, 3, 5])

        points_n1 = sorted_nets[2]
        points_n2 = sorted_nets[3]
        points_n3 = sorted_nets[5]

        self.assertEqual(
            sorted(points_n1.keys()),
            sorted(['5320a4510', '5320a4350'])
        )
        self.assertEquals(
            points_n1['5320a4510'].connected_points,
            ['5320a4350']
        )
        self.assertEquals(
            points_n1['5320a4350'].connected_points,
            ['5320a4510']
        )


        self.assertEquals(
            sorted(points_n2.keys()),
            sorted([
                '5210a4440', '5430a4640', '5430a4440'
            ])
        )
        self.assertEquals(
            sorted(points_n2['5210a4440'].connected_points),
            ['5430a4440']
        )
        self.assertEquals(
            sorted(points_n2['5430a4640'].connected_points),
            ['5430a4440']
        )
        self.assertEquals(
            sorted(points_n2['5430a4440'].connected_points),
            ['5210a4440', '5430a4640']
        )

        self.assertEquals(
            sorted(points_n3.keys()),
            sorted([
                '5500a4440', '5660a4440', '5570a4510',
                '5570a4440', '5570a4350'
            ])
        )
        self.assertEquals(
            sorted(points_n3['5500a4440'].connected_points),
            ['5570a4440'],
        )
        self.assertEquals(
            sorted(points_n3['5660a4440'].connected_points),
            ['5570a4440'],
        )
        self.assertEquals(
            sorted(points_n3['5570a4510'].connected_points),
            ['5570a4440'],
        )
        self.assertEquals(
            sorted(points_n3['5570a4440'].connected_points),
            ['5500a4440', '5570a4350', '5570a4510', '5660a4440'],
        )
        self.assertEquals(
            sorted(points_n3['5570a4350'].connected_points),
            ['5570a4440'],
        )

    def test_complex_net_example_with_test_file(self):
        """ Test complex net example with test file. """

        net = """v 20110115 2
C 40000 40000 0 0 0 title-B.sym
N 45300 47000 45400 47000 4
{
T 45300 47000 5 10 1 1 0 0 1
netname=short_test
}
N 44900 46500 45400 46500 4
{
T 44900 46500 5 10 1 1 0 0 1
netname=long test
}
N 48500 48500 48500 46500 4
N 48500 46500 52500 46500 4
N 50400 46500 50400 48500 4
N 50400 48500 52000 48500 4
{
T 50400 48500 5 10 1 1 0 0 1
netname=simple
}
N 51100 48500 51100 49900 4
N 51100 49900 54100 49900 4
N 42000 43000 48500 43000 4
{
T 42000 43000 5 10 1 1 0 0 1
netname=advanced
}
N 48500 43000 48500 45100 4
N 48500 45100 50500 45100 4
N 45300 43000 45300 44400 4
N 45300 44400 42000 44400 4
{
T 45300 44400 5 10 1 1 0 0 1
netname=more_advanced
}
N 48500 44400 50500 44400 4
N 43000 44400 43000 43000 4"""

        net_handle, net_schematic = mkstemp()
        os.write(net_handle, net)

        design = self.geda_parser.parse(net_schematic)

        self.assertEquals(len(design.nets), 4)

        net_names = [net.net_id for net in design.nets]
        self.assertEquals(
            sorted(net_names),
            sorted(['advanced', 'long test', 'short_test', 'simple']),
        )

    @use_file('10M_receiver.sch')
    def test_single_point_nets(self):
        """ Test nets created by overlapping pins."""

        net = [n for n in self.design.nets if n.net_id == '400a1170'][0]
        self.assertEqual(list(net.points), ['400a1170'])
        point = net.points.values()[0]
        self.assertEqual(len(point.connected_components), 2)
        self.assertEqual(set((cc.instance_id, cc.pin_number)
                             for cc in point.connected_components),
                         set([('C153', '1'), ('gnd-1-30', '1')]))


class GEDABusParsingTests(GEDATestCase):

    def test_parsing_buses_from_command(self):
        """ Tests parsing bus commands from stream, extracting
            busripper components and substituting the corresponding
            net segments.
        """
        bus_data = """U 800 0 800 1000 10 -1
N 1000 800 1200 800 4
C 1000 800 1 180 0 busripper-1.sym
{
T 1000 400 5 8 0 0 180 0 1
device=none
}
N 600 400 300 400 4
C 600 400 1 270 0 busripper-1.sym
{
T 1000 400 5 8 0 0 270 0 1
device=none
}"""
        stream = StringIO.StringIO(bus_data)
        self.geda_parser.parse_schematic(stream)
        design = self.geda_parser.design

        ## check nets from design
        self.assertEquals(len(design.nets), 1)

        point_ids = design.nets[0].points.keys()
        expected_points = [
            '80a100', '80a0', '120a80', '100a80', '80a60',
            '30a40', '60a40', '80a20'
        ]

        self.assertEquals(
            sorted(point_ids),
            sorted(expected_points),
        )


class GEDAEmbeddedSectionTests(GEDATestCase):

    def test_skip_embedded_section(self):
        """ Tests skipping an embedded section (enclosed in '[' & ']')."""
        data = """C 1000 800 1 180 0 busripper-1.sym\n"""
        stream = StringIO.StringIO(data)
        self.assertEquals(stream.tell(), 0)

        self.geda_parser.skip_embedded_section(stream)
        self.assertEquals(stream.tell(), 0)

        data += """[
T 1000 400 5 8 0 0 180 0 1
device=none
]\n"""
        stream = StringIO.StringIO(data)
        self.assertEquals(stream.tell(), 0)

        self.geda_parser._parse_command(stream)
        self.geda_parser.skip_embedded_section(stream)
        self.assertEquals(stream.tell(), len(data))


class GEDASegmentParsingTests(GEDATestCase):

    def test_parsing_simple_segment_from_command(self):
        """ Tests parsing a net segment command into NetPoints."""
        simple_segment = "N 47300 48500 43500 48500 4"

        self.geda_parser.segments = set()
        self.geda_parser.net_points = dict()
        self.geda_parser.net_names = dict()

        stream = StringIO.StringIO(simple_segment)
        typ, params = self.geda_parser._parse_command(stream)
        self.assertEquals(typ, 'N')
        self.geda_parser._parse_N(stream, params)

        np_a, np_b = self.geda_parser.segments.pop()
        self.assertEquals(np_a.point_id, '4730a4850')
        self.assertEquals(np_a.x, 4730)
        self.assertEquals(np_a.y, 4850)

        self.assertEquals(np_b.point_id, '4350a4850')
        self.assertEquals(np_b.x, 4350)
        self.assertEquals(np_b.y, 4850)

        expected_points = [(4730, 4850), (4350, 4850)]
        for x, y in expected_points:
            point = self.geda_parser.net_points[(x, y)]
            self.assertEquals(point.point_id, '%da%d' % (x, y))
            self.assertEquals(point.x, x)
            self.assertEquals(point.y, y)

    def test_parsing_complex_segment_from_command(self):
        """ Tests parsing a complex net segment command into NetPoints."""
        complex_segment = """N 47300 48500 43500 48500 4
{
T 43800 48300 5 10 1 1 0 0 1
netname=+_1
}"""
        self.geda_parser.segments = set()
        self.geda_parser.net_points = dict()
        self.geda_parser.net_names = dict()

        stream = StringIO.StringIO(complex_segment)
        typ, params = self.geda_parser._parse_command(stream)
        self.assertEquals(typ, 'N')
        self.geda_parser._parse_N(stream, params)

        expected_points = [(4730, 4850), (4350, 4850)]
        for x, y in expected_points:
            point = self.geda_parser.net_points[(x, y)]
            self.assertEquals(point.point_id, '%da%d' % (x, y))
            self.assertEquals(point.x, x)
            self.assertEquals(point.y, y)


class GEDAArcParsingTests(GEDATestCase):

    def test_parse_arc_of_quarter_circle(self):
        """ Tests parsing an arc command into an Arc object. """
        typ, params =  self.geda_parser._parse_command(
            StringIO.StringIO("A 41100 48500 1900 0 90 3 0 0 0 -1 -1")
        )
        self.assertEquals(typ, 'A')
        arc_obj = self.geda_parser._parse_A(None, params)
        self.assertEquals(arc_obj.type, 'arc')
        self.assertEquals(arc_obj.x, 4110)
        self.assertEquals(arc_obj.y, 4850)
        self.assertEquals(arc_obj.radius, 190)
        self.assertEquals(arc_obj.start_angle, 0.0)
        self.assertEquals(arc_obj.end_angle, 1.5)
        ## mirrored arc
        params['mirror'] = True
        arc_obj = self.geda_parser._parse_A(None, params)
        self.assertEquals(arc_obj.x, -4110)
        self.assertEquals(arc_obj.y, 4850)
        self.assertEquals(arc_obj.radius, 190)
        self.assertEquals(arc_obj.start_angle, 1.5)
        self.assertEquals(arc_obj.end_angle, 1.0)

    def test_parse_arc_with_sweepangle_200(self):
        """ Test parsing arc with sweepangle 200 """
        typ, params =  self.geda_parser._parse_command(
            StringIO.StringIO("A 44300 49800 500 30 200 3 0 0 0 -1 -1")
        )
        self.assertEquals(typ, 'A')
        arc_obj = self.geda_parser._parse_A(None, params)
        self.assertEquals(arc_obj.type, 'arc')
        self.assertEquals(arc_obj.x, 4430)
        self.assertEquals(arc_obj.y, 4980)
        self.assertEquals(arc_obj.radius, 50)
        self.assertEquals(arc_obj.start_angle, 1.8)
        self.assertEquals(arc_obj.end_angle, 0.7)
        ## mirrored arc
        params['mirror'] = True
        arc_obj = self.geda_parser._parse_A(None, params)
        self.assertEquals(arc_obj.type, 'arc')
        self.assertEquals(arc_obj.x, -4430)
        self.assertEquals(arc_obj.y, 4980)
        self.assertEquals(arc_obj.radius, 50)
        self.assertEquals(arc_obj.start_angle, 0.3)
        self.assertEquals(arc_obj.end_angle, 1.2)

    def test_parse_arc_with_sweepangle_291(self):
        """ Test parsing arc with sweepangle 291 """
        typ, params =  self.geda_parser._parse_command(
            StringIO.StringIO("A 45100 48400 700 123 291 3 0 0 0 -1 -1")
        )
        self.assertEquals(typ, 'A')
        arc_obj = self.geda_parser._parse_A(None, params)
        self.assertEquals(arc_obj.type, 'arc')
        self.assertEquals(arc_obj.x, 4510)
        self.assertEquals(arc_obj.y, 4840)
        self.assertEquals(arc_obj.radius, 70)
        self.assertEquals(arc_obj.start_angle, 1.3)
        self.assertEquals(arc_obj.end_angle, 1.7)

    def test_parse_arc_with_sweepangle_larger_full_circle(self):
        """ Test parsing arc larger then full circle """
        typ, params =  self.geda_parser._parse_command(
            StringIO.StringIO("A 45100 48400 700 123 651 3 0 0 0 -1 -1")
        )
        self.assertEquals(typ, 'A')
        arc_obj = self.geda_parser._parse_A(None, params)
        self.assertEquals(arc_obj.type, 'arc')
        self.assertEquals(arc_obj.x, 4510)
        self.assertEquals(arc_obj.y, 4840)
        self.assertEquals(arc_obj.radius, 70)
        self.assertEquals(arc_obj.start_angle, 1.3)
        self.assertEquals(arc_obj.end_angle, 1.7)

    def test_parse_arc_with_large_sweepangle(self):
        """ Test parsing arc with large sweepangle """
        typ, params =  self.geda_parser._parse_command(
            StringIO.StringIO("A 0 0 500 30 200 3 0 0 0 -1 -1")
        )
        self.assertEquals(typ, 'A')
        params['mirror'] = True
        arc_obj = self.geda_parser._parse_A(None, params)
        self.assertEquals(arc_obj.type, 'arc')
        self.assertEquals(arc_obj.x, 0)
        self.assertEquals(arc_obj.y, 0)
        self.assertEquals(arc_obj.radius, 50)
        ## mirrored to 310 (0.3) + 200 = 510 (1.2)
        self.assertEquals(arc_obj.start_angle, 0.3)
        self.assertEquals(arc_obj.end_angle, 1.2)


class GEDABoxParsingTests(GEDATestCase):

    def test_parsing_boxes_from_command(self):
        """ Tests parsing box commands into Rectangle objects. """
        test_strings = [
            "B 41700 42100 2900 1500 3 0 0 0 -1 -1 0 -1 -1 -1 -1 -1",
            "B 46100 41100 1200 2600 3 0 0 0 -1 -1 0 -1 -1 -1 -1 -1",
        ]

        for rect_string in test_strings:
            typ, params =  self.geda_parser._parse_command(
                StringIO.StringIO(rect_string)
            )
            self.assertEquals(typ, 'B')
            rect_obj = self.geda_parser._parse_B(None, params)
            self.assertEquals(rect_obj.type, 'rectangle')
            self.assertEquals(
                rect_obj.x,
                params['x']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                rect_obj.y,
                (params['y']+params['height'])/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                rect_obj.width,
                params['width']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                rect_obj.height,
                params['height']/self.geda_parser.SCALE_FACTOR
            )

    def test_parsing_boxes_from_command_with_mirror_flag(self):
        """ Test parsing boxes from command with mirror flag """
        mirror_test_strings = [
            (
                "B 100 300 300 500 3 0 0 0 -1 -1 0 -1 -1 -1 -1 -1",
                {'x': -40, 'y': 80, 'width': 30, 'height': 50},
            ),
            (
                "B -200 400 500 200 3 0 0 0 -1 -1 0 -1 -1 -1 -1 -1",
                {'x': -30, 'y': 60, 'width': 50, 'height': 20},
            )
        ]
        ## check mirrored rectangle
        for rect_string, result_dict in mirror_test_strings:
            typ, params =  self.geda_parser._parse_command(
                StringIO.StringIO(rect_string)
            )
            params['mirror'] = True
            rect_obj = self.geda_parser._parse_B(None, params)
            self.assertEquals(rect_obj.type, 'rectangle')
            self.assertEquals(rect_obj.x, result_dict['x'])
            self.assertEquals(rect_obj.y, result_dict['y'])
            self.assertEquals(rect_obj.width, result_dict['width'])
            self.assertEquals(rect_obj.height, result_dict['height'])


class GEDAPathParsingTests(GEDATestCase):

    def test_parsing_invalid_path(self):
        """ Test parsing a line command into a Line object. """
        invalid_example = """H 3 0 0 0 -1 -1 1 -1 -1 -1 -1 -1 2
M 510,240
X 510,240
z"""
        stream =  StringIO.StringIO(invalid_example)
        typ, params = self.geda_parser._parse_command(stream)
        self.assertRaises(
            GEDAError,
            self.geda_parser._parse_H,
            stream,
            params
        )

    def test_parsing_path_with_first_element_not_M(self):
        """ Test parsing a line command into a Line object. """
        invalid_example = """H 3 0 0 0 -1 -1 1 -1 -1 -1 -1 -1 2
L 510,240
z"""
        stream =  StringIO.StringIO(invalid_example)
        typ, params = self.geda_parser._parse_command(stream)
        self.assertRaises(
            GEDAError,
            self.geda_parser._parse_H,
            stream,
            params
        )

    def test_parse_simple_path_command(self):
        """ Tests parsing path commands into lists of shapes. """
        simple_example = """H 3 0 0 0 -1 -1 1 -1 -1 -1 -1 -1 5
M 510,240
L 601,200
L 555,295
L 535,265
z"""

        stream = StringIO.StringIO(simple_example)
        typ, params = self.geda_parser._parse_command(stream)
        self.assertEquals(typ, 'H')

        shapes = self.geda_parser._parse_H(stream, params)

        expected_results = [
            ['line', (51, 24), (60, 20)],
            ['line', (60, 20), (55, 29)],
            ['line', (55, 29), (53, 26)],
            ['line', (53, 26), (51, 24)],
        ]

        self.assertEquals(len(shapes), 4)

        for shape, expected in zip(shapes, expected_results):
            self.assertEquals(shape.type, expected[0])
            start_x, start_y = expected[1]
            self.assertEquals(shape.p1.x, start_x)
            self.assertEquals(shape.p1.y, start_y)
            end_x, end_y = expected[2]
            self.assertEquals(shape.p2.x, end_x)
            self.assertEquals(shape.p2.y, end_y)

    def test_parse_simple_path_command_with_mirrored_flag(self):
        """ Test parsing simple path command with mirror flag set """
        simple_example = """H 3 0 0 0 -1 -1 1 -1 -1 -1 -1 -1 5
M 510,240
L 601,200
L 555,295
L 535,265
z"""
        stream = StringIO.StringIO(simple_example)
        typ, params = self.geda_parser._parse_command(stream)
        params['mirror'] = True
        shapes = self.geda_parser._parse_H(stream, params)

        expected_results = [
            ['line', (-51, 24), (-60, 20)],
            ['line', (-60, 20), (-55, 29)],
            ['line', (-55, 29), (-53, 26)],
            ['line', (-53, 26), (-51, 24)],
        ]

        self.assertEquals(len(shapes), 4)

        for shape, expected in zip(shapes, expected_results):
            self.assertEquals(shape.type, expected[0])
            start_x, start_y = expected[1]
            self.assertEquals(shape.p1.x, start_x)
            self.assertEquals(shape.p1.y, start_y)
            end_x, end_y = expected[2]
            self.assertEquals(shape.p2.x, end_x)
            self.assertEquals(shape.p2.y, end_y)

    def test_parse_curve_path_command(self):
        """ Test parsing curve path command """
        curve_example = """H 3 0 0 0 -1 -1 0 2 20 100 -1 -1 6
M 100,100
L 500,100
C 700,100 800,275 800,400
C 800,500 700,700 500,700
L 100,700
z"""
        stream = StringIO.StringIO(curve_example)
        typ, params = self.geda_parser._parse_command(stream)
        self.assertEquals(typ, 'H')

        shapes = self.geda_parser._parse_H(stream, params)

        self.assertEquals(len(shapes), 5)

        expected_shapes = ['line', 'bezier', 'bezier', 'line', 'line']
        for shape, expected in zip(shapes, expected_shapes):
            self.assertEquals(shape.type, expected)


class GEDACircleParsingTests(GEDATestCase):

    def test_parse_circles(self):
        """ Tests parsing circle commands into Circle objects. """
        test_strings = [
            "V 49100 48800 900 3 0 0 0 -1 -1 0 -1 -1 -1 -1 -1",
            "V 51200 49000 400 3 0 0 0 -1 -1 0 -1 -1 -1 -1 -1",
        ]

        for circle_string in test_strings:
            typ, params =  self.geda_parser._parse_command(
                StringIO.StringIO(circle_string)
            )
            self.assertEquals(typ, 'V')
            circle_obj = self.geda_parser._parse_V(None, params)
            self.assertEquals(circle_obj.type, 'circle')
            self.assertEquals(
                circle_obj.x,
                params['x']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                circle_obj.y,
                params['y']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                circle_obj.radius,
                params['radius']/self.geda_parser.SCALE_FACTOR
            )

    def test_parse_circles_with_mirror_flag(self):
        """ Test parsing circles with mirror flag set """
        test_strings = [
            "V 49100 48800 900 3 0 0 0 -1 -1 0 -1 -1 -1 -1 -1",
            "V 51200 49000 400 3 0 0 0 -1 -1 0 -1 -1 -1 -1 -1",
        ]
        for circle_string in test_strings:
            typ, params = self.geda_parser._parse_command(
                StringIO.StringIO(circle_string)
            )
            params['mirror'] = True
            self.assertEquals(typ, 'V')
            circle_obj = self.geda_parser._parse_V(None, params)
            self.assertEquals(circle_obj.type, 'circle')
            self.assertEquals(
                circle_obj.x,
                0-params['x']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                circle_obj.y,
                params['y']/self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                circle_obj.radius,
                params['radius']/self.geda_parser.SCALE_FACTOR
            )

class GEDAPinParsingTests(GEDATestCase):

    @staticmethod
    def get_pin_sample():
        """ Get pin command. """
        return """P 100 600 200 600 1 0 0
{
T 150 650 5 8 1 1 0 6 1
pinnumber=3
T 150 650 5 8 0 1 0 6 1
pinseq=3
T 250 500 9 16 0 1 0 0 1
pinlabel=+
T 150 550 5 8 0 1 0 8 1
pintype=in
}"""

    @staticmethod
    def get_reversed_pin():
        """ Get reversed pin command """
        return """P 100 600 200 600 1 0 1
{
T 150 650 5 8 1 1 0 6 1
pinnumber=E
T 150 650 5 8 0 1 0 6 1
pinseq=3
T 150 550 5 8 0 1 0 8 1
pintype=in
}"""

    def test_parse_pin(self):
        """ Tests parsing pin commands into Pin objects. """
        pin_sample = self.get_pin_sample()
        stream = StringIO.StringIO(pin_sample)
        typ, params =  self.geda_parser._parse_command(stream)
        self.assertEquals(typ, 'P')
        pin = self.geda_parser._parse_P(stream, params)

        self.assertEquals(pin.pin_number, '3')
        self.assertEquals(pin.label.text, '+')
        ## null_end
        self.assertEquals(pin.p1.x, 20)
        self.assertEquals(pin.p1.y, 60)
        ## connect_end
        self.assertEquals(pin.p2.x, 10)
        self.assertEquals(pin.p2.y, 60)

    def test_parse_pin_with_mirror_flag(self):
        """ Test parsing a pin command with the mirror flag set."""
        pin_sample = self.get_pin_sample()
        stream = StringIO.StringIO(pin_sample)
        typ, params =  self.geda_parser._parse_command(stream)
        params['mirror'] = True
        pin = self.geda_parser._parse_P(stream, params)

        ## null_end
        self.assertEquals(pin.p1.x, -20)
        self.assertEquals(pin.p1.y, 60)
        ## connect_end
        self.assertEquals(pin.p2.x, -10)
        self.assertEquals(pin.p2.y, 60)

    def test_parse_reversed_pin(self):
        """ Test pin command with reversed order of pin ends. """
        reversed_pin_sample = self.get_reversed_pin()
        stream = StringIO.StringIO(reversed_pin_sample)
        typ, params =  self.geda_parser._parse_command(stream)
        self.assertEquals(typ, 'P')
        pin = self.geda_parser._parse_P(stream, params)

        self.assertEquals(pin.pin_number, 'E')
        self.assertEquals(pin.label, None)
        ## null_end
        self.assertEquals(pin.p1.x, 10)
        self.assertEquals(pin.p1.y, 60)
        ## connect_end
        self.assertEquals(pin.p2.x, 20)
        self.assertEquals(pin.p2.y, 60)

    def test_parse_reversed_pin_with_mirror_flag(self):
        """
        Test parsing pin command with ends in reversed order and
        the mirror flag set.
        """
        reversed_pin_sample = self.get_reversed_pin()
        stream = StringIO.StringIO(reversed_pin_sample)
        typ, params =  self.geda_parser._parse_command(stream)
        params['mirror'] = True
        pin = self.geda_parser._parse_P(stream, params)

        ## null_end
        self.assertEquals(pin.p1.x, -10)
        self.assertEquals(pin.p1.y, 60)
        ## connect_end
        self.assertEquals(pin.p2.x, -20)
        self.assertEquals(pin.p2.y, 60)


class GEDAComponentParsingTests(GEDATestCase):

    def test_parse_command(self):
        """ Test parsing commands from a stream. """
        typ, params = self.geda_parser._parse_command(StringIO.StringIO('{'))
        self.assertEquals(typ, '{')
        self.assertEquals(params, {})

        typ, params = self.geda_parser._parse_command(
            StringIO.StringIO('A 49 34 223 30 90')
        )
        self.assertEquals(typ, 'A')
        self.assertEquals(params, {
            'x': 49,
            'y': 34,
            'radius': 223,
            'startangle': 30,
            'sweepangle': 90,
            'style_color': 3,
            'style_width': 10,
            'style_capstyle': 0,
            'style_dashstyle': 0,
            'style_dashlength': -1,
            'style_dashspace': -1,
        })

        expected_params = {
            'x': 18600,
            'y': 21500,
            'selectable': 1,
            'angle': 0,
            'mirror': 0,
            'basename': 'EMBEDDED555-1',
        }
        string = 'C 18600 21500 1 0 0 EMBEDDED555-1'
        typ, params = self.geda_parser._parse_command(
            StringIO.StringIO(string)
        )
        self.assertEquals(typ, 'C')
        self.assertEquals(params, expected_params)

    def test_parse_component_data(self):
        """ Tests parsing component data from symbol files and embedded
            sections.
        """
        self.geda_parser = GEDA([
            './test/geda/simple_example/symbols',
        ])
        # need to do this to force setup since parse_schematic isn't being run
        self.geda_parser.parse_setup()

        symbol = """v 20110115 2
H 3 0 0 0 -1 -1 1 -1 -1 -1 -1 -1 5
M 510,240
L 601,200
L 555,295
L 535,265
z
H 3 0 0 0 -1 -1 0 2 20 100 -1 -1 6
M 100,100
L 500,100
C 700,100 800,300 800,400
C 800,500 700,700 500,700
L 100,700
z"""
        stream = StringIO.StringIO(symbol)
        component = self.geda_parser.parse_component_data(stream, {
            'basename': 'test.sym',
        })

        self.assertEquals(component.name, 'test')
        self.assertEquals(len(component.symbols), 1)
        self.assertEquals(len(component.symbols[0].bodies), 1)
        self.assertEquals(len(component.symbols[0].bodies[0].shapes), 9)

    def test_parsing_unknown_component(self):
        """ Test parsing unknown component """
        self.geda_parser.design = upconvert.core.design.Design()
        stream = StringIO.StringIO('C 18600 21500 1 0 0 invalid.sym')
        component, instance = self.geda_parser._parse_component(
            stream,
            {'basename': 'invalid',},
        )
        self.assertEquals(component, None)
        self.assertEquals(instance, None)


class GEDATopLevelShapeTests(GEDATestCase):

    def test_adding_top_level_shapes_to_design(self):
        """ Test adding top-level shapes to design """
        with open('/tmp/toplevelshapes.sch', 'w') as toplevel_sch:
            toplevel_sch.write("\n".join([
                "v 20001 2",
                "L 40800 46600 45700 46600 3 0 0 0 -1 -1",
                "L 42300 45900 42900 45500 3 0 0 0 -1 -1",
                GEDAPinParsingTests.get_pin_sample(),
                GEDAPinParsingTests.get_reversed_pin(),
            ]))

        design = self.geda_parser.parse('/tmp/toplevelshapes.sch')

        self.assertEquals(len(design.shapes), 2)
        self.assertEquals(len(design.pins), 2)

        self.assertEqual(
            sorted(['line', 'line']),
            sorted([s.type for s in design.shapes])
        )


class GEDAStyleTests(GEDATestCase):

    def test_attaching_styles_to_shape(self):
        """ Test attaching style to shape """
        params = {
            'x': 49, 'y': 34,
            'radius': 223,
            'startangle': 30,
            'sweepangle': 90,
            'style_capstyle': None,
            'style_color': None,
            'style_dashlength': None,
            'style_dashspace': None,
            'style_dashstyle': None,
            'style_width': None,
        }
        shape_ = upconvert.core.shape.Arc(0, 0, 200, 200, 200)
        self.geda_parser._save_parameters_to_object(shape_, params)
        self.assertEqual(shape_.styles, {
            'style_capstyle': None,
            'style_color': None,
            'style_dashlength': None,
            'style_dashspace': None,
            'style_dashstyle': None,
            'style_width': None,
        })

    def test_attaching_styles_to_invalid_object(self):
        """ Test attaching styles to invalid objects """
        import logging
        logging.basicConfig(level=logging.INFO)
        import StringIO

        stream = StringIO.StringIO()
        logging.root.handlers = []
        logger = logging.getLogger('parser.geda')
        logger.setLevel(logging.DEBUG)
        logger.addHandler(logging.StreamHandler(stream))

        self.geda_parser._save_parameters_to_object(
            object,
            {'style_color': 1, 'style_somethingelse': 1},
        )
        self.assertTrue('without styles dict' in stream.getvalue())


class GEDAFullConversionTests(GEDATestCase):

    def test_parse(self):
        """ Tests parsing valid and invalid schematic files. """
        self.geda_parser = GEDA([
            'test/geda/simple_example/symbols',
        ])

        invalid_sch = open('/tmp/invalid.sch', 'w')
        invalid_sch.write('C 18600 21500 1 0 0 EMBEDDED555-1')
        invalid_sch.close()
        self.assertRaises(
            GEDAError,
            self.geda_parser.parse,
            '/tmp/invalid.sch'
        )

        ## testing EMBEDDED component
        design = self.geda_parser.parse(
            './test/geda/embedded_component.sch'
        )

        components = design.components.components #test components dictionary
        self.assertEquals(components.keys(), ['EMBEDDEDbattery-1'])

        component = components['EMBEDDEDbattery-1']
        self.assertEquals(component.name, 'EMBEDDEDbattery-1')

        keys = ['p1x', 'p1y', 'p2x', 'p2y', 'num', 'seq', 'label', 'type']
        expected_pins = [
            dict(zip(keys, [0, 200, 200, 200, '1', 1, '+', 'pwr'])),
            dict(zip(keys, [700, 200, 500, 200, '2', 2, '-', 'pwr'])),
        ]
        for pin, expected_pin in zip(component.symbols[0].bodies[0].pins,
                                     expected_pins):
            self.assertEquals(pin.label.text, expected_pin['label'])
            ## test reversed pin order due to different handling in direction
            self.assertEquals(
                pin.p1.x,
                expected_pin['p2x'] / self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                pin.p1.y,
                expected_pin['p2y'] / self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                pin.p2.x,
                expected_pin['p1x'] / self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                pin.p2.y,
                expected_pin['p1y'] / self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(pin.pin_number, expected_pin['num'])

        ## testing referenced component
        design = self.geda_parser.parse('test/geda/component.sch')

        components = design.components.components #test components dictionary
        self.assertEquals(components.keys(), ['battery-1'])

        component = components['battery-1']
        self.assertEquals(component.name, 'battery-1')

        keys = ['p1x', 'p1y', 'p2x', 'p2y', 'num', 'seq', 'label', 'type']
        expected_pins = [
            dict(zip(keys, [0, 200, 200, 200, '1', 1, '+', 'pwr'])),
            dict(zip(keys, [700, 200, 500, 200, '2', 2, '-', 'pwr'])),
        ]
        for pin, expected_pin in zip(component.symbols[0].bodies[0].pins,
                                     expected_pins):
            self.assertEquals(pin.label.text, expected_pin['label'])
            ## test reversed pin order due to different handling in direction
            self.assertEquals(
                pin.p1.x,
                expected_pin['p2x'] / self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                pin.p1.y,
                expected_pin['p2y'] / self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                pin.p2.x,
                expected_pin['p1x'] / self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(
                pin.p2.y,
                expected_pin['p1y'] / self.geda_parser.SCALE_FACTOR
            )
            self.assertEquals(pin.pin_number, expected_pin['num'])

    def test_parse_full(self):
        """
        Test parsing a complete schematic file generating OpenJSON.
        """
        self.geda_parser = GEDA([
            './test/geda/simple_example/symbols',
        ])
        design = self.geda_parser.parse(
            'test/geda/simple_example/simple_example.sch'
        )
        self.assertEquals(len(design.nets), 2)

        net_names = [net.net_id for net in design.nets]
        self.assertEquals(
            sorted(net_names),
            sorted(['+_1', '-_In+']),
        )


class GedaLightningProjectTests(TestCase):

    filename = 'test/geda/lightning/lightning.json'

    def setUp(self):
        with open(self.filename) as fh:
            self.reference = json.load(fh)

        self.components = {}
        for comp in self.reference['components']:
            if not comp['filename'].startswith('title'):
                self.components[comp['refdes']] = comp

        self.bom = self.reference['bom']

    def test_something(self):
        self.geda_parser = GEDA(['./test/geda/lightning/symbols',])
        design = self.geda_parser.parse('test/geda/lightning/lightning.sch')

        self.assertEquals(
            len(design.component_instances),
            len(self.components)
        )

        for comp in design.component_instances:
            refcomp = self.components[comp.instance_id]

            self.assertEquals(comp.instance_id, refcomp['refdes'])
            # check that the library ID corresponds to the filename
            # of the symbol but ignoring the suffix that might indicate
            # a mirrored component.
            assert comp.library_id.startswith(
                refcomp['filename'].replace('.sym', '')
            )

        self.assertEquals(len(design.nets), 13)

        net_names = ['net%d' % (idx+1) for idx, ___ in enumerate(design.nets)]
        for net in design.nets:
            net_names.remove(net.net_id)
        self.assertFalse(net_names)

        pin_lookup = {}
        def make_pin_lookup(lst, pins):
            for i in lst:
                pin_lookup[i] = pins

        make_pin_lookup(['A1', 'bat(+3v)', 'lamp(1)', 'lamp(2)', 'bat(0v)'], 1)
        make_pin_lookup(['L1', 'L2', 'C1', 'C2', 'R1', 'R2', 'C3', 'R3',
                         'D1', 'C4', 'R5', 'C5', 'R6', 'C6', 'R7'], 2)
        make_pin_lookup(['Q%d' % idx for idx in range(1, 5)] + ['R4'], 3)

        for inst in design.component_instances:
            comp = design.components.components[inst.library_id]
            body = comp.symbols[inst.symbol_index].bodies[0]
            self.assertEquals(len(body.pins), pin_lookup[inst.instance_id])

        # check for correct amount of netpoints with connections
        # fail early when not the right amount of points connected
        connected_nets = {
            'net1': ['A1', 'L2'],
            'net2': ['L2', 'L1', 'C2', 'C1'],
            'net3': ['L1', 'Q1', 'C1', 'R6', 'C6', 'Q4', 'bat(0v)'],
            'net4': ['Q1', 'R1', 'C2'],
            'net5': ['Q1', 'R1', 'R2', 'C3'],
            'net6': ['R2', 'C6', 'R7', 'bat(+3v)'],
            'net7': ['R4']*2 + ['D1', 'Q3', 'R7', 'lamp(1)'],
            'net8': ['D1', 'Q2', 'C4'],
            'net9': ['R3', 'R4', 'Q2', 'C3'],
            'net10': ['R3', 'C4', 'C5', 'Q3', 'R6', 'Q4'],
            'net11': ['R5', 'C5', 'Q3'],
            'net12': ['Q4', 'lamp(2)'],
            'net13': ['Q2', 'R5'],
        }

        for net in design.nets:
            net_connections = []
            for np in net.points.values():
                net_connections += [c.instance_id for c in np.connected_components]
            self.assertEquals(sorted(connected_nets[net.net_id]), sorted(net_connections))

    def is_connected(self, point, inst):
        for conn_comp in point.connected_components:
            if conn_comp.instance_id == inst.instance_id:
                return True
        return False

    def get_normalised_pins(self, design, inst):
        try:
            inst.library_id
        except AttributeError:
            for i in design.component_instances:
                if i.instance_id == inst:
                    inst = i
                    break

        comp = design.components.components[inst.library_id]

        norm_pins = []
        for pin in comp.symbols[inst.symbol_index].bodies[0].pins:
            inst_origin = inst.symbol_attributes[inst.symbol_index]

            x1, y1 = GEDA.translate_coords(pin.p1.x, pin.p1.y, inst_origin.rotation)
            x2, y2 = GEDA.translate_coords(pin.p2.x, pin.p2.y, inst_origin.rotation)

            norm_pins.append(Point(
                x2 + inst_origin.x,
                y2 + inst_origin.y)
            )
        return norm_pins

########NEW FILE########
__FILENAME__ = gerber_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The gerber parser test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from functools import wraps
from os import path
import unittest

from nose.tools import raises

from upconvert.parser.gerber import Gerber, DelimiterMissing, ParamContainsBadData, \
                            CoordPrecedesFormatSpec, CoordMalformed, \
                            FileNotTerminated, DataAfterEOF, \
                            UnintelligibleDataBlock, QuadrantViolation, \
                            OpenFillBoundary, IncompatibleAperture, Modifier

STRIP_DIRS = path.join('upconvert', 'parser', 't')
BASE_DIR = path.dirname(__file__).split(STRIP_DIRS)[0]
TEST_FILES = path.join('test', 'gerber', 'unittest')
DIR = path.join(BASE_DIR, TEST_FILES)


def use_file(filename):
    """ Return a decorator which will parse a gerber file
    before running the test. """

    def decorator(test_method):
        """ Add params to decorator function. """

        @wraps(test_method)
        def wrapper(self):
            """ Parse file then run test. """
            parser = Gerber(ignore_unknown=False)
            self.design = parser.parse(path.join(DIR, filename))
            test_method(self)

        return wrapper

    return decorator


class GerberTests(unittest.TestCase):
    """ The tests of the gerber parser """

    def setUp(self):
        """ Setup the test case. """
        self.design = None

    # tests that pass if no errors are raised

    def test_create_new_gerber_parser(self):
        """ Create an empty gerber parser. """
        parser = Gerber()
        assert parser != None

    @use_file('simple.ger')
    def test_simple(self):
        """ Parse a simple, correct gerber file. """
        image = self.design.layout.layers[0].images[0]
        assert len(image.traces) == 2

    @use_file('arc_segments.ger')
    def test_arcs(self):
        """ Parse some connected arcs and lines - gerber. """
        image = self.design.layout.layers[0].images[0]
        assert len(image.traces) == 2

    @use_file('fills.ger')
    def test_outline_fills(self):
        """ Parse outline fills - gerber. """
        image = self.design.layout.layers[0].images[0]
        assert len(image.fills) == 2

    @use_file('smear.ger')
    def test_smear(self):
        """ Parse a smear - gerber. """
        image = self.design.layout.layers[0].images[0]
        assert len(image.smears) == 1

    @use_file('complex.ger')
    def test_complex(self):
        """ Parse aperture macros - gerber. """
        image = self.design.layout.layers[0].images[2]
        assert len(image.shape_instances) == 3

    @use_file('macro1.ger')
    def test_macros(self):
        """ Parse simple macros. """
        macros = self.design.layout.layers[0].macros

        self.assertEqual(len(macros), 10)
        self.assertEqual(set(macros),
                         set(['MOIRE', 'POLYGON', 'POLYGON0', 'LINE2', 'LINE1',
                              'THERMAL', 'VECTOR', 'CIRCLE', 'OUTLINE',
                              'COMPOUND']))

        self.assertEqual(macros['CIRCLE'].primitives[0].shape.type, 'circle')
        self.assertEqual(macros['CIRCLE'].primitives[0].shape.radius, 0.25)

        self.assertEqual(macros['VECTOR'].primitives[0].shape.type, 'rectangle')
        self.assertEqual(macros['VECTOR'].primitives[0].shape.width, 1.25)
        self.assertEqual(macros['VECTOR'].primitives[0].shape.height, 0.05)
        self.assertEqual(macros['VECTOR'].primitives[0].shape.x, 0.0)
        self.assertEqual(macros['VECTOR'].primitives[0].shape.y, 0.025)

        self.assertEqual(macros['LINE1'].primitives[0].shape.type, 'rectangle')
        self.assertEqual(macros['LINE1'].primitives[0].shape.width, 0.3)
        self.assertEqual(macros['LINE1'].primitives[0].shape.height, 0.05)
        self.assertEqual(macros['LINE1'].primitives[0].shape.x, -0.15)
        self.assertEqual(macros['LINE1'].primitives[0].shape.y, 0.025)

        self.assertEqual(macros['LINE2'].primitives[0].shape.type, 'rectangle')
        self.assertEqual(macros['LINE2'].primitives[0].shape.width, 0.8)
        self.assertEqual(macros['LINE2'].primitives[0].shape.height, 0.5)
        self.assertEqual(macros['LINE2'].primitives[0].shape.x, 0.0)
        self.assertEqual(macros['LINE2'].primitives[0].shape.y, 0.5)

        self.assertEqual(macros['OUTLINE'].primitives[0].shape.type, 'polygon')
        self.assertEqual(len(macros['OUTLINE'].primitives[0].shape.points), 4)
        self.assertEqual(macros['OUTLINE'].primitives[0].shape.points[0].x, 0.0)
        self.assertEqual(macros['OUTLINE'].primitives[0].shape.points[0].y, 0.0)
        self.assertEqual(macros['OUTLINE'].primitives[0].shape.points[1].x, 0.0)
        self.assertEqual(macros['OUTLINE'].primitives[0].shape.points[1].y, 0.5)
        self.assertEqual(macros['OUTLINE'].primitives[0].shape.points[2].x, 0.5)
        self.assertEqual(macros['OUTLINE'].primitives[0].shape.points[2].y, 0.5)
        self.assertEqual(macros['OUTLINE'].primitives[0].shape.points[3].x, 0.5)
        self.assertEqual(macros['OUTLINE'].primitives[0].shape.points[3].y, 0.0)

        self.assertEqual(macros['POLYGON'].primitives[0].shape.type, 'regular polygon')
        self.assertEqual(macros['POLYGON'].primitives[0].shape.x, 0.0)
        self.assertEqual(macros['POLYGON'].primitives[0].shape.y, 0.0)
        self.assertEqual(macros['POLYGON'].primitives[0].shape.outer_diameter, 0.5)
        self.assertEqual(macros['POLYGON'].primitives[0].shape.vertices, 3)
        self.assertEqual(macros['POLYGON'].primitives[0].shape.rotation, 0)

        self.assertEqual(macros['POLYGON0'].primitives[0].shape.type, 'regular polygon')
        self.assertEqual(macros['POLYGON0'].primitives[0].shape.x, 0.0)
        self.assertEqual(macros['POLYGON0'].primitives[0].shape.y, 0.0)
        self.assertEqual(macros['POLYGON0'].primitives[0].shape.outer_diameter, 0.5)
        self.assertEqual(macros['POLYGON0'].primitives[0].shape.vertices, 6)
        self.assertEqual(macros['POLYGON0'].primitives[0].shape.rotation, 0)

        self.assertEqual(macros['MOIRE'].primitives[0].shape.type, 'moire')
        self.assertEqual(macros['MOIRE'].primitives[0].shape.x, 0.0)
        self.assertEqual(macros['MOIRE'].primitives[0].shape.y, 0.0)
        self.assertEqual(macros['MOIRE'].primitives[0].shape.outer_diameter, 1.0)
        self.assertEqual(macros['MOIRE'].primitives[0].shape.ring_thickness, 0.1)
        self.assertEqual(macros['MOIRE'].primitives[0].shape.gap_thickness, 0.4)
        self.assertEqual(macros['MOIRE'].primitives[0].shape.max_rings, 2.0)
        self.assertEqual(macros['MOIRE'].primitives[0].shape.hair_thickness, 0.01)
        self.assertEqual(macros['MOIRE'].primitives[0].shape.hair_length, 1.0)
        self.assertEqual(macros['MOIRE'].primitives[0].shape.rotation, 1.777777777777777777)

        self.assertEqual(macros['THERMAL'].primitives[0].shape.type, 'thermal')
        self.assertEqual(macros['THERMAL'].primitives[0].shape.x, 0.0)
        self.assertEqual(macros['THERMAL'].primitives[0].shape.y, 0.0)
        self.assertEqual(macros['THERMAL'].primitives[0].shape.outer_diameter, 1.0)
        self.assertEqual(macros['THERMAL'].primitives[0].shape.inner_diameter, 0.3)
        self.assertEqual(macros['THERMAL'].primitives[0].shape.gap_thickness, 0.01)
        self.assertEqual(macros['THERMAL'].primitives[0].shape.rotation, 2.0722222222222224)

        self.assertEqual(len(macros['COMPOUND'].primitives), 2)
        self.assertEqual(macros['COMPOUND'].primitives[0].shape.type, 'circle')
        self.assertEqual(macros['COMPOUND'].primitives[0].shape.radius, .75)
        self.assertEqual(macros['COMPOUND'].primitives[1].shape.type, 'circle')
        self.assertEqual(macros['COMPOUND'].primitives[1].shape.radius, 2.0)

    @use_file('simple.zip')
    def test_zip_batch(self):
        """ Parse a batch of gerber files in a zip file. """
        assert self.design.layout.layers[0].name == 'top'

    @use_file('simple.bz2')
    def test_bz_batch(self):
        """ Parse a batch of gerber files in a bz2 tarball. """
        assert self.design.layout.layers[0].name == 'top'

    @use_file('simple.tgz')
    def test_gz_batch(self):
        """ Parse a batch of gerber files in a gz tarball. """
        assert self.design.layout.layers[0].name == 'top'

    def test_modifier(self):
        """ The Modifier can evaluate expressions correctly. """
        modif = Modifier('1.2')
        self.assertEqual(modif.evaluate({}), 1.2)
        modif = Modifier('$1')
        self.assertEqual(modif.evaluate({1:3.2}), 3.2)
        modif = Modifier('1+1')
        self.assertEqual(modif.evaluate({}), 2)
        modif = Modifier('3-1.5')
        self.assertEqual(modif.evaluate({}), 1.5)
        modif = Modifier('2.2X3')
        self.assertAlmostEqual(modif.evaluate({}), 6.6, 3)
        modif = Modifier('4.4/2.2')
        self.assertAlmostEqual(modif.evaluate({}), 2, 2)
        modif = Modifier('1+4.4/2.2')
        self.assertAlmostEqual(modif.evaluate({}), 3, 2)
        modif = Modifier('$1+$2')
        self.assertAlmostEqual(modif.evaluate({1:1, 2:2.2}), 3.2, 2)
        modif = Modifier('$3=$1+$2')
        values = {1:1, 2:2}
        self.assertEqual(modif.evaluate(values), 3)
        self.assertEqual(values, {1:1, 2:2, 3:3.0})

    # tests that pass if they raise expected errors

    @raises(DelimiterMissing)
    @use_file('missing-delim.ger')
    def test_missing_delim(self):
        """ Trap param outside of gerber param block. """

    @raises(CoordPrecedesFormatSpec)
    @use_file('coord-precedes-fs.ger')
    def test_coord_preceding_fs(self):
        """ Trap coord preceding gerber format spec. """

    @raises(ParamContainsBadData)
    @use_file('coord-in-param-block.ger')
    def test_data_in_param(self):
        """ Trap coord inside gerber param block. """

    @raises(CoordMalformed)
    @use_file('y-precedes-x.ger')
    def test_y_before_x(self):
        """ Trap coord with 'Y' before 'X' - gerber. """

    @raises(DataAfterEOF)
    @use_file('data-after-eof.ger')
    def test_trailing_data(self):
        """ Trap data following M02* block - gerber. """

    @raises(FileNotTerminated)
    @use_file('not-terminated.ger')
    def test_no_eof(self):
        """ Trap file with no M02* block - gerber. """

    @raises(UnintelligibleDataBlock)
    @use_file('alien.ger')
    def test_alien_data(self):
        """ Trap off-spec data in gerber file. """

    @raises(QuadrantViolation)
    @use_file('sq-violation.ger')
    def test_single_quadrant(self):
        """ Trap long arc in single quadrant mode. """

    @raises(OpenFillBoundary)
    @use_file('open-fill.ger')
    def test_open_fill(self):
        """ Trap unsuccessful outline fill closure. """

    @raises(IncompatibleAperture)
    @use_file('disallowed-smear.ger')
    def test_arc_smear(self):
        """ Trap non-linear smear - gerber. """


########NEW FILE########
__FILENAME__ = kicad_t
# encoding: utf-8
#pylint: disable=R0904
""" The kicad parser test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.parser.kicad import KiCAD, ComponentParser, MULT
from upconvert.writer.openjson import JSON as JSONWriter

import unittest

from functools import wraps
from os.path import dirname, join
from os import devnull

TEST_DIR = join(dirname(__file__), '..', '..', '..', 'test', 'kicad')


_cache = {} # filename -> Design

def get_design(filename):
    if filename not in _cache:
        _cache[filename] = KiCAD().parse(join(TEST_DIR, filename))
    return _cache[filename]


def use_file(filename):
    """ Return a decorator which will parse a kicad file
    before running the test. """

    def decorator(test_method):
        """ Add params to decorator function. """

        @wraps(test_method)
        def wrapper(self):
            """ Parse file then run test. """
            self.design = get_design(filename)
            test_method(self)

        return wrapper

    return decorator


class KiCADTests(unittest.TestCase):
    """ The tests of the kicad parser """

    @use_file('test/test.sch')
    def test_design_attributes(self):
        """ All the design attributes are correct """

        anns = self.design.design_attributes.annotations
        self.assertTrue(len(anns), 1)
        self.assertEqual(anns[0].value, "I'm a net label")


    @use_file('test/test.sch')
    def test_points(self):
        """
        Test that all the points are present and have the right
        positions and connected points and components.
        """

        self.assertEqual(len(self.design.nets[0].points), 3)
        self.assertEqual(set(self.design.nets[0].points),
                         set(['2700a-6450',
                              '2700a-3950',
                              '3250a-3950']))


    @use_file('test/test.sch')
    def test_nets(self):
        """
        Test that all the right nets are present.
        """

        self.assertEqual(len(self.design.nets), 5)
        self.assertEqual(self.design.nets[0].net_id, '2700a-3950')


    @use_file('arduino/Arduino-Ethernet.sch')
    def test_nets_no_dups(self):
        """
        Test that no duplicate nets are present.
        """

        self.assertEqual(len(self.design.nets), 82)
        self.assertEqual(len(self.design.nets),
                         len(set(n.net_id for n in self.design.nets)))


    @use_file('test/test.sch')
    def test_components(self):
        """
        Test that all the right components are present with the
        correct values.
        """

        self.assertEqual(len(self.design.components.components), 5)
        self.assertEqual(set([c.name for c in self.design.components.components.values()]),
                         set(['74LS00',
                             'ATMEGA8-P',
                             'NSL-32',
                             'LP3966',
                             'LAA110']))

        cpt = self.design.components.components['74LS00']

        self.assertEqual(len(cpt.symbols), 2)
        self.assertEqual(len(cpt.symbols[0].bodies), 4)
        self.assertEqual(len(cpt.symbols[0].bodies[0].pins), 5)


    @use_file('test/test.sch')
    def test_component_instances(self):
        """
        Test that the component instances were loaded correctly.
        """

        self.assertEqual(len(self.design.component_instances), 5)

        inst = self.design.component_instances[0]

        self.assertEqual(inst.instance_id, 'U3')
        self.assertEqual(inst.library_id, 'LAA110')
        self.assertEqual(len(inst.symbol_attributes), 1)
        self.assertEqual(inst.symbol_attributes[0].rotation, 1.5)
        self.assertEqual(inst.symbol_attributes[0].x, 1650 * MULT)
        self.assertEqual(inst.symbol_attributes[0].y, -3400 * MULT)


    @use_file('arduino/Arduino-Ethernet.sch')
    def test_connected_components(self):
        """
        The components are connected correctly.
        """

        ccomps = set()
        for net in self.design.nets:
            for point in net.points.itervalues():
                for cc in point.connected_components:
                    ccomps.add((cc.instance_id, cc.pin_number))

        self.assertTrue(('R1', '2') in ccomps)
        self.assertTrue(('P1', '1') in ccomps)
        self.assertTrue(('P1', '2') in ccomps)
        self.assertTrue(('P1', '3') in ccomps)
        self.assertTrue(('P1', '4') in ccomps)
        self.assertTrue(('P1', '5') in ccomps)
        self.assertTrue(('P1', '6') in ccomps)
        self.assertTrue(('D1', '1') in ccomps)
        self.assertTrue(('D1', '2') in ccomps)


    def test_bad_x_line_rotation(self):
        """
        Test that a bad rotation in an X line raises a ValueError.
        """

        parser = ComponentParser('DEF 74LS00 U 0 30 Y Y 4 F N')
        line = 'X GND 7 -200 -200 0 E 40 40 0 0 W N'
        self.assertRaises(ValueError, parser.parse_x_line, line.split())


    @use_file('jtag_schematic.sch')
    def test_annotation_spaces(self):
        """
        Annotations with spaces are handled correctly.
        """

        inst = [i for i in self.design.component_instances
                if i.library_id == 'CONN_4X2'][0]
        self.assertEqual(inst.symbol_attributes[0].annotations[1].value,
                         'MAPLE JTAG')


    @use_file('ps2toserial.sch')
    def test_utf8_annotations(self):
        """
        Annotations with special chars are handled correctly.
        """

        JSONWriter().write(self.design, devnull)


    def test_t_line_no_alignment(self):
        """
        T lines with no alignment are handled correctly.
        """

        parser = ComponentParser('DEF 74LS00 U 0 30 Y Y 4 F N')
        shape = parser.parse_t_line(['T', '0', '150', '-235', '50',
                                     '0', '4', '0', 'Common'])
        self.assertEqual(shape.type, 'label')
        self.assertEqual(shape.text, 'Common')
        self.assertEqual(shape.align, 'left')


    def test_parse_field(self):
        """
        A field description with an embedded quote is parsed correctly.
        """

        line = 'F 0 "Reference Designs ARE PROVIDED "AS IS"" H 1150 11950 120 0000 L B'
        ann = KiCAD().parse_field(0, 0, line)
        self.assertEqual(ann.value, 'Reference Designs ARE PROVIDED "AS IS"')
        self.assertEqual(ann.x, 1150)
        self.assertEqual(ann.y, -11950)
        self.assertEqual(ann.rotation, 0)

########NEW FILE########
__FILENAME__ = openjson_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The openjson parser test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.parser.openjson import JSON
import unittest


class JSONTests(unittest.TestCase):
    """ The tests of the json parser """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_json_parser(self):
        """ Test creating an empty parser. """
        parser = JSON()
        assert parser != None

########NEW FILE########
__FILENAME__ = specctra_t
# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import unittest

from upconvert.parser.specctra import DsnParser

class DsnParserTests(unittest.TestCase):
    def test_plain_parser(self):
        parser = DsnParser()
        got = parser.parse('''
(pcb test.dsn
  (parser
    (host_cad "Kicad's PCBNEW")
    (host_version "(2011-06-28)")
  )
)''')
        correct = ['pcb', 'test.dsn',
                    ['parser',
                        ['host_cad', "\"Kicad's", "PCBNEW\""],
                        ['host_version', '"', ['2011-06-28'], '"']
                    ]
                ]
 
        self.assertEqual(correct, got)

    def test_quote_parser(self):
        parser = DsnParser()
        got = parser.parse('''
(pcb test.dsn
  (parser
    (string_quote ")
    (host_cad "Kicad's PCBNEW)
    (host_version "(2011-06-28)")
  )
)''')
        correct = ['pcb', 'test.dsn',
                    ['parser',
                        ['string_quote', '"'],
                        ['host_cad', "Kicad's", "PCBNEW"],
                        ['host_version', '(2011-06-28)']
                    ]
                ]
 
        self.assertEqual(correct, got)

    def test_quote_space_parser(self):
        parser = DsnParser()
        got = parser.parse('''
(pcb test.dsn
  (parser
    (string_quote ")
    (space_in_quoted_tokens on)
    (host_cad "Kicad's PCBNEW")
    (host_version "(2011-06-28)")
  )
)''')
        correct = ['pcb', 'test.dsn',
                    ['parser',
                        ['string_quote', '"'],
                        ['space_in_quoted_tokens', 'on'],
                        ['host_cad', "Kicad's PCBNEW"],
                        ['host_version', '(2011-06-28)']
                    ]
                ]
 
        self.assertEqual(correct, got)

    def test_quoted_string_part(self):
        parser = DsnParser()
        got = parser.parse('''
(pcb test.dsn
  (parser
    (string_quote ")
    (space_in_quoted_tokens on)
    (host_cad "Kicad's PCBNEW")
    (host_version "(2011-06-28)")
  )
  (pins A1-"-")
)''')
        correct = ['pcb', 'test.dsn',
                    ['parser',
                        ['string_quote', '"'],
                        ['space_in_quoted_tokens', 'on'],
                        ['host_cad', "Kicad's PCBNEW"],
                        ['host_version', '(2011-06-28)']
                    ],
                    ['pins', 'A1--'],
                ]
 
        self.assertEqual(correct, got)

########NEW FILE########
__FILENAME__ = viewdraw_t
""" Tests for the ViewDraw parser """

import unittest
from inspect import getargspec
from upconvert.parser.viewdraw import FileStack, ViewDrawBase, ViewDrawSym, ViewDrawSch

from upconvert.core.annotation import Annotation
from upconvert.core.shape import Label, Point
from math import sin, cos, pi

_real_fs_init  = FileStack.__init__

def stub_file_stack():
    """ stub in a constructor that doesn't depend on the filesystem """
    def fake_init(self, filename):
        self.f = iter([])
        self.fstack = []
        self.line = 0
    FileStack.__init__ = fake_init

def unstub_file_stack():
    """ return to the proper FileStack constructor. """
    FileStack.__init__ = _real_fs_init

    
class FileStackTests(unittest.TestCase):
    """ Tests for the file reader used by the parser """

    def setUp(self):
        stub_file_stack()
        self.fs = FileStack('test')


    def tearDown(self):
        unstub_file_stack()
        del self.fs


    def test_subpop(self):
        """Ensure subpop() can iterate through the simplest case"""
        self.fs.f = iter(['test\n', 'foo\n', 'bar\n', 'baz\n'])
        for i, line in enumerate(['test', 'foo', 'bar', 'baz']):
            self.assertEqual(self.fs.line, i)
            self.assertEqual(self.fs.subpop(), line + '\n')
            self.assertEqual(self.fs.line, i + 1)
        self.assertRaises(StopIteration, self.fs.subpop)


    def test_line_continuation(self):
        """Test that line continuations are re-assembled correctly"""
        self.assertEqual(self.fs.continuation('foo\n', ' bar\n'), 'foo bar\n')
        self.assertEqual(self.fs.continuation('foo\n', '+ bar\n'), 'foobar\n')


    def test_next(self):
        """Test for iterator functionality, with a continuation"""
        self.fs.f = iter(['foo\n', 'bar\n', ' baz\n', 'garr\n'])
        for i, line in zip([1, 3, 4], ['foo', 'bar baz', 'garr']):
            self.assertEqual(self.fs.next(), line)
            self.assertEqual(self.fs.line, i)
        self.assertRaises(StopIteration, self.fs.next)


    def test_push(self):
        """Test pushing lines back on to the stack"""
        self.fs.f = iter([])
        for i, line in zip([-1, -2, -3], ['baz', 'bar', 'foo']):
            # push them on backwards because it's a stack
            self.fs.push(line)
            self.assertEqual(self.fs.line, i)
        self.assertEqual(list(self.fs), ['foo', 'bar', 'baz'])


class ViewDrawBaseTests(unittest.TestCase):
    """ Tests for functionality shared between parsers """
    
    def setUp(self):
        stub_file_stack()
        self.base = ViewDrawBase('foo')
        self.base.stream = FileStack('bar')

    def tearDown(self):
        unstub_file_stack()
        del self.base

    def test_rot_and_flip(self):
        rotations = (0, 1.5, 1, 0.5)
        for vd_rot, rot in enumerate(rotations):
            self.assertEqual((rot, False), self.base.rot_and_flip(str(vd_rot)))
        for vd_rot, rot in enumerate(rotations, 4):
            self.assertEqual((rot, True), self.base.rot_and_flip(str(vd_rot)))

    def test_base_init(self):
        self.assertEqual(self.base.filename, 'foo')

    def test_parser_dispatch(self):
        """ Check that the parsers used have the proper call signatures """
        valid_cmds = 'A L |R V Z c b T a l'.split()
        for cmd in valid_cmds:
            parser  = self.base.parsenode(cmd)
            # make sure it only needs two argument (self, args)
            self.assertEqual(len(getargspec(parser)[0]), 2)
        # currently not testing invalid commands, their behaviour can be
        # considered 'undefined'

    def test_label(self):
        """ Test basic label parsing """
        args = '2 3 12 2 # # # # this is a text label'
        # `#` args are unhandled, but may be in the future
        k, v = self.base.parse_label(args)
        self.assertEqual(k, 'annot')
        self.assertTrue(isinstance(v, Annotation))
        self.assertEqual(v.x, 2)
        self.assertEqual(v.y, 3)
        self.assertAlmostEqual(v.rotation, 1.0)
        self.assertEqual(v.value, 'this is a text label')

    def test_annot(self):
        """ Test basic Annotation parsing """
        args = '2 3 12 0 1'
        text = 'foo=bar baz'
        pairs = (('0', text),
                 ('1', text),
                 ('2', 'foo'),
                 ('3', 'bar baz'))
        for viz, val in pairs:
            k, v = self.base.parse_annot(' '.join([args, viz, text]))
            self.assertEqual(k, 'annot')
            self.assertEqual(v.x, 2)
            self.assertEqual(v.y, 3)
            if viz is '0':
                self.assertFalse(v.visible)
            else:
                self.assertTrue(v.visible)
            self.assertEqual(v.value, val)

    def test_revision(self):
        """ Test the file revision datetime parser """
        k, v = self.base.parse_rev('timedate')
        self.assertEqual(k, 'annot')
        self.assertEqual(v.value, 'rev=timedate')
        self.assertFalse(v.visible)
        self.assertEqual(v.x, 0)
        self.assertEqual(v.y, 0)
        self.assertEqual(v.rotation, 0)

    def test_circle(self):
        """ Test parsing a simple circle """
        posargs = '1 2 3'
        negargs = '-6 -7 8'
        k, v = self.base.parse_circle(posargs)
        self.assertEqual(k, 'shape')
        self.assertEqual(v.type, 'circle')
        self.assertEqual((v.x, v.y), (1, 2))
        self.assertEqual(v.radius, 3)

        k, v = self.base.parse_circle(negargs)
        self.assertEqual(k, 'shape')
        self.assertEqual(v.type, 'circle')
        self.assertEqual((v.x, v.y), (-6, -7))
        self.assertEqual(v.radius, 8)

    def test_box(self):
        """ Test for a simple rectangle """
        k, v = self.base.parse_box('2 4 7 8')
        self.assertEqual(k, 'shape')
        self.assertEqual(v.type, 'rectangle')
        self.assertEqual((v.x, v.y), (2, 4))
        self.assertEqual(v.height, (8 - 4))
        self.assertEqual(v.width, (7 - 2))

        k, v = self.base.parse_box('1 3 -5 -6')
        self.assertEqual(k, 'shape')
        self.assertEqual(v.type, 'rectangle')
        self.assertEqual((v.x, v.y), (1, 3))
        self.assertEqual(v.width, -5 - 1)
        self.assertEqual(v.height, -6 - 3)

    def test_text(self):
        """ Test text labels """
        k, v = self.base.parse_text('3 4 # 1 # hello world')
        self.assertEqual(k, 'shape')
        self.assertEqual(v.type, 'label')
        self.assertEqual((v.x, v.y), (3, 4))
        self.assertAlmostEqual(v._rotation, 1.5)
        self.assertEqual(v.text, 'hello world')

    def test_version(self):
        """ Test format version parser """
        k, v = self.base.parse_ver('51')
        self.assertEqual(k, 'fileversion')
        self.assertEqual(v, '51')

    def test_line_one_seg(self):
        """One line segment, from (2,3) to (4,7)"""
        k, v = self.base.parse_line('2 1 3 4 7')
        self.assertEqual(k, 'lines')
        self.assertEqual(len(v), 1)
        self.assertEqual(v[0].type, 'line')
        p1, p2 = v[0].p1, v[0].p2
        self.assertEqual(p1, Point(1, 3))
        self.assertEqual(p2, Point(4, 7))

    def test_line_multi_seg(self):
        """A multi-segment line, should become many Line objects"""
        pts = [(2, 1), (4, 5), (8, 7), (9, 2)]
        pts_text = ' '.join([str(p1) + ' ' + str(p2) for p1, p2 in pts])
        k, v = self.base.parse_line(str(len(pts)) + ' ' + pts_text)
        self.assertEqual(k, 'lines')
        self.assertEqual(len(v), len(pts) - 1)
        # line segments returned out of order, or with p1/p2 swapped, would be
        # acceptable. The test would need to change for that.
        for i, line in enumerate(v):
            self.assertEqual(line.type, 'line')
            self.assertEqual(Point(pts[i]), line.p1)
            self.assertEqual(Point(pts[i + 1]), line.p2)

    def test_arc(self):
        """ Test multiple arc segment constructions """
        x_c, y_c, radius = 2, 3, 50
        angles = ((0., 0.5, 1.),
                  (1.5, 0., 0.5),
                  (1., 1.25, 1.5))
        def angle2xy(theta):
            return [int(round(cos(theta * pi) * radius + x_c)),
                    int(round(sin(theta * pi) * radius + y_c))]

        for ang in (angles):
            pts = sum([angle2xy(th) for th in ang], [])

            k, v = self.base.parse_arc(' '.join([str(p) for p in pts]))
            self.assertEqual(k, 'shape')
            self.assertEqual(v.type, 'arc')
            # allow for points to be off by up to one unit, to account for
            # rounding error in calculating center point, radius.
            self.assertTrue(abs(v.x - x_c) <=1)
            self.assertTrue(abs(v.y - y_c) <=1)
            self.assertTrue(abs(v.radius - radius) <=1)
            self.assertTrue(abs(v.end_angle - (2 - ang[0])) <=0.01)
            self.assertTrue(abs(v.start_angle - (2 - ang[2])) <=0.01)

class ViewDrawSymTests(unittest.TestCase):
    """ Tests for ViewDraw library symbol files """

    def setUp(self):
        stub_file_stack()
        self.sym = ViewDrawSym('library/', 'file.1')
        self.sym.stream = FileStack(self.sym.filename)

    def tearDown(self):
        unstub_file_stack()
        del self.sym

    def test_parser_dispatch(self):
        """ Check that the parsers used have the proper call signatures """
        valid_cmds = 'Y U P L'.split()
        for cmd in valid_cmds:
            parser  = self.sym.parsenode(cmd)
            # make sure it only needs two argument (self, args)
            self.assertEqual(len(getargspec(parser)[0]), 2)
        # currently not testing invalid commands, their behaviour can be
        # considered 'undefined'

    def test_sym_type(self):
        """ Test symbol type extraction, based on found documents """
        for i, txt in enumerate(['composite', 'module', 'annotate', 'pin',
                               'power', 'unknown']):
            k, v = self.sym.parse_type(str(i))
            self.assertEqual(k, 'attr')
            self.assertEqual(v, ('symtype', txt))

    def test_attr_key_val(self):
        """ Test attribute parsing, when it has a key and value """
        k, v = self.sym.parse_attr('0 1 2 3 4 5 KEY=VAL')
        self.assertEqual(k, 'attr')
        self.assertEqual(v, ('KEY', 'VAL'))

    def test_attr_just_key(self):
        """ Test attribute parsing, when it has a key but no value """
        k, v = self.sym.parse_attr('0 1 2 3 4 5 KEY')
        self.assertEqual(k, 'attr')
        self.assertEqual(v, ('KEY', ''))

    def subtest_pin(self):
        """ Common tests for both pin test cases """
        k, v = self.sym.parse_pin('13 2 4 3 5 0 0 0')
        self.assertEqual(k, 'pin')
        self.assertEqual(v.p1, Point(3, 5))
        self.assertEqual(v.p2, Point(2, 4))
        self.assertEqual(v.pin_number, 13)
        return(v)

    def test_pin(self):
        """ Test parsing a simple pin """
        v = self.subtest_pin()
        self.assertTrue(v.label is None)

    def test_pin_with_label(self):
        """ Test parsing a pin with an attached label """
        self.sym.stream.f = iter(['L testlabel'])
        # create a fake label parser
        # NOTE not sure if this test is too coupled to internal
        # state/architecture. Fix it if there's a better way
        def fake_label(args):
            return ('label', Label(1, 2, args, align='left', rotation=0))

        p = self.sym.parsenode
        def parsenode_shim(cmd):
            if cmd is 'L':
                return fake_label
            return p(cmd)
        self.sym.parsenode = parsenode_shim

        label = self.subtest_pin().label
        self.assertEqual(label.type, 'label')
        self.assertEqual((label.x, label.y), (1, 2))
        self.assertEqual(label.text, 'testlabel')
        self.assertEqual(label.align, 'left')
        self.assertEqual(label._rotation, 0)

    def test_label(self):
        """ Test parsing a text label """
        k, v = self.sym.parse_label('2 3 12 0 1 1 1 0 foobar')
        # values of 1 aren't used by parser
        self.assertEqual(k, 'label')
        self.assertEqual(v.type, 'label')
        self.assertEqual((v.x, v.y), (2, 3))
        self.assertEqual(v.text, 'foobar')
        self.assertEqual(v.align, 'left')
        self.assertEqual(v._rotation, 0)

    def test_label_inverted(self):
        """ Test parsing a label (for a pin) for an inverted signal """
        _k, v = self.sym.parse_label('2 3 12 0 1 1 1 1 foobar')
        # everything else already tested in test_label()
        self.assertEqual(v.text, '/foobar')

class ViewDrawSchTests(unittest.TestCase):
    """ Tests for a ViewDraw schematic sheet file """
    # TODO work out a sensible way to test connecting instances to nets.

    def setUp(self):
        stub_file_stack()
        self.sch = ViewDrawSch(None, 'foobar')
        self.sch.stream = FileStack('foo')

    def tearDown(self):
        unstub_file_stack()
        del self.sch

    def test_junc(self):
        """ Test the parsing of a single junction on a net """
        k, v = self.sch.parse_junc('2 3 4')
        self.assertEqual(k, 'netpoint')
        self.assertEqual((v.x, v.y), (2, 3))
        self.assertEqual(len(v.connected_points), 0)
        self.assertEqual(len(v.connected_components), 0)
        # Not checking v.point_id, as it is only spec'd to be a unique string

    def test_seg(self):
        """ Test the parsing of a net segment between two junctions """
        k, v = self.sch.parse_seg('6 5')
        self.assertEqual(k, 'segment')
        self.assertEqual(v, (6, 5))

    def test_basic_net(self):
        """ Basics for a net, no actual pi=oints placed """
        k, v = self.sch.parse_net('bar')
        self.assertEqual(k, 'net')
        self.assertEqual(v.net_id, 'bar')
        # make sure nothing got put in there
        self.assertEqual(len(v.points), 0)
        self.assertEqual(len(v.attributes), 0)
        self.assertEqual(len(v.annotations), 0)

    def netpt_helper(self, pts_dict, net):
        """ Checks that the netpoints we wanted were all created """
        self.assertEqual(len(net.points), len(pts_dict))
        for pt in net.points.values():
            # make sure pt is one of the ones we created
            self.assertTrue((pt.x, pt.y) in pts_dict)
            # make sure it's connected to the other point
            self.assertEqual(len(pt.connected_points),
                             len(pts_dict[(pt.x, pt.y)]))
            for ptid in pt.connected_points:
                otherpt = net.points[ptid]
                self.assertTrue((otherpt.x, otherpt.y) in pts_dict[(pt.x, pt.y)])
                self.assertEqual(len(pt.connected_components), 0)

    def test_net_two_points(self):
        """ Test a net with two points """
        pts_dict = {(13, 15): [(17, 19)],
                    (17, 19): [(13, 15)]}
        self.sch.stream.f = iter(['J 13 15 2\n',
                                  'J 17 19 2\n',
                                  'S 1 2\n'])
        k, v = self.sch.parse_net('bar')
        self.assertEqual(k, 'net')
        self.netpt_helper(pts_dict, v)
        self.assertEqual(v.net_id, 'bar')
        self.assertEqual(len(v.attributes), 0)
        self.assertEqual(len(v.annotations), 0)

    def test_net_three_points(self):
        """ Test a net with three points """
        pts_dict = {(1, 2): [(3, 4)],
                    (3, 4): [(1, 2), (5, 6)],
                    (5, 6): [(3, 4)]}
        segs = [('1 2', '2 1'), ('2 3', '3 2')]
        for (p, q, r) in [(a, b, c) for a in (0, 1) for b in (0, 1)
                          for c in (0, 1)]:
            self.sch.stream.f = iter(['J 1 2 2\n',
                                      'J 3 4 2\n',
                                      'J 5 6 2\n',
                                      'S %s\n' % segs[r][p],
                                      'S %s\n' % segs[1-r][q]])
            # run the different permutations to make sure different ordering of
            # connections doesn't matter
            k, v = self.sch.parse_net('bar')
            self.assertEqual(k, 'net')
            self.netpt_helper(pts_dict, v)
            self.assertEqual(v.net_id, 'bar')
            self.assertEqual(len(v.attributes), 0)
            self.assertEqual(len(v.annotations), 0)

    def test_net_label(self):
        """ Test a label added to a net """
        self.sch.stream.f = iter(['L 2 3 4 0 5 6 7 8 foo label\n'])
        _k, v = self.sch.parse_net('bar')
        self.assertEqual(len(v.annotations), 1)
        annot = v.annotations[0]
        self.assertEqual((annot.x, annot.y), (2, 3))
        self.assertEqual(annot.value, 'foo label')
        self.assertEqual(annot.visible, True)

    def test_simple_inst(self):
        """ Test a basic component instance """
        k, v = self.sch.parse_inst("1500 lib:file 5 4 3 2 1 '")
        self.assertEqual(k, 'inst')
        self.assertEqual(v.instance_id, '1500')
        self.assertEqual(v.library_id, 'lib:file.5')
        self.assertEqual(v.symbol_index, 0)
        self.assertEqual(len(v.symbol_attributes), 1)
        attrs = v.symbol_attributes[0]
        self.assertEqual((attrs.x, attrs.y), (4, 3))
        self.assertEqual(attrs.rotation, 1)

########NEW FILE########
__FILENAME__ = viewdraw
#!/usr/bin/env python2
""" The ViewDraw [5.x] format parser """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.core.net import Net, NetPoint, ConnectedComponent
from upconvert.core.annotation import Annotation
from upconvert.core.design import Design
from upconvert.core.components import Components, Component, Symbol, SBody, Pin
from upconvert.core.component_instance import ComponentInstance, SymbolAttribute
from upconvert.core.shape import Circle, Line, Rectangle, Label, Arc
from os import listdir, sep as dirsep
from math import pi, sqrt, atan
from collections import defaultdict
from copy import deepcopy

# Notes:
# ViewDraw files are line-based, where the first character of a line is a
# command, and the rest of the line is arguments for that command. '|' was
# originally a comment, but seems to have ben co-opted to get even more commands
# out of the format, such that |R, |Q, |FNTSTL, and others are now also used.


class ViewDrawBase:
    '''The base class for the parsers. Includes parsing code for commands that
    are shared between the different files'''

    sheetsizes = ('ASIZE', 'BSIZE', 'CSIZE', 'DSIZE', 'ESIZE', 'A4', 'A3',
                  'A2', 'A1', 'A0', 'CUSTOM')

    @staticmethod
    def auto_detect(filename):
        """ Return our confidence that the given file is a viewdraw file """
        confidence = 0.
        with open(filename) as f:
            # as far as I've seen, the first two non-comment lines in a
            # viewdraw file are the version, and the mysterious K line
            version = f.readline().strip()
            while version.startswith('|'):
                version = f.readline().strip()
            kline = f.readline().strip()
            while kline.startswith('|'):
                kline = f.readline().strip()

            if version.startswith('V '):
                confidence += 0.2
                if version.split(' ')[1] in ('50', '51', '52', '53'):
                    # the only version numbers I've seen that match this format
                    confidence += 0.5
            if kline.startswith('K '):
                confidence += 0.2

        # result is that confidence is 0.9 if it's precisely what I expected,
        # and likely 0.4 if it's just in a related format (eg later versions
        # will report 'V 5.4' or similar)
        return confidence


    @staticmethod
    def rot_and_flip(vd_rot):
        """ translates the standard rotation argument from ViewDraw into a
        (rotation, flip) tuple that wakes sense in the upverter world """
        vd_rot = int(vd_rot)
        flip = vd_rot > 3
        # if part is flipped around y-axis. When applying transforms, flip it
        # first, then rotate it.
        vd_rot %= 4
        return ((2 - float(vd_rot) / 2) % 2, flip)


    def __init__(self, filename):
        self.filename = filename
        self.stream = None
        self.parsers = {'A': 'parse_annot',
                        'L': 'parse_label',
                        '|R': 'parse_rev',
                        'V': 'parse_ver',
                        'Z': 'parse_size',
                        'c': 'parse_circle',
                        'b': 'parse_box',
                        'T': 'parse_text',
                        'a': 'parse_arc',
                        'l': 'parse_line',
                       }

    def parse(self):
        '''Returns a dict of elements that have been parsed out of the file'''
        self.stream = FileStack(self.filename)
        tree = defaultdict(list)
        for phrase in self.stream:
            cmd, _sep, args = phrase.partition(' ')
            k, v = self.parsenode(cmd)(args)
            tree[k].append(v)
        return tree

    def parsenode(self, cmd):
        '''Returns the method used to parse the given command. Parse methods
        return a key and a properly parsed element (unspecified type)'''
        # this would be the place to override or decorate if you want additional
        # info or control on every single action taken.
        parser = self.parsers.get(cmd, 'parse_null')
        return getattr(self, parser)

    def parse_null(self, args): # pylint: disable=W0613
        '''A do-nothing parser for commands to be ignored'''
        # override/decorate this if you have a method you want to have called
        # for every unhandled command.
        # get that token off the stack, and ignore it
        return (None, [])

    def parse_annot(self, args):
        """ Returns a parsed annotation. """
        x, y, _font_size, rot, _anchor, viz, val = args.split(' ', 6)
        # anchor is 1,2,3: bottom,mid,top respectively
        # visibility is 0,1,2,3: invis, vis, name only, val only
        self.sub_nodes(['Q'])
        # Q cmd is ignored for now anyway, but need to get it out of the way
        display = True
        if viz == '1':
            value = val
        elif viz == '2':
            value = val.split('=')[0]
        elif viz == '3':
            value = val.split('=', 1)[-1]
        else:
            value = val
            display = False
        rot, _flip = self.rot_and_flip(rot)
        return ('annot', Annotation(value, int(x), int(y), rot, display))

    def parse_label(self, args):
        """ Returns a parsed label. """
        args = args.split(' ', 8)
        x, y, _font_size, rot, _anchor, _scope, _vis, _sense, text = args
        # treat them as annotations for now, I guess.
        # suspect that anchor and vis are as in parse_annot
        # According to other research, _scope is (0=local, 1=global) and _sense
        # might be logic sense (for overbars, 0=normal, 1=inverted)
        # FIXME use vis
        rot, _flip = self.rot_and_flip(rot)
        return ('annot', Annotation(text, int(x), int(y), rot, True))

    def parse_rev(self, args):
        """ Returns the file revision date, parsed into an annotation. """
        # File revision date. Gahh, ugly.
        return ('annot', Annotation('rev=' + args, 0, 0, 0, False))

    def parse_size(self, args):
        """ Returns the sheet size. """
        size = int(args.split()[0])
        if size < len(self.sheetsizes):
            sheet = self.sheetsizes[size]
        else:
            sheet = 'unknown'
        return ('sheetsize', sheet)

    def parse_circle(self, args):
        """ Returns a parsed circle. """
        x, y, rad = [int(a) for a in args.split()]
        return ('shape', Circle(x, y, rad))

    def parse_box(self, args):
        """ Returns a parsed box. """
        x1, y1, x2, y2 = [int(a) for a in args.split()]
        return ('shape', Rectangle.from_corners(x1, y1, x2, y2))

    def parse_text(self, args):
        """ Parses a text label and returns as a Shape.Label. """
        x, y, _size, rot, _anchor, text = args.split(' ', 5)
        # TODO sort out alignment
        rot, _flip = self.rot_and_flip(rot)
        return ('shape', Label(int(x), int(y), text, align='left', rotation=rot))

    def parse_ver(self, args):
        """ Returns the ViewDraw output file format version. """
        # Viewdraw file version. So far have only dealt with 50, 51.
        return ('fileversion', args)

    def parse_line(self, args):
        """ Returns a parsed line. """
        numpts, _sep, pts = args.partition(' ')
        pts = [int(p) for p in pts.split()]
        numpts = int(numpts)
        # this next bit would be much easier if open polygons were
        # explicitly acceptable
        # TODO yuck, and callers need to special-case this
        return ('lines', [Line((pts[i], pts[i + 1]),(pts[i + 2], pts[i + 3]))
                          for i in range(0, (numpts - 1) * 2, 2)])

    def parse_arc(self, args):
        """ Returns a parsed arc. """
        # ViewDraw saves arcs as three points along a circle. Start, mid, end
        # [not entirely sure that mid is a midpoint, but irrelevant here]. We
        # need to find the centre of that circle, and the angles of the start
        # and end points. Tracing from start to end, the arcs are always CCW.

        # To find the centre: construct two chords using the three points. Lines
        # drawn perpendicular to and bisecting these chords will intersect at
        # the circle's centre.
        x0, y0, x1, y1, x2, y2 = [float(pt) for pt in args.split()]
        # can't allow for infinite slopes (m_a and m_b), and can't allow m_a
        # to be a zero slope.
        while abs(x0 - x1) < 0.1 or abs(x1 - x2) < 0.1 or abs(y0 - y1) < 0.1:
            x0, y0, x1, y1, x2, y2 = x1, y1, x2, y2, x0, y0
        # slopes of the chords
        m_a, m_b = (y1-y0) / (x1-x0), (y2-y1) / (x2-x1)
        # find the centre
        xcenter = ((m_a * m_b * (y0 - y2) + m_b * (x0 + x1) - m_a * (x1 + x2))
                   / (2 * (m_b - m_a)))
        ycenter = (-1/m_a) * (xcenter - (x0+x1) / 2) + (y0+y1) / 2
        # radius is the distance from the centre to any of the three points
        rad = sqrt((xcenter-x0)**2 + (ycenter-y0)**2)

        # re-init xs,ys so that start and end points don't get confused.
        x0, y0, x1, y1, x2, y2 = [float(pt) for pt in args.split()]

        def angle(x, y):
            """ Calculate the angle from the center of the arc to (x, y). """
            # as parsed, the angle increases CCW. Here, we return an angle
            # increasing CW
            opp = y - ycenter
            adj = x - xcenter
            if abs(adj) < 0.01:
                # vertical line to x,y
                if opp > 0:
                    return 3 * pi / 2
                else:
                    return pi / 2

            ang = atan(opp/adj)
            # correct for ambiguity due to atan
            if adj < 0:
                ang += pi

            # restrict angle to (0, 2pi) range
            ang = ang % (2 * pi)
            # upverter uses CW angles, so...
            return 2 * pi - ang

        return ('shape', Arc(int(round(xcenter)), int(round(ycenter)),
                             angle(x2,y2) / pi, angle(x0,y0) / pi,
                             int(round(rad))))

    def sub_nodes(self, sub_cmds):
        """ Parse and return any commands that the parent needs.

        Returns a dict in the same style as parse() that the parent node can
        use. Any use of this sub-tree is left up to the caller. """
        subdata = defaultdict(list)
        for phrase in self.stream:
            cmd, _sep, args = phrase.partition(' ')
            if cmd not in sub_cmds:
                self.stream.push(phrase)
                break
            k, v = self.parsenode(cmd)(args)
            subdata[k].append(v)
        return subdata

class ViewDrawSch(ViewDrawBase):
    """ Parser for a single schematic file. """

    def __init__(self, lib, filename):
        ViewDrawBase.__init__(self, filename)
        self.parsers.update({'N': 'parse_net',
                             'J': 'parse_junc',
                             'S': 'parse_seg',
                             'B': 'parse_seg', # FIXME No! It is a bus!
                             'I': 'parse_inst',
                             'C': 'parse_conn',
                             'U': 'parse_attr',
                             'D': 'parse_bounds'
                            })
        self.lib = lib

    def parse(self):
        '''Returns a Design built up from a schematic file that represents one
        sheet of the original schematic'''
        tree = ViewDrawBase.parse(self)
        # tree['lines'] is a [list of [list of lines]]
        tree['shape'].extend(sum(tree['lines'], []))
        ckt = Design()
        # TODO little weak here, a copy instead?
        ckt.components = self.lib

        for net in tree['net']:
            ckt.add_net(net)
        for inst in tree['inst']:
            ckt.add_component_instance(inst)
            # hold on tight, this is ugly
            for (netid, netpt, pinid) in inst.conns:
                net = [n for n in ckt.nets if n.net_id == netid][0]
                comp = ConnectedComponent(inst.instance_id, pinid)
                net.ibpts[netpt - 1].add_connected_component(comp)
            del inst.conns
        for net in ckt.nets:
            del net.ibpts

        for shape in tree['shape']:
            ckt.add_shape(shape)
            if isinstance(shape, Label):
                ann = Annotation(shape.text, shape.x, shape.y,
                                 shape._rotation, True)
                ckt.design_attributes.add_annotation(ann)

        for k, v, annot in tree['attr']:
            ckt.design_attributes.add_attribute(k, v)
            ckt.design_attributes.add_annotation(annot)

        return ckt

    def parse_net(self, args):
        """ Assembles a net from a list of junctions, segments, and labels. """
        thisnet = Net(args)
        subdata = self.sub_nodes('J S A L Q B'.split())
        # finish building thisnet
        for netpt in subdata['netpoint'][:]:
            # using a copy so that we can modify subdata['netpoint'] inside loop
            if netpt.point_id not in thisnet.points:
                thisnet.add_point(netpt)
            else:
                # oh yeah, a net can have a point more than once, because that
                # makes *great* sense.
                for point in netpt.connected_points:
                    thisnet.points[netpt.point_id].add_connected_point(point)
                for comp in netpt.connected_components:
                    thisnet.points[netpt.point_id].add_connected_component(comp)
                # update subdata['netpoint'] so that ref to netpt points to the
                # new combined point
                i = subdata['netpoint'].index(netpt)
                subdata['netpoint'][i] = thisnet.points[netpt.point_id]

        # yuck, passing in-band
        thisnet.ibpts = subdata['netpoint']

        for pt_a, pt_b in subdata['segment']:
            thisnet.connect((subdata['netpoint'][pt_a - 1],
                             subdata['netpoint'][pt_b - 1]))
        for annot in subdata['annot']:
            thisnet.add_annotation(annot)
            if '=' in annot.value:
                thisnet.add_attribute(*(annot.value.split('=', 1)))
        return ('net', thisnet)

    def parse_junc(self, args):
        """ Parses a junction on the net as a NetPoint. """
        x, y, _unknown = args.split()
        # unknown is suspected to be drawing style for the net at this
        # point (right-angle corner? T-section? Solder dot?) ATM not very
        # useful, not really our responsibility.
        return ('netpoint', NetPoint(x + 'x' + y, int(x), int(y)))

    def parse_seg(self, args):
        """ Returns a parsed net segment """
        pt_a, pt_b = [int(n) for n in args.split()]
        return ('segment', (pt_a, pt_b))

    def parse_inst(self, args):
        """ Returns a parsed component instance. """
        inst, libname, libnum, x, y, rot, scale, _unknown = args.split()
        # scale is a floating point scaling constant. Also, evil.
        if scale != '1':
            libkey = self.scaled_component(libname, libnum, scale)
        else:
            libkey = self.lookup(libname, libnum)
        thisinst = ComponentInstance(inst, self.lib.components[libkey],
                                     libkey, 0)
        rot, flip = self.rot_and_flip(rot)
        thisinst.add_symbol_attribute(SymbolAttribute(int(x), int(y),
                                                      rot, flip))
        subdata = self.sub_nodes('|R A C'.split())
        for annot in subdata['annot']:
            thisinst.symbol_attributes[0].add_annotation(annot)
            if '=' in annot.value:
                thisinst.add_attribute(*(annot.value.split('=', 1)))

        # Turns out C can reference a net before it's been created via
        # the N command. Really don't like passing stuff inband like this. Ugh.
        thisinst.conns = subdata['conn']
        return ('inst', thisinst)


    def scaled_component(self, libname, libnum, scale):
        """ Returns library key for a scaled component, creates it if needed """
        # libnames that we have parsed are lower case, so this is guaranteed
        # not to collide
        scaled_libname = ("SCALED-%s-" % scale) + self.lookup(libname, libnum)
        if scaled_libname not in self.lib.components:
            scaled_comp = deepcopy(self.lib.components[self.lookup(libname,
                                                                   libnum)])

            bodies = [bod for sym in scaled_comp.symbols for bod in sym.bodies]
            # ViewDraw scales towards the (minx, miny) corner, as opposed to
            # doing the sensible thing and scaling towards the origin. So for
            # every body, we're going to have to keep track of how the (minx,
            # miny) corner has moved, and shift it back to be in the same spot.
            premins = [body.bounds()[0] for body in bodies]
            scaled_comp.scale(float(scale))
            for body, premin in zip(bodies, premins):
                postmin = body.bounds()[0]
                body.shift(premin.x - postmin.x, premin.y - postmin.y)

            self.lib.add_component(scaled_libname, scaled_comp)
        return scaled_libname


    def parse_conn(self, args):
        """ Returns a parsed connection between component and net. """
        netid, segpin, pin, _unknown = args.split()
        # as far as has been observed, _unknown is always 0
        # segpin is the netpoint on the net
        # TODO I have no faith in pin variable here
        return ('conn', (netid, int(segpin), pin))

    def parse_bounds(self, args):
        """ Parses the bounds of this schematic sheet. """
        # Not sure if this is quite valid.
        return ('Dbounds', [int(a) for a in args.split()])

    def parse_attr(self, args):
        """ Returns a parsed attribute. """
        keyval = args.split(' ', 6)[-1]
        # need to keep the attribute key/val pair, as it may be clobbered while
        # creating the annotation.
        k, _sep, v = keyval.partition('=')
        # make an annotation out of it too, so that it displays on the design
        return ('attr', (k, v, self.parse_annot(args)[1]))

    def lookup(self, libname, num):
        """ Given a component name and version, returns the filename """
        return libname.lower() + '.' + num


class ViewDrawSym(ViewDrawBase):
    """ Parser for a library symbol file. """
    symtypes = ('composite', 'module', 'annotate', 'pin', 'power')
    # TODO A command

    def __init__(self, libdir, filename):
        ViewDrawBase.__init__(self, libdir + filename)
        self.parsers.update({'Y': 'parse_type',
                             'U': 'parse_attr',
                             'P': 'parse_pin',
                             'L': 'parse_label',
                            })
        self.libdir = libdir

    def parse(self):
        """ Parses a component from the library, returns a Compenent. """
        part = Component(self.filename)
        part.add_symbol(Symbol())
        part.symbols[0].add_body(SBody())

        tree = ViewDrawBase.parse(self)
        for k, v in tree['attr']:
            part.add_attribute(k, v)
        for shape in tree['shape'] + sum(tree['lines'], []):
            part.symbols[0].bodies[0].add_shape(shape)
        for pin in tree['pin']:
            part.symbols[0].bodies[0].add_pin(pin)

        return part

    def parse_type(self, args):
        """ Returns a parsed symbol type. """
        if int(args) < len(self.symtypes):
            symtype = self.symtypes[int(args)]
        else:
            symtype = 'unknown'
        return ('attr', ('symtype', symtype))

    def parse_attr(self, args):
        """ Returns a parsed attribute. """
        # part properties, some of which look in need of further
        # processing to properly extract the part
        key, _sep, val = args.split(' ', 6)[-1].partition('=')
        # I have seen some properties that have no value set, and don't
        # have '=' in the string. partition() will set val = ''

        #TODO are those properties names user-controlled? should I make
        # sure they don't collide with other attributes?
        return ('attr', (key, val))

    def parse_pin(self, args):
        """ Returns a parsed pin. """
        # Pin declaration, seems to only be done once per pin
        pid, x1, y1, x0, y0, _rot, _side, _inv = [int(a) for a in args.split()]
        # _rot and _side are not needed, because the x-y data tells us what we
        # need to know. _inv is used to draw the little inverted signal cirles.
        thispin = Pin(pid, (x0, y0), (x1, y1))
        subdata = self.sub_nodes(['L'])
        if len(subdata['label']) > 0:
            # I suppose if there's more than one label, just go with the first
            thispin.label = subdata['label'][0]
        return ('pin', thispin)

    def parse_label(self, args):
        """ Returns a parsed label. """
        # So far, only seen it for labelling pins, in the symmbol files
        # at least.
        x, y, _pts, rot, _anchor, _scope, _vis, inv, text = args.split()
        if inv == '1':
            # cheap-o overbar
            text = '/' + text
        rot, _flip = self.rot_and_flip(rot)
        return ('label', Label(int(x), int(y), text, 'left', rot))
        # I have a feeling the alignment will break, but anchor is a
        # vertical alignment thing


class ViewDraw:
    """ The viewdraw parser. """

    def __init__(self, schdir, symdirs):
        # symdirs is a dict; k,v = libname,directory
        # ^-that could be parsed out of a viewdraw.ini some day
        self.schdir, self.symdirs = schdir, symdirs

    @staticmethod
    def inifile(projdir, inidirsep='\\'):
        """ Attempt to get project info from a viewdraw.ini file

        No guarantees, but it should return a (schdir, symdirs) tuple that
        would work fine if passed to the ViewDraw constructor """

        with open(projdir + 'viewdraw.ini') as f:
            dirlines = [li.strip() for li in f.readlines() if
                        li.strip().startswith('DIR ')]
            schdir, symdirs = projdir + 'sym' + dirsep, {}
            for line in dirlines:
                # DIR [p] .\directory\to\lib (lib_name)
                _cmd, mode, vals = line.split(' ', 2)
                # libname might not exist, but if it does it's <= 32 chars, and
                # enclosed by parens
                libname = None
                if vals.endswith(')') and len(vals.rsplit('(', 1)[1]) <= 33:
                    dirname, libname = vals.rsplit('(', 1)
                    dirname, libname = dirname[:-1], libname[:-1]
                else:
                    dirname = vals
                # dirname can be quoted
                if dirname[0] == '"' and dirname[-1] == '"':
                    dirname = dirname[1:-1]
                dirname = dirname.replace(inidirsep, dirsep) + dirsep
                if 'p' in mode:
                    schdir = projdir + dirname + 'sch' + dirsep
                if libname is not None:
                    symdirs[libname] = projdir + dirname + 'sym' + dirsep
            return (schdir, symdirs)

    @staticmethod
    def auto_detect(filename): # pylint: disable=W0613
        """ Return our confidence that the given file is an viewdraw file """
        # I'm not sure what you'd throw this at right now, there is no "project
        # file" you could check. Maybe if/when viewdraw.ini parsing happens?
        return 0


    def parse(self):
        """ Parses a viewdraw project and returns a list of sheets. """
        lib = Components()
        # All the symbol files I have seen have a filename like partname.n
        # where n is a number, for multi-versioned parts I'm guessing
        for libname, libdir in self.symdirs.items():
            files = [f for f in listdir(libdir)
                     if f.rpartition('.')[-1].isdigit()]

            for f in files:
                lib.add_component((libname + ':' + f).lower(),
                                  ViewDrawSym(libdir, f).parse())

        sheets = list()
        schfiles = [f for f in listdir(self.schdir)
                    if f.split('.')[-1].isdigit()]
        for sch in sorted(schfiles, key=lambda s: int(s.split('.')[-1])):
            sheets.append(ViewDrawSch(lib, self.schdir + sch).parse())

        # For now, we'll return a list of designs, each one represents one
        # sheet in the viewdraw schematic.
        return sheets


class FileStack:
    """ Handles a file as a stack of lines, to be able to push back lines"""
    # Two reasons for this:
    # 1) Line continuations are signaled at the beginning of the continuing
    #   line. This means you can't know if line n is the entirety of a statement
    #   until you've checked line n+1
    # 2) Some commands are affected by preceeding commands, so need to check if
    #   the next command is of concern. If not, need to be able to send it back.

    def __init__(self, filename):
        self.f = open(filename)
        self.fstack = []
        self.line = 0

    def __iter__(self):
        return self

    def next(self):
        """ Returns the next command. Continuations handled transparently. """
        tok = self.subpop()
        try:
            nexttok = self.subpop()
            while nexttok.startswith(' ') or nexttok.startswith('+'):
                tok = self.continuation(tok, nexttok)
                nexttok = self.subpop()
            self.push(nexttok)
        except(StopIteration):
            # don't want to pass that up the chain if tok is valid
            pass
        return tok.strip('\r\n')

    def subpop(self):
        """ Next line, from the pushed-back stack if applicable. """
        if len(self.fstack) > 0:
            retval = self.fstack.pop()
        else:
            retval = self.f.next()
        # need to increment after iterators have had a chance to StopIteration
        self.line += 1
        return retval

    def continuation(self, tok, cont):
        """ Tie together multi-line commands. """
        if cont.startswith('+'):
            cont = cont[2:]
        return tok.strip('\r\n') + cont

    def push(self, tok):
        """ Push line back on the stack (before what would be the next line) """
        self.line -= 1
        self.fstack.append(tok)

########NEW FILE########
__FILENAME__ = upconverter
#!/usr/bin/env python2
""" A universal hardware design file format converter using 
Upverter's Open JSON Interchange Format """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Development:
#   Active: As of July, 2012
#   See: github.com/upverter/schematic-file-converter
#
# Authors:
#   Alex Ray ajray@ncsu.edu
#   Upverter support@upverter.com
#
# Contact:
#   Zak Homuth @ Upverter
#   zak@upverter.com
#   415-766-2333
#   24 Phoebe Street, Toronto, On
#
# Format & Documentation:
#   Based on Upverter's Open JSON Interchange Format
#   upverter.com/resources/open-json-format/
#
# Dependencies:
#   Python: 2.6+ (excluding 3.0+)
#   ArgumentParser
#
#
# Usage example:
#   python2 -m upconvert.upconverter -i test/openjson/simple.upv -o example.upv


import logging
import os
import sys
import operator
import tempfile
import zipfile
from argparse import ArgumentParser
try:
    import simplejson as json
except ImportError:
    import json

from upconvert import version as ver

from upconvert.parser import openjson as openjson_p, kicad as kicad_p, geda as geda_p, \
    eagle as eagle_p, eaglexml as eaglexml_p, fritzing as fritzing_p, gerber as gerber_p, \
    specctra as specctra_p
from upconvert.writer import openjson as openjson_w, kicad as kicad_w, geda as geda_w, \
    eagle as eagle_w, eaglexml as eaglexml_w, gerber as gerber_w, specctra as specctra_w, \
    bom_csv as bom_w, netlist_csv as netlist_w, ncdrill as ncdrill_w


# Try to include image writer support
try:
    from upconvert.writer import image as image_w
    image_parser = image_w.Image # pylint: disable=C0103
except ImportError, err:
    if err.message != 'No module named PIL':
        raise
    image_parser = None # pylint: disable=C0103


# Logging
logging.basicConfig(level=logging.DEBUG)
log = logging.getLogger('main')  # pylint: disable=C0103

PARSERS = {
    'openjson': openjson_p.JSON,
    'kicad': kicad_p.KiCAD,
    'geda': geda_p.GEDA,
    'eagle': eagle_p.Eagle,
    'eaglexml': eaglexml_p.EagleXML,
    'fritzing': fritzing_p.Fritzing,
    'gerber': gerber_p.Gerber,
    'specctra': specctra_p.Specctra,
}

WRITERS = {
    'openjson': openjson_w.JSON,
    'kicad': kicad_w.KiCAD,
    'geda': geda_w.GEDA,
    'eagle': eagle_w.Eagle,
    'eaglexml': eaglexml_w.EagleXML,
    'gerber': gerber_w.Gerber,
    'ncdrill': ncdrill_w.NCDrill,
    'specctra': specctra_w.Specctra,
    'image':  image_parser,
    'bom': bom_w.BOM,
    'netlist': netlist_w.Netlist,
}

EXTENSIONS = {
    'openjson': '.upv',
    'kicad': '.sch',
    'geda': '.sch',
    'eagle': '.sch',
    'eaglexml': '.sch',
    'fritzing': '.fz',
    'gerber': '.zip',
    'ncdrill': '.drill',
    'specctra': '.dsn',
    'image': '.png',
    'bom': '.csv',
    'netlist': '.csv',
}


class Upconverter(object):
    """ The bee knees """

    @staticmethod
    def autodetect(inputfile):
        """ Autodetect the given input files formatting """
        confidence = {}

        for name, parser in PARSERS.iteritems():
            confidence[name] = parser.auto_detect(inputfile)

        ordered = sorted(confidence.iteritems(), key=operator.itemgetter(1), reverse=True)
        if ordered[0][1] < 0.5:
            log.error('Failed to auto-detect input type for %s. best guess: %s, confidence: %s',
                      inputfile, ordered[0][0], ordered[0][1])
            raise Exception('failed to autodetect')

        log.info('Auto-detected input type: %s', ordered[0][0])
        return ordered[0][0]


    @staticmethod
    def parse(in_filename, in_format='openjson', **parser_kwargs):
        """ Parse the given input file using the in_format """

        log.debug('parsing %s in format %s', in_filename, in_format)
        try:
            if in_format == 'geda':
                par = PARSERS[in_format](**parser_kwargs)
            else:
                par = PARSERS[in_format]()
        except KeyError:
            raise Exception('ERROR: Unsupported input type: %s' % (in_format))

        return par.parse(in_filename)


    @staticmethod
    def write(dsgn, out_file, out_format='openjson', **parser_kwargs):
        """ Write the converted input file to the out_format """

        try:
            if out_format == 'geda':
                wri = WRITERS[out_format](**parser_kwargs)
            else:
                wri = WRITERS[out_format]()
        except KeyError:
            raise Exception('ERROR: Unsupported output type: %s' % (out_format))

        return wri.write(dsgn, out_file)


    @staticmethod
    def file_to_upv(file_content, lib_contents):
        """ convert file_content into upv data pre-jsonification """
        log.info('Starting to convert content into upv')

        tmp_dir = tempfile.mkdtemp()

        tmp_fd, tmp_path = tempfile.mkstemp(dir=tmp_dir)
        os.write(tmp_fd, file_content.read())
        os.close(tmp_fd)

        lib_path_list = []
        for lib_filename, lib_content in lib_contents.iteritems():
            lib_tmp_fd, lib_tmp_path = tempfile.mkstemp(suffix = lib_filename, prefix = lib_filename, dir=tmp_dir)
            os.write(lib_tmp_fd, lib_content.read())
            os.close(lib_tmp_fd)
            lib_path_list.append(lib_tmp_path)

        frmt = Upconverter.autodetect(tmp_path)
        design = Upconverter.parse(tmp_path, frmt)
        os.remove(tmp_path)

        for path in lib_path_list:
            os.remove(path)

        return json.loads(json.dumps(design.json(), sort_keys=True, indent=4))


    @staticmethod
    def json_to_format(upv_json_data, frmt, path):
        """ convert upv_json_data into format as a file @ path """
        log.info('Converting upv data into %s at %s', frmt, path)

        path_w_ext = path + EXTENSIONS[frmt]
        tmp_fd, tmp_path = tempfile.mkstemp()
        os.write(tmp_fd, upv_json_data)
        os.close(tmp_fd)

        design = Upconverter.parse(tmp_path, 'openjson')
        Upconverter.write(design, path_w_ext, frmt)
        os.remove(tmp_path)

        if frmt == 'kicad':
            kicad_zip = zipfile.ZipFile(path + '.zip', mode='w')
            kicad_zip.write(path_w_ext, os.path.basename(path_w_ext))
            kicad_zip.write(path + '-cache.lib', os.path.basename(path + '-cache.lib'))
            kicad_zip.close()
            path_w_ext = path + '.zip'
        elif frmt == 'geda':
            geda_zip = zipfile.ZipFile(path + '.zip', mode='w')
            geda_zip.write(path_w_ext, os.path.basename(path_w_ext))
            symbol_dir = os.path.join(os.path.dirname(path), 'symbols-' + os.path.basename(path_w_ext))
            for symbol_file in os.listdir(symbol_dir):
                geda_zip.write(os.path.join(symbol_dir, symbol_file), symbol_file)
            geda_zip.close()
            path_w_ext = path + '.zip'

        return path_w_ext


def main(): #pylint: disable=R0912,R0915
    """ Also, bees knees """
    argp = ArgumentParser()
    argp.add_argument("-i", "--input", dest="inputfile",
                      help="read INPUT file in", metavar="INPUT")
    argp.add_argument("-f", "--from", dest="inputtype",
                      help="read input file as TYPE", metavar="TYPE")
    argp.add_argument("-o", "--output", dest="outputfile",
                      help="write OUTPUT file out", metavar="OUTPUT")
    argp.add_argument("-t", "--to", dest="outputtype",
                      help="write output file as TYPE", metavar="TYPE",
                      default="openjson")
    argp.add_argument("-s", "--sym-dirs", dest="sym_dirs",
                      help="specify SYMDIRS to search for .sym files (for gEDA only)", 
                      metavar="SYMDIRS", nargs="+")
    argp.add_argument('--unsupported', action='store_true', default=False,
                      help="run with an unsupported python version")
    argp.add_argument('--raise-errors', dest='raise_errors',
                      action='store_true', default=False,
                      help="show tracebacks for parsing and writing errors")
    argp.add_argument('--profile', action='store_true', default=False,
                      help="collect profiling information")
    argp.add_argument('-v', '--version', action='store_true', default=False,
                      help="print version information and quit")
    argp.add_argument('--formats', action='store_true', default=False,
                      help="print supported formats and quit")

    args = argp.parse_args()

    if args.version:
        print "upconverter %s in python %s.%s" % (ver.version(), sys.version_info[0], sys.version_info[1])
        print "Copyright (C) 2007 Upverter, Inc."
        print "This is free software; see the source for copying conditions.  There is NO warranty; not even for",
        print "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
        sys.exit(0)

    if args.formats:
        print "upconverter supports the following file formats & encodings"
        print ""
        print "As Input:"
        for frmt in PARSERS:
            print "* %s (%s)" % (frmt, EXTENSIONS[frmt])
        print ""
        print "As Output:"
        for frmt in WRITERS:
            print "* %s (%s)" % (frmt, EXTENSIONS[frmt])
        sys.exit(0)

    # Fail if strict and wrong python version
    if sys.version_info[0] > 2 or sys.version_info[1] > 6:
        print 'WARNING: RUNNING UNSUPPORTED VERSION OF PYTHON (%s.%s > 2.6)' % (sys.version_info[0],
            sys.version_info[1])
        if not args.unsupported:
            sys.exit(-1)

    inputtype = args.inputtype
    outputtype = args.outputtype
    inputfile = args.inputfile
    outputfile = args.outputfile

    parser_kwargs = {}
    if args.sym_dirs:
        parser_kwargs['symbol_dirs'] = args.sym_dirs

    # Test for input file
    if inputfile == None:
        log.error('No input file provided.')
        argp.print_help()
        exit(1)

    # Autodetect input type
    if inputtype == None:
        try:
            inputtype = Upconverter.autodetect(inputfile)
        except Exception: #pylint: disable=W0703
            argp.print_help()
            exit(1)

    # Autoset output file
    if outputfile == None:
        try:
            file_name, file_ext = os.path.splitext(inputfile)  #pylint: disable=W0612
            outputfile = file_name + EXTENSIONS[outputtype]
            log.info('Setting output file & format: %s', outputfile)
        except Exception: #pylint: disable=W0703
            log.error('Failed to set output file & format.')
            argp.print_help()
            exit(1)

    if args.profile:
        import cProfile
        profile = cProfile.Profile()
        profile.enable()

    # parse the data
    try:
        design = Upconverter.parse(inputfile, inputtype, **parser_kwargs) #pylint: disable=W0142
    except Exception: #pylint: disable=W0703
        if args.raise_errors:
            raise
        print "ERROR: Failed to parse", inputtype
        exit(1)

    # we got a good result
    if design is not None:
        try:
            Upconverter.write(design, outputfile, outputtype, **parser_kwargs) #pylint: disable=W0142
        except Exception: #pylint: disable=W0703
            if args.raise_errors:
                raise
            print "ERROR: Failed to write", outputtype
            exit(1)

    # parse returned None -> something went wrong
    else:
        print "Output cancelled due to previous errors."
        exit(1)

    if args.profile:
        profile.disable()
        profile.print_stats()


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = stringify
""" Converts all attribute values to a string """

import unicodedata

def stringify_attributes(attributes):
    """ Converts all attribute values to a string """
    attrs = {}
    for name, value in attributes.iteritems():
        try:
            attrs[name] = str(value)
        except UnicodeEncodeError:
            attrs[name] = unicodedata.normalize('NFKD', value)
    return attrs
########NEW FILE########
__FILENAME__ = verify_json
""" 
Checks the following for the converted JSON:
    - has component component instances
    - component instances match up with a defined component
    - nets do not contain pins that don't exist
"""

def verify_json(data):
    """ 
    Checks the following for the converted JSON:
        - has component component instances
        - component instances match up with a defined component
        - nets do not contain pins that don't exist
    """
    assert ('component_instances' in data)
    assert (len(data['component_instances']) > 0)
    assert ('components' in data)

    # key is the instance id. value is the library id
    instance_and_lib = {}

    #make sure each instance's library id is defined as a component
    for instance in data['component_instances']:
        assert (instance['library_id'] in data['components'])
        instance_and_lib[instance['instance_id']] = instance['library_id']

    # key is the component name. value is the number of pins it has
    component_and_pins = {}

    for comp_id, comp in data['components'].iteritems():
        component_and_pins[comp_id] = []
        for symbol in comp['symbols']:
            for body in symbol['bodies']:
                for pin in body ['pins']:
                    component_and_pins[comp_id].append(pin['pin_number'])

    assert ('nets' in data)

    # check to make sure that a net doesn't have an instance with a pin number that
    # its component doesn't have
    for net in data['nets']:
        for point in net['points']:
            for comp in point['connected_components']:
                lib_id = instance_and_lib[comp['instance_id']]
                assert (comp['pin_number'] in component_and_pins[lib_id])

########NEW FILE########
__FILENAME__ = version
#!/usr/bin/env python2
""" The package version tool """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import subprocess

def version():
    """ Attempt to return the version of the converter """
    try:
        if os.path.exists(".git/"):
            subprocess.call(["git describe --tags > version"])
        with open('version', 'r') as f:
            vrsn = f.read().strip()
    except Exception: #pylint: disable=W0703
        vrsn = '0.8.9'

    return vrsn

########NEW FILE########
__FILENAME__ = altium
#!/usr/bin/env python2
""" The Altium Format Writer """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


class Altium(object):
    """ The Altium Format Writer """

    def write(self, filename):
        """ Write the design to the Altium format """

        with open(filename, "w") as f:
            f.write('Altium export is currently unsupported')

########NEW FILE########
__FILENAME__ = bom_csv
#!/usr/bin/env python2
""" The BOM Format Writer """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


class BOM(object):
    """ The BOM Format Writer """

    def write(self, design, filename):
        """ Write the design to the BOM format """

        bom = {}
        for c in design.component_instances:
            refdes = c.instance_id
            if 'refdes' in c.attributes:
                refdes = c.attributes['refdes']

            if c.library_id in bom:
                bom[c.library_id]['refs'].append(refdes)

            else:
                library_part = design.components.components[c.library_id]
                name = ''
                if '_manufacturer' in library_part.attributes:
                    name += library_part.attributes['_manufacturer'] + ' '
                if '_part_number' in library_part.attributes:
                    name += library_part.attributes['_part_number']
                bom[c.library_id] = {'part': c.library_id,
                                     'name': name,
                                     'refs': [refdes]}

        with open(filename, "w") as f:
            f.write('Part,Name,Reference,Qty\n')
            for c in bom.values():
                if len(c['refs']) > 0 and c['part'] != '0000000000000001':
                    f.write('%s,"%s","%s",%s\n' % (c['part'], c['name'], ','.join(c['refs']), len(c['refs'])))

########NEW FILE########
__FILENAME__ = eagle
#!/usr/bin/env python2
""" This module provides a writer class to generate valid Eagle
    file format data from an OpenJSON design.

    TODO more description

    TODO usage samples
"""

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# 
# Note: This writer saves file as a 5.11 version one.
#


import struct
import re
import math

from upconvert.core.shape import Line, Label, Rectangle, Arc, \
    BezierCurve, Circle, Polygon

#from upconvert.parser.eagle import EagleBinConsts


class Eagle: # pylint: disable=R0902
    """ The Eagle format writer """

    class Header:
        """ A struct that represents a header """
        constant = 0x10
        template = "=4BI4B3I"

        def __init__(self, version="5.11", numofblocks=0):
            """ Just a constructor
                Num Of Headers has to be validated!
            """
            self.version = version # has to be of x.y (dot-separated) format
            self.numofblocks = numofblocks
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, 0, 
                                   self.numofblocks,
                                   int(self.version.split('.')[0]),
                                   int(self.version.split('.')[1]),
                                   0, 0, 
                                   0, 0, 0
                                  )
            return _ret_val

    class Settings:
        """ A struct that represents ?? settings ??
        """
        constant = 0x11
        template = "=4BI4BII4B"

        # TODO if i need to synchronize access?..
        counter = 0

        def __init__(self, copyno=0, seqno=None):
            """ Just a constructor
            """
            if None == seqno:
                seqno = Eagle.Settings.counter
                Eagle.Settings.counter += 1
            else:
                Eagle.Settings.counter = 1 + seqno
            self.seqno = seqno # looks like first and second blocks
                               #  starts with the same byte set
                               #  but then the second set starts to evolve
            self.copyno = copyno # holds No of a 'Save As..' copy
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, 0,
                                   0,
                                   0, 0xcd, 0, self.copyno,
                                   0x99207800,
                                   0xa9471aa0,
                                   0xcd, 0, 0, 0
                                  )
            return _ret_val

    class Grid:
        """ A struct that represents a grid
        """
        constant = 0x12
        template = "=4B5I"

        unitmask = 0x0f
        units = {
                 0x0f: "inch",
                 0x00: "mic",
                 0x05: "mm",
                 0x0a: "mil",
                }
        lookmask = 2
        look = {
                0: "lines",
                2: "dots",
               }
        showmask = 1
        show = {
                0: False,
                1: True,
               }

        def __init__(self, distance=0.1, unitdist="inch", unit="inch", # pylint: disable=R0913
                style="lines", multiple=1, display=False, altdistance=0.01, 
                altunitdist="inch", altunit="inch"):
            """ Just a constructor
            """
            self.distance = distance
            self.unitdist = unitdist
            self.unit = unit
            self.style = style
            self.multiple = multiple
            self.display = display
            self.altdistance = altdistance
            self.altunitdist = altunitdist
            self.altunit = altunit
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _look = 0
            for _dd in self.show:
                if self.show[_dd] == self.display:
                    _look += _dd
            for _ss in self.look:
                if self.look[_ss] == self.style:
                    _look += _ss

            _units = 0
            for _uu in self.units:
                if self.units[_uu] == self.unit:
                    _units += _uu
                if self.units[_uu] == self.altunit:
                    _units += (_uu << 4)

# strage float format here: 8 bytes ; no idea yet
# thus proceeding in 6.0.0 way: default values are used
# (but units are preserved; 6.0.0 uses default set -- with inches)
            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 
                                   _look, _units,
                                   self.multiple,
                                   0x9999999a, 0x3fb99999,
                                   0x47ae147b, 0x3f847a1e,
                                  )
            return _ret_val

    class Layer:
        """ A struct that represents a layer
        """
        constant = 0x13
        template = "=7B2I9s"

        linkedsignmask = 0x10

        visactmask = 0x0e
        visact = 0x0e
        nvisact = 0x02

        max_embed_len = 9
        no_embed_str = b'\x7f'

#        colors = ['unknown','darkblue','darkgreen','darkcyan',
#                'darkred','unknown','khaki','grey',
## light variants x8
#                 ]
#        fill = ['none','filled',
## total 16; different line and dot patterns
#               ]

        def __init__(self, number, name, color, fill, visible, active, # pylint: disable=R0913
                     linkednumber=None, linkedsign=0):
            """ Just a constructor
            """
            self.number = number
            self.name = name
            self.color = color
            self.fill = fill
            self.visible = visible
            self.active = active
            self.linkedsign = linkedsign
            if None == linkednumber:
                linkednumber = number
            self.linkednumber = linkednumber
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _vis_act_link = 0x00
            if self.visible and self.active:
                _vis_act_link += self.visact
            elif not self.visible and self.active:
                _vis_act_link += self.nvisact
            if self.linkedsign:
                _vis_act_link += self.linkedsignmask

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, _vis_act_link, 
                                   self.number, self.linkednumber,
                                   self.fill, self.color,
                                   0, 0,
                                   _name,
                                  )
            return _ret_val

    class ShapeSet(object):
        """ A struct that represents a bunch of shapes
        """

        def __init__(self, numofshapes=0, shapes=None):
            """ Just a constructor
            """
            self.numofshapes = numofshapes
            if None == shapes:
                shapes = []
            self.shapes = shapes
            return

    class NamedShapeSet(ShapeSet):
        """ A struct that represents a *named* bunch of shapes
        """

        def __init__(self, name, numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.NamedShapeSet, self).__init__(numofshapes, shapes)
            self.name = name
            return

    class Web(object):
        """ A base struct for a bunch of shapesets
            It's needed to uniform parsing and counting of members
        """

        def __init__(self, name, numofblocks=0, numofshapesets=0, 
                     shapesets=None):
            """ Just a constructor
            """
            self.name = name
            self.numofblocks = numofblocks
            self.numofshapesets = numofshapesets
            if None == shapesets:
                shapesets = []
            self.shapesets = shapesets
            return

    class AttributeHeader:
        """ A struct that represents a header of attributes
        """
        constant = 0x14
        template = "=4B3I3B5s"

        max_embed_len = 5
        no_embed_str = b'\x7f'

        defxreflabel = ":%F%N/%S.%C%R"
        defxrefpart = "/%S.%C%R"
        delimeter = b'\t'

        def __init__(self, schematic, numofshapes=0, numofattributes=0):
            """ Just a constructor
            """
            self.schematic = schematic
            self.numofshapes = numofshapes # to be validated!
            self.numofattributes = numofattributes # to be validated!
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _schematic = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.schematic:
                _schematic = ''
            elif self.max_embed_len >= len(self.schematic):
                _schematic = self.schematic
            else:
                Eagle.attr_jar_append(self.schematic)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, 0,
                                   0, 
                                   1 + self.numofshapes, # TODO recheck +1
                                   self.numofattributes,
                                   0, 0, 0,
                                   _schematic,
                                  )
            return _ret_val

    class Library:
        """ A struct that represents a library
        """
        constant = 0x15
        template = "=4B3I8s"

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, name, numofdevsetblocks=0, devsets=None, # pylint: disable=R0913
                     numofsymbolblocks=0, symbols=None,
                     numofpackageblocks=0, packages=None,):
            """ Just a constructor
            """
            self.name = name

            self.numofdevsetblocks = numofdevsetblocks
            if None == devsets:
                devsets = []
            self.devsets = devsets

            self.numofsymbolblocks = numofsymbolblocks
            if None == symbols:
                symbols = []
            self.symbols = symbols

            self.numofpackageblocks = numofpackageblocks
            if None == packages:
                packages = []
            self.packages = packages
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, 0,
                                   self.numofdevsetblocks,
                                   self.numofsymbolblocks,
                                   self.numofpackageblocks,
                                   _name,
                                  )
            return _ret_val

    class DeviceSetHeader(Web):
        """ Not a real "Web" but with a like structure
        """
        constant = 0x17
        template = "=4B3I8s"

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, name, numofblocks=0, numofshapesets=0, 
                     shapesets=None):
            """ Just a constructor
            """
            super(Eagle.DeviceSetHeader, self).__init__(name, numofblocks, 
                        numofshapesets, shapesets)
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, 0,
                                   self.numofblocks,
                                   self.numofshapesets,
                                   0,
                                   _name,
                                  )
            return _ret_val

    class SymbolHeader(Web):
        """ A struct that represents a header of symbols
        """
        constant = 0x18
        template = "=4B3I8s"

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, name, numofblocks=0, numofshapesets=0, 
                     shapesets=None):
            """ Just a constructor
            """
            super(Eagle.SymbolHeader, self).__init__(name, numofblocks, 
                        numofshapesets, shapesets)
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, 0,
                                   self.numofblocks,
                                   self.numofshapesets,
                                   0,
                                   _name,
                                  )
            return _ret_val

    class PackageHeader(Web):
        """ A struct that represents a header of packages
        """
        constant = 0x19
        template = "=4B3I8s"

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, name, numofblocks=0, numofshapesets=0, 
                     shapesets=None):
            """ Just a constructor
            """
            super(Eagle.PackageHeader, self).__init__(name, numofblocks, 
                        numofshapesets, shapesets)
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, 0,
                                   self.numofblocks,
                                   self.numofshapesets,
                                   0,
                                   _name,
                                  )
            return _ret_val

    class Symbol(NamedShapeSet):
        """ A struct that represents a symbol
        """
        constant = 0x1d
        template = "=2BHI4BI8s"

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, libid, name, numofshapes=0, shapes=None):
            """ Just a constructor; shown for a sake of clarity
            """
            super(Eagle.Symbol, self).__init__(name, numofshapes, shapes)
            self.libid = libid
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 
                                   self.numofshapes,
                                   0, 0, self.libid, 0, 0, 0,
                                   _name,
                                  )
            return _ret_val

    class Package(NamedShapeSet):
        """ A struct that represents a package
        """
        constant = 0x1e
        template = "=2BH2IB5s6s"

        max_embed_nlen = 5
        max_embed_dlen = 6
        no_embed_str = b'\x7f'

        def __init__(self, name, desc, numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.Package, self).__init__(name, numofshapes, shapes)
            self.desc = desc
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_nlen >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _desc = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.desc:
                _desc = ''
            elif self.max_embed_dlen >= len(self.desc):
                _desc = self.desc
            else:
                Eagle.attr_jar_append(self.desc)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 
                                   self.numofshapes,
                                   0, 0, 0,
                                   _name,
                                   _desc
                                  )
            return _ret_val

    class Net(NamedShapeSet):
        """ A struct that represents a net
        """
        constant = 0x1f
        template = "=2BH2I4B8s"

        constantmid1 = 0x7fff7fff
        constantmid2 = 0x80008000

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, name, nclass, numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.Net, self).__init__(name, numofshapes, shapes)
            self.nclass = nclass
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0,
                                   self.numofshapes,
                                   self.constantmid1,
                                   self.constantmid2,
                                   0, self.nclass, 0, 0,
                                   _name,
                                  )
            return _ret_val

    class Part(NamedShapeSet):
        """ A struct that represents a part
        """
        constant = 0x38
        template = "=2B3H3B5s8s" 

        max_embed_len1 = 5
        max_embed_len2 = 8
        no_embed_str = b'\x7f'

        val_sign_mask = 0x01

        def __init__(self, name, libid, devsetndx, symvar, techno, value='', # pylint: disable=R0913
                     numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.Part, self).__init__(name, numofshapes, shapes)
            self.value = value
            self.libid = libid
            self.devsetndx = devsetndx
            self.symvar = symvar # within a devset!
            self.techno = techno
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len1 >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _value = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.value:
                _value = ''
            elif self.max_embed_len2 >= len(self.value):
                _value = self.value
            else:
                Eagle.attr_jar_append(self.value)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0,
                                   self.numofshapes,
                                   self.libid, 
                                   self.devsetndx,
                                   self.symvar, 
                                   self.techno,
                                   self.val_sign_mask 
                                        if 'None' != self.value and
                                            0 != len(self.value) else 0,
                                   _name,
                                   _value,
                                  )
            return _ret_val

    class DeviceSet(NamedShapeSet):
        """ A struct that represents a deviceset
        """
        constant = 0x37
        template = "=2B2H2B5s5s6s" 

        max_embed_len1 = 5
        max_embed_len2 = 5
        max_embed_len3 = 6
        no_embed_str = b'\x7f'

        nopref_sign_mask = 0x02
        uservalue_sign_mask = 0x01

        def __init__(self, name, prefix, description, uservalue, # pylint: disable=R0913
                     numofshapes=0, shapes=None,
                     numofconnblocks=0, connblocks=None):
            """ Just a constructor
            """
            super(Eagle.DeviceSet, self).__init__(name, numofshapes, shapes)
            self.prefix = prefix
            self.description = description
            self.uservalue = uservalue

            self.numofconnblocks = numofconnblocks
            if None == connblocks:
                connblocks = []
            self.connblocks = connblocks
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _signs = 0
            if '' == self.prefix:
                _signs += self.nopref_sign_mask
            if self.uservalue:
                _signs += self.uservalue_sign_mask

            _prefix = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.prefix:
                _prefix = ''
            elif self.max_embed_len1 >= len(self.prefix):
                _prefix = self.prefix
            else:
                Eagle.attr_jar_append(self.prefix)

            _desc = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.description:
                _desc = ''
            elif self.max_embed_len2 >= len(self.description):
                _desc = self.description
            else:
                Eagle.attr_jar_append(self.description)

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len3 >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0,
                                   self.numofshapes,
                                   self.numofconnblocks,
                                   _signs, 0,
                                   _prefix,
                                   _desc,
                                   _name,
                                  )
            return _ret_val

    class Bus(NamedShapeSet):
        """ A struct that represents a bus
        """
        constant = 0x3a
        template = "=2BH20s" 

        max_embed_len = 20
        no_embed_str = b'\x7f'

        def __init__(self, name, numofshapes=0, shapes=None):
            """ Just a constructor; shown for a sake of clarity
            """
            super(Eagle.Bus, self).__init__(name, numofshapes, shapes)
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0,
                                   self.numofshapes,
                                   _name,
                                  )
            return _ret_val

    class ShapeHeader(ShapeSet):
        """ A struct that represents a header of shapes
        """
        constant = 0x1a
        template = "=2BH5I"

        def __init__(self, numofshapes=0, shapes=None, # pylint: disable=R0913
                     numofpartblocks=0, parts=None,
                     numofbusblocks=0, buses=None,
                     numofnetblocks=0, nets=None,):
            """ Just a constructor
            """
            super(Eagle.ShapeHeader, self).__init__(numofshapes, shapes)

            self.numofpartblocks = numofpartblocks
            if None == parts:
                parts = []
            self.parts = parts

            self.numofbusblocks = numofbusblocks
            if None == buses:
                buses = []
            self.buses = buses

            self.numofnetblocks = numofnetblocks
            if None == nets:
                nets = []
            self.nets = nets
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 
                                   self.numofshapes,
                                   0, 0, 
                                   self.numofpartblocks, 
                                   self.numofbusblocks, 
                                   self.numofnetblocks,
                                  )
            return _ret_val

    class Segment(ShapeSet):
        """ A struct that represents a segment
        """
        constant = 0x20
        template = "=2BHI4B3I"

        def __init__(self, numofshapes=0, shapes=None,
                     cumulativenumofshapes=0):
            """ Just a constructor
            """
            super(Eagle.Segment, self).__init__(numofshapes, shapes)
            self.cumulativenumofshapes = cumulativenumofshapes
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 
                                   self.numofshapes,
                                   0,
                                   0, self.cumulativenumofshapes, 0, 0, # TODO recheck
                                   0, 0, 0
                                  )
            return _ret_val

    class ConnectionHeader(ShapeSet):
        """ A struct that represents a header for 'connections' blocks
        """
        constant = 0x36
        template = "=2B2H13s5s"

        constantmid_def = "''"

        no_embed_str = b'\x7f'
        max_embed_len = 13

        delim_techs = b'\x04'
        delim_namesvals = b'\x04'
        delim_names = b'\x01'
        delim_vals = b'\x02'

        def __init__(self, sindex, attributes, technologies, name, # pylint: disable=R0913
                     numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.ConnectionHeader, self).__init__(numofshapes, shapes)
            self.sindex = sindex
            
            if None == technologies:
                technologies = []
            self.technologies = technologies

            if None == attributes:
                attributes = []
            self.attributes = attributes
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _attrstechs = self.no_embed_str + r'\0\0\0' + b'\x09'
            if 0 < len(self.technologies):
                _at2 = self.delim_techs + self.delim_techs.join(self.technologies)
                if self.max_embed_len >= len(_at2):
                    _attrstechs = _at2
                else:
                    Eagle.attr_jar_append(_at2)
            elif 0 < len(self.attributes):
                _at2 = self.delim_namesvals.join((
                        self.delim_names + self.delim_names.join(
                                        [x for x, y in self.attributes]),
                        self.delim_names + self.delim_names.join(
                                        [y for x, y in self.attributes]),
                        ))
                if self.max_embed_len >= len(_at2):
                    _attrstechs = str(_at2)
                else:
                    Eagle.attr_jar_append(_at2)
            else:
                _attrstechs = ''

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 
                                   self.numofshapes,
                                   self.sindex,
                                   _attrstechs,
                                   self.constantmid_def,
                                  )
            return _ret_val

    class Connections:
        """ A struct that represents a set of connection indexes
        """
        constant = 0x3c
        template = "=2B22B"

        connset_len = 22

        def __init__(self, connections=None):
            """ Just a constructor
            """
            if None == connections:
                connections = []
            self.connections = connections
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _indexes = self.connections + [0,] * (self.connset_len - 
                                            len(self.connections))

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 
                                   *_indexes
                                  )
            return _ret_val

    class Shape(object):
        """ A base struct for shapes, provides common codecs
             Although it provides two scaling methods, #2 has 
             to be used all the time
        """

        scale1a = 1000000.0
        scale1b = 2
        scale2 = 10000.0

        width_xscale = 2
        size_xscale = 2
        ratio_sscale = 2

        rotatemask = 0x0c # in some cases 0x0f works as well
        rotates = {
                   0x00: None,
                   0x01: "R40",
                   0x02: "R45",
                   0x04: "R90",
                   0x06: "R135",
                   0x08: "R180",
                   0x0a: "R225",
                   0x0c: "R270",
                   0x0e: "R315",
# ones below are possible for text & frame -- don't apply the mask there
                   0x10: "MR0",
                   0x12: "MR45",
                   0x14: "MR90",
                   0x16: "MR135",
                   0x18: "MR180",
                   0x1a: "MR225",
                   0x1c: "MR270",
                   0x1e: "MR315",

                   0x40: "SR0", #...
                  }

        fonts = {
                  0x00: "vector",
                  0x01: None, # "proportional",
                  0x02: "fixed",
                 }

        def __init__(self, layer):
            """ Just a constructor
            """
            self.layer = layer
            return 

        @staticmethod
        def encode_real(real, algo=2):
            """ Transforms given value to a binary representation
            """
            _ret_val = 0
            if 1 == algo:
                _ret_val = (int(real * Eagle.Shape.scale1a) >> 
                                                Eagle.Shape.scale1b)
            else:
                _ret_val = real * Eagle.Shape.scale2
                if 0 < _ret_val:
                    _ret_val += 0.01
                else:
                    _ret_val -= 0.01
            return int(_ret_val)

        @staticmethod
        def rotate2strings(rotate):
            """ Converts pi-radian number into 'rotates' string
                It could be implemented as a map, but a special handling for 
                 None as 0. would be needed..
            """
            _ret_val = None

            if 0.5 == rotate:
                _ret_val = 'R90'
            elif 1.0 == rotate:
                _ret_val = 'R180'
            elif 1.5 == rotate:
                _ret_val = 'R270'
            return _ret_val 

    class Polygon(ShapeSet, Shape):
        """ A struct that represents a polygon
        """
        constant = 0x21
        template = "=2BH2I2H4BI"

        def __init__(self, width, layer, numofshapes=0, shapes=None):
            """ Just a constructor
            """
            super(Eagle.Polygon, self).__init__(numofshapes, shapes)
            self.layer = layer # no Shape constructor will be called
            self.width = width
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _ret_val = struct.pack(self.template,
                                   self.constant, 0,
                                   self.numofshapes,
                                   0, # maybe a constant 0xfffeff05
                                   0,
                                   Eagle.Shape.encode_real(
                                       self.width / self.width_xscale),
                                   0,
                                   0, 0, self.layer, 0,
                                   0,
                                  )
            return _ret_val

    class Instance(ShapeSet, Shape):
        """ A struct that represents an instance
        """
        constant = 0x30
        template = "=2BH2iH6BI"

        smashed_mask = 0x01
        smashed2_mask = 0x02

        constantmid = 0xffff

        def __init__(self, x, y, smashed, rotate, numofshapes=0, # pylint: disable=R0913
                     shapes=None):
            """ Just a constructor
            """
            super(Eagle.Instance, self).__init__(numofshapes, shapes)
#            super(Eagle.Shape, self).__init__(-1)
            self.x = x
            self.y = y
            self.smashed = smashed
            self.rotate = rotate
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _rotate = 0
            for _rr in self.rotates:
                if self.rotates[_rr] == self.rotate:
                    _rotate = _rr
                    break

            _ret_val = struct.pack(self.template,
                                   self.constant, 0,
                                   self.numofshapes,
                                   self.encode_real(self.x),
                                   self.encode_real(self.y),
                                   self.constantmid,
                                   0, 0, 0,
                                   _rotate,
                                   self.smashed_mask if self.smashed
                                        else 0,
                                   0, 0
                                  )
            return _ret_val

    class Circle(Shape):
        """ A struct that represents a circle
        """
        constant = 0x25
        template = "=4B2i2IH2B"

        def __init__(self, x, y, radius, width, layer): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.Circle, self).__init__(layer)
            self.x = x
            self.y = y
            self.radius = radius
            self.width = width
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _ret_val = struct.pack(self.template,
                                   self.constant, 
                                   0, 0, self.layer,
                                   Eagle.Shape.encode_real(self.x),
                                   Eagle.Shape.encode_real(self.y),
                                   Eagle.Shape.encode_real(self.radius),
                                   Eagle.Shape.encode_real(self.radius),
                                   Eagle.Shape.encode_real(
                                       self.width / self.width_xscale),
                                   0, 0
                                  )
            return _ret_val

    class Rectangle(Shape):
        """ A struct that represents a rectangle
        """
        constant = 0x26
        template = "=4B4i4B"

        def __init__(self, x1, y1, x2, y2, layer, rotate): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.Rectangle, self).__init__(layer)
            self.x1 = x1
            self.y1 = y1
            self.x2 = x2
            self.y2 = y2
            self.rotate = rotate
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _rotate = 0
            for _rr in Eagle.Rectangle.rotates:
                if Eagle.Rectangle.rotates[_rr] == self.rotate:
                    _rotate = _rr
                    break

            _ret_val = struct.pack(Eagle.Rectangle.template,
                                   Eagle.Rectangle.constant, 
                                   0, 0, self.layer,
                                   Eagle.Shape.encode_real(self.x1),
                                   Eagle.Shape.encode_real(self.y1),
                                   Eagle.Shape.encode_real(self.x2),
                                   Eagle.Shape.encode_real(self.y2),
                                   0, _rotate, 0, 0
                                  )
            return _ret_val

    class Wire(Shape):
        """ A struct that represents a wire
        """
        constant = 0x22
        template = "=4B4iH2B"

        stylemask = 0x0f
        styles = {
                  0x00: "Continuous",
                  0x01: "LongDash",
                  0x02: "ShortDash",
                  0x03: "DashDot",
                 }

        arc_sign = 0x81

        def __init__(self, x1, y1, x2, y2, style, layer, width): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.Wire, self).__init__(layer)
            self.x1 = x1
            self.y1 = y1
            self.x2 = x2
            self.y2 = y2
            self.width = width
            self.style = style
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _signs = 0
            for _ss in self.styles:
                if self.styles[_ss] == self.style:
                    _signs += _ss
                    break

            _ret_val = struct.pack(self.template,
                                   self.constant, 
                                   0, 0, self.layer,
                                   Eagle.Shape.encode_real(self.x1),
                                   Eagle.Shape.encode_real(self.y1),
                                   Eagle.Shape.encode_real(self.x2),
                                   Eagle.Shape.encode_real(self.y2),
                                   Eagle.Shape.encode_real(
                                       self.width / self.width_xscale),
                                   _signs, 0
                                  )
            return _ret_val

    class Junction(Shape):
        """ A struct that represents a junction
        """
        constant = 0x27
        template = "=4B5I"

        constantmid = 0x000013d8

        def __init__(self, x, y, layer):
            """ Just a constructor
            """
            super(Eagle.Junction, self).__init__(layer)
            self.x = x
            self.y = y
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, self.layer,
                                   self.constantmid,
                                   Eagle.Shape.encode_real(self.x),
                                   Eagle.Shape.encode_real(self.y),
                                   0, 0
                                  )
            return _ret_val

    class Hole(Shape):
        """ A struct that represents a hole
            (no layer is available for hole ; base Shape class
            is used both for uniformity and convertors)
        """
        constant = 0x28
        template = "=4B5I"

        def __init__(self, x, y, drill):
            """ Just a constructor
            """
            super(Eagle.Hole, self).__init__(-1)
            self.x = x
            self.y = y
            self.drill = drill
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, 0,
                                   Eagle.Shape.encode_real(self.x),
                                   Eagle.Shape.encode_real(self.y),
                                   Eagle.Shape.encode_real(
                                       self.drill / self.width_xscale),
                                   0, 0
                                  )
            return _ret_val

    class SMD(Shape):
        """ A struct that represents an SMD (Surface Mount Device)
        """
        constant = 0x2b
        template = "=4B2i2H3B5s"

        max_embed_len = 5
        no_embed_str = b'\x7f'

        def __init__(self, name, x, y, dx, dy, layer): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.SMD, self).__init__(layer)
            self.name = name
            self.x = x
            self.y = y
            self.dx = dx
            self.dy = dy
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, self.layer,
                                   Eagle.Shape.encode_real(self.x),
                                   Eagle.Shape.encode_real(self.y),
                                   Eagle.Shape.encode_real(
                                       self.dx / self.width_xscale),
                                   Eagle.Shape.encode_real(
                                       self.dy / self.width_xscale),
                                   0, 0, 0,
                                   _name,
                                  )
            return _ret_val

    class Arc(Wire):
        """ A struct that represents an arc
        """
        template = "=4B4IH2B" # 3-bytes long coords here..

        capmask = 0x10
        caps = {
                0x00: None,
                0x10: "flat",
               }
        directionmask = 0x20
        directions = {
                      0x00: "clockwise",        # == negative curve (angle)
                      0x20: "counterclockwise", # == positive curve (angle)
                     }

        def __init__(self, x1, y1, x2, y2, style, layer, width, # pylint: disable=R0913
                        curve, cap, direction):
            """ Just a constructor
            """
            super(Eagle.Arc, self).__init__(x1, y1, x2, y2, style, layer, width)
            self.curve = curve
            self.cap = cap
            self.direction = direction
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _signs = 0
            for _dd in self.directions:
                if self.directions[_dd] == self.direction:
                    _signs += _dd
                    break
            for _cc in self.caps:
                if self.caps[_cc] == self.cap:
                    _signs += _cc
                    break
            for _ss in self.styles:
                if self.styles[_ss] == self.style:
                    _signs += _ss
                    break

# calculating circle's center coords
            _dp = math.sqrt(math.pow(self.x2 - self.x1, 2) + math.pow(self.y2 - self.y1, 2)) 
            _r = _dp / (2 * math.cos(math.radians((180 - self.curve) / 2)))

            _h = math.sqrt(_r * _r - math.pow(_dp / 2, 2))

            if 'counterclockwise' == self.direction:
                _x3 = self.x1 + abs(self.x2 - self.x1) / 2 + _h * abs(self.y2 - self.y1) / _dp
                _y3 = self.y1 + abs(self.y2 - self.y1) / 2 - _h * abs(self.x2 - self.x1) / _dp
            else:
                _x3 = self.x1 + abs(self.x2 - self.x1) / 2 - _h * abs(self.y2 - self.y1) / _dp
                _y3 = self.y1 + abs(self.y2 - self.y1) / 2 + _h * abs(self.x2 - self.x1) / _dp

            if abs(self.x1 - self.x2) < abs(self.y1 - self.y2):
                _curve = _x3
            else:
                _curve = _y3

            _curve = self.encode_real(int((_curve + 0.005) * 100) / 100.) # rounding..

            _ret_val = struct.pack(self.template,
                                   self.constant, 
                                   0, 0, self.layer,
                                   ((self.encode_real(self.x1) & 0xffffff) +
                                       ((_curve & 0xff) << 24)),
                                   ((self.encode_real(self.y1) & 0xffffff) +
                                       ((_curve & 0xff00) << 16)),
                                   ((self.encode_real(self.x2) & 0xffffff) +
                                       ((_curve & 0xff0000) << 8)),
                                   self.encode_real(self.y2) & 0xffffff,
                                   self.encode_real(
                                       self.width / self.width_xscale),
                                   _signs, 
                                   self.arc_sign
                                  )
            return _ret_val

    class Pad(Shape):
        """ A struct that represents a pad
            (no layer is available for pad ; base Shape class
            is used both for uniformity and convertors)
        """
        constant = 0x2a
        template = "=4B3I3B5s"

        max_embed_len = 5
        no_embed_str = b'\x7f'

        def __init__(self, name, x, y, drill):
            """ Just a constructor
            """
            super(Eagle.Pad, self).__init__(layer=-1)
            self.name = name
            self.x = x
            self.y = y
            self.drill = drill
# TODO shape (3:1==normal,3==long)
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, 0,
                                   self.encode_real(self.x),
                                   self.encode_real(self.y),
                                   self.encode_real(self.drill),
                                   0, 0, 0,
                                   _name,
                                  )
            return _ret_val

    class Pin(Shape):
        """ A struct that represents a pin
            (no layer is available for pin ; base Shape class
            is used both for uniformity and convertors)
        """
        constant = 0x2c
        template = "=4B2i2B10s"

        max_embed_len = 10
        no_embed_str = b'\x7f'

        visiblemask = 0xf0
        visibles = {
                    0x00: "off",
                    0x40: "pad",
                    0x80: "pin",
                    0xc0: None, # default
                   }
        dirmask = 0x0f
        directions = {
                      0x00: "nc",
                      0x01: "in",
                      0x02: "out",
                      0x03: None, # default
                      0x04: "oc",
                      0x05: "pwr",
                      0x06: "pas",
                      0x07: "hiz",
                      0x08: "sup",
                     }
        lengthmask = 0x30
        lengths = {
                   0x00: "point",
                   0x10: "short",
                   0x20: "middle",
                  }
        funcmask = 0x0f
        functions = {
                     0x00: None, # default
                     0x01: "dot",
                     0x02: "clk",
                     0x03: "dotclk",
                    }
 
        def __init__(self, name, x, y, visible, direction, rotate, length, # pylint: disable=R0913
                     function=None, swaplevel=0): 
            """ Just a constructor
            """
            super(Eagle.Pin, self).__init__(layer=-1)
            self.name = name.encode('ascii', 'replace') if None != name else ''
            self.x = x
            self.y = y
            self.visible = visible
            self.direction = direction
# rotation codes direction: R0 means left, R90 - down, R180 - right, R270 - up
            self.rotate = rotate
            self.length = length
            self.function = function
            self.swaplevel = swaplevel
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _viz = 0
            for _vv in self.visibles:
                if self.visibles[_vv] == self.visible:
                    _viz += _vv
                    break
            for _ff in self.functions:
                if self.functions[_ff] == self.function:
                    _viz += _ff
                    break
            _rotdir = 0
            for _rr in self.rotates:
                if self.rotates[_rr] == self.rotate:
                    _rotdir += _rr << 4
                    break
            for _ll in self.lengths:
                if self.lengths[_ll] == self.length:
                    _rotdir += _ll
                    break
            for _dd in self.directions:
                if self.directions[_dd] == self.direction:
                    _rotdir += _dd
                    break

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, _viz, 0,
                                   self.encode_real(self.x),
                                   self.encode_real(self.y),
                                   _rotdir, self.swaplevel, 
                                   _name,
                                  )
            return _ret_val

    class Gate(Shape):
        """ A struct that represents a gate
            (no layer is available for gate ; base Shape class
            is used both for uniformity and convertors)
        """
        constant = 0x2d
        template = "=4B2i2BH8s"

        addlevels = {
                     0x00: "must",
                     0x02: None,
                     0x03: "request",
                     0x04: "always",
                    }

        max_embed_len = 8
        no_embed_str = b'\x7f'

        def __init__(self, x, y, name, sindex, addlevel): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.Gate, self).__init__(-1)
            self.x = x
            self.y = y
            self.name = name
            self.sindex = sindex
            self.addlevel = addlevel
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _addlevel = 0
            for _ll in self.addlevels:
                if self.addlevels[_ll] == self.addlevel:
                    _addlevel = _ll
                    break

            _name = self.no_embed_str + r'\0\0\0' + b'\x09'
            if None == self.name:
                _name = ''
            elif self.max_embed_len >= len(self.name):
                _name = self.name
            else:
                Eagle.attr_jar_append(self.name)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, 0,
                                   self.encode_real(self.x),
                                   self.encode_real(self.y),
                                   _addlevel, 0, 
                                   self.sindex,
                                   _name,
                                  )
            return _ret_val

    class Text(Shape):
        """ A struct that represents a text
        """
        constant = 0x31
        template = "=4B2iH4B6s"

        max_embed_len = 6
        delimeter = b'!'
        no_embed_str = b'\x7f'

        def __init__(self, value, x, y, size, layer, rotate, font, ratio): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.Text, self).__init__(layer)
            self.value = str(value)
            self.x = x
            self.y = y
            self.size = size
            self.rotate = rotate
            self.font = font
            self.ratio = ratio
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _font = 0
            for _ff in Eagle.Text.fonts:
                if Eagle.Text.fonts[_ff] == self.font:
                    _font = _ff
                    break
            _rotate = 0
            for _rr in Eagle.Text.rotates:
                if Eagle.Text.rotates[_rr] == self.rotate:
                    _rotate = _rr
                    break

            if None == self.value:
                _value = ''
            elif self.max_embed_len >= len(self.value):
                _value = self.value
            else:
                _value = self.no_embed_str + r'\0\0\0' + b'\x09'
                Eagle.attr_jar_append(self.value)

            _ret_val = struct.pack(self.template,
                                   self.constant, 0,
                                   _font, self.layer,
                                   self.encode_real(self.x),
                                   self.encode_real(self.y),
                                   self.encode_real(self.size /
                                       self.size_xscale),
                                   self.ratio << self.ratio_sscale,
                                   0, 0,
                                   _rotate,
                                   _value,
                                  )
            return _ret_val

        def construct2(self):
            """ Prepares a string block
                (Returns None if binary block is OK)
            """
            _ret_val = None

            if None == self.value or self.max_embed_len >= len(self.value):
                pass # was embedded
            else:
                _ret_val = self.value + self.delimeter

            return _ret_val

    class Label(Shape):
        """ A struct that represents a label
        """
        constant = 0x33
        template = "=4B2I2H4BI"

        mirroredmask = 0x10
        onoffmask = 0x01

        def __init__(self, x, y, size, layer, rotate, ratio, font,  # pylint: disable=R0913
                     onoff, mirrored):
            """ Just a constructor
                Note: 6.0.0's xref is the same as onoff
            """
            super(Eagle.Label, self).__init__(layer)
            self.x = x
            self.y = y
            self.size = size
            self.xref = onoff
            self.rotate = rotate
            self.ratio = ratio
            self.font = font
            self.onoff = onoff
            self.mirrored = mirrored
            return #}}}

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _font = 0
            for _ff in Eagle.Text.fonts:
                if Eagle.Text.fonts[_ff] == self.font:
                    _font = _ff
                    break

            _ss = 0
            for _rr in Eagle.Label.rotates:
                if Eagle.Label.rotates[_rr] == self.rotate:
                    _ss += _rr
                    break
            if self.mirrored:
                _ss += self.mirroredmask

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, _font, self.layer,
                                   self.encode_real(self.x),
                                   self.encode_real(self.y),
                                   self.encode_real(self.size /
                                       self.size_xscale),
                                   self.ratio << Eagle.Text.ratio_sscale,
                                   0,
                                   _ss,
                                   self.onoffmask if self.onoff else 0,
                                   0, 0
                                  )
            return _ret_val

    class Frame(Shape):
        """ A struct that represents a frame
        """
        constant = 0x43
        template = "=4B4i4B"

        bleftmask = 0x08
        btopmask = 0x04
        brightmask = 0x02
        bbottommask = 0x01

        def __init__(self, x1, y1, x2, y2, columns, rows, # pylint: disable=R0913
                    layer, bleft=True, btop=True, bright=True, bbottom=True): 
            """ Just a constructor
            """
            super(Eagle.Frame, self).__init__(layer)
            self.x1 = x1
            self.y1 = y1
            self.x2 = x2
            self.y2 = y2

            self.columns = columns
            self.rows = rows

            self.bleft = bleft
            self.btop = btop
            self.bright = bright
            self.bbottom = bbottom
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _borbot = ( (self.bleftmask if self.bleft else 0) +
                        (self.btopmask if self.btop else 0) +
                        (self.brightmask if self.bright else 0) +
                        (self.bbottommask if self.bbottom else 0) )

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, self.layer,
                                   self.encode_real(self.x1),
                                   self.encode_real(self.y1),
                                   self.encode_real(self.x2),
                                   self.encode_real(self.y2),
                                   self.columns,
                                   self.rows,
                                   _borbot,
                                   0,
                                  )
            return _ret_val

    class AttributeNam(Shape):
        """ A struct that represents a part's NAME attribute
        """
        constant = 0x34
        template = "=4B2i2H4B4s"

        def __init__(self, x, y, size, layer, rotate, font, name="NAME"): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.AttributeNam, self).__init__(layer)
            self.name = name
            self.x = x
            self.y = y
            self.size = size
            self.font = font
            self.rotate = rotate
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _font = 0
            for _ff in Eagle.AttributeNam.fonts:
                if Eagle.AttributeNam.fonts[_ff] == self.font:
                    _font = _ff
                    break

            _rot = 0
            for _rr in Eagle.AttributeNam.rotates:
                if Eagle.AttributeNam.rotates[_rr] == self.rotate:
                    _rot += _rr
                    break

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, _font, self.layer,
                                   self.encode_real(self.x),
                                   self.encode_real(self.y),
                                   self.encode_real(self.size /
                                       self.size_xscale),
                                   0, 
                                   0, _rot, 0, 0,
                                   ''
                                  )
            return _ret_val

    class AttributeVal(AttributeNam):
        """ A struct that represents a part's VALUE attribute
        """
        constant = 0x35

        def __init__(self, x, y, size, layer, rotate, font, name="VALUE"): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.AttributeVal, self).__init__(x, y, 
                                        size, layer, rotate, font, name)
            return

    class AttributePrt(AttributeNam):
        """ A struct that represents a part's PART attribute
        """
        constant = 0x3f

        def __init__(self, x, y, size, layer, rotate, font, name="VALUE"): # pylint: disable=R0913
            """ Just a constructor
            """
            super(Eagle.AttributePrt, self).__init__(x, y, 
                                        size, layer, rotate, font, name)
            return

    class PinRef(Shape):
        """ A struct that represents a pinref
            (no layer is available for pinref ; base Shape class
            is used both for uniformity and convertors)
        """
        constant = 0x3d
        template = "=4B3H14s"

        def __init__(self, partno, gateno, pinno):
            """ Just a constructor
            """
            super(Eagle.PinRef, self).__init__(-1)
            self.partno = partno
            self.gateno = gateno
            self.pinno = pinno
            return

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _ret_val = struct.pack(self.template,
                                   self.constant, 0, 0, 0,
                                   self.partno,
                                   self.gateno,
                                   self.pinno,
                                   '',
                                  )
            return _ret_val

    class Attribute:
        """ A struct that represents an attribute
        """
        constant = 0x42
        template = "=3BI17s"

        max_embed_len = 17
        delimeter = b'!'
        no_embed_str = b'\x7f'

        def __init__(self, name, value):
            """ Just a constructor
            """
            self.name = name
            self.value = value
            return

        def _construct(self):
            """ Prepares a string
            """
            _ret_val = self.delimeter.join((self.name, str(self.value)))
            return _ret_val

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _str = self._construct()

            if self.max_embed_len >= len(_str):
                _str2 = _str
            else:
                _str2 = self.no_embed_str + r'\0\0\0' + b'\x09'
                Eagle.attr_jar_append(_str)

            _ret_val = struct.pack(self.template,
                                   Eagle.Attribute.constant, 
                                   0, 0x2a, # <--- a kind of a marker?
                                   0,
                                   _str2
                                  )
            return _ret_val

        def construct2(self):
            """ Prepares a string block
                (Returns None if binary block is OK)
            """
            _ret_val = None

            _str = self._construct()
            if self.max_embed_len > len(_str):
                pass # was embedded
            else:
                _ret_val = _str

            return _ret_val

    class Schematic:
        """ A struct that represents "schematic"
        """
        defxreflabel = ":%F%N/%S.%C%R"
        defxrefpart = "/%S.%C%R"

        delimeter = b'\t'

        def __init__(self, xreflabel=None, xrefpart=None):
            """ Just a constructor
            """
            if None == xreflabel:
                xreflabel = Eagle.Schematic.defxreflabel
            if None == xrefpart:
                xrefpart = Eagle.Schematic.defxrefpart

            self.xreflabel = xreflabel
            self.xrefpart = xrefpart
            return

        def construct(self):
            """ Prepares a string block
            """
            _ret_val = None

            _ret_val = self.delimeter.join((self.xreflabel, 
                                            str(self.xrefpart)))
            return _ret_val

    class NetClass:
        """ A struct that represents a net class
        """
        template0 = "=3I" # header part read by _parse_file
        template1 = "=13I" # unpack the rest of chunk
        template2x = "=3I%ss13I" # pack the whole thing

        scale1 = 10000.0

        constant = 0x20000425
        constantmid = 0x87654321
        constantend = 0x89abcdef
        
        endmarker = 0x99999999

        def __init__(self, num, name='', width=0, drill=0, clearances=None, # pylint: disable=R0913
                     leadint=0):
            """ Just a constructor
            """ 
            self.num = num
            self.name = name
            self.width = width
            self.drill = drill
            if None == clearances:
                clearances = []
            self.clearances = clearances
            
            self.leadint = leadint # TODO decypher it..
            return

        @staticmethod
        def encode_real(real):
            """ Transforms given value to a binary representation
            """
            _ret_val = 0
            _ret_val = int(real * Eagle.NetClass.scale1)
            return _ret_val

        def construct(self):
            """ Prepares a binary block
            """
            _ret_val = None

            _ndx = 0
            _cls = []
            for _nn in range(8):
                _val = 0
                if (len(self.clearances) > _ndx and 
                            _nn == sorted(self.clearances)[_ndx]):
                    _val = Eagle.NetClass.encode_real(
                            sorted(self.clearances)[_ndx])
                    _ndx += 1
                _cls.append(_val)

            _name = self.name + r'\0'

            _ret_val = struct.pack(self.template2x % str(len(_name)),
                                   self.leadint, 
                                   self.constant,
                                   struct.calcsize(self.template1) + len(_name), 
                                   _name,
                                   self.num, 
                                   self.constantmid,
                                   self.encode_real(self.width), 
                                   self.encode_real(self.drill),
                                   _cls[0], _cls[1], _cls[2], _cls[3],
                                   _cls[4], _cls[5], _cls[6], _cls[7],
                                   self.constantend
                                  )
            return _ret_val

    blocksize = 24
    noregblockconst = b'\x13\x12\x99\x19'
    noregdelimeter = r'\0'

    def __init__(self):
        """ Construct a writer object and initialize it.
        """
#        self.shapes = []
#        self.nets = []
#        self.buses = []
        self.header = None
        self.layers = []
        self.settings = []
        self.grid = None
        self.attributeheader = None
        self.attributes = []
        self.libraries = []
        self.shapeheader = None
        self.parts = []
        self.texts = []
        self.schematic = None
        self.netclasses = []
        return

    @staticmethod
    def _calculateweb(web):
        """ Calculates counters in web tree
        """
        _cumuno = 0
        for _nn in web:
            _cumuno += 1
            for _ss in _nn.segments:
                _ss.numofshapes = (len(_ss.wires) + 
                                   len(_ss.junctions) +
                                   len(_ss.labels))
                _cumuno += _ss.numofshapes
                _ss.cumulativenumofshapes = _cumuno
            _nn.numofblocks = (len(_nn.segments) + 
                        sum([_ss.numofshapes for _ss in _nn.segments]))
        return

    attr_jar = [] # attribute list

    @classmethod
    def attr_jar_append(cls, value):
        """ Puts one more string into the jar
        """
        cls.attr_jar.append(value.encode('ascii', 'replace'))

    def _convert_library(self, design):
        """ Converts library part into a set of Eagle objects
        """

        for _cc in design.components.components:
            _libid = 'default'
            _compname = _cc
            _tech = []
            _attrs = []
            if -1 != _cc.find(':'):
                _libid, _compname = _cc.split(':')

            _lib = None
            _libnid = -1
            for _li, _ll in enumerate(self.libraries):
                if _libid == _ll.name:
                    _lib = _ll
                    _libnid = 1 + _li # numbered from 1
                    break
            else:
                _lib = Eagle.Library(name=_libid)
                _libnid = len(self.libraries) # numbered from 1
                self.libraries.append(_lib)

# checking if symbols / devsets / packages are in the library already
#  (adding them if not)
            _co = design.components.components[_cc]

            if 0 == len(_lib.devsets):
                _lib.devsets.append(Eagle.DeviceSetHeader(name='default'))

            for _di, _dd in enumerate(_lib.devsets[0].shapesets):
                if _compname == _dd.name:
                    _dset = _dd
                    break
            else:
                _prefix = 'xC'
                _desc = 'n/a'
                if 'prefix' in _co.attributes:
                    _prefix = _co.attributes['prefix']
                if 'description' in _co.attributes:
                    _desc = _co.attributes['description']
                _dset = Eagle.DeviceSet(name=_compname, prefix=_prefix, 
                            description=_desc, uservalue=False)

                _lib.devsets[0].shapesets.append(_dset)

            if 0 == len(_lib.symbols):
                _lib.symbols.append(Eagle.SymbolHeader(name='default'))

            for _si, _ss in enumerate(_lib.symbols[0].shapesets):
                if _compname == _ss.name:
                    _symbol = _ss
                    _symnid = 1 + _si # numbered from 1
                    break
            else: # no such symbol yet
                _symbol = Eagle.Symbol(libid=_libnid, name=_compname)
                _symnid = len(_lib.symbols[0].shapesets) # numbered from 1

                for _css in _co.symbols:
                    for _cbb in _css.bodies:

                        for _ci in design.component_instances:
                            if _cc != _ci.library_id:
                                continue
                            for _xaa in _ci.attributes:
                                if 'technology' == _xaa:
                                    _tech.append(_ci.attributes[_xaa])
                                elif _xaa in ('prefix', 'description'):
                                    pass
                                else:
                                    _attrs.append((_xaa, _ci.attributes[_xaa]))
                            for _sa in _ci.symbol_attributes:
                                for _an, _aa in enumerate(_sa.annotations):
                                    _val = 'n/a'
                                    if 0 == _an:
                                        _val = '>NAME'
                                    elif 1 == _an:
                                        _val = '>VALUE'

                                    _rot = self.Shape.rotate2strings(_aa.rotation)

                                    _symbol.shapes.append(Eagle.Text(
                                                value=_val,
                                                x=_aa.x - _sa.x,
                                                y=_aa.y - _sa.y,
                                                size=1.778, layer=95, 
                                                rotate=_rot, font=None,
                                                ratio=10))

                        for _cpp in _cbb.pins:

                            _name = None
                            if None != _cpp.label:
                                _name = _cpp.label.text

                            _visible = None
                            if 'visible' in _cpp.attributes:
                                _visible = _cpp.attributes['visible']

                            _dir = None
                            if 'direction' in _cpp.attributes:
                                _dir = _cpp.attributes['direction']

                            _rot = None

                            _len = 'short'
                            if 'length' in _cpp.attributes:
                                _len = _cpp.attributes['length']
                            
                            _func = None
                            if 'function' in _cpp.attributes:
                                _func = _cpp.attributes['function']
                            
                            _swap = 0
                            if 'swaplevel' in _cpp.attributes:
                                _swap = _cpp.attributes['swaplevel']
                            
                            _symbol.shapes.append(Eagle.Pin(name=_name,
                                    x=_cpp.p2.x, y=_cpp.p2.y, visible=_visible,
                                    direction=_dir, rotate=_rot, length=_len,
                                    function=_func, swaplevel=_swap))
                        for _cff in _cbb.shapes:

                            _layer = 94
                            if 'label' in _cff.attributes:
                                _layer = _cff.attributes['layer']

                            if isinstance(_cff, Line):
                                _style = 'Continuous'
                                if 'style' in _cff.attributes:
                                    _style = _cff.attributes['style']

                                _width = 0.254
                                if 'width' in _cff.attributes:
                                    _width = _cff.attributes['width']

                                _symbol.shapes.append(Eagle.Wire(
                                        x1=_cff.p1.x, y1=_cff.p1.y,
                                        x2=_cff.p2.x, y2=_cff.p2.y,
                                        style=_style, layer=_layer, width=_width))
                            elif isinstance(_cff, Rectangle):
                                _symbol.shapes.append(Eagle.Rectangle(
                                        x1=_cff.x, y1=_cff.y,
                                        x2=(_cff.x + _cff.width), 
                                        y2=(_cff.y - _cff.height),
                                        rotate=None, layer=_layer))
                            elif isinstance(_cff, Arc):
                                _style = 'Continuous'
                                if 'style' in _cff.attributes:
                                    _style = _cff.attributes['style']

                                _width = 0.254
                                if 'width' in _cff.attributes:
                                    _width = _cff.attributes['width']

                                _layer = 91 # usually Nets

                                _dir = ('counterclockwise' 
                                            if _cff.start_angle < _cff.end_angle
                                            else 'clockwise')
                                _symbol.shapes.append(Eagle.Arc( # _cff's angles're in radians
                                        x1=_cff.x + _cff.radius * math.cos(_cff.start_angle), # sign is ok
                                        y1=_cff.y + _cff.radius * math.sin(_cff.start_angle),
                                        x2=_cff.x + _cff.radius * math.cos(_cff.end_angle),
                                        y2=_cff.y + _cff.radius * math.sin(_cff.end_angle),
                                        style=_style, 
                                        layer=_layer, width=_width,
                                        curve=math.degrees(abs(_cff.start_angle - _cff.end_angle)),
                                        cap=None, 
                                        direction=_dir))
                            elif isinstance(_cff, BezierCurve):
#                                raise NotImplementedError("BezierCurve isn't implemented for Eagle yet")
# TODO curve approximation with arcs
                                _style = 'Continuous'
                                if 'style' in _cff.attributes:
                                    _style = _cff.attributes['style']

                                _width = 0.254
                                if 'width' in _cff.attributes:
                                    _width = _cff.attributes['width']

                                _symbol.shapes.append(Eagle.Wire(
                                        x1=_cff.p1.x, y1=_cff.p1.y,
                                        x2=_cff.p2.x, y2=_cff.p2.y,
                                        style=_style, layer=_layer, width=_width))
                            elif isinstance(_cff, Circle):
                                _width = 0.254
                                if 'width' in _cff.attributes:
                                    _width = _cff.attributes['width']

                                _symbol.shapes.append(Eagle.Circle(
                                        x=_cff.x, y=_cff.y,
                                        radius=_cff.radius, 
                                        width=_width, layer=_layer))
                            elif isinstance(_cff, Polygon):
                                _width = 0.254
                                if 'width' in _cff.attributes:
                                    _width = _cff.attributes['width']

                                _style = 'Continuous'
                                if 'style' in _cff.attributes:
                                    _style = _cff.attributes['style']

                                _symbol.shapes.append(Eagle.Polygon(
                                    width=_width, layer=_layer,
                                    numofshapes=len(_cff.points),
                                    shapes=[ # lines from points
                                        Eagle.Wire(
                                            x1=p1.x, y1=p1.y,
                                            x2=p2.x, y2=p2.y,
                                            style=_style, layer=_layer, 
                                            width=_width)
                                        for p1, p2 in zip(_cff.points, 
                                            _cff.points[1:]+[_cff.points[0],])
                                        ]))
                            elif isinstance(_cff, Label):
                                _layer = 95 # usually Names
                                if 'label' in _cff.attributes:
                                    _layer = _cff.attributes['layer']

                                _rot = self.Shape.rotate2strings(_cff.rotation)

                                _symbol.shapes.append(Eagle.Text(
                                        value=_cff.text,
                                        x=_cff.x, y=_cff.y,
                                        size=1.778, font=None, ratio=10,
                                        rotate=_rot, layer=_layer))
                            else:
                                raise ValueError("cannot process " + _cff.__class__.__name__)

                _lib.symbols[0].shapesets.append(_symbol)

                _dset.shapes.append(Eagle.Gate(name='G$1', x=0., y=0., 
                            sindex=_symnid, addlevel=False))
                _dset.connblocks.append(Eagle.ConnectionHeader(name='default', 
                            attributes=_attrs, technologies=_tech,
                            sindex=_symnid))
                
            if 0 == len(_lib.packages):
                _lib.packages.append(Eagle.PackageHeader(name='default'))
            # TODO to load from a library file
        return

    def _convert_shapes1(self, design):
        """ Converts shapes (parts) into a set of Eagle objects
        """
        for _pp in design.component_instances:
            _libid = -1
            _devn = -1
            _libname = 'default'
            _pname = _pp.library_id
            if -1 != _pp.library_id.find(':'):
                _libname, _pname = _pp.library_id.split(':')
                
            for _li, _ll in enumerate(self.libraries):
                if _libname == _ll.name:
                    _libid = _li
                    for _di, _dd in enumerate(_ll.devsets[0].shapesets):
                        if _pname == _dd.name:
                            _devn = _di
                            break
                    break

            self.shapeheader.parts.append(Eagle.Part(
                    name=_pp.instance_id, libid=_libid, devsetndx=_devn,
                    symvar=1, techno=1)) # after OpenJSON all parts are split
        return

    def _convert_shapes2(self, design):
        """ Converts shapes (buses/nets) into a set of Eagle objects
        """
        for _nn in design.nets:
            _web = None
            if 'type' in _nn.attributes:
                if 'bus' == _nn.attributes['type']:
                    _width = 0.762
                    _web = Eagle.Bus(name=_nn.net_id)
                    self.shapeheader.buses.append(_web)
                else:
                    _clrs = []
                    _attrre = re.compile(r'^netclearance(\d+)$')
                    for _aa in _nn.attributes:
                        _attr = _attrre.match(_aa)
                        if None != _attr:
                            _clrs.append((_attr.group(1), _nn.attributes[_aa]))

                    self.netclasses.append(Eagle.NetClass( # duplicates are cleared below
                            num=_nn.attributes['netclass'], 
                            name=_nn.attributes['netname'], 
                            width=_nn.attributes['netwidth'],
                            drill=_nn.attributes['netdrill'],
                            clearances=_clrs,
                        ))
                    _width = 0.1524 # _nn.attributes['netwidth']
                    _web = Eagle.Net(name=_nn.net_id, 
                                nclass=_nn.attributes['netclass'])
                    self.shapeheader.nets.append(_web)
            else:
                _width = 0.1524
                _web = Eagle.Net(name=_nn.net_id, nclass=0)
                self.shapeheader.nets.append(_web)

            _prpts = set() # processed points
            for _pp in _nn.points:
                _pt = _nn.points[_pp]
                for _opp in _pt.connected_points:
                    if not _opp in _prpts: # not yet processed
                        _opt = None
                        try:
                            _opt = _nn.points[_opp]
                        except KeyError: # not from current net
                            for _xxn in design.nets:
                                if _opp in _xxn.points:
                                    _opt = _xxn.points[_opp]
                                    break
                            else:
                                raise ValueError("undefined point ID: %s" % str(_opp))

                        _web.shapes.append(Eagle.Wire(
                                x1=_pt.x, y1=_pt.y,
                                x2=_opt.x,
                                y2=_opt.y,
                                style="Continuous", layer=91, width=_width))

                _prpts.add(_pp)
                letter_pin_numbers = []
                for _rr in _pt.connected_components:
                    _pno = -1
                    for _in, _ii in enumerate(self.shapeheader.parts):
                        if _rr.instance_id == _ii.name:
                            _pno = 1 + _in
                            break
                    try:
                        pin_number = int(_rr.pin_number)
                    except ValueError:
                        if letter_pin_numbers:
                            pin_number = letter_pin_numbers.pop() + 1
                        else: 
                            pin_number = 1
                        letter_pin_numbers.append(pin_number)

                    _web.shapes.append(Eagle.PinRef(
                            partno= _pno, gateno=1, 
                            pinno=pin_number,
                        ))
        return

    def _convert(self, design):
        """ Converts design into a set of Eagle objects
        """
        self._convert_library(design)
        self.shapeheader = Eagle.ShapeHeader()
        self._convert_shapes1(design)
        self._convert_shapes2(design)
        return

    def _validate(self, design):
        """ Add extra structures required by an Eagle format and
            calculate section counters
        """

        if None == self.header:
            self.header = Eagle.Header()

        if None == self.settings:
            self.settings = []
        while 2 > len(self.settings):
            self.settings.append(Eagle.Settings())

        if None == self.grid:
            self.grid = Eagle.Grid()

        for _ll in self.layers:
            if 91 == _ll.number:
                break
        else: # default layer set
            _deflayers = ((91, 'Nets', 2),
                          (92, 'Busses', 1),
                          (93, 'Pins', 2),
                          (94, 'Symbols', 4),
                          (95, 'Names', 7),
                          (96, 'Values', 7),
                          (97, 'Info', 7),
                          (98, 'Guide', 6),
                         )
            for _ll in _deflayers:
                self.layers.append(
                        Eagle.Layer(number=_ll[0], name=_ll[1], color=_ll[2], 
                                    fill=1, visible=True, active=True))

        if None == self.attributeheader:
            self.attributeheader = Eagle.AttributeHeader(
                    schematic=Eagle.AttributeHeader.delimeter.join((
                        Eagle.AttributeHeader.defxreflabel,
                        Eagle.AttributeHeader.defxrefpart)))

        if None == self.shapeheader:
            self.shapeheader = Eagle.ShapeHeader()

        if None == self.netclasses:
            self.netclasses = []
        else: # clear duplicates
            _ncsm = {}
            for _nc in self.netclasses:
                _ncsm[_nc.num] = _nc

            self.netclasses = []
            for _nc in sorted(_ncsm):
                self.netclasses.append(_ncsm[_nc])

        if 0 == len(self.netclasses):
            self.netclasses.append(Eagle.NetClass(0, 'default'))

        while 8 > len(self.netclasses):
            self.netclasses.append(Eagle.NetClass(len(self.netclasses)))

# calculate num of blocks
        self._calculatelibs()
        self._calculateshapes()

        self.attributeheader.numofshapes = (self.shapeheader.numofshapes +
                sum(x.numofdevsetblocks + x.numofsymbolblocks + 
                    x.numofpackageblocks for x in self.libraries))
        self.attributeheader.numofattributes = len(self.attributes)

        return

    def _calculatelibs(self):
        """ Refreshes all library (and nested) blocks
        """

        for _ll in self.libraries:

            for _ds in _ll.devsets: # usually a single entry
                _ds.numofshapesets = len(_ds.shapesets)
                _nb = 0
                for _ss in _ds.shapesets:
                    for _cc in _ss.connblocks:
                        _cc.numofshapes = len(_cc.shapes) # conns
                        _nb += 1 + _cc.numofshapes
                    _nb += 1 # connblocks hdr

                    _ss.numofshapes = len(_ss.shapes) # gates
                    _nb += 1 + _ss.numofshapes
                _ds.numofblocks = _nb

            _ll.numofdevsetblocks = 1 + sum(x.numofblocks for x in _ll.devsets)

            for _sh in _ll.symbols: # usually a single entry
                _sh.numofshapesets = len(_sh.shapesets)
                _nb = 0
                for _ss in _sh.shapesets:
                    _ss.numofshapes = len(_ss.shapes)
                    _nb += 1 + _ss.numofshapes
                _sh.numofblocks = _nb
            _ll.numofsymbolblocks = 1 + sum(x.numofblocks for x in _ll.symbols)

            for _ph in _ll.packages: # usually a single entry
                _ph.numofshapesets = len(_ph.shapesets)
                _nb = 0
                for _ss in _ph.shapesets:
                    _ss.numofshapes = len(_ss.shapes)
                    _nb += 1 + _ss.numofshapes
                _ph.numofblocks = _nb
            _ll.numofpackageblocks = 1 + sum(x.numofblocks for x in _ll.packages)

        return

    def _calculateshapes(self):
        """ Refreshes shape header (and nested) blocks
        """
        self.shapeheader.numofshapes = 1 
        for _ss in self.shapeheader.shapes:
            if not isinstance(_ss, Eagle.Polygon):
                self.shapeheader.numofshapes += 1 
            else:
                _ss.numofshapes = len(_ss.shapes)
                self.shapeheader.numofshapes += 1 + _ss.numofshapes

        self.shapeheader.numofpartblocks = 1 + len(self.shapeheader.parts)

        self.shapeheader.numofbusblocks = 1
        for _bb in self.shapeheader.buses:
            _bb.numofshapes = len(_bb.shapes)
            self.shapeheader.numofbusblocks += 1 + _bb.numofshapes

        self.shapeheader.numofnetblocks = 1
        for _nn in self.shapeheader.nets:
            _nn.numofshapes = len(_nn.shapes)
            self.shapeheader.numofnetblocks += 1 + _nn.numofshapes
        return

    def write(self, design, filename):
        """ Save given design as an Eagle format file with a given name
        """

        self._convert(design)
        self._validate(design)

        with open(filename, 'wb') as _of:

            _of.write(self.header.construct())

            for _ss in self.settings:
                _of.write(_ss.construct())

            _of.write(self.grid.construct())

            for _ll in self.layers:
                _of.write(_ll.construct())

            _of.write(self.attributeheader.construct())

            for _aa in self.attributes:
                _of.write(_aa.construct())

            for _ll in self.libraries:
                _of.write(_ll.construct())
                for _ds in _ll.devsets: # usually a single entry
                    _of.write(_ds.construct())
                    for _ss in _ds.shapesets:
                        _of.write(_ss.construct())
                        for _cc in _ss.connblocks:
                            _of.write(_cc.construct())
                            for _hh in _cc.shapes: # connections
                                _of.write(_hh.construct())
                        for _gg in _ss.shapes: # gates, usually a single entry
                            _of.write(_gg.construct())
                for _sh in _ll.symbols: # usually a single entry
                    _of.write(_sh.construct())
                    for _ss in _sh.shapesets:
                        _of.write(_ss.construct())
                        for _pp in _ss.shapes: # pins, lines, texts
                            _of.write(_pp.construct())
                for _ph in _ll.packages: # usually a single entry
                    _of.write(_ph.construct())

            _of.write(self.shapeheader.construct())

            for _ss in self.shapeheader.shapes:
                _of.write(_ss.construct())

            for _pp in self.shapeheader.parts:
                _of.write(_pp.construct())
                for _ss in _pp.shapes:
                    _of.write(_ss.construct())

            for _bb in self.shapeheader.buses:
                _of.write(_bb.construct())
                for _ss in _bb.shapes:
                    _of.write(_ss.construct())

            for _nn in self.shapeheader.nets:
                _of.write(_nn.construct())
                for _ss in _nn.shapes:
                    _of.write(_ss.construct())

            _of.write(Eagle.noregblockconst)

            _dta = self.noregdelimeter.join(self.attr_jar + 
                                        [self.noregdelimeter,])
            _of.write(struct.pack("I", len(_dta))) # length of noreg block
            _of.write(_dta) # noreg block itself

            for _cc in self.netclasses:
                _of.write(_cc.construct())

            _of.write(struct.pack(Eagle.NetClass.template0,
                                  0, Eagle.NetClass.constantend, 0
                                 ))
            return



########NEW FILE########
__FILENAME__ = eaglexml
#!/usr/bin/env python2
""" The Eagle XML Format Writer """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2012 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# TODO: handle layers

import upconvert.parser.eaglexml.generated_g as G
from math import fabs

default_layers = {
    "net": G.layer(number="91", name="Nets", color="2", fill="1", visible="yes", active="yes"),
    "bus": G.layer(number="92", name="Busses", color="1", fill="1", visible="yes", active="yes"),
    "pin": G.layer(number="93", name="Pins", color="2", fill="1", visible="no", active="yes"),
    "symbol": G.layer(number="94", name="Symbols", color="4", fill="1", visible="yes", active="yes"),
    "name": G.layer(number="95", name="Names", color="7", fill="1", visible="yes", active="yes"),
    "value": G.layer(number="96", name="Values", color="7", fill="1", visible="yes", active="yes"),
    "info": G.layer(number="97", name="Info", color="7", fill="1", visible="yes", active="yes"),
    "guide": G.layer(number="98", name="Guide", color="6", fill="1", visible="yes", active="yes"),
    }

EAGLE_SCALE = 9.0 / 10.0

class EagleXML(object):
    """ The Eagle XML Format Writer """

    SCALE = 0.5
    MULT =  25.4 / 90 # 90dpi to mm

    def __init__(self):
        # map library names to eaglexml library dom objects
        self.libcache = {}

        # map string layer numbers to eaglexml layer objects.
        self.layercache = {}

        # map (lib, name) to deviceset dom objects where lib
        # is a library dom object and name is a deviceset name
        self.dscache = {} # (lib, name) -> deviceset dom object

        # map openjson SBody objects to eaglexml gate names
        self.body2gate = {}

        # map openjson components ids to eaglexml libraries
        self.cpt2lib = {} # component id -> library

        # map openjson components ids to eaglexml devicesets
        self.cpt2deviceset = {} # component id -> deviceset

        # map (component id, device name) to eaglexml devices
        self.cptdname2dev = {} # (component id, device name) -> device

        # map (component id, pin name) to eaglexml gate names
        self.cptpin2gate = {} # (component id, pin name) -> gate name

        # map (instance id to component id)
        self.inst2cpt = {}

        # map a (library id, pin number) to the pin name
        self.pinnum2name = {}

        # map a library id to a list of its pin names (to prevent duplication)
        self.cpt2pinnames = {}

    def write(self, design, filename):
        """ Write the design to the Eagle XML format """

        inst2coordrot = {}
        for ci in design.component_instances:
            self.inst2cpt[ci.instance_id] = ci.library_id
            inst2coordrot[ci.instance_id] = {}
            for sym_idx, sym_attr in enumerate(ci.symbol_attributes):
                inst2coordrot[ci.instance_id][sym_idx] = sym_attr.x, sym_attr.y, sym_attr.rotation

        # shift pins if they arent a multiple of 20
        edited_pins = {}
        pin2symidx = {}
        for lib_id, cpt in design.components.components.iteritems():
            for sym_idx, symbol in enumerate(cpt.symbols):
                for body in symbol.bodies:
                    for pin in body.pins:
                        pin2symidx[pin.pin_number] = sym_idx
                        if pin.p2.x == pin.p1.x and (pin.p2.y - pin.p1.y) % 20 != 0:
                            if fabs(pin.p2.y - pin.p1.y) <= 5:
                                shift_val = 20
                            else:
                                shift_val = 10
                            if pin.p2.y > pin.p1.y:
                                edited_pins[lib_id, pin.pin_number] = ('y', shift_val, pin.p2.x, pin.p2.y)
                                pin.p2.y += shift_val
                            elif pin.p2.y < pin.p1.y:
                                edited_pins[lib_id, pin.pin_number] = ('y', -shift_val, pin.p2.x, pin.p2.y)
                                pin.p2.y += -shift_val
                        elif pin.p2.y == pin.p1.y and (pin.p2.x - pin.p1.x) % 20 != 0:
                            if fabs(pin.p2.x - pin.p1.x) <= 5:
                                shift_val = 20
                            else:
                                shift_val = 10
                            if pin.p2.x > pin.p1.x:
                                edited_pins[lib_id, pin.pin_number] = ('x', shift_val, pin.p2.x, pin.p2.y)
                                pin.p2.x += shift_val
                            elif pin.p2.x < pin.p1.x:
                                edited_pins[lib_id, pin.pin_number] = ('x', -shift_val, pin.p2.x, pin.p2.y)
                                pin.p2.x += -shift_val

        # shift nets if we had to shift the pins its connected to.
        for net in design.nets:
            for netpoint in net.points.itervalues():
                for cc in netpoint.connected_components:
                    if (self.inst2cpt[cc.instance_id], cc.pin_number) in edited_pins:
                        direction, shift, pin_x, pin_y = edited_pins[self.inst2cpt[cc.instance_id], cc.pin_number]
                        inst_x, inst_y, rot = inst2coordrot[cc.instance_id][pin2symidx[cc.pin_number]]
                        if rot == 1.5:
                            t = pin_y
                            pin_y = pin_x
                            pin_x = -t
                        elif rot == 1.0:
                            pin_x = -pin_x
                            pin_y = -pin_y
                        elif rot == 0.5:
                            t = pin_y
                            pin_y = - pin_x
                            pin_x = t
                        x, y = inst_x + pin_x, inst_y + pin_y

                        dir_shift_rot = {0.0: {'y': ('y', shift), 'x': ('x', shift)}, 1.5: {'y': ('x', -shift), 'x': ('y', shift)}, 1.0: {'y': ('y', -shift), 'x': ('x', -shift)}, 0.5: {'y': ('x', shift), 'x': ('y', -shift)}}
                        direction, shift = dir_shift_rot[rot][direction]

                        if direction == 'y':
                            if netpoint.y in range(y, y + shift + 1) or netpoint.y in range(y + shift, y + 1):
                                netpoint.y = y + shift
                        else:
                            if netpoint.x in range(x, x + shift + 1) or netpoint.x in range(x + shift, x + 1):
                                netpoint.x = x + shift

        design.scale(EAGLE_SCALE)
        eagle = self.make_dom(design)

        with open(filename, 'wb') as outfile:
            outfile.write('<?xml version="1.0" encoding="utf-8"?>\n')
            outfile.write('<!DOCTYPE eagle SYSTEM "eagle.dtd">\n')
            eagle.export(outfile, 0, namespace_='')


    def make_dom(self, design):
        """ Return the DOM tree for a design. """

        self.design = design

        eagle = G.eagle()
        eagle.drawing = G.drawing()
        eagle.drawing.layers = G.layers()
        eagle.drawing.schematic = G.schematic()
        eagle.drawing.schematic.libraries = G.libraries()
        eagle.drawing.schematic.parts = G.parts()
        eagle.drawing.schematic.sheets = G.sheets()
        eagle.drawing.schematic.sheets.sheet.append(G.sheet())

        sheet = eagle.drawing.schematic.sheets.sheet[0]
        sheet.instances = G.instances()
        sheet.nets = G.nets()

        self.layers = eagle.drawing.layers

        self.add_libraries(eagle.drawing.schematic.libraries, design)
        self.add_parts(eagle.drawing.schematic.parts, design)
        self.add_instances(sheet.instances, design)
        self.add_nets(sheet.nets, design)
        self.add_default_layers()

        return eagle


    def add_libraries(self, dom, design):
        """ Add the libraries to a dom object. """

        for cpt_name, cpt in design.components.components.iteritems():
            lib = self.ensure_lib_for_cpt(dom, cpt)
            deviceset = self.ensure_deviceset_for_cpt(lib, cpt)
            self.add_component_to_deviceset(cpt_name, cpt, lib, deviceset)


    def add_parts(self, dom, design):
        """ Add the parts to a dom object. """

        for ci in design.component_instances:
            dom.part.append(self.make_part(ci))


    def add_instances(self, dom, design):
        """ Add the instances to a dom object. """

        for ci in design.component_instances:
            for bodyindex, symattr in enumerate(ci.symbol_attributes):
                dom.instance.append(self.make_instance(ci, symattr, bodyindex))


    def add_nets(self, dom, design):
        """ Add the nets to a dom object. """

        for net in design.nets:
            dom.net.append(self.make_net(net))


    def ensure_lib_for_cpt(self, libraries, cpt):
        """ Ensure there is an eaglexml library for the given openjson
        component. Return the new or existing library. """

        libname = cpt.attributes.get('eaglexml_library', 'openjson')

        if libname in self.libcache:
            return self.libcache[libname]

        lib = G.library(libname)
        lib.packages = G.packages()
        lib.symbols = G.symbols()
        lib.devicesets = G.devicesets()

        libraries.library.append(lib)
        self.libcache[libname] = lib

        return lib


    def ensure_deviceset_for_cpt(self, lib, cpt):
        """Ensure there is an eaglexml deviceset for the given
        openjson component. """

        dsname = cpt.attributes.get('eaglexml_deviceset', cpt.name)

        if (lib, dsname) in self.dscache:
            return self.dscache[lib, dsname]

        deviceset = G.deviceset(name=dsname)
        deviceset.gates = G.gates()
        deviceset.devices = G.devices()

        lib.devicesets.deviceset.append(deviceset)
        self.dscache[lib, dsname] = deviceset

        return deviceset


    def add_component_to_deviceset(self, cpt_name, cpt, lib, deviceset):
        """ Add the openjson component to the eagle library and deviceset objects. """

        self.add_logical_component_to_deviceset(cpt_name, cpt, lib, deviceset)
        self.add_physical_component_to_deviceset(cpt, lib, deviceset)

        self.cpt2lib[cpt_name] = lib
        self.cpt2deviceset[cpt_name] = deviceset


    def add_logical_component_to_deviceset(self, cpt_name, cpt, lib, deviceset):
        """ Add the openjson component to the eagle library and deviceset objects
        as a logical device with gates. """

        # set of names used for eaglexml symbols
        symbol_names = set([s.name for s in lib.symbols.symbol])
        gate_names = set() # set of names used for eaglemxl gates
        self.cpt2pinnames[cpt_name] = []

        for symindex, symbol in enumerate(cpt.symbols):
            for bodyindex, body in enumerate(symbol.bodies):
                index = (symindex * len(symbol.bodies)) + bodyindex
                symname = cpt.attributes.get('eaglexml_symbol_%d' % index,
                                             'symbol_%d' % len(lib.symbols.symbol))
                for pin in body.pins:
                    if pin.label is not None:
                        pin_name = pin.label.text
                    else:
                        pin_name = pin.pin_number
                    if pin_name in self.cpt2pinnames[cpt_name]:
                        self.pinnum2name[(cpt_name, pin.pin_number)] = pin_name + ' ' + str(self.cpt2pinnames[cpt_name].count(pin_name) + 1)
                    else:
                        self.pinnum2name[(cpt_name, pin.pin_number)] = pin_name
                    self.cpt2pinnames[cpt_name].append(pin_name)

                if symname not in symbol_names:
                    lib.symbols.symbol.append(
                        self.make_eagle_symbol_for_openjson_body(symname, body, cpt_name))
                    symbol_names.add(symname)

                gatename = cpt.attributes.get('eaglexml_gate_%d' % bodyindex,
                                              'G$%d' % bodyindex)
                if gatename not in gate_names:
                    deviceset.gates.gate.append(
                        G.gate(name=gatename, symbol=symname, x="0", y="0"))
                    gate_names.add(gatename)

                self.body2gate[body] = gatename

                for pin in body.pins:
                    self.cptpin2gate[cpt_name, pin.pin_number] = gatename


    def make_eagle_symbol_for_openjson_body(self, name, body, cpt_name):
        """ Make an eaglexml symbol from an opensjon body. """

        symbol = G.symbol(name=name)

        layer = self.ensure_layer(body, 'symbol')

        for shape in body.shapes:
            if shape.type == 'line':
                symbol.wire.append(
                    G.wire(x1=self.make_length(shape.p1.x),
                           y1=self.make_length(shape.p1.y),
                           x2=self.make_length(shape.p2.x),
                           y2=self.make_length(shape.p2.y),
                           layer=layer.number))
            elif shape.type == 'rectangle':
                symbol.rectangle.append(
                    G.rectangle(x1=self.make_length(shape.x),
                                y1=self.make_length(shape.y)
                                - self.make_length(shape.height),
                                x2=self.make_length(shape.x)
                                + self.make_length(shape.width),
                                y2=self.make_length(shape.y),
                                layer=layer.number))
            elif shape.type == 'polygon':
                symbol.polygon.append(self.make_polygon(shape))
                symbol.polygon[-1].layer = layer.number
            elif shape.type == 'circle':
                symbol.circle.append(self.make_circle(shape))
                symbol.circle[-1].layer = layer.number

        for pin in body.pins:
            symbol.pin.append(
                G.pin(name=self.pinnum2name[(cpt_name, pin.pin_number)].replace(' ', ''), #delete space
                      x=self.make_length(pin.p2.x),
                      y=self.make_length(pin.p2.y),
                      length=self.get_pin_length(pin),
                      direction=pin.attributes.get('eaglexml_direction'),
                      visible=pin.attributes.get('eaglexml_visible'),
                      rot=self.get_pin_rotation(pin)))

        return symbol


    def make_polygon(self, ipoly):
        """ Make an eagle polygon from an opensjon polygon. """

        poly = G.polygon()

        for point in ipoly.points:
            poly.vertex.append(G.vertex(x=self.make_length(point.x),
                                        y=self.make_length(point.y)))

        return poly


    def make_circle(self, shape):
        """ Make an eagle circle from an opensjon circle. """

        circ = G.circle(x=self.make_length(shape.x),
                        y=self.make_length(shape.y),
                        radius=self.make_length(shape.radius))

        if 'eaglexml_width' in shape.attributes:
            circ.width = shape.attributes['eaglexml_width']
        else:
            circ.width = "0.254"

        return circ


    def get_pin_length(self, pin):
        """ Return the eaglexml length for an openjson pin. """

        delta_x = int(round(fabs(pin.p2.x - pin.p1.x) -1, - 1))
        delta_y = int(round(fabs(pin.p2.y - pin.p1.y) -1, - 1))

        length = ((delta_x ** 2)
                  + (delta_y ** 2)) ** .5
        length = self.make_length(length)
        if length == 0:
            return 'point'
        elif length <= 2.90:
            return 'short'
        elif length <= 5.70:
            return 'middle'
        else:
            return 'long'


    def get_pin_rotation(self, pin):
        """ Return the eaglexml rotation for an openjson pin. """

        if pin.p2.x == pin.p1.x:
            if pin.p2.y == pin.p1.y:
                return None # point
            elif pin.p2.y < pin.p1.y:
                return 'R90'
            else:
                return 'R270'
        elif pin.p2.x < pin.p1.x:
            return None
        else:
            return 'R180'


    def add_physical_component_to_deviceset(self, cpt, lib, deviceset):
        """ Add the openjson component to the eagle library and deviceset objects
        as a physical device with a package. """


    def make_part(self, cpt_inst):
        """ Make an eaglexml part for an openjson component instance. """

        part = G.part()
        part.name = cpt_inst.instance_id
        part.library = self.cpt2lib[cpt_inst.library_id].name
        part.deviceset = self.cpt2deviceset[cpt_inst.library_id].name
        part.device = self.ensure_device_for_component_instance(cpt_inst).name

        return part


    def make_instance(self, cpt_inst, symattr, bodyindex):
        """ Make an eaglexml part for an openjson component instance
        and symbol attribute. """

        cpt = self.design.components.components[cpt_inst.library_id]
        symbol = cpt.symbols[cpt_inst.symbol_index]
        body = symbol.bodies[bodyindex]

        inst = G.instance()
        inst.part = cpt_inst.instance_id
        inst.gate = self.body2gate[body]
        inst.x = self.make_length(symattr.x)
        inst.y = self.make_length(symattr.y)
        inst.rot = self.make_angle(symattr.rotation)

        layer = self.ensure_layer(body, 'symbol')

        for ann in symattr.annotations:
            inst.attribute.append(
                G.attribute(name=ann.value,
                            value=ann.value,
                            layer=layer.number,
                            size="1.27",
                            x=self.make_length(ann.x + symattr.x),
                            y=self.make_length(ann.y + symattr.y),
                            rot=self.make_angle(ann.rotation),
                            display='value' if ann.visible else 'off'))

        return inst


    def ensure_device_for_component_instance(self, cpt_inst):
        """ Return an eagle device for an openjson component instance,
        creating a new one if necessary. """

        name = cpt_inst.attributes.get('eaglexml_device', '')

        if (cpt_inst.library_id, name) in self.cptdname2dev:
            return self.cptdname2dev[cpt_inst.library_id, name]

        device = G.device(name=name)

        self.cptdname2dev[cpt_inst.library_id, name] = device
        self.cpt2deviceset[cpt_inst.library_id].devices.device.append(device)

        return device


    def make_net(self, openjson_net):
        """ Make a new eagle net from an openjson net. """

        # connected components. maps point ids to sets of points in
        # the net which are connected visually. These become eagle
        # segments in the net.
        conncomps = {} # point id -> set([point id])

        for point in openjson_net.points.itervalues():
            point_ids = set(point.connected_points)
            point_ids.add(point.point_id)
            for point_id in point_ids:
                if point_id in conncomps:
                    conncomp = conncomps[point_id]
                    conncomp.update(point_ids)
                    break
            else:
                conncomp = point_ids

            for point_id in point_ids:
                conncomps[point_id] = conncomp

        net = G.net(name=openjson_net.net_id)
        done = set() # objects ids of point sets

        for pointset in conncomps.itervalues():
            if id(pointset) not in done:
                done.add(id(pointset))
                net.segment.append(self.make_segment(openjson_net, pointset))

        return net


    def make_segment(self, openjson_net, pointset):
        wires = set() # ((x1, y1), (x2, y2))

        for point_id in pointset:
            p1 = openjson_net.points[point_id]
            x1 = self.make_length(p1.x)
            y1 = self.make_length(p1.y)

            for point_id in p1.connected_points:
                p2 = openjson_net.points[point_id]
                x2 = self.make_length(p2.x)
                y2 = self.make_length(p2.y)
                wires.add(tuple(sorted([(x1, y1), (x2, y2)])))

        seg = G.segment()

        layer = self.ensure_layer(openjson_net, "net")

        for (x1, y1), (x2, y2) in sorted(wires):
            wire = G.wire(x1=x1, y1=y1, x2=x2, y2=y2, layer=layer.number)
            seg.wire.append(wire)

        for point_id in pointset:
            for cc in openjson_net.points[point_id].connected_components:
                cid = self.inst2cpt[cc.instance_id]
                gate = self.cptpin2gate[cid, cc.pin_number]
                pin_name = self.pinnum2name[(cid, cc.pin_number)]
                pinref = G.pinref(part=cc.instance_id, gate=gate, pin=pin_name)
                seg.pinref.append(pinref)

        seg.pinref.sort(key=lambda p : (p.part, p.gate, p.pin))

        return seg


    def ensure_layer(self, openjson_obj, eagle_context):
        """
        Return the eaglexml layer for the given openjson object (Pin, Shape, etc.)
        given an eaglexml context string (pin, symbol, etc.). If the layer does
        not exists, create it and add it to the design.
        """

        layernum = None

        if hasattr(openjson_obj, 'attributes') \
                and 'eaglexml_layer' in openjson_obj.attributes:
            layernum = openjson_obj.attributes['eaglexml_layer']

            if layernum in self.layercache:
                return self.layercache[layernum]

        layer = default_layers[eagle_context]

        if layernum is None or layernum == layer.number:
            pass
        else:
            layer = G.layer(number=layernum, name=layernum,
                            color="1", fill="1", visible="yes", active="yes")

        if layer.number in self.layercache:
            return self.layercache[layer.number]
        else:
            self.layercache[layer.number] = layer
            self.layers.layer.append(layer)
            return layer


    def add_default_layers(self):
        """
        Add default layers to the design if they have not been added already.
        """

        for layer in default_layers.itervalues():
            if layer.number not in self.layercache:
                self.layercache[layer.number] = layer
                self.layers.layer.append(layer)

        self.layers.layer.sort(key=lambda layer : int(layer.number))


    def make_length(self, value):
        """ Make an eagle length measurement from an openjson length. """

        return round(float(value) * self.MULT * self.SCALE, 3)


    def make_angle(self, value):
        """ Make an eaglexml angle measurement from an openjson angle. """

        return 'R%d' % (360 - value * 180,)

########NEW FILE########
__FILENAME__ = geda
#!/usr/bin/env python2
# pylint: disable=C0302
""" This module provides a writer class to generate valid gEDA
    file format data from a OpenJSON design. The module does
    not generate embedded symbols but writes each symbol to
    its own symbol file to reduce the amount of data in the
    schematic file. This also allows for reuse of system-wide
    gEDA symbol files.
    For gEDA to be able to find the generated symbols a project
    file *gafrc* will be placed in the same directory as the
    schematic file adding an instruction to include the local
    symbols directory. If a *gafrc* file already exists it will
    not be overwritten but a warning will be printed to check
    for the required instruction.

    An easy to use example to run the parser would be:
    >>> import writer.geda
    >>> writer.geda.GEDA(auto_include=True)
    >>> writer.geda.write(design, 'geda_test_design.sch')

    To provide additional symbol directories to use for
    symbol lookup try this:
    >>> import writer.geda
    >>> writer.geda.GEDA(symbol_dirs=[
        '/usr/share/gEDA/sym',
        'some/local/path/symbols',
    ])
    >>> writer.geda.write(design, 'geda_test_design.sch')
"""

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Basic Strategy
# 0) converted file will be store in subdirectory
# 1) create subdirectory, symbol and project file
# 2) Write each component into a .sym file (even EMBEDDED components)
# 3) Write component instances to .sch file
# 4) Store net segments at the end of .sch file
#
# NOTE: The gEDA format is based on a 100x100 MILS grid where
# 1 MILS is equal to 1/1000 of an inch. In a vanilla gEDA file
# a blueprint-style frame is present with origin at
# (40'000, 40'000).


import os
import types
import codecs

from upconvert.core import shape
from upconvert.core import components
from upconvert.core.shape import Point
from upconvert.core.annotation import Annotation

from upconvert.parser import geda_commands
from upconvert.parser.geda import GEDAError
from upconvert.parser.geda import find_symbols


class GEDA:
    """ The gEDA Format Writer """

    ## gEDA grid size is 100mils
    ## to 10px in openjson format
    SCALE_FACTOR = 10

    ALIGNMENT = {
        'left': 0,
        'center': 3,
        'right': 4,
    }

    def __init__(self, symbol_dirs=None):
        """ Constructs a new GEDA object and initialises it. *symbol_dirs*
            expects a list of directories. It will search for .sym files
            in all the specified directories.
        """

        if symbol_dirs is None:
            symbol_dirs = []

        symbol_dirs = symbol_dirs + \
            [os.path.join(os.path.dirname(__file__), '..',
                          'library', 'geda')]

        self.known_symbols = find_symbols(symbol_dirs)

        ## offset used as bottom left origin as default
        ## in gEDA when starting new file
        self.offset = Point(0, 0)
        self.component_library = None

        ##NOTE: special attributes that are processed
        ## separately and will not be used as regular attributes
        self.ignored_attributes = [
            '_prefix',
            '_suffix',
            '_geda_imported',
        ]
        self.ignored_annotations = self.ignored_attributes + [
            'name',
            'refdes'
        ]
        self.project_dirs = {
            'symbol': None,
            'project': None,
        }

        self.component_names = []

    def set_offset(self, point):
        """ Set the offset point for the gEDA output. As OpenJSON
            positions the origin in the center of the viewport and
            gEDA usually uses (40'000, 40'000) as page origin, this
            allows for translating from one coordinate system to
            another. It expects a *point* object providing a *x* and
            *y* attribute.
        """
        self.offset.x = point.x
        self.offset.y = point.y

    def write(self, design, filename):
        """ Write the design to the gEDA format """
        self.component_library = dict()

        attrs = design.design_attributes.attributes
        self.offset.x = int(attrs.get('_geda_offset_x', 0))
        self.offset.y = int(attrs.get('_geda_offset_y', 0))

        ## setup project environment
        self.create_project_files(filename)

        ## generate GEDA commands for all top-level shapes/pins
        ## in the current design
        output = self.generate_body_commands(design)

        ## create symbol files for components writing all symbols
        ## to local 'symbols' directory. Symbols that are available
        ## in provided directories are ignored and referenced.
        for library_id, component in design.components.components.items():
            self.write_component_to_file(library_id, component)

        ## generate commands for schematic file from design
        ## output is a list of lines
        output += self.write_schematic_file(design)

        with codecs.open(filename, encoding='utf-8', mode='w') as f_out:
            f_out.write(self.commands_to_string(output))

    def create_project_files(self, filename):
        """ Creates various files and directories based on the *filename*.
            The directory of *filename* is assumed to be the project
            directory. The method creates a *gafrc* file adding support
            to load symbols from the local 'symbols' directory. If this
            directory does not exist it is created.
            The *gafrc* is not overwritten when it exists assume that there
            is more settings stored in it. A warning will be printed to
            stdout to remind you to add the directory lookup.
        """
        project_dir = os.path.dirname(filename)
        symbol_dir = os.path.join(project_dir, 'symbols-' + os.path.basename(filename))

        if not os.path.exists(symbol_dir):
            os.mkdir(symbol_dir)

        self.project_dirs['symbol'] = symbol_dir
        self.project_dirs['project'] = project_dir

    def write_schematic_file(self, design):
        """ Creates a list of gEDA commands based on the *design*.

            Returns a list of gEDA commands without trailing linebreaks.
        """
        output = []

        ## create page frame & write name and owner
        output += self._create_schematic_title(design.design_attributes)

        ## create component instances
        output += self.generate_instances(design.component_instances)

        ## create gEDA commands for all nets
        output += self.generate_net_commands(design.nets)

        return output

    def generate_instances(self, component_instances):
        """ Generates a list of gEDA commands from the list of
            *component_instances*. For each instance the referenced
            component is retrieved and an attribute environment is
            attached if attributes are present for the given
            environment.

            Returns a list of gEDA commands without trailing linebreaks.
        """
        commands = []

        for instance in component_instances:
            mirrored = 0
            if '_MIRRORED' in instance.library_id:
                mirrored = 1

            ## retrieve symbol for instance
            component_symbol = self.component_library[(
                instance.library_id.replace('_MIRRORED', ''),
                instance.symbol_index
            )]

            component_annotations = []

            ## create component instance for every symbolattribute
            attr_x, attr_y = 0, 0
            for symbol_attribute in instance.symbol_attributes:
                commands += self._create_component(
                    symbol_attribute.x,
                    symbol_attribute.y,
                    angle=symbol_attribute.rotation,
                    mirrored=mirrored,
                    basename=component_symbol,
                )

                component_annotations += symbol_attribute.annotations

                attr_x = symbol_attribute.x
                attr_y = symbol_attribute.y

            for annotation in component_annotations:
                commands += self._convert_annotation(annotation)

            ## start an attribute environment
            commands.append('{')

            refdes = instance.attributes.get('name', None)
            refdes = instance.attributes.get('refdes', refdes)

            if refdes:
                commands += self._create_attribute(
                    'refdes',
                    refdes,
                    attr_x,
                    attr_y,
                    visibility=1,
                )

            for key, value in instance.attributes.items():
                if key != 'refdes':
                    ## no position details available, stack attributes
                    attr_x, attr_y = attr_x + 10, attr_y + 10
                    commands += self._create_attribute(
                            key, value,
                            attr_x, attr_y
                    )

            ## close the attribute environment
            commands.append('}')

        return commands

    def write_component_to_file(self, library_id, component):
        """ Writes a *component* to a local symbol file and adds it to
            the symbol lookup used for instantiating components. A component
            might have a special attribute 'geda_imported' assigned when
            converted with the upconverter parser. This allows for retrieving
            that a local symbol file can be referenced. If this attribute is
            not present, a new symbol file will be generated in the project
            directory's symbols directory.
        """
        # pylint: disable=R0914

        ##NOTE: extract and remove gEDA internal attribute
        geda_imported = component.attributes.get('_geda_imported', 'false')
        geda_imported = (geda_imported == "true")

        prefix = component.attributes.get('_prefix', None)
        suffix = component.attributes.get('_suffix', None)
        if prefix is not None and suffix is not None:
            component.attributes['refdes'] = '%s?%s' % (prefix, suffix)

        symbol_filename = None
        ##NOTE: this attributed is used in the parser to mark at component
        ## as being imported using the upconverter. If this marker is found
        ## local .sym files will be referenced if available.
        if geda_imported:
            ##remove mirrored tag from name
            if '_MIRRORED' in component.name:
                component.name = component.name.replace('_MIRRORED', '')

            ##check if component is known sym file in OS dirs
            symbol_filename = "%s.sym" % component.name.replace('EMBEDDED', '')

            self.component_library[(
                library_id.replace('_MIRRORED', ''),
                0
            )] = symbol_filename

            if component.name.replace('EMBEDDED', '') in self.known_symbols:
                return

        ## symbol files should not use offset
        saved_offset = self.offset
        self.offset = shape.Point(0, 0)

        ## write symbol file for each symbol in component
        for sym_idx, symbol in enumerate(component.symbols):

            symbol_attr = "_symbol_%d_0" % sym_idx
            if symbol_attr in component.attributes:
                prefix = component.attributes[symbol_attr]
                del component.attributes[symbol_attr]
            else:
                prefix = component.name

            if not geda_imported:
                prefix = prefix.replace(' ', '_')
                prefix_idx = 1
                while prefix in self.component_names:
                    prefix_idx += 1
                    prefix = prefix + str(prefix_idx)
                symbol_filename = "%s-%d.sym" % (prefix, sym_idx)
                if prefix not in self.component_names:
                    self.component_names.append(prefix)

            commands = []
            for body in symbol.bodies:
                commands += self.generate_body_commands(body)

            attr_y = 0
            for key, value in component.attributes.items():
                if not key.startswith('_symbol') \
                   and key not in self.ignored_attributes:
                    commands += self._create_attribute(
                        key, value,
                        0, attr_y,
                    )
                    attr_y = attr_y + 10

            ## write commands to file
            path = os.path.join(
                self.project_dirs['symbol'],
                symbol_filename
            )
            with codecs.open(path, encoding='utf-8', mode='w') as fout:
                fout.write(self.commands_to_string(commands))

            ## required for instantiating components later
            self.component_library[(library_id, sym_idx)] = symbol_filename

        ## restore offset
        self.offset = saved_offset

    @staticmethod
    def commands_to_string(commands):
        """ Generates a string from the *commands* list. It assumes that each
            element in *commands* is a line, adding linebreaks accordingly.
            Required file headings are inserted. There resulting string is in
            valid gEDA file format and can be written to file directly.

            Returns gEDA fileformat string.
        """

        commands = ['v 20110115 2'] + commands
        return '\n'.join(commands)

    def generate_body_commands(self, body):
        """ Generates gEDA commands for *body* converting all shapes
            into valid gEDA shapes. If the body can be represented as
            a gEDA 'path' command it will generated as such. Pins are
            added after shapes.

            Returns a list of gEDA commands without trailing linebreaks.
        """
        commands = []

        id_param = geda_commands.GEDAExtraParameter('id')
        ## extract paths
        paths = {}
        for shape_ in body.shapes:
            path_id = shape_.styles.get(id_param.name, None)
            paths.setdefault(path_id, []).append(shape_)

        for shape_ in paths.get(None, []):
            method_name = '_convert_%s' % shape_.type
            if hasattr(self, method_name):
                commands += getattr(self, method_name)(shape_)
            else:
                raise GEDAError(
                    "invalid shape '%s' in component" % shape_.type
                )

        for path_id in paths:
            if path_id is not None:
                commands += self._create_path(paths[path_id])

        ## create commands for pins
        for pin_seq, pin in enumerate(body.pins):
            commands += self._create_pin(pin_seq, pin)

        return commands

    def generate_net_commands(self, nets):
        """ Generates gEDA commands for list of *nets*. Net names are
            retrieved from the 'name' attribute and are stored in the
            first gEDA net segment. By definition this will be populated
            in gEDA to all segments in the same net.

            Returns a list of gEDA commands without linebreaks.
        """
        commands = []

        for net in nets:

            ## check if 'name' attribute carries net name
            if 'name' in net.attributes and net.attributes['name']:
                net.attributes['netname'] = net.attributes['name']

            elif len(net.annotations) > 0:
                ## assume that the first annotation is net name
                annotation = net.annotations[0]
                net.attributes['netname'] = annotation.value
                net.annotations.remove(annotation)

            ## parse annotations into text commands
            for annotation in net.annotations:
                if annotation.value == 'name':
                    continue
                commands += self._create_text(
                    annotation.value,
                    annotation.x,
                    annotation.y,
                    rotation=annotation.rotation
                )

            ## generate list of segments from net points
            ## prevent segments from being added twice (reverse)
            segments = set()
            for start_id, start_pt in net.points.items():
                for end_id in start_pt.connected_points:
                    if (end_id, start_id) not in segments:
                        segments.add((start_id, end_id))

            attributes = dict(net.attributes)
            net_name = attributes.get('name', None)

            for segment in segments:
                start_id, end_id = segment

                ## check for missing points
                if start_id not in net.points or \
                        end_id not in net.points:
                    continue

                ## prevent zero-length segements from being written
                if net.points[start_id].x == net.points[end_id].x \
                    and net.points[start_id].y == net.points[end_id].y:
                    ## the same point is defined twice
                    continue

                commands += self._create_segment(
                    net.points[start_id],
                    net.points[end_id],
                    attributes=attributes,
                    net_name=net_name,
                )

                ## it's enough to store net name only in first element
                if attributes is not None:
                    attributes = None

        return commands

    def _create_schematic_title(self, design_attributes):
        """ Creates gEDA commands for the toplevel gEDA schematic
            including the schematic frame, title and owner name.
            Toplevel attributes are attached as well.

            Returns a list of gEDA commands without linebreaks.
        """
        commands = []

        title_frame = design_attributes.attributes.pop(
            '_geda_titleframe',
            None,
        )

        if title_frame is None:
            return []

        commands += self._create_component(
            0, 0,  # use 0, 0 as coordinates will be converted in component
            title_frame + '.sym',
        )

        if design_attributes.metadata.owner:
            commands += self._create_text(
                design_attributes.metadata.owner,
                1390,
                10,
                size=10
            )

        if design_attributes.metadata.name:
            commands += self._create_text(
                design_attributes.metadata.name,
                1010,
                80,
                size=20
            )

        if design_attributes.metadata.license:
            commands += self._create_attribute(
                '_use_license',
                design_attributes.metadata.license,
                0, 0
            )

        ## set coordinates at offset for design attributes
        attr_x, attr_y = 0, 0
        for key, value in design_attributes.attributes.items():
            if key.startswith('_geda'):
                continue
            commands += self._create_attribute(
                key, value,
                attr_x,
                attr_y,
            )
            attr_y = attr_y + 10

        return commands

    def _create_component(self, x, y, basename, angle=0, mirrored=0):
        """ Creates a gEDA command for a component in symbol file *basename*
            at location *x*, *y*. *angle* allows for specifying the rotation
            angle of the component and is specified in pi radians. Valid values
            are 0.0, 0.5, 1.0, 1.5.

            Returns a list of gEDA commands without linebreaks.
        """
        # pylint: disable=C0103,R0913
        x, y = self.conv_coords(x, y)
        return geda_commands.GEDAComponentCommand().generate_command(
            x=x, y=y,
            angle=self.conv_angle(angle),
            mirror=mirrored,
            basename=basename
        )

    def _create_attribute(self, key, value, x, y, **kwargs):
        """ Creates a gEDA attribute command from *key* and *value*
            at position *x*,*y*. If *key* is prefixed by '_' it is
            interpreted as private and the attribute will be set as
            invisible. Visibility can be specified explicitly using
            the keyword *visibility*.

            Returns a list of gEDA commands without linebreaks.
        """
        # pylint: disable=C0103
        if key in self.ignored_attributes or not value:
            return []

        ## make private attribute invisible in gEDA
        if key.startswith('_'):
            key = key[1:]
            kwargs['visibility'] = 0

        try:
            text = "%s=%s" % (unicode(key), unicode(value))
        except UnicodeDecodeError:
            text = "%s=%s" % (unicode(key), unicode(value, errors='replace'))

        kwargs['style_color'] = geda_commands.GEDAColor.ATTRIBUTE_COLOR

        return self._create_text(text, x, y, **kwargs)

    def _create_text(self, text, x, y, **kwargs):
        """ Creates a gEDA text command with *text* at position
            *x*, *y*. Further valid keywords include *size*,
            *alignment*, *angle* and *visibility*.

            Returns a list of gEDA commands without trailing linebreaks.
        """
        # pylint: disable=C0103
        if isinstance(text, basestring):
            text = text.split('\n')

        assert(isinstance(text, types.ListType))

        kwargs.update({
            'x': self.x_to_mils(x),
            'y': self.y_to_mils(y),
            'angle': self.conv_angle(kwargs.get('angle', 0)),
            'alignment': self.ALIGNMENT[kwargs.get('alignment', 'left')],
            'num_lines': len(text),
        })

        commands = geda_commands.GEDATextCommand().generate_command(**kwargs)
        return commands + text

    def _create_pin(self, pin_seq, pin):
        """ Creates a pin command followed by the mandatory
            attribute environment. The numeric *pin_seq*
            is stored as gEDA attribute *pinseq*. *pinnummer*
            attribute is taken from the pin's pin_number
            attribute. If the pin has a label it will a
            *pinlabel* gEDA attribute is attached.

            Returns a list of gEDA commands without trailing linebreaks.
        """
        # pylint: disable=W0142
        assert(issubclass(pin.__class__, components.Pin))

        connected_x, connected_y = pin.p2.x, pin.p2.y
        kwargs = {
            "x1": self.x_to_mils(connected_x),
            "y1": self.y_to_mils(connected_y),
            "x2": self.x_to_mils(pin.p1.x),
            "y2": self.y_to_mils(pin.p1.y),
        }
        kwargs.update(pin.styles)

        command = geda_commands.GEDAPinCommand().generate_command(**kwargs)

        command.append('{')

        if pin.label is not None:
            attribute = self._create_attribute(
                'pinlabel',
                pin.label.text,
                pin.label.x,
                pin.label.y,
                alignment=pin.label.align,
                angle=pin.label._rotation
            )
            command += attribute

        command += self._create_attribute(
            'pinseq',
            pin_seq,
            connected_x + 10,
            connected_y + 10,
            visibility=0,
        )
        command += self._create_attribute(
            'pinnumber',
            pin.pin_number,
            connected_x + 10,
            connected_y + 20,
            visibility=0,
        )

        command.append('}')
        return command

    def _convert_annotation(self, annotation):
        """ Converts Annotation object in *annotation* into a
            gEDA text command. If the annotation text is
            enclosed in '{{' '}}' it will be ignored and an
            empty list is returned.

            Returns a list of gEDA commands without linebreaks.
        """
        # pylint: disable=W0142
        assert(issubclass(annotation.__class__, Annotation))

        if annotation.value in self.ignored_annotations:
            return []

        if bool(annotation.visible in (True, 'true')):
            visibility = 1
        else:
            visibility = 0

        kwargs = dict(
            text=annotation.value,
            x=annotation.x,
            y=annotation.y,
            angle=annotation.rotation,
            visibility=visibility,
        )
        return self._create_text(**kwargs)

    def _convert_arc(self, arc):
        """ Converts Arc object in *arc* into a gEDA arc command.
            Returns a list of gEDA commands without line breaks.
        """
        # pylint: disable=C0103,W0142
        assert(issubclass(arc.__class__, shape.Arc))

        x, y = self.conv_coords(arc.x, arc.y)
        start_angle = self.conv_angle(arc.start_angle)

        sweep_angle = self.conv_angle(arc.end_angle) - start_angle
        if sweep_angle < 0:
            sweep_angle = 360 + sweep_angle

        kwargs = dict(
            x=x, y=y,
            radius=self.to_mils(arc.radius),
            startangle=start_angle,
            sweepangle=sweep_angle,
        )
        kwargs.update(arc.styles)
        return geda_commands.GEDAArcCommand().generate_command(**kwargs)

    def _convert_circle(self, circle):
        """ Converts Circle object in *circle* to gEDA circle command.

            Returns gEDA command as list without trailing line breaks.
        """
        # pylint: disable=W0142
        assert(issubclass(circle.__class__, shape.Circle))

        center_x, center_y = self.conv_coords(circle.x, circle.y)
        kwargs = dict(
            x=center_x,
            y=center_y,
            radius=self.to_mils(circle.radius)
        )
        kwargs.update(circle.styles)
        return geda_commands.GEDACircleCommand().generate_command(**kwargs)

    def _convert_rounded_rectangle(self, rect):
        """ Converts RoundedRectangle object into gEDA rectangle command.

            Returns gEDA command (without trailing line break) as list.
        """
        return self._convert_rectangle(rect)

    def _convert_rectangle(self, rect):
        """ Converts Rectangle object into gEDA rectangle command.

            Returns gEDA command (without trailing line break) as list.
        """
        # pylint: disable=W0142
        assert(issubclass(rect.__class__, (shape.Rectangle,
                                           shape.RoundedRectangle)))

        top_x, top_y = self.conv_coords(rect.x, rect.y)
        width, height = self.to_mils(rect.width), self.to_mils(rect.height)
        kwargs = dict(
            x=top_x,
            y=(top_y - height),
            width=width,
            height=height
        )
        kwargs.update(rect.styles)
        return geda_commands.GEDABoxCommand().generate_command(**kwargs)

    def _convert_line(self, line):
        """ Converts Line object in *line* to gEDA command.

            Returns gEDA command (without line break) as list.
        """
        # pylint: disable=W0142
        assert(issubclass(line.__class__, shape.Line))

        start_x, start_y = self.conv_coords(line.p1.x, line.p1.y)
        end_x, end_y = self.conv_coords(line.p2.x, line.p2.y)

        kwargs = dict(
            x1=start_x,
            y1=start_y,
            x2=end_x,
            y2=end_y
        )
        kwargs.update(line.styles)
        return geda_commands.GEDALineCommand().generate_command(**kwargs)

    def _convert_label(self, label):
        """ Converts Label object in *label* to gEDA command.
            Returns gEDA command (without line break) as list.
        """
        # pylint: disable=W0142
        assert(issubclass(label.__class__, shape.Label))

        kwargs = dict(
            text=label.text,
            x=label.x,
            y=label.y,
            alignment=label.align,
            angle=label._rotation,
        )
        kwargs.update(label.styles)
        return self._create_text(**kwargs)

    def _create_segment(self, np1, np2, attributes=None, net_name=None):
        """ Creates net segment from NetPoint *np1* to
            *np2*. If dictionary of *attributes* is specified
            commands for the attribute environment are generated
            as well.

            Returns a list of gEDA commands without trailing linebreaks.
        """
        np1_x, np1_y = self.conv_coords(np1.x, np1.y)
        np2_x, np2_y = self.conv_coords(np2.x, np2.y)

        command = geda_commands.GEDASegmentCommand().generate_command(
            x1=np1_x, y1=np1_y,
            x2=np2_x, y2=np2_y,
        )

        if attributes is None:
            attributes = {}

        if net_name:
            attributes['netname'] = net_name

        if attributes:
            command.append('{')
            for key, value in attributes.items():
                command += self._create_attribute(
                    key,
                    value,
                    np1.x + 10,
                    np1.y + 10
                )
            command.append('}')

        return command

    def _convert_polygon(self, polygon):
        """ Converts Polygon object in *polygon* to gEDA path command.

            Returns a list of gEDA commands without trailing linebreaks.
        """
        num_lines = len(polygon.points) + 1  # add closing command to polygon
        commands = geda_commands.GEDAPathCommand().generate_command(
            num_lines=num_lines
        )

        start_x, start_y = polygon.points[0].x, polygon.points[0].y
        commands.append('M %d,%d' % self.conv_coords(start_x, start_y))

        for point in polygon.points[1:]:
            commands.append('L %d,%d' % self.conv_coords(point.x, point.y))

        commands.append('z')  # closes the polygon

        return commands

    def _create_path(self, shapes):
        """ Creates a set of gEDA commands for *path*.

            Returns gEDA commands without trailing linebreaks as list.
        """
        # pylint: disable=R0914,W0142
        num_lines = 1
        shapes = list(shapes)  # create new list to be able to modify

        current_x, current_y = self.conv_coords(
            shapes[0].p1.x,
            shapes[0].p1.y
        )
        start_x, start_y = current_x, current_y
        command = ['M %d,%d' % (start_x, start_y)]

        close_command = []
        ## check if last element is line back to starting point
        if shapes[-1].type == 'line':
            if shapes[-1].p2.x == shapes[0].p1.x \
                and shapes[-1].p2.y == shapes[0].p1.y:
                ## discard line and close path instead
                close_command = ['z']
                shapes.remove(shapes[-1])
                num_lines += 1

        shape_styles = {}  # store shape style in this dict for later use
        for shape_obj in shapes:
            if shape_obj.type == 'line':
                current_x, current_y = self.conv_coords(
                    shape_obj.p2.x,
                    shape_obj.p2.y
                )
                command.append("L %d,%d" % (current_x, current_y))

            elif shape_obj.type == 'bezier':
                c1_x, c1_y = self.conv_coords(
                    shape_obj.control1.x,
                    shape_obj.control1.y
                )
                c2_x, c2_y = self.conv_coords(
                    shape_obj.control2.x,
                    shape_obj.control2.y
                )
                current_x, current_y = self.conv_coords(
                    shape_obj.p2.x,
                    shape_obj.p2.y
                )

                command += [
                    'C %d,%d %d,%d %d,%d' % (
                        c1_x, c1_y,
                        c2_x, c2_y,
                        current_x, current_y
                    )
                ]

            else:
                raise GEDAError(
                    "shape type '%s' invalid in path" % shape_obj.type
                )

            num_lines += 1
            shape_styles.update(shape_obj.styles)

        kwargs = {
            'num_lines': num_lines,
        }
        kwargs.update(shape_styles)
        return geda_commands.GEDAPathCommand().generate_command(
            **kwargs
        ) + command + close_command

    def _convert_bezier(self, curve):
        """ Converts BezierCurve object in *curve* to gEDA curve command.

            Returns gEDA command without trailing linebreaks as list.
        """
        # pylint: disable=W0142
        assert(issubclass(curve.__class__, shape.BezierCurve))
        p1_x, p1_y = self.conv_coords(curve.p1.x, curve.p1.y)
        c1_x, c1_y = self.conv_coords(curve.control1.x, curve.control1.y)

        p2_x, p2_y = self.conv_coords(curve.p2.x, curve.p2.y)
        c2_x, c2_y = self.conv_coords(curve.control2.x, curve.control2.y)

        path_commands = [
            'M %d,%d' % (p1_x, p1_y),
            'C %d,%d %d,%d %d,%d' % (c1_x, c1_y, c2_x, c2_y, p2_x, p2_y)
        ]

        kwargs = {
            'num_lines': len(path_commands),
        }
        kwargs.update(curve.styles)
        return geda_commands.GEDAPathCommand().generate_command(
            **kwargs
        ) + path_commands

    @staticmethod
    def is_valid_path(body):
        """ Checks if *body* contains only shapes that can be
            represented as a gEDA path. If body contains only
            Line and BezierCurve shapes and all shapes are
            succesively connected it is a valid path.

            Returns True for body that can be represented as gEDA
                path, False otherwise.
        """
        current_pt = None

        for shape_obj in body.shapes:
            if shape_obj.type not in ['line', 'bezier']:
                return False

            if current_pt is None:
                current_pt = shape_obj.p1

            if not (current_pt.x == shape_obj.p1.x
                and current_pt.y == shape_obj.p1.y):
                return False

            current_pt = shape_obj.p2

        return True

    def to_mils(self, value):
        """ Converts *value* from px to mils based on the
            scaling factor. Offset is not used.

            Returns integer value in MILS.
        """
        return value * self.SCALE_FACTOR

    def y_to_mils(self, y_px):
        """ Converts *y_px* from pixel to mils and translating
            it along the Y axis according to the offset value.

            Returns a scaled and translated Y coordinate in MILS.
        """
        value = (y_px * self.SCALE_FACTOR) + self.offset.y
        return value

    def x_to_mils(self, x_px):
        """ Converts *x_px* from pixel to mils and translating
            it along the X axis according to the offset value.

            Returns a scaled and translated X coordinate in MILS.
        """
        value = (x_px * self.SCALE_FACTOR) + self.offset.x
        return value

    @staticmethod
    def conv_angle(angle, steps=1):
        """ Converts *angle* in pi radians into degrees. If
            *steps* is set, it will be used to limit angles
            to the provide steps in degrees.

            Retuns converted and cut-off angle in degrees.
        """
        converted_angle = int(angle * 180) // int(steps)
        converted_angle *= steps

        ## convert from clockwise rotation to counter-clockwise
        ## as used in gEDA schematic
        return abs(360 - converted_angle) % 360

    def conv_coords(self, x_px, y_px):
        """ Converts *x_px*, *y_px* from pixel to mils and translating
            it along the X- and Y-axes, respectively, according to
            the offset value.

            Returns a scaled and translated coordinates in MILS.
        """
        return (
            self.x_to_mils(x_px),
            self.y_to_mils(y_px)
        )

########NEW FILE########
__FILENAME__ = gerber
#!/usr/bin/env python2
""" The Gerber RS274-X Format Writer """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from sys import stdout
from os import path, mkdir, listdir, makedirs, stat
from shutil import rmtree
from collections import namedtuple
from tarfile import TarFile
from zipfile import ZipFile
import copy
import errno
import freetype
import logging

from upconvert.core.component_instance import FootprintPos
from upconvert.core.layout import Aperture, Image, Macro, MacroAperture, Smear, Fill
from upconvert.core.shape import Circle, Rectangle, Obround, RegularPolygon
from upconvert.core.shape import Polygon, Moire, Thermal
from upconvert.core.shape import Point, Arc, Line


log = logging.getLogger('writer.gerber')


# exceptions

class Unwritable(ValueError):
    """ Parent class for all gerber writer errors. """
    pass

class MissingLayout(Unwritable):
    """ Design has no layout information. """
    pass

class NoLayersFound(Unwritable):
    """ Layout doesn't have any layers. """
    pass

class UnitsNotSpecified(Unwritable):
    """ Layout doesn't specify units. """
    pass

class ImageContainsNoData(Unwritable):
    """ One of the layers contains an empty image. """
    pass

class NotBatch(ValueError):
    """ The intended output is a single file. """
    pass


# constants
POS_UNITS_PER_MM = 1000 * 1000
POS_UNITS_PER_MIL = 25400
POS_UNITS_PER_CM = POS_UNITS_PER_MM * 10
POS_UNITS_PER_IN = POS_UNITS_PER_MIL * 1000

LINE = '{0}\r\n'
FORMAT_SPEC = '%FSLAX{int}{dec}Y{int}{dec}*%'
MACRO = LINE.format('%AM{name}*') + '{primitives}%'
PRIMITIVE = '{mods}*'
APERTURE = '%ADD{code}{type}{mods}*%'
AP_MODS = ',{mods}'
PARAM = '%{name}{val}*%'
SR_MODS = 'X{x}Y{y}I{i}J{j}'
FUNCT = '{type}{code}*'
COORD = 'X{x}Y{y}*'
COORD_EXT = 'X{x}Y{y}I{i}J{j}*'
PLOT = 'X{x}Y{y}D01*'
MOVE = 'X{x}Y{y}D02*'
FLASH = 'X{x}Y{y}D03*'
LAYER_NAME = '%LN{layer_name}*%'
LAYER_POLARITY_CLEAR = '%LPC*%'
LAYER_POLARITY_DARK = '%LPD*%'
MM_UNITS = '%MOMM*%'
IN_UNITS = '%MOIN*%'
EOF = 'M02*'
INTERPOLATION = {'LINEAR': '01',
                 'CLOCKWISE_CIRCULAR': '02',
                 'ANTICLOCKWISE_CIRCULAR': '03'}
SHAPE_TAGS = {'circle': {'int': 1, 'char': 'C'},
              'center_rectangle': {'int': 21, 'char': 'R'},
              'rectangle': {'int': 22, 'char': 'R'},
              'obround': {'char': 'O'},
              'reg_polygon': {'int': 5, 'char': 'P'},
              'polygon': {'int': 4},
              'moire': {'int': 6},
              'thermal': {'int': 7}}
LAYERS_CFG = 'layers.cfg'
TAR_MODES = {'.tar': 'w',
             '.gz': 'w:gz',
             '.tgz': 'w:gz',
             '.bz2': 'w:bz2'}


# archive class

Batch = namedtuple('Batch', 'archive add_ rootdir')             # pylint: disable=C0103


# writer

class Gerber:
    """ The Gerber Format Writer. """

    def __init__(self):
        self.coord_format = None
        self.face = freetype.Face('./arial.ttf')
        self._reset()

    def _reset(self):
        self.layers = list()
        self.images = list()
        self.apertures = list()
        self.macros = list()
        self.status = {'x':0,
                       'y':0,
                       'interpolation':None,
                       'aperture':None,
                       'outline_fill':False,
                       'multi_quadrant':False,
                       'units':None,
                       'incremental_coords':None}


    def write(self, design, outfile=None):
        """ Main logic for producing a set of output files. """
        log.debug('starting gerber write to %s', outfile)
        self._check_design(design)
        if outfile:
            dir_ = path.dirname(outfile)
            if dir_:
                try:
                    stat(dir_)
                except OSError:
                    makedirs(dir_)
        batch = self._get_archive(outfile)

        if batch:
            cfg_name = self._config_batch(batch, outfile)
            with open(cfg_name, 'w') as cfg:
                for layer in design.layer_options:
                    member_name = layer.name.lower().replace(' ', '_') + '.ger'
                    with open(batch.rootdir and
                              path.join(batch.rootdir, member_name) or
                              path.join(dir_, member_name), 'w') as member:
                        self._write_layer(design, layer, member)
                    cfg.write(LINE.format(', '.join([layer.name, member_name])))
            if batch.archive:
                #TODO: line below doesn't work
                #batch.add_(batch.rootdir)
                for member_name in listdir(batch.rootdir):
                    batch.add_(path.join(batch.rootdir, member_name))
                batch.archive.close()
                rmtree(batch.rootdir)

        else:
            #TODO: check that there's actually only one layer
            with outfile and open(outfile, 'w') or stdout as f:
                self._write_layer(design, design.layer_options[0], f)


    # primary writer support methods
    def _get_archive(self, outfile):
        """ Establish zip or tarfile for batch output. """
        batch = None
        if outfile:
            filename = path.basename(outfile)
            rootdir, ext = path.splitext(filename)
            if ext in TAR_MODES.keys() + ['.zip']:
                if ext == '.zip':
                    archive = ZipFile(outfile, 'w')
                    add_ = archive.write
                else:
                    archive = TarFile.open(outfile, TAR_MODES[ext])
                    add_ = archive.add
                rootdir = filename.split('.')[0]
                batch = Batch(archive, add_, rootdir)
            elif LAYERS_CFG in filename:
                batch = Batch(False, False, False)
        return batch


    def _config_batch(self, batch, outfile):
        """ Establish config file for batch output. """
        if not batch:
            raise NotBatch
        else:
            if batch.rootdir:
                try:
                    mkdir(batch.rootdir)
                except OSError as exc: # Python >2.5
                    if exc.errno == errno.EEXIST:
                        pass
                    else: raise
                cfg_name = path.join(batch.rootdir, LAYERS_CFG)
            else:
                cfg_name = outfile
        return cfg_name



    def _write_layer(self, design, layer_options, layer_file):
        """ Write the information for `layer_name` from the design to a single gerber file. """

        # Initialize the writer state for the layer
        self._reset()

        # decompose layer data into images and the apertures and macros used to represent the images,
        self._define_images(design, layer_options.name)

        self._define_macros()
        self._define_apertures()

        # write layer parameters
        layer_file.write(LINE.format(self._get_format_spec(design.layout_units)))
        if design.layout_units == 'mm':
            layer_file.write(LINE.format(MM_UNITS))
        elif design.layout_units == 'in':
            layer_file.write(LINE.format(IN_UNITS))
        else:
            raise UnitsNotSpecified('acceptable units not specified')

        # include macros and apertures used on the layer
        for macro in self.macros:
            layer_file.write(self._get_macro_def(macro))
        for aperture in self.apertures:
            if isinstance(aperture, MacroAperture):
                layer_file.write(self._get_macro_ap_def(aperture))
            elif isinstance(aperture, Aperture):
                layer_file.write(self._get_shape_ap_def(aperture))
            else:
                raise TypeError('unexpected aperture class')

        # FIXME(shamer): What is this check doing?
        # select an arbitrary aperture for trace[0] check
        if self.apertures:
            self.status['aperture'] = self.apertures[0]
            layer_file.write(LINE.format(FUNCT.format(type='D', code=self.apertures[0].code)))

        for i in range(len(self.layers)):
            for param in self._get_image_meta(i, self.layers):
                layer_file.write(param)
            for block in self._gen_paths(self.layers[i]):
                layer_file.write(block)

        # build non-layer images - main data section
        for i in range(len(self.images)):
            for param in self._get_image_meta(i, self.images):
                layer_file.write(param)
            for block in self._gen_paths(self.images[i]):
                layer_file.write(block)

        # tidy up
        layer_file.write(EOF)


    def  _define_images(self, design, layer_name):
        """ Define the images that make up the layer information. """
        log.debug('creating images for layer "%s"', layer_name)

        # trace segments on this layer
        traces_image = Image(layer_name + '_traces', font_renderer=self.face)
        for segment in design.trace_segments:
            if segment.layer != layer_name:
                continue
            log.debug('Creating smear for trace: %s', segment)

            # Assumes segment is rounded, straignt
            trace_smear = Smear(Line(segment.p1, segment.p2), Circle(0, 0, segment.width / 2.0))
            traces_image.smears.append(trace_smear)

        # Generated objects in the design (vias, PTHs)
        zero_pos = FootprintPos(0, 0, 0.0, False, 'top')
        for gen_obj in design.layout_objects:
            # XXX(shamer): body attr is only being used to hold the layer, other placement details are contained
            # elsewhere
            for body_attr, body in gen_obj.bodies(zero_pos, {}):
                if body_attr.layer == layer_name:
                    for shape in body.shapes:
                        traces_image.add_shape(shape, design, zero_pos, body_attr)

        self.images.append(traces_image)


        # Pours on this layer
        for pour in design.pours:
            log.debug('adding body for pour: %s points, %s', len(pour.points), pour.layer)
            if layer_name == pour.layer:
                log.debug('adding body for pour: %s points, %s subtractive shapes', len(pour.points), len(pour.subtractive_shapes))
                fill_image = Image('pour fill', font_renderer=self.face)
                fill_image.fills.append(Fill(pour.points))
                self.images.append(fill_image)

                subtractive_image = Image('pour subtractive shapes', font_renderer=self.face, is_additive=False)
                for shape in pour.subtractive_shapes:
                    if shape.type == 'rounded_segment':
                        trace_smear = Smear(Line(shape.p1, shape.p2), Circle(0, 0, shape.width / 2.0))
                        subtractive_image.smears.append(trace_smear)
                    else:
                        subtractive_image.add_shape(shape, None, FootprintPos(0, 0, 0.0, False, ''), FootprintPos(0, 0, 0.0, False, ''))
                self.images.append(subtractive_image)

                readded_image = Image('pour readded shapes', font_renderer=self.face, is_additive=True)
                for shape in pour.readded_shapes:
                    if shape.type == 'rounded_segment':
                        trace_smear = Smear(Line(shape.p1, shape.p2), Circle(0, 0, shape.width / 2.0))
                        readded_image.smears.append(trace_smear)
                    else:
                        readded_image.add_shape(shape, None, FootprintPos(0, 0, 0.0, False, ''), FootprintPos(0, 0, 0.0, False, ''))
                self.images.append(readded_image)

        # trace segments on this layer
        traces_image = Image(layer_name + '_traces', font_renderer=self.face)
        for segment in design.trace_segments:
            if segment.layer != layer_name:
                continue
            log.debug('Creating smear for trace: %s', segment)

            # Assumes segment is rounded, straignt
            trace_smear = Smear(Line(segment.p1, segment.p2), Circle(0, 0, segment.width / 2.0))
            traces_image.smears.append(trace_smear)

        # Generated objects in the design (vias, PTHs)
        zero_pos = FootprintPos(0, 0, 0.0, False, 'top')
        for gen_obj in design.layout_objects:
            # XXX(shamer): body attr is only being used to hold the layer, other placement details are contained
            # elsewhere
            for body_attr, body in gen_obj.bodies(zero_pos, {}):
                if body_attr.layer == layer_name:
                    for shape in body.shapes:
                        traces_image.add_shape(shape, design, zero_pos, body_attr)

        self.images.append(traces_image)


        # Component aspects on this layer
        # a separate image is used for each component
        for component_instance in design.component_instances:
            component = design.components.components[component_instance.library_id]
            component_image = Image(layer_name + ' component ' + component_instance.instance_id, font_renderer=self.face)
            footprint_pos = component_instance.footprint_pos
            if footprint_pos.side is None:
                continue

            for idx, footprint_attr in enumerate(component_instance.footprint_attributes):
                log.debug('footprint pos: %s, side %s, flip %s', footprint_attr.layer, footprint_pos.side, footprint_pos.flip_horizontal)
                fp_attr_cpy = copy.deepcopy(footprint_attr)
                if footprint_attr.layer:
                    if footprint_pos.side == 'bottom':
                        # XXX(shamer): don't flip, just take the footprint side. This is a temporary fix to address the
                        # tool not saving the layer correctly for moves on the bottom.
                        #rev_sides = {'top': 'bottom', 'bottom': 'top'}
                        rev_sides = {'top': footprint_pos.side, 'bottom': footprint_pos.side}
                        fp_attr_cpy.layer = ' '.join([rev_sides.get(piece, piece) for piece in footprint_attr.layer.split(' ')])
                if fp_attr_cpy.layer == layer_name:
                    footprint_body = component.footprints[component_instance.footprint_index].bodies[idx]
                    log.debug('adding footprint attribute: %s, %d shapes', fp_attr_cpy, len(footprint_body.shapes))
                    body_pos = copy.deepcopy(footprint_pos)
                    if footprint_pos.flip_horizontal != footprint_body.flip_horizontal:
                        body_pos.rotation = (footprint_pos.rotation - footprint_body.rotation) % 2
                    else:
                        body_pos.rotation = (footprint_pos.rotation + footprint_body.rotation) % 2
                    body_pos.flip_horizontal = (footprint_pos.flip_horizontal != footprint_body.flip_horizontal)

                    for shape in footprint_body.shapes:
                        component_image.add_shape(shape, component_instance, body_pos, fp_attr_cpy)

            for idx, gen_obj_attr in enumerate(component_instance.gen_obj_attributes):
                gen_obj = component.footprints[component_instance.footprint_index].gen_objs[idx]
                # FIXME(shamer): check for unplaced generated objects.

                # XXX(shamer): body attr is only being used to hold the layer, other placement details are contained
                # elsewhere
                for body_attr, body in gen_obj.bodies(footprint_pos, gen_obj_attr.attributes):
                    if body_attr.layer == layer_name:
                        log.debug('adding body for generated object: %s, %s', footprint_pos, gen_obj_attr)
                        for shape in body.shapes:
                            component_image.add_shape(shape, component_instance, footprint_pos, body_attr)

            if component_image.not_empty():
                self.images.append(component_image)

        # paths on the layer
        for path in design.paths:
            if layer_name == path.layer:
                log.debug('adding body for path: %s points, %s, %s, is closed: %s', len(path.points), path.width, path.layer, path.is_closed)
                path_image = Image('path', font_renderer=self.face)
                start = path.points[0]
                for point in path.points[1:]:
                    path_image.add_shape(Line(start, point), Circle(0, 0, path.width), zero_pos, zero_pos)
                    start = point
                if path.is_closed:
                    path_image.add_shape(Line(path.points[0], path.points[-1]), Circle(0, 0, path.width), zero_pos, zero_pos)
                self.images.append(path_image)

        # stand alone text on the layer
        text_image = Image('text', font_renderer=self.face)
        for text in design.pcb_text:
            if layer_name == text.layer:
                log.debug('adding body for text: "%s"', text.value)
                text_image.add_shape(text.label, design, text, zero_pos)

        if text_image.not_empty():
            self.images.append(text_image)


    def _define_macros(self):
        """ Define the macros used in the design. """
        for image in self.images:
            self._define_image_macros(image)
        for layer in self.layers:
            self._define_image_macros(layer)


    def _define_image_macros(self, image):
        """ Build the macros needed to make the image. """
        for complex_instance in image.complex_instances:
            self._add_macro(complex_instance)


    def _add_macro(self, complex_instance):
        """ Add a macro definition for a complex collection of shapes. """
        macro = Macro(complex_instance.name, complex_instance.primitives)
        if macro not in self.macros:
            self.macros.append(macro)


    def _define_apertures(self):
        """ Define the apertures used in the design. """
        for image in self.images:
            self._define_image_apertures(image)
        for layer in self.layers:
            self._define_image_apertures(layer)


    def _define_image_apertures(self, image):
        """ Build the apertures needed to make shapes. """
        for smear in image.smears:
            self._add_shape_aperture(smear.shape, None)
        for shape_instance in image.shape_instances:
            self._add_shape_aperture(shape_instance.shape,
                               shape_instance.hole)
        for complex_instance in image.complex_instances:
            self._add_macro_aperture(complex_instance)


    def _get_format_spec(self, units, max_size=False, max_precision=False):
        """ Generate FS parameter with sensible precision. """
        if units == 'inch':
            int_, dec_ = (2, 4)
        elif units == 'mm':
            int_, dec_ = (3, 3)
        else:
            raise ValueError('unknown unit format: ' + units)
        if max_size:
            int_ = 6
        if max_precision:
            dec_ = 6
        self.coord_format = {'int': int_, 'dec': dec_}
        return FORMAT_SPEC.format(int=int_, dec=dec_)


    def _get_macro_def(self, macro):
        """ Convert macro based on core shapes to gerber. """
        prims_def = ''
        for primitive in macro.primitives:
            shape = primitive.shape
            exposure = primitive.is_additive
            rotation = shape.rotation #or primitive.rotation
            rotation = int((2 - rotation) * 180 or 0)

            if isinstance(shape, Circle):
                mods = [SHAPE_TAGS['circle']['int'],
                        exposure,
                        self._convert_units_str(shape.radius * 2),
                        self._convert_units_str(shape.x),
                        self._convert_units_str(shape.y)]
            elif isinstance(shape, Rectangle) and shape.is_centered:
                mods = [SHAPE_TAGS['center_rectangle']['int'],
                        exposure,
                        self._convert_units_str(shape.width),
                        self._convert_units_str(shape.height),
                        self._convert_units_str(shape.x),
                        self._convert_units_str(shape.y),
                        rotation if not shape.flip_horizontal else -rotation]
            elif isinstance(shape, Rectangle) and not shape.is_centered:
                mods = [SHAPE_TAGS['rectangle']['int'],
                        exposure,
                        self._convert_units_str(shape.width),
                        self._convert_units_str(shape.height),
                        self._convert_units_str(shape.x),
                        self._convert_units_str(shape.y),
                        rotation]
            elif isinstance(shape, Polygon):
                vertices = [(self._convert_units_str(p.x), self._convert_units_str(p.y)) for p in shape.points]
                v_args = [vertices[i / 2][i % 2]
                          for i in range(len(vertices) * 2)]
                mods = [SHAPE_TAGS['polygon']['int'],
                        exposure] + v_args + [rotation]
            elif isinstance(shape, RegularPolygon):
                vertices = [(self._convert_units_str(p.x), self._convert_units_str(p.y)) for p in shape.vertices]
                mods = [SHAPE_TAGS['reg_polygon']['int'],
                        exposure,
                        vertices,
                        self._convert_units_str(shape.x),
                        self._convert_units_str(shape.y),
                        self._convert_units_str(shape.outer_diameter),
                        rotation]
            elif isinstance(shape, Moire):
                mods = [SHAPE_TAGS['moire']['int'],
                        self._convert_units_str(shape.x),
                        self._convert_units_str(shape.y),
                        self._convert_units_str(shape.outer_diameter),
                        self._convert_units_str(shape.ring_thickness),
                        self._convert_units_str(shape.gap_thickness),
                        self._convert_units_str(shape.max_rings),
                        self._convert_units_str(shape.hair_thickness),
                        self._convert_units_str(shape.hair_length),
                        rotation]
            elif isinstance(shape, Thermal):
                mods = [SHAPE_TAGS['thermal']['int'],
                        self._convert_units_str(shape.x),
                        self._convert_units_str(shape.y),
                        self._convert_units_str(shape.outer_diameter),
                        self._convert_units_str(shape.inner_diameter),
                        self._convert_units_str(shape.gap_thickness),
                        rotation]
            mods = ','.join(str(m) for m in mods)
            prim_def = PRIMITIVE.format(mods=mods)
            prims_def += LINE.format(prim_def)
        macro_def = MACRO.format(name=macro.name,
                                 primitives=prims_def.strip())
        return LINE.format(macro_def)


    def _get_shape_ap_def(self, aperture):
        """ Convert aperture based on core shapes to gerber. """

        # get type and shape mods
        shape = aperture.shape
        if isinstance(shape, Circle):
            type_ = SHAPE_TAGS['circle']['char']
            mods = [self._convert_units_str(shape.radius * 2)]
        elif isinstance(shape, Rectangle):
            type_ = SHAPE_TAGS['rectangle']['char']
            mods = [self._convert_units_str(shape.width),
                    self._convert_units_str(shape.height)]
        elif isinstance(shape, Obround):
            type_ = SHAPE_TAGS['obround']['char']
            mods = [self._convert_units_str(shape.width),
                    self._convert_units_str(shape.height)]
        elif isinstance(shape, RegularPolygon):
            rot = shape.rotation
            rotation = int(rot and (2 - rot) * 180 or 0)
            vertices = [(self._convert_units_str(p.x), self._convert_units_str(p.y)) for p in shape.vertices]
            type_ = SHAPE_TAGS['reg_polygon']['char']
            mods = [self._convert_units_str(shape.outer_diameter),
                    vertices,
                    rotation]
        elif isinstance(shape, str):
            type_ = shape
            mods = []

        # add hole mods
        hole = aperture.hole
        if isinstance(hole, Circle):
            hole_mods = [self._convert_units_str(hole.radius)]
        elif hole:
            hole_mods = [self._convert_units_str(hole.width), self._convert_units_str(hole.height)]
        else:
            hole_mods = []
        mods += hole_mods

        # generate param
        mods = 'X'.join(str(m) for m in mods)
        mods_def = (mods and AP_MODS.format(mods=mods) or '')
        ap_def = APERTURE.format(code=aperture.code,
                                 type=type_,
                                 mods=mods_def)
        return LINE.format(ap_def)


    def _get_macro_ap_def(self, macro_aperture):
        """ Convert aperture based on core shapes to gerber. """
        ap_def = APERTURE.format(code=macro_aperture.code,
                                 type=macro_aperture.name,
                                 mods='')
        return LINE.format(ap_def)


    def _get_image_meta(self, image_idx, images):
        """ Generate layer params for the image layer. """
        image = images[image_idx]
        prev_additive = True
        if image_idx > 0:
            prev_additive = images[image_idx - 1].is_additive

        if image.name:
            meta = PARAM.format(name='LN',
                                val=image.name)
            yield LINE.format(meta)

        # Image.is_additive can only be set explicitly,
        # so we check the previous image layer.
        if image.is_additive:
            if not prev_additive:
                meta = PARAM.format(name='LP',
                                    val='D')
                yield LINE.format(meta)
        else:
            if prev_additive:
                meta = PARAM.format(name='LP',
                                    val='C')
                yield LINE.format(meta)

        # handle repetition of image layer
        if image.x_repeats > 1 or image.y_repeats > 1:
            val = SR_MODS.format(x=image.x_repeats,
                                 y=image.y_repeats,
                                 i=image.x_step,
                                 j=image.y_step)
            meta = PARAM.format(name='SR',
                                val=val)
            yield LINE.format(meta)


    def _gen_paths(self, image):
        """ Generate functions and coordinates. """
        for smear in image.smears:
            for block in self._gen_smear(smear):
                yield block
        for shin in image.shape_instances:
            for block in self._gen_shape_instance(shin):
                yield block
        for complex_instance in image.complex_instances:
            for block in self._gen_complex_instance(complex_instance):
                yield block
        if image.fills:
            for block in self._gen_fills(image.fills):
                yield block


    # secondary writer support methods

    def _add_shape_aperture(self, shape, hole):
        """ Generate D code and store aperture. """
        next_ap = len(self.apertures) + 10
        aperture = Aperture(next_ap, shape, hole)
        if aperture not in self.apertures:
            self.apertures.append(aperture)


    def _add_macro_aperture(self, complex_instance):
        """ Generate D code and store aperture. """
        next_ap = len(self.apertures) + 10
        aperture = MacroAperture(next_ap, complex_instance.name, complex_instance.primitives)
        if aperture not in self.apertures:
            self.apertures.append(aperture)


    def _gen_smear(self, smear):
        """ Smears are lines drawn with rect apertures. """
        select = self._select_shape_aperture(smear.shape, None)
        if select:
            yield LINE.format(select)
        for block in self._draw_seg(smear.line):
            yield LINE.format(block)


    def _gen_shape_instance(self, shin):
        """ A snapshot of an aperture or macro. """
        select = self._select_shape_aperture(shin.shape,
                                             shin.hole)
        if select:
            yield LINE.format(select)
        block = self._flash(shin.x, shin.y)
        yield LINE.format(block)


    def _gen_complex_instance(self, complex_instance):
        """ An instance of a complex collection of primitives. """
        select = self._select_macro_aperture(complex_instance)

        if select:
            yield LINE.format(select)
        block = self._flash(complex_instance.x, complex_instance.y)
        yield LINE.format(block)


    def _gen_fills(self, fills):
        """ Fills are defined by their line/arc outlines. """
        fill_mode_on = FUNCT.format(type='G', code='36')
        yield LINE.format(fill_mode_on)
        for fill in fills:
            # Move to the first point in the outline
            yield LINE.format(MOVE.format(x=self._fix(fill.outline_points[0].x),
                                          y=self._fix(fill.outline_points[0].y)))

            for point in fill.outline_points[1:]:
                yield LINE.format(PLOT.format(x=self._fix(point.x),
                                              y=self._fix(point.y)))
        fill_mode_off = FUNCT.format(type='G', code='37')
        yield LINE.format(fill_mode_off)


    def _select_shape_aperture(self, shape, hole):
        """ Change the current aperture if necessary. """
        selection = Aperture(None, shape, hole)
        if selection == self.status['aperture']:
            return None
        else:
            index = self.apertures.index(selection)
            self.status['aperture'] = self.apertures[index]
            return FUNCT.format(type='D',
                                code=self.status['aperture'].code)


    def _select_macro_aperture(self, complex_instance):
        """ Change the current aperture if necessary. """
        selection = MacroAperture(None, complex_instance.name, complex_instance.primitives)
        if selection == self.status['aperture']:
            return None
        else:
            index = self.apertures.index(selection)
            self.status['aperture'] = self.apertures[index]
            return FUNCT.format(type='D',
                                code=self.status['aperture'].code)


    def _draw_seg(self, seg):
        """ Define path for a line or arc. """
        init_draw = not self.status['interpolation']
        mq_mode = None
        if isinstance(seg, Arc):
            interpolate = self._interpolate('CLOCKWISE_CIRCULAR')
            start, end = seg.ends()

            # handle clockwise representation of anticlock arcs
            if Point(self.status['x'], self.status['y']) == end:
                interpolate = self._interpolate('ANTICLOCKWISE_CIRCULAR')
                end, start = seg.ends()

            i, j = (seg.x - start.x, seg.y - start.y)

            # further establish interpolation mode
            mq_mode = self._check_mq(seg)
            if not self.status['multi_quadrant']:
                i, j = (abs(i), abs(j))

            move = COORD_EXT.format(x=self._fix(end.x),
                                    y=self._fix(end.y),
                                    i=self._fix(i),
                                    j=self._fix(j))
        else:
            interpolate = self._interpolate('LINEAR')
            start, end = (seg.p1, seg.p2)
            move = COORD.format(x=self._fix(end.x),
                                y=self._fix(end.y))

        # move to the start point of a draw
        stealth_move = self._move_start(start)

        # reset draw mode after stealth move
        if stealth_move or init_draw:
            move = move.replace('*', 'D01*')

        # compile directives for drawing segment
        self.status['x'] = end.x
        self.status['y'] = end.y
        blocks = (mq_mode, interpolate, stealth_move, move)
        return (b for b in blocks if b)


    def _move_start(self, point):
        """ Move the 'photo plotter head' without 'drawing'. """
        loc = Point(self.status['x'], self.status['y'])
        return ((not loc == point) and
                MOVE.format(x=self._fix(point.x),
                               y=self._fix(point.y)))


    def _flash(self, x, y):
        """ Create a shape instance. """
        return FLASH.format(x=self._fix(x),
                            y=self._fix(y))


    def _interpolate(self, code):
        """ Change the interpolation setting if necessary. """
        if self.status['interpolation'] == code:
            return None
        else:
            self.status['interpolation'] = code
            return FUNCT.format(type='G', code=INTERPOLATION[code])


    # general methods

    def _fix(self, ord_):
        """ Convert a float ordinate according to spec. Adjust from the core units to the units of the file. """
        dec = self.coord_format['dec']
        spec = '{{0}}{{1:0<{0}}}'.format(dec)
        unit_ord_ = self._convert_units(ord_)
        padded_ord = spec.format(*str(round(unit_ord_, dec)).split('.'))
        return int(padded_ord) and padded_ord or '0'


    def _convert_units(self, num):
        """ Convert from the core units (nm) to those of the current gerber being written. """
        # FIXME(shamer): adjust to actual units of gerber, is hard coded to mm
        return (num / 1000000.0)


    def _convert_units_str(self, num):
        """ Convert from the core units (nm) to a string of those of the current gerber being written. """
        return ('%.10f' % self._convert_units(num)).rstrip('0')


    def _parse_units(self, unitstr):
        parts = unitstr.split(' ')
        num = float(parts[0])
        units = parts[1].lower()
        if units == 'in':
            return int(num * POS_UNITS_PER_IN)
        elif units == 'mm':
            return int(num * POS_UNITS_PER_MM)
        elif units == 'cm':
            return int(num * POS_UNITS_PER_CM)
        elif units == 'mil':
            return int(num * POS_UNITS_PER_MM)


    def _check_mq(self, seg):
        """ Set multi_quadrant mode on/off if necessary. """

        # handle arcs that traverse the 3 o'clock boundary
        if seg.end_angle <= seg.start_angle:
            seg.end_angle += 2

        mq_seg = seg.end_angle - seg.start_angle > 0.5
        code = None
        if mq_seg and not self.status['multi_quadrant']:
            self.status['multi_quadrant'] = True
            code = '75'
        elif self.status['multi_quadrant'] and not mq_seg:
            self.status['multi_quadrant'] = False
            code = '74'
        return code and FUNCT.format(type='G', code=code)


    def _check_design(self, design):
        """ Ensure the design contains the necessary information to generate a gerber. """
        #TODO: check fills for closure and self-intersection
        if not design.layer_options:
            raise NoLayersFound
        return True

        for layer in design.layout.layers:
            for image in layer.images:
                if not (image.traces or
                        image.fills or
                        image.smears or
                        image.shape_instances):
                    raise ImageContainsNoData(image.name)

########NEW FILE########
__FILENAME__ = image
#!/usr/bin/env python2
""" A crude image output writer, inspired by ajray's render.py """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from PIL import Image as Img, ImageDraw
from math import cos, sin, pi, sqrt, atan
from collections import defaultdict
from upconvert.core.shape import Point


class Image:
    """ encapsulates rendering options and provides the write() method """
    default_style = {'bground': (255, 255, 255),
                     'fground': (  0,   0,   0),
                     'net'    : (  0, 180,   0),
                     'annot'  : (140, 140, 140),
                     'part'   : (  0,   0,   0),
                    }


    def __init__(self, img_format='PNG', style={}, scale=1):
        # Override default style where the user provided some
        self.style = self.default_style
        self.style.update(style)
        self.scale = scale
        self.img_format = img_format


    def write(self, design, filename):
        """ create a worker and have it build and output the image """
        writer = Worker(design, self)
        writer.save(filename)



class Worker:
    """ Does the actual work of converting and saving an image """
    

    def __init__(self, design, options):
        self.design, self.options = design, options
        # Calculate the image size
        minpt, maxpt = self.design.bounds()
        width = int(maxpt.x - minpt.x)
        height = int(maxpt.y - minpt.y)

        # Setup image & design
        self.image = Img.new('RGB', (width * self.options.scale,
                                     height * self.options.scale),
                             self.options.style['bground'])
        self.canvas = ImageDraw.Draw(self.image)

        # Draw & save image
        self.base_xform = Scale(self.options.scale,
                                FixY(height, Shift(-minpt.x, -minpt.y)))
        self.draw_design()


    def save(self, filename):
        """ Save to a file """
        self.image.save(filename, self.options.img_format)


    def draw_design(self):
        """ Render the design into 2 images """
        if len(self.design.trace_segments) > 0:
            self.draw_layout()
        else:
            self.draw_schematic()


    def draw_schematic(self):
        """ Render the schematic into self.img """
        # start off with all the component instances
        for inst in self.design.component_instances:
            comp = self.design.components.components[inst.library_id]
            for body, attr in zip(comp.symbols[inst.symbol_index].bodies,
                                  inst.symbol_attributes):
                # draw the appropriate body, at the position in attr
                pos = Point(attr.x, attr.y)
                self.draw_symbol(body, pos, attr.rotation, attr.flip)
                # draw in any annotations
                for ann in attr.annotations:
                    if ann.visible:
                        pos = self.base_xform.chain(Point(ann.x, ann.y))
                        self.canvas.text((pos.x, pos.y), ann.value,
                                         fill=self.options.style['annot'])

        for shape in self.design.shapes:
            draw_method = getattr(self, 'draw_shape_%s' % shape.type)
            draw_method(shape, self.base_xform, self.options.style['annot'])

        for net in self.design.nets:
            self.draw_net(net)

        for ann in self.design.design_attributes.annotations:
            if ann.visible:
                pos = self.base_xform.chain(Point(ann.x, ann.y))
                self.canvas.text((pos.x, pos.y), ann.value,
                                  fill=self.options.style['annot'])


    def draw_layout(self):
        """ Render the layout into self.img """
        # start off with all the component instances
        for inst in self.design.component_instances:
            comp = self.design.components.components[inst.library_id]
            for body, attr in zip(comp.footprints[inst.footprint_index].bodies,
                                  inst.footprint_attributes):
                # draw the appropriate body, at the position in attr
                pos = Point(attr.x, attr.y)
                self.draw_footprint(body, pos, attr.rotation, attr.flip)
                # draw in any annotations
                for ann in attr.annotations:
                    if ann.visible:
                        pos = self.base_xform.chain(Point(ann.x, ann.y))
                        self.canvas.text((pos.x, pos.y), ann.value,
                                         fill=self.options.style['annot'])

        for trace in self.design.traces:
            self.draw_trace(trace)


    def draw_symbol(self, body, offset, rot, flip):
        """draw a symbol at the location of offset"""
        xform = self.base_xform.copy()
        # flip if necessary, then rotate the symbol, then shift.
        # Want to rotate before it's been moved away from the global origin.
        if flip:
            flipper = FlipY()
        else:
            flipper = XForm()

        locxform = Shift(offset.x, offset.y, Rotate(rot, flipper))
        xform.prefix(locxform)

        for shape in body.shapes:
            draw_method = getattr(self, 'draw_shape_%s' % shape.type)
            draw_method(shape, xform, self.options.style['part'])

        for pin in body.pins:
            self.draw_pin(pin, xform)


    def draw_footprint(self, body, offset, rot, flip):
        """draw a footprint at the location of offset"""
        xform = self.base_xform.copy()
        # flip if necessary, then rotate the footprint, then shift.
        # Want to rotate before it's been moved away from the global origin.
        if flip:
            flipper = FlipY()
        else:
            flipper = XForm()

        locxform = Shift(offset.x, offset.y, Rotate(rot, flipper))
        xform.prefix(locxform)

        for shape in body.shapes:
            draw_method = getattr(self, 'draw_shape_%s' % shape.type)
            draw_method(shape, xform, self.options.style['part'])

        for pad in body.pads:
            self.draw_pad(pad, xform)


    def draw_net(self, net):
        """ draw out a net """
        # need a second dict so that removing nets as they are drawn does
        # not affect the actual design object.
        connects = dict([(pt.point_id, list(pt.connected_points))
                         for pt in net.points.values()])
        for pid, connlist in connects.items():
            pidpt = self.base_xform.chain(net.points[pid])
            for junc in connlist:
                juncpt = self.base_xform.chain(net.points[junc])
                # draw a line to each connected point from this junction
                self.canvas.line([(pidpt.x, pidpt.y),
                                  (juncpt.x, juncpt.y)],
                                 fill=self.options.style['net'])
                # don't need the connected point to draw a line back
                connects[junc].remove(pid)
                # TODO draw the connection to the component pin
                #      (may actually be done)

        for pt in net.points.values():
            if self.dot_at(pt, net):
                drawpt = self.base_xform.chain(pt)
                # arbitrarily, drawing the dot 4x the minimum dimension in the 
                # design + 1 pixel.
                scale = self.options.scale * 2
                # draw the actual solder dot
                self.canvas.ellipse((drawpt.x - scale, drawpt.y - scale,
                                     drawpt.x + scale, drawpt.y + scale),
                                     outline=self.options.style['net'],
                                     fill=self.options.style['net'])

        for ann in net.annotations:
            pos = self.base_xform.chain(Point(ann.x, ann.y))
            self.canvas.text((pos.x, pos.y), ann.value,
                             fill=self.options.style['annot'])


    def draw_trace(self, trace):
        """ draw out a trace """
        pts = [xform.chain(p) for p in (trace.p1, trace.p2)]
        self.canvas.line([(p.x, p.y) for p in pts], fill=colour)


    def dot_at(self, pt, net):
        """ return True if a solder dot is required at pt on net """
        if len(pt.connected_points) + len(pt.connected_components) < 3:
            # definitely not a solder dot, so don't try harder
            return False
        lines = defaultdict(list)
        for pid in pt.connected_points:
            connpt = net.points[pid]
            if pt.x == connpt.x:
                # case of a pt connected to itself falls through the cracks
                # here, as is appropriate. Not sure why it would happen, but if
                # it does it doesn't make any difference as to whether to draw a
                # solder dot or no
                if pt.y != connpt.y:
                    # infinite slope
                    lines[None].append(connpt)
            else:
                slope = float(connpt.y - pt.y) / (connpt.x - pt.x)
                lines[slope].append(connpt)

        spokes = 0
        for slope, pts in lines.items():
            # figure out which axis to compare along
            if slope is None:
                # actually, this means infinite slope
                axis = lambda p: p.y
            else:
                axis = lambda p: p.x

            pts.sort(key=axis)
            if axis(pts[0]) < axis(pt):
                # there is at least one connected point "lower" along this slope
                spokes += 1
            if axis(pts[-1]) > axis(pt):
                # there is at least one connected point "higher" along the slope
                spokes += 1

        return (spokes + len(pt.connected_components)) > 2


    def draw_shape_circle(self, circle, xform, colour):
        """ draw a circle """
        minpt, maxpt = [xform.chain(p) for p in circle.bounds()]
        xs, ys = [minpt.x, maxpt.x], [minpt.y, maxpt.y]
        # draw.ellipse gets confused if x1 > x0 or y1 > y0
        self.canvas.ellipse((min(xs), min(ys), max(xs), max(ys)),
                            outline=colour)


    def draw_shape_line(self, line, xform, colour):
        """ draw a line segment """
        pts = [xform.chain(p) for p in (line.p1, line.p2)]
        self.canvas.line([(p.x, p.y) for p in pts], fill=colour)


    def draw_shape_polygon(self, poly, xform, colour):
        """ draw a multi-segment polygon """
        pts = [xform.chain(p) for p in poly.points]
        self.canvas.polygon([(p.x, p.y) for p in pts], outline=colour)


    def draw_shape_arc(self, arc, xform, colour):
        """ draw an arc segment """
        x, y, r = arc.x, arc.y, arc.radius
        # if the arc segment were extended to draw a full circle, box would
        # enclose that circle
        minpt, maxpt = [xform.chain(Point(px, py)) for (px, py)
                        in [(x - r, y - r), (x + r, y + r)]]
        xs, ys = [minpt.x, maxpt.x], [minpt.y, maxpt.y]
        box = (min(xs), min(ys), max(xs), max(ys))

        center = xform.chain(Point(x, y))

        def pt_to_deg(pt):
            # given a point, give the angle w.r.t. to the xform'd center of the
            # arc (ie. where it will be when drawn)
            # 3 o'clock is angle of 0, angles increase clockwise
            opp, adj = pt.y - center.y, pt.x - center.x
            if adj == 0:
                if opp > 0:
                    return 90
                return 270
            angle = 180 * atan(opp / float(adj)) / pi
            if pt.x < center.x:
                angle += 180
            return int(angle % 360)

        # create a point in the middle of the arc (used to detect that the xform
        # has flipped the arc around. In that case, drawing from start_angle to
        # end_angle will go in the wrong direction, and draw out exactly the
        # wrong part of the circle)
        mid_ang = (arc.start_angle + arc.end_angle) / 2
        if arc.start_angle > arc.end_angle:
            mid_ang = (mid_ang - 1) % 2
        mid_pt = xform.chain(Point(cos((2 - mid_ang) * pi) * arc.radius + x,
                                   sin((2 - mid_ang) * pi) * arc.radius + y))

        start, end = [xform.chain(pt) for pt in arc.ends()]
        if pt_to_deg(start) < pt_to_deg(end):
            if not (pt_to_deg(start) < pt_to_deg(mid_pt) <  pt_to_deg(end)):
                # swap start and end so that the arc traces through the
                # transformed midpoint
                start, end = end, start
        elif (pt_to_deg(end) < pt_to_deg(mid_pt) < pt_to_deg(start)):
            # swap start and end so that the arc traces through the
            # transformed midpoint
            start, end = end, start

        # by using the arc.ends() points, any rotation in xform gets handled
        # properly.
        self.canvas.arc(box, pt_to_deg(start), pt_to_deg(end), fill=colour)


    def draw_shape_rectangle(self, rect, xform, colour):
        """ draw a rectangle """
        # use polygon-style, so it'll handle rotated rectangles
        pts = [Point(p) for p in [(rect.x, rect.y),
                                  (rect.x + rect.width, rect.y),
                                  (rect.x + rect.width, rect.y - rect.height),
                                  (rect.x, rect.y - rect.height)]]
        pts = [xform.chain(p) for p in pts]
        self.canvas.polygon([(p.x, p.y) for p in pts], outline=colour)


    def draw_shape_rounded_rectangle(self, rect, xform, colour):
        """ draw a rectangle, eventually with rounded corners """
        for shape in rect.as_arcs_lines():
            getattr(self, 'draw_shape_%s' % shape.type)(shape, xform, colour)


    def draw_shape_label(self, label, xform, colour):
        """ draw a text label """
        #TODO deal with alignment, rotation
        pos = xform.chain(Point(label.x, label.y))
        self.canvas.text((pos.x, pos.y), label.text, fill=colour)


    def draw_shape_bezier(self, bez, xform, colour):
        """ draw a bezier curve """
        # hasn't really been tested properly, but seems okay
        # calculate maximum path length as straight lines between each point,
        # then double it, and use that to decide t step size
        pts = [xform.chain(p) for p in [bez.point1, bez.control1,
                                        bez.control2, bez.point2]]
        maxpath = sum([sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2)
                       for (p1, p2) in zip(pts, pts[1:])]) * 2
        dt = 1. / maxpath
        p0, p1, p2, p3 = pts
        # textbook Bezier interpolation
        Bx = lambda t: int(    (1-t)**3        * p0.x +
                           3 * (1-t)**2 * t    * p1.x +
                           3 * (1-t)    * t**2 * p2.x +
                                          t**3 * p3.x)
        By = lambda t: int(    (1-t)**3        * p0.y +
                           3 * (1-t)**2 * t    * p1.y +
                           3 * (1-t)    * t**2 * p2.y +
                                          t**3 * p3.y)

        for i in xrange(0, int(1./dt)):
            self.canvas.point((Bx(i * dt), By(i * dt)), fill=colour)
        # make sure to draw in the endpoint
        self.canvas.point((Bx(1.), By(1.)), fill=colour)


    def draw_pin(self, pin, xform):
        """ draw a component's pin """
        # TODO special pin characteristics (inverted, clock)?
        line = [xform.chain(p) for p in (pin.p1, pin.p2)]
        self.canvas.line([(p.x, p.y) for p in line],
                         fill=self.options.style['part'])



class XForm(object):
    """ Transformations operate on a Point, can also be chained. """
    def __init__(self, prev=None):
        """ Create a transformation.
        prev is an optional transformation to append this one to. """
        self.prev = prev


    def chain(self, pt):
        """ Apply all the transformations, one after the other. """
        if self.prev is not None:
            pt = self.prev.chain(pt)
        return self.convert(pt)


    def convert(self, pt):
        """ Apply just this transformation. """
        # default transformation is to do nothing
        return pt


    def prefix(self, xform):
        """ Put another transformation at the start of this chain. """
        tail = self
        while tail.prev != None:
            tail = tail.prev
        tail.prev = xform


    def copy(self):
        """ A deep copy of the xform chain, from the first XForm to here """
        cprev = None
        if self.prev is not None:
            cprev = self.prev.copy()
        return self._copy(cprev)


    def _copy(self, previous):
        """ A copy of just this transformation, appended to `previous` """
        return XForm(previous)



class Shift(XForm):
    """ Simple shift in cartesian coordinates """
    def __init__(self, dx, dy, prev=None):
        """ A transformation that shifts Points by (dx, dy). """
        XForm.__init__(self, prev)
        self.dx, self.dy = dx, dy


    def convert(self, pt):
        return Point(pt.x + self.dx,
                     pt.y + self.dy)


    def _copy(self, previous):
        return Shift(self.dx, self.dy, previous)



class Rotate(XForm):
    """ Rotation around the origin """
    def __init__(self, theta, prev=None):
        """ A transformation that will rotate a Point theta*pi rads CW. """
        XForm.__init__(self, prev)
        self.theta = theta * -pi


    def convert(self, pt):
        cos_t, sin_t = cos(self.theta), sin(self.theta)
        return Point(int(round(cos_t * pt.x - sin_t * pt.y)),
                     int(round(sin_t * pt.x + cos_t * pt.y)))


    def _copy(self, previous):
        return Rotate(self.theta, previous)



class Scale(XForm):
    """ Linear scaling """
    def __init__(self, scale, prev=None):
        XForm.__init__(self, prev)
        self.scale = scale


    def convert(self, pt):
        return Point(int(pt.x * self.scale), int(pt.y * self.scale))


    def _copy(self, previous):
        return Scale(self.scale, previous)



class FixY(XForm):
    """ Compensate for difference in origin between upverter and PIL """
    def __init__(self, ymax, prev=None):
        """ Will transform Points from bottom-left origin to top-left origin """
        XForm.__init__(self, prev)
        self.ymax = ymax


    def convert(self, pt):
        return Point(pt.x, self.ymax - pt.y)


    def _copy(self, previous):
        return FixY(self.ymax, previous)



class FlipY(XForm):
    """ Flips a point around the y-axis """
    def convert(self, pt):
        return Point(-pt.x, pt.y)


    def _copy(self, previous):
        return FlipY(previous)

########NEW FILE########
__FILENAME__ = kicad
#!/usr/bin/env python2
""" The KiCAD Format Writer """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Basic Strategy
# 0) converted file will be store in subdirectory
# 1) create subdirectory, symbol and project file
# 2) Write each component into a .sym file (even EMBEDDED components)
# 3) Write component instances to .sch file
# 4) Store net segments at the end of .sch file

# Note: in a KiCAD schematic, the y coordinates increase downwards. In
# OpenJSON, y coordinates increase upwards, so we negate them. In the
# KiCAD library file (where components are stored) y coordinates
# increase upwards as in OpenJSON and no transformation is needed.


import time

from os.path import splitext

from upconvert.core.shape import Shape
from upconvert.parser.kicad import MATRIX2ROTATIONFLIP, MULT as INMULT

ROTATIONFLIP2MATRIX = dict((v, k) for k, v in MATRIX2ROTATIONFLIP.items())


class KiCAD(object):
    """ The KiCAD Format Writer """

    def write(self, design, filename, library_filename=None):
        """ Write the design to the KiCAD format """

        if library_filename is None:
            library_filename = splitext(filename)[0] + '-cache.lib'

        self.write_library(design, library_filename)

        with open(filename, "w") as f:
            self.write_header(f, design)
            self.write_libs(f, library_filename)
            self.write_eelayer(f)
            self.write_descr(f, design)
            for ann in design.design_attributes.annotations:
                self.write_annotation(f, ann)
            for inst in design.component_instances:
                self.write_instance(f, inst)
            for net in design.nets:
                self.write_net(f, net)
            self.write_footer(f)


    def write_header(self, f, design):
        """ Write a kiCAD schematic file header """
        f.write('EESchema Schematic File Version 2  date ')
        self.write_header_date(f, design)


    def write_header_date(self, f, design):
        """ Write the date portion of a kiCAD schematic header """
        bdt = time.localtime(design.design_attributes.metadata.updated_timestamp)
        f.write(time.strftime('%a %d %b %Y %H:%M:%S %p ', bdt))
        if time.daylight and bdt.tm_isdst:
            f.write(time.tzname[1])
        else:
            f.write(time.tzname[0])
        f.write('\n')


    def write_libs(self, f, library_filename):
        """ Write the LIBS section of a kiCAD schematic """
        f.write('LIBS:%s\n' % (splitext(library_filename)[0],))


    def write_eelayer(self, f):
        """ Write the EELAYER block of a kiCAD schematic """
        f.write('EELAYER 25  0\n')
        f.write('EELAYER END\n')


    def write_descr(self, f, design):
        """ Write the description block of a kiCAD schematic """
        bdt = time.localtime(design.design_attributes.metadata.updated_timestamp)
        datestr = time.strftime('%d %b %Y', bdt).lower()
        f.write('''\
$Descr A4 11700 8267
encoding utf-8
Sheet 1 1
Title ""
Date "%s"
Rev ""
Comp ""
Comment1 ""
Comment2 ""
Comment3 ""
Comment4 ""
$EndDescr
''' % (datestr,))


    def write_annotation(self, f, ann):
        """ Write a design annotation to a kiCAD schematic """
        f.write('Text Label %d %d %d 60 ~ 0\n' %
                (make_length(ann.x), -make_length(ann.y),
                 int(ann.rotation * 1800)))
        f.write(ann.value.encode('utf-8') + '\n')

    def write_instance(self, f, inst):
        """ Write a $Comp component to a kiCAD schematic """
        f.write('$Comp\n')
        f.write('L %s %s\n' % (inst.library_id, inst.instance_id))
        f.write('U %d 1 00000000\n' % (inst.symbol_index,))
        f.write('P %d %d\n' % (make_length(inst.symbol_attributes[0].x),
                               -make_length(inst.symbol_attributes[0].y)))
        for i, ann in enumerate(inst.symbol_attributes[0].annotations):
            f.write('F %d "%s" %s %d %d 60  0000 C CNN\n' %
                    (i, ann.value.encode('utf-8'),
                     'H' if ann.rotation == 0 else 'V',
                     make_length(inst.symbol_attributes[0].x + ann.x),
                     -make_length(inst.symbol_attributes[0].y + ann.y)))
        f.write('\t1    %d %d\n' % (make_length(inst.symbol_attributes[0].x),
                                    -make_length(inst.symbol_attributes[0].y)))
        f.write('\t%d    %d    %d    %d\n' %
                ROTATIONFLIP2MATRIX[(inst.symbol_attributes[0].rotation % 2, inst.symbol_attributes[0].flip)])
        f.write('$EndComp\n')


    def write_net(self, f, net):
        """ Write a Net as kiCAD Wires and Connections """
        segments = set() # ((x,y),(x,y))

        for point in net.points.values():
            for point2_id in point.connected_points:
                point2 = net.points.get(point2_id)
                if point2 is not None:
                    seg = [(point.x, point.y), (point2.x, point2.y)]
                    seg.sort() # canonical order
                    segments.add(tuple(seg))

        for seg in sorted(segments):
            f.write('Wire Wire Line\n')
            f.write('\t%d %d %d %d\n' % (make_length(seg[0][0]),
                                         -make_length(seg[0][1]),
                                         make_length(seg[1][0]),
                                         -make_length(seg[1][1])))


    def write_footer(self, f):
        """ Write the kiCAD schematic footer """
        f.write('$EndSCHEMATC\n')


    def write_library(self, design, filename):
        """ Write out a kiCAD cache library to the given filename """
        with open(filename, 'w') as f:
            self.write_library_header(f, design)
            for cpt in design.components.components.iteritems():
                self.write_library_component(f, cpt)
            self.write_library_footer(f)


    def write_library_header(self, f, design):
        """ Write the header line for a kiCAD cache library """
        f.write('EESchema-LIBRARY Version 2.3  Date: ')
        self.write_header_date(f, design)
        f.write('#encoding utf-8\n')


    def write_library_component(self, f, cpt):
        """ Write a single component to a kiCAD cache library """
        cpt_name, cpt = cpt
        ref = cpt.attributes.get('_prefix', 'U').encode('utf-8')
        name = cpt_name.replace(' ', '')
        name = name.encode('utf-8')
        f.write('#\n')
        f.write('# ' + name + '\n')
        f.write('#\n')
        f.write('DEF %s %s 0 30 Y Y %d F N\n' %
                (name, ref, len(cpt.symbols[0].bodies)))
        f.write('F0 "%s" 0 0 60 H V L CNN\n' % (ref,))
        f.write('F1 "%s" 0 60 60 H V L CNN\n' % (name,))
        self.write_symbols(f, cpt.symbols)
        f.write('ENDDEF\n')


    def write_symbols(self, f, symbols):
        """ Write the DRAW portion (shapes and pins) of a kiCAD
        component symbol """
        f.write('DRAW\n')

        lines = {} # obj -> (order, line, symbol,
                   #         set([units]), set([converts]))

        def add_line(obj, symbol, unit, convert):
            """ Add a line with a given symbol, unit and convert """
            if obj not in lines:
                order = (0 if isinstance(obj, Shape) else 0,
                         add_line.next_index)
                add_line.next_index += 1
                lines[obj] = (order, self.get_line(obj), symbol, set(), set())
            lines[obj][3].add(unit)
            lines[obj][4].add(convert)

        add_line.next_index = 0 # for sorting

        for convert, symbol in enumerate(symbols[:2], 1):
            for unit, body in enumerate(symbol.bodies, 1):
                for shape in body.shapes:
                    add_line(shape, symbol, unit, convert)

                for pin in body.pins:
                    if pin.label is not None:
                        pin.label.text = pin.label.text.replace(' ', '')
                    add_line(pin, symbol, unit, convert)

        for _, line, symbol, units, converts in sorted(lines.values()):
            for body in symbol.bodies:
                for pin in body.pins:
                    if pin.label is not None:
                        pin.label.text = pin.label.text.replace(' ', '')
            if len(units) == len(symbol.bodies):
                units = (0,)
            if len(converts) == 2:
                converts = (0,)
            for unit in units:
                for convert in converts:
                    writeline = line % dict(unit=unit, convert=convert)
                    f.write(writeline.encode('utf-8'))

        f.write('ENDDRAW\n')

    def get_line(self, obj):
        """ Return the line for a pin or a shape. """
        if isinstance(obj, Shape):
            return self.get_shape_line(obj)
        else:
            return self.get_pin_line(obj)

    def get_shape_line(self, shape):
        """ Return the line for a Shape in a kiCAD cache library """
        if shape.type == 'arc':
            # convert pi radians to tenths of degrees
            start = round(shape.start_angle * 1800)
            end = round(shape.end_angle * 1800)
            return ('A %d %d %d %d %d %%(unit)d %%(convert)d 0 N\n' %
                    (make_length(shape.x), make_length(shape.y),
                     make_length(shape.radius), end, start))
        elif shape.type == 'circle':
            return ('C %d %d %d %%(unit)d %%(convert)d 0 N\n' %
                    (make_length(shape.x), make_length(shape.y),
                     make_length(shape.radius)))
        elif shape.type == 'line':
            return ('P 2 %%(unit)d %%(convert)d 0 %d %d %d %d N\n' %
                    (make_length(shape.p1.x), make_length(shape.p1.y),
                     make_length(shape.p2.x), make_length(shape.p2.y)))
        elif shape.type == 'polygon':
            points = list(shape.points)
            if points[0] != points[-1]:
                points.append(points[0]) # close the polygon
            return ('P %d %%(unit)d %%(convert)d 0 %s N\n' %
                    (len(points),
                     ' '.join('%d %d' % (make_length(p.x), make_length(p.y))
                              for p in points)))
        elif shape.type == 'rectangle':
            return ('S %d %d %d %d %%(unit)d %%(convert)d 0 N\n' %
                    (make_length(shape.x), make_length(shape.y),
                     make_length(shape.x + shape.width),
                     make_length(shape.y - shape.height)))
        elif shape.type == 'label':
            angle = round(shape._rotation * 1800)
            align = shape.align[0].upper()
            return ('T %d %d %d 20 0 %%(unit)d %%(convert)d %s Normal 0 %s C\n' %
                    (angle, make_length(shape.x), make_length(shape.y),
                     shape.text.replace(' ', '~'), align))
        elif shape.type == 'bezier':
            return ('P 2 %%(unit)d %%(convert)d 0 %s N\n' %
                    (' '.join('%d %d' % (make_length(p.x), make_length(p.y))
                              for p in (shape.p1, shape.p2))))


    def get_pin_line(self, pin):
        """ Return the line for a Pin in a kiCAD cache library """
        x, y = pin.p2.x, pin.p2.y

        if x == pin.p1.x: # vertical
            length = y - pin.p1.y
            if length > 0:
                direction = 'D' # down
            else:
                direction = 'U' # up
        else:
            length = x - pin.p1.x
            if length > 0:
                direction = 'L' # left
            else:
                direction = 'R' # right

        if pin.label is None:
            name = '~'
        else:
            name = pin.label.text

        return ('X %s %s %d %d %d %s 60 60 %%(unit)d %%(convert)d B\n' %
                (name, pin.pin_number, make_length(x), make_length(y),
                 make_length(abs(length)), direction))


    def write_library_footer(self, f):
        """ Write a kiCAD library file footer """
        f.write('#\n#End Library\n')


MULT = 1.0 / INMULT

def make_length(value):
    """ Make a kicad length measurement from an openjson measurement """
    return int(round(float(value) * MULT))

########NEW FILE########
__FILENAME__ = ncdrill
#!/usr/bin/env python2
""" The NC drill/ICP-NC-349 Format Writer """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from sys import stdout
from os import path, mkdir, listdir, makedirs, stat
from shutil import rmtree
import logging

from upconvert.core.component_instance import FootprintPos
from upconvert.core.shape import Circle, Point, Line


log = logging.getLogger('writer.ncdrill')


# exceptions

class Unwritable(ValueError):
    """ Parent class for all gerber writer errors. """
    pass


# constants
#
# http://www.excellon.com/manuals/program.htm


LINE = '{0}\r\n'
REWIND_AND_STOP = '%'
TOOL_SELECT = 'T{code}'
END_FILE = 'M30'
END_FILE_OTHER = 'M00'
UNLOAD_TOOL = 'T00'
START_PATTERN = 'M25'
START_PATTERN_OTHER = 'M31'
END_PATTERN = 'M01'
LOCATION = 'X{x}Y{y}'
REPEAT_PATTERN = 'M02X{x}Y{y}'
MULTI_REPEAT_PATTERN = 'R{num}M02X{x}Y{y}'
SWAP_AXIS = 'M02X{x}Y{y}M70'
MIRROR_IMAGE_X_AXIS = 'M02X{x}Y{y}M80'
MIRROR_IMAGE_y_AXIS = 'M02X{x}Y{y}M90'
END_STEP_REPEAT = 'M08'
BLOCK_SEQUENCE_NUM = 'N{seq_num}'
BLOCK_DELETE = '/'
REPEAT_HOLE = 'R{num}X{x}Y{y}'
SELECT_DRILL_MODE = 'G05'
SELECT_DRILL_MODE_OTHER = 'G81'
VARIABLE_DWELL = 'G04X{x}' # ignored
ABSOLUTE_MODE = 'G90'
INCREMENTAL_MODE = 'G91'
SET_ZERO = 'G92X{x}Y{y}'
SET_ZERO_OTHER = 'G93X{x}Y{y}'
PROGRAM_HEADER_TO_FIRST_REWIND = 'M48'
OPERATOR_MESSAGE_CRT_DISPLAY = 'M47'
METRIC_MODE = 'M71'
IMPERIAL_MODE = 'M72'
SPINDLE_SPEED = 'S{rpm}'
Z_AZIS_FEED_SPEED = 'F{IPM}'
FORMAT_VERSION = 'FMAT,{ver}'
IMPERIAL_UNITS_LEADING_ZERO = 'M72,TZ'
METRIC_UNITS_LEADING_ZERO = 'M71,TZ'  # also seen as METRIC,TZ

TOOL_DEFINITION = 'T{code}C{diameter}'
TOOL_DEFINITION_SPEED = 'T{code}C{diameter}F{infeed}S{krpm}'


class Hole:
    def __init__(self, shape):
        self.shape = shape
        self.locations = []

# writer

class NCDrill:
    """ The Gerber Format Writer. """

    def __init__(self):
        self.coord_format = None
        self._reset()

    def _reset(self):
        # Map of holes keyed by radius
        self._holes = {}
        self.status = {'x':0,
                       'y':0,
                       'units':None,
                       'incremental_coords':None}


    def write(self, design, outfile_name=None):
        """ Entry point for producing a NC Drill file. """
        log.debug('starting NC Drill file write to %s', outfile_name)
        if outfile_name:
            dir_ = path.dirname(outfile_name)
            if dir_:
                try:
                    stat(dir_)
                except OSError:
                    makedirs(dir_)

        self._define_tools(design)

        with outfile_name and open(outfile_name, 'w') or stdout as f:
            self._write_header(design, f)
            self._write_body(f)

    def _add_hole(self, parent_attr, body_attr, shape):
        if not isinstance(shape, Circle):
            log.error('holes must be circular, found %s', shape)
            return
            #raise Unwritable('all holes must be circular')

        pos = Point(shape.x, shape.y)
        pos.shift(body_attr.x, body_attr.y)
        if parent_attr:
            if parent_attr.rotation != 0:
                pos.rotate(parent_attr.rotation)
            if parent_attr.flip_horizontal:
                pos.flip(parent_attr.flip_horizontal)
            pos.shift(parent_attr.x, parent_attr.y)

        if body_attr.rotation != 0:
            if parent_attr and parent_attr.flip_horizontal:
                pos.rotate(-body_attr.rotation, in_place=True)
            else:
                pos.rotate(body_attr.rotation, in_place=True)
        if body_attr.flip_horizontal:
            shape.flip(body_attr.flip_horizontal)

        log.debug('adding %d hole at %d, %d', shape.radius * 2, pos.x, pos.y)
        if shape.radius not in self._holes:
            self._holes[shape.radius] = Hole(shape)
        self._holes[shape.radius].locations.append(pos)


    def _define_tools(self, design):
        log.debug('building tool list for holes layer')
        hole_layer = 'hole'

        # Skipping segments, no holes

        # Generated objects in the design (vias, PTHs)
        log.debug('design generated objects')
        zero_pos = FootprintPos(0, 0, 0.0, False, 'top')
        for gen_obj in design.layout_objects:
            # XXX(shamer): body attr is only being used to hold the layer, other placement details are contained
            # elsewhere
            for body_attr, body in gen_obj.bodies(zero_pos, {}):
                if body_attr.layer == hole_layer:
                    for shape in body.shapes:
                        self._add_hole(None, body_attr, shape)

        # Component instance aspects
        log.debug('component instances')
        for component_instance in design.component_instances:
            component = design.components.components[component_instance.library_id]
            footprint_pos = component_instance.footprint_pos
            # Skip unplaced footprints
            if footprint_pos.side is None:
                continue

            for idx, footprint_attr in enumerate(component_instance.footprint_attributes):
                log.debug('footprint pos: %s, side %s, flip %s', footprint_attr.layer, footprint_pos.side, footprint_pos.flip_horizontal)
                if footprint_attr.layer:
                    footprint_attr.layer = footprint_attr.layer.replace('top', footprint_pos.side)
                if footprint_attr.layer == hole_layer:
                    footprint_body = component.footprints[component_instance.footprint_index].bodies[idx]
                    log.debug('adding footprint attribute: %s, %d shapes', footprint_attr, len(footprint_body.shapes))
                    for shape in footprint_body.shapes:
                        self._add_hole(footprint_pos, footprint_attr, shape)

            for idx, gen_obj_attr in enumerate(component_instance.gen_obj_attributes):
                gen_obj = component.footprints[component_instance.footprint_index].gen_objs[idx]
                # FIXME(shamer): check for unplaced generated objects.

                # XXX(shamer): body attr is only being used to hold the layer, other placement details are contained
                # elsewhere
                for body_attr, body in gen_obj.bodies(footprint_pos, gen_obj_attr.attributes):
                    if body_attr.layer == hole_layer:
                        log.debug('adding body for generated object: %s, %s', footprint_pos, gen_obj_attr)
                        for shape in body.shapes:
                            self._add_hole(footprint_pos, body_attr, shape)

    def _write_header(self, design, out_file):
        # Write out the file settings
        out_file.write(LINE.format(PROGRAM_HEADER_TO_FIRST_REWIND))
        out_file.write(LINE.format(METRIC_UNITS_LEADING_ZERO))
        out_file.write(LINE.format(FORMAT_VERSION.format(ver=2)))

        # Define tools used and assign codes
        hole_count = 1 # tool count starts at 1, 00 us used for 'unload'
        for hole_key, hole in self._holes.items():
            diameter = self._convert_units(hole.shape.radius * 2)
            hole.code = hole_count
            hole_count += 1
            out_file.write(LINE.format(TOOL_DEFINITION.format(code=hole.code, diameter=diameter)))
        out_file.write(LINE.format(REWIND_AND_STOP))

    def _write_body(self, out_file):
        """ Write all of the locations for the holes. """

        for hole_key, hole in self._holes.items():
            out_file.write(LINE.format(TOOL_SELECT.format(code=hole.code)))
            for pos in hole.locations:
                out_file.write(LINE.format(LOCATION.format(x=self._convert_units(pos.x), y=self._convert_units(pos.y))))

        # tidy up
        out_file.write(LINE.format(UNLOAD_TOOL))
        out_file.write(LINE.format(END_FILE))

    def _convert_units(self, num):
        """ Convert from the core units (nm) to those of the current gerber being written. """
        # FIXME(shamer): adjust to actual units of gerber, is hard coded to mm
        return num / 1000000.0

########NEW FILE########
__FILENAME__ = netlist_csv
#!/usr/bin/env python2
""" The Netlist Format Writer """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


class Netlist(object):
    """ The Netlist Format Writer """

    def write(self, design, filename):
        """ Write the design to the Netlist format """

        nets = {}
        for net in design.nets:
            endpoints = []
            for point in net.points.values():
                for connect in point.connected_components:
                    endpoints.append('%s.%s' % (connect.instance_id, connect.pin_number))

            if net.net_id in nets:
                nets[net.net_id]['endpoints'].extend(endpoints)
            else:
                nets[net.net_id] = {'name': net.net_id,
                                  'endpoints': endpoints}

        with open(filename, "w") as f:
            f.write('Name,Connections\n')
            for net in nets.values():
                if len(net['endpoints']) > 0:
                    f.write('%s:%s\n' % (net['name'], ','.join(net['endpoints'])))

########NEW FILE########
__FILENAME__ = netlist_telesis
#!/usr/bin/env python2
""" The Telesis Format Writer """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


class Telesis(object):
    """ The Telesis Format Writer """

    def write(self, design, filename):
        """ Write the design to the Telesis format """

        with open(filename, "w") as f:
            f.write('Telesis netlist export is currently unsupported')
            design = design

########NEW FILE########
__FILENAME__ = openjson
#!/usr/bin/env python2
""" The Open JSON Format Writer """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Basic Strategy
# 0) 1:1 Output of the data model


import json


class JSON:
    """ The JSON Format Writer """

    def write(self, design, filename):
        """ Recursively ask for JSON forms of components for output """
        with open(filename, "w") as f:
            f.write(json.dumps(design.json(), sort_keys=True, indent=4))

########NEW FILE########
__FILENAME__ = specctra
#!/usr/bin/env python2

""" The Specctra DSN Format Writer """

# upconvert - A universal hardware design file format converter using
# Format: upverter.com/resources/open-json-format/
# Development: github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.parser import specctraobj 
import math


_PIN = 'pin0'

class Specctra(object):
    """ The Specctra (DSN) Format Writer """

    def __init__(self):
        self.resolution = None
        self.max_x = 0
        self.max_y = 0
        self.min_x = 0
        self.min_y = 0
        self.max_offset = 0
        self.pcb = None

    def write(self, design, filename):
        """ Write the design to the Specctra format """
        self._convert(design)

        with open(filename, "w") as f:
            f.write(self._to_string(self.pcb.compose()))

    def _make_layer(self, name, index):
        """ Make a layer """
        layer = specctraobj.Layer()
        layer.layer_id = name 
        layer.ltype = specctraobj.Type()
        layer.ltype.value = 'signal'
        layer.lproperty = specctraobj.Property()
        layer.lproperty.index = specctraobj.Index()
        layer.lproperty.index.value = index
        return layer

    def _make_pcb(self, design):
        """ Make a pcb """
        pcb = specctraobj.Pcb()
        pcb.library = specctraobj.Library()
        pcb.placement = specctraobj.Placement()
        pcb.network = specctraobj.Network()
        pcb.wiring = specctraobj.Wiring()
        pcb.parser.host_cad = specctraobj.HostCad()
        pcb.parser.host_cad.value = design.version.get('exporter')
        pcb.parser.host_version = specctraobj.HostVersion()
        pcb.parser.host_version.value = design.version.get('file_version')

        pcb.resolution = specctraobj.Resolution()
        pcb.resolution.unit = 'mil'
        pcb.resolution.resolution = 10
        self.resolution = pcb.resolution

        pcb.unit = specctraobj.Unit()
        pcb.unit.value = 'mil'
        return pcb
 
    def _convert(self, design):
        """ Convert """
        self.pcb = self._make_pcb(design)

        self._make_pin(_PIN)

        for library_id, cpt in design.components.components.items():
            self._convert_component(library_id, cpt)

        for inst in design.component_instances:
            cpt_inst = self._convert_component_instance(inst)
            self.pcb.placement.component.append(cpt_inst)

        for net in design.nets:
            self._convert_net(net)

        self.pcb.structure = self._make_structure()

    def _convert_component_instance(self, inst):
        """ Convert an instance """
        component = specctraobj.Component()
        component.image_id = inst.library_id + '-' + str(inst.symbol_index)
        component.place = specctraobj.Place()
        component.place.component_id = inst.instance_id
        symbattr = inst.symbol_attributes[0]
        mirror = {0.5:1.5, 1.5:0.5}
        component.place.rotation = int(mirror.get(symbattr.rotation,  symbattr.rotation) * 180)
        component.place.vertex = self._from_pixels_abs((symbattr.x, symbattr.y))
        return component

    def _make_structure(self):
        """ Make a structure """
        structure = specctraobj.Structure()
        boundary = specctraobj.Boundary()
        boundary.rectangle = specctraobj.Rectangle()
        boundary.rectangle.layer_id = 'pcb'
        boundary.rectangle.vertex1 = (self.min_x - self.max_offset, self.min_y - self.max_offset)
        boundary.rectangle.vertex2 = (self.max_x + self.max_offset, self.max_y + self.max_offset)
        structure.boundary.append(boundary)

        structure.layer.append(self._make_layer('Front', 0))
        structure.layer.append(self._make_layer('Back', 1))
        return structure

    def _from_pixels_abs(self, point):
        """ Converts absolute position and updates min/max values for boundary calculation """
        point = self.resolution.from_pixels(point)
        self.max_x = max(self.max_x, point[0])
        self.max_y = max(self.max_y, point[1])
        self.min_x = min(self.min_x, point[0])
        self.min_y = min(self.min_y, point[1])
        return point

    def _from_pixels(self, point):
        """ Converts relative position and updates max value for boundary calculation """
        point = self.resolution.from_pixels(point)

        if isinstance(point, tuple):
            self.max_offset = max(self.max_offset, max(abs(point[0]), abs(point[1])))
        else:            
            self.max_offset = max(self.max_offset, abs(point))
        return point

    def _convert_net(self, net):
        """ Convert a net """

        #TODO: Pins (padstack) and wires must be on the same layer!

        pcbnet = specctraobj.Net()
        pcbnet.net_id = net.net_id
        pcbnet.pins.append(specctraobj.Pins())

        wire = specctraobj.Wire()
        wire.net = specctraobj.Net() 
        wire.net.net_id = net.net_id

        paths = set()
        for point in net.points.values():
            for cpt in point.connected_components:
                pcbnet.pins[-1].pin_reference.append(cpt.instance_id + '-' + cpt.pin_number)

            for point2_id in point.connected_points:
                point2 = net.points.get(point2_id)
                if point2 is not None:
                    path = [(point.x, point.y), (point2.x, point2.y)]
                    path.sort() # canonical order
                    paths.add(tuple(path))

        # Keep unique pins only
        pcbnet.pins[-1].pin_reference = dict.fromkeys(pcbnet.pins[-1].pin_reference).keys()
        self.pcb.network.net.append(pcbnet)

        for path in paths:
            wire = specctraobj.Wire()
            wire.net = specctraobj.Net() 
            wire.net.net_id = net.net_id
            wire.shape = specctraobj.Path()
            wire.shape.layer_id = 'Front'

            point1, point2 = path
            wire.shape.vertex.append(self._from_pixels_abs(point1))
            wire.shape.vertex.append(self._from_pixels_abs(point2))
            self.pcb.wiring.wire.append(wire)

    def _convert_pin_to_outline(self, pin):
        """ Convert a pin into an outline """
        pcbshape = specctraobj.Path()
        pcbshape.layer_id = 'Front'
        pcbshape.aperture_width = self._from_pixels(1)
        pcbshape.vertex.append(self._from_pixels((pin.p1.x, pin.p1.y)))
        pcbshape.vertex.append(self._from_pixels((pin.p2.x, pin.p2.y)))
        outline = specctraobj.Outline()
        outline.shape = pcbshape
        return outline

    def _convert_component(self, library_id, cpt):
        """ Convert a component """
        for idx, symbol in enumerate(cpt.symbols):
            image = specctraobj.Image()
            image.image_id = library_id + '-' + str(idx)
            self.pcb.library.image.append(image)

            for body in symbol.bodies:
                for shape in body.shapes:
                    for pcbshape in self._convert_shape(shape):
                        outline = specctraobj.Outline()
                        outline.shape = pcbshape
                        image.outline.append(outline)

                for pin in body.pins:
                    image.pin.append(self._convert_pin(pin))
                    image.outline.append(self._convert_pin_to_outline(pin))

    def _get_arc_qarcs(self, arc):
        """ Specctra does not have arcs so convert them to qarcs """
        
        min_angle = min(arc.start_angle, arc.end_angle)
        max_angle = max(arc.start_angle, arc.end_angle)

        def make_point(angle):
            """ Make a point """
            opp = math.sin(angle * math.pi) * arc.radius
            adj = math.cos(angle * math.pi) * arc.radius
            return (arc.x + adj, arc.y - opp)
 
        points = []
        for angle in (0.5, 1.0, 1.5, 2.0):
            if max_angle < angle:
                points.append((make_point(max_angle), make_point(min_angle)))
                break
            elif min_angle < angle:
                points.append((make_point(angle), make_point(min_angle)))
                min_angle = angle
                if min_angle == max_angle:
                    break

        return points

    def _get_arc_points(self, arc):
        """ Specctra does not have arcs so convert them to lines """
        
        min_angle = min(arc.start_angle, arc.end_angle)
        max_angle = max(arc.start_angle, arc.end_angle)
        step = 0.2
        count = int((max_angle - min_angle) / step)

        angle = min_angle
        angles = []
        for _ in xrange(count):
            angles.append(angle)
            angle += step
        angles.append(max_angle)

        def make_point(angle):
            """ Make a point """
            opp = math.sin(angle * math.pi) * arc.radius
            adj = math.cos(angle * math.pi) * arc.radius
            return (arc.x - adj, arc.y + opp)
 
        points = []
        for angle in angles:
            points.append(make_point(angle))
        return points

    def _points_to_paths(self, points):
        """ Convert points to paths """
        prev = points[0]
        result = []
        for point in points[1:]:
            path = specctraobj.Path()
            path.aperture_width = self._from_pixels(1)
            path.vertex.append(prev)
            path.vertex.append(point)
            result.append(path)
            prev = point
        return result

    def _convert_shape(self, shape):
        """ Convert a shape """
        if shape.type == 'circle':
            circle = specctraobj.Circle()
            circle.aperture_width = self._from_pixels(1)
            circle.diameter = self._from_pixels(float(shape.radius) * 2.0)
            circle.vertex = self._from_pixels((shape.x, shape.y))
            return [circle]
        elif shape.type == 'line':
            path = specctraobj.Path()
            path.aperture_width = self._from_pixels(1)
            path.vertex.append(self._from_pixels((shape.p1.x, shape.p1.y)))
            path.vertex.append(self._from_pixels((shape.p2.x, shape.p2.y)))
            return [path]
        elif shape.type == 'polygon':
            polygon = specctraobj.Polygon()
            polygon.aperture_width = self._from_pixels(1)
            for point in shape.points:
                polygon.vertex.append(self._from_pixels((point.x, point.y)))
            return [polygon]
        elif shape.type == 'arc':
            # Can't get freerouting.net to show qarc, replace it with multiple paths
            #
            #points = self._get_arc_qarcs(shape)
            #center = self._from_pixels((shape.x, shape.y))
            #
            #result = []
            #for start, end in points:
            #    qarc = specctraobj.QArc()
            #    qarc.vertex1 = self._from_pixels(start)
            #    qarc.vertex2 = self._from_pixels(end)
            #    qarc.vertex3 = center
            #    result.append(qarc)
            #return result

            points = [self._from_pixels(point) for point in self._get_arc_points(shape)]
            return self._points_to_paths(points)
           
        elif shape.type == 'bezier':
            points = [self._from_pixels((point.x, point.y)) for point in shape._line()]
            return self._points_to_paths(points)

        elif shape.type == 'rectangle':
            rect = specctraobj.Rectangle()
            rect.aperture_width = self._from_pixels(1)
            rect.vertex1 = self._from_pixels((shape.x, shape.y))
            rect.vertex2 = self._from_pixels((shape.x + shape.width, shape.y - shape.height))
            return [rect]
        else:
            assert shape.type is None # Not reached

    def _make_pin(self, padstack_id):
        """ Make a pin """
        shape = specctraobj.Path()
        shape.layer_id = 'Front'
        shape.vertex.append((0, 0))
        shape.vertex.append((0, 0))

        padstack = specctraobj.Padstack()
        padstack.padstack_id = padstack_id
        padstack.shape.append(specctraobj.Shape())
        padstack.shape[-1].shape = shape
        self.pcb.library.padstack.append(padstack)

    def _convert_pin(self, pin):
        """ Convert a pin """
        new_pin = specctraobj.Pin()
        new_pin.pin_id = pin.pin_number
        new_pin.vertex = self._from_pixels_abs((pin.p2.x, pin.p2.y))
        new_pin.padstack_id = _PIN

        return new_pin
 
    def _to_string(self, lst, indent=''):
        """ Convert to a string """
        result = []
        for elem in lst:
            if isinstance(elem, list):
                if len(elem) > 0:
                    result.append('\n')
                    result.append(self._to_string(elem, indent + '  '))
            elif isinstance(elem, float):
                result.append('%.6f' % elem)
            elif isinstance(elem, basestring):
                for char in ('(', ')', ' '):
                    if char in elem:
                        result.append('"%s"' % elem)
                        break
                else:
                    result.append(str(elem))
            elif elem is not None:
                result.append(str(elem))
        return indent + '(' + ' '.join(result) + ')\n' + indent 



########NEW FILE########
__FILENAME__ = eaglexml_t
# encoding: utf-8
#pylint: disable=R0904
""" The eaglexml writer test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.parser.t.eaglexml_t import get_design
from upconvert.writer.eaglexml import EagleXML

from functools import wraps

import os
import unittest
import tempfile

EAGLE_SCALE = 10.0/9.0

_cache = {} # filename -> DOM

def get_dom(filename):
    if filename not in _cache:
        design = get_design(filename)
        eaglexml = EagleXML()
        for ci in design.component_instances:
            eaglexml.inst2cpt[ci.instance_id] = ci.library_id
        _cache[filename] = eaglexml.make_dom(design)
    return _cache[filename]


def use_file(filename):
    """ Return a decorator which will parse a gerber file
    before running the test. """

    def decorator(test_method):
        """ Add params to decorator function. """

        @wraps(test_method)
        def wrapper(self):
            """ Parse file then run test. """
            self.design = get_design(filename)
            self.dom = get_dom(filename)
            test_method(self)

        return wrapper

    return decorator


class EagleXMLTests(unittest.TestCase):
    """ The tests of the eaglexml writer """

    @use_file('E1AA60D5.sch')
    def test_write(self):
        """
        We can write out a complete design file.
        """

        writer = EagleXML()
        filedesc, filename = tempfile.mkstemp()
        os.close(filedesc)
        os.remove(filename)
        writer.write(self.design, filename)
        self.assertTrue(os.path.exists(filename))
        os.remove(filename)


    @use_file('E1AA60D5.sch')
    def test_libraries(self):
        """
        The correct libraries are generated.
        """

        libnames = [lib.name for lib
                    in self.dom.drawing.schematic.libraries.library]
        self.assertTrue('atmel' in libnames, libnames)


    @use_file('E1AA60D5.sch')
    def test_layers(self):
        """
        The correct layers are generated.
        """

        layers = [layer.name for layer in self.dom.drawing.layers.layer]
        self.assertTrue('Nets' in layers, layers)


    @use_file('E1AA60D5.sch')
    def test_devicesets(self):
        """
        The correct devicesets are generated.
        """

        lib = self.get_library('atmel')
        dsnames = [ds.name for ds in lib.devicesets.deviceset]
        self.assertTrue('TINY15L' in dsnames, dsnames)


    @use_file('E1AA60D5.sch')
    def test_parts(self):
        """
        The correct parts are generated.
        """

        parts = self.dom.drawing.schematic.parts
        names = [p.name for p in parts.part]
        self.assertTrue('R1' in names, names)


    @use_file('E1AA60D5.sch')
    def test_instances(self):
        """
        The correct instances are generated.
        """

        instances = self.dom.drawing.schematic.sheets.sheet[0].instances.instance
        names = [i.part for i in instances]
        self.assertTrue('IC1' in names, names)


    @use_file('E1AA60D5.sch')
    def test_attributes(self):
        """
        The correct instances are generated.
        """

        instances = self.dom.drawing.schematic.sheets.sheet[0].instances.instance
        instance = [i for i in instances if i.part == 'IC1'][0]
        self.assertTrue(len(instance.attribute), 2)
        self.assertTrue(set(a.value for a in instance.attribute),
                        set(['IC1', 'TINY25']))


    @use_file('E1AA60D5.sch')
    def test_symbols(self):
        """
        The correct symbols are generated.
        """

        lib = self.get_library('transistor-pnp')
        self.assertEqual(len(lib.symbols.symbol), 1)
        self.assertEqual(lib.symbols.symbol[0].name, 'PNP')


    @use_file('E1AA60D5.sch')
    def test_symbol_wires(self):
        """
        The correct symbol wires are generated.
        """

        lib = self.get_library('transistor-pnp')
        sym = lib.symbols.symbol[0]
        self.assertEqual(len(sym.wire), 11)
        wire = sym.wire[0]
        self.assertEqual(round(wire.x1 / EAGLE_SCALE, 3), 2.117)
        self.assertEqual(round(wire.y1 / EAGLE_SCALE, 3), 1.693)
        self.assertEqual(round(wire.x2 / EAGLE_SCALE, 2), 1.55)
        self.assertEqual(round(wire.y2 / EAGLE_SCALE, 2), 2.54)


    @use_file('E1AA60D5.sch')
    def test_symbol_rectangles(self):
        """
        The correct symbol rectangles are generated.
        """

        lib = self.get_library('transistor-pnp')
        sym = lib.symbols.symbol[0]
        self.assertEqual(len(sym.rectangle), 1)
        rect = sym.rectangle[0]
        self.assertEqual(round(rect.x1 / EAGLE_SCALE, 2), -0.28)
        self.assertEqual(round(rect.y1 / EAGLE_SCALE, 2), -2.54)
        self.assertEqual(round(rect.x2 / EAGLE_SCALE, 2), 0.56)
        self.assertEqual(round(rect.y2 / EAGLE_SCALE, 2), 2.54)


    @use_file('450B679C.sch')
    def test_symbol_polygons(self):
        """
        The correct symbol polygons are generated.
        """

        lib = self.get_library('adafruit')
        sym = lib.symbols.symbol[0]
        self.assertEqual(sym.name, 'LED')
        self.assertEqual(len(sym.polygon), 2)
        poly = sym.polygon[0]
        self.assertEqual(len(poly.vertex), 3)
        self.assertEqual(round(poly.vertex[0].x / EAGLE_SCALE, 3), -3.387)
        self.assertEqual(round(poly.vertex[0].y / EAGLE_SCALE, 3), -2.117)


    @use_file('D9CD1423.sch')
    def test_symbol_circles(self):
        """
        The correct symbol circles are generated.
        """

        lib = self.get_library('CONNECTER')
        sym = lib.symbols.symbol[0]
        self.assertEqual(sym.name, 'HEADER_1X10')
        self.assertEqual(len(sym.circle), 9)
        self.assertEqual(round(sym.circle[0].x / EAGLE_SCALE, 2), 0)
        self.assertEqual(round(sym.circle[0].y / EAGLE_SCALE, 2), 8.89)
        self.assertEqual(round(sym.circle[0].radius / EAGLE_SCALE, 3), 0.988)
        self.assertEqual(sym.circle[0].width, '0.254')


    @use_file('E1AA60D5.sch')
    def test_symbol_pins(self):
        """
        The correct symbol pins are generated.
        """

        lib = self.get_library('transistor-pnp')
        sym = lib.symbols.symbol[0]
        self.assertEqual(len(sym.pin), 3)
        pin = sym.pin[0]
        self.assertEqual(pin.name, "B")
        self.assertEqual(round(pin.x / EAGLE_SCALE, 2), -2.54)
        self.assertEqual(round(pin.y / EAGLE_SCALE, 2), 0)
        self.assertEqual(pin.length, "short")
        self.assertEqual(pin.rot, None)
        pin = sym.pin[1]
        self.assertEqual(pin.name, "E")
        self.assertEqual(round(pin.x / EAGLE_SCALE, 2), 2.54)
        self.assertEqual(round(pin.y / EAGLE_SCALE, 2), 5.08)
        self.assertEqual(pin.length, "short")
        self.assertEqual(pin.rot, "R270")
        pin = sym.pin[2]
        self.assertEqual(pin.name, "C")
        self.assertEqual(round(pin.x / EAGLE_SCALE, 2), 2.54)
        self.assertEqual(round(pin.y / EAGLE_SCALE, 2), -5.08)
        self.assertEqual(pin.length, "short")
        self.assertEqual(pin.rot, "R90")


    @use_file('E1AA60D5.sch')
    def test_nets(self):
        """
        The correct nets are generated.
        """

        nets = self.dom.drawing.schematic.sheets.sheet[0].nets
        names = [n.name for n in nets.net]
        self.assertTrue('GND' in names, names)


    @use_file('E1AA60D5.sch')
    def test_segments(self):
        """
        The correct segments are generated.
        """

        nets = self.dom.drawing.schematic.sheets.sheet[0].nets
        gnd = [n for n in nets.net if n.name == 'GND'][0]
        self.assertEqual(len(gnd.segment), 7)


    @use_file('E1AA60D5.sch')
    def test_segment_wires(self):
        """
        The correct wires in segments are generated.
        """

        nets = self.dom.drawing.schematic.sheets.sheet[0].nets
        net = [n for n in nets.net if n.name == 'N$7'][0]
        self.assertEqual(len(net.segment), 1)
        seg = net.segment[0]
        self.assertEqual(len(seg.wire), 2)
        self.assertEqual(round(seg.wire[0].x1 / EAGLE_SCALE, 1), 76.2)
        self.assertEqual(round(seg.wire[0].y1 / EAGLE_SCALE, 2), 68.58)
        self.assertEqual(round(seg.wire[0].x2 / EAGLE_SCALE, 2), 83.82)
        self.assertEqual(round(seg.wire[0].y2 / EAGLE_SCALE, 2), 68.58)
        self.assertEqual(round(seg.wire[1].x1 / EAGLE_SCALE, 2), 83.82)
        self.assertEqual(round(seg.wire[1].y1 / EAGLE_SCALE, 2), 48.26)
        self.assertEqual(round(seg.wire[1].x2 / EAGLE_SCALE, 2), 83.82)
        self.assertEqual(round(seg.wire[1].y2 / EAGLE_SCALE, 2), 68.58)


    @use_file('E1AA60D5.sch')
    def test_segment_pinrefs(self):
        """
        The correct pinrefs in segments are generated.
        """

        nets = self.dom.drawing.schematic.sheets.sheet[0].nets
        net = [n for n in nets.net if n.name == 'N$7'][0]
        self.assertEqual(len(net.segment), 1)
        seg = net.segment[0]
        self.assertEqual(len(seg.pinref), 2)
        self.assertEqual(seg.pinref[0].part, 'IC1')
        self.assertEqual(seg.pinref[0].gate, 'G$1')
        self.assertEqual(seg.pinref[0].pin, '(ADC1)PB2')
        self.assertEqual(seg.pinref[1].part, 'R3')
        self.assertEqual(seg.pinref[1].gate, 'G$1')
        self.assertEqual(seg.pinref[1].pin, '2')


    def get_library(self, name):
        """ Return the named library from the dom. """

        return [lib for lib
                in self.dom.drawing.schematic.libraries.library
                if lib.name == name][0]

########NEW FILE########
__FILENAME__ = eagle_t
#!/usr/bin/python
# encoding: utf-8
""" The eagle writer test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import unittest

from upconvert.writer.eagle import Eagle

class EagleTests(unittest.TestCase):
    """ The tests of the eagle writer """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_eagle_writer(self):
        """ Test creating an empty writer. """
        writer = Eagle()
        assert writer != None

    def test_header_construct(self):
        """ Test Header block creation """

        _header = Eagle.Header(version="5.11", 
                               numofblocks=12,
                              )

        _chunk = _header.construct()
        
        _valid_chunk = b''.join((b"\x10\x00\x00\x00\x0c\x00\x00\x00", 
                                 b"\x05\x0b\x00\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_settings_construct(self):
        """ Test Settings block creation """
#TODO ...
        pass

    def test_grid_construct(self):
        """ Test Grid block creation """

        _grid = Eagle.Grid(distance=0.1,
                           unitdist="mm",
                           unit="mm",
                           style="dots",
                           multiple=15,
                           display=False,
                           altdistance=0.01,
                           altunitdist="mil",
                           altunit="mil",
                          )

        _chunk = _grid.construct()

        _valid_chunk = b''.join((b"\x12\x00\x02\xa5\x0f\x00\x00\x00",
                                 b"\x9a\x99\x99\x99\x99\x99\xb9\x3f",
                                 b"\x7b\x14\xae\x47\x1e\x7a\x84\x3f"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_layer_construct(self):
        """ Test Layer block creation """

        _layer = Eagle.Layer(number=91,
                             name="Nets",
                             color=2,
                             fill=1,
                             visible=True,
                             active=True,
                             linkedsign=False,
                             linkednumber=91,
                            )

        _chunk = _layer.construct()

        _valid_chunk = b''.join((b"\x13\x00\x0e\x5b\x5b\x01\x02\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x4e",
                                 b"\x65\x74\x73\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_attributeheader_construct(self):
        """ Test AttributeHeader block creation """

# probably no embedded schematic is possible;
        _attrheader = Eagle.AttributeHeader(schematic=''.join((
                                                ":%F%N/%S.%C%R", 
                                                '\t', "/%S.%C%R")),
                                            numofshapes=3,
                                            numofattributes=2, 
                                           )

        _chunk = _attrheader.construct()

        _valid_chunk = b''.join((b"\x14\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x04\x00\x00\x00\x02\x00\x00\x00",
                                 b"\x00\x00\x00\x7f\x00\x00\x00\x09"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_library_construct(self):
        """ Test Library block creation """

# embedded text
        _library = Eagle.Library(name="diode",
                                 numofdevsetblocks=9,
                                 numofsymbolblocks=22,
                                 numofpackageblocks=36,
                                )

        _chunk = _library.construct()

        _valid_chunk = b''.join((b"\x15\x00\x00\x00\x09\x00\x00\x00",
                                 b"\x16\x00\x00\x00\x24\x00\x00\x00",
                                 b"\x64\x69\x6f\x64\x65\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)

# TODO external text
        return

    def test_devicesetheader_construct(self):
        """ Test DeviceSetHeader block creation """

# embedded text
        _deviceset = Eagle.DeviceSetHeader(name="diode",
                                           numofblocks=8,
                                           numofshapesets=2,
                                          )

        _chunk = _deviceset.construct()

        _valid_chunk = b''.join((b"\x17\x00\x00\x00\x08\x00\x00\x00",
                                 b"\x02\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x64\x69\x6f\x64\x65\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)

# TODO external text
        return

    def test_symbolheader_construct(self):
        """ Test SymbolHeader block creation """

# embedded text
        _symbolheader = Eagle.SymbolHeader(name="diode",
                                           numofblocks=21,
                                           numofshapesets=2,
                                          )

        _chunk = _symbolheader.construct()

        _valid_chunk = b''.join((b"\x18\x00\x00\x00\x15\x00\x00\x00",
                                 b"\x02\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x64\x69\x6f\x64\x65\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)

# TODO external text
        return

    def test_packageheader_construct(self):
        """ Test PackageHeader block creation """

# embedded text
        _packageheader = Eagle.PackageHeader(name="diode",
                                             numofblocks=35,
                                             numofshapesets=2,
                                            )

        _chunk = _packageheader.construct()

        _valid_chunk = b''.join((b"\x19\x00\x00\x00\x23\x00\x00\x00",
                                 b"\x02\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x64\x69\x6f\x64\x65\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)

# TODO external text
        return

    def test_symbol_construct(self):
        """ Test Symbol block creation """

# embedded text
        _symbol = Eagle.Symbol(libid=1,
                               name="ZD", 
                               numofshapes=10,
                              )

        _chunk = _symbol.construct()

        _valid_chunk = b''.join((b"\x1d\x00\x0a\x00\x00\x00\x00\x00",
                                 b"\x00\x01\x00\x00\x00\x00\x00\x00",
                                 b"\x5a\x44\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)

# TODO external text
        return

    def test_package_construct(self):
        """ Test Package block creation """

# TODO embedded text

# external text
        _package = Eagle.Package(name="LongName", 
                                 desc="LongDescription",
                                 numofshapes=13,
                                )

        _chunk = _package.construct()

        _valid_chunk = b''.join((b"\x1e\x00\x0d\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x7f\x00\x00",
                                 b"\x00\x09\x7f\x00\x00\x00\x09\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)

        return

    def test_net_construct(self):
        """ Test Net block creation """

        _net = Eagle.Net(name="N$1",
                         nclass=1,
                         numofshapes=5,
                        )

        _chunk = _net.construct()

        _valid_chunk = b''.join((b"\x1f\x00\x05\x00\xff\x7f\xff\x7f",
                                 b"\x00\x80\x00\x80\x00\x01\x00\x00",
                                 b"\x4e\x24\x31\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_part_construct(self):
        """ Test Part block creation """

        _part = Eagle.Part(name="IC9",
                           libid=1,
                           devsetndx=2,
                           symvar=1,
                           techno=1,
                           value="DS3668",
                           numofshapes=2,
                          )

        _chunk = _part.construct()

        _valid_chunk = b''.join((b"\x38\x00\x02\x00\x01\x00\x02\x00",
                                 b"\x01\x01\x01\x49\x43\x39\x00\x00",
                                 b"\x44\x53\x33\x36\x36\x38\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_deviceset_construct(self):
        """ Test DeviceSet block creation """

# embedded names (2 of 3)
        _devset = Eagle.DeviceSet(name="1N5333",
                                  prefix="D",
                                  description="some long long long description",
                                  uservalue=False,
                                  numofshapes=1,
                                  numofconnblocks=2,
                                 )

        _chunk = _devset.construct()

        _valid_chunk = b''.join((b"\x37\x00\x01\x00\x02\x00\x00\x00",
                                 b"\x44\x00\x00\x00\x00\x7f\x00\x00",
                                 b"\x00\x09\x31\x4e\x35\x33\x33\x33"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
# embedded names (2 of 3)
        _devset = Eagle.DeviceSet(name="some long long long name",
                                  prefix="JP",
                                  description="",
                                  uservalue=True,
                                  numofshapes=1,
                                  numofconnblocks=2,
                                 )

        _chunk = _devset.construct()

        _valid_chunk = b''.join((b"\x37\x00\x01\x00\x02\x00\x01\x00",
                                 b"\x4A\x50\x00\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x7f\x00\x00\x00\x09\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)

        return

    def test_bus_construct(self):
        """ Test Bus block creation """

        _bus = Eagle.Bus(name="B$3",
                         numofshapes=4,
                        )

        _chunk = _bus.construct()

        _valid_chunk = b''.join((b"\x3a\x00\x04\x00\x42\x24\x33\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_shapeheader_construct(self):
        """ Test ShapeHeader block creation """

        _shapeheader = Eagle.ShapeHeader(numofshapes=3,
                                         numofpartblocks=4,
                                         numofbusblocks=5,
                                         numofnetblocks=14,
                                        )

        _chunk = _shapeheader.construct()

        _valid_chunk = b''.join((b"\x1a\x00\x03\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x04\x00\x00\x00",
                                 b"\x05\x00\x00\x00\x0e\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_segment_construct(self):
        """ Test Segment block creation """

        _segment = Eagle.Segment(numofshapes=4,
                                 cumulativenumofshapes=19,
                                )

        _chunk = _segment.construct()

        _valid_chunk = b''.join((b"\x20\x00\x04\x00\x00\x00\x00\x00",
                                 b"\x00\x13\x00\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_connectionheader_construct(self):
        """ Test ConnectionHeader block creation """

        _connheader = Eagle.ConnectionHeader(numofshapes=1,
                                             sindex=4,
                                             attributes=None,
                                             technologies=None,
                                             name=None,
                                            )

        _chunk = _connheader.construct()

        _valid_chunk = b''.join((b"\x36\x00\x01\x00\x04\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x27\x27\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
# TODO technology / attributes check, 'name'
        return

    def test_connections_construct(self):
        """ Test Connections block creation """

        _connections = Eagle.Connections(connections = [33, 34, 35, 36, 37, 38, 
                                        39, 40, 41, 42, 43, 44, 45, 46, 47, 48]
                                        )

        _chunk = _connections.construct()

        _valid_chunk = b''.join((b"\x3c\x00\x21\x22\x23\x24\x25\x26",
                                 b"\x27\x28\x29\x2a\x2b\x2c\x2d\x2e",
                                 b"\x2f\x30\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_polygon_construct(self):
        """ Test Polygon block creation """

        _polygon = Eagle.Polygon(numofshapes=3,
                                 width=0.1016,
                                 layer=21,
                                )

        _chunk = _polygon.construct()

        _valid_chunk = b''.join((b"\x21\x00\x03\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\xfc\x01\x00\x00",
                                 b"\x00\x00\x15\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_instance_construct(self):
        """ Test Instance block creation """

        _instance = Eagle.Instance(numofshapes=2,
                                   x=218.44,
                                   y=60.96,
                                   smashed=True,
                                   rotate="R90",
                                  )

        _chunk = _instance.construct()

        _valid_chunk = b''.join((b"\x30\x00\x02\x00\xd0\x54\x21\x00",
                                 b"\x40\x4d\x09\x00\xff\xff\x00\x00",
                                 b"\x00\x04\x01\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_wire_construct(self):
        """ Test Wire block creation """

        _wire = Eagle.Wire(x1=33.02,
                           y1=60.96,
                           x2=33.02,
                           y2=50.8,
                           width=0.1524,
                           style="DashDot",
                           layer=91,
                          )

        _chunk = _wire.construct()

        _valid_chunk = b''.join((b"\x22\x00\x00\x5b\xd8\x09\x05\x00",
                                 b"\x40\x4d\x09\x00\xd8\x09\x05\x00",
                                 b"\x60\xc0\x07\x00\xfa\x02\x03\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_hole_construct(self):
        """ Test Hole block creation """

        _hole = Eagle.Hole(x=0.,
                           y=11.176,
                           drill=3.302,
                          )

        _chunk = _hole.construct()

        _valid_chunk = b''.join((b"\x28\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x90\xb4\x01\x00\x7e\x40\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_smd_construct(self):
        """ Test SMD block creation """

        _smd = Eagle.SMD(name="14",
                         x=-1.905,
                         y=3.0734,
                         dx=0.6604,
                         dy=2.032,
                         layer=1,
                        )

        _chunk = _smd.construct()

        _valid_chunk = b''.join((b"\x2b\x00\x00\x01\x96\xb5\xff\xff",
                                 b"\x0e\x78\x00\x00\xe6\x0c\xb0\x27",
                                 b"\x00\x00\x00\x31\x34\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_arc_construct(self):
        """ Test Arc block construction """

        _arc = Eagle.Arc(x1=101.6,
                         y1=38.1,
                         x2=111.76,
                         y2=60.96,
                         width=0.6096,
                         curve=247.38,      # note: encoded number is 114.3 -- a circle center's X coord
                         cap="flat",
                         direction="counterclockwise",
                         style="ShortDash",
                         layer=91,
                        )

        _chunk = _arc.construct()

        _valid_chunk = b''.join((b"\x22\x00\x00\x5b\xc0\x80\x0f\xd8",
                                 b"\x48\xd0\x05\x70\xa0\x0d\x11\x11",
                                 b"\x40\x4d\x09\x00\xe8\x0b\x32\x81"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_circle_construct(self):
        """ Test Circle block creation """

        _circle = Eagle.Circle(x=119.38,
                               y=66.04,
                               radius=9.1581,
                               width=0.3048,
                               layer=91,
                              )

        _chunk = _circle.construct()

        _valid_chunk = b''.join((b"\x25\x00\x00\x5b\x48\x37\x12\x00",
                                 b"\xb0\x13\x0a\x00\xbd\x65\x01\x00",
                                 b"\xbd\x65\x01\x00\xf4\x05\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_rectangle_construct(self):
        """ Test Rectangle block creation """

        _rectangle = Eagle.Rectangle(x1=15.24,
                                     y1=68.58,
                                     x2=58.42,
                                     y2=111.76,
                                     rotate=None,
                                     layer=92,
                                    )

        _chunk = _rectangle.construct()

        _valid_chunk = b''.join((b"\x26\x00\x00\x5c\x50\x53\x02\x00",
                                 b"\xe8\x76\x0a\x00\x08\xea\x08\x00",
                                 b"\xa0\x0d\x11\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_pad_construct(self):
        """ Test Pad block creation """

        _pad = Eagle.Pad(name="A",
                         x=5.08,
                         y=0.,
                         drill=0.5588,
                        )

        _chunk = _pad.construct()

        _valid_chunk = b''.join((b"\x2a\x00\x00\x00\x70\xc6\x00\x00",
                                 b"\x00\x00\x00\x00\xd4\x15\x00\x00",
                                 b"\x00\x00\x00\x41\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_pin_construct(self):
        """ Test Pin block creation """

        _pin = Eagle.Pin(name="C",
                         x=2.54,
                         y=0.,
                         visible="off",
                         direction="pas",
                         rotate="R180",
                         length="short",
                         function=None,
                         swaplevel=0,
                        )

        _chunk = _pin.construct()

        _valid_chunk = b''.join((b"\x2c\x00\x00\x00\x38\x63\x00\x00",
                                 b"\x00\x00\x00\x00\x96\x00\x43\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)

        _pin = Eagle.Pin(name="IN+",
                         x=-5.08,
                         y=2.54,
                         visible="pad",
                         direction="in",
                         rotate=None,
                         length="short",
                         function="dot",
                         swaplevel=1,
                        )

        _chunk = _pin.construct()

        _valid_chunk = b''.join((b"\x2c\x00\x41\x00\x90\x39\xff\xff",
                                 b"\x38\x63\x00\x00\x11\x01\x49\x4e",
                                 b"\x2b\x00\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_gate_construct(self):
        """ Test Gate block creation """

        _gate = Eagle.Gate(name="P",
                           x=-25.4,
                           y=2.54,
                           sindex=2,
                           addlevel="request",
                          )

        _chunk = _gate.construct()

        _valid_chunk = b''.join((b"\x2d\x00\x00\x00\xd0\x1f\xfc\xff",
                                 b"\x38\x63\x00\x00\x03\x00\x02\x00",
                                 b"\x50\x00\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_text_construct(self):
        """ Test Text block creation """

# embedded text
        _text = Eagle.Text(value="text!",
                           x=121.92,
                           y=20.32,
                           size=6.4516,
                           rotate="R180",
                           font="fixed",
                           ratio=19,
                           layer=91,
                          )

        _chunk = _text.construct()

        _valid_chunk = b''.join((b"\x31\x00\x02\x5b\x80\x9a\x12\x00",
                                 b"\xc0\x19\x03\x00\x02\x7e\x4c\x00",
                                 b"\x00\x08\x74\x65\x78\x74\x21\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)

# external text
        _text = Eagle.Text(value="longlonglonglongtext",
                           x=12.7,
                           y=93.98,
                           size=6.4516,
                           rotate=None,
                           font="fixed",
                           ratio=19,
                           layer=91,
                          )

        _chunk = _text.construct()

        _valid_chunk = b''.join((b"\x31\x00\x02\x5b\x18\xf0\x01\x00",
                                 b"\x18\x57\x0e\x00\x02\x7e\x4c\x00",
                                 b"\x00\x00\x7f\x00\x00\x00\x09\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return
 
    def test_label_construct(self):
        """ Test Label block creation """

        _label = Eagle.Label(x=91.44,
                             y=30.48,
                             size=0.8128,
                             rotate="R270",
                             font="fixed",
                             ratio=3,
                             onoff=True,
                             mirrored=True,
                             layer=95,
                            )

        _chunk = _label.construct()

        _valid_chunk = b''.join((b"\x33\x00\x02\x5f\xe0\xf3\x0d\x00",
                                 b"\xa0\xa6\x04\x00\xe0\x0f\x0c\x00",
                                 b"\x00\x1c\x01\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_frame_construct(self):
        """ Test Frame block creation """

        _frame = Eagle.Frame(x1=0.,
                             y1=0.,
                             x2=431.8,
                             y2=279.4,
                             columns=9,
                             rows=6,
                             bleft=True,
                             btop=True,
                             bright=True,
                             bbottom=False,
                             layer=94,
                            )

        _chunk = _frame.construct()

        _valid_chunk = b''.join((b"\x43\x00\x00\x5e\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x30\xe3\x41\x00",
                                 b"\x10\xa2\x2a\x00\x09\x06\x0e\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return





 
    def test_attributenam_construct(self):
        """ Test AttributeNam block creation """

        _attrnam = Eagle.AttributeNam(x=221.615,
                                      y=64.77,
                                      size=1.524,
                                      rotate=None,
                                      font=None,
                                      layer=95,
                                     )

        _chunk = _attrnam.construct()

        _valid_chunk = b''.join((b"\x34\x00\x01\x5f\xd6\xd0\x21\x00",
                                 b"\x14\xe2\x09\x00\xc4\x1d\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return
 
    def test_attributeval_construct(self):
        """ Test AttributeVal block creation """

        _attrval = Eagle.AttributeVal(x=220.345,
                                      y=62.611,
                                      size=1.524,
                                      rotate=None,
                                      font=None,
                                      layer=96,
                                     )

        _chunk = _attrval.construct()

        _valid_chunk = b''.join((b"\x35\x00\x01\x60\x3a\x9f\x21\x00",
                                 b"\xbe\x8d\x09\x00\xc4\x1d\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_attributeprt_construct(self):
        """ Test AttributePrt block creation """

        _attrprt = Eagle.AttributePrt(x=419.1,
                                      y=-20.32,
                                      size=1.778,
                                      rotate='MR0',
                                      font=None,
                                      layer=95,
                                     )

        _chunk = _attrprt.construct()

        _valid_chunk = b''.join((b"\x3f\x00\x01\x5f\x18\xf3\x3f\x00",
                                 b"\x40\xe6\xfc\xff\xba\x22\x00\x00",
                                 b"\x00\x10\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_pinref_construct(self):
        """ Test PinRef block creation """

        _pinref = Eagle.PinRef(partno=6,
                               gateno=1,
                               pinno=7,
                              )

        _chunk = _pinref.construct()

        _valid_chunk = b''.join((b"\x3d\x00\x00\x00\x06\x00\x01\x00",
                                 b"\x07\x00\x00\x00\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return

    def test_attribute_construct(self):
        """ Test Attribute block creation """

# embedded attribute
        _attr = Eagle.Attribute(name="1234567890",
                                value="qw!rt",
                               )

        _chunk = _attr.construct()

        _valid_chunk = b''.join((b"\x42\x00\x2a\x00\x00\x00\x00\x31",
                                 b"\x32\x33\x34\x35\x36\x37\x38\x39",
                                 b"\x30\x21\x71\x77\x21\x72\x74\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)

# external attribute
        _attr = Eagle.Attribute(name="1234567890",
                                value="longerthanexpected",
                               )

        _chunk = _attr.construct()

        _valid_chunk = b''.join((b"\x42\x00\x2a\x00\x00\x00\x00\x7f",
                                 b"\x00\x00\x00\x09\x00\x00\x00\x00",
                                 b"\x00\x00\x00\x00\x00\x00\x00\x00"))

        self.assertNotEqual(_chunk, None)
        self.assertEqual(_chunk, _valid_chunk)
        return



########NEW FILE########
__FILENAME__ = geda_t
﻿#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The geda writer test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import os
import unittest
import StringIO
import shutil
from upconvert.core.net import NetPoint
from upconvert.core import shape
from upconvert.core import components
from upconvert.core.design import Design

import upconvert.parser.geda
from upconvert.writer.geda import GEDA
from upconvert.parser.openjson import JSON


class GEDAWriterTestCase(unittest.TestCase):
    """ The tests of the geda writer """
    # pylint: disable=W0212

    def setUp(self):
        self.geda_writer = GEDA()
        self.oj_parser = JSON()


class GEDAWriterTests(GEDAWriterTestCase):
    """ The tests of the geda writer """
    # pylint: disable=W0212

    def test_converter_methods(self):
        """ Test if converter methods are available for all known
            shapes in the core.
        """
        shape_types = [
            'line',
            'bezier',
            'label',
            'rectangle',
            'rounded_rectangle',
            'circle',
            'polygon',
        ]

        for typ in shape_types:
            self.assertTrue(hasattr(self.geda_writer, "_convert_"+typ))

    def test_create_project_files(self):
        """ Test creating project files in the directory derived from the
            output filename. Should try to create *gafrc* file and *symbol*
            directory.
        """
        geda_filename = '/tmp/test_geda.sch'

        self.geda_writer.create_project_files(geda_filename)

        self.assertEquals(
            self.geda_writer.project_dirs['project'],
            '/tmp'
        )
        self.assertEquals(
            self.geda_writer.project_dirs['symbol'],
            '/tmp/symbols-test_geda.sch'
        )

    def test_write_schematic_file(self):
        """ Reads the gEDA *simple_example* file into a design using the
            gEDA parser, writes the result to a gEDA file and reads it into
            a new design. Both designs are then compared regarding their
            respective components, instances and nets. """
        # pylint: disable=R0914
        # pylint: disable=R0915

        sym_dir = '/tmp/sym'

        if os.path.exists('/tmp/converted.sch'):
            os.remove('/tmp/converted.sch')

        if os.path.exists(sym_dir):
            shutil.rmtree(sym_dir)

        geda_parser = upconvert.parser.geda.GEDA(
            symbol_dirs=['test/geda/simple_example/symbols']
        )
        geda_parser.set_offset(shape.Point(0, 0))
        simple_design = geda_parser.parse(
            'test/geda/simple_example/simple_example.sch'
        )

        geda_writer = GEDA()
        geda_writer.write(simple_design, '/tmp/converted.sch')

        converted_design = geda_parser.parse(
            '/tmp/converted.sch'
        )

        ## parse design again to make sure it is a clean slate
        geda_parser = upconvert.parser.geda.GEDA(
            symbol_dirs=['test/geda/simple_example/symbols']
        )
        geda_parser.set_offset(shape.Point(0, 0))
        simple_design = geda_parser.parse(
            'test/geda/simple_example/simple_example.sch'
        )

        ##compare nets
        self.assertEquals(
            sorted([(net.net_id, len(net.points)) for net in simple_design.nets]),
            sorted([(net.net_id, len(net.points)) for net in converted_design.nets])
        )

        snets = dict([(net.net_id, net) for net in simple_design.nets])
        cnets = dict([(net.net_id, net) for net in converted_design.nets])

        for snet_id, snet in snets.items():
            cnet = cnets[snet_id]

            spoints = dict([(pt.point_id, pt) for pt in snet.points.values()])
            cpoints = dict([(pt.point_id, pt) for pt in cnet.points.values()])
            self.assertEqual(sorted(spoints.keys()), sorted(cpoints.keys()))

            for spoint_id, spoint in spoints.items():
                cpoint = cpoints[spoint_id]

                self.assertEquals(spoint.x, cpoint.x)
                self.assertEquals(spoint.y, cpoint.y)

        ## compare component library
        self.assertEqual(
            sorted(simple_design.components.components.keys()),
            sorted(converted_design.components.components.keys())
        )

        for lib_id in simple_design.components.components:
            scomponent = simple_design.components.components[lib_id]
            ccomponent = converted_design.components.components[lib_id]

            self.assertEquals(scomponent.name, ccomponent.name)
            self.assertEquals(scomponent.attributes, ccomponent.attributes)

            self.assertEquals(len(scomponent.symbols), 1)
            self.assertEquals(
                len(scomponent.symbols),
                len(ccomponent.symbols)
            )

            self.assertEquals(len(scomponent.symbols[0].bodies), 1)
            self.assertEquals(
                len(scomponent.symbols[0].bodies),
                len(ccomponent.symbols[0].bodies)
            )
            sbody = scomponent.symbols[0].bodies[0]
            cbody = ccomponent.symbols[0].bodies[0]

            ## skip the unassigned shapes component as it adds an additional
            ## text from the basename when importing GEDA
            if scomponent.name != 'UNASSIGNED_SHAPES':
                self.assertEquals(len(sbody.shapes), len(cbody.shapes))
            self.assertEquals(len(sbody.pins), len(cbody.pins))

            for spin, cpin in zip(sbody.pins, cbody.pins):
                self.assertEquals(spin.p1.x, cpin.p1.x)
                self.assertEquals(spin.p1.x, cpin.p1.x)
                self.assertEquals(spin.p2.y, cpin.p2.y)
                self.assertEquals(spin.p2.y, cpin.p2.y)
                if spin.label is None:
                    self.assertEquals(cpin.label, None)
                else:
                    self.assertEquals(spin.label.text, cpin.label.text)

            for sshape, cshape in zip(sbody.shapes, cbody.shapes):
                self.assertEquals(sshape.type, cshape.type)

        ## compare component instances
        scomp_instances = dict([(comp.instance_id, comp) for comp in simple_design.component_instances])
        ccomp_instances = dict([(comp.instance_id, comp) for comp in converted_design.component_instances])

        for instance_id in scomp_instances:
            sinst = scomp_instances[instance_id]
            cinst = ccomp_instances[instance_id]

            self.assertEquals(sinst.instance_id, cinst.instance_id)
            self.assertEquals(sinst.library_id, cinst.library_id)
            self.assertEquals(sinst.symbol_index, cinst.symbol_index)

            self.assertEquals(
                sinst.symbol_attributes[0].x,
                cinst.symbol_attributes[0].x
            )
            self.assertEquals(
                sinst.symbol_attributes[0].y,
                cinst.symbol_attributes[0].y
            )
            self.assertEquals(
                sinst.symbol_attributes[0].rotation,
                cinst.symbol_attributes[0].rotation
            )

    def test_write_component_to_file(self):
        """ Tests writing a component to a symbol file. """
        sym_dir = '/tmp/sym'
        if os.path.exists(sym_dir):
            shutil.rmtree(sym_dir)

        os.mkdir(sym_dir)

        self.geda_writer.set_offset(shape.Point(-500, -500))

        self.geda_writer.component_library = dict()
        self.geda_writer.project_dirs['symbol'] = sym_dir

        simple_design = self.oj_parser.parse('test/openjson/simple.upv')

        library_id = '0000000000000001'
        component = simple_design.components.components[library_id]
        self.geda_writer.write_component_to_file(library_id, component)

        component_library = self.geda_writer.component_library
        self.assertEquals(len(component_library), 4)

        self.assertEquals(
            component_library,
            {
                (library_id, 0): 'Flag_1-0.sym',
                (library_id, 1): 'Flag_2-1.sym',
                (library_id, 2): 'GND-2.sym',
                (library_id, 3): 'VCC-3.sym'
            }
        )
        self.assertEquals(
            sorted(os.listdir(sym_dir)),
            ['Flag_1-0.sym', 'Flag_2-1.sym', 'GND-2.sym', 'VCC-3.sym']
        )


    def test_write_component_to_file_symbol_dirs(self):
        """ Tests writing a component to a symbol file with symbol dirs.
        """
        sym_dir = '/tmp/sym'

        if os.path.exists(sym_dir):
            shutil.rmtree(sym_dir)

        os.mkdir(sym_dir)

        self.geda_writer = GEDA(
            symbol_dirs=['test/geda/simple_example/symbols'])
        self.geda_writer.component_library = dict()
        self.geda_writer.project_dirs['symbol'] = sym_dir

        geda_parser = upconvert.parser.geda.GEDA(
            symbol_dirs=['test/geda/simple_example/symbols']
        )
        converted_design = geda_parser.parse(
            'test/geda/simple_example/simple_example.sch'
        )

        library_id = 'opamp'
        component = converted_design.components.components[library_id]
        self.geda_writer.write_component_to_file(library_id, component)

        component_library = self.geda_writer.component_library
        self.assertEquals(len(component_library), 1)

        self.assertEquals(
            component_library,
            {
                (library_id, 0): 'opamp.sym',
            }
        )
        library_id = 'capacitor-1'
        component = converted_design.components.components[library_id]
        self.geda_writer.write_component_to_file(library_id, component)

        component_library = self.geda_writer.component_library
        self.assertEquals(len(component_library), 2)

        self.assertEquals(
            component_library,
            {
                ('opamp', 0): 'opamp.sym',
                (library_id, 0): 'capacitor-1.sym',
            }
        )
        self.assertEquals(sorted(os.listdir(sym_dir)), [])


    def test_generate_net_commands(self):
        """ Tests creating commands for nets that can then be
            written to the schematic file.
        """
        design = self.oj_parser.parse('test/geda/nets_exported.upv')

        self.geda_writer.set_offset(design.bounds()[0])

        commands = self.geda_writer.generate_net_commands(design.nets)
        self.assertTrue(len(commands) > 0)

        segment_count = 0
        for command in commands:
            if command.startswith('N '):
                segment_count += 1

        self.assertEquals(segment_count, 21)

        env_count = 0
        for command in commands:
            if command.startswith('{'):
                env_count += 1
        self.assertEquals(env_count, 4)

        commands += ['v 20110115 2\n']
        geda_parser = upconvert.parser.geda.GEDA()
        geda_parser.unassigned_body = components.SBody()
        new_design = geda_parser.parse_schematic(
            StringIO.StringIO('\n'.join(commands))
        )
        self.assertEquals(len(design.nets), len(new_design.nets))


    def test_create_component(self):
        """ Tests creating components from various gEDA commands. """
        component = self.geda_writer._create_component(0, 0, 'test-1.sym')
        self.assertEquals(
            component,
            ['C 0 0 0 0 0 test-1.sym']
        )

    def test_create_attribute(self):
        """ Tests creating attribute commands. """
        attribute = self.geda_writer._create_attribute(
            '_private_attr', 'U1',
            0, 0
        )
        self.assertEquals(
            attribute,
            ['T 0 0 5 10 0 1 0 0 1', 'private_attr=U1']
        )
        attribute = self.geda_writer._create_attribute(
            'attr', 'U1',
            0, 0,
            style_size=25
        )
        self.assertEquals(
            attribute,
            ['T 0 0 5 25 1 1 0 0 1', 'attr=U1']
        )

    def test_create_text(self):
        """ Tests creating text commands. """
        text = self.geda_writer._create_text('some text', 0, 0)
        self.assertEquals(len(text), 2)
        self.assertEquals(
            text,
            ['T 0 0 9 10 1 1 0 0 1', 'some text']
        )

        text = self.geda_writer._create_text(
            "some text\nmulti line\ntext",
            0, 0, style_size=25, style_color=5, visibility=0,
            alignment='right',
        )
        self.assertEquals(len(text), 4)
        self.assertEquals(
            text,
            ['T 0 0 5 25 0 1 0 4 3', "some text", "multi line", "text"]
        )

    def test_create_pin(self):
        """ Tests creating pin commands. """
        pin = components.Pin('E', (0, 0), (0, 30))
        command = self.geda_writer._create_pin(1, pin)

        self.assertEquals(
            command,
            [
                'P 0 300 0 0 1 0 0',
                '{',
                'T 100 400 5 10 0 1 0 0 1',
                'pinseq=1',
                'T 100 500 5 10 0 1 0 0 1',
                'pinnumber=E',
                '}'
            ]
        )

        label = shape.Label(10, 0, 'p1', align='left', rotation=0.5)

        pin = components.Pin('E', (0, 0), (0, 30), label=label)
        command = self.geda_writer._create_pin(1, pin)

        self.assertEquals(
            command,
            [
                'P 0 300 0 0 1 0 0',
                '{',
                'T 100 0 5 10 1 1 270 0 1',
                'pinlabel=p1',
                'T 100 400 5 10 0 1 0 0 1',
                'pinseq=1',
                'T 100 500 5 10 0 1 0 0 1',
                'pinnumber=E',
                '}'
            ]
        )


    def test_convert_arc(self):
        """ Tests converting Arc objects to arc commands."""
        arc = shape.Arc(0, 0, 0.0, 0.7, 30)
        command = self.geda_writer._convert_arc(arc)

        self.assertEquals(
            command,
            ['A 0 0 300 0 235 3 10 0 0 -1 -1']
        )

        arc = shape.Arc(200, 400, 1.0, 0.5, 10)
        command = self.geda_writer._convert_arc(arc)

        self.assertEquals(
            command,
            ['A 2000 4000 100 180 90 3 10 0 0 -1 -1']
        )

        arc = shape.Arc(200, 400, 0.2, 0.1, 10)
        command = self.geda_writer._convert_arc(arc)

        self.assertEquals(
            command,
            ['A 2000 4000 100 324 18 3 10 0 0 -1 -1']
        )

    def test_convert_circle(self):
        """ Tests converting Circle objects to circle commands."""
        circle = shape.Circle(0, 0, 300)
        command = self.geda_writer._convert_circle(circle)

        self.assertEquals(
            command,
            ['V 0 0 3000 3 10 0 0 -1 -1 0 -1 -1 -1 -1 -1']
        )

        circle = shape.Circle(10, 30, 10)
        command = self.geda_writer._convert_circle(circle)

        self.assertEquals(
            command,
            ['V 100 300 100 3 10 0 0 -1 -1 0 -1 -1 -1 -1 -1']
        )

    def test_convert_rectangle(self):
        """ Tests converting Rectancle and RoundedRectangle
            objects to box commands.
        """
        rect = shape.Rectangle(0, 0, 40, 50)
        command = self.geda_writer._convert_rectangle(rect)

        self.assertEquals(
            command,
            ['B 0 -500 400 500 3 10 0 0 -1 -1 0 -1 -1 -1 -1 -1']
        )

        rect = shape.Rectangle(100, 50, 150, 30)
        command = self.geda_writer._convert_rectangle(rect)

        self.assertEquals(
            command,
            ['B 1000 200 1500 300 3 10 0 0 -1 -1 0 -1 -1 -1 -1 -1']
        )

        rect = shape.RoundedRectangle(0, 0, 40, 50, 0.5)
        command = self.geda_writer._convert_rounded_rectangle(rect)

        self.assertEquals(
            command,
            ['B 0 -500 400 500 3 10 0 0 -1 -1 0 -1 -1 -1 -1 -1']
        )

        rect = shape.RoundedRectangle(100, 50, 150, 30, 0.1)
        command = self.geda_writer._convert_rounded_rectangle(rect)

        self.assertEquals(
            command,
            ['B 1000 200 1500 300 3 10 0 0 -1 -1 0 -1 -1 -1 -1 -1']
        )

    def test_convert_line(self):
        """ Tests converting Line objects to line commands. """
        line = shape.Line((0, 0), (0, 50))
        command = self.geda_writer._convert_line(line)
        self.assertEquals(
            command,
            ['L 0 0 0 500 3 10 0 0 -1 -1']
        )

        line = shape.Line((20, 40), (-20, 40))
        command = self.geda_writer._convert_line(line)
        self.assertEquals(
            command,
            ['L 200 400 -200 400 3 10 0 0 -1 -1']
        )

        line = shape.Line((20, 40), (-30, 50))
        command = self.geda_writer._convert_line(line)
        self.assertEquals(
            command,
            ['L 200 400 -300 500 3 10 0 0 -1 -1']
        )

    def test_convert_label(self):
        """ Tests converting Lable objects to label commands. """
        label = shape.Label(0, 0, 'test label', align='center', rotation=0.0)
        command = self.geda_writer._convert_label(label)
        self.assertEquals(
            command,
            [
                'T 0 0 9 10 1 1 0 3 1',
                'test label'
            ]
        )

        label = shape.Label(0, 0, 'test label', align='left', rotation=0.5)
        command = self.geda_writer._convert_label(label)
        self.assertEquals(
            command,
            [
                'T 0 0 9 10 1 1 270 0 1',
                'test label'
            ]
        )

    def test_create_segment(self):
        """ Tests creating segment commands from NetPoint objects. """
        np1 = NetPoint('0a0', 0, 0)
        np2 = NetPoint('0a10', 0, 10)
        self.assertEquals(
            self.geda_writer._create_segment(np1, np2),
            ['N 0 0 0 100 4']
        )
        np1 = NetPoint('100a40', 100, 40)
        np2 = NetPoint('50a40', 50, 40)
        attrs = {'netname': 'test_net'}
        self.assertEquals(
            self.geda_writer._create_segment(np1, np2, attributes=attrs),
            [
                'N 1000 400 500 400 4',
                '{',
                'T 1100 500 5 10 1 1 0 0 1',
                'netname=test_net',
                '}',
            ]
        )

    def test_convert_polygon(self):
        """ Tests converting Polygon objects to path commands."""
        polygon = shape.Polygon()
        polygon.add_point((0, 0))
        polygon.add_point((100, 200))
        polygon.add_point((150, 200))
        polygon.add_point((200, 100))

        self.assertEquals(
            self.geda_writer._convert_polygon(polygon),
            [
                'H 3 10 0 0 -1 -1 0 -1 -1 -1 -1 -1 5',
                'M 0,0',
                'L 1000,2000',
                'L 1500,2000',
                'L 2000,1000',
                'z'
            ]
        )

    def test_convert_bezier(self):
        """ Tests converting BezierCurve objects to path commands. """
        curve = shape.BezierCurve((9, -10), (11, -10), (3, -12), (17, -12))

        self.assertEquals(
            self.geda_writer._convert_bezier(curve),
            [
                'H 3 10 0 0 -1 -1 0 -1 -1 -1 -1 -1 2',
                'M 30,-120',
                'C 90,-100 110,-100 170,-120',
            ]
        )

    def test_create_path(self):
        """ Test creating path commands from SBody objects. """
        shapes = [
            shape.Line((10, 10), (50, 10)),
            shape.BezierCurve((70, 10), (80, 30), (50, 10), (80, 40)),
            shape.BezierCurve((80, 50), (70, 70), (80, 40), (50, 70)),
            shape.Line((50, 70), (10, 70)),
        ]

        self.assertEquals(
            self.geda_writer._create_path(shapes),
            [
                'H 3 10 0 0 -1 -1 0 -1 -1 -1 -1 -1 5',
                'M 100,100',
                'L 500,100',
                'C 700,100 800,300 800,400',
                'C 800,500 700,700 500,700',
                'L 100,700',
            ]
        )

        shapes.append(shape.Line((10, 70), (10, 10)))

        self.assertEquals(
            self.geda_writer._create_path(shapes),
            [
                'H 3 10 0 0 -1 -1 0 -1 -1 -1 -1 -1 6',
                'M 100,100',
                'L 500,100',
                'C 700,100 800,300 800,400',
                'C 800,500 700,700 500,700',
                'L 100,700',
                'z',
            ]
        )

    def test_is_valid_path(self):
        """ Tests if SBody objects contain valid paths."""
        shapes = [
            shape.Line((10, 10), (50, 10)), #L 500,100
            shape.BezierCurve((70, 10), (80, 30), (50, 10), (80, 40)), #C 700,100 800,300 800,400
            shape.BezierCurve((80, 50), (70, 70), (80, 40), (50, 70)), #C 800,500 700,700 500,700
            shape.Line((50, 70), (10, 70)), #L 100,700
        ]

        body = components.SBody()
        body.shapes = shapes
        self.assertTrue(self.geda_writer.is_valid_path(body))

        body.add_shape(shape.Line((10, 70), (10, 10)))
        self.assertTrue(self.geda_writer.is_valid_path(body))

        shapes = [
            shape.Line((10, 10), (50, 10)), #L 500,100
            shape.BezierCurve((70, 10), (80, 30), (50, 10), (80, 40)), #C 700,100 800,300 800,400
            shape.Line((50, 70), (10, 70)), #L 100,700
        ]
        body.shapes = shapes
        self.assertFalse(self.geda_writer.is_valid_path(body))

        body.add_shape(shape.Circle(0, 0, 10))
        self.assertFalse(self.geda_writer.is_valid_path(body))

    def test_conv_angle(self):
        """ Test conversion of angles from pi radians to degrees. """
        angle_samples = [
            # angle, steps, expected result
            (0.0, 1, 0),
            (0.0, 10.0, 0),
            (0.5, 90, 270),
            (0.8,  1, 216),
            (0.8,  90, 270),
            (1.5,  1, 90),
            (1.5,  90, 90),
        ]

        for angle, steps, expected in angle_samples:
            self.assertEquals(
                self.geda_writer.conv_angle(angle, steps),
                expected
            )

class GEDAWriteTopLevelShapeTests(GEDAWriterTestCase):

    def test_generating_geda_commands_for_toplevel_shapes(self):
        design = Design()
        design.shapes = [
            shape.Line((0, 0), (0, 50)),
            shape.Circle(0, 0, 300),
        ]
        design.pins = [
            components.Pin('E', (0, 0), (0, 30)),
            components.Pin('E', (0, 0), (0, 30)),
        ]
        commands = self.geda_writer.generate_body_commands(design)
        ## default pins require 6 commands, shapes require 1 command
        self.assertEquals(len(commands), 2*6 + 2*1)

########NEW FILE########
__FILENAME__ = gerber_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The gerber writer test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from os import path
import unittest, shutil, tempfile

from nose.tools import raises

from upconvert.core.design import Design
from upconvert.core.layout import Layout, Layer, Image
from upconvert.parser.gerber import Gerber as Parser
from upconvert.writer.gerber import Gerber as Writer
from upconvert.writer.gerber import MissingLayout, NoLayersFound
from upconvert.writer.gerber import UnitsNotSpecified, ImageContainsNoData


STRIP_DIRS = path.join('upconvert', 'writer', 't')
BASE_DIR = path.dirname(__file__).split(STRIP_DIRS)[0]
TEST_FILES = path.join('test', 'gerber', 'unittest')
DIR = path.join(BASE_DIR, TEST_FILES)


# decorator for tests that use input files

def in_out(infile):
    """ Write gerber file based on design from upconvert.parser. """
    def wrap_wrap_tm(test_method):
        """ Add params to decorator function. """
        def wrap_tm(self):
            """ Perform meta operations, then method. """
            outfile = 'out-' + infile
            parser = Parser()
            design = parser.parse(path.join(DIR, infile))
            writer = Writer()
            tmpd = tempfile.mkdtemp()
            writer.write(design, path.join(tmpd, outfile))
            with open(path.join(tmpd, outfile), 'r') as f:
                self.output = f.read()
            test_method(self)
            shutil.rmtree(tmpd)

        # correctly identify the decorated method
        # (otherwise nose will not run the test)
        wrap_tm.__name__ = test_method.__name__
        wrap_tm.__doc__ = test_method.__doc__
        wrap_tm.__dict__.update(test_method.__dict__)
        wrap_wrap_tm.__name__ = wrap_tm.__name__
        wrap_wrap_tm.__doc__ = wrap_tm.__doc__
        wrap_wrap_tm.__dict__.update(wrap_tm.__dict__)

        return wrap_tm
    return wrap_wrap_tm


class GerberTests(unittest.TestCase):
    """ The tests of the gerber writer """

    def setUp(self):
        """ Setup the test case. """
        self.output = None

    # tests that pass if no errors are raised

    def test_create_new_gerber_writer(self):
        """ Create an empty gerber writer. """
        writer = Writer()
        assert writer != None

    @in_out('simple.ger')
    def test_simple(self):
        """ Generate a simple, correct gerber file. """
        start_second_trace = 'X0Y0*\r\nX60000Y0D02*\r\nX110000Y0D01*'
        assert start_second_trace in self.output

    @in_out('arc_segments.ger')
    def test_arcs(self):
        """ Generate connected arcs and lines - gerber. """
        arc_near_eof = 'G03*\r\nX60000Y-05000I10000J20000*'
        assert arc_near_eof in self.output

    @in_out('fills.ger')
    def test_outline_fills(self):
        """ Generate outline fills - gerber. """
        lines_near_eof = 'G01*\r\nX50000Y05000*\r\nG37*\r\nM02*'
        assert lines_near_eof in self.output

    @in_out('smear.ger')
    def test_smear(self):
        """ Generate a smear - gerber. """
        smear_aperture = '%ADD10R,1.0X1.0*%\r\nD10*'
        assert smear_aperture in self.output

    @in_out('complex.ger')
    def test_complex(self):
        """ Generate aperture macros - gerber. """
        start_subtractive_image = '%LPC*%\r\nG36*\r\nX10000Y25000D02*'
        assert start_subtractive_image in self.output

    @in_out('flash-current-pos.ger')
    def test_flash_curr_pos(self):
        """ Correctly handle unusual D03 usage - gerber. """
        shape_instance = 'D10*\r\n%LNUntitled Image*%\r\nX10000Y60000D03*'
        assert shape_instance in self.output

    @in_out('squarish/layers.cfg')
    def test_folder_batch(self):
        """ Parse a batch of gerber files in a folder. """
        layer_boundary = 'copper.ger\r\nTop'
        assert layer_boundary in self.output

    @in_out('simple.zip')
    def test_zip_batch(self):
        """ Parse a batch of gerber files in a zip file. """
        pass

    @in_out('simple.bz2')
    def test_bz_batch(self):
        """ Parse a batch of gerber files in a bz2 tarball. """
        pass

    @in_out('simple.tgz')
    def test_gz_batch(self):
        """ Parse a batch of gerber files in a gz tarball. """
        pass


    # tests that pass if they raise expected errors

    @raises(MissingLayout)
    def test_layout(self):
        """ Capture absence of a layout. """
        design = Design()
        writer = Writer()
        writer.write(design)

    @raises(UnitsNotSpecified)
    def test_units(self):
        """ Capture absence of units. """
        layout = Layout()
        layout.units = None
        layout.layers.append(Layer())
        design = Design()
        design.layout = layout
        writer = Writer()
        writer.write(design)

    @raises(NoLayersFound)
    def test_layers(self):
        """ Capture absence of layers. """
        design = Design()
        design.layout = Layout()
        writer = Writer()
        writer.write(design)

    @raises(ImageContainsNoData)
    def test_images(self):
        """ Capture images with no data. """
        layer = Layer()
        layer.images.append(Image())
        layout = Layout()
        layout.units = 'mm'
        layout.layers.append(layer)
        design = Design()
        design.layout = layout
        writer = Writer()
        writer.write(design)

########NEW FILE########
__FILENAME__ = kicad_t
# encoding: utf-8
#pylint: disable=R0904
""" The kicad writer test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.writer.kicad import KiCAD
from upconvert.core.design import Design
from upconvert.core.components import Pin
from upconvert.core.net import Net, NetPoint
from upconvert.core.component_instance import ComponentInstance, SymbolAttribute
from upconvert.core.shape import Label, Rectangle, Polygon, Arc, BezierCurve
from upconvert.core.annotation import Annotation
from upconvert.parser.kicad import MULT, KiCAD as KiCADParser

import os
import unittest
import tempfile

from cStringIO import StringIO


from upconvert.parser.t.kicad_t import TEST_DIR


class KiCADTests(unittest.TestCase):
    """ The tests of the kicad writer """

    def test_write(self):
        """
        We can write out a complete design file.
        """

        design = KiCADParser().parse(os.path.join(TEST_DIR, 'test/test.sch'))
        writer = KiCAD()
        filedesc, filename = tempfile.mkstemp()
        os.close(filedesc)
        os.remove(filename)
        writer.write(design, filename)
        self.assertTrue(os.path.exists(filename))
        os.remove(filename)

    def test_write_header(self):
        """
        The write_header method produces the right string.
        """

        design = Design()
        design.design_attributes.metadata.updated_timestamp = 0
        writer = KiCAD()
        buf = StringIO()
        writer.write_header(buf, design)
        self.assertEqual(buf.getvalue()[:40], 'EESchema Schematic File Version 2  date ')

    def test_write_libs(self):
        """
        The write_libs method produces the right string.
        """

        writer = KiCAD()
        buf = StringIO()
        writer.write_libs(buf, 'test-cache.sch')
        self.assertEqual(buf.getvalue(), 'LIBS:test-cache\n')

    def test_write_eelayer(self):
        """
        The write_eelayer method produces the correct string.
        """

        writer = KiCAD()
        buf = StringIO()
        writer.write_eelayer(buf)
        self.assertEqual(buf.getvalue(), 'EELAYER 25  0\nEELAYER END\n')

    def test_write_annotation(self):
        """
        The write_annotation method produces the correct string.
        """

        writer = KiCAD()
        buf = StringIO()
        ann = Annotation('test', 1, 2, .5, 'true')
        writer.write_annotation(buf, ann)
        self.assertEqual(buf.getvalue(),
                         'Text Label ' 
                         + str(int(1 / MULT)) + ' '
                         + str(int(-2 / MULT)) + ' '
                         '900 60 ~ 0\ntest\n')

    def test_write_instance(self):
        """
        The write_instance method serializes a component instance
        correctly.
        """

        inst = ComponentInstance('id', None, 'libid', 1)
        inst.add_symbol_attribute(SymbolAttribute(3, 4, 0.5, False))
        writer = KiCAD()
        buf = StringIO()
        writer.write_instance(buf, inst)
        self.assertEqual(buf.getvalue(), '''\
$Comp
L libid id
U 1 1 00000000
P ''' + str(int(3 / MULT)) + ' ' + str(int(-4 / MULT)) + 
'''
\t1    ''' + str(int(3 / MULT)) + ' ' + str(int(-4 / MULT)) + 
'''
\t0    1    1    0
$EndComp
''')

    def test_write_net(self):
        """
        The write_net method creates the correct kicad wires from an
        openjson net.
        """

        net = Net('')
        p1 = NetPoint('p1', 0, 0)
        p2 = NetPoint('p2', 1, 0)
        p3 = NetPoint('p3', 0, 1)

        net.add_point(p1)
        net.add_point(p2)
        net.add_point(p3)

        net.conn_point(p1, p2)
        net.conn_point(p1, p3)

        writer = KiCAD()
        buf = StringIO()
        writer.write_net(buf, net)
        self.assertEqual(
            buf.getvalue(),
            'Wire Wire Line\n\t0 0 0 ' + str(int(-1 / MULT)) + 
            '\nWire Wire Line\n\t0 0 ' + str(int(1 / MULT)) + 
            ' 0\n')

    def test_write_footer(self):
        """
        The write_footer method produces the correct string.
        """

        writer = KiCAD()
        buf = StringIO()
        writer.write_footer(buf)
        self.assertEqual(buf.getvalue(), '$EndSCHEMATC\n')

    def test_get_pin_line(self):
        """
        The get_pin_line returns the correct string for a kicad pin.
        """

        writer = KiCAD()

        pin = Pin('1', (-300, 100), (-600, 100))
        line = writer.get_pin_line(pin)
        self.assertEqual(
            line, 'X ~ 1 ' 
            + str(int(-600 / MULT)) + ' ' 
            + str(int(100 / MULT)) + ' ' 
            + str(int(300 / MULT)) + ' ' 
            + 'R 60 60 %(unit)d %(convert)d B\n')

        pin = Pin('1', (300, 100), (600, 100))
        line = writer.get_pin_line(pin)
        self.assertEqual(
            line, 'X ~ 1 '
            + str(int(600 / MULT)) + ' '
            + str(int(100 / MULT)) + ' '
            + str(int(300 / MULT)) + ' '
            + 'L 60 60 %(unit)d %(convert)d B\n')

        pin = Pin('2', (0, -1300), (0, -1500))
        line = writer.get_pin_line(pin)
        self.assertEqual(
            line, 'X ~ 2 0 '
            + str(int(-1500 / MULT)) + ' '
            + str(int(200 / MULT)) + ' U 60 60 %(unit)d %(convert)d B\n')

        pin = Pin('2', (0, 1300), (0, 1500))
        line = writer.get_pin_line(pin)
        self.assertEqual(
            line, 'X ~ 2 0 '
            + str(int(1500 / MULT)) + ' '
            + str(int(200 / MULT)) + ' D 60 60 %(unit)d %(convert)d B\n')

        pin = Pin('2', (0, 1300), (0, 1500),
                  Label(0, 0, 'name', align='center', rotation=0))
        line = writer.get_pin_line(pin)
        self.assertEqual(
            line, 'X name 2 0 '
            + str(int(1500 / MULT)) + ' '
            + str(int(200 / MULT)) + ' D 60 60 %(unit)d %(convert)d B\n')

    def test_write_library_footer(self):
        """
        The write_library_footer produces the correct string.
        """

        writer = KiCAD()
        buf = StringIO()
        writer.write_library_footer(buf)
        self.assertEqual(buf.getvalue(), '#\n#End Library\n')


    def test_rectangle(self):
        """
        Rectangles are output correctly.
        """

        writer = KiCAD()
        rect = Rectangle(10, 20, 5, 10)
        line = writer.get_shape_line(rect)
        self.assertEqual(line, 'S ' + str(int(10 / MULT)) + ' '
            + str(int(20 / MULT)) + ' '
            + str(int(15 / MULT)) + ' '
            + str(int(10 / MULT)) + ' '
            + '%(unit)d %(convert)d 0 N\n')


    def test_polygon(self):
        """
        Polygons are output correctly.
        """

        writer = KiCAD()
        poly = Polygon()
        poly.add_point(0, 0)
        poly.add_point(0, 10)
        poly.add_point(10, 10)
        poly.add_point(10, 0)
        line = writer.get_shape_line(poly)
        self.assertEqual(line, 'P 5 %(unit)d %(convert)d 0 0 0 0 '
            + str(int(10 / MULT)) + ' '
            + str(int(10 / MULT)) + ' '
            + str(int(10 / MULT)) + ' '
            + str(int(10 / MULT)) + ' '
            + '0 0 0 N\n')


    def test_arc(self):
        """
        Arcs are output correctly.
        """

        writer = KiCAD()
        arc = Arc(0, 0, -0.5, 0.5, 1)
        line = writer.get_shape_line(arc)
        self.assertEqual(line, 'A 0 0 ' + str(int(1 / MULT)) 
            + ' 900 -900 %(unit)d %(convert)d 0 N\n')


    def test_bezier_curve(self):
        """
        BezierCurves are output correctly.
        """

        writer = KiCAD()
        bezier = BezierCurve((0, 0), (1, 1), (2, 2), (3, 3))
        line = writer.get_shape_line(bezier)
        self.assertEqual(line, 'P 2 %(unit)d %(convert)d 0 ' 
            + str(int(2 / MULT)) + ' ' + str(int(2 / MULT)) + ' ' 
            + str(int(3 / MULT)) + ' ' 
            + str(int(3 / MULT)) + ' N\n')

########NEW FILE########
__FILENAME__ = openjson_t
#!/usr/bin/python
# encoding: utf-8
#pylint: disable=R0904
""" The openjson writer test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.writer.openjson import JSON
import unittest


class JSONTests(unittest.TestCase):
    """ The tests of the json writer """

    def setUp(self):
        """ Setup the test case. """
        pass

    def tearDown(self):
        """ Teardown the test case. """
        pass

    def test_create_new_json_writer(self):
        """ Test creating an empty writer. """
        writer = JSON()
        assert writer != None

########NEW FILE########
__FILENAME__ = specctra_t
# encoding: utf-8
#pylint: disable=R0904
""" The specctra writer test class """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from upconvert.writer.specctra import Specctra
from upconvert.core.component_instance import ComponentInstance, SymbolAttribute
from upconvert.core.shape import Rectangle, Polygon, Arc, BezierCurve, Circle
from upconvert.parser import specctraobj

import unittest

def to_string(writer, obj):
    if isinstance(obj, list):
        buf = writer._to_string([o.compose() for o in obj]).replace('\n', '')
    else:
        buf = writer._to_string(obj.compose()).replace('\n', '')
    return ' '.join(buf.split())

class SpecctraTests(unittest.TestCase):
    """ The tests of the specctra writer """


    def test_write_instance(self):
        """ Convert component instance """
        inst = ComponentInstance('id', None, 'libid', 1)
        inst.add_symbol_attribute(SymbolAttribute(3, 4, 0.5, False))
        writer = Specctra()
        writer.resolution = specctraobj.Resolution()
        writer.resolution.unit = 'mil'
        writer.resolution.resolution = 10
        obj = writer._convert_component_instance(inst)
        self.assertEqual(
                to_string(writer, obj),
                '(component libid-1 (place id 31.250000 41.666667 front 270) )')

    def test_circle(self):
        """ Convert circle shape """

        circle = Circle(10, 20, 10)
        writer = Specctra()
        writer.resolution = specctraobj.Resolution()
        writer.resolution.unit = 'mil'
        writer.resolution.resolution = 10
        obj = writer._convert_shape(circle)
        self.assertEqual(
                to_string(writer, obj),
                '( (circle signal 208.333333 104.166667 208.333333) )')

    def test_rectangle(self):
        """ Convert rectangle shape """

        rect = Rectangle(10, 20, 5, 10)
        writer = Specctra()
        writer.resolution = specctraobj.Resolution()
        writer.resolution.unit = 'mil'
        writer.resolution.resolution = 10
        obj = writer._convert_shape(rect)
        self.assertEqual(
                to_string(writer, obj),
                '( (rect signal 104.166667 208.333333 156.250000 104.166667) )')

    def test_polygon(self):
        """ Convert polygon shape """

        poly = Polygon()
        poly.add_point(0, 0)
        poly.add_point(0, 10)
        poly.add_point(10, 10)
        poly.add_point(10, 0)
        writer = Specctra()
        writer.resolution = specctraobj.Resolution()
        writer.resolution.unit = 'mil'
        writer.resolution.resolution = 10
        obj = writer._convert_shape(poly)
        self.assertEqual(
                to_string(writer, obj), 
                '( (polygon signal 10.416667 0.000000 0.000000 0.000000 104.166667 104.166667' +
                ' 104.166667 104.166667 0.000000) )')

    def test_arc(self):
        """ Convert arc to lines shape """

        arc = Arc(0, 0, -0.5, 0.5, 1)
        writer = Specctra()
        writer.resolution = specctraobj.Resolution()
        writer.resolution.unit = 'mil'
        writer.resolution.resolution = 10
        obj = writer._convert_shape(arc)
        self.assertEqual(
                to_string(writer, obj), 
                '( (path signal 10.416667 -0.000000 -10.416667 -6.122763 -8.427260)' +
                    ' (path signal 10.416667 -6.122763 -8.427260 -9.906839 -3.218927)' +
                    ' (path signal 10.416667 -9.906839 -3.218927 -9.906839 3.218927)' +
                    ' (path signal 10.416667 -9.906839 3.218927 -6.122763 8.427260)' +
                    ' (path signal 10.416667 -6.122763 8.427260 -0.000000 10.416667) )')

    def test_bezier_curve(self):
        """ Convert bezier to lines shape """

        bezier = BezierCurve((0, 0), (1, 1), (2, 2), (3, 3))
        writer = Specctra()
        writer.resolution = specctraobj.Resolution()
        writer.resolution.unit = 'mil'
        writer.resolution.resolution = 10
        obj = writer._convert_shape(bezier)
        self.assertEqual(
                to_string(writer, obj),
                '( (path signal 10.416667 20.833333 20.833333 20.833333 20.833333)' +
                ' (path signal 10.416667 20.833333 20.833333 10.416667 10.416667)' +
                ' (path signal 10.416667 10.416667 10.416667 10.416667 10.416667)' +
                ' (path signal 10.416667 10.416667 10.416667 10.416667 10.416667)' +
                ' (path signal 10.416667 10.416667 10.416667 10.416667 10.416667)' +
                ' (path signal 10.416667 10.416667 10.416667 10.416667 10.416667)' +
                ' (path signal 10.416667 10.416667 10.416667 10.416667 10.416667)' +
                ' (path signal 10.416667 10.416667 10.416667 20.833333 20.833333)' +
                ' (path signal 10.416667 20.833333 20.833333 20.833333 20.833333)' +
                ' (path signal 10.416667 20.833333 20.833333 20.833333 20.833333)' +
                ' (path signal 10.416667 20.833333 20.833333 31.250000 31.250000) )')

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = viewdraw
#!/usr/bin/env python2
""" The Viewdraw Format Writer """

# upconvert - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


class Viewdraw(object):
    """ The Viewdraw Format Writer """

    def write(self, design, filename):
        """ Write the design to the Viewdraw format """

        with open(filename, "w") as f:
            f.write('Viewdraw export is currently unsupported')
            design = design

########NEW FILE########
