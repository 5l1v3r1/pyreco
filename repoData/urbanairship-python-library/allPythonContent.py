__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Urban Airship Python Library documentation build configuration file, created by
# sphinx-quickstart on Fri Jun 14 13:52:06 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Urban Airship Python Library'
copyright = u'2013, Urban Airship'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = open('../VERSION.txt').read().strip().rstrip('b').rstrip('a')
# The full version, including alpha/beta/rc tags.
release = open('../VERSION.txt').read().strip()

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'urbanairship'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'UrbanAirshipPythonLibrarydoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'UrbanAirshipPythonLibrary.tex', u'Urban Airship Python Library Documentation',
   u'Urban Airship', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'urbanairshippythonlibrary', u'Urban Airship Python Library Documentation',
     [u'Urban Airship'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'UrbanAirshipPythonLibrary', u'Urban Airship Python Library Documentation',
   u'Urban Airship', 'UrbanAirshipPythonLibrary', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

autodoc_member_order = 'bysource'

########NEW FILE########
__FILENAME__ = test_audience
import unittest

import urbanairship as ua


class TestAudience(unittest.TestCase):

    def test_basic_selectors(self):
        selectors = (
            (ua.device_token, 'f' * 64,
                {'device_token': 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'}),
            (ua.device_token, '0' * 64,
                {'device_token': '0000000000000000000000000000000000000000000000000000000000000000'}),
            (ua.device_pin, '12345678', {'device_pin': '12345678'}),
            (ua.apid, '074e84a2-9ed9-4eee-9ca4-cc597bfdbef3',
                {'apid': '074e84a2-9ed9-4eee-9ca4-cc597bfdbef3'}),
            (ua.wns, '074e84a2-9ed9-4eee-9ca4-cc597bfdbef3',
                {'wns': '074e84a2-9ed9-4eee-9ca4-cc597bfdbef3'}),
            (ua.mpns, '074e84a2-9ed9-4eee-9ca4-cc597bfdbef3',
                {'mpns': '074e84a2-9ed9-4eee-9ca4-cc597bfdbef3'}),
            (ua.tag, 'test', {'tag': 'test'}),
            (ua.alias, 'test', {'alias': 'test'}),
            (ua.segment, 'test', {'segment': 'test'}),
        )

        for selector, value, result in selectors:
            self.assertEqual(selector(value), result)

    def test_invalid_device_selectors(self):
        selectors = (
            (ua.device_token, 'f' * 63),
            (ua.device_token, 'f' * 65),
            (ua.device_token, '0123'),
            (ua.device_token, 'X' * 64),
            (ua.device_pin, '1234567'),
            (ua.device_pin, 'x' * 8),
            (ua.apid, 'foobar'),
            (ua.apid, '074e84a2-9ed9-4eee-9ca4-cc597bfdbef33'),
            (ua.apid, '074e84a2-9ed9-4eee-9ca4-cc597bfdbef'),
            (ua.wns, '074e84a2-9ed9-4eee-9ca4-cc597bfdbef'),
            (ua.mpns, '074e84a2-9ed9-4eee-9ca4-cc597bfdbef'),
        )

        for selector, value in selectors:
            self.assertRaises(ValueError, selector, value)

    def test_compound_selectors(self):
        self.assertEqual(
            ua.or_(ua.tag('foo'), ua.tag('bar')),
            {'or': [{'tag': 'foo'}, {'tag': 'bar'}]})

        self.assertEqual(
            ua.and_(ua.tag('foo'), ua.tag('bar')),
            {'and': [{'tag': 'foo'}, {'tag': 'bar'}]})

        self.assertEqual(
            ua.not_(ua.tag('foo')),
            {'not': {'tag': 'foo'}})

    def test_time_period_selector(self):
        self.assertEqual(ua.recent_date(days=4), {"recent": {"days": 4}})
        self.assertEqual(
            ua.recent_date(days=4, last_seen=True),
            {"recent": {"days": 4}, "last_seen": True})
        self.assertEqual(
            ua.absolute_date(resolution='days', start='2012-01-01',
                end='2012-01-15'),
            {"days": {"start": '2012-01-01', 'end': '2012-01-15'}})
        self.assertEqual(
            ua.absolute_date(resolution='weeks', start='2012-01-01',
                end='2012-01-15', last_seen=True),
            {"weeks": {'start': '2012-01-01', 'end': '2012-01-15'},
             'last_seen': True})

        # Invalid time periods
        self.assertRaises(ValueError, ua.recent_date, hours=1, minutes=1)
        self.assertRaises(ValueError, ua.recent_date, eons=1)
        self.assertRaises(ValueError, ua.absolute_date,
            'eons', 'alpha', 'omega')

    def test_location_selector(self):
        self.assertEqual(
            ua.location(
                id='a_location_id',
                date=ua.recent_date(days=4)),
            {"location": {
                "id": "a_location_id",
                "date": {
                    "recent": {"days": 4}
                }
            }})

        self.assertRaises(ValueError, ua.location)
        self.assertRaises(ValueError, ua.location, alias=1, id=1)
        self.assertRaises(ValueError, ua.location, date=None, id='foobar')

########NEW FILE########
__FILENAME__ = test_message
import unittest

import urbanairship as ua


class TestMessage(unittest.TestCase):

    def test_simple_alert(self):
        self.assertEqual(
            ua.notification(alert='Hello'),
            {'alert': 'Hello'})

    def test_ios(self):
        self.assertEqual(
            ua.notification(ios=ua.ios(
                alert='Hello',
                badge='+1',
                sound='cat.caf',
                extra={'more': 'stuff'}
            )),
            {'ios': {
                'alert': 'Hello',
                'badge': '+1',
                'sound': 'cat.caf',
                'extra': {
                    'more': 'stuff',
                }
            }})

        self.assertEqual(
            ua.notification(ios=ua.ios(content_available=True)),
            {'ios': { 'content-available': True}})

    def test_android(self):
        self.assertEqual(
            ua.notification(android=ua.android(
                alert='Hello',
                delay_while_idle=True,
                collapse_key='123456',
                time_to_live=100,
                extra={'more': 'stuff'}
            )),
            {'android': {
                'alert': 'Hello',
                'delay_while_idle': True,
                'collapse_key': '123456',
                'time_to_live': 100,
                'extra': {
                    'more': 'stuff',
                }
            }})

    def test_blackberry(self):
        self.assertEqual(
            ua.notification(blackberry=ua.blackberry(
                alert='Hello',
            )),
            {'blackberry': {
                'body': 'Hello',
                'content_type': 'text/plain',
            }})

        self.assertEqual(
            ua.notification(blackberry=ua.blackberry(
                body='Hello', content_type='text/html',
            )),
            {'blackberry': {
                'body': 'Hello',
                'content_type': 'text/html',
            }})
        self.assertRaises(ValueError, ua.blackberry, body='Hello')

    def test_wns_payload(self):
        self.assertEqual(
            ua.notification(wns=ua.wns_payload(
                alert='Hello',
            )),
            {'wns': {
                'alert': 'Hello',
            }})

        self.assertEqual(
            ua.notification(wns=ua.wns_payload(
                toast={'key': 'value'},
            )),
            {'wns': {
                'toast': {'key': 'value'},
            }})

        self.assertEqual(
            ua.notification(wns=ua.wns_payload(
                tile={'key': 'value'},
            )),
            {'wns': {
                'tile': {'key': 'value'},
            }})

        self.assertEqual(
            ua.notification(wns=ua.wns_payload(
                badge={'key': 'Hello'},
            )),
            {'wns': {
                'badge': {'key': 'Hello'},
            }})
        self.assertRaises(ValueError, ua.wns_payload, alert='Hello',
            tile='Foo')

    def test_mpns_payload(self):
        self.assertEqual(
            ua.notification(mpns=ua.mpns_payload(
                alert='Hello',
            )),
            {'mpns': {
                'alert': 'Hello',
            }})

        self.assertEqual(
            ua.notification(mpns=ua.mpns_payload(
                toast={'key': 'Hello'},
            )),
            {'mpns': {
                'toast': {'key': 'Hello'},
            }})

        self.assertEqual(
            ua.notification(mpns=ua.mpns_payload(
                tile={'key': 'Hello'},
            )),
            {'mpns': {
                'tile': {'key': 'Hello'},
            }})
        self.assertRaises(ValueError, ua.mpns_payload, alert='Hello',
            tile='Foo')

    def test_rich_push(self):
        self.assertEqual(
            ua.message("My Title", "My Body", content_type='text/html',
                content_encoding='utf8'),
            {
                'title': 'My Title',
                'body': 'My Body',
                'content_type': 'text/html',
                'content_encoding': 'utf8',
            })
        self.assertEqual(
            ua.message("My Title", "My Body"),
            {'title': 'My Title', 'body': 'My Body'})

    def test_all_device_types(self):
        self.assertEqual(ua.device_types(ua.all_), 'all')

    def test_invalid_payloads(self):
        # Base notification
        self.assertRaises(ValueError, ua.notification)

        # iOS
        self.assertRaises(ValueError, ua.ios, alert=100)
        self.assertRaises(ValueError, ua.ios, badge=object())
        self.assertRaises(ValueError, ua.ios, badge="++100!")

########NEW FILE########
__FILENAME__ = test_push
import datetime
import json
import unittest

import mock
import requests

import urbanairship as ua


class TestPush(unittest.TestCase):

    def test_full_payload(self):
        p = ua.Push(None)
        p.audience = ua.all_
        p.notification = ua.notification(alert='Hello')
        p.options = {}
        p.device_types = ua.all_
        p.message = ua.message("Title", "Body", "text/html", "utf8")

        self.assertEqual(p.payload, {
            "audience": "all",
            "notification": {"alert": "Hello"},
            "device_types": "all",
            "options": {},
            "message": {
                "title": "Title",
                "body": "Body",
                "content_type": "text/html",
                "content_encoding": "utf8",
            }
        })

    def test_full_scheduled_payload(self):
        p = ua.Push(None)
        p.audience = ua.all_
        p.notification = ua.notification(alert='Hello')
        p.options = {}
        p.device_types = ua.all_
        p.message = ua.message("Title", "Body", "text/html", "utf8")
        sched = ua.ScheduledPush(None)
        sched.push = p
        sched.name = "a schedule"
        sched.schedule = ua.scheduled_time(
            datetime.datetime(2014, 1, 1, 12, 0, 0))

        self.assertEqual(sched.payload, {
            "name": "a schedule",
            "schedule": {'scheduled_time': '2014-01-01T12:00:00'},
            "push": {
                "audience": "all",
                "notification": {"alert": "Hello"},
                "device_types": "all",
                "options": {},
                "message": {
                    "title": "Title",
                    "body": "Body",
                    "content_type": "text/html",
                    "content_encoding": "utf8",
                },
            }
        })

    def test_push_success(self):
        with mock.patch.object(ua.Airship, '_request') as mock_request:
            response = requests.Response()
            response._content = (
                '''{"push_ids": ["0492662a-1b52-4343-a1f9-c6b0c72931c0"]}''')
            response.status_code = 202
            mock_request.return_value = response

            airship = ua.Airship('key', 'secret')
            push = airship.create_push()
            push.audience = ua.all_
            push.notification = ua.notification(alert='Hello')
            push.options = {}
            push.device_types = ua.all_
            pr = push.send()
            self.assertEqual(
                pr.push_ids, ['0492662a-1b52-4343-a1f9-c6b0c72931c0'])

    def test_schedule_success(self):
        with mock.patch.object(ua.Airship, '_request') as mock_request:
            response = requests.Response()
            response._content = (
                '''{"schedule_urls": ["https://go.urbanairship.com/api/schedules/0492662a-1b52-4343-a1f9-c6b0c72931c0"]}''')
            response.status_code = 202
            mock_request.return_value = response

            airship = ua.Airship('key', 'secret')
            sched = ua.ScheduledPush(airship)
            push = airship.create_push()
            push.audience = ua.all_
            push.notification = ua.notification(alert='Hello')
            push.device_types = ua.all_
            sched.push = push
            sched.schedule = ua.scheduled_time(datetime.datetime.now())
            sched.send()

            self.assertEquals(sched.url,
                "https://go.urbanairship.com/api/schedules/0492662a-1b52-4343-a1f9-c6b0c72931c0")

    def test_schedule_from_url(self):
        with mock.patch.object(ua.Airship, '_request') as mock_request:
            response = requests.Response()
            response._content = json.dumps({
                "name": "a schedule",
                "schedule": {"scheduled_time": "2013-07-15T18:40:20"},
                "push": {
                    "audience": "all",
                    "notification": {"alert": "Hello"},
                    "device_types": "all",
                    "options": {},
                    "message": {
                        "title": "Title",
                        "body": "Body",
                        "content_type": "text/html",
                        "content_encoding": "utf8",
                    },
                },
            })

            response.status_code = 200
            mock_request.return_value = response

            url = "https://go.urbanairship.com/api/schedules/0492662a-1b52-4343-a1f9-c6b0c72931c0"

            airship = ua.Airship('key', 'secret')
            sched = ua.ScheduledPush.from_url(airship, url)

            self.assertEqual(sched.push.device_types, 'all')

    def test_cancel(self):
        airship = ua.Airship('key', 'secret')
        sched = ua.ScheduledPush(airship)

        # Fail w/o URL
        self.assertRaises(ValueError, sched.cancel)

        with mock.patch.object(ua.Airship, '_request') as mock_request:
            response = requests.Response()
            response.status_code = 204
            mock_request.return_value = response

            url = "https://go.urbanairship.com/api/schedules/0492662a-1b52-4343-a1f9-c6b0c72931c0"

            sched.url = url

            sched.cancel()

    def test_update_schedule(self):
        airship = ua.Airship('key', 'secret')
        sched = ua.ScheduledPush(airship)
        # Fail w/o URL
        self.assertRaises(ValueError, sched.update)

        with mock.patch.object(ua.Airship, '_request') as mock_request:
            url = "https://go.urbanairship.com/api/schedules/0492662a-1b52-4343-a1f9-c6b0c72931c0"

            response = requests.Response()
            response.status_code = 202
            response._content = (
                '''{"schedule_urls": ["https://go.urbanairship.com/api/schedules/0492662a-1b52-4343-a1f9-c6b0c72931c0"]}''')

            mock_request.return_value = response

            sched.url = url
            push = airship.create_push()
            push.audience = ua.all_
            push.notification = ua.notification(alert='Hello')
            push.device_types = ua.all_
            sched.push = push
            sched.schedule = ua.scheduled_time(datetime.datetime.now())

            sched.update()

########NEW FILE########
__FILENAME__ = test_schedule
import datetime
import unittest

import urbanairship as ua


class TestSchedule(unittest.TestCase):

    def test_scheduled_time(self):
        d = datetime.datetime(2013, 1, 1, 12, 56)
        self.assertEqual(ua.scheduled_time(d),
            {'scheduled_time': '2013-01-01T12:56:00'})


########NEW FILE########
__FILENAME__ = common
import json
import logging


SERVER = 'go.urbanairship.com'
BASE_URL = "https://go.urbanairship.com/api"
DEVICE_TOKEN_URL = BASE_URL + '/device_tokens/'
APID_URL = BASE_URL + '/apids/'
DEVICE_PIN_URL = BASE_URL + '/device_pins/'
PUSH_URL = BASE_URL + '/push/'
BATCH_PUSH_URL = BASE_URL + '/push/batch/'
BROADCAST_URL = BASE_URL + '/push/broadcast/'
FEEDBACK_URL = BASE_URL + '/device_tokens/feedback/'
RICH_PUSH_SEND_URL = BASE_URL + '/airmail/send/'
RICH_PUSH_BROADCAST_URL = BASE_URL + '/airmail/send/broadcast/'
SCHEDULES_URL = BASE_URL + '/schedules/'


logger = logging.getLogger('urbanairship')


class Unauthorized(Exception):
    """Raised when we get a 401 from the server"""


class AirshipFailure(Exception):
    """Raised when we get an error response from the server.


    :param args: For backwards compatibility, ``*args`` includes the status and
        response body.

    """

    error = None
    error_code = None
    details = None
    response = None

    def __init__(self, error, error_code, details, response, *args):
        self.error = error
        self.error_code = error_code
        self.details = details
        self.response = response
        super(AirshipFailure, self).__init__(*args)

    @classmethod
    def from_response(cls, response):
        """Instantiate a ValidationFailure from a Response object"""

        try:
            payload = response.json()
            error = payload.get('error')
            error_code = payload.get('error_code')
            details = payload.get('details')
        except ValueError:
            error = response.reason
            error_code = None
            details = response.content

        logger.error(
            "Request failed with status %d: '%s %s': %s",
            response.status_code, error_code, error, json.dumps(details))

        return cls(error, error_code, details, response, response.status_code,
            response.content)

########NEW FILE########
__FILENAME__ = core
import json
import logging
import warnings

import requests

from . import common, __about__
from .push import Push, ScheduledPush


logger = logging.getLogger('urbanairship')


class AirshipDeviceList(object):
    """Iterator that fetches and returns a list of device tokens

    Follows pagination

    """

    def __init__(self, airship):
        self._airship = airship
        self._load_page(common.DEVICE_TOKEN_URL)

    def __iter__(self):
        return self

    def next(self):
        try:
            return self._token_iter.next()
        except StopIteration:
            self._fetch_next_page()
            return self._token_iter.next()

    def __len__(self):
        return self._page['device_tokens_count']

    def _fetch_next_page(self):
        next_page = self._page.get('next_page')
        if not next_page:
            return
        self._load_page(next_page)

    def _load_page(self, url):
        response = self._airship._request('GET', None, url, version=1)
        self._page = page = response.json()
        self._token_iter = iter(page['device_tokens'])


class Airship(object):

    def __init__(self, key, secret):
        self.key = key
        self.secret = secret

        self.session = requests.Session()
        self.session.auth = (key, secret)


    def _request(self, method, body, url, content_type=None,
            version=None, params=None):

        headers = \
                {'User-agent': "UAPythonLib/{0}".format(__about__.__version__)}
        if content_type:
            headers['content-type'] = content_type
        if version is not None:
            headers['Accept'] = \
                "application/vnd.urbanairship+json; version=%d;" % version

        logger.debug("Making %s request to %s. Headers:\n\t%s\nBody:\n\t%s",
            method, url, '\n\t'.join(
                '%s: %s' % (key, value) for (key, value) in headers.items()),
            body)

        response = self.session.request(
            method, url, data=body, params=params, headers=headers)

        logger.debug("Received %s response. Headers:\n\t%s\nBody:\n\t%s",
            response.status_code, '\n\t'.join(
                '%s: %s' % (key, value) for (key, value)
                in response.headers.items()),
            response.content)

        if response.status_code == 401:
            raise common.Unauthorized
        elif not (200 <= response.status_code < 300):
            raise common.AirshipFailure.from_response(response)

        return response

    def register(self, device_token, alias=None, tags=None, badge=None,
            quiettime_start=None, quiettime_end=None, tz=None):
        """Register the device token with UA."""
        url = common.DEVICE_TOKEN_URL + device_token
        payload = {}
        if alias is not None:
            payload['alias'] = alias
        if tags is not None:
            payload['tags'] = tags
        if badge is not None:
            payload['badge'] = badge
        if quiettime_start is not None and quiettime_end is not None:
            payload['quiettime'] = {
                "start": quiettime_start,
                "end": quiettime_end,
            }
        if tz is not None:
            payload['tz'] = tz
        if payload:
            body = json.dumps(payload)
            content_type = 'application/json'
        else:
            body = ''
            content_type = None

        response = self._request('PUT', body, url, content_type,
            version=1)
        return response.status_code == 201

    def deregister(self, device_token):
        """Mark this device token as inactive"""
        url = common.DEVICE_TOKEN_URL + device_token
        self._request('DELETE', '', url, None, version=1)

    def get_device_token_info(self, device_token):
        """Retrieve information about this device token"""
        url = common.DEVICE_TOKEN_URL + device_token
        response = self._request('GET', None, url, version=1)
        return response.json()

    def get_apid_info(self, apid):
        """Retrieve information about this Android APID"""
        url = common.APID_URL + apid
        response = self._request('GET', None, url, version=1)
        return response.json()

    def get_device_pin_info(self, device_pin):
        """Retrieve information about this BlackBerry PIN"""
        url = common.DEVICE_PIN_URL + device_pin
        response = self._request('GET', None, url, version=1)
        return response.json()

    def get_device_tokens(self):
        return AirshipDeviceList(self)

    def push(self, payload, device_tokens=None, aliases=None, tags=None,
            apids=None, device_pins=None, schedules=None):
        """Push this payload to the specified recipients.

        Payload: a dictionary the contents to send, e.g.:
            {'aps': {'alert': 'Hello'}, 'android': {'alert': 'Hello'}}
        device_tokens, apids, aliases, tags, device_pins:
            lists of identifiers to send the notification to
        schedules: list of datetime.datetime objects of when to send this
            notification. If no schedules are present, send immediately.
            Schedules should be in UTC time, not local.

        """
        warnings.warn(
            "Airship.push() is deprecated. See documentation on upgrading.",
            DeprecationWarning)
        if device_tokens:
            payload['device_tokens'] = device_tokens
        if apids:
            payload['apids'] = apids
        if device_pins:
            payload['device_pins'] = device_pins
        if aliases:
            payload['aliases'] = aliases
        if tags:
            payload['tags'] = tags
        if schedules:
            payload['schedule_for'] = [
                schedule.isoformat() for schedule in schedules]
        body = json.dumps(payload)
        self._request('POST', body, common.PUSH_URL,
            'application/json', version=1)

    def batch_push(self, payloads):
        """Push the following payloads as a batch.

        For payload details see:

          http://urbanairship.com/docs/push.html#batch-push

        Summary:
          List of dictionaries, each with:
            * 0 or more "device_tokens", "apids", or "device_pins"
            * 0 or more "aliases" or "tags"
            * "aps" payload, "android" payload, and/or "blackberry".
        """
        warnings.warn(
            "Airship.batch_push() is deprecated. See documentation on upgrading.",
            DeprecationWarning)
        body = json.dumps(payloads)

        self._request('POST', body, common.BATCH_PUSH_URL,
            'application/json', version=1)

    def broadcast(self, payload, exclude_tokens=None, schedules=None):
        """Broadcast this payload to all users."""
        warnings.warn(
            "Airship.broadcast() is deprecated. See documentation on upgrading.",
            DeprecationWarning)
        if exclude_tokens:
            payload['exclude_tokens'] = exclude_tokens
        if schedules:
            payload['schedule_for'] = [
                schedule.isoformat() for schedule in schedules]
        body = json.dumps(payload)
        self._request('POST', body, common.BROADCAST_URL,
            'application/json', version=1)

    def feedback(self, since):
        """Return device tokens marked inactive since this timestamp.

        Returns a list of (device token, timestamp, alias) functions.

        Example:
            airship.feedback(datetime.datetime.utcnow()
                - datetime.timedelta(days=1))

        Note:
            In order to parse the result, we need a sane date parser,
            dateutil: http://labix.org/python-dateutil

        """
        url = common.FEEDBACK_URL
        response = self._request('GET', '', url,
            params={'since': since.isoformat()}, version=1)
        data = response.json()
        try:
            from dateutil.parser import parse
        except ImportError:
            def parse(x):
                return x
        return [
            (r['device_token'], parse(r['marked_inactive_on']), r['alias'])
            for r in data]

    def create_push(self):
        """Create a Push notification."""
        return Push(self)

    def create_scheduled_push(self):
        """Create a Scheduled Push notification."""
        return ScheduledPush(self)

    def create_rich_push(self):
        """Create a RichPush message."""
        warnings.warn(
            "Airship.create_rich_push() is deprecated. See documentation on upgrading.",
            DeprecationWarning)
        return RichPush(self)


class RichPush(object):
    """A Rich Push message. Set recipients, message, and options, then send."""

    def __init__(self, airship):
        self._airship = airship
        self.users = []
        self.aliases = []
        self.tags = []
        self.title = None
        self.message = None
        self.content_type = None
        self.push = None
        self.extra = None

    def add_recipients(self, users=None, aliases=None, tags=None):
        """Add one or more user IDs, aliases, or tags."""

        if users is not None:
            self.users = users
        if aliases is not None:
            self.aliases = aliases
        if tags is not None:
            self.tags = tags

    def set_message(self, title, message, content_type='text/html'):
        """Set the Rich Push title and message body."""

        self.title = title
        self.message = message
        self.content_type = content_type
        if self.push is None:
            self.push = {"aps": {"alert": title}}

    def set_push(self, push):
        """Specify the push notification payload to be delivered.

        Default is to send an alert to iOS devices with the specified title.
        """

        self.push = push

    def set_extra(self, **kw):
        """Set extra key and values for the rich push message."""

        self.extra = kw

    def send(self):
        """Send the rich push message."""

        if not self.users and not self.aliases and not self.tags:
            raise ValueError("No recipients specified")
        payload = {
            "title": self.title,
            "message": self.message,
            "content-type": self.content_type,
        }
        if self.push:
            payload['push'] = self.push
        if self.users:
            payload['users'] = self.users
        if self.aliases:
            payload['aliases'] = self.aliases
        if self.tags:
            payload['tags'] = self.tags
        if self.extra:
            payload['extra'] = self.extra
        body = json.dumps(payload)
        self._airship._request('POST', body,
            common.RICH_PUSH_SEND_URL, 'application/json', version=1)

    def broadcast(self):
        """Broadcast the rich push message to all users."""

        if self.users or self.aliases or self.tags:
            raise ValueError("Recipients cannot be specified for a broadcast")
        payload = {
            "title": self.title,
            "message": self.message,
            "content-type": self.content_type,
        }
        if self.push:
            payload['push'] = self.push
        if self.extra:
            payload['extra'] = self.extra
        body = json.dumps(payload)
        self._airship._request('POST', body,
            common.RICH_PUSH_BROADCAST_URL, 'application/json', version=1)


########NEW FILE########
__FILENAME__ = devicelist
from urbanairship import common

class DeviceInfo(object):
    """Information object for a single device token.

    :ivar id: Device identifier. Also available at the attribute named by the
        ``device_type``.
    :ivar device_type: Type of the device, e.g. ``device_token``
    :ivar active: bool; whether this device can receive notifications.
    :ivar tags: list of tags associated with this device, if any.
    :ivar alias: alias associated with this device, if any.

    """
    id = None
    device_type = None
    active = None
    tags = None
    alias = None

    @classmethod
    def from_payload(cls, payload, device_key):
        """Create based on results from a DeviceList iterator."""
        obj = cls()
        obj.id = payload[device_key]
        obj.device_type = device_key
        for key in payload:
            setattr(obj, key, payload[key])
        return obj


class DeviceList(object):
    start_url = NotImplemented
    next_url = None
    limit = None
    data_attribute = NotImplemented
    id_key = NotImplemented

    def __init__(self, airship, limit=None):
        self._airship = airship
        self.next_url = self.start_url
        self._token_iter = iter(())
        if limit is not None:
            self.limit = limit

    def __iter__(self):
        return self

    def next(self):
        try:
            return DeviceInfo.from_payload(self._token_iter.next(), self.id_key)
        except StopIteration:
            self._fetch_next_page()
            return DeviceInfo.from_payload(self._token_iter.next(), self.id_key)

    def _fetch_next_page(self):
        if not self.next_url:
            return
        self._load_page(self.next_url)
        self.next_url = self._page.get('next_page')

    def _load_page(self, url):
        params = {'limit': self.limit} if self.limit is not None else {}
        response = self._airship._request('GET', None, url, version=3, params=params)
        self._page = page = response.json()
        self._token_iter = iter(page[self.data_attribute])


class DeviceTokenList(DeviceList):
    """Iterator for listing all device tokens for this application.

    :ivar limit: Number of entries to fetch in each page request.
    :returns: Each ``next`` returns a :py:class:`DeviceInfo` object.

    """
    start_url = common.DEVICE_TOKEN_URL
    data_attribute = 'device_tokens'
    id_key = 'device_token'


class APIDList(DeviceList):
    """Iterator for listing all device tokens for this application.

    :ivar limit: Number of entries to fetch in each page request.
    :returns: Each ``next`` returns a :py:class:`DeviceInfo` object.

    """
    start_url = common.APID_URL
    data_attribute = 'apids'
    id_key = 'apid'


class DevicePINList(DeviceList):
    """Iterator for listing all device tokens for this application.

    :ivar limit: Number of entries to fetch in each page request.
    :returns: Each ``next`` returns a :py:class:`DeviceInfo` object.

    """
    start_url = common.DEVICE_PIN_URL
    data_attribute = 'device_pins'
    id_key = 'device_pin'

########NEW FILE########
__FILENAME__ = audience
import re

DEVICE_TOKEN_FORMAT = re.compile(r'^[0-9a-fA-F]{64}$')
PIN_FORMAT = re.compile(r'^[0-9a-fA-F]{8}$')
UUID_FORMAT = re.compile(
    r'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}'
    r'-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')


# Value selectors; device IDs, aliases, tags, etc.


def device_token(token):
    """Select a single iOS device token"""
    # Ensure the device token is valid
    if not DEVICE_TOKEN_FORMAT.match(token):
        raise ValueError("Invalid device token")
    return {"device_token": token.upper().strip()}


def device_pin(pin):
    """Select a single BlackBerry PIN"""
    if not PIN_FORMAT.match(pin):
        raise ValueError("Invalid BlackBerry PIN")
    return {"device_pin": pin.lower().strip()}


def apid(uuid):
    """Select a single Android APID"""
    if not UUID_FORMAT.match(uuid):
        raise ValueError("Invalid APID")
    return {"apid": uuid.lower().strip()}


def wns(uuid):
    """Select a single Windows 8 APID"""
    if not UUID_FORMAT.match(uuid):
        raise ValueError("Invalid wns")
    return {"wns": uuid.lower().strip()}


def mpns(uuid):
    """Select a single Windows Phone 8 APID"""
    if not UUID_FORMAT.match(uuid):
        raise ValueError("Invalid mpns")
    return {"mpns": uuid.lower().strip()}


def tag(tag):
    """Select a single tag."""
    return {"tag": tag}


def alias(alias):
    """Select a single alias."""
    return {"alias": alias}


def segment(segment):
    """Select a single segment."""
    return {"segment": segment}


# Compound selectors


def or_(*children):
    """Select devices that match at least one of the given selectors.

    >>> or_(tag('sports'), tag('business'))
    {'or': [{'tag': 'sports'}, {'tag': 'business'}]}

    """
    return {"or": [child for child in children]}


def and_(*children):
    """Select devices that match all of the given selectors.

    >>> and_(tag('sports'), tag('business'))
    {'and': [{'tag': 'sports'}, {'tag': 'business'}]}

    """
    return {"and": [child for child in children]}

def not_(child):
    """Select devices that does not match the given selectors.

    >>> not_(and_(tag('sports'), tag('business')))
    {'not': {'and': [{'tag': 'sports'}, {'tag': 'business'}]}}

    """
    return {"not": child}


# Location selectors

def location(date=None, **kwargs):
    """Select a location expression.

    Location selectors are made up of either an id or an alias and a date
    period specifier. Use a date specification function to generate the time
    period specifier.

    ID location example:

    >>> from pprint import pprint
    >>> l = location(id='4oFkxX7RcUdirjtaenEQIV', date=recent_date(days=4))
    >>> pprint(l, width=76)
    {'location': {'date': {'recent': {'days': 4}},
                  'id': '4oFkxX7RcUdirjtaenEQIV'}}

    Alias location example:

    >>> l = location(us_zip='94103', date=absolute_date(
    ...    resolution='days', start='2012-01-01', end='2012-01-15'))
    >>> pprint(l, width=76)
    {'location': {'date': {'days': {'end': '2012-01-15',
                                    'start': '2012-01-01'}},
                  'us_zip': '94103'}}

    """
    if not len(kwargs) == 1:
        raise ValueError("Must specificy a single location id or alias")
    if date is None:
        raise ValueError("Must specificy a time period specifier")
    kwargs['date'] = date
    return {"location": kwargs}


def recent_date(last_seen=False, **kwargs):
    """Select a recent date range for a location selector.

    :keyword resolution: One keyword time resolution specifier, e.g. ``hours``
        or ``days``.
    :type resolution: int
    :keyword last_seen: Select only devices last seen in this location. Defaults
        to False.

    >>> recent_date(months=6)
    {'recent': {'months': 6}}
    >>> recent_date(weeks=3, last_seen=True)
    {'last_seen': True, 'recent': {'weeks': 3}}
    """
    if not len(kwargs) == 1:
        raise ValueError("Must specificy a single date resolution")
    resolution = kwargs.keys()[0]
    value = kwargs.values()[0]

    if resolution not in ('minutes' 'hours' 'days' 'weeks' 'months' 'years'):
        raise ValueError("Invalid date resolution: %s" % resolution)
    payload = {"recent": {resolution: value}}
    if last_seen:
        payload['last_seen'] = True
    return payload


def absolute_date(resolution, start, end, last_seen=False):
    """Select an absolute date range for a location selector.

    :keyword resolution: Time resolution specifier, e.g. ``hours`` or ``days``.
    :keyword start: UTC start time in ISO 8601 format.
    :keyword end: UTC end time in ISO 8601 format.
    :keyword last_seen: Select only devices last seen in this location.
        Defaults to False.

    >>> from pprint import pprint
    >>> d = absolute_date(resolution='months', start='2013-01', end='2013-06')
    >>> pprint(d)
    {'months': {'end': '2013-06', 'start': '2013-01'}}
    >>> d = absolute_date(resolution='minutes', start='2012-01-01 12:00',
    ...         end='2012-01-01 12:45', last_seen=True)
    >>> pprint(d, width=76)
    {'last_seen': True,
     'minutes': {'end': '2012-01-01 12:45', 'start': '2012-01-01 12:00'}}

    """
    if resolution not in ('minutes' 'hours' 'days' 'weeks' 'months' 'years'):
        raise ValueError("Invalid date resolution: %s" % resolution)

    payload = {resolution: {'start': start, 'end': end}}
    if last_seen:
        payload['last_seen'] = True
    return payload

########NEW FILE########
__FILENAME__ = core
import json
import logging

from urbanairship import common


logger = logging.getLogger('urbanairship')


class Push(object):
    """A push notification. Set audience, message, etc, and send."""

    def __init__(self, airship):
        self._airship = airship
        self.audience = None
        self.notification = None
        self.device_types = None
        self.options = None
        self.message = None

    @property
    def payload(self):
        data = {
            "audience": self.audience,
            "notification": self.notification,
            "device_types": self.device_types,
        }
        if self.options is not None:
            data['options'] = self.options
        if self.message is not None:
            data['message'] = self.message
        return data

    def send(self):
        """Send the notification.

        :returns: :py:class:`PushResponse` object with ``push_ids`` and
            other response data.
        :raises AirshipFailure: Request failed.
        :raises Unauthorized: Authentication failed.

        """
        body = json.dumps(self.payload)
        response = self._airship._request('POST', body,
            common.PUSH_URL, 'application/json', version=3)

        data = response.json()
        logger.info("Push successful. push_ids: %s",
            ', '.join(data['push_ids']))

        return PushResponse(response)


class ScheduledPush(object):
    """A scheduled push notification. Set schedule, push, and send."""

    def __init__(self, airship):
        self._airship = airship
        self.schedule = None
        self.name = None
        self.push = None
        self.url = None

    @classmethod
    def from_url(cls, airship, url):
        """Load an existing scheduled push from its URL."""

        sched = cls(airship)
        response = sched._airship._request('GET', None, url, version=3)
        payload = response.json()
        sched.name = payload.get('name')
        sched.schedule = payload['schedule']
        sched.push = Push(airship)
        sched.push.audience = payload['push']['audience']
        sched.push.notification = payload['push']['notification']
        sched.push.device_types = payload['push']['device_types']
        if 'message' in payload['push']:
            sched.push.message = payload['push']['message']
        if 'options' in payload['push']:
            sched.push.options = payload['push']['options']
        sched.url = url
        return sched

    @property
    def payload(self):
        data = {
            "schedule": self.schedule,
            "push": self.push.payload,
        }
        if self.name is not None:
            data['name'] = self.name
        return data

    def send(self):
        """Schedule the notification

        :returns: :py:class:`PushResponse` object with ``schedule_url`` and
            other response data.
        :raises AirshipFailure: Request failed.
        :raises Unauthorized: Authentication failed.

        """
        body = json.dumps(self.payload)
        response = self._airship._request('POST', body,
            common.SCHEDULES_URL, 'application/json', version=3)

        data = response.json()
        logger.info("Scheduled push successful. schedule_urls: %s",
            ', '.join(data.get('schedule_urls', [])))
        self.url = data.get('schedule_urls', [None])[0]

        return PushResponse(response)

    def cancel(self):
        """Cancel a previously scheduled notification."""
        if not self.url:
            raise ValueError(
                "Cannot cancel ScheduledPush without url.")
        self._airship._request('DELETE', None, self.url, version=3)

    def update(self):
        if not self.url:
            raise ValueError(
                "Cannot update ScheduledPush without url.")
        body = json.dumps(self.payload)
        response = self._airship._request('PUT', body,
            self.url, 'application/json', version=3)

        data = response.json()
        logger.info("Scheduled push update successful. schedule_urls: %s",
            ', '.join(data.get('schedule_urls', [])))

        return PushResponse(response)


class PushResponse(object):
    """Response to a successful push notification send or schedule.

    Right now this is a fairly simple wrapper around the json payload response,
    but making it an object gives us some flexibility to add functionality
    later.

    """
    ok = None
    push_ids = None
    schedule_url = None
    operation_id = None
    payload = None

    def __init__(self, response):
        data = response.json()
        self.push_ids = data.get('push_ids')
        self.schedule_url = data.get('schedule_urls', [None])[0]
        self.operation_id = data.get('operation_id')
        self.ok = data.get('ok')
        self.payload = data

    def __str__(self):
        return "Response Payload: {0}".format(self.payload)


########NEW FILE########
__FILENAME__ = payload
import re

# Valid autobadge values: auto, +N, -N
VALID_AUTOBADGE = re.compile(r'^(auto|[+-][\d]+)$')


def notification(alert=None, ios=None, android=None, blackberry=None, wns=None,
        mpns=None):
    """Create a notification payload.

    :keyword alert: A simple text alert, applicable for all platforms.
    :keyword ios: An iOS platform override, as generated by :py:func:`ios`.
    :keyword android: An Android platform override, as generated by :py:func:`android`.
    :keyword blackberry: A BlackBerry platform override, as generated by :py:func:`blackberry`.
    :keyword wns: A WNS platform override, as generated by :py:func:`wns`.
    :keyword mpns: A MPNS platform override, as generated by :py:func:`mpns`.

    """
    payload = {}
    if alert is not None:
        payload['alert'] = alert
    if ios is not None:
        payload['ios'] = ios
    if android is not None:
        payload['android'] = android
    if blackberry is not None:
        payload['blackberry'] = blackberry
    if wns is not None:
        payload['wns'] = wns
    if mpns is not None:
        payload['mpns'] = mpns
    if not payload:
        raise ValueError("Notification body may not be empty")
    return payload


def ios(alert=None, badge=None, sound=None, content_available=False,
        extra=None):
    """iOS/APNS specific platform override payload.

    :keyword alert: iOS format alert, as either a string or dictionary.
    :keyword badge: An integer badge value or an *autobadge* string.
    :keyword sound: An string sound file to play.
    :keyword content_available: If True, pass on the content_available command
        for Newsstand iOS applications.
    :keyword extra: A set of key/value pairs to include in the push payload
        sent to the device.

    >>> ios(alert='Hello!', sound='cat.caf',
    ...     extra={'articleid': '12345'})
    {'sound': 'cat.caf', 'extra': {'articleid': '12345'}, 'alert': 'Hello!'}

    """
    payload = {}
    if alert is not None:
        if not isinstance(alert, basestring) or isinstance(alert, dict):
            raise ValueError("iOS alert must be a string or dictionary")
        payload['alert'] = alert
    if badge is not None:
        if not (isinstance(badge, basestring) or isinstance(badge, int)):
            raise ValueError("iOS badge must be an integer or string")
        if isinstance(badge, basestring) and not VALID_AUTOBADGE.match(badge):
            raise ValueError("Invalid iOS autobadge value")
        payload['badge'] = badge
    if sound is not None:
        payload['sound'] = sound
    if content_available:
        payload['content-available'] = 1
    if extra is not None:
        payload['extra'] = extra
    return payload


def android(alert=None, collapse_key=None, time_to_live=None,
        delay_while_idle=False, extra=None):
    """Android specific platform override payload.

    All keyword arguments are optional.

    :keyword alert: String alert text.
    :keyword collapse_key: String
    :keyword time_to_live: Integer
    :keyword delay_while_idle: Boolean
    :keyword extra: A set of key/value pairs to include in the push payload
        sent to the device. All values must be strings.

    See
    `GCM Advanced Topics <http://developer.android.com/google/gcm/adv.html>`_
    for details on ``collapse_key``, ``time_to_live``, and
    ``delay_while_idle``.

    >>> ios(alert='Hello!', sound='cat.caf',
    ...     extra={'articleid': '12345'})
    {'sound': 'cat.caf', 'extra': {'articleid': '12345'}, 'alert': 'Hello!'}

    """
    payload = {}
    if alert is not None:
        payload['alert'] = alert
    if collapse_key is not None:
        payload['collapse_key'] = collapse_key
    if time_to_live is not None:
        payload['time_to_live'] = time_to_live
    if delay_while_idle:
        payload['delay_while_idle'] = True
    if extra is not None:
        payload['extra'] = extra
    return payload


def blackberry(alert=None, body=None, content_type=None):
    """BlackBerry specific platform override payload.

    Include either ``alert`` or both ``body`` and ``content_type``.

    :keyword alert: String alert text. Shortcut for ``content_type``
        ``text/plain``.
    :keyword body: String value.
    :keyword content_type: MIME type describing body.

    """
    payload = {}
    if alert is not None:
        payload['body'] = alert
        payload['content_type'] = 'text/plain'
    elif body is not None and content_type is not None:
        payload['body'] = body
        payload['content_type'] = content_type
    else:
        raise ValueError("BlackBerry body and content_type may not be empty")
    return payload


def wns_payload(alert=None, toast=None, tile=None, badge=None):
    """WNS specific platform override payload.

    Must include exactly one of ``alert``, ``toast``, ``tile``, or ``badge``.

    """
    if len(filter(None, (alert, toast, tile, badge))) != 1:
        raise ValueError("WNS payload must have one notification type.")
    payload = {}
    if alert is not None:
        payload['alert'] = alert
    if toast is not None:
        payload['toast'] = toast
    if tile is not None:
        payload['tile'] = tile
    if badge is not None:
        payload['badge'] = badge
    return payload


def mpns_payload(alert=None, toast=None, tile=None):
    """MPNS specific platform override payload.

    Must include exactly one of ``alert``, ``toast``, or ``tile``.

    """
    if len(filter(None, (alert, toast, tile))) != 1:
        raise ValueError("MPNS payload must have one notification type.")
    payload = {}
    if alert is not None:
        payload['alert'] = alert
    if toast is not None:
        payload['toast'] = toast
    if tile is not None:
        payload['tile'] = tile
    return payload


def message(title, body, content_type=None, content_encoding=None):
    """Rich push message payload creation.

    :param title: Required, string
    :param body: Required, string
    :keyword content_type: Optional, MIME type of the body
    :keyword content_encoding: Optional, encoding of the data in body, e.g.
        ``utf-8``.
    :keyword extra: Optional, dictionary of string values.

    """
    payload = {
        'title': title,
        'body': body,
    }
    if content_type is not None:
        payload['content_type'] = content_type
    if content_encoding is not None:
        payload['content_encoding'] = content_encoding
    return payload


def device_types(*types):
    """Create a device type specifier.

    >>> device_types('ios', 'wns')
    ['ios', 'wns']
    >>> device_types('ios', 'symbian')
    Traceback (most recent call last):
        ...
    ValueError: Invalid device type 'symbian'

    """
    if len(types) == 1 and types[0] == 'all':
        return 'all'
    for t in types:
        if t not in ('ios', 'android', 'blackberry', 'wns', 'mpns'):
            raise ValueError("Invalid device type '%s'" % t)
    return [t for t in types]

########NEW FILE########
__FILENAME__ = schedule
def scheduled_time(timestamp):
    """Specify a time for the delivery of this push.

    :param timestamp: A ``datetime.datetime`` object.

    """

    return {'scheduled_time': timestamp.strftime('%Y-%m-%dT%H:%M:%S')}

########NEW FILE########
__FILENAME__ = __about__

__version__ = '0.6.2'

########NEW FILE########
