__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Pyzotero documentation build configuration file, created by
# sphinx-quickstart on Mon Jul  4 19:52:05 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Pyzotero'
copyright = u'2011 – 2014, Stephan Hügel'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.10.2'
# The full version, including alpha/beta/rc tags.
release = '0.10.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Pyzoterodoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Pyzotero.tex', u'Pyzotero Documentation',
   u'Stephan Hügel', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pyzotero', u'Pyzotero Documentation',
     [u'Stephan Hügel'], 1)
]


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Pyzotero'
epub_author = u'Stephan Hügel'
epub_publisher = u'Stephan Hügel'
epub_copyright = u'2011 – 2014, Stephan Hügel'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

########NEW FILE########
__FILENAME__ = test_zotero
#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""
Tests for the Pyzotero module

Copyright Stephan Hügel, 2011

This file is part of Pyzotero.

Pyzotero is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Pyzotero is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Pyzotero. If not, see <http://www.gnu.org/licenses/>.
"""

import unittest
from httpretty import HTTPretty, httprettified
import zotero as z
from datetime import datetime
import pytz


class ZoteroTests(unittest.TestCase):
    """ Tests for pyzotero
    """
    def setUp(self):
        """ Set stuff up
        """
        self.items_doc = """<?xml version="1.0"?>
        <feed xmlns="http://www.w3.org/2005/Atom" xmlns:zapi="http://zotero.org/ns/api">
          <title>Zotero / urschrei / Items</title>
          <id>http://zotero.org/users/436/items?limit=3&amp;content=json</id>
          <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/items?limit=1&amp;content=json"/>
          <link rel="first" type="application/atom+xml" href="https://api.zotero.org/users/436/items?limit=1&amp;content=json"/>
          <link rel="next" type="application/atom+xml" href="https://api.zotero.org/users/436/items?limit=1&amp;content=json&amp;start=3"/>
          <link rel="last" type="application/atom+xml" href="https://api.zotero.org/users/436/items?limit=1&amp;content=json&amp;start=1086"/>
          <link rel="alternate" type="text/html" href="http://zotero.org/users/436/items?limit=1"/>
          <zapi:totalResults>1087</zapi:totalResults>
          <zapi:apiVersion>1</zapi:apiVersion>
          <updated>2011-05-28T11:07:58Z</updated>
          <entry>
            <title>Copyright in custom code: Who owns commissioned software?</title>
            <author>
              <name>urschrei</name>
              <uri>http://zotero.org/urschrei</uri>
            </author>
            <id>http://zotero.org/urschrei/items/T4AH4RZA</id>
            <published>2011-02-14T00:27:03Z</published>
            <updated>2011-02-14T00:27:03Z</updated>
            <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/items/T4AH4RZA?content=json"/>
            <link rel="alternate" type="text/html" href="http://zotero.org/urschrei/items/T4AH4RZA"/>
            <zapi:key>T4AH4RZA</zapi:key>
            <zapi:itemType>journalArticle</zapi:itemType>
            <zapi:creatorSummary>McIntyre</zapi:creatorSummary>
            <zapi:numChildren>1</zapi:numChildren>
            <zapi:numTags>0</zapi:numTags>
            <content type="application/json" zapi:etag="7252daf2495feb8ec89c61f391bcba24">{"itemType":"journalArticle","title":"Copyright in custom code: Who owns commissioned software?","creators":[{"creatorType":"author","firstName":"T. J.","lastName":"McIntyre"}],"abstractNote":"","publicationTitle":"Journal of Intellectual Property Law \u0026 Practice","volume":"","issue":"","pages":"","date":"2007","series":"","seriesTitle":"","seriesText":"","journalAbbreviation":"","language":"","DOI":"","ISSN":"1747-1532","shortTitle":"Copyright in custom code","url":"","accessDate":"","archive":"","archiveLocation":"","libraryCatalog":"Google Scholar","callNumber":"","rights":"","extra":"","tags":[]}</content>
          </entry>
        </feed>"""
        self.citation_doc = """<?xml version="1.0" encoding="UTF-8"?>
            <entry xmlns="http://www.w3.org/2005/Atom" xmlns:zapi="http://zotero.org/ns/api">
            <title>The power broker : Robert Moses and the fall of New York</title>
            <author><name>urschrei</name><uri>http://zotero.org/urschrei</uri></author>
            <id>http://zotero.org/urschrei/items/GW8V2CK7</id>
            <published>2014-02-12T16:16:22Z</published>
            <updated>2014-03-06T20:25:20Z</updated>
            <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/items/GW8V2CK7?content=citation"/>
            <link rel="alternate" type="text/html" href="http://zotero.org/urschrei/items/GW8V2CK7"/>
            <zapi:key>GW8V2CK7</zapi:key>
            <zapi:version>764</zapi:version>
            <zapi:itemType>document</zapi:itemType>
            <zapi:creatorSummary>Robert \xc3\x84. Caro</zapi:creatorSummary>
            <zapi:year>1974</zapi:year>
            <zapi:numChildren>0</zapi:numChildren>
            <zapi:numTags>0</zapi:numTags>
            <content zapi:type="citation" type="xhtml">
                <span xmlns="http://www.w3.org/1999/xhtml">(Robert \xc3\x84. Caro 1974)</span>
            </content>
            </entry>"""
        self.biblio_doc = """<?xml version="1.0" encoding="UTF-8"?>
            <entry xmlns="http://www.w3.org/2005/Atom" xmlns:zapi="http://zotero.org/ns/api">
                <title>The power broker : Robert Moses and the fall of New York</title>
                <author>
                <name>urschrei</name>
                <uri>http://zotero.org/urschrei</uri>
                </author>
                <id>http://zotero.org/urschrei/items/GW8V2CK7</id>
                <published>2014-02-12T16:16:22Z</published>
                <updated>2014-02-12T16:16:22Z</updated>
                <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/items/GW8V2CK7?content=bib"/>
                <link rel="alternate" type="text/html" href="http://zotero.org/urschrei/items/GW8V2CK7"/>
                <zapi:key>GW8V2CK7</zapi:key>
                <zapi:version>739</zapi:version>
                <zapi:itemType>document</zapi:itemType>
                <zapi:creatorSummary>Robert A. Caro</zapi:creatorSummary>
                <zapi:year>1974</zapi:year>
                <zapi:numChildren>0</zapi:numChildren>
                <zapi:numTags>0</zapi:numTags>
                <content zapi:type="bib" type="xhtml">
                <div xmlns="http://www.w3.org/1999/xhtml" class="csl-bib-body" style="line-height: 1.35; padding-left: 2em; text-indent:-2em;">
            <div class="csl-entry">Robert Ä. Caro. 1974. “The Power Broker : Robert Moses and the Fall of New York.”</div>
            </div>
              </content>
            </entry>"""
        self.attachments_doc = """<?xml version="1.0"?>
        <feed xmlns="http://www.w3.org/2005/Atom" xmlns:zapi="http://zotero.org/ns/api">
          <title>Zotero / urschrei / Items</title>
          <id>http://zotero.org/users/436/items?limit=1&amp;content=json</id>
          <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/items?limit=1&amp;content=json"/>
          <link rel="first" type="application/atom+xml" href="https://api.zotero.org/users/436/items?limit=1&amp;content=json"/>
          <link rel="next" type="application/atom+xml" href="https://api.zotero.org/users/436/items?limit=1&amp;content=json&amp;start=1"/>
          <link rel="last" type="application/atom+xml" href="https://api.zotero.org/users/436/items?limit=1&amp;content=json&amp;start=1128"/>
          <link rel="alternate" type="text/html" href="http://zotero.org/users/436/items?limit=1"/>
          <zapi:totalResults>1129</zapi:totalResults>
          <zapi:apiVersion>1</zapi:apiVersion>
          <updated>2012-01-11T19:54:47Z</updated>
          <entry>
            <title>1641 Depositions</title>
            <author>
              <name>urschrei</name>
              <uri>http://zotero.org/urschrei</uri>
            </author>
            <id>http://zotero.org/urschrei/items/TM8QRS36</id>
            <published>2012-01-11T19:54:47Z</published>
            <updated>2012-01-11T19:54:47Z</updated>
            <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/items/TM8QRS36?content=json"/>
            <link rel="up" type="application/atom+xml" href="https://api.zotero.org/users/436/items/47RUN6RI?content=json"/>
            <link rel="alternate" type="text/html" href="http://zotero.org/urschrei/items/TM8QRS36"/>
            <zapi:key>TM8QRS36</zapi:key>
            <zapi:itemType>attachment</zapi:itemType>
            <zapi:numTags>0</zapi:numTags>
            <content zapi:type="json" zapi:etag="1686f563f9b4cb1db3a745a920bf0afa">{"itemType":"attachment","title":"1641 Depositions","accessDate":"2012-01-11 19:54:47","url":"http://1641.tcd.ie/project-conservation.php","note":"","linkMode":1,"mimeType":"text/html","charset":"utf-8","tags":[]}</content>
          </entry>
        </feed>"""
        self.collections_doc = """<?xml version="1.0"?>
        <feed xmlns="http://www.w3.org/2005/Atom" xmlns:zapi="http://zotero.org/ns/api">
          <title>Zotero / urschrei / Collections</title>
          <id>http://zotero.org/users/436/collections?limit=1&amp;content=json</id>
          <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/collections?limit=1&amp;content=json"/>
          <link rel="first" type="application/atom+xml" href="https://api.zotero.org/users/436/collections?limit=1&amp;content=json"/>
          <link rel="next" type="application/atom+xml" href="https://api.zotero.org/users/436/collections?limit=1&amp;content=json&amp;start=1"/>
          <link rel="last" type="application/atom+xml" href="https://api.zotero.org/users/436/collections?limit=1&amp;content=json&amp;start=37"/>
          <link rel="alternate" type="text/html" href="http://zotero.org/users/436/collections?limit=1"/>
          <zapi:totalResults>38</zapi:totalResults>
          <zapi:apiVersion>1</zapi:apiVersion>
          <updated>2011-03-16T15:00:09Z</updated>
          <entry>
            <title>Badiou</title>
            <author>
              <name>urschrei</name>
              <uri>http://zotero.org/urschrei</uri>
            </author>
            <id>http://zotero.org/urschrei/collections/HTUHVPE5</id>
            <published>2011-03-16T14:48:18Z</published>
            <updated>2011-03-16T15:00:09Z</updated>
            <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/collections/HTUHVPE5"/>
            <link rel="alternate" type="text/html" href="http://zotero.org/urschrei/collections/HTUHVPE5"/>
            <zapi:key>HTUHVPE5</zapi:key>
            <zapi:numCollections>0</zapi:numCollections>
            <zapi:numItems>27</zapi:numItems>
            <content type="application/json" zapi:etag="7252daf2495feb8ec89c61f391bcba24">{"name":"A Midsummer Night's Dream","parent":false}</content>
          </entry>
        </feed>"""
        self.tags_doc = """<?xml version="1.0"?>
        <feed xmlns="http://www.w3.org/2005/Atom" xmlns:zapi="http://zotero.org/ns/api">
          <title>Zotero / urschrei / Tags</title>
          <id>http://zotero.org/users/436/tags?limit=1&amp;content=json</id>
          <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/tags?limit=1&amp;content=json"/>
          <link rel="first" type="application/atom+xml" href="https://api.zotero.org/users/436/tags?limit=1&amp;content=json"/>
          <link rel="next" type="application/atom+xml" href="https://api.zotero.org/users/436/tags?limit=1&amp;content=json&amp;start=1"/>
          <link rel="last" type="application/atom+xml" href="https://api.zotero.org/users/436/tags?limit=1&amp;content=json&amp;start=319"/>
          <link rel="alternate" type="text/html" href="http://zotero.org/users/436/tags?limit=1"/>
          <zapi:totalResults>320</zapi:totalResults>
          <zapi:apiVersion>1</zapi:apiVersion>
          <updated>2010-03-27T13:56:08Z</updated>
          <entry xmlns:zxfer="http://zotero.org/ns/transfer">
            <title>Authority in literature</title>
            <author>
              <name>urschrei</name>
              <uri>http://zotero.org/urschrei</uri>
            </author>
            <id>http://zotero.org/urschrei/tags/Authority+in+literature</id>
            <published>2010-03-26T18:23:14Z</published>
            <updated>2010-03-27T13:56:08Z</updated>
            <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/tags/Authority+in+literature"/>
            <link rel="alternate" type="text/html" href="http://zotero.org/urschrei/tags/Authority+in+literature"/>
            <zapi:numItems>1</zapi:numItems>
          </entry>
        </feed>"""
        self.groups_doc = """<?xml version="1.0"?>
        <feed xmlns="http://www.w3.org/2005/Atom" xmlns:zapi="http://zotero.org/ns/api">
          <title>urschrei&#x2019;s Groups</title>
          <id>http://zotero.org/users/436/groups?limit=1&amp;content=json</id>
          <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/groups?limit=1&amp;content=json"/>
          <link rel="first" type="application/atom+xml" href="https://api.zotero.org/users/436/groups?limit=1&amp;content=json"/>
          <link rel="next" type="application/atom+xml" href="https://api.zotero.org/users/436/groups?limit=1&amp;content=json&amp;start=1"/>
          <link rel="last" type="application/atom+xml" href="https://api.zotero.org/users/436/groups?limit=1&amp;content=json&amp;start=1"/>
          <link rel="alternate" type="text/html" href="http://zotero.org/users/436/groups?limit=1"/>
          <zapi:totalResults>2</zapi:totalResults>
          <zapi:apiVersion>1</zapi:apiVersion>
          <updated>2010-07-04T21:56:22Z</updated>
          <entry xmlns:zxfer="http://zotero.org/ns/transfer">
            <title>DFW</title>
            <author>
              <name>urschrei</name>
              <uri>http://zotero.org/urschrei</uri>
            </author>
            <id>http://zotero.org/groups/dfw</id>
            <published>2010-01-20T12:31:26Z</published>
            <updated>2010-07-04T21:56:22Z</updated>
            <link rel="self" type="application/atom+xml" href="https://api.zotero.org/groups/10248?content=json"/>
            <link rel="alternate" type="text/html" href="http://zotero.org/groups/dfw"/>
            <zapi:numItems>468</zapi:numItems>
            <content type="application/json">{"name":"DFW","owner":436,"type":"PublicOpen","description":"%3Cp%3EA+grouped+collection+of+the+David+Foster+Wallace+bibliography%2C+adapted%2Fedited%2Fupdated+from+what%27s+available+elsewhere.%3C%2Fp%3E","url":"","hasImage":1,"libraryEnabled":1,"libraryEditing":"admins","libraryReading":"all","fileEditing":"none","members":{"2":539271}}</content>
          </entry>
        </feed>"""
        self.bib_doc = """<?xml version="1.0"?>
         <feed xmlns="http://www.w3.org/2005/Atom" xmlns:zapi="http://zotero.org/ns/api">
           <title>Zotero / urschrei / Top-Level Items</title>
           <id>http://zotero.org/users/436/items/top?limit=1&amp;content=bib</id>
           <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/items/top?limit=1&amp;content=bib"/>
           <link rel="first" type="application/atom+xml" href="https://api.zotero.org/users/436/items/top?limit=1&amp;content=bib"/>
           <link rel="next" type="application/atom+xml" href="https://api.zotero.org/users/436/items/top?limit=1&amp;content=bib&amp;start=1"/>
           <link rel="last" type="application/atom+xml" href="https://api.zotero.org/users/436/items/top?limit=1&amp;content=bib&amp;start=949"/>
           <link rel="alternate" type="text/html" href="http://zotero.org/users/436/items/top?limit=1"/>
           <zapi:totalResults>950</zapi:totalResults>
           <zapi:apiVersion>1</zapi:apiVersion>
           <updated>2011-02-14T00:27:03Z</updated>
           <entry>
             <title>Copyright in custom code: Who owns commissioned software?</title>
             <author>
               <name>urschrei</name>
               <uri>http://zotero.org/urschrei</uri>
             </author>
             <id>http://zotero.org/urschrei/items/T4AH4RZA</id>
             <published>2011-02-14T00:27:03Z</published>
             <updated>2011-02-14T00:27:03Z</updated>
             <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/items/T4AH4RZA?content=bib"/>
             <link rel="alternate" type="text/html" href="http://zotero.org/urschrei/items/T4AH4RZA"/>
             <zapi:key>T4AH4RZA</zapi:key>
             <zapi:itemType>journalArticle</zapi:itemType>
             <zapi:creatorSummary>McIntyre</zapi:creatorSummary>
             <zapi:numChildren>1</zapi:numChildren>
             <zapi:numTags>0</zapi:numTags>
             <content type="xhtml" zapi:etag="7252daf2495feb8ec89c61f391bcba24">
               <div xmlns="http://www.w3.org/1999/xhtml" class="csl-bib-body" style="line-height: 1.35; padding-left: 2em; text-indent:-2em;">
           <div class="csl-entry">McIntyre, T. J. &#x201C;Copyright in custom code: Who owns commissioned software?&#x201D; <i>Journal of Intellectual Property Law &amp; Practice</i> (2007).</div>
         </div>
             </content>
           </entry>
         </feed>"""
        self.created_response = """<?xml version="1.0"?>
        <entry xmlns="http://www.w3.org/2005/Atom" xmlns:zapi="http://zotero.org/ns/api">
          <title>Hell, I don't Know</title>
          <author>
            <name>urschrei</name>
            <uri>http://zotero.org/urschrei</uri>
          </author>
          <id>http://zotero.org/urschrei/items/NVGIBE59</id>
          <published>2011-12-14T19:24:20Z</published>
          <updated>2011-12-17T19:19:37Z</updated>
          <link rel="self" type="application/atom+xml" href="https://api.zotero.org/users/436/items/NVGIBE59?content=json"/>
          <link rel="alternate" type="text/html" href="http://zotero.org/urschrei/items/NVGIBE59"/>
          <zapi:key>NVGIBE59</zapi:key>
          <zapi:itemType>journalArticle</zapi:itemType>
          <zapi:creatorSummary>Salo</zapi:creatorSummary>
          <zapi:year/>
          <zapi:numChildren>1</zapi:numChildren>
          <zapi:numTags>0</zapi:numTags>
          <content type="application/json" zapi:etag="1ed002db69174ae2ae0e3b90499df15e">{"itemType":"journalArticle","title":"Hell, I don't Know","creators":[{"creatorType":"author","firstName":"Dorotea","lastName":"Salo"}],"abstractNote":"","publicationTitle":"","volume":"","issue":"","pages":"","date":"","series":"","seriesTitle":"","seriesText":"","journalAbbreviation":"","language":"","DOI":"","ISSN":"","shortTitle":"","url":"","accessDate":"","archive":"","archiveLocation":"","libraryCatalog":"","callNumber":"","rights":"","extra":"","tags":[]}</content>
        </entry>"""
        self.item_templt = """{
          "itemType" : "book",
          "title" : "",
          "creators" : [
            {
              "creatorType" : "author",
              "firstName" : "",
              "lastName" : ""
            }
          ],
          "url" : "",
          "tags" : [],
          "notes" : [],
          "etag" : ""
        }"""
        self.item_types = """[
        {
            "itemType":"artwork",
            "localized":"Artwork"
        },
        {
            "itemType":"audioRecording",
            "localized":"Audio Recording"
        },
        {
            "itemType":"bill",
            "localized":"Bill"
        },
        {
            "itemType":"blogPost",
            "localized":"Blog Post"
        },
        {
            "itemType":"book",
            "localized":"Book"
        },
        {
            "itemType":"bookSection",
            "localized":"Book Section"
        },
        {
            "itemType":"case",
            "localized":"Case"
        },
        {
            "itemType":"computerProgram",
            "localized":"Computer Program"
        },
        {
            "itemType":"conferencePaper",
            "localized":"Conference Paper"
        },
        {
            "itemType":"dictionaryEntry",
            "localized":"Dictionary Entry"
        },
        {
            "itemType":"document",
            "localized":"Document"
        },
        {
            "itemType":"email",
            "localized":"E-mail"
        },
        {
            "itemType":"encyclopediaArticle",
            "localized":"Encyclopedia Article"
        },
        {
            "itemType":"film",
            "localized":"Film"
        },
        {
            "itemType":"forumPost",
            "localized":"Forum Post"
        },
        {
            "itemType":"hearing",
            "localized":"Hearing"
        },
        {
            "itemType":"instantMessage",
            "localized":"Instant Message"
        },
        {
            "itemType":"interview",
            "localized":"Interview"
        },
        {
            "itemType":"journalArticle",
            "localized":"Journal Article"
        },
        {
            "itemType":"letter",
            "localized":"Letter"
        },
        {
            "itemType":"magazineArticle",
            "localized":"Magazine Article"
        },
        {
            "itemType":"manuscript",
            "localized":"Manuscript"
        },
        {
            "itemType":"map",
            "localized":"Map"
        },
        {
            "itemType":"newspaperArticle",
            "localized":"Newspaper Article"
        },
        {
            "itemType":"note",
            "localized":"Note"
        },
        {
            "itemType":"patent",
            "localized":"Patent"
        },
        {
            "itemType":"podcast",
            "localized":"Podcast"
        },
        {
            "itemType":"presentation",
            "localized":"Presentation"
        },
        {
            "itemType":"radioBroadcast",
            "localized":"Radio Broadcast"
        },
        {
            "itemType":"report",
            "localized":"Report"
        },
        {
            "itemType":"statute",
            "localized":"Statute"
        },
        {
            "itemType":"tvBroadcast",
            "localized":"TV Broadcast"
        },
        {
            "itemType":"thesis",
            "localized":"Thesis"
        },
        {
            "itemType":"videoRecording",
            "localized":"Video Recording"
        },
        {
            "itemType":"webpage",
            "localized":"Web Page"
        }
        ]"""
        self.keys_response = """ABCDE\nFGHIJ\nKLMNO\n"""
        # Add the item file to the mock response by default
        HTTPretty.enable()
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items?content=json&key=myuserkey',
            body=self.items_doc)

    @httprettified
    def testFailWithoutCredentials(self):
        """ Instance creation should fail, because we're leaving out a
            credential
        """
        with self.assertRaises(z.ze.MissingCredentials):
            zf = z.Zotero('myuserID')

    @httprettified
    def testRequestBuilder(self):
        """ Should add the user key, then url-encode all other added parameters
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        zot.add_parameters(limit=0, start=7)
        self.assertEqual('content=json&start=7&limit=0&key=myuserkey', zot.url_params)

    @httprettified
    def testBuildQuery(self):
        """ Check that spaces etc. are being correctly URL-encoded and added
            to the URL parameters
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        zot.add_parameters(start=10)
        query_string = '/users/{u}/tags/hi there/items'
        query = zot._build_query(query_string)
        self.assertEqual(
            '/users/myuserID/tags/hi%20there/items?content=json&start=10&key=myuserkey',
            query)

    @httprettified
    def testParseItemAtomDoc(self):
        """ Should successfully return a list of item dicts, key should match
            input doc's zapi:key value, and author should have been correctly
            parsed out of the XHTML payload
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items?content=json&key=myuserkey',
            body=self.items_doc)
        items_data = zot.items()
        self.assertEqual(u'T4AH4RZA', items_data[0]['key'])
        self.assertEqual(u'7252daf2495feb8ec89c61f391bcba24', items_data[0]['etag'])
        self.assertEqual(u'McIntyre', items_data[0]['creators'][0]['lastName'])
        self.assertEqual(u'journalArticle', items_data[0]['itemType'])
        test_dt = datetime.strptime(
            u'Mon, 14 Feb 2011 00:27:03 UTC',
            "%a, %d %b %Y %H:%M:%S %Z").replace(tzinfo=pytz.timezone('GMT'))
        incoming_dt = datetime.strptime(
            items_data[0]['updated'],
            "%a, %d %b %Y %H:%M:%S %Z").replace(tzinfo=pytz.timezone('GMT'))
        self.assertEqual(test_dt, incoming_dt)

    @httprettified
    def testParseAttachmentsAtomDoc(self):
        """ Ensure that attachments are being correctly parsed """
        zot = z.Zotero('myuserid', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserid/items?content=json&key=myuserkey',
            body=self.attachments_doc)
        attachments_data = zot.items()
        self.assertEqual(u'1641 Depositions', attachments_data[0]['title'])

    @httprettified
    def testParseKeysResponse(self):
        """ Check that parsing plain keys returned by format = keys works """
        zot = z.Zotero('myuserid', 'user', 'myuserkey')
        zot.url_params = 'format=keys'
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserid/items?format=keys',
            body=self.keys_response)
        response = zot.items()
        self.assertEqual('ABCDE\nFGHIJ\nKLMNO\n', response)

    @httprettified
    def testParseChildItems(self):
        """ Try and parse child items """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items/ABC123/children?content=json&key=myuserkey',
            body=self.items_doc)
        items_data = zot.children('ABC123')
        self.assertEqual(u'T4AH4RZA', items_data[0]['key'])

    @httprettified
    def testEncodings(self):
        """ Should be able to print unicode strings to stdout, and convert
            them to UTF-8 before printing them
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items?content=json&key=myuserkey',
            body=self.items_doc)
        items_data = zot.items()
        try:
            print(items_data[0]['title'])
        except UnicodeError:
            self.fail('Your Python install appears unable to print unicode')
        try:
            print(items_data[0]['title'].encode('utf-8'))
        except UnicodeError:
            self.fail(
                'Your Python install appears to dislike encoding unicode strings as UTF-8')

    @httprettified
    def testCitUTF8(self):
        """ ensure that unicode citations are correctly processed by Pyzotero
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items/GW8V2CK7?content=citation&style=chicago-author-date&key=myuserkey',
            body=self.citation_doc)
        cit = zot.item('GW8V2CK7', content='citation', style='chicago-author-date')
        self.assertEqual(cit[0], u'<span>(Robert Ä. Caro 1974)</span>')

    @httprettified
    def testParseItemAtomBibDoc(self):
        """ Should match a DIV with class = csl-entry
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        zot.url_params = 'content=bib'
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items?content=json&key=myuserkey',
            body=self.bib_doc)
        items_data = zot.items()
        dec = items_data[0]
        self.assertTrue(dec.startswith("""<div class="csl-entry">"""))

    @httprettified
    def testParseCollectionsAtomDoc(self):
        """ Should successfully return a list of collection dicts, key should
            match input doc's zapi:key value, and 'title' value should match
            input doc's title value
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/collections?content=json&key=myuserkey',
            body=self.collections_doc)
        collections_data = zot.collections()
        self.assertEqual(u'HTUHVPE5', collections_data[0]['key'])
        self.assertEqual(
            "A Midsummer Night's Dream",
            collections_data[0]['name'])

    @httprettified
    def testParseTagsAtomDoc(self):
        """ Should successfully return a list of tags
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/tags?content=json&key=myuserkey',
            body=self.tags_doc)
        # /users/myuserID/tags?content=json&key=myuserkey
        tags_data = zot.tags()
        self.assertEqual('Authority in literature', tags_data[0])

    @httprettified
    def testParseGroupsAtomDoc(self):
        """ Should successfully return a list of group dicts, ID should match
            input doc's zapi:key value, and 'total_items' value should match
            input doc's zapi:numItems value
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/groups?content=json&key=myuserkey',
            body=self.groups_doc)
        groups_data = zot.groups()
        self.assertEqual('DFW', groups_data[0]['name'])
        self.assertEqual('10248', groups_data[0]['group_id'])

    def testParamsReset(self):
        """ Should successfully reset URL parameters after a query string
            is built
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        zot.add_parameters(start=5, limit=10)
        zot._build_query('/whatever')
        zot.add_parameters(start=2)
        self.assertEqual('content=json&start=2&key=myuserkey', zot.url_params)

    @httprettified
    def testParamsBlankAfterCall(self):
        """ self.url_params should be blank after an API call
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items?content=json&key=myuserkey',
            body=self.items_doc)
        _ = zot.items()
        self.assertEqual(None, zot.url_params)

    @httprettified
    def testResponseForbidden(self):
        """ Ensure that an error is properly raised for 403
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items?content=json&key=myuserkey',
            body=self.items_doc,
            status=403)
        with self.assertRaises(z.ze.UserNotAuthorised):
            zot.items()

    @httprettified
    def testResponseUnsupported(self):
        """ Ensure that an error is properly raised for 400
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items?content=json&key=myuserkey',
            body=self.items_doc,
            status=400)
        with self.assertRaises(z.ze.UnsupportedParams):
            zot.items()

    @httprettified
    def testResponseNotFound(self):
        """ Ensure that an error is properly raised for 404
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items?content=json&key=myuserkey',
            body=self.items_doc,
            status=404)
        with self.assertRaises(z.ze.ResourceNotFound):
            zot.items()

    @httprettified
    def testResponseMiscError(self):
        """ Ensure that an error is properly raised for unspecified errors
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items?content=json&key=myuserkey',
            body=self.items_doc,
            status=500)
        with self.assertRaises(z.ze.HTTPError):
            zot.items()

    @httprettified
    def testGetItems(self):
        """ Ensure that we can retrieve a list of all items """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/itemTypes',
            body=self.item_types)
        t = zot.item_types()
        self.assertEqual(t[0]['itemType'], 'artwork')
        self.assertEqual(t[-1]['itemType'], 'webpage')

    @httprettified
    def testGetTemplate(self):
        """ Ensure that item templates are retrieved and converted into dicts
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/items/new?itemType=book',
            body=self.item_templt)
        t = zot.item_template('book')
        self.assertEqual('book', t['itemType'])

    def testCreateCollectionError(self):
        """ Ensure that collection creation fails with the wrong dict
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        t = {'foo': 'bar'}
        with self.assertRaises(z.ze.ParamNotPassed):
            t = zot.create_collection(t)

    @httprettified
    def testCreateItem(self):
        """ Ensure that items can be created
        """
        # first, retrieve an item template
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/items/new?itemType=book',
            body=self.item_templt)
        t = zot.item_template('book')
        # Update the item type
        t['itemType'] = 'journalArticle'
        # Add keys which should be removed before the data is sent
        t['key'] = 'KEYABC123'
        t['etag'] = 'TAGABC123'
        t['group_id'] = 'GROUPABC123'
        t['updated'] = '14 March, 2011'
        tn = dict(t)
        tn['key'] = 'KEYABC124'
        ls = []
        ls.append(t)
        ls.append(tn)
        # register a 403 response
        HTTPretty.register_uri(
            HTTPretty.POST,
            'https://api.zotero.org/users/myuserID/items?key=myuserkey',
            body=self.items_doc,
            status=403)
        with self.assertRaises(z.ze.UserNotAuthorised) as e:
            _ = zot.create_items(ls)
        exc = str(e.exception)
        # this test is a kludge; we're checking the POST data in the 403 response
        self.assertIn("journalArticle", exc)
        self.assertNotIn("KEYABC123", exc)
        self.assertNotIn("TAGABC123", exc)
        self.assertNotIn("GROUPABC123", exc)

    @httprettified
    def testUpdateItem(self):
        """ Test that we can update an item
            This test is a kludge; it only tests that the mechanism for
            internal key removal is OK, and that we haven't made any silly
            list/dict comprehension or genexpr errors
        """
        import json
        # first, retrieve an item
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        HTTPretty.register_uri(
            HTTPretty.GET,
            'https://api.zotero.org/users/myuserID/items?content=json&key=myuserkey',
            body=self.items_doc)
        items_data = zot.items()
        items_data[0]['title'] = 'flibble'
        json.dumps(*zot._cleanup(items_data[0]))

    def testEtagsParsing(self):
        """ Tests item and item update response etag parsing
        """
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        self.assertEqual(z.etags(self.created_response), ['1ed002db69174ae2ae0e3b90499df15e'])
        self.assertEqual(
            z.etags(self.items_doc),
            ['7252daf2495feb8ec89c61f391bcba24'])

    def testTooManyItems(self):
        """ Should fail because we're passing too many items
        """
        itms = [i for i in xrange(51)]
        zot = z.Zotero('myuserID', 'user', 'myuserkey')
        with self.assertRaises(z.ze.TooManyItems):
            zot.create_items(itms)

    # @httprettified
    # def testRateLimit(self):
    #     """ Test 429 response handling (e.g. wait, wait a bit longer etc.)
    #     """
    #     zot = z.Zotero('myuserID', 'user', 'myuserkey')
    #     HTTPretty.register_uri(
    #         HTTPretty.GET,
    #         'https://api.zotero.org/users/myuserID/items?content=json&key=myuserkey',
    #         responses=[
    #             HTTPretty.Response(body=self.items_doc, status=429),
    #             HTTPretty.Response(body=self.items_doc, status=429),
    #             HTTPretty.Response(body=self.items_doc, status=200)])
    #     zot.items()
    #     with self.assertEqual(z.backoff.delay, 8):
    #         zot.items()

    def tearDown(self):
        """ Tear stuff down
        """
        HTTPretty.disable()


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = zotero
# -*- coding: utf-8 -*-
# pylint: disable=R0904
"""
zotero.py

Created by Stephan Hügel on 2011-02-28
Copyright Stephan Hügel

This file is part of Pyzotero.

Pyzotero is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Pyzotero is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Pyzotero. If not, see <http://www.gnu.org/licenses/>.

"""

from __future__ import unicode_literals

__author__ = 'urschrei@gmail.com'
__version__ = '0.10.1'

# Python 3 compatibility faffing
try:
    from urllib import urlencode
    from urllib import quote
    from urlparse import urlparse
except ImportError:
    from urllib.parse import urlencode
    from urllib.parse import urlparse
    from urllib.parse import quote

import xml.etree.ElementTree as et
import requests
import socket
import feedparser
import json
import uuid
import time
import os
import hashlib
import datetime
import re
import pytz
import mimetypes

try:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict

from . import zotero_errors as ze


# Avoid hanging the application if there's no server response
timeout = 30
socket.setdefaulttimeout(timeout)


def ib64_patched(self, attrsD, contentparams):
    """ Patch isBase64 to prevent Base64 encoding of JSON content
    """
    if attrsD.get('mode', '') == 'base64':
        return 0
    if self.contentparams['type'].startswith('text/'):
        return 0
    if self.contentparams['type'].endswith('+xml'):
        return 0
    if self.contentparams['type'].endswith('/xml'):
        return 0
    if self.contentparams['type'].endswith('/json'):
        return 0
    return 0


def token():
    """ Return a unique 32-char write-token
    """
    return str(uuid.uuid4().hex)


def etags(incoming):
    """ Return a list of etags parsed out of the XML response
    """
    # Parse Atom as straight XML in order to get the etags FFS
    atom_ns = '{http://www.w3.org/2005/Atom}'
    tree = et.fromstring(incoming.encode("utf8"))
    try:
        return [entry.attrib['{http://zotero.org/ns/api}etag'] for
                entry in tree.findall('.//{0}content'.format(atom_ns))]
    except KeyError:
        pass


# Override feedparser's buggy isBase64 method until they fix it
feedparser._FeedParserMixin._isBase64 = ib64_patched


def cleanwrap(func):
    """ Wrapper for Zotero._cleanup
    """
    def enc(self, *args):
        """ Send each item to _cleanup() """
        return (func(self, item) for item in args)
    return enc


def retrieve(func):
    """
    Decorator for Zotero read API methods; calls _retrieve_data() and passes
    the result to the correct processor, based on a lookup
    """
    def wrapped_f(self, *args, **kwargs):
        """
        Returns result of _retrieve_data()

        func's return value is part of a URI, and it's this
        which is intercepted and passed to _retrieve_data:
        '/users/123/items?key=abc123'
        the atom doc returned by _retrieve_data is then
        passed to _etags in order to extract the etag attributes
        from each entry, then to feedparser, then to the correct processor
        """
        if kwargs:
            self.add_parameters(**kwargs)
        retrieved = self._retrieve_data(func(self, *args))
        # determine content and format, based on url params
        content = self.content.search(
            self.request.url) and \
            self.content.search(
                self.request.url).group(0) or 'bib'
        fmt = self.fmt.search(
            self.request.url) and \
            self.fmt.search(
                self.request.url).group(0) or 'atom'
        # step 1: process atom if it's atom-formatted
        if fmt == 'atom':
            parsed = feedparser.parse(retrieved)
            processor = self.processors.get(content)
            # optional step 2: if the content is JSON, extract its etags
            if processor == self._json_processor:
                self.etags = etags(retrieved)
            # extract next, previous, first, last links
            self.links = self._extract_links(parsed)
            # process the content correctly with a custom rule
            return processor(parsed)
        # otherwise, just return the unparsed content as is
        else:
            return retrieved
    return wrapped_f


class Zotero(object):
    """
    Zotero API methods
    A full list of methods can be found here:
    http://www.zotero.org/support/dev/server_api
    """
    def __init__(self, library_id=None, library_type=None, api_key=None,
                 preserve_json_order=False):
        """ Store Zotero credentials
        """
        self.endpoint = 'https://api.zotero.org'
        if library_id and library_type:
            self.library_id = library_id
            # library_type determines whether query begins w. /users or /groups
            self.library_type = library_type + 's'
        else:
            raise ze.MissingCredentials(
                'Please provide both the library ID and the library type')
        # api_key is not required for public individual or group libraries
        if api_key:
            self.api_key = api_key
        self.preserve_json_order = preserve_json_order
        self.url_params = None
        self.etags = None
        self.request = None
        # these aren't valid item fields, so never send them to the server
        self.temp_keys = set(['key', 'etag', 'group_id', 'updated'])
        # determine which processor to use for the parsed content
        self.fmt = re.compile('(?<=format=)\w+')
        self.content = re.compile('(?<=content=)\w+')
        self.processors = {
            'bib': self._bib_processor,
            'citation': self._citation_processor,
            'bibtex': self._bib_processor,
            'bookmarks': self._bib_processor,
            'coins': self._bib_processor,
            'csljson': self._csljson_processor,
            'mods': self._bib_processor,
            'refer': self._bib_processor,
            'rdf_bibliontology': self._bib_processor,
            'rdf_dc': self._bib_processor,
            'rdf_zotero': self._bib_processor,
            'ris': self._bib_processor,
            'tei': self._bib_processor,
            'wikipedia': self._bib_processor,
            'json': self._json_processor
        }
        self.links = None
        self.templates = {}

    def _cache(self, template, key):
        """
        Add a retrieved template to the cache for 304 checking
        accepts a dict and key name, adds the retrieval time, and adds both
        to self.templates as a new dict using the specified key
        """
        # cache template and retrieval time for subsequent calls
        thetime = datetime.datetime.utcnow().replace(
            tzinfo=pytz.timezone('GMT'))
        self.templates[key] = {
            'tmplt': template,
            'updated': thetime}
        return template

    @cleanwrap
    def _cleanup(self, to_clean):
        """ Remove keys we added for internal use
        """
        return dict([[k, v] for k, v in list(to_clean.items())
                    if k not in self.temp_keys])

    def _retrieve_data(self, request=None):
        """
        Retrieve Zotero items via the API
        Combine endpoint and request to access the specific resource
        Returns an Atom document
        """
        full_url = '%s%s' % (self.endpoint, request)
        headers = {"User-Agent": "Pyzotero/%s" % __version__}
        self.request = requests.get(url=full_url, headers=headers)
        try:
            self.request.raise_for_status()
        except requests.exceptions.HTTPError:
            error_handler(self.request)
        return self.request.content.decode('utf8')

    def _extract_links(self, doc):
        """
        Extract self, first, next, last links from an Atom doc, and add
        an instance's API key to the links if it exists
        """
        extracted = dict()
        try:
            for link in doc['feed']['links'][:-1]:
                url = urlparse(link['href'])
                try:
                    extracted[link['rel']] = '{0}?{1}&key={2}'.format(
                        url[2],
                        url[4],
                        self.api_key)
                except AttributeError:
                    # no API key present
                    extracted[link['rel']] = '{0}?{1}'.format(url[2], url[4])
            return extracted
        except KeyError:
            # No links present, because it's a single item
            return None

    def _updated(self, url, payload, template=None):
        """
        Generic call to see if a template request returns 304
        accepts:
        - a string to combine with the API endpoint
        - a dict of format values, in case they're required by 'url'
        - a template name to check for
        As per the API docs, a template less than 1 hour old is
        assumed to be fresh, and will immediately return False if found
        """
        # If the template is more than an hour old, try a 304
        if abs(datetime.datetime.utcnow().replace(tzinfo=pytz.timezone('GMT'))
                - self.templates[template]['updated']).seconds > 3600:
            query = self.endpoint + url.format(
                u=self.library_id,
                t=self.library_type,
                **payload)
            headers = {
                'If-Modified-Since':
                payload['updated'].strftime("%a, %d %b %Y %H:%M:%S %Z"),
                'User-Agent':
                'Pyzotero/%s' % __version__}
            # perform the request, and check whether the response returns 304
            r = requests.get(query, headers=headers)
            try:
                r.raise_for_status()
            except requests.exceptions.HTTPError:
                error_handler(r)
            return r.status_code == 304
        # Still plenty of life left in't
        return False

    def add_parameters(self, **params):
        """ Add URL parameters. Will always add the api key if it exists
        """
        self.url_params = None
        if hasattr(self, 'api_key') and params:
            params['key'] = self.api_key
        elif hasattr(self, 'api_key'):
            params = {'key': self.api_key}
        # always return json, unless different format is specified
        if 'content' not in params and 'format' not in params:
            params['content'] = 'json'
        self.url_params = urlencode(params)

    def _build_query(self, query_string):
        """
        Set request parameters. Will always add the user ID if it hasn't
        been specifically set by an API method
        """
        try:
            query = quote(query_string.format(
                u=self.library_id,
                t=self.library_type))
        except KeyError as err:
            raise ze.ParamNotPassed(
                'There\'s a request parameter missing: %s' % err)
        # Add the URL parameters and the user key, if necessary
        if not self.url_params:
            self.add_parameters()
        query = '%s?%s' % (query, self.url_params)
        return query

    # The following methods are Zotero Read API calls
    def num_items(self):
        """ Return the total number of top-level items in the library
        """
        query = '/{t}/{u}/items/top'
        return self._totals(query)

    def num_collectionitems(self, collection):
        """ Return the total number of items in the specified collection
        """
        query = '/{t}/{u}/collections/{c}/items'.format(
            u=self.library_id,
            t=self.library_type,
            c=collection.upper())
        return self._totals(query)

    def num_tagitems(self, tag):
        """ Return the total number of items for the specified tag
        """
        query = '/{t}/{u}/tags/{ta}/items'.format(
            u=self.library_id,
            t=self.library_type,
            ta=tag)
        return self._totals(query)

    def _totals(self, query):
        """ General method for returning total counts
        """
        self.add_parameters(limit=1)
        query = self._build_query(query)
        data = self._retrieve_data(query)
        self.url_params = None
        parsed = feedparser.parse(data)
        # extract the 'total items' figure
        return int(parsed.feed['zapi_totalresults'])

    @retrieve
    def items(self, **kwargs):
        """ Get user items
        """
        query_string = '/{t}/{u}/items'
        return self._build_query(query_string)

    @retrieve
    def top(self, **kwargs):
        """ Get user top-level items
        """
        query_string = '/{t}/{u}/items/top'
        return self._build_query(query_string)

    @retrieve
    def trash(self, **kwargs):
        """ Get all items in the trash
        """
        query_string = '/{t}/{u}/items/trash'
        return self._build_query(query_string)

    @retrieve
    def item(self, item, **kwargs):
        """ Get a specific item
        """
        query_string = '/{t}/{u}/items/{i}'.format(
            u=self.library_id,
            t=self.library_type,
            i=item.upper())
        return self._build_query(query_string)

    @retrieve
    def children(self, item, **kwargs):
        """ Get a specific item's child items
        """
        query_string = '/{t}/{u}/items/{i}/children'.format(
            u=self.library_id,
            t=self.library_type,
            i=item.upper())
        return self._build_query(query_string)

    @retrieve
    def tag_items(self, tag, **kwargs):
        """ Get items for a specific tag
        """
        query_string = '/{t}/{u}/tags/{ta}/items'.format(
            u=self.library_id,
            t=self.library_type,
            ta=tag)
        return self._build_query(query_string)

    @retrieve
    def collection_items(self, collection, **kwargs):
        """ Get a specific collection's items
        """
        query_string = '/{t}/{u}/collections/{c}/items'.format(
            u=self.library_id,
            t=self.library_type,
            c=collection.upper())
        return self._build_query(query_string)

    @retrieve
    def collections(self, **kwargs):
        """ Get user collections
        """
        query_string = '/{t}/{u}/collections'
        return self._build_query(query_string)

    @retrieve
    def collections_sub(self, collection, **kwargs):
        """ Get subcollections for a specific collection
        """
        query_string = '/{t}/{u}/collections/{c}/collections'.format(
            u=self.library_id,
            t=self.library_type,
            c=collection.upper())
        return self._build_query(query_string)

    @retrieve
    def groups(self, **kwargs):
        """ Get user groups
        """
        query_string = '/users/{u}/groups'
        return self._build_query(query_string)

    @retrieve
    def tags(self, **kwargs):
        """ Get tags for a specific item
        """
        query_string = '/{t}/{u}/tags'
        return self._build_query(query_string)

    @retrieve
    def item_tags(self, item, **kwargs):
        """ Get tags for a specific item
        """
        query_string = '/{t}/{u}/items/{i}/tags'.format(
            u=self.library_id,
            t=self.library_type,
            i=item.upper())
        return self._build_query(query_string)

    def all_top(self, **kwargs):
        """ Retrieve all top-level items
        """
        return self.everything(self.top(**kwargs))

    @retrieve
    def follow(self):
        """ Return the result of the call to the URL in the 'Next' link
        """
        if self.links:
            return self.links.get('next')
        else:
            return None

    def iterfollow(self):
        """ Generator for self.follow()
        """
        # use same criterion as self.follow()
        while self.links.get('next'):
            yield self.follow()

    def makeiter(self, func):
        """ Return a generator of func's results
        """
        _ = func
        # reset the link. This results in an extra API call, yes
        self.links['next'] = self.links['self']
        return self.iterfollow()

    def everything(self, query):
        """
        Retrieve all items in the library for a particular query
        This method will override the 'limit' parameter if it's been set
        """
        items = []
        items.extend(query)
        while not self.links['self'] == self.links['last']:
            items.extend(self.follow())
        return items

    def get_subset(self, subset):
        """
        Retrieve a subset of items
        Accepts a single argument: a list of item IDs
        """
        if len(subset) > 50:
            raise ze.TooManyItems(
                "You may only retrieve 50 items per call")
        # remember any url parameters that have been set
        params = self.url_params
        retr = []
        for itm in subset:
            retr.extend(self.item(itm))
            self.url_params = params
        # clean up URL params when we're finished
        self.url_params = None
        return retr

    # The following methods process data returned by Read API calls
    def _json_processor(self, retrieved):
        """ Format and return data from API calls which return Items
        """
        json_kwargs = {}
        if self.preserve_json_order:
            json_kwargs['object_pairs_hook'] = OrderedDict
        # send entries to _tags_data if there's no JSON
        try:
            items = [json.loads(e['content'][0]['value'], **json_kwargs)
                     for e in retrieved.entries]
        except KeyError:
            return self._tags_data(retrieved)
        # try to add various namespaced values to the items
        zapi_keys = ['key']
        for zapi in zapi_keys:
            try:
                for key, _ in enumerate(items):
                    items[key][zapi] = \
                        retrieved.entries[key]['zapi_%s' % zapi]
            except KeyError:
                pass
        for key, _ in enumerate(items):
            try:
        # add the etags
                items[key][u'etag'] = self.etags[key]
            except TypeError:
                pass
        # try to add the updated time in the same format the server expects it
            items[key][u'updated'] = \
                time.strftime(
                    "%a, %d %b %Y %H:%M:%S %Z",
                    retrieved.entries[key]['updated_parsed'])
        # Try to get a group ID, and add it to the dict
        try:
            group_id = [urlparse(g['links'][0]['href']).path.split('/')[2]
                        for g in retrieved.entries]
            for k, val in enumerate(items):
                val[u'group_id'] = group_id[k]
        except KeyError:
            pass
        self.url_params = None
        return items

    def _csljson_processor(self, retrieved):
        """ Return a list of dicts which are dumped CSL JSON
        """
        items = []
        json_kwargs = {}
        if self.preserve_json_order:
            json_kwargs['object_pairs_hook'] = OrderedDict
        for csl in retrieved.entries:
            items.append(json.loads(csl['content'][0]['value'], **json_kwargs))
        self.url_params = None
        return items

    def _bib_processor(self, retrieved):
        """ Return a list of strings formatted as HTML bibliography entries
        """
        items = []
        for bib in retrieved.entries:
            items.append(bib['content'][0]['value'])
        self.url_params = None
        return items

    def _citation_processor(self, retrieved):
        """ Return a list of strings formatted as HTML citation entries
        """
        items = []
        for cit in retrieved.entries:
            items.append(cit['content'][0]['value'])
        self.url_params = None
        return items

    def _tags_data(self, retrieved):
        """ Format and return data from API calls which return Tags
        """
        tags = [t['title'] for t in retrieved.entries]
        self.url_params = None
        return tags

    # The following methods are Write API calls
    def item_template(self, itemtype):
        """ Get a template for a new item
        """
        # if we have a template and it hasn't been updated since we stored it
        template_name = 'item_template_' + itemtype
        query_string = '/items/new?itemType={i}'.format(
            i=itemtype)
        if self.templates.get(template_name) and not \
                self._updated(
                    query_string,
                    self.templates[template_name],
                    template_name):
            return self.templates[template_name]['tmplt']
        # otherwise perform a normal request and cache the response
        retrieved = self._retrieve_data(query_string)
        return self._cache(json.loads(retrieved), template_name)

    def _attachment_template(self, attachment_type):
        """
        Return a new attachment template of the required type:
        imported_file
        imported_url
        linked_file
        linked_url
        """
        return self.item_template('attachment&linkMode=' + attachment_type)

    def _attachment(self, payload, parentid=None):
        """
        Create attachments
        accepts a list of one or more attachment template dicts
        and an optional parent Item ID. If this is specified,
        attachments are created under this ID
        """
        def verify(files):
            """
            ensure that all files to be attached exist
            open()'s better than exists(), cos it avoids a race condition
            """
            for templt in files:
                if os.path.isfile(templt[u'filename']):
                    try:
                        # if it is a file, try to open it, and catch the error
                        with open(templt[u'filename']) as _:
                            pass
                    except IOError:
                        raise ze.FileDoesNotExist(
                            "The file at %s couldn't be opened or found." %
                            templt[u'filename'])
                # no point in continuing if the file isn't a file
                else:
                    raise ze.FileDoesNotExist(
                        "The file at %s couldn't be opened or found." %
                        templt[u'filename'])

        def create_prelim(payload):
            """
            Step 0: Register intent to upload files
            """
            verify(payload)
            if not parentid:
                liblevel = '/users/{u}/items?key={k}'
            else:
                liblevel = '/users/{u}/items/{i}/children?key={k}'
            # Create one or more new attachments
            headers = {
                'X-Zotero-Write-Token': token(),
                'Content-Type': 'application/json',
                'User-Agent': 'Pyzotero/%s' % __version__
            }
            to_send = json.dumps({'items': payload})
            req = requests.post(
                url=self.endpoint
                + liblevel.format(
                    u=self.library_id,
                    i=parentid,
                    k=self.api_key),
                data=to_send,
                headers=headers)
            try:
                req.raise_for_status()
            except requests.exceptions.HTTPError:
                error_handler(req)
            data = req.text
            return self._json_processor(feedparser.parse(data))

        def get_auth(attachment):
            """
            Step 1: get upload authorisation for a file
            """
            mtypes = mimetypes.guess_type(attachment)
            digest = hashlib.md5()
            with open(attachment, 'rb') as f:
                for chunk in iter(lambda: f.read(8192), b''):
                    digest.update(chunk)
            auth_headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'If-None-Match': '*',
                'User-Agent': 'Pyzotero/%s' % __version__
            }
            data = {
                'md5': digest.hexdigest(),
                'filename': os.path.basename(attachment),
                'filesize': os.path.getsize(attachment),
                'mtime': str(int(os.path.getmtime(attachment) * 1000)),
                'contentType': mtypes[0] or 'application/octet-stream',
                'charset': mtypes[1]
            }
            auth_req = requests.post(
                url=self.endpoint
                + '/users/{u}/items/{i}/file?key={k}'.format(
                    u=self.library_id,
                    i=created[idx]['key'],
                    k=self.api_key),
                data=data,
                headers=auth_headers)
            try:
                auth_req.raise_for_status()
            except requests.exceptions.HTTPError:
                error_handler(auth_req)
            return json.loads(auth_req.text)

        def uploadfile(authdata):
            """
            Step 2: auth successful, and file not on server
            zotero.org/support/dev/server_api/file_upload#a_full_upload
            """
            upload_file = bytearray(authdata['prefix'].encode())
            upload_file.extend(open(attach, 'r').read()),
            upload_file.extend(authdata['suffix'].encode())
            # Requests chokes on bytearrays, so convert to str
            upload_dict = {
                'file': (
                    os.path.basename(attach),
                    str(upload_file))}
            upload = requests.post(
                url=authdata['url'],
                files=upload_dict,
                headers={
                    "Content-Type": authdata['contentType'],
                    'User-Agent': 'Pyzotero/%s' % __version__})
            try:
                upload.raise_for_status()
            except requests.exceptions.HTTPError:
                error_handler(upload)
            return register_upload(authdata)

        def register_upload(authdata):
            """
            Step 3: upload successful, so register it
            """
            reg_headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'If-None-Match': '*',
                'User-Agent': 'Pyzotero/%s' % __version__
            }
            reg_data = {
                'upload': authdata.get('uploadKey')
            }
            upload_reg = requests.post(
                url=self.endpoint
                + '/users/{u}/items/{i}/file?key={k}'.format(
                    u=self.library_id,
                    i=created[idx]['key'],
                    k=self.api_key),
                data=reg_data,
                headers=reg_headers)
            try:
                upload_reg.raise_for_status()
            except requests.exceptions.HTTPError:
                error_handler(upload_reg)

        created = create_prelim(payload)
        for idx, content in enumerate(created):
            attach = content.get('filename')
            if attach:
                authdata = get_auth(attach)
                # only upload files that don't exist
                if not authdata.get('exists'):
                    uploadfile(authdata)
                else:
                    # item exists
                    continue
        return True

    def add_tags(self, item, *tags):
        """
        Add one or more tags to a retrieved item,
        then update it on the server
        Accepts a dict, and one or more tags to add to it
        Returns the updated item from the server
        """
        # Make sure there's a tags field, or add one
        try:
            assert(item['tags'])
        except AssertionError:
            item['tags'] = list()
        for tag in tags:
            item['tags'].append({u'tag': u'%s' % tag})
        # make sure everything's OK
        assert(self.check_items([item]))
        return self.update_item(item)

    def check_items(self, items):
        """
        Check that items to be created contain no invalid dict keys
        Accepts a single argument: a list of one or more dicts
        The retrieved fields are cached and re-used until a 304 call fails
        """
        # check for a valid cached version
        if self.templates.get('item_fields') and not \
                self._updated(
                    '/itemFields',
                    self.templates['item_fields'],
                    'item_fields'):
            template = set(
                t['field'] for t in self.templates['item_fields']['tmplt'])
        else:
            template = set(
                t['field'] for t in self.item_fields())
        # add fields we know to be OK
        template = template | set([
            'tags',
            'notes',
            'itemType',
            'creators',
            'mimeType',
            'linkMode',
            'note',
            'charset'])
        template = template | set(self.temp_keys)
        for pos, item in enumerate(items):
            to_check = set(i for i in list(item.keys()))
            difference = to_check.difference(template)
            if difference:
                raise ze.InvalidItemFields(
                    "Invalid keys present in item %s: %s" % (pos + 1,
                    ' '.join(i for i in difference)))
        return True

    def item_types(self):
        """ Get all available item types
        """
        # Check for a valid cached version
        if self.templates.get('item_types') and not \
                self._updated(
                    '/itemTypes',
                    self.templates['item_types'],
                    'item_types'):
            return self.templates['item_types']['tmplt']
        query_string = '/itemTypes'
        # otherwise perform a normal request and cache the response
        retrieved = self._retrieve_data(query_string)
        return self._cache(json.loads(retrieved), 'item_types')

    def creator_fields(self):
        """ Get localised creator fields
        """
        # Check for a valid cached version
        if self.templates.get('creator_fields') and not \
                self._updated(
                    '/creatorFields',
                    self.templates['creator_fields'],
                    'creator_fields'):
            return self.templates['creator_fields']['tmplt']
        query_string = '/creatorFields'
        # otherwise perform a normal request and cache the response
        retrieved = self._retrieve_data(query_string)
        return self._cache(json.loads(retrieved), 'creator_fields')

    def item_type_fields(self, itemtype):
        """ Get all valid fields for an item
        """
        # check for a valid cached version
        template_name = 'item_type_fields_' + itemtype
        query_string = '/itemTypeFields?itemType={i}'.format(
            i=itemtype)
        if self.templates.get(template_name) and not \
                self._updated(
                    query_string,
                    self.templates[template_name],
                    template_name):
            return self.templates[template_name]['tmplt']
        # otherwise perform a normal request and cache the response
        retrieved = self._retrieve_data(query_string)
        return self._cache(json.loads(retrieved), template_name)

    def item_fields(self):
        """ Get all available item fields
        """
        # Check for a valid cached version
        if self.templates.get('item_fields') and not \
                self._updated(
                    '/itemFields',
                    self.templates['item_fields'],
                    'item_fields'):
            return self.templates['item_fields']['tmplt']
        query_string = '/itemFields'
        # otherwise perform a normal request and cache the response
        retrieved = self._retrieve_data(query_string)
        return self._cache(json.loads(retrieved), 'item_fields')

    def item_creator_types(self, itemtype):
        """ Get all available creator types for an item
        """
        # check for a valid cached version
        template_name = 'item_creator_types_' + itemtype
        query_string = '/itemTypeFields?itemType={i}'.format(
            i=itemtype)
        if self.templates.get(template_name) and not \
                self._updated(
                    query_string,
                    self.templates[template_name],
                    template_name):
            return self.templates[template_name]['tmplt']
        # otherwise perform a normal request and cache the response
        retrieved = self._retrieve_data(query_string)
        return self._cache(json.loads(retrieved), template_name)

    def create_items(self, payload):
        """
        Create new Zotero items
        Accepts one argument, a list containing one or more item dicts
        """
        if len(payload) > 50:
            raise ze.TooManyItems(
                "You may only create up to 50 items per call")
        to_send = json.dumps({'items': [i for i in self._cleanup(*payload)]})
        headers = {
            'X-Zotero-Write-Token': token(),
            'Content-Type': 'application/json',
            'User-Agent': 'Pyzotero/%s' % __version__
        }
        req = requests.post(
            url=self.endpoint
            + '/{t}/{u}/items?key={k}'.format(
                t=self.library_type,
                u=self.library_id,
                k=self.api_key),
            data=to_send,
            headers=headers)
        data = req.text
        try:
            req.raise_for_status()
        except requests.exceptions.HTTPError:
            error_handler(req)
        return self._json_processor(feedparser.parse(data))

    def create_collection(self, payload):
        """
        Create a new Zotero collection
        Accepts one argument, a dict containing the following keys:

        'name': the name of the collection
        'parent': OPTIONAL, the parent collection to which you wish to add this
        """
        # no point in proceeding if there's no 'name' key
        if 'name' not in payload:
            raise ze.ParamNotPassed(
                "The dict you pass must include a 'name' key")
        # add a blank 'parent' key if it hasn't been passed
        if not 'parent' in payload:
            payload['parent'] = ''
        headers = {
            'X-Zotero-Write-Token': token(),
            'User-Agent': 'Pyzotero/%s' % __version__
        }
        req = requests.post(
            url=self.endpoint
            + '/{t}/{u}/collections?key={k}'.format(
                t=self.library_type,
                u=self.library_id,
                k=self.api_key),
            headers=headers,
            data=json.dumps(payload))
        try:
            req.raise_for_status()
        except requests.exceptions.HTTPError:
            error_handler(req)
        return True

    def update_collection(self, payload):
        """
        Update a Zotero collection
        Accepts one argument, a dict containing collection data retrieved
        using e.g. 'collections()'
        """
        tkn = payload['etag']
        key = payload['key']
        # remove any keys we've added
        to_send = (i for i in self._cleanup(payload))
        headers = {
            'If-Match': tkn,
            'User-Agent': 'Pyzotero/%s' % __version__
        }
        req = requests.put(
            url=self.endpoint
            + '/{t}/{u}/collections/{c}'.format(
                t=self.library_type, u=self.library_id, c=key)
            + '?' + urlencode({'key': self.api_key}),
            headers=headers,
            payload=to_send)
        try:
            req.raise_for_status()
        except requests.exceptions.HTTPError:
            error_handler(req)
        return True

    def attachment_simple(self, files, parentid=None):
        """
        Add attachments using filenames as title
        Arguments:
        One or more file paths to add as attachments:
        An optional Item ID, which will create child attachments
        """
        orig = self._attachment_template('imported_file')
        to_add = [orig.copy() for f in files]
        for idx, tmplt in enumerate(to_add):
            tmplt['title'] = os.path.basename(files[idx])
            tmplt['filename'] = files[idx]
        if parentid:
            return self._attachment(to_add, parentid)
        else:
            return self._attachment(to_add)

    def attachment_both(self, files, parentid=None):
        """
        Add child attachments using title, filename
        Arguments:
        One or more lists or tuples containing title, file path
        An optional Item ID, which will create child attachments
        """
        orig = self._attachment_template('imported_file')
        to_add = [orig.copy() for f in files]
        for idx, tmplt in enumerate(to_add):
            tmplt['title'] = files[idx][0]
            tmplt['filename'] = files[idx][1]
        if parentid:
            return self._attachment(to_add, parentid)
        else:
            return self._attachment(to_add)

    def update_item(self, payload):
        """
        Update an existing item
        Accepts one argument, a dict containing Item data
        """
        etag = payload['etag']
        ident = payload['key']
        to_send = json.dumps(*self._cleanup(payload))
        headers = {
            'If-Match': etag,
            'Content-Type': 'application/json',
            'User-Agent': 'Pyzotero/%s' % __version__,
        }
        req = requests.put(
            url=self.endpoint
            + '/{t}/{u}/items/'.format(
                t=self.library_type, u=self.library_id)
            + ident
            + '?' + urlencode({'key': self.api_key}),
            headers=headers,
            data=to_send)
        try:
            req.raise_for_status()
        except requests.exceptions.HTTPError:
            error_handler(req)
        data = req.text
        self.etags = etags(data)
        return self._json_processor(feedparser.parse(data))

    def addto_collection(self, collection, payload):
        """
        Add one or more items to a collection
        Accepts two arguments:
        The collection ID, and a list containing one or more item dicts
        """
        # create a string containing item IDs
        to_send = ' '.join([p['key'].encode('utf8') for p in payload])
        headers = {
            'User-Agent': 'Pyzotero/%s' % __version__
        }
        req = requests.post(
            url=self.endpoint
            + '/{t}/{u}/collections/{c}/items?key={k}'.format(
                t=self.library_type,
                u=self.library_id,
                c=collection.upper(),
                k=self.api_key),
            data=to_send,
            headers=headers)
        try:
            req.raise_for_status()
        except requests.exceptions.HTTPError:
            error_handler(req)
        return True

    def deletefrom_collection(self, collection, payload):
        """
        Delete an item from a collection
        Accepts two arguments:
        The collection ID, and a dict containing one or more item dicts
        """
        ident = payload['key']
        req = requests.delete(
            url=self.endpoint
            + '/{t}/{u}/collections/{c}/items/'.format(
                t=self.library_type,
                u=self.library_id,
                c=collection.upper())
            + ident + '?' + urlencode({'key': self.api_key}),
            headers={'User-Agent': 'Pyzotero/%s' % __version__})
        try:
            req.raise_for_status()
        except requests.exceptions.HTTPError:
            error_handler(req)
        return True

    def delete_item(self, payload):
        """
        Delete an Item from a Zotero library
        Accepts a single argument: a dict containing item data
        """
        etag = payload['etag']
        ident = payload['key']
        headers = {
            'If-Match': etag,
            'User-Agent': 'Pyzotero/%s' % __version__,
        }
        req = requests.delete(
            url=self.endpoint
            + '/{t}/{u}/items/'.format(
                t=self.library_type, u=self.library_id)
            + ident + '?' + urlencode({'key': self.api_key}),
            headers=headers
        )
        try:
            req.raise_for_status()
        except requests.exceptions.HTTPError:
            error_handler(req)
        return True

    def delete_collection(self, payload):
        """
        Delete a Collection from a Zotero library
        Accepts a single argument: a dict containing item data
        """
        etag = payload['etag']
        ident = payload['key']
        headers = {
            'If-Match': etag,
            'User-Agent': 'Pyzotero/%s' % __version__,
        }
        req = requests.delete(
            url=self.endpoint
            + '/{t}/{u}/collections/{c}'.format(
                t=self.library_type,
                u=self.library_id,
                c=ident) +
            '?' + urlencode({'key': self.api_key}),
            headers=headers)
        try:
            req.raise_for_status()
        except requests.exceptions.HTTPError:
            error_handler(req)
        return True


class Backoff():
    """ a simple backoff timer for HTTP 429 responses """
    def __init__(self, delay=1):
        self.wait = delay

    @property
    def delay(self):
        self.wait = self.wait * 2
        return self.wait

    def reset(self):
        self.wait = 1


backoff = Backoff()


def error_handler(req):
    """ Error handler for HTTP requests
    """
    error_codes = {
        400: ze.UnsupportedParams,
        401: ze.UserNotAuthorised,
        403: ze.UserNotAuthorised,
        404: ze.ResourceNotFound,
        409: ze.Conflict,
        412: ze.PreConditionFailed,
        413: ze.RequestEntityTooLarge,
        428: ze.PreConditionRequired,
        429: ze.TooManyRequests,
    }

    def err_msg(req):
        """ Return a nicely-formatted error message
        """
        return "\nCode: %s\nURL: %s\nMethod: %s\nResponse: %s" % (
            req.status_code,
            # error.msg,
            req.url,
            req.request.method,
            req.text)

    if error_codes.get(req.status_code):
        # check to see whether its 429
        if req.status_code == 429:
            # call our back-off function
            delay = backoff.delay
            if delay > 32:
                # we've waited a total of 62 seconds (2 + 4 … + 32), so give up
                backoff.reset()
                raise ze.TooManyRetries("Continuing to receive HTTP 429 \
responses after 62 seconds. You are being rate-limited, try again later")
            time.sleep(delay)
            s = requests.Session()
            new_req = s.send(req.request)
            try:
                new_req.raise_for_status()
            except requests.exceptions.HTTPError:
                error_handler(new_req)
        else:
            raise error_codes.get(req.status_code)(err_msg(req))
    else:
        raise ze.HTTPError(err_msg(req))

########NEW FILE########
__FILENAME__ = zotero_errors
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
zotero_errors.py

Created by Stephan Hügel on 2011-03-04
Copyright Stephan Hügel, 2011

This file is part of Pyzotero.

Pyzotero is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Pyzotero is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Pyzotero. If not, see <http://www.gnu.org/licenses/>.
"""


# Define some exceptions
class PyZoteroError(Exception):
    """ Generic parent exception
    """
    pass


class ParamNotPassed(PyZoteroError):
    """ Raised if a parameter which is required isn't passed
    """
    pass


class CallDoesNotExist(PyZoteroError):
    """ Raised if the specified API call doesn't exist
    """
    pass


class UnsupportedParams(PyZoteroError):
    """ Raised when unsupported parameters are passed
    """
    pass


class UserNotAuthorised(PyZoteroError):
    """ Raised when the user is not allowed to retrieve the resource
    """
    pass


class TooManyItems(PyZoteroError):
    """ Raised when too many items are passed to a Write API method
    """
    pass


class MissingCredentials(PyZoteroError):
    """
    Raised when an attempt is made to create a Zotero instance
    without providing both the user ID and the user key
    """
    pass


class InvalidItemFields(PyZoteroError):
    """ Raised when an attempt is made to create/update items w/invalid fields
    """
    pass


class ResourceNotFound(PyZoteroError):
    """ Raised when a resource (item, collection etc.) could not be found
    """
    pass


class HTTPError(PyZoteroError):
    """ Raised for miscellaneous URLLib errors
    """
    pass


class CouldNotReachURL(PyZoteroError):
    """ Raised when we can't reach a URL
    """
    pass


class Conflict(PyZoteroError):
    """ 409 - Raised when the target library is locked
    """
    pass


class PreConditionFailed(PyZoteroError):
    """
    412 - Raised when the provided X-Zotero-Write-Token has already been
    submitted
    """
    pass


class RequestEntityTooLarge(PyZoteroError):
    """
    413 – The upload would exceed the storage quota of the library owner.
    """
    pass


class PreConditionRequired(PyZoteroError):
    """
    428 - Raised when If-Match or If-None-Match was not provided.
    """
    pass


class TooManyRequests(PyZoteroError):
    """
    429 - Raised when Too many unfinished uploads.
    Try again after the number of seconds specified in the Retry-After header.
    """
    pass


class FileDoesNotExist(PyZoteroError):
    """
    Raised when a file path to be attached can't be opened (or doesn't exist)
    """
    pass


class TooManyRetries(PyZoteroError):
    """
    Raise after the backoff period for new requests exceeds 32s
    """
    pass

########NEW FILE########
