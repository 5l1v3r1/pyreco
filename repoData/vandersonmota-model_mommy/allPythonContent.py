__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Model Mommy documentation build configuration file, created by
# sphinx-quickstart on Wed Apr 30 11:58:35 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.viewcode',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Model Mommy'
copyright = u'2014, Lucas Simon Rodrigues Magalhaes'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.2.1'
# The full version, including alpha/beta/rc tags.
release = '1.2.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'ModelMommydoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'ModelMommy.tex', u'Model Mommy Documentation',
   u'Lucas Simon Rodrigues Magalhaes', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'modelmommy', u'Model Mommy Documentation',
     [u'Lucas Simon Rodrigues Magalhaes'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'ModelMommy', u'Model Mommy Documentation',
   u'Lucas Simon Rodrigues Magalhaes', 'ModelMommy', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


# -- Options for Epub output ----------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Model Mommy'
epub_author = u'Lucas Simon Rodrigues Magalhaes'
epub_publisher = u'Lucas Simon Rodrigues Magalhaes'
epub_copyright = u'2014, Lucas Simon Rodrigues Magalhaes'

# The basename for the epub file. It defaults to the project name.
#epub_basename = u'Model Mommy'

# The HTML theme for the epub output. Since the default themes are not optimized
# for small screen space, using the same theme for HTML and epub output is
# usually not wise. This defaults to 'epub', a theme designed to save visual
# space.
#epub_theme = 'epub'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# A sequence of (type, uri, title) tuples for the guide element of content.opf.
#epub_guide = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

# Choose between 'default' and 'includehidden'.
#epub_tocscope = 'default'

# Fix unsupported image types using the PIL.
#epub_fix_images = False

# Scale large images.
#epub_max_image_width = 0

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#epub_show_urls = 'inline'

# If false, no index is generated.
#epub_use_index = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = exceptions
#coding:utf-8


class RecipeNotFound(Exception):
    pass


class RecipeIteratorEmpty(Exception):
    pass


class ModelNotFound(Exception):
    pass


class AmbiguousModelName(Exception):
    pass


class InvalidQuantityException(Exception):
    pass

########NEW FILE########
__FILENAME__ = generators
# -*- coding:utf-8 -*-
"""
Generators are callables that return a value used to populate a field.

If this callable has a `required` attribute (a list, mostly), for each item in
the list, if the item is a string, the field attribute with the same name will
be fetched from the field and used as argument for the generator. If it is a
callable (which will receive `field` as first argument), it should return a
list in the format (key, value) where key is the argument name for generator
and value is the value for that argument.
"""

import string
from decimal import Decimal
from os.path import abspath, join, dirname
from random import randint, choice, random
from django import VERSION
from django.core.files.base import ContentFile

from model_mommy.timezone import now


MAX_LENGTH = 300
# Using sys.maxint here breaks a bunch of tests when running against a
# Postgres database.
MAX_INT = 10000

def get_content_file(content, name):
    if VERSION < (1, 4):
        return ContentFile(content)
    else:
        return ContentFile(content, name=name)

def gen_file_field():
    name = u'mock_file.txt'
    file_path = abspath(join(dirname(__file__), name))
    with open(file_path, 'rb') as f:
        return get_content_file(f.read(), name=name)

def gen_image_field():
    name = u'mock-img.jpeg'
    file_path = abspath(join(dirname(__file__), name))
    with open(file_path, 'rb') as f:
        return get_content_file(f.read(), name=name)


def gen_from_list(L):
    '''Makes sure all values of the field are generated from the list L
    Usage:
    from mommy import Mommy
    class KidMommy(Mommy):
      attr_mapping = {'some_field':gen_from_list([A, B, C])}
    '''
    return lambda: choice(list(L))

# -- DEFAULT GENERATORS --


def gen_from_choices(C):
    choice_list = []
    for value, label in C:
        if isinstance(label, (list, tuple)):
            for val, lbl in label:
                choice_list.append(val)
        else:
            choice_list.append(value)
    return gen_from_list(choice_list)


def gen_integer(min_int=-MAX_INT, max_int=MAX_INT):
    return randint(min_int, max_int)


def gen_float():
    return random() * gen_integer()


def gen_decimal(max_digits, decimal_places):
    num_as_str = lambda x: ''.join([str(randint(0, 9)) for i in range(x)])
    return Decimal("%s.%s" % (num_as_str(max_digits - decimal_places),
                              num_as_str(decimal_places)))
gen_decimal.required = ['max_digits', 'decimal_places']


def gen_date():
    return now().date()


def gen_datetime():
    return now()


def gen_time():
    return now().time()


def gen_string(max_length):
    return u''.join(choice(string.ascii_letters) for i in range(max_length))
gen_string.required = ['max_length']


def gen_slug(max_length):
    valid_chars = string.ascii_letters + string.digits + '_-'
    return u''.join(choice(valid_chars) for i in range(max_length))
gen_slug.required = ['max_length']


def gen_text():
    return gen_string(MAX_LENGTH)


def gen_boolean():
    return choice((True, False))


def gen_url():
    return u'http://www.%s.com' % gen_string(30)


def gen_email():
    return u"%s@example.com" % gen_string(10)


def gen_ipv6():
    return ":".join(format(randint(1, 65535), 'x') for i in range(8))


def gen_ipv4():
    return ".".join(str(randint(1, 255)) for i in range(4))


def gen_content_type():
    from django.contrib.contenttypes.models import ContentType
    from django.db.models import get_models

    return ContentType.objects.get_for_model(choice(get_models()))

########NEW FILE########
__FILENAME__ = mommy
# -*- coding: utf-8 -*-
import warnings

from django.conf import settings
from django.utils import importlib
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
import django
from django.db.models.loading import get_model
if django.VERSION >= (1, 7):
    from django.apps import apps
else:
    from django.db.models.loading import cache
from django.db.models.base import ModelBase
from django.db.models import (
    CharField, EmailField, SlugField, TextField, URLField,
    DateField, DateTimeField, TimeField,
    AutoField, IntegerField, SmallIntegerField,
    PositiveIntegerField, PositiveSmallIntegerField,
    BooleanField, DecimalField, FloatField,
    FileField, ImageField, Field,
    ForeignKey, ManyToManyField, OneToOneField)
from django.db.models.fields.related import ForeignRelatedObjectsDescriptor
try:
    from django.db.models import BigIntegerField
except ImportError:
    BigIntegerField = IntegerField

from . import generators
from .exceptions import ModelNotFound, AmbiguousModelName, InvalidQuantityException, RecipeIteratorEmpty

from six import string_types, advance_iterator, PY3

recipes = None

# FIXME: use pkg_resource
from os.path import dirname, join
mock_file_jpeg = join(dirname(__file__), 'mock-img.jpeg')
mock_file_txt = join(dirname(__file__), 'mock_file.txt')


#TODO: improve related models handling
foreign_key_required = [lambda field: ('model', field.related.parent_model)]

MAX_MANY_QUANTITY = 5

def make(model, _quantity=None, make_m2m=False, **attrs):
    """
    Creates a persisted instance from a given model its associated models.
    It fill the fields with random values or you can specify
    which fields you want to define its values by yourself.
    """
    mommy = Mommy(model, make_m2m=make_m2m)
    if _quantity and (not isinstance(_quantity, int) or _quantity < 1):
        raise InvalidQuantityException

    if _quantity:
        return [mommy.make(**attrs) for i in range(_quantity)]
    else:
        return mommy.make(**attrs)


def prepare(model, _quantity=None, **attrs):
    """
    Creates a BUT DOESN'T persist an instance from a given model its
    associated models.
    It fill the fields with random values or you can specify
    which fields you want to define its values by yourself.
    """
    mommy = Mommy(model)
    if _quantity and (not isinstance(_quantity, int) or _quantity < 1):
        raise InvalidQuantityException

    if _quantity:
        return [mommy.prepare(**attrs) for i in range(_quantity)]
    else:
        return mommy.prepare(**attrs)


def _recipe(name):
    app, recipe_name = name.rsplit('.', 1)
    recipes = importlib.import_module('.'.join([app, 'mommy_recipes']))
    return getattr(recipes, recipe_name)

def make_recipe(mommy_recipe_name, _quantity=None, **new_attrs):
    return _recipe(mommy_recipe_name).make(_quantity=_quantity, **new_attrs)

def prepare_recipe(mommy_recipe_name, _quantity=None, **new_attrs):
    return _recipe(mommy_recipe_name).prepare(_quantity=_quantity, **new_attrs)


def __m2m_generator(model, **attrs):
    return make(model, _quantity=MAX_MANY_QUANTITY, **attrs)

make.required = foreign_key_required
prepare.required = foreign_key_required
__m2m_generator.required = foreign_key_required

default_mapping = {
    BooleanField: generators.gen_boolean,
    IntegerField: generators.gen_integer,
    BigIntegerField: generators.gen_integer,
    SmallIntegerField: generators.gen_integer,

    PositiveIntegerField: lambda: generators.gen_integer(0),
    PositiveSmallIntegerField: lambda: generators.gen_integer(0),

    FloatField: generators.gen_float,
    DecimalField: generators.gen_decimal,

    CharField: generators.gen_string,
    TextField: generators.gen_text,
    SlugField: generators.gen_slug,

    ForeignKey: make,
    OneToOneField: make,
    ManyToManyField: __m2m_generator,

    DateField: generators.gen_date,
    DateTimeField: generators.gen_datetime,
    TimeField: generators.gen_time,

    URLField: generators.gen_url,
    EmailField: generators.gen_email,
    FileField: generators.gen_file_field,
    ImageField: generators.gen_image_field,

    ContentType: generators.gen_content_type,
}


class ModelFinder(object):
    '''
    Encapsulates all the logic for finding a model to Mommy.
    '''
    _unique_models = None
    _ambiguous_models = None

    def get_model(self, name):
        '''
        Get a model.

        :param name String on the form 'applabel.modelname' or 'modelname'.
        :return a model class.
        '''
        try:
            if '.' in name:
                app_label, model_name = name.split('.')
                model = get_model(app_label, model_name)
            else:
                model = self.get_model_by_name(name)
        except LookupError:  # Django 1.7.0a1 throws an exception
            # Lower djangos just fail silently
            model = None

        if not model:
            raise ModelNotFound("Could not find model '%s'." % name.title())

        return model

    def get_model_by_name(self, name):
        '''
        Get a model by name.

        If a model with that name exists in more than one app,
        raises AmbiguousModelName.
        '''
        name = name.lower()

        if self._unique_models is None:
            self._populate()

        if name in self._ambiguous_models:
            raise AmbiguousModelName('%s is a model in more than one app. '
                                     'Use the form "app.model".' % name.title())

        return self._unique_models.get(name)

    def _populate(self):
        '''
        Cache models for faster self._get_model.
        '''
        unique_models = {}
        ambiguous_models = []

        if django.VERSION >= (1, 7):
            all_models = apps.all_models
        else:
            all_models = cache.app_models

        for app_model in all_models.values():
            for name, model in app_model.items():
                if name not in unique_models:
                    unique_models[name] = model
                else:
                    ambiguous_models.append(name)

        for name in ambiguous_models:
            unique_models.pop(name, None)

        self._ambiguous_models = ambiguous_models
        self._unique_models = unique_models


def is_iterator(value):
    if PY3:
        return hasattr(value, '__next__')
    else:
        return hasattr(value, 'next')


class Mommy(object):
    attr_mapping = {}
    type_mapping = None

    # Note: we're using one finder for all Mommy instances to avoid
    # rebuilding the model cache for every make_* or prepare_* call.
    finder = ModelFinder()

    def __init__(self, model, make_m2m=False):
        self.make_m2m = make_m2m
        self.m2m_dict = {}

        if isinstance(model, ModelBase):
            self.model = model
        else:
            self.model = self.finder.get_model(model)

        self.init_type_mapping()

    def init_type_mapping(self):
        self.type_mapping = default_mapping.copy()
        generator_from_settings = getattr(settings, 'MOMMY_CUSTOM_FIELDS_GEN', {})
        for k, v in generator_from_settings.items():
            path, field_name = k.rsplit('.', 1)
            field_class = getattr(importlib.import_module(path), field_name)
            self.type_mapping[field_class] = v

    def make(self, **attrs):
        '''Creates and persists an instance of the model
        associated with Mommy instance.'''
        return self._make(commit=True, **attrs)

    def prepare(self, **attrs):
        '''Creates, but do not persists, an instance of the model
        associated with Mommy instance.'''
        self.type_mapping[ForeignKey] = prepare
        self.type_mapping[OneToOneField] = prepare
        return self._make(commit=False, **attrs)

    def get_fields(self):
        return self.model._meta.fields + self.model._meta.many_to_many

    def _make(self, commit=True, **attrs):
        is_rel_field = lambda x: '__' in x
        iterator_attrs = dict((k, v) for k, v in attrs.items() if is_iterator(v))
        model_attrs = dict((k, v) for k, v in attrs.items() if not is_rel_field(k))
        self.rel_attrs = dict((k, v) for k, v in attrs.items() if is_rel_field(k))
        self.rel_fields = [x.split('__')[0] for x in self.rel_attrs.keys() if is_rel_field(x)]

        for field in self.get_fields():

            # Skip links to parent so parent is not created twice.
            if isinstance(field, OneToOneField) and field.rel.parent_link:
                continue

            field_value_not_defined = field.name not in model_attrs

            if isinstance(field, (AutoField, generic.GenericRelation)):
                continue

            if all([field.name not in model_attrs, field.name not in self.rel_fields, field.name not in self.attr_mapping]):
                # Django is quirky in that BooleanFields are always "blank", but have no default default.
                if not issubclass(field.__class__, Field) or field.has_default() or (field.blank and not isinstance(field, BooleanField)):
                    continue

            if isinstance(field, ManyToManyField):
                if field.name not in model_attrs:
                    self.m2m_dict[field.name] = self.m2m_value(field)
                else:
                    self.m2m_dict[field.name] = model_attrs.pop(field.name)
            elif field_value_not_defined:
                if field.name not in self.rel_fields and field.null:
                    continue
                else:
                    model_attrs[field.name] = self.generate_value(field)
            elif callable(model_attrs[field.name]):
                model_attrs[field.name] = model_attrs[field.name]()
            elif field.name in iterator_attrs:
                try:
                    model_attrs[field.name] = advance_iterator(iterator_attrs[field.name])
                except StopIteration:
                    raise RecipeIteratorEmpty('{} iterator is empty.'.format(field.name))

        return self.instance(model_attrs, _commit=commit)

    def m2m_value(self, field):
        if field.name in self.rel_fields:
            return self.generate_value(field)
        if not self.make_m2m or field.null:
            return []
        return self.generate_value(field)

    def instance(self, attrs, _commit):
        one_to_many_keys = {}
        for k in tuple(attrs.keys()):
            field = getattr(self.model, k, None)
            if isinstance(field, ForeignRelatedObjectsDescriptor):
                one_to_many_keys[k] = attrs.pop(k)
        instance = self.model(**attrs)
        # m2m only works for persisted instances
        if _commit:
            instance.save()
            self._handle_one_to_many(instance, one_to_many_keys)
            self._handle_m2m(instance)
        return instance

    def _handle_one_to_many(self, instance, attrs):
        for k, v in attrs.items():
            setattr(instance, k, v)

    def _handle_m2m(self, instance):
        for key, values in self.m2m_dict.items():
            if not values:
                continue

            m2m_relation = getattr(instance, key)
            through_model = m2m_relation.through
            through_fields = through_model._meta.fields

            instance_key, value_key = '', ''
            for field in through_fields:
                if isinstance(field, ForeignKey):
                    if isinstance(instance, field.rel.to):
                        instance_key = field.name
                    elif isinstance(values[0], field.rel.to):
                        value_key = field.name

            base_kwargs = {instance_key: instance}
            for model_instance in values:
                base_kwargs[value_key] = model_instance
                make(through_model, **base_kwargs)

    def generate_value(self, field):
        '''
        Calls the generator associated with a field passing all required args.

        Generator Resolution Precedence Order:
        -- attr_mapping - mapping per attribute name
        -- choices -- mapping from avaiable field choices
        -- type_mapping - mapping from user defined type associated generators
        -- default_mapping - mapping from pre-defined type associated
           generators

        `attr_mapping` and `type_mapping` can be defined easely overwriting the
        model.
        '''
        if field.name in self.attr_mapping:
            generator = self.attr_mapping[field.name]
        elif getattr(field, 'choices'):
            generator = generators.gen_from_choices(field.choices)
        elif isinstance(field, ForeignKey) and isinstance(field.rel.to, ContentType):
            generator = self.type_mapping[ContentType]
        elif field.__class__ in self.type_mapping:
            generator = self.type_mapping[field.__class__]
        else:
            raise TypeError('%s is not supported by mommy.' % field.__class__)

        # attributes like max_length, decimal_places are take in account when
        # generating the value.
        generator_attrs = get_required_values(generator, field)

        if field.name in self.rel_fields:
            generator_attrs.update(filter_rel_attrs(field.name, **self.rel_attrs))

        return generator(**generator_attrs)


def get_required_values(generator, field):
    '''
    Gets required values for a generator from the field.
    If required value is a function, call's it with field as argument.
    If required value is a string, simply fetch the value from the field
    and returns.
    '''
    #FIXME: avoid abreviations
    rt = {}
    if hasattr(generator, 'required'):
        for item in generator.required:

            if callable(item):  # mommy can deal with the nasty hacking too!
                key, value = item(field)
                rt[key] = value

            elif isinstance(item, string_types):
                rt[item] = getattr(field, item)

            else:
                raise ValueError("Required value '%s' is of wrong type. \
                                  Don't make mommy sad." % str(item))

    return rt

def filter_rel_attrs(field_name, **rel_attrs):
    clean_dict = {}

    for k, v in rel_attrs.items():
        if k.startswith(field_name + '__'):
            splited_key = k.split('__')
            key = '__'.join(splited_key[1:])
            clean_dict[key] = v
        else:
            clean_dict[k] = v

    return clean_dict


### DEPRECATED METHODS (should be removed on the future)
def make_many(model, quantity=None, **attrs):
    msg = "make_many is deprecated. You should use make with _quantity parameter."
    warnings.warn(msg, DeprecationWarning)
    quantity = quantity or MAX_MANY_QUANTITY
    mommy = Mommy(model)
    return [mommy.make(**attrs) for i in range(quantity)]


def make_one(model, make_m2m=False, **attrs):
    msg = "make_one is deprecated. You should use the method make instead."
    warnings.warn(msg, DeprecationWarning)
    mommy = Mommy(model, make_m2m=make_m2m)
    return mommy.make(**attrs)


def prepare_one(model, **attrs):
    msg = "prepare_one is deprecated. You should use the method prepare instead."
    warnings.warn(msg, DeprecationWarning)
    mommy = Mommy(model)
    return mommy.prepare(**attrs)


def make_many_from_recipe(mommy_recipe_name, quantity=None, **new_attrs):
    msg = "make_many_from_recipe is deprecated. You should use the method make_recipe with the _quantity parameter instead."
    warnings.warn(msg, DeprecationWarning)
    quantity = quantity or MAX_MANY_QUANTITY
    return [make_recipe(mommy_recipe_name, **new_attrs) for x in range(quantity)]

########NEW FILE########
__FILENAME__ = recipe
#coding: utf-8
import inspect
import itertools
from . import mommy
from .exceptions import RecipeNotFound, RecipeIteratorEmpty

from six import string_types


class Recipe(object):
    def __init__(self, model, **attrs):
        self.attr_mapping = attrs
        self.model = model
        # _iterator_backups will hold values of the form (backup_iterator, usable_iterator).
        self._iterator_backups = {}

    def _mapping(self, new_attrs):
        rel_fields_attrs = dict((k, v) for k, v in new_attrs.items() if '__' in k)
        new_attrs = dict((k, v) for k, v in new_attrs.items() if not '__' in k)
        mapping = self.attr_mapping.copy()
        for k, v in self.attr_mapping.items():
            # do not generate values if field value is provided
            if new_attrs.get(k):
                continue
            elif mommy.is_iterator(v):
                if self.model.objects.count() == 0:
                    self._iterator_backups[k] = itertools.tee(self._iterator_backups.get(k, [v])[0])
                mapping[k] = self._iterator_backups[k][1]
            elif isinstance(v, RecipeForeignKey):
                a={}
                for key, value in list(rel_fields_attrs.items()):
                    if key.startswith('%s__' % k):
                        a[key] = rel_fields_attrs.pop(key)
                recipe_attrs = mommy.filter_rel_attrs(k, **a)
                mapping[k] = v.recipe.make(**recipe_attrs)
            elif isinstance(v, related):
                mapping[k] = v.prepare()
        mapping.update(new_attrs)
        mapping.update(rel_fields_attrs)
        return mapping

    def make(self, **attrs):
        return mommy.make(self.model, **self._mapping(attrs))

    def prepare(self, **attrs):
        return mommy.prepare(self.model, **self._mapping(attrs))


class RecipeForeignKey(object):

    def __init__(self, recipe):
        if isinstance(recipe, Recipe):
            self.recipe = recipe
        elif isinstance(recipe, string_types):
            frame = inspect.stack()[2]
            caller_module = inspect.getmodule(frame[0])
            recipe = getattr(caller_module, recipe)
            if recipe:
                self.recipe = recipe
            else:
                raise RecipeNotFound
        else:
            raise TypeError('Not a recipe')


def foreign_key(recipe):
    """
      Returns the callable, so that the associated model
      will not be created during the recipe definition.
    """
    return RecipeForeignKey(recipe)


def seq(value, increment_by=1):
    for n in itertools.count(increment_by, increment_by):
        yield value + type(value)(n)

class related(object):
    def __init__(self, *args):
        self.related = []
        for recipe in args:
            if isinstance(recipe, Recipe):
                self.related.append(recipe)
            elif isinstance(recipe, string_types):
                frame = inspect.stack()[1]
                caller_module = inspect.getmodule(frame[0])
                recipe = getattr(caller_module, recipe)
                if recipe:
                    self.related.append(recipe)
                else:
                    raise RecipeNotFound
            else:
                raise TypeError('Not a recipe')

    def prepare(self):
        """
            Django related manager saves related set.
            No need to persist at first
        """
        return [m.prepare() for m in self.related]


########NEW FILE########
__FILENAME__ = timezone
# coding: utf-8
'''
Add support for Django 1.4+ safe datetimes.
https://docs.djangoproject.com/en/1.4/topics/i18n/timezones/
'''

from datetime import datetime
from django import VERSION
from django.conf import settings

try:
    from django.utils.timezone import now, utc
except ImportError:
    now = lambda: datetime.now()


def smart_datetime(*args):
    value = datetime(*args)

    if VERSION >= (1, 4) and settings.USE_TZ:
        value = value.replace(tzinfo=utc)

    return value

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python

from os.path import dirname, join
import sys
from optparse import OptionParser
import warnings
import django


def parse_args():
    parser = OptionParser()
    parser.add_option('--use-tz', dest='USE_TZ', action='store_true')
    return parser.parse_args()


def configure_settings(options):
    from django.conf import settings

    # If DJANGO_SETTINGS_MODULE envvar exists the settings will be
    # configured by it. Otherwise it will use the parameters bellow.
    if not settings.configured:
        params = dict(
            DATABASES={
                'default': {
                    'ENGINE': 'django.db.backends.sqlite3',
                    'NAME': ':memory:',
                }
            },
            INSTALLED_APPS = (
                'django.contrib.contenttypes',
                'test.generic',
                'test.ambiguous',
                'test.ambiguous2',
            ),
            SITE_ID=1,
            TEST_RUNNER='django.test.simple.DjangoTestSuiteRunner',
            TEST_ROOT=join(dirname(__file__), 'test', 'generic', 'tests'),
        )

        # Force the use of timezone aware datetime and change Django's warning to
        # be treated as errors.
        if getattr(options, 'USE_TZ', False):
            params.update(USE_TZ=True)
            warnings.filterwarnings('error', r"DateTimeField received a naive datetime",
                                    RuntimeWarning, r'django\.db\.models\.fields')

        # Configure Django's settings
        settings.configure(**params)

    return settings


def get_runner(settings):
    '''
    Asks Django for the TestRunner defined in settings or the default one.
    '''
    from django.test.utils import get_runner
    TestRunner = get_runner(settings)
    if django.VERSION >= (1, 7):
        #  I suspect this will not be necessary in next release after 1.7.0a1:
        #  See https://code.djangoproject.com/ticket/21831
        setattr(settings, 'INSTALLED_APPS',
                ['django.contrib.auth']
                + list(getattr(settings, 'INSTALLED_APPS')))
    return TestRunner(verbosity=1, interactive=True, failfast=False)


def runtests(options=None, labels=None):
    if not labels:
        labels = ['generic']

    settings = configure_settings(options)
    runner = get_runner(settings)
    if django.VERSION >= (1, 7):
        django.setup()
    sys.exit(runner.run_tests(labels))


if __name__ == '__main__':
    options, labels = parse_args()
    runtests(options, labels)

########NEW FILE########
__FILENAME__ = models
# coding: utf-8
from django.db import models


class Ambiguous(models.Model):
    name = models.CharField(max_length=20)

########NEW FILE########
__FILENAME__ = models
# coding: utf-8
from django.db import models


class Ambiguous(models.Model):
    name = models.CharField(max_length=20)

########NEW FILE########
__FILENAME__ = fields
from django.db import models

class CustomFieldWithGenerator(models.TextField):
    pass

class CustomFieldWithoutGenerator(models.TextField):
    pass

########NEW FILE########
__FILENAME__ = forms
from django import VERSION
from django.forms import ModelForm


if VERSION < (1, 4):
    from test.generic.models import DummyIPAddressFieldModel

    class DummyIPAddressFieldForm(ModelForm):
        class Meta:
            model = DummyIPAddressFieldModel
else:
    from test.generic.models import DummyGenericIPAddressFieldModel

    class DummyGenericIPAddressFieldForm(ModelForm):
        class Meta:
            model = DummyGenericIPAddressFieldModel
########NEW FILE########
__FILENAME__ = models
#coding: utf-8

#######################################
# TESTING PURPOSE ONLY MODELS!!       #
# DO NOT ADD THE APP TO INSTALLED_APPS#
#######################################
from decimal import Decimal
from tempfile import gettempdir

from django import VERSION
from django.db import models
from django.core.files.storage import FileSystemStorage

from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from .fields import *
from model_mommy.timezone import smart_datetime as datetime

# check whether or not PIL is installed
try:
    from PIL import ImageFile as PilImageFile
except ImportError:
    has_pil = False
else:
    has_pil = True

GENDER_CH = [('M', 'male'), ('F', 'female')]

OCCUPATION_CHOCIES = (
    ('Service Industry', (
        ('waitress', 'Waitress'),
        ('bartender', 'Bartender'))),
    ('Education', (
        ('teacher', 'Teacher'),
        ('principal', 'Principal'))))


class ModelWithImpostorField(models.Model):
    pass

class Profile(models.Model):
    email = models.EmailField()

class User(models.Model):
    profile = models.ForeignKey(Profile, blank=True, null=True)


class PaymentBill(models.Model):
    user = models.ForeignKey(User)
    value = models.FloatField()


class Person(models.Model):
    gender = models.CharField(max_length=1, choices=GENDER_CH)
    happy = models.BooleanField(default=True)
    unhappy = models.BooleanField(default=False)
    bipolar = models.BooleanField()
    name = models.CharField(max_length=30)
    nickname = models.SlugField(max_length=36)
    age = models.IntegerField()
    bio = models.TextField()
    birthday = models.DateField()
    birth_time = models.TimeField()
    appointment = models.DateTimeField()
    blog = models.URLField()
    occupation = models.CharField(max_length=10, choices=OCCUPATION_CHOCIES)

    #backward compatibilty with Django 1.1
    try:
        wanted_games_qtd = models.BigIntegerField()
    except AttributeError:
        wanted_games_qtd = models.IntegerField()


class Dog(models.Model):
    owner = models.ForeignKey('Person')
    breed = models.CharField(max_length=50)
    created = models.DateTimeField(auto_now_add=True)

class GuardDog(Dog):
    pass

class LonelyPerson(models.Model):
    only_friend = models.OneToOneField(Person)


class Classroom(models.Model):
    students = models.ManyToManyField(Person, null=True)


class Store(models.Model):
    customers = models.ManyToManyField(Person, related_name='favorite_stores')
    employees = models.ManyToManyField(Person, related_name='employers')
    suppliers = models.ManyToManyField(Person, related_name='suppliers', blank=True, null=True)


class DummyIntModel(models.Model):
    int_field = models.IntegerField()
    small_int_field = models.SmallIntegerField()
    try:
        big_int_field = models.BigIntegerField()
    except AttributeError:
        big_int_field = models.IntegerField()


class DummyPositiveIntModel(models.Model):
    positive_small_int_field = models.PositiveSmallIntegerField()
    positive_int_field = models.PositiveIntegerField()


class DummyNumbersModel(models.Model):
    float_field = models.FloatField()


class DummyDecimalModel(models.Model):
    decimal_field = models.DecimalField(max_digits=5, decimal_places=2)


class UnsupportedField(models.Field):
    description = "I'm bad company, mommy doesn't know me"

    def __init__(self, *args, **kwargs):
        super(UnsupportedField, self).__init__(*args, **kwargs)


class UnsupportedModel(models.Model):
    unsupported_field = UnsupportedField()


class DummyEmailModel(models.Model):
    email_field = models.EmailField()


class DummyGenericForeignKeyModel(models.Model):
    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField()
    content_object = generic.GenericForeignKey('content_type', 'object_id')


class DummyGenericRelationModel(models.Model):
    relation = generic.GenericRelation(DummyGenericForeignKeyModel)


class DummyNullFieldsModel(models.Model):
    null_foreign_key = models.ForeignKey('DummyBlankFieldsModel', null=True)
    null_integer_field = models.IntegerField(null=True)


class DummyBlankFieldsModel(models.Model):
    blank_char_field = models.CharField(max_length=50, blank=True)
    blank_text_field = models.TextField(blank=True)

class DummyDefaultFieldsModel(models.Model):
    default_char_field = models.CharField(max_length=50, default='default')
    default_text_field = models.TextField(default='default')
    default_int_field = models.IntegerField(default=123)
    default_float_field = models.FloatField(default=123.0)
    default_date_field = models.DateField(default='2012-01-01')
    default_date_time_field = models.DateTimeField(default=datetime(2012, 1, 1))
    default_time_field = models.TimeField(default='00:00:00')
    default_decimal_field = models.DecimalField(max_digits=5, decimal_places=2,
                                                default=Decimal('0'))
    default_email_field = models.EmailField(default='foo@bar.org')
    default_slug_field = models.SlugField(default='a-slug')


class DummyFileFieldModel(models.Model):
    fs = FileSystemStorage(location=gettempdir())
    file_field = models.FileField(upload_to="%Y/%m/%d", storage=fs)


if has_pil:
    class DummyImageFieldModel(models.Model):
        fs = FileSystemStorage(location=gettempdir())
        image_field = models.ImageField(upload_to="%Y/%m/%d", storage=fs)
else:
    # doesn't matter, won't be using
    class DummyImageFieldModel(models.Model):
        pass


class DummyMultipleInheritanceModel(DummyDefaultFieldsModel, Person):
    my_dummy_field = models.IntegerField()

class Ambiguous(models.Model):
    name = models.CharField(max_length=20)


class School(models.Model):
    name = models.CharField(max_length = 10)
    students = models.ManyToManyField(Person, through='SchoolEnrollment')


class SchoolEnrollment(models.Model):
    start_date = models.DateField(auto_now_add=True)
    school = models.ForeignKey(School)
    student = models.ForeignKey(Person)

class NonAbstractPerson(Person):
    dummy_count = models.IntegerField()


class CustomFieldWithGeneratorModel(models.Model):
    custom_value = CustomFieldWithGenerator()


class CustomFieldWithoutGeneratorModel(models.Model):
    custom_value = CustomFieldWithoutGenerator()


class DummyUniqueIntegerFieldModel(models.Model):
    value = models.IntegerField(unique=True)


if VERSION < (1, 4):
    class DummyIPAddressFieldModel(models.Model):
        ip = models.IPAddressField()  # Deprecated in Django 1.7
else:
    class DummyGenericIPAddressFieldModel(models.Model):
        ip = models.GenericIPAddressField()  # New in Django 1.4


########NEW FILE########
__FILENAME__ = mommy_recipes
#coding: utf-8

#ATTENTION: Recipes defined for testing purposes only
from decimal import Decimal
from model_mommy.recipe import Recipe, foreign_key, seq
from model_mommy.recipe import related
from model_mommy.timezone import now
from test.generic.models import Person, Dog, DummyDefaultFieldsModel, DummyUniqueIntegerFieldModel

from six import u


person = Recipe(Person,
    name = 'John Doe',
    nickname = 'joe',
    age = 18,
    bio = 'Someone in the crowd',
    blog = 'http://joe.blogspot.com',
    wanted_games_qtd = 4,
    birthday = now().date(),
    appointment = now(),
    birth_time = now()
)

serial_person = Recipe(Person,
    name = seq('joe'),
)

serial_numbers = Recipe(DummyDefaultFieldsModel,
    default_decimal_field = seq(Decimal('20.1')),
    default_int_field = seq(10),
    default_float_field = seq(1.23)
)

serial_numbers_by = Recipe(DummyDefaultFieldsModel,
    default_decimal_field = seq(Decimal('20.1'), increment_by=Decimal('2.4')),
    default_int_field = seq(10, increment_by=3),
    default_float_field = seq(1.23, increment_by=1.8)
)

dog = Recipe(Dog,
    breed = 'Pug',
    owner = foreign_key(person)
)

other_dog = Recipe(Dog,
    breed = 'Basset',
    owner = foreign_key('person')
)

other_dog_unicode = Recipe(Dog,
    breed = 'Basset',
    owner = foreign_key(u('person'))
)

dummy_unique_field = Recipe(DummyUniqueIntegerFieldModel,
    value = seq(10),
)

dog_lady = Recipe(Person,
    dog_set = related('dog', other_dog)
)

########NEW FILE########
__FILENAME__ = mommy_recipes
#coding: utf-8
from model_mommy.recipe import Recipe, foreign_key
from test.generic.models import Person

from datetime import date, datetime

person = Recipe(Person,
    name = 'John Deeper',
    nickname = 'joe',
    age = 18,
    bio = 'Someone in the crowd',
    blog = 'http://joe.blogspot.com',
    wanted_games_qtd = 4,
    birthday = date.today(),
    appointment = datetime.now(),
    birth_time = datetime.now
)

########NEW FILE########
__FILENAME__ = test_extending_mommy
from django.db.models.fields import BooleanField
from django.test import TestCase

from model_mommy import mommy
from model_mommy.generators import gen_from_list
from test.generic.models import Person

__all__ = ['SimpleExtendMommy', 'LessSimpleExtendMommy']


class SimpleExtendMommy(TestCase):

    def test_list_generator_respects_values_from_list(self):
        age_list = range(4, 12)

        class KidMommy(mommy.Mommy):
            attr_mapping = {'age': gen_from_list(age_list)}

        mom = KidMommy(Person)
        kid = mom.make()

        self.assertTrue(kid.age in age_list)


class LessSimpleExtendMommy(TestCase):

    def test_unexistent_required_field(self):
        gen_oposite = lambda x: not x
        gen_oposite.required = ['house']

        class SadPeopleMommy(mommy.Mommy):
            attr_mapping = {'happy': gen_oposite}

        mom = SadPeopleMommy(Person)
        self.assertRaises(AttributeError, mom.make)

    #TODO: put a better name
    def test_string_to_generator_required(self):
        gen_oposite = lambda default: not default
        gen_oposite.required = ['default']

        class SadPeopleMommy(mommy.Mommy):
            attr_mapping = {
                'happy': gen_oposite,
                'unhappy': gen_oposite,
            }

        happy_field = Person._meta.get_field('happy')
        unhappy_field = Person._meta.get_field('unhappy')
        mom = SadPeopleMommy(Person)
        person = mom.make()
        self.assertEqual(person.happy, not happy_field.default)
        self.assertEqual(person.unhappy, not unhappy_field.default)

    def test_fail_pass_non_string_to_generator_required(self):
        gen_age = lambda x: 10

        class MyMommy(mommy.Mommy):
            attr_mapping = {'age': gen_age}

        mom = MyMommy(Person)

        # for int
        gen_age.required = [10]
        self.assertRaises(ValueError, mom.make)

        # for float
        gen_age.required = [10.10]
        self.assertRaises(ValueError, mom.make)

        # for iterable
        gen_age.required = [[]]
        self.assertRaises(ValueError, mom.make)

        # for iterable/dict
        gen_age.required = [{}]
        self.assertRaises(ValueError, mom.make)

        # for boolean
        gen_age.required = [True]
        self.assertRaises(ValueError, mom.make)

########NEW FILE########
__FILENAME__ = test_filling_fields
from datetime import date, datetime, time
from decimal import Decimal
from os.path import abspath
from tempfile import gettempdir

from django.test import TestCase
from django.conf import settings
from django.contrib.contenttypes.models import ContentType
from django.db.models.fields import CharField, TextField, SlugField
from django.db.models.fields import DateField, DateTimeField,TimeField, EmailField
from django.db.models.fields import IntegerField, SmallIntegerField
from django.db.models.fields import PositiveSmallIntegerField
from django.db.models.fields import PositiveIntegerField
from django.db.models.fields import FloatField, DecimalField
from django.db.models.fields import BooleanField, URLField
from django.db.models import FileField, ImageField
from django.core.files import File
from django.core.files.images import ImageFile

try:
    from django.db.models.fields import BigIntegerField
except ImportError:
    pass
    #BigIntegerField = IntegerField

from six import text_type, string_types

from model_mommy import mommy
from test.generic.models import has_pil
from test.generic.models import Person
from test.generic.models import DummyIntModel, DummyPositiveIntModel
from test.generic.models import DummyNumbersModel
from test.generic.models import DummyDecimalModel, DummyEmailModel
from test.generic.models import DummyGenericForeignKeyModel
from test.generic.models import DummyFileFieldModel
from test.generic.models import DummyImageFieldModel
from test.generic.models import CustomFieldWithoutGeneratorModel, CustomFieldWithGeneratorModel

__all__ = [
    'StringFieldsFilling', 'BooleanFieldsFilling', 'DateTimeFieldsFilling',
    'DateFieldsFilling', 'FillingIntFields', 'FillingPositiveIntFields',
    'FillingOthersNumericFields', 'FillingFromChoice', 'URLFieldsFilling',
    'FillingEmailField', 'FillingGenericForeignKeyField', 'FillingFileField',
    'FillingImageFileField', 'TimeFieldsFilling', 'FillingCustomFields',
]


def assert_not_raise(method, parameters, exception):
    try:
        method(*parameters)
    except exception:
        msg = "Exception %s not expected to be raised" % exception.__name__
        raise AssertionError(msg)


class FieldFillingTestCase(TestCase):

    def setUp(self):
        self.person = mommy.make(Person)


class FillingFromChoice(FieldFillingTestCase):

    def test_if_gender_is_populated_from_choices(self):
        from test.generic.models import GENDER_CH
        self.assertTrue(self.person.gender in map(lambda x: x[0], GENDER_CH))

    def test_if_oppucation_populated_from_choices(self):
        from test.generic.models import OCCUPATION_CHOCIES
        occupations = [item[0] for list in OCCUPATION_CHOCIES for item in list[1]]
        self.assertTrue(self.person.occupation in occupations)


class StringFieldsFilling(FieldFillingTestCase):

    def test_fill_CharField_with_a_random_str(self):
        person_name_field = Person._meta.get_field('name')
        self.assertIsInstance(person_name_field, CharField)

        self.assertIsInstance(self.person.name, text_type)
        self.assertEqual(len(self.person.name), person_name_field.max_length)

    def test_fill_SlugField_with_a_random_str(self):
        person_nickname_field = Person._meta.get_field('nickname')
        self.assertIsInstance(person_nickname_field, SlugField)

        self.assertIsInstance(self.person.nickname, text_type)
        self.assertEqual(len(self.person.nickname),
                         person_nickname_field.max_length)

    def test_fill_TextField_with_a_random_str(self):
        person_bio_field = Person._meta.get_field('bio')
        self.assertIsInstance(person_bio_field, TextField)

        self.assertIsInstance(self.person.bio, text_type)


class BooleanFieldsFilling(FieldFillingTestCase):
    def test_fill_BooleanField_with_boolean(self):
        happy_field = Person._meta.get_field('happy')
        self.assertIsInstance(happy_field, BooleanField)

        self.assertIsInstance(self.person.happy, bool)
        self.assertTrue(self.person.happy)

    def test_fill_BooleanField_with_false_if_default_is_false(self):
        unhappy_field = Person._meta.get_field('unhappy')
        self.assertIsInstance(unhappy_field, BooleanField)

        self.assertIsInstance(self.person.unhappy, bool)
        self.assertFalse(self.person.unhappy)


class DateFieldsFilling(FieldFillingTestCase):

    def test_fill_DateField_with_a_date(self):
        birthday_field = Person._meta.get_field('birthday')
        self.assertIsInstance(birthday_field, DateField)

        self.assertIsInstance(self.person.birthday, date)


class DateTimeFieldsFilling(FieldFillingTestCase):

    def test_fill_DateTimeField_with_a_datetime(self):
        appointment_field = Person._meta.get_field('appointment')
        self.assertIsInstance(appointment_field, DateTimeField)

        self.assertIsInstance(self.person.appointment, datetime)


class TimeFieldsFilling(FieldFillingTestCase):

    def test_fill_TimeField_with_a_time(self):
        birth_time_field = Person._meta.get_field('birth_time')
        self.assertIsInstance(birth_time_field, TimeField)

        self.assertIsInstance(self.person.birth_time, time)


class FillingIntFields(TestCase):

    def setUp(self):
        self.dummy_int_model = mommy.make(DummyIntModel)

    def test_fill_IntegerField_with_a_random_number(self):
        int_field = DummyIntModel._meta.get_field('int_field')
        self.assertIsInstance(int_field, IntegerField)

        self.assertIsInstance(self.dummy_int_model.int_field, int)

    def test_fill_BigIntegerField_with_a_random_number(self):
        big_int_field = DummyIntModel._meta.get_field('big_int_field')
        self.assertIsInstance(big_int_field, BigIntegerField)

        self.assertIsInstance(self.dummy_int_model.big_int_field, int)

    def test_fill_SmallIntegerField_with_a_random_number(self):

        small_int_field = DummyIntModel._meta.get_field('small_int_field')
        self.assertIsInstance(small_int_field, SmallIntegerField)

        self.assertIsInstance(self.dummy_int_model.small_int_field, int)


class FillingPositiveIntFields(TestCase):

    def setUp(self):
        self.dummy_positive_int_model = mommy.make(DummyPositiveIntModel)

    def test_fill_PositiveSmallIntegerField_with_a_random_number(self):
        field = DummyPositiveIntModel._meta.get_field('positive_small_int_field')
        positive_small_int_field = field
        self.assertIsInstance(positive_small_int_field, PositiveSmallIntegerField)

        self.assertIsInstance(self.dummy_positive_int_model.positive_small_int_field, int)
        self.assertTrue(self.dummy_positive_int_model.positive_small_int_field > 0)

    def test_fill_PositiveIntegerField_with_a_random_number(self):
        positive_int_field = DummyPositiveIntModel._meta.get_field('positive_int_field')
        self.assertIsInstance(positive_int_field, PositiveIntegerField)

        self.assertIsInstance(self.dummy_positive_int_model.positive_int_field, int)
        self.assertTrue(self.dummy_positive_int_model.positive_int_field > 0)


class FillingOthersNumericFields(TestCase):
    def test_filling_FloatField_with_a_random_float(self):
        self.dummy_numbers_model = mommy.make(DummyNumbersModel)
        float_field = DummyNumbersModel._meta.get_field('float_field')
        self.assertIsInstance(float_field, FloatField)
        self.assertIsInstance(self.dummy_numbers_model.float_field, float)

    def test_filling_DecimalField_with_random_decimal(self):
        self.dummy_decimal_model = mommy.make(DummyDecimalModel)
        decimal_field = DummyDecimalModel._meta.get_field('decimal_field')

        self.assertIsInstance(decimal_field, DecimalField)
        self.assertIsInstance(self.dummy_decimal_model.decimal_field, Decimal)


class URLFieldsFilling(FieldFillingTestCase):

    def test_fill_URLField_with_valid_url(self):
        blog_field = Person._meta.get_field('blog')
        self.assertIsInstance(blog_field, URLField)

        self.assertIsInstance(self.person.blog, text_type)


class FillingEmailField(TestCase):

    def test_filling_EmailField(self):
        obj = mommy.make(DummyEmailModel)
        field = DummyEmailModel._meta.get_field('email_field')
        self.assertIsInstance(field, EmailField)
        self.assertIsInstance(obj.email_field, string_types)


class FillingGenericForeignKeyField(TestCase):

    def test_filling_content_type_field(self):
        dummy = mommy.make(DummyGenericForeignKeyModel)
        self.assertIsInstance(dummy.content_type, ContentType)


class FillingFileField(TestCase):

    def setUp(self):
        path = mommy.mock_file_txt
        self.fixture_txt_file = File(open(path))

    def test_filling_file_field(self):
        self.dummy = mommy.make(DummyFileFieldModel)
        field = DummyFileFieldModel._meta.get_field('file_field')
        self.assertIsInstance(field, FileField)
        import time
        path = "%s/%s/mock_file.txt" % (gettempdir(), time.strftime('%Y/%m/%d'))

        from django import VERSION
        if VERSION[1] >= 4:
            self.assertEqual(abspath(self.dummy.file_field.path), abspath(path))

    def tearDown(self):
        self.dummy.file_field.delete()

# skipUnless not available in Django 1.2
# @skipUnless(has_pil, "PIL is required to test ImageField")
class FillingImageFileField(TestCase):

    def setUp(self):
        path = mommy.mock_file_jpeg
        self.fixture_img_file = ImageFile(open(path))

    if has_pil:
        def test_filling_image_file_field(self):
            self.dummy = mommy.make(DummyImageFieldModel)
            field = DummyImageFieldModel._meta.get_field('image_field')
            self.assertIsInstance(field, ImageField)
            import time
            path = "%s/%s/mock-img.jpeg" % (gettempdir(), time.strftime('%Y/%m/%d'))

            from django import VERSION
            if VERSION[1] >= 4:
                # These require the file to exist in earlier versions of Django
                self.assertEqual(abspath(self.dummy.image_field.path), abspath(path))
                self.assertTrue(self.dummy.image_field.width)
                self.assertTrue(self.dummy.image_field.height)

    def tearDown(self):
        self.dummy.image_field.delete()


class FillingCustomFields(TestCase):

    def setUp(self):
        generator_dict = {'test.generic.fields.CustomFieldWithGenerator': lambda: "value"}
        setattr(settings, 'MOMMY_CUSTOM_FIELDS_GEN', generator_dict)

    def tearDown(self):
        delattr(settings, 'MOMMY_CUSTOM_FIELDS_GEN')

    def test_raises_unsupported_field_for_custom_field(self):
        self.assertRaises(TypeError, mommy.make, CustomFieldWithoutGeneratorModel)

    def test_uses_generator_defined_on_settings_for_custom_field(self):
        obj = mommy.make(CustomFieldWithGeneratorModel)
        self.assertEqual("value", obj.custom_value)

########NEW FILE########
__FILENAME__ = test_mommy
# -*- coding:utf-8 -*-
from decimal import Decimal

from django.test import TestCase
from django import VERSION
from django.db.models.options import Options
from django.db.models import Manager
from mock import patch
from model_mommy import mommy
from model_mommy import generators
from model_mommy.exceptions import ModelNotFound, AmbiguousModelName, InvalidQuantityException
from model_mommy.timezone import smart_datetime as datetime
from test.generic.models import Person, Dog, Store, LonelyPerson, School, SchoolEnrollment, ModelWithImpostorField, Classroom, GuardDog
from test.generic.models import User, PaymentBill
from test.generic.models import UnsupportedModel, DummyGenericRelationModel
from test.generic.models import DummyNullFieldsModel, DummyBlankFieldsModel
from test.generic.models import DummyDefaultFieldsModel, DummyMultipleInheritanceModel
from test.generic.models import DummyGenericForeignKeyModel, NonAbstractPerson


class ModelFinderTest(TestCase):
    def test_unicode_regression(self):
        obj = mommy.prepare(u'generic.Person')
        self.assertIsInstance(obj, Person)

    def test_model_class(self):
        obj = mommy.prepare(Person)
        self.assertIsInstance(obj, Person)

    def test_app_model_string(self):
        obj = mommy.prepare('generic.Person')
        self.assertIsInstance(obj, Person)

    def test_model_string(self):
        obj = mommy.prepare('Person')
        self.assertIsInstance(obj, Person)

    def test_raise_on_ambiguous_model_string(self):
        with self.assertRaises(AmbiguousModelName):
            obj = mommy.prepare('Ambiguous')

    def test_raise_model_not_found(self):
        with self.assertRaises(ModelNotFound):
            mommy.Mommy('non_existing.Model')

        with self.assertRaises(ModelNotFound):
            mommy.Mommy('NonExistingModel')


class MommyCreatesSimpleModel(TestCase):

    def test_consider_real_django_fields_only(self):
        id_ = ModelWithImpostorField._meta.get_field('id')
        with patch.object(mommy.Mommy, 'get_fields') as mock:
            f = Manager()
            f.name = 'foo'
            mock.return_value = [id_, f]
            try:
                mommy.make(ModelWithImpostorField)
            except TypeError:
                self.fail('TypeError raised')

    def test_make_should_create_one_object(self):
        person = mommy.make(Person)
        self.assertIsInstance(person, Person)

        # makes sure it is the person we created
        self.assertTrue(Person.objects.filter(id=person.id))

    def test_prepare_should_not_persist_one_object(self):
        person = mommy.prepare(Person)
        self.assertIsInstance(person, Person)

        # makes sure database is clean
        self.assertEqual(Person.objects.all().count(), 0)

        self.assertEqual(person.id, None)

    def test_make_one_should_create_one_object(self):
        """
        make_one method is deprecated, so this test must be removed when the
        method is removed
        """
        person = mommy.make_one(Person)
        self.assertIsInstance(person, Person)
        self.assertTrue(Person.objects.filter(id=person.id))

    def test_prepare_one_should_not_persist_one_object(self):
        """
        prepare_one method is deprecated, so this test must be removed when the
        method is removed
        """
        person = mommy.prepare_one(Person)
        self.assertIsInstance(person, Person)
        self.assertEqual(Person.objects.all().count(), 0)
        self.assertEqual(person.id, None)

    def test_non_abstract_model_creation(self):
        person = mommy.make(NonAbstractPerson, name='bob', happy=False)
        self.assertIsInstance(person, NonAbstractPerson)
        self.assertEqual('bob', person.name)
        self.assertFalse(person.happy)

    def test_multiple_inheritance_creation(self):
        multiple = mommy.make(DummyMultipleInheritanceModel)
        self.assertIsInstance(multiple, DummyMultipleInheritanceModel)
        self.assertTrue(Person.objects.filter(id=multiple.id))
        self.assertTrue(DummyDefaultFieldsModel.objects.filter(id=multiple.id))


class MommyRepeatedCreatesSimpleModel(TestCase):

    def test_make_should_create_objects_respecting_quantity_parameter(self):
        people = mommy.make(Person, _quantity=5)
        self.assertEqual(Person.objects.count(), 5)

        people = mommy.make(Person, _quantity=5, name="George Washington")
        self.assertTrue(all(p.name == "George Washington" for p in people))

    def test_make_raises_correct_exception_if_invalid_quantity(self):
        self.assertRaises(
            InvalidQuantityException, mommy.make, model=Person, _quantity="hi"
        )
        self.assertRaises(
            InvalidQuantityException, mommy.make, model=Person, _quantity=-1
        )

    def test_prepare_should_create_objects_respecting_quantity_parameter(self):
        people = mommy.prepare(Person, _quantity=5)
        self.assertEqual(len(people), 5)
        self.assertTrue(all(not p.id for p in people))

        people = mommy.prepare(Person, _quantity=5, name="George Washington")
        self.assertTrue(all(p.name == "George Washington" for p in people))

    def test_prepare_raises_correct_exception_if_invalid_quantity(self):
        self.assertRaises(
            InvalidQuantityException, mommy.prepare, model=Person, _quantity="hi"
        )
        self.assertRaises(
            InvalidQuantityException, mommy.prepare, model=Person, _quantity=-1
        )

    def test_make_many_method(self):
        """
        make_many method is deprecated, so this test must be removed when the
        method is removed
        """
        people = mommy.make_many(Person, quantity=5)
        self.assertEqual(Person.objects.count(), 5)

        people = mommy.make_many(Person, name="George Washington")
        self.assertTrue(all(p.name == "George Washington" for p in people))


class MommyCreatesAssociatedModels(TestCase):

    def test_dependent_models_with_ForeignKey(self):
        dog = mommy.make(Dog)
        self.assertIsInstance(dog.owner, Person)

    def test_foreign_key_on_parent_should_create_one_object(self):
        '''
        Foreign key on parent gets created twice. Once for
        parent oject and another time for child object
        '''
        person_count = Person.objects.count()
        dog = mommy.make(GuardDog)
        self.assertEqual(Person.objects.count(), person_count+1)

    def test_auto_now_add_on_parent_should_work(self):
        '''
        Foreign key on parent gets created twice. Once for
        parent oject and another time for child object
        '''
        person_count = Person.objects.count()
        dog = mommy.make(GuardDog)
        self.assertNotEqual(dog.created, None)

    def test_attrs_on_related_model_through_parent(self):
        '''
        Foreign key on parent gets created twice. Once for
        parent oject and another time for child object
        '''
        dog = mommy.make(GuardDog, owner__name='john')
        for person in Person.objects.all():
            self.assertEqual(person.name, 'john')

    def test_prepare_should_not_create_one_object(self):
        dog = mommy.prepare(Dog)
        self.assertIsInstance(dog, Dog)
        self.assertIsInstance(dog.owner, Person)

        # makes sure database is clean
        self.assertEqual(Person.objects.all().count(), 0)
        self.assertEqual(Dog.objects.all().count(), 0)

    def test_prepare_one_to_one_should_not_persist_one_object(self):
        lonely_person = mommy.prepare(LonelyPerson)

        # makes sure database is clean
        self.assertEqual(LonelyPerson.objects.all().count(), 0)
        self.assertTrue(isinstance(lonely_person.only_friend, Person))
        self.assertEqual(Person.objects.all().count(), 0)

    def test_create_one_to_one(self):
        lonely_person = mommy.make(LonelyPerson)

        self.assertEqual(LonelyPerson.objects.all().count(), 1)
        self.assertTrue(isinstance(lonely_person.only_friend, Person))
        self.assertEqual(Person.objects.all().count(), 1)

    def test_create_many_to_many_if_flagged(self):
        store = mommy.make(Store, make_m2m=True)
        self.assertEqual(store.employees.count(), 5)
        self.assertEqual(store.customers.count(), 5)

    def test_regresstion_many_to_many_field_is_accepted_as_kwargs(self):
        employees = mommy.make(Person, _quantity=3)
        customers = mommy.make(Person, _quantity=3)

        store = mommy.make(Store, employees=employees, customers=customers)

        self.assertEqual(store.employees.count(), 3)
        self.assertEqual(store.customers.count(), 3)
        self.assertEqual(Person.objects.count(), 6)

    def test_create_many_to_many_with_set_default_quantity(self):
        store = mommy.make(Store, make_m2m=True)
        self.assertEqual(store.employees.count(), mommy.MAX_MANY_QUANTITY)
        self.assertEqual(store.customers.count(), mommy.MAX_MANY_QUANTITY)

    def test_create_many_to_many_with_through_option(self):
        # School student's attr is a m2m relationship with a model through
        school = mommy.make(School, make_m2m=True)
        self.assertEqual(School.objects.count(), 1)
        self.assertEqual(school.students.count(), mommy.MAX_MANY_QUANTITY)
        self.assertEqual(SchoolEnrollment.objects.count(), mommy.MAX_MANY_QUANTITY)
        self.assertEqual(Person.objects.count(), mommy.MAX_MANY_QUANTITY)

    def test_does_not_create_many_to_many_as_default(self):
        store = mommy.make(Store, make_m2m=False)
        self.assertEqual(store.employees.count(), 0)
        self.assertEqual(store.customers.count(), 0)

    def test_does_not_create_nullable_many_to_many_for_relations(self):
        classroom = mommy.make(Classroom, make_m2m=False)
        self.assertEqual(classroom.students.count(), 0)

    def test_nullable_many_to_many_is_not_created_even_if_flagged(self):
        classroom = mommy.make(Classroom, make_m2m=True)
        self.assertEqual(classroom.students.count(), 0)

    def test_simple_creating_person_with_parameters(self):
        kid = mommy.make(Person, happy=True, age=10, name='Mike')
        self.assertEqual(kid.age, 10)
        self.assertEqual(kid.happy, True)
        self.assertEqual(kid.name, 'Mike')

    def test_creating_person_from_factory_using_paramters(self):
        person_mom = mommy.Mommy(Person)
        person = person_mom.make(happy=False, age=20, gender='M',
                                     name='John')
        self.assertEqual(person.age, 20)
        self.assertEqual(person.happy, False)
        self.assertEqual(person.name, 'John')
        self.assertEqual(person.gender, 'M')

    def test_ForeignKey_model_field_population(self):
        dog = mommy.make(Dog, breed='X1', owner__name='Bob')
        self.assertEqual('X1', dog.breed)
        self.assertEqual('Bob', dog.owner.name)

    def test_ForeignKey_model_field_population_should_work_with_prepare(self):
        dog = mommy.prepare(Dog, breed='X1', owner__name='Bob')
        self.assertEqual('X1', dog.breed)
        self.assertEqual('Bob', dog.owner.name)

    def test_ForeignKey_model_field_population_for_not_required_fk(self):
        user = mommy.make(User, profile__email="a@b.com")
        self.assertEqual('a@b.com', user.profile.email)

    def test_does_not_creates_null_ForeignKey(self):
        user = mommy.make(User)
        self.assertFalse(user.profile)

    def test_ensure_recursive_ForeignKey_population(self):
        bill = mommy.make(PaymentBill, user__profile__email="a@b.com")
        self.assertEqual('a@b.com', bill.user.profile.email)

    def test_field_lookup_for_m2m_relationship(self):
        store = mommy.make(Store, suppliers__gender='M')
        suppliers = store.suppliers.all()
        self.assertTrue(suppliers)
        for supplier in suppliers:
            self.assertEqual('M', supplier.gender)

    def test_field_lookup_for_one_to_one_relationship(self):
        lonely_person = mommy.make(LonelyPerson, only_friend__name='Bob')
        self.assertEqual('Bob', lonely_person.only_friend.name)

    def test_allow_create_fkey_related_model(self):
        try:
            person = mommy.make(Person, dog_set=[mommy.prepare(Dog), mommy.prepare(Dog)])
        except TypeError:
            self.fail('type error raised')

        self.assertEqual(person.dog_set.count(), 2)

class HandlingUnsupportedModels(TestCase):
    def test_unsupported_model_raises_an_explanatory_exception(self):
        try:
            mommy.make(UnsupportedModel)
            self.fail("Should have raised a TypeError")
        except TypeError as e:
            self.assertTrue('not supported' in repr(e))


class HandlingModelsWithGenericRelationFields(TestCase):
    def test_create_model_with_generic_relation(self):
        dummy = mommy.make(DummyGenericRelationModel)
        self.assertIsInstance(dummy, DummyGenericRelationModel)


class HandlingContentTypeField(TestCase):
    def test_create_model_with_contenttype_field(self):
        dummy = mommy.make(DummyGenericForeignKeyModel)
        self.assertIsInstance(dummy, DummyGenericForeignKeyModel)


class SkipNullsTestCase(TestCase):
    def test_skip_null(self):
        dummy = mommy.make(DummyNullFieldsModel)
        self.assertEqual(dummy.null_foreign_key, None)
        self.assertEqual(dummy.null_integer_field, None)


class SkipBlanksTestCase(TestCase):
    def test_skip_blank(self):
        dummy = mommy.make(DummyBlankFieldsModel)
        self.assertEqual(dummy.blank_char_field, '')
        self.assertEqual(dummy.blank_text_field, '')


class SkipDefaultsTestCase(TestCase):
    def test_skip_fields_with_default(self):
        dummy = mommy.make(DummyDefaultFieldsModel)
        self.assertEqual(dummy.default_char_field, 'default')
        self.assertEqual(dummy.default_text_field, 'default')
        self.assertEqual(dummy.default_int_field, 123)
        self.assertEqual(dummy.default_float_field, 123.0)
        self.assertEqual(dummy.default_date_field, '2012-01-01')
        self.assertEqual(dummy.default_date_time_field, datetime(2012, 1, 1))
        self.assertEqual(dummy.default_time_field, '00:00:00')
        self.assertEqual(dummy.default_decimal_field, Decimal('0'))
        self.assertEqual(dummy.default_email_field, 'foo@bar.org')
        self.assertEqual(dummy.default_slug_field, 'a-slug')


if VERSION < (1, 4):
    from test.generic.forms import DummyIPAddressFieldForm

    class MommyGeneratesIPAdresses(TestCase):
        def test_create_model_with_valid_ipv4(self):
            form_data = {
                'ip': generators.gen_ipv4(),
            }
            self.assertTrue(DummyIPAddressFieldForm(form_data).is_valid())
else:
    from test.generic.forms import DummyGenericIPAddressFieldForm

    class MommyGeneratesIPAdresses(TestCase):
        def test_create_model_with_valid_ipv4(self):
            form_data = {
                'ip': generators.gen_ipv4(),
            }
            self.assertTrue(DummyGenericIPAddressFieldForm(form_data).is_valid())

        def test_create_model_with_valid_ipv6(self):
            form_data = {
                'ip': generators.gen_ipv6(),
            }
            self.assertTrue(DummyGenericIPAddressFieldForm(form_data).is_valid())

########NEW FILE########
__FILENAME__ = test_recipes
#coding: utf-8

import itertools
from random import choice
from mock import patch
from decimal import Decimal
from django.test import TestCase
from model_mommy import mommy
from model_mommy.recipe import Recipe, foreign_key, RecipeForeignKey
from model_mommy.timezone import now
from model_mommy.exceptions import InvalidQuantityException, RecipeIteratorEmpty
from test.generic.models import Person, DummyNumbersModel, DummyBlankFieldsModel, Dog


class TestDefiningRecipes(TestCase):
    def setUp(self):
        self.recipe_attrs = {
          'name': 'John Doe',
          'nickname': 'joe',
          'age': 18,
          'bio': 'Someone in the crowd',
          'birthday': now().date(),
          'appointment': now(),
          'blog': 'http://joe.blogspot.com',
          'wanted_games_qtd': 4,
          'birth_time': now()
        }
        self.person_recipe = Recipe(
          Person,
          **self.recipe_attrs
        )

    def test_flat_model_make_recipe_with_the_correct_attributes(self):
        """
          A 'flat model' means a model without associations, like
          foreign keys, many to many and one to one
        """
        person = self.person_recipe.make()
        self.assertEqual(person.name, self.recipe_attrs['name'])
        self.assertEqual(person.nickname, self.recipe_attrs['nickname'])
        self.assertEqual(person.age, self.recipe_attrs['age'])
        self.assertEqual(person.bio, self.recipe_attrs['bio'])
        self.assertEqual(person.birthday, self.recipe_attrs['birthday'])
        self.assertEqual(person.appointment, self.recipe_attrs['appointment'])
        self.assertEqual(person.blog, self.recipe_attrs['blog'])
        self.assertEqual(person.wanted_games_qtd, self.recipe_attrs['wanted_games_qtd'])
        self.assertNotEqual(person.id, None)

    def test_flat_model_prepare_recipe_with_the_correct_attributes(self):
        person = self.person_recipe.prepare()
        self.assertEqual(person.name, self.recipe_attrs['name'])
        self.assertEqual(person.nickname, self.recipe_attrs['nickname'])
        self.assertEqual(person.age, self.recipe_attrs['age'])
        self.assertEqual(person.bio, self.recipe_attrs['bio'])
        self.assertEqual(person.birthday, self.recipe_attrs['birthday'])
        self.assertEqual(person.appointment, self.recipe_attrs['appointment'])
        self.assertEqual(person.blog, self.recipe_attrs['blog'])
        self.assertEqual(person.wanted_games_qtd, self.recipe_attrs['wanted_games_qtd'])
        self.assertEqual(person.id, None)

    def test_accepts_callable(self):
        r = Recipe(DummyBlankFieldsModel,
            blank_char_field = lambda: 'callable!!'
        )
        value = r.make().blank_char_field
        self.assertEqual(value, 'callable!!')

    def test_always_calls_when_creating(self):
        with patch('test.generic.tests.test_recipes.choice') as choice_mock:
            l = ['foo', 'bar', 'spam', 'eggs']
            r = Recipe(DummyBlankFieldsModel,
                blank_char_field = lambda: choice(l)
            )
            r.make().blank_char_field
            r.make().blank_char_field
            self.assertEqual(choice_mock.call_count, 2)

    def test_always_calls_with_quantity(self):
        with patch('test.generic.tests.test_recipes.choice') as choice_mock:
            l = ['foo', 'bar', 'spam', 'eggs']
            r = Recipe(DummyBlankFieldsModel,
                blank_char_field = lambda: choice(l)
            )
            r.make(_quantity=3)
            self.assertEqual(choice_mock.call_count, 3)

    def test_make_recipes_with_args(self):
        """
          Overriding some fields values at recipe execution
        """
        person = self.person_recipe.make(name='Guido', age=56)
        self.assertNotEqual(person.name, self.recipe_attrs['name'])
        self.assertEqual(person.name, 'Guido')

        self.assertNotEqual(person.age, self.recipe_attrs['age'])
        self.assertEqual(person.age, 56)

        self.assertEqual(person.nickname, self.recipe_attrs['nickname'])
        self.assertEqual(person.bio, self.recipe_attrs['bio'])
        self.assertEqual(person.birthday, self.recipe_attrs['birthday'])
        self.assertEqual(person.appointment, self.recipe_attrs['appointment'])
        self.assertEqual(person.blog, self.recipe_attrs['blog'])
        self.assertEqual(person.wanted_games_qtd, self.recipe_attrs['wanted_games_qtd'])
        self.assertNotEqual(person.id, None)

    def test_prepare_recipes_with_args(self):
        """
          Overriding some fields values at recipe execution
        """
        person = self.person_recipe.prepare(name='Guido', age=56)
        self.assertNotEqual(person.name, self.recipe_attrs['name'])
        self.assertEqual(person.name, 'Guido')

        self.assertNotEqual(person.age, self.recipe_attrs['age'])
        self.assertEqual(person.age, 56)

        self.assertEqual(person.nickname, self.recipe_attrs['nickname'])
        self.assertEqual(person.bio, self.recipe_attrs['bio'])
        self.assertEqual(person.birthday, self.recipe_attrs['birthday'])
        self.assertEqual(person.appointment, self.recipe_attrs['appointment'])
        self.assertEqual(person.blog, self.recipe_attrs['blog'])
        self.assertEqual(person.wanted_games_qtd, self.recipe_attrs['wanted_games_qtd'])
        self.assertEqual(person.id, None)

    def test_make_recipe_without_all_model_needed_data(self):
        person_recipe = Recipe(Person, name='John Doe')
        person = person_recipe.make()
        self.assertEqual('John Doe', person.name)
        self.assertTrue(person.nickname)
        self.assertTrue(person.age)
        self.assertTrue(person.bio)
        self.assertTrue(person.birthday)
        self.assertTrue(person.appointment)
        self.assertTrue(person.blog)
        self.assertTrue(person.wanted_games_qtd)
        self.assertTrue(person.id)

    def test_prepare_recipe_without_all_model_needed_data(self):
        person_recipe = Recipe(Person, name='John Doe')
        person = person_recipe.prepare()
        self.assertEqual('John Doe', person.name)
        self.assertTrue(person.nickname)
        self.assertTrue(person.age)
        self.assertTrue(person.bio)
        self.assertTrue(person.birthday)
        self.assertTrue(person.appointment)
        self.assertTrue(person.blog)
        self.assertTrue(person.wanted_games_qtd)
        self.assertFalse(person.id)


class TestExecutingRecipes(TestCase):
    """
      Tests for calling recipes defined in mommy_recipes.py
    """
    def test_model_with_foreign_key(self):
        dog = mommy.make_recipe('test.generic.dog')
        self.assertEqual(dog.breed, 'Pug')
        self.assertIsInstance(dog.owner, Person)
        self.assertNotEqual(dog.owner.id, None)

        dog = mommy.prepare_recipe('test.generic.dog')
        self.assertEqual(dog.breed, 'Pug')
        self.assertIsInstance(dog.owner, Person)
        self.assertNotEqual(dog.owner.id, None)

    def test_model_with_foreign_key_as_str(self):
        dog = mommy.make_recipe('test.generic.other_dog')
        self.assertEqual(dog.breed, 'Basset')
        self.assertIsInstance(dog.owner, Person)
        self.assertNotEqual(dog.owner.id, None)

        dog = mommy.prepare_recipe('test.generic.other_dog')
        self.assertEqual(dog.breed, 'Basset')
        self.assertIsInstance(dog.owner, Person)
        self.assertNotEqual(dog.owner.id, None)

    def test_model_with_foreign_key_as_unicode(self):
        dog = mommy.make_recipe('test.generic.other_dog_unicode')
        self.assertEqual(dog.breed, 'Basset')
        self.assertIsInstance(dog.owner, Person)
        self.assertNotEqual(dog.owner.id, None)

        dog = mommy.prepare_recipe('test.generic.other_dog_unicode')
        self.assertEqual(dog.breed, 'Basset')
        self.assertIsInstance(dog.owner, Person)
        self.assertNotEqual(dog.owner.id, None)

    def test_make_recipe(self):
        person = mommy.make_recipe('test.generic.person')
        self.assertIsInstance(person, Person)
        self.assertNotEqual(person.id, None)

    def test_make_recipe_with_quantity_parameter(self):
        people = mommy.make_recipe('test.generic.person', _quantity=3)
        self.assertEqual(len(people), 3)
        for person in people:
            self.assertIsInstance(person, Person)
            self.assertNotEqual(person.id, None)

    def test_make_recipe_with_quantity_parameter_respection_model_args(self):
        people = mommy.make_recipe('test.generic.person', _quantity=3, name='Dennis Ritchie', age=70)
        self.assertEqual(len(people), 3)
        for person in people:
            self.assertEqual(person.name, 'Dennis Ritchie')
            self.assertEqual(person.age, 70)

    def test_make_recipe_raises_correct_exception_if_invalid_quantity(self):
        self.assertRaises(
            InvalidQuantityException,
            mommy.make_recipe, 'test.generic.person', _quantity="hi"
        )
        self.assertRaises(
            InvalidQuantityException,
            mommy.make_recipe, 'test.generic.person', _quantity=-1
        )

    def test_prepare_recipe_with_quantity_parameter(self):
        people = mommy.prepare_recipe('test.generic.person', _quantity=3)
        self.assertEqual(len(people), 3)
        for person in people:
            self.assertIsInstance(person, Person)
            self.assertEqual(person.id, None)

    def test_prepare_recipe_with_quantity_parameter_respection_model_args(self):
        people = mommy.prepare_recipe('test.generic.person', _quantity=3, name='Dennis Ritchie', age=70)
        self.assertEqual(len(people), 3)
        for person in people:
            self.assertEqual(person.name, 'Dennis Ritchie')
            self.assertEqual(person.age, 70)

    def test_prepare_recipe_raises_correct_exception_if_invalid_quantity(self):
        self.assertRaises(
            InvalidQuantityException,
            mommy.prepare_recipe, 'test.generic.person', _quantity="hi"
        )
        self.assertRaises(
            InvalidQuantityException,
            mommy.prepare_recipe, 'test.generic.person', _quantity=-1
        )

    def test_prepare_recipe(self):
        person = mommy.prepare_recipe('test.generic.person')
        self.assertIsInstance(person, Person)
        self.assertEqual(person.id, None)

    def test_make_recipe_with_args(self):
        person = mommy.make_recipe('test.generic.person', name='Dennis Ritchie', age=70)
        self.assertEqual(person.name, 'Dennis Ritchie')
        self.assertEqual(person.age, 70)

    def test_prepare_recipe_with_args(self):
        person = mommy.prepare_recipe('test.generic.person', name='Dennis Ritchie', age=70)
        self.assertEqual(person.name, 'Dennis Ritchie')
        self.assertEqual(person.age, 70)

    def test_import_recipe_inside_deeper_modules(self):
        recipe_name = 'test.generic.tests.sub_package.person'
        person = mommy.prepare_recipe(recipe_name)
        self.assertEqual(person.name, 'John Deeper')

    def test_make_many_from_recipe(self):
        """
        make_many_from_recipe is deprecated, so this test must be deleted when
        the method is
        """
        persons = mommy.make_many_from_recipe('test.generic.person')
        self.assertIsInstance(persons, list)
        self.assertEqual(len(persons), mommy.MAX_MANY_QUANTITY)
        for person in persons:
            self.assertIsInstance(person, Person)
            self.assertNotEqual(person.id, None)

    def test_make_many_from_recipe_with_specified_quantity(self):
        """
        make_many_from_recipe is deprecated, so this test must be deleted when
        the method is
        """
        quantity = 2
        persons = mommy.make_many_from_recipe('test.generic.person', quantity=quantity)
        self.assertIsInstance(persons, list)
        self.assertEqual(len(persons), quantity)

    def test_make_many_with_model_args(self):
        """
        make_many_from_recipe is deprecated, so this test must be deleted when
        the method is
        """
        persons = mommy.make_many_from_recipe('test.generic.person', name='Dennis Ritchie', age=70)
        for person in persons:
            self.assertEqual(person.name, 'Dennis Ritchie')
            self.assertEqual(person.age, 70)

class ForeignKeyTestCase(TestCase):
    def test_foreign_key_method_returns_a_recipe_foreign_key_object(self):
        number_recipe = Recipe(DummyNumbersModel,
            float_field = 1.6
        )
        obj = foreign_key(number_recipe)
        self.assertIsInstance(obj, RecipeForeignKey)

    def test_not_accept_other_type(self):
        with self.assertRaises(TypeError) as c:
            foreign_key(2)
        exception = c.exception
        self.assertEqual(str(exception), 'Not a recipe')

    def test_do_not_create_related_model(self):
        """
          It should not attempt to create other object when
          passing the object as argument
        """
        person = mommy.make_recipe('test.generic.person')
        self.assertEqual(Person.objects.count(), 1)
        mommy.make_recipe('test.generic.dog', owner=person)
        self.assertEqual(Person.objects.count(), 1)
        mommy.prepare_recipe('test.generic.dog', owner=person)
        self.assertEqual(Person.objects.count(), 1)

    def test_do_query_lookup_for_recipes_make_method(self):
        """
          It should not attempt to create other object when
          using query lookup syntax
        """
        dog = mommy.make_recipe('test.generic.dog', owner__name='James')
        self.assertEqual(Person.objects.count(), 1)
        self.assertEqual(dog.owner.name, 'James')

    def test_do_query_lookup_for_recipes_prepare_method(self):
        """
          It should not attempt to create other object when
          using query lookup syntax
        """
        dog = mommy.prepare_recipe('test.generic.dog', owner__name='James')
        self.assertEqual(Person.objects.count(), 1)
        self.assertEqual(dog.owner.name, 'James')

    def test_do_query_lookup_empty_recipes(self):
        """
          It should not attempt to create other object when
          using query lookup syntax
        """
        dog_recipe = Recipe(Dog)
        dog = dog_recipe.make(owner__name='James')
        self.assertEqual(Person.objects.count(), 1)
        self.assertEqual(dog.owner.name, 'James')

        dog = dog_recipe.prepare(owner__name='Zezin')
        self.assertEqual(Person.objects.count(), 1)
        self.assertEqual(dog.owner.name, 'Zezin')

    def test_related_models_recipes(self):
        lady = mommy.make_recipe('test.generic.dog_lady')
        self.assertEqual(lady.dog_set.count(), 2)
        self.assertEqual(lady.dog_set.all()[0].breed, 'Pug')
        self.assertEqual(lady.dog_set.all()[1].breed, 'Basset')

class TestSequences(TestCase):
    def test_increment_for_strings(self):
        person = mommy.make_recipe('test.generic.serial_person')
        self.assertEqual(person.name, 'joe1')
        person = mommy.prepare_recipe('test.generic.serial_person')
        self.assertEqual(person.name, 'joe2')
        person = mommy.make_recipe('test.generic.serial_person')
        self.assertEqual(person.name, 'joe3')

    def test_increment_for_numbers(self):
        dummy = mommy.make_recipe('test.generic.serial_numbers')
        self.assertEqual(dummy.default_int_field, 11)
        self.assertEqual(dummy.default_decimal_field, Decimal('21.1'))
        self.assertEqual(dummy.default_float_field, 2.23)
        dummy = mommy.make_recipe('test.generic.serial_numbers')
        self.assertEqual(dummy.default_int_field, 12)
        self.assertEqual(dummy.default_decimal_field, Decimal('22.1'))
        self.assertEqual(dummy.default_float_field, 3.23)
        dummy = mommy.prepare_recipe('test.generic.serial_numbers')
        self.assertEqual(dummy.default_int_field, 13)
        self.assertEqual(dummy.default_decimal_field, Decimal('23.1'))
        self.assertEqual(dummy.default_float_field, 4.23)

    def test_increment_for_numbers_2(self):
        """
        This test is a repeated one but it is necessary to ensure Sequences atomicity
        """
        dummy = mommy.make_recipe('test.generic.serial_numbers')
        self.assertEqual(dummy.default_int_field, 11)
        self.assertEqual(dummy.default_decimal_field, Decimal('21.1'))
        self.assertEqual(dummy.default_float_field, 2.23)
        dummy = mommy.make_recipe('test.generic.serial_numbers')
        self.assertEqual(dummy.default_int_field, 12)
        self.assertEqual(dummy.default_decimal_field, Decimal('22.1'))
        self.assertEqual(dummy.default_float_field, 3.23)
        dummy = mommy.prepare_recipe('test.generic.serial_numbers')
        self.assertEqual(dummy.default_int_field, 13)
        self.assertEqual(dummy.default_decimal_field, Decimal('23.1'))
        self.assertEqual(dummy.default_float_field, 4.23)

    def test_creates_unique_field_recipe_using_for_iterator(self):
        for i in range(1, 4):
            dummy = mommy.make_recipe('test.generic.dummy_unique_field')
            self.assertEqual(dummy.value, 10 + i)

    def test_creates_unique_field_recipe_using_quantity_argument(self):
        dummies= mommy.make_recipe('test.generic.dummy_unique_field', _quantity=3)
        self.assertEqual(11, dummies[0].value)
        self.assertEqual(12, dummies[1].value)
        self.assertEqual(13, dummies[2].value)

    def test_increment_by_3(self):
        dummy = mommy.make_recipe('test.generic.serial_numbers_by')
        self.assertEqual(dummy.default_int_field, 13)
        self.assertEqual(dummy.default_decimal_field, Decimal('22.5'))
        self.assertAlmostEqual(dummy.default_float_field, 3.030000)
        dummy = mommy.make_recipe('test.generic.serial_numbers_by')
        self.assertEqual(dummy.default_int_field, 16)
        self.assertEqual(dummy.default_decimal_field, Decimal('24.9'))
        self.assertAlmostEqual(dummy.default_float_field, 4.83)
        dummy = mommy.prepare_recipe('test.generic.serial_numbers_by')
        self.assertEqual(dummy.default_int_field, 19)
        self.assertEqual(dummy.default_decimal_field, Decimal('27.3'))
        self.assertAlmostEqual(dummy.default_float_field, 6.63)


class TestIterators(TestCase):

    def test_accepts_generators(self):
        r = Recipe(DummyBlankFieldsModel,
                   blank_char_field=itertools.cycle(['a', 'b']))
        self.assertEqual('a', r.make().blank_char_field)
        self.assertEqual('b', r.make().blank_char_field)
        self.assertEqual('a', r.make().blank_char_field)

    def test_accepts_iterators(self):
        r = Recipe(DummyBlankFieldsModel,
                   blank_char_field=iter(['a', 'b', 'c']))
        self.assertEqual('a', r.make().blank_char_field)
        self.assertEqual('b', r.make().blank_char_field)
        self.assertEqual('c', r.make().blank_char_field)

    def test_empty_iterator_exception(self):
        r = Recipe(DummyBlankFieldsModel,
                   blank_char_field=iter(['a', 'b']))
        self.assertEqual('a', r.make().blank_char_field)
        self.assertEqual('b', r.make().blank_char_field)
        self.assertRaises(RecipeIteratorEmpty, r.make)

    def test_only_iterators_not_iteratables_are_iterated(self):
        """Ensure we only iterate explicit iterators.

        Consider "iterable" vs "iterator":

        Something like a string is "iterable", but not an "iterator". We don't
        want to iterate "iterables", only explicit "iterators".

        """
        r = Recipe(DummyBlankFieldsModel,
                   blank_text_field="not an iterator, so don't iterate!")
        self.assertEqual(
            r.make().blank_text_field,
            "not an iterator, so don't iterate!")

########NEW FILE########
