__FILENAME__ = conftest

# Configuration for the tests.
# Use `py.test` to run the tests.

# (This file needs to be in or above the directory where py.test is called)

import pytest
import os

def pytest_addoption(parser):
    parser.addoption("--media-root", action="store",
        default=None,
        help="Root for the media files (if not specified and pokedex/data/media doesn't exist, tests are skipped)")
    parser.addoption("--all", action="store_true", default=False,
        help="Run all tests, even those that take a lot of time")

def pytest_generate_tests(metafunc):
    for funcargs in getattr(metafunc.function, 'funcarglist', ()):
        metafunc.addcall(funcargs=funcargs)
    for posargs in getattr(metafunc.function, 'posarglist', ()):
        metafunc.addcall(funcargs=dict(zip(metafunc.funcargnames, posargs)))

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# pokedex documentation build configuration file, created by
# sphinx-quickstart on Tue Apr 12 17:43:05 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

reload(sys)
sys.setdefaultencoding("UTF-8")

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
        'sphinx.ext.autodoc',
        'sphinx.ext.doctest',
        'sphinx.ext.todo',
        'sphinx.ext.pngmath',
        'sphinx.ext.intersphinx',
        #'sphinx.ext.viewcode',
        'sphinx.ext.coverage',
        'pokedex.doc.tabledoc',
    ]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'pokedex'
copyright = u'2011, Alex Munroe (Eevee)'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


intersphinx_mapping = {'sqlalchemy': ('http://www.sqlalchemy.org/docs', None)}

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'pokedexdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'pokedex.tex', u'Pokedex Documentation',
   u'veekun', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pokedex', u'Pokedex Documentation',
     [u'veekun'], 1)
]

########NEW FILE########
__FILENAME__ = compatibility
"""Things missing from older versions of Python

Currently these are functions missing from Python 2.5.
"""

try:
    from itertools import permutations
except ImportError:
    # From the itertools documentation
    def permutations(iterable, r=None):
        # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
        # permutations(range(3)) --> 012 021 102 120 201 210
        pool = tuple(iterable)
        n = len(pool)
        r = n if r is None else r
        if r > n:
            return
        indices = range(n)
        cycles = range(n, n-r, -1)
        yield tuple(pool[i] for i in indices[:r])
        while n:
            for i in reversed(range(r)):
                cycles[i] -= 1
                if cycles[i] == 0:
                    indices[i:] = indices[i+1:] + indices[i:i+1]
                    cycles[i] = n - i
                else:
                    j = cycles[i]
                    indices[i], indices[-j] = indices[-j], indices[i]
                    yield tuple(pool[i] for i in indices[:r])
                    break
            else:
                return

try:
    from collections import namedtuple
except ImportError:
    # http://code.activestate.com/recipes/500261-named-tuples/
    from operator import itemgetter as _itemgetter
    from keyword import iskeyword as _iskeyword
    import sys as _sys

    def namedtuple(typename, field_names, verbose=False, rename=False):
        """Returns a new subclass of tuple with named fields.

        >>> Point = namedtuple('Point', 'x y')
        >>> Point.__doc__                   # docstring for the new class
        'Point(x, y)'
        >>> p = Point(11, y=22)             # instantiate with positional args or keywords
        >>> p[0] + p[1]                     # indexable like a plain tuple
        33
        >>> x, y = p                        # unpack like a regular tuple
        >>> x, y
        (11, 22)
        >>> p.x + p.y                       # fields also accessable by name
        33
        >>> d = p._asdict()                 # convert to a dictionary
        >>> d['x']
        11
        >>> Point(**d)                      # convert from a dictionary
        Point(x=11, y=22)
        >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields
        Point(x=100, y=22)

        """

        # Parse and validate the field names.  Validation serves two purposes,
        # generating informative error messages and preventing template injection attacks.
        if isinstance(field_names, basestring):
            field_names = field_names.replace(',', ' ').split() # names separated by whitespace and/or commas
        field_names = tuple(map(str, field_names))
        if rename:
            names = list(field_names)
            seen = set()
            for i, name in enumerate(names):
                if (not min(c.isalnum() or c=='_' for c in name) or _iskeyword(name)
                    or not name or name[0].isdigit() or name.startswith('_')
                    or name in seen):
                        names[i] = '_%d' % i
                seen.add(name)
            field_names = tuple(names)
        for name in (typename,) + field_names:
            if not min(c.isalnum() or c=='_' for c in name):
                raise ValueError('Type names and field names can only contain alphanumeric characters and underscores: %r' % name)
            if _iskeyword(name):
                raise ValueError('Type names and field names cannot be a keyword: %r' % name)
            if name[0].isdigit():
                raise ValueError('Type names and field names cannot start with a number: %r' % name)
        seen_names = set()
        for name in field_names:
            if name.startswith('_') and not rename:
                raise ValueError('Field names cannot start with an underscore: %r' % name)
            if name in seen_names:
                raise ValueError('Encountered duplicate field name: %r' % name)
            seen_names.add(name)

        # Create and fill-in the class template
        numfields = len(field_names)
        argtxt = repr(field_names).replace("'", "")[1:-1]   # tuple repr without parens or quotes
        reprtxt = ', '.join('%s=%%r' % name for name in field_names)
        template = '''class %(typename)s(tuple):
            '%(typename)s(%(argtxt)s)' \n
            __slots__ = () \n
            _fields = %(field_names)r \n
            def __new__(_cls, %(argtxt)s):
                return _tuple.__new__(_cls, (%(argtxt)s)) \n
            @classmethod
            def _make(cls, iterable, new=tuple.__new__, len=len):
                'Make a new %(typename)s object from a sequence or iterable'
                result = new(cls, iterable)
                if len(result) != %(numfields)d:
                    raise TypeError('Expected %(numfields)d arguments, got %%d' %% len(result))
                return result \n
            def __repr__(self):
                return '%(typename)s(%(reprtxt)s)' %% self \n
            def _asdict(self):
                'Return a new dict which maps field names to their values'
                return dict(zip(self._fields, self)) \n
            def _replace(_self, **kwds):
                'Return a new %(typename)s object replacing specified fields with new values'
                result = _self._make(map(kwds.pop, %(field_names)r, _self))
                if kwds:
                    raise ValueError('Got unexpected field names: %%r' %% kwds.keys())
                return result \n
            def __getnewargs__(self):
                return tuple(self) \n\n''' % locals()
        for i, name in enumerate(field_names):
            template += '            %s = _property(_itemgetter(%d))\n' % (name, i)
        if verbose:
            print template

        # Execute the template string in a temporary namespace
        namespace = dict(_itemgetter=_itemgetter, __name__='namedtuple_%s' % typename,
                         _property=property, _tuple=tuple)
        try:
            exec template in namespace
        except SyntaxError, e:
            raise SyntaxError(e.message + ':\n' + template)
        result = namespace[typename]

        # For pickling to work, the __module__ variable needs to be set to the frame
        # where the named tuple is created.  Bypass this step in enviroments where
        # sys._getframe is not defined (Jython for example) or sys._getframe is not
        # defined for arguments greater than 0 (IronPython).
        try:
            result.__module__ = _sys._getframe(1).f_globals.get('__name__', '__main__')
        except (AttributeError, ValueError):
            pass

        return result

########NEW FILE########
__FILENAME__ = dependencies
import sqlalchemy.sql.visitors as visitors

from pokedex.db.tables import metadata

# stolen from sqlalchemy.sql.util.sort_tables
def compute_dependencies(tables):
    """Construct a reverse dependency graph for the given tables.

    Returns a dict which maps a table to the list of tables which depend on it.
    """
    tables = list(tables)
    graph = {}
    def visit_foreign_key(fkey):
        if fkey.use_alter:
            return
        parent_table = fkey.column.table
        if parent_table in tables:
            child_table = fkey.parent.table
            if parent_table is not child_table:
                graph.setdefault(parent_table, []).append(child_table)

    for table in tables:
        visitors.traverse(table,
                          {'schema_visitor': True},
                          {'foreign_key': visit_foreign_key})

        graph.setdefault(table, []).extend(table._extra_dependencies)

    return graph

#: The dependency graph for pokedex.db.tables
_pokedex_graph = compute_dependencies(metadata.tables.values())

def find_dependent_tables(tables, graph=None):
    """Recursively find all tables which depend on the given tables.

    The returned set does not include the original tables.
    """
    if graph is None:
        graph = _pokedex_graph
    tables = list(tables)
    dependents = set()
    def add_dependents_of(table):
        for dependent_table in graph.get(table, []):
            if dependent_table not in dependents:
                dependents.add(dependent_table)
                add_dependents_of(dependent_table)

    for table in tables:
        add_dependents_of(table)

    dependents -= set(tables)

    return dependents

########NEW FILE########
__FILENAME__ = load
"""CSV to database or vice versa."""
import csv
import fnmatch
import os.path
import sys

import sqlalchemy.sql.util
import sqlalchemy.types

import pokedex
from pokedex.db import metadata, tables, translations
from pokedex.defaults import get_default_csv_dir
from pokedex.db.dependencies import find_dependent_tables
from pokedex.db.oracle import rewrite_long_table_names


def _get_table_names(metadata, patterns):
    """Returns a list of table names from the given metadata.  If `patterns`
    exists, only tables matching one of the patterns will be returned.
    """
    if patterns:
        table_names = set()
        for pattern in patterns:
            if '.' in pattern or '/' in pattern:
                # If it looks like a filename, pull out just the table name
                _, filename = os.path.split(pattern)
                table_name, _ = os.path.splitext(filename)
                pattern = table_name

            table_names.update(fnmatch.filter(metadata.tables.keys(), pattern))
    else:
        table_names = metadata.tables.keys()

    return list(table_names)

def _get_verbose_prints(verbose):
    """If `verbose` is true, returns three functions: one for printing a
    starting message, one for printing an interim status update, and one for
    printing a success or failure message when finished.

    If `verbose` is false, returns no-op functions.
    """

    if not verbose:
        # Return dummies
        def dummy(*args, **kwargs):
            pass

        return dummy, dummy, dummy

    ### Okay, verbose == True; print stuff

    def print_start(thing):
        # Truncate to 66 characters, leaving 10 characters for a success
        # or failure message
        truncated_thing = thing[:66]

        # Also, space-pad to keep the cursor in a known column
        num_spaces = 66 - len(truncated_thing)

        print "%s...%s" % (truncated_thing, ' ' * num_spaces),
        sys.stdout.flush()

    if sys.stdout.isatty():
        # stdout is a terminal; stupid backspace tricks are OK.
        # Don't use print, because it always adds magical spaces, which
        # makes backspace accounting harder

        backspaces = [0]
        def print_status(msg):
            # Overwrite any status text with spaces before printing
            sys.stdout.write('\b' * backspaces[0])
            sys.stdout.write(' ' * backspaces[0])
            sys.stdout.write('\b' * backspaces[0])
            sys.stdout.write(msg)
            sys.stdout.flush()
            backspaces[0] = len(msg)

        def print_done(msg='ok'):
            # Overwrite any status text with spaces before printing
            sys.stdout.write('\b' * backspaces[0])
            sys.stdout.write(' ' * backspaces[0])
            sys.stdout.write('\b' * backspaces[0])
            sys.stdout.write(msg + "\n")
            sys.stdout.flush()
            backspaces[0] = 0

    else:
        # stdout is a file (or something); don't bother with status at all
        def print_status(msg):
            pass

        def print_done(msg='ok'):
            print msg

    return print_start, print_status, print_done


def load(session, tables=[], directory=None, drop_tables=False, verbose=False, safe=True, recursive=True, langs=None):
    """Load data from CSV files into the given database session.

    Tables are created automatically.

    `session`
        SQLAlchemy session to use.

    `tables`
        List of tables to load.  If omitted, all tables are loaded.

    `directory`
        Directory the CSV files reside in.  Defaults to the `pokedex` data
        directory.

    `drop_tables`
        If set to True, existing `pokedex`-related tables will be dropped.

    `verbose`
        If set to True, status messages will be printed to stdout.

    `safe`
        If set to False, load can be faster, but can corrupt the database if
        it crashes or is interrupted.

    `recursive`
        If set to True, load all dependent tables too.

    `langs`
        List of identifiers of extra language to load, or None to load them all
    """

    # First take care of verbosity
    print_start, print_status, print_done = _get_verbose_prints(verbose)


    if directory is None:
        directory = get_default_csv_dir()

    # XXX why isn't this done in command_load
    table_names = _get_table_names(metadata, tables)
    table_objs = [metadata.tables[name] for name in table_names]

    if recursive:
        table_objs.extend(find_dependent_tables(table_objs))

    table_objs = sqlalchemy.sql.util.sort_tables(table_objs)

    # Limit table names to 30 characters for Oracle
    oracle = (session.connection().dialect.name == 'oracle')
    if oracle:
        rewrite_long_table_names()

    # SQLite speed tweaks
    if not safe and session.connection().dialect.name == 'sqlite':
        session.connection().execute("PRAGMA synchronous=OFF")
        session.connection().execute("PRAGMA journal_mode=OFF")

    # Drop all tables if requested
    if drop_tables:
        bind = session.get_bind()
        print_start('Dropping tables')
        for n, table in enumerate(reversed(table_objs)):
            table.drop(checkfirst=True)

            # Drop columns' types if appropriate; needed for enums in
            # postgresql
            for column in table.c:
                try:
                    drop = column.type.drop
                except AttributeError:
                    pass
                else:
                    drop(bind=bind, checkfirst=True)

            print_status('%s/%s' % (n, len(table_objs)))
        print_done()

    print_start('Creating tables')
    for n, table in enumerate(table_objs):
        table.create()
        print_status('%s/%s' % (n, len(table_objs)))
    print_done()
    connection = session.connection()

    # Okay, run through the tables and actually load the data now
    for table_obj in table_objs:
        if oracle:
            table_name = table_obj._original_name
        else:
            table_name = table_obj.name

        insert_stmt = table_obj.insert()

        print_start(table_name)

        try:
            csvpath = "%s/%s.csv" % (directory, table_name)
            csvfile = open(csvpath, 'rb')
        except IOError:
            # File doesn't exist; don't load anything!
            print_done('missing?')
            continue

        csvsize = os.stat(csvpath).st_size

        reader = csv.reader(csvfile, lineterminator='\n')
        column_names = [unicode(column) for column in reader.next()]

        if not safe and session.connection().dialect.name == 'postgresql':
            """
            Postgres' CSV dialect works with our data, if we mark the not-null
            columns with FORCE NOT NULL.
            COPY is only allowed for DB superusers. If you're not one, use safe
            loading (pokedex load -S).
            """
            session.commit()
            not_null_cols = [c for c in column_names if not table_obj.c[c].nullable]
            if not_null_cols:
                force_not_null = 'FORCE NOT NULL ' + ','.join('"%s"' % c for c in not_null_cols)
            else:
                force_not_null = ''
            command = "COPY %(table_name)s (%(columns)s) FROM '%(csvpath)s' CSV HEADER %(force_not_null)s"
            session.connection().execute(
                command % dict(
                    table_name=table_name,
                    csvpath=csvpath,
                    columns=','.join('"%s"' % c for c in column_names),
                    force_not_null=force_not_null,
                )
            )
            session.commit()
            print_done()
            continue

        # Self-referential tables may contain rows with foreign keys of other
        # rows in the same table that do not yet exist.  Pull these out and add
        # them to the session last
        # ASSUMPTION: Self-referential tables have a single PK called "id"
        deferred_rows = []  # ( row referring to id, [foreign ids we need] )
        seen_ids = set()    # primary keys we've seen

        # Fetch foreign key columns that point at this table, if any
        self_ref_columns = []
        for column in table_obj.c:
            if any(x.references(table_obj) for x in column.foreign_keys):
                self_ref_columns.append(column)

        new_rows = []
        def insert_and_commit():
            if not new_rows:
                return
            session.connection().execute(insert_stmt, new_rows)
            session.commit()
            new_rows[:] = []

            progress = "%d%%" % (100 * csvfile.tell() // csvsize)
            print_status(progress)

        for csvs in reader:
            row_data = {}

            for column_name, value in zip(column_names, csvs):
                column = table_obj.c[column_name]
                if column.nullable and value == '':
                    # Empty string in a nullable column really means NULL
                    value = None
                elif isinstance(column.type, sqlalchemy.types.Boolean):
                    # Boolean values are stored as string values 0/1, but both
                    # of those evaluate as true; SQLA wants True/False
                    if value == '0':
                        value = False
                    else:
                        value = True
                else:
                    # Otherwise, unflatten from bytes
                    value = value.decode('utf-8')

                # nb: Dictionaries flattened with ** have to have string keys
                row_data[ str(column_name) ] = value

            # May need to stash this row and add it later if it refers to a
            # later row in this table
            if self_ref_columns:
                foreign_ids = set(row_data[x.name] for x in self_ref_columns)
                foreign_ids.discard(None)  # remove NULL ids

                if not foreign_ids:
                    # NULL key.  Remember this row and add as usual.
                    seen_ids.add(row_data['id'])

                elif foreign_ids.issubset(seen_ids):
                    # Non-NULL key we've already seen.  Remember it and commit
                    # so we know the old row exists when we add the new one
                    insert_and_commit()
                    seen_ids.add(row_data['id'])

                else:
                    # Non-NULL future id.  Save this and insert it later!
                    deferred_rows.append((row_data, foreign_ids))
                    continue

            # Insert row!
            new_rows.append(row_data)

            # Remembering some zillion rows in the session consumes a lot of
            # RAM.  Let's not do that.  Commit every 1000 rows
            if len(new_rows) >= 1000:
                insert_and_commit()

        insert_and_commit()

        # Attempt to add any spare rows we've collected
        for row_data, foreign_ids in deferred_rows:
            if not foreign_ids.issubset(seen_ids):
                # Could happen if row A refers to B which refers to C.
                # This is ridiculous and doesn't happen in my data so far
                raise ValueError("Too many levels of self-reference!  "
                                 "Row was: " + str(row))

            session.connection().execute(
                insert_stmt.values(**row_data)
            )
            seen_ids.add(row_data['id'])
        session.commit()

        print_done()


    print_start('Translations')
    transl = translations.Translations(csv_directory=directory)

    new_row_count = 0
    for translation_class, rows in transl.get_load_data(langs):
        table_obj = translation_class.__table__
        if table_obj in table_objs:
            insert_stmt = table_obj.insert()
            session.connection().execute(insert_stmt, rows)
            session.commit()
            # We don't have a total, but at least show some increasing number
            new_row_count += len(rows)
            print_status(str(new_row_count))

    print_done()

    # SQLite check
    if session.connection().dialect.name == 'sqlite':
        session.connection().execute("PRAGMA integrity_check")



def dump(session, tables=[], directory=None, verbose=False, langs=['en']):
    """Dumps the contents of a database to a set of CSV files.  Probably not
    useful to anyone besides a developer.

    `session`
        SQLAlchemy session to use.

    `tables`
        List of tables to dump.  If omitted, all tables are dumped.

    `directory`
        Directory the CSV files should be put in.  Defaults to the `pokedex`
        data directory.

    `verbose`
        If set to True, status messages will be printed to stdout.

    `langs`
        List of identifiers of languages to dump unofficial texts for
    """

    # First take care of verbosity
    print_start, print_status, print_done = _get_verbose_prints(verbose)

    languages = dict((l.id, l) for l in session.query(pokedex.db.tables.Language))

    if not directory:
        directory = get_default_csv_dir()

    table_names = _get_table_names(metadata, tables)
    table_names.sort()

    # Oracle needs to dump from tables with shortened names to csvs with the
    # usual names
    oracle = (session.connection().dialect.name == 'oracle')
    if oracle:
        rewrite_long_table_names()

    for table_name in table_names:
        print_start(table_name)
        table = metadata.tables[table_name]

        if oracle:
            filename = '%s/%s.csv' % (directory, table._original_name)
        else:
            filename = '%s/%s.csv' % (directory, table_name)

        writer = csv.writer(open(filename, 'wb'), lineterminator='\n')

        columns = [col.name for col in table.columns]

        # For name tables, dump rows for official languages, as well as
        # for those in `langs`.
        # For other translation tables, only dump rows for languages in `langs`
        # For non-translation tables, dump all rows.
        if 'local_language_id' in columns:
            if any(col.info.get('official') for col in table.columns):
                def include_row(row):
                    return (languages[row.local_language_id].official or
                            languages[row.local_language_id].identifier in langs)
            else:
                def include_row(row):
                    return languages[row.local_language_id].identifier in langs
        else:
            def include_row(row):
                return True

        writer.writerow(columns)

        primary_key = table.primary_key
        for row in session.query(table).order_by(*primary_key).all():
            if include_row(row):
                csvs = []
                for col in columns:
                    # Convert Pythony values to something more universal
                    val = getattr(row, col)
                    if val == None:
                        val = ''
                    elif val == True:
                        val = '1'
                    elif val == False:
                        val = '0'
                    else:
                        val = unicode(val).encode('utf-8')

                    csvs.append(val)

                writer.writerow(csvs)

        print_done()

########NEW FILE########
__FILENAME__ = markdown
# encoding: utf8
u"""Implements the markup used for description and effect text in the database.

The language used is a variation of Markdown and Markdown Extra.  There are
docs for each at http://daringfireball.net/projects/markdown/ and
http://michelf.com/projects/php-markdown/extra/ respectively.

Pokédex links are represented with the syntax `[label]{category:identifier}`,
e.g., `[Eevee]{pokemon:eevee}`. The label can (and should) be left out, in
which case it is replaced by the name of the thing linked to.
"""
from __future__ import absolute_import

import re

import markdown
from sqlalchemy.orm.session import object_session
try:
    # Markdown 2.1+
    from markdown.util import etree, AtomicString
except ImportError:
    # Old Markdown
    from markdown import etree, AtomicString

class MarkdownString(object):
    """Wraps a Markdown string.

    Use unicode() and __html__ for text and HTML representations.
    The as_text() and as_html() functions do the same, but accept optional
    arguments that may affect the rendering.
    The `source_text` property holds the original text.

    init args:
    `source_text`: the text in Markdown syntax
    `session`: A DB session used for looking up linked objects
    `language`: The language the string is in. If None, the session default
        is used.
    """

    default_link_extension = None

    def __init__(self, source_text, session, language):
        self.source_text = source_text
        self.session = session
        self.language = language

    def __unicode__(self):
        return self.as_text()

    def __str__(self):
        return self.as_text().encode()

    def __html__(self):
        return self.as_html()

    def as_html(self, extension=None):
        """Returns the string as HTML.

        Pass a custom `extension` to use your own extension object to generate
        links.
        The default is the session's markdown_extension. Usually that's a
        `PokedexLinkExtension` described below, which is also the recommended
        superclass.
        """

        if extension is None:
            extension = self.session.markdown_extension

        md = markdown.Markdown(
            extensions=['extra', extension],
            safe_mode='escape',
            output_format='xhtml1',
        )

        return md.convert(self.source_text)

    def as_text(self):
        """Returns the string in a plaintext-friendly form.

        Currently there are no tunable parameters
        """
        # Since Markdown is pretty readable by itself, we just have to replace
        # the links by their text.
        # XXX: The tables get unaligned

        link_maker = PokedexLinkExtension(self.session)
        pattern = PokedexLinkPattern(link_maker, self.session, self.language)
        regex = '()%s()' % pattern.regex
        def handleMatch(m):
            return pattern.handleMatch(m).text

        return re.sub(regex, handleMatch, self.source_text)

def _markdownify_effect_text(move, effect_text, language=None):
    session = object_session(move)

    if effect_text is None:
        return effect_text
    effect_text = effect_text.replace(
        u'$effect_chance',
        unicode(move.effect_chance),
    )

    # "The target" vs "each target"; for Conquest, but hopefully main series
    # moves too eventually
    if hasattr(move, 'range'):
        effect_text = effect_text.replace(
            u'$target',
            _target_labels[move.range.targets > 1]
        ).replace(
            u'$Target',
            _target_labels[move.range.targets > 1].capitalize()
        )

    return MarkdownString(effect_text, session, language)

_target_labels = {
    False: 'the target',
    True: 'each target'
}

class MoveEffectProperty(object):
    """Property that wraps move effects.  Used like this:

        MoveClass.effect = MoveEffectProperty('effect')

        some_move.effect            # returns a MarkdownString
        some_move.effect.as_html    # returns a chunk of HTML

    This class also performs simple substitution on the effect, replacing
    `$effect_chance` with the move's actual effect chance.

    Use `MoveEffectPropertyMap` for dict-like association proxies.
    """

    def __init__(self, effect_column, relationship='move_effect'):
        self.effect_column = effect_column
        self.relationship = relationship

    def __get__(self, obj, cls):
        if obj is None:
            return self
        if obj.move_effect is None:
            return None
        thing = getattr(obj, self.relationship)
        prop = getattr(thing, self.effect_column)
        return _markdownify_effect_text(obj, prop)

class MoveEffectPropertyMap(MoveEffectProperty):
    """Similar to `MoveEffectProperty`, but works on dict-like association
    proxies.
    """
    def __get__(self, obj, cls):
        if obj is None:
            return self
        prop = getattr(obj.move_effect, self.effect_column)
        newdict = dict(prop)
        for key in newdict:
            newdict[key] = _markdownify_effect_text(obj, newdict[key], key)
        return newdict


class PokedexLinkPattern(markdown.inlinepatterns.Pattern):
    """Matches [label]{category:target}.

    Handles matches using factory
    """
    regex = ur'(?x) \[ ([^]]*) \] \{ ([-a-z0-9]+) : ([-a-z0-9 ]+) \}'

    def __init__(self, factory, session, string_language=None, game_language=None):
        markdown.inlinepatterns.Pattern.__init__(self, self.regex)
        self.factory = factory
        self.session = session
        self.string_language = string_language
        self.game_language = game_language

    def handleMatch(self, m):
        from pokedex.db import tables, util
        start, label, category, target, end = m.groups()
        try:
            table = dict(
                    ability=tables.Ability,
                    item=tables.Item,
                    location=tables.Location,
                    move=tables.Move,
                    pokemon=tables.PokemonSpecies,
                    type=tables.Type,
                    form=tables.PokemonForm,
                )[category]
        except KeyError:
            obj = name = target
            url = self.factory.identifier_url(category, obj)
        else:
            session = self.session
            if table is tables.PokemonForm:
                form_ident, pokemon_ident = target.split()
                query = session.query(table)
                query = query.filter(
                        tables.PokemonForm.form_identifier == form_ident)
                query = query.join(tables.PokemonForm.pokemon)
                query = query.join(tables.Pokemon.species)
                query = query.filter(
                        tables.PokemonSpecies.identifier == pokemon_ident)
            else:
                query = session.query(table)
                query = query.filter(table.identifier == target)
            try:
                obj = query.one()
            except Exception:
                obj = name = target
                url = self.factory.identifier_url(category, obj)
            else:
                url = self.factory.object_url(category, obj)
                url = url or self.factory.identifier_url(category, target)
                name = None
                # Translations can be incomplete; in which case we want to use
                # a fallback.
                if table in [tables.Type] and self.string_language:
                    # Type wants to be localized to the text language
                    name = obj.name_map.get(self.string_language)
                if not name and self.game_language:
                    name = obj.name_map.get(self.game_language)
                if not name:
                    name = obj.name
        if url:
            el = self.factory.make_link(category, obj, url, label or name)
        else:
            el = etree.Element('span')
            el.text = AtomicString(label or name)
        return el

class PokedexLinkExtension(markdown.Extension):
    u"""Markdown extension that translates the syntax used in effect text:

    `[label]{category:identifier}` is treated as a link to a Pokédex object,
    where `category` is the table's singular name, and `label` is an optional
    link title that defaults to the object's name in the current language.
    """
    def __init__(self, session):
        self.session = session

    def extendMarkdown(self, md, md_globals):
        pattern = PokedexLinkPattern(self, self.session)
        md.inlinePatterns['pokedex-link'] = pattern

    def make_link(self, category, obj, url, text):
        """Make an <a> element

        Override this to set custom attributes, e.g. title.
        """
        el = etree.Element('a')
        el.set('href', url)
        el.text = AtomicString(text)
        return el

    def identifier_url(self, category, identifier):
        """Return the URL for the given {category:identifier} link.  For ORM
        objects, object_url is tried first.

        Returns None by default, which causes <span> to be used in place of
        <a>.

        This method is also called for non-existent objects, e.g.
        []{pokemon:bogus}.
        """
        return None

    def object_url(self, category, obj):
        u"""Return the URL for the ORM object `obj`.

        Returns None by default, which causes identifier_url to be tried.

        Note that obj may be a Pokémon form. Unlike other returned objects,
        these do not have identifiers. Be sure to test this case.
        """
        return None

########NEW FILE########
__FILENAME__ = multilang
from functools import partial

from sqlalchemy.ext.associationproxy import association_proxy, AssociationProxy
from sqlalchemy.orm import Query, aliased, mapper, relationship, synonym
from sqlalchemy.orm.collections import attribute_mapped_collection
from sqlalchemy.orm.scoping import ScopedSession
from sqlalchemy.orm.session import Session, object_session
from sqlalchemy.schema import Column, ForeignKey, Table
from sqlalchemy.sql.expression import and_, bindparam, select, exists
from sqlalchemy.sql.operators import ColumnOperators
from sqlalchemy.types import Integer

from pokedex.db import markdown

class LocalAssociationProxy(AssociationProxy, ColumnOperators):
    """An association proxy for names in the default language

    Over the regular association_proxy, this provides sorting and filtering
    capabilities, implemented via SQL subqueries.
    """
    def __clause_element__(self):
        q = select([self.remote_attr])
        q = q.where(self.target_class.foreign_id == self.owning_class.id)
        q = q.where(self.target_class.local_language_id == bindparam('_default_language_id'))
        return q

    def operate(self, op, *other, **kwargs):
        q = select([self.remote_attr])
        q = q.where(self.target_class.foreign_id == self.owning_class.id)
        q = q.where(self.target_class.local_language_id == bindparam('_default_language_id'))
        q = q.where(op(self.remote_attr, *other))
        return exists(q)


def _getset_factory_factory(column_name, string_getter):
    """Hello!  I am a factory for creating getset_factory functions for SQLA.
    I exist to avoid the closure-in-a-loop problem.
    """
    def getset_factory(underlying_type, instance):
        def getter(translations):
            if translations is None:
                return None
            text = getattr(translations, column_name)
            if text is None:
                return text
            session = object_session(translations)
            language = translations.local_language
            return string_getter(text, session, language)
        def setter(translations, value):
            # The string must be set on the Translation directly.
            raise AttributeError("Cannot set %s" % column_name)
        return getter, setter
    return getset_factory

def create_translation_table(_table_name, foreign_class, relation_name,
    language_class, relation_lazy='select', **kwargs):
    """Creates a table that represents some kind of data attached to the given
    foreign class, but translated across several languages.  Returns the new
    table's mapped class.  It won't be declarative, but it will have a
    `__table__` attribute so you can retrieve the Table object.

    `foreign_class` must have a `__singlename__`, currently only used to create
    the name of the foreign key column.

    Also supports the notion of a default language, which is attached to the
    session.  This is English by default, for historical and practical reasons.

    Usage looks like this:

        class Foo(Base): ...

        create_translation_table('foo_bars', Foo, 'bars',
            name = Column(...),
        )

        # Now you can do the following:
        foo.name
        foo.name_map['en']
        foo.foo_bars['en']

        foo.name_map['en'] = "new name"
        del foo.name_map['en']

        q.options(joinedload(Foo.bars_local))
        q.options(joinedload(Foo.bars))

    The following properties are added to the passed class:

    - `(relation_name)`, a relation to the new table.  It uses a dict-based
      collection class, where the keys are language identifiers and the values
      are rows in the created tables.
    - `(relation_name)_local`, a relation to the row in the new table that
      matches the current default language.
    - `(relation_name)_table`, the class created by this function.

    Note that these are distinct relations.  Even though the former necessarily
    includes the latter, SQLAlchemy doesn't treat them as linked; loading one
    will not load the other.  Modifying both within the same transaction has
    undefined behavior.

    For each column provided, the following additional attributes are added to
    Foo:

    - `(column)_map`, an association proxy onto `foo_bars`.
    - `(column)`, an association proxy onto `foo_bars_local`.

    Pardon the naming disparity, but the grammar suffers otherwise.

    Modifying these directly is not likely to be a good idea.

    For Markdown-formatted columns, `(column)_map` and `(column)` will give
    Markdown objects.
    """
    # n.b.: language_class only exists for the sake of tests, which sometimes
    # want to create tables entirely separate from the pokedex metadata

    foreign_key_name = foreign_class.__singlename__ + '_id'

    Translations = type(_table_name, (object,), {
        '_language_identifier': association_proxy('local_language', 'identifier'),
        'relation_name': relation_name,
        '__tablename__': _table_name,
    })

    # Create the table object
    table = Table(_table_name, foreign_class.__table__.metadata,
        Column(foreign_key_name, Integer, ForeignKey(foreign_class.id),
            primary_key=True, nullable=False,
            info=dict(description="ID of the %s these texts relate to" % foreign_class.__singlename__)),
        Column('local_language_id', Integer, ForeignKey(language_class.id),
            primary_key=True, nullable=False,
            info=dict(description="Language these texts are in")),
    )
    Translations.__table__ = table

    # Add ye columns
    # Column objects have a _creation_order attribute in ascending order; use
    # this to get the (unordered) kwargs sorted correctly
    kwitems = kwargs.items()
    kwitems.sort(key=lambda kv: kv[1]._creation_order)
    for name, column in kwitems:
        column.name = name
        table.append_column(column)

    # Construct ye mapper
    mapper(Translations, table, properties={
        'foreign_id': synonym(foreign_key_name),
        'local_language': relationship(language_class,
            primaryjoin=table.c.local_language_id == language_class.id,
            innerjoin=True),
    })

    # Add full-table relations to the original class
    # Foo.bars_table
    setattr(foreign_class, relation_name + '_table', Translations)
    # Foo.bars
    setattr(foreign_class, relation_name, relationship(Translations,
        primaryjoin=foreign_class.id == Translations.foreign_id,
        collection_class=attribute_mapped_collection('local_language'),
    ))
    # Foo.bars_local
    # This is a bit clever; it uses bindparam() to make the join clause
    # modifiable on the fly.  db sessions know the current language and
    # populate the bindparam.
    # The 'dummy' value is to trick SQLA; without it, SQLA thinks this
    # bindparam is just its own auto-generated clause and everything gets
    # fucked up.
    local_relation_name = relation_name + '_local'
    setattr(foreign_class, local_relation_name, relationship(Translations,
        primaryjoin=and_(
            Translations.foreign_id == foreign_class.id,
            Translations.local_language_id == bindparam('_default_language_id',
                value='dummy', type_=Integer, required=True),
        ),
        foreign_keys=[Translations.foreign_id, Translations.local_language_id],
        uselist=False,
        #innerjoin=True,
        lazy=relation_lazy,
    ))

    # Add per-column proxies to the original class
    for name, column in kwitems:
        getset_factory = None
        string_getter = column.info.get('string_getter')
        if string_getter:
            getset_factory = _getset_factory_factory(
                column.name, string_getter)

        # Class.(column) -- accessor for the default language's value
        setattr(foreign_class, name,
            LocalAssociationProxy(local_relation_name, name,
                    getset_factory=getset_factory))

        # Class.(column)_map -- accessor for the language dict
        # Need a custom creator since Translations doesn't have an init, and
        # these are passed as *args anyway
        def creator(language, value):
            row = Translations()
            row.local_language = language
            setattr(row, name, value)
            return row
        setattr(foreign_class, name + '_map',
            association_proxy(relation_name, name, creator=creator,
                    getset_factory=getset_factory))

    # Add to the list of translation classes
    foreign_class.translation_classes.append(Translations)

    # Done
    return Translations

class MultilangQuery(Query):
    def __iter__(self):
        if '_default_language_id' not in self._params:
            self._params = self._params.copy()
            self._params['_default_language_id'] = self.session.default_language_id
        return super(MultilangQuery, self).__iter__()

class MultilangSession(Session):
    """A tiny Session subclass that adds support for a default language.

    Needs to be used with `MultilangScopedSession`, below.
    """
    default_language_id = None
    markdown_extension_class = markdown.PokedexLinkExtension

    def __init__(self, *args, **kwargs):
        if 'default_language_id' in kwargs:
            self.default_language_id = kwargs.pop('default_language_id')

        markdown_extension_class = kwargs.pop('markdown_extension_class',
                self.markdown_extension_class)

        self.markdown_extension = markdown_extension_class(self)

        kwargs.setdefault('query_cls', MultilangQuery)

        super(MultilangSession, self).__init__(*args, **kwargs)

class MultilangScopedSession(ScopedSession):
    """Dispatches language selection to the attached Session."""

    @property
    def default_language_id(self):
        """Passes the new default language id through to the current session.
        """
        return self.registry().default_language_id

    @default_language_id.setter
    def default_language_id(self, new):
        self.registry().default_language_id = new

    @property
    def markdown_extension(self):
        return self.registry().markdown_extension

########NEW FILE########
__FILENAME__ = oracle
from pokedex.db import metadata

### Helper functions for oracle
def rewrite_long_table_names():
    """Disemvowels all table names over thirty characters."""
    # Load tables from metadata
    table_objs = metadata.tables.values()

    # Shorten table names, Oracle limits table and column names to 30 chars
    for table in table_objs:
        table._original_name = table.name

        if len(table.name) > 30:
            for letter in 'aeiouy':
                table.name = table.name.replace(letter, '')

def restore_long_table_names():
    """Modifies the table names to restore the long-naming."""
    for table in metadata.tables.values():
        table.name = table._original_name
        del table._original_name

########NEW FILE########
__FILENAME__ = tables
# encoding: utf8

u"""The Pokédex schema

Columns have a info dictionary with these keys:
- description: The description of the column
- official: True if the values appear in games or official material; False if
  they are fan-created or fan-written. This flag is currently only set for
  official text columns.
- markup: The format of a text column. Can be one of:
  - plaintext: Normal Unicode text (widely used in names)
  - markdown: Veekun's Markdown flavor (generally used in effect descriptions)
  - gametext: Transcription of in-game text that strives to be both
    human-readable and represent the original text exactly.
  - identifier: A fan-made identifier in the [-_a-z0-9]* format. Not intended
    for translation.
  - latex: A formula in LaTeX syntax.
- ripped: True for text that has been ripped from the games, and can be ripped
  again for new versions or languages

 - string_getter: for translation columns, a function taking (text, session,
    language) that is used for properties on the main table. Used for Markdown
    text.

See `pokedex.db.multilang` for how localizable text columns work.  The session
classes in that module can be used to change the default language.
"""
# XXX: Check if "gametext" is set correctly everywhere

import collections
from functools import partial

from sqlalchemy import Column, ForeignKey, MetaData, PrimaryKeyConstraint, Table, UniqueConstraint
from sqlalchemy.ext.declarative import declarative_base, DeclarativeMeta
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.orm import backref, relationship
from sqlalchemy.orm.session import Session
from sqlalchemy.orm.interfaces import AttributeExtension
from sqlalchemy.sql import and_, or_
from sqlalchemy.schema import ColumnDefault
from sqlalchemy.types import Boolean, Enum, Integer, SmallInteger, Unicode, UnicodeText

from pokedex.db import markdown, multilang

class TableSuperclass(object):
    """Superclass for declarative tables, to give them some generic niceties
    like stringification.
    """
    def __unicode__(self):
        """Be as useful as possible.  Show the primary key, and an identifier
        if we've got one.
        """
        typename = u'.'.join((__name__, type(self).__name__))

        pk_constraint = self.__table__.primary_key
        if not pk_constraint:
            return u"<%s object at %x>" % (typename, id(self))

        pk = u', '.join(unicode(getattr(self, column.name))
            for column in pk_constraint.columns)
        try:
            return u"<%s object (%s): %s>" % (typename, pk, self.identifier)
        except AttributeError:
            return u"<%s object (%s)>" % (typename, pk)

    def __str__(self):
        return unicode(self).encode('utf8')

    def __repr__(self):
        return unicode(self).encode('utf8')

mapped_classes = []
class TableMetaclass(DeclarativeMeta):
    def __init__(cls, name, bases, attrs):
        super(TableMetaclass, cls).__init__(name, bases, attrs)
        if hasattr(cls, '__tablename__'):
            mapped_classes.append(cls)
            cls.translation_classes = []

metadata = MetaData()
TableBase = declarative_base(metadata=metadata, cls=TableSuperclass, metaclass=TableMetaclass)


### Need Language first, to create the partial() below

class Language(TableBase):
    u"""A language the Pokémon games have been translated into
    """
    __tablename__ = 'languages'
    __singlename__ = 'language'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    iso639 = Column(Unicode(79), nullable=False,
        info=dict(description="The two-letter code of the country where this language is spoken. Note that it is not unique.", format='identifier'))
    iso3166 = Column(Unicode(79), nullable=False,
        info=dict(description="The two-letter code of the language. Note that it is not unique.", format='identifier'))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))
    official = Column(Boolean, nullable=False, index=True,
        info=dict(description=u"True iff games are produced in the language."))
    order = Column(Integer, nullable=True,
        info=dict(description=u"Order for sorting in foreign name lists."))

create_translation_table = partial(multilang.create_translation_table, language_class=Language)

create_translation_table('language_names', Language, 'names',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

### The actual tables

class Ability(TableBase):
    u"""An ability a Pokémon can have, such as Static or Pressure.
    """
    __tablename__ = 'abilities'
    __singlename__ = 'ability'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="This ability's unique ID; matches the games' internal ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))
    generation_id = Column(Integer, ForeignKey('generations.id'), nullable=False,
        info=dict(description="The ID of the generation this ability was introduced in", detail=True))
    is_main_series = Column(Boolean, nullable=False, index=True,
        info=dict(description="True iff the ability exists in the main series."))

create_translation_table('ability_names', Ability, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True, ripped=True)),
)
create_translation_table('ability_prose', Ability, 'prose',
    short_effect = Column(UnicodeText, nullable=True,
        info=dict(description="A short summary of this ability's effect", format='markdown', string_getter=markdown.MarkdownString)),
    effect = Column(UnicodeText, nullable=True,
        info=dict(description="A detailed description of this ability's effect", format='markdown', string_getter=markdown.MarkdownString)),
)

class AbilityChangelog(TableBase):
    """History of changes to abilities across main game versions."""
    __tablename__ = 'ability_changelog'
    __singlename__ = 'ability_changelog'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="This change's unique ID"))
    ability_id = Column(Integer, ForeignKey('abilities.id'), nullable=False,
        info=dict(description="The ID of the ability that changed"))
    changed_in_version_group_id = Column(Integer, ForeignKey('version_groups.id'), nullable=False,
        info=dict(description="The ID of the version group in which the ability changed"))

create_translation_table('ability_changelog_prose', AbilityChangelog, 'prose',
    effect = Column(UnicodeText, nullable=False,
        info=dict(description="A description of the old behavior", format='markdown', string_getter=markdown.MarkdownString))
)

class AbilityFlavorText(TableBase):
    u"""In-game flavor text of an ability
    """
    __tablename__ = 'ability_flavor_text'
    ability_id = Column(Integer, ForeignKey('abilities.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="The ID of the ability"))
    version_group_id = Column(Integer, ForeignKey('version_groups.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="The ID of the version group this flavor text is taken from"))
    language_id = Column(Integer, ForeignKey('languages.id'), primary_key=True, nullable=False,
        info=dict(description="The language"))
    flavor_text = Column(UnicodeText, nullable=False,
        info=dict(description="The actual flavor text", official=True, format='gametext'))

class Berry(TableBase):
    u"""A Berry, consumable item that grows on trees

    For data common to all items, such as the name, see the corresponding item entry.
    """
    __tablename__ = 'berries'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="This Berry's in-game number"))
    item_id = Column(Integer, ForeignKey('items.id'), nullable=False,
        info=dict(description="The ID of the item that represents this Berry"))
    firmness_id = Column(Integer, ForeignKey('berry_firmness.id'), nullable=False,
        info=dict(description="The ID of this Berry's firmness category"))
    natural_gift_power = Column(Integer, nullable=True,
        info=dict(description="Natural Gift's power when used with this Berry"))
    natural_gift_type_id = Column(Integer, ForeignKey('types.id'), nullable=True,
        info=dict(description="The ID of the Type that Natural Gift has when used with this Berry"))
    size = Column(Integer, nullable=False,
        info=dict(description=u"The size of this Berry, in millimeters"))
    max_harvest = Column(Integer, nullable=False,
        info=dict(description="The maximum number of these berries that can grow on one tree in Generation IV"))
    growth_time = Column(Integer, nullable=False,
        info=dict(description="Time it takes the tree to grow one stage, in hours.  Berry trees go through four of these growth stages before they can be picked."))
    soil_dryness = Column(Integer, nullable=False,
        info=dict(description="The speed at which this Berry dries out the soil as it grows.  A higher rate means the soil dries more quickly."))
    smoothness = Column(Integer, nullable=False,
        info=dict(description=u"The smoothness of this Berry, used in making Pokéblocks or Poffins"))

class BerryFirmness(TableBase):
    u"""A Berry firmness, such as "hard" or "very soft".
    """
    __tablename__ = 'berry_firmness'
    __singlename__ = 'berry_firmness'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A unique ID for this firmness"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('berry_firmness_names', BerryFirmness, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class BerryFlavor(TableBase):
    u"""A Berry flavor level.
    """
    __tablename__ = 'berry_flavors'
    berry_id = Column(Integer, ForeignKey('berries.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="The ID of the berry"))
    contest_type_id = Column(Integer, ForeignKey('contest_types.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="The ID of the flavor"))
    flavor = Column(Integer, nullable=False,
        info=dict(description="The level of the flavor in the berry"))

class ConquestEpisode(TableBase):
    u"""An episode from Pokémon Conquest: one of a bunch of mini-stories
    featuring a particular warrior.

    The main story, "The Legend of Ransei", also counts, even though it's not
    in the episode select menu and there's no way to replay it.
    """
    __tablename__ = 'conquest_episodes'
    __singlename__ = 'episode'
    id = Column(Integer, primary_key=True, autoincrement=True,
        info=dict(description=u'An ID for this episode.'))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u'A readable identifier for this episode.', format='identifier'))

create_translation_table('conquest_episode_names', ConquestEpisode, 'names',
    relation_lazy='joined',
    name=Column(Unicode(79), nullable=False, index=True,
        info=dict(description='The name.', format='plaintext', official=True))
)

class ConquestEpisodeWarrior(TableBase):
    u"""A warrior featured in an episode in Pokémon Conquest.

    This needs its own table because of the player having two episodes and
    there being two players.
    """
    __tablename__ = 'conquest_episode_warriors'
    episode_id = Column(Integer, ForeignKey('conquest_episodes.id'), primary_key=True,
        info=dict(description=u'The ID of the episode.'))
    warrior_id = Column(Integer, ForeignKey('conquest_warriors.id'), primary_key=True,
        info=dict(description=u'The ID of the warrior.'))

class ConquestKingdom(TableBase):
    u"""A kingdom in Pokémon Conquest.
    """
    __tablename__ = 'conquest_kingdoms'
    __singlename__ = 'kingdom'
    id = Column(Integer, primary_key=True, autoincrement=True,
        info=dict(description="An ID for this kingdom."))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="A readable identifier for this kingdom.", format='identifier'))
    type_id = Column(Integer, ForeignKey('types.id'), nullable=False,
        info=dict(description="The type associated with this kingdom in-game."))

create_translation_table('conquest_kingdom_names', ConquestKingdom, 'names',
    relation_lazy='joined',
    name=Column(Unicode(79), nullable=False, index=True,
        info=dict(description='The name.', format='plaintext', official=True))
)

class ConquestMaxLink(TableBase):
    u"""The maximum link a warrior rank can reach with a Pokémon in Pokémon
    Conquest.
    """
    __tablename__ = 'conquest_max_links'
    warrior_rank_id = Column(Integer, ForeignKey('conquest_warrior_ranks.id'), primary_key=True,
        info=dict(description="The ID of the warrior rank."))
    pokemon_species_id = Column(Integer, ForeignKey('pokemon_species.id'), primary_key=True,
        info=dict(description='The ID of the Pokémon species.'))
    max_link = Column(Integer, nullable=False,
        info=dict(description='The maximum link percentage this warrior rank and Pokémon can reach.'))

class ConquestMoveData(TableBase):
    u"""Data about a move in Pokémon Conquest.
    """
    __tablename__ = 'conquest_move_data'
    move_id = Column(Integer, ForeignKey('moves.id'), primary_key=True, autoincrement=False,
        info=dict(description=u'The ID of the move.'))
    power = Column(Integer, nullable=True,
        info=dict(description=u"The move's power, null if it does no damage."))
    accuracy = Column(Integer, nullable=True,
        info=dict(description=u"The move's base accuracy, null if it is self-targetted or never misses."))
    effect_chance = Column(Integer, nullable=True,
        info=dict(description=u"The chance as a percentage that the move's secondary effect will trigger."))
    effect_id = Column(Integer, ForeignKey('conquest_move_effects.id'), nullable=False,
        info=dict(description=u"The ID of the move's effect."))
    range_id = Column(Integer, ForeignKey('conquest_move_ranges.id'), nullable=False,
        info=dict(description=u"The ID of the move's range."))
    displacement_id = Column(Integer, ForeignKey('conquest_move_displacements.id'), nullable=True,
        info=dict(description=u"The ID of the move's displacement."))

    @property
    def star_rating(self):
        """Return the move's in-game power rating as a number of stars."""
        if not self.power:
            return 0
        else:
            stars = (self.power - 1) // 10
            stars = min(stars, 5)  # i.e. maximum of 5 stars
            stars = max(stars, 1)  # And minimum of 1
            return stars

class ConquestMoveDisplacement(TableBase):
    u"""A way in which a move can cause the user or target to move to a
    different tile.

    If a move displaces its user, the move's range is relative to the user's
    original position.
    """
    __tablename__ = 'conquest_move_displacements'
    __singlename__ = 'move_displacement'
    id = Column(Integer, primary_key=True, autoincrement=True,
        info=dict(description=u'An ID for this displacement.'))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u'A readable identifier for this displacement.', format='identifier'))
    affects_target = Column(Boolean, nullable=False,
        info=dict(description=u'True iff the move displaces its target(s) and not its user.'))

create_translation_table('conquest_move_displacement_prose', ConquestMoveDisplacement, 'prose',
    name = Column(Unicode(79), nullable=True,
        info=dict(description='A name for the displacement.', format='plaintext')),
    short_effect = Column(UnicodeText, nullable=True,
        info=dict(description="A short summary of how the displacement works, to be used in the move's short effect.", format='markdown')),
    effect = Column(UnicodeText, nullable=True,
        info=dict(description="A detailed description of how the displacement works, to be used alongside the move's long effect.", format='markdown')),
)

class ConquestMoveEffect(TableBase):
    u"""An effect moves can have in Pokémon Conquest.
    """
    __tablename__ = 'conquest_move_effects'
    __singlename__ = 'conquest_move_effect'
    id = Column(Integer, primary_key=True, autoincrement=True,
        info=dict(description=u'An ID for this effect.'))

create_translation_table('conquest_move_effect_prose', ConquestMoveEffect, 'prose',
    short_effect = Column(UnicodeText, nullable=True,
        info=dict(description="A short summary of the effect", format='markdown')),
    effect = Column(UnicodeText, nullable=True,
        info=dict(description="A detailed description of the effect", format='markdown')),
)

class ConquestMoveRange(TableBase):
    u"""A set of tiles moves can target in Pokémon Conquest."""
    __tablename__ = 'conquest_move_ranges'
    __singlename__ = 'conquest_move_range'
    id = Column(Integer, primary_key=True, autoincrement=True,
        info=dict(description=u'An ID for this range.'))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u'A readable identifier for this range.', format='identifier'))
    targets = Column(Integer, nullable=False,
        info=dict(description=u'The number of tiles this range targets.'))

create_translation_table('conquest_move_range_prose', ConquestMoveRange, 'prose',
    name = Column(Unicode(79), nullable=True,
        info=dict(description="A short name briefly describing the range", format='plaintext')),
    description = Column(UnicodeText, nullable=True,
        info=dict(description="A detailed description of the range", format='plaintext')),
)

class ConquestPokemonAbility(TableBase):
    u"""An ability a Pokémon species has in Pokémon Conquest.
    """
    __tablename__ = 'conquest_pokemon_abilities'
    pokemon_species_id = Column(Integer, ForeignKey('pokemon_species.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u'The ID of the Pokémon species with this ability.'))
    slot = Column(Integer, primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"The order abilities are listed in.  Upon evolution, if a Pokémon's abilities change, it will receive the one in the same slot."))
    ability_id = Column(Integer, ForeignKey('abilities.id'), nullable=False,
        info=dict(description=u'The ID of the ability.'))

class ConquestPokemonEvolution(TableBase):
    u"""The conditions under which a Pokémon must successfully complete an
    action to evolve in Pokémon Conquest.

    Any condition may be null if it does not apply for a particular Pokémon.
    """
    __tablename__ = 'conquest_pokemon_evolution'
    evolved_species_id = Column(Integer, ForeignKey('pokemon_species.id'), primary_key=True, nullable=False,
        info=dict(description=u"The ID of the post-evolution species."))
    required_stat_id = Column(Integer, ForeignKey('conquest_stats.id'), nullable=True,
        info=dict(description=u"The ID of the stat which minimum_stat applies to."))
    minimum_stat = Column(Integer, nullable=True,
        info=dict(description=u"The minimum value the Pokémon must have in a particular stat."))
    minimum_link = Column(Integer, nullable=True,
        info=dict(description=u"The minimum link percentage the Pokémon must have with its warrior."))
    kingdom_id = Column(Integer, ForeignKey('conquest_kingdoms.id'), nullable=True,
        info=dict(description=u"The ID of the kingdom in which this Pokémon must complete an action after meeting all other requirements."))
    warrior_gender_id = Column(Integer, ForeignKey('genders.id'), nullable=True,
        info=dict(description=u"The ID of the gender the Pokémon's warrior must be."))
    item_id = Column(Integer, ForeignKey('items.id'), nullable=True,
        info=dict(description=u"The ID of the item the Pokémon's warrior must have equipped."))
    recruiting_ko_required = Column(Boolean, nullable=False,
        info=dict(description=u"If true, the Pokémon must KO a Pokémon under the right conditions to recruit that Pokémon's warrior."))

class ConquestPokemonMove(TableBase):
    u"""A Pokémon's move in Pokémon Conquest.

    Yes, "move"; each Pokémon has exactly one.
    """
    __tablename__ = 'conquest_pokemon_moves'
    pokemon_species_id = Column(Integer, ForeignKey('pokemon_species.id'), primary_key=True, autoincrement=False,
        info=dict(description=u'The ID of the Pokémon species.'))
    move_id = Column(Integer, ForeignKey('moves.id'), nullable=False,
        info=dict(description=u'The ID of the move.'))

class ConquestPokemonStat(TableBase):
    u"""A Pokémon's base stat in Pokémon Conquest.

    The main four base stats in Conquest are derived from level 100 stats in
    the main series (ignoring effort, genes, and natures).  Attack matches
    either Attack or Special Attack, and Defense matches the average of Defense
    and Special Defense.  HP and Speed are the same.
    """
    __tablename__ = 'conquest_pokemon_stats'
    pokemon_species_id = Column(Integer, ForeignKey('pokemon_species.id'), primary_key=True, autoincrement=False,
        info=dict(description=u'The ID of the Pokémon species.'))
    conquest_stat_id = Column(Integer, ForeignKey('conquest_stats.id'), primary_key=True, autoincrement=False,
        info=dict(description=u'The ID of the stat.'))
    base_stat = Column(Integer, nullable=False,
        info=dict(description=u'The base stat.'))

class ConquestStat(TableBase):
    u"""A stat Pokémon have in Pokémon Conquest.
    """
    __tablename__ = 'conquest_stats'
    __singlename__ = 'conquest_stat'  # To be safe
    id = Column(Integer, primary_key=True, autoincrement=True,
        info=dict(description=u'An ID for this stat.'))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u'A readable identifier for this stat.', format='identifier'))
    is_base = Column(Boolean, nullable=False,
        info=dict(description=u'True iff this is one of the main stats, calculated for individual Pokémon.'))

create_translation_table('conquest_stat_names', ConquestStat, 'names',
    relation_lazy='joined',
    name=Column(Unicode(79), nullable=False, index=True,
        info=dict(description='The name.', format='plaintext', official=True))
)

class ConquestTransformationPokemon(TableBase):
    u"""A Pokémon that satisfies a warrior transformation's link condition.

    If a warrior has one or more Pokémon listed here, they only need to raise
    one of them to the required link.
    """
    __tablename__ = 'conquest_transformation_pokemon'
    transformation_id = Column(Integer, ForeignKey('conquest_warrior_transformation.transformed_warrior_rank_id'), primary_key=True,
        info=dict(description=u'The ID of the corresponding transformation, in turn a warrior rank ID.'))
    pokemon_species_id = Column(Integer, ForeignKey('pokemon_species.id'), primary_key=True,
        info=dict(description=u'The ID of the Pokémon species.'))

class ConquestTransformationWarrior(TableBase):
    u"""A warrior who must be present in the same nation as another warrior for
    the latter to transform into their next rank.

    If a warrior has one or more other warriors listed here, they *all* need to
    gather in the same nation for the transformation to take place.
    """
    __tablename__ = 'conquest_transformation_warriors'
    transformation_id = Column(Integer, ForeignKey('conquest_warrior_transformation.transformed_warrior_rank_id'), primary_key=True,
        info=dict(description=u'The ID of the corresponding transformation, in turn a warrior rank ID.'))
    present_warrior_id = Column(Integer, ForeignKey('conquest_warriors.id'), primary_key=True,
        info=dict(description=u'The ID of the other warrior who must be present.'))

class ConquestWarrior(TableBase):
    u"""A warrior in Pokémon Conquest.
    """
    __tablename__ = 'conquest_warriors'
    __singlename__ = 'warrior'
    id = Column(Integer, primary_key=True, nullable=False, autoincrement=True,
        info=dict(description='An ID for this warrior.'))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description='A readable identifier for this warrior.', format='identifier'))
    gender_id = Column(Integer, ForeignKey('genders.id'), nullable=False,
        info=dict(description="The ID of the warrior's gender."))
    archetype_id = Column(Integer, ForeignKey('conquest_warrior_archetypes.id'), nullable=True,
        info=dict(description="The ID of this warrior's archetype.  Null for unique warriors."))

create_translation_table('conquest_warrior_names', ConquestWarrior, 'names',
    relation_lazy='joined',
    name=Column(Unicode(79), nullable=False, index=True,
        info=dict(description='The name.', format='plaintext', official=True))
)

class ConquestWarriorArchetype(TableBase):
    u"""An archetype that generic warriors in Pokémon Conquest can have.  All
    warriors of a particular archetype share sprites and dialogue.

    Some of these are unused as warriors because they exist only as NPCs.  They
    should still be kept because we have their sprites and may eventually get
    their dialogue.
    """
    __tablename__ = 'conquest_warrior_archetypes'
    __singlename__ = 'archetype'
    id = Column(Integer, primary_key=True, autoincrement=True,
        info=dict(description='An ID for this archetype.'))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description='A readable identifier describing this archetype.', format='identifier'))

class ConquestWarriorRank(TableBase):
    u"""A warrior at a particular rank in Pokémon Conquest.

    These are used for whatever changes between ranks, much like Pokémon forms.
    Generic warriors who have only one rank are also represented here, with a
    single row.

    To clarify, each warrior's ranks are individually called "warrior ranks"
    here; for example, "Rank 2 Nobunaga" is an example of a warrior rank, not
    just "Rank 2".
    """
    __tablename__ = 'conquest_warrior_ranks'
    __singlename__ = 'warrior_rank'
    id = Column(Integer, primary_key=True, autoincrement=True,
        info=dict(description=u'An ID for this warrior rank.'))
    warrior_id = Column(Integer, ForeignKey('conquest_warriors.id'), nullable=False,
        info=dict(description=u'The ID of the warrior.'))
    rank = Column(Integer, nullable=False,
        info=dict(description=u'The rank number.'))
    skill_id = Column(Integer, ForeignKey('conquest_warrior_skills.id'), nullable=False,
        info=dict(description=u"The ID of this warrior rank's warrior skill."))

    __table_args__ = (
        UniqueConstraint(warrior_id, rank),
        {},
    )

class ConquestWarriorRankStatMap(TableBase):
    u"""Any of a warrior rank's warrior stats in Pokémon Conquest."""
    __tablename__ = 'conquest_warrior_rank_stat_map'
    warrior_rank_id = Column(Integer, ForeignKey('conquest_warrior_ranks.id'), primary_key=True, autoincrement=False,
        info=dict(description=u'The ID of the warrior rank.'))
    warrior_stat_id = Column(Integer, ForeignKey('conquest_warrior_stats.id'), primary_key=True, autoincrement=False,
        info=dict(description=u'The ID of the warrior stat.'))
    base_stat = Column(Integer, nullable=False,
        info=dict(description=u'The stat.'))

class ConquestWarriorSkill(TableBase):
    u"""A warrior skill in Pokémon Conquest.
    """
    __tablename__ = 'conquest_warrior_skills'
    __singlename__ = 'skill'
    id = Column(Integer, primary_key=True, nullable=False, autoincrement=True,
        info=dict(description='An ID for this skill.'))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description='A readable identifier for this skill.', format='identifier'))

create_translation_table('conquest_warrior_skill_names', ConquestWarriorSkill, 'names',
    relation_lazy='joined',
    name=Column(Unicode(79), nullable=False, index=True,
        info=dict(description='The name.', format='plaintext', official=True))
)

class ConquestWarriorSpecialty(TableBase):
    u"""A warrior's specialty types in Pokémon Conquest.

    These have no actual effect on gameplay; they just indicate which types of
    Pokémon each warrior generally has strong maximum links with.
    """
    __tablename__ = 'conquest_warrior_specialties'
    warrior_id = Column(Integer, ForeignKey('conquest_warriors.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u'The ID of the warrior.'))
    type_id = Column(Integer, ForeignKey('types.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u'The ID of the type.'))
    slot = Column(Integer, primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"The order in which the warrior's types are listed."))

class ConquestWarriorStat(TableBase):
    u"""A stat that warriors have in Pokémon Conquest."""
    __tablename__ = 'conquest_warrior_stats'
    __singlename__ = 'warrior_stat'
    id = Column(Integer, primary_key=True, autoincrement=True,
        info=dict(description=u'An ID for this stat.'))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u'A readable identifier for this stat.', format='identifier'))

create_translation_table('conquest_warrior_stat_names', ConquestWarriorStat, 'names',
    relation_lazy='joined',
    name=Column(Unicode(79), nullable=False, index=True,
        info=dict(description='The name.', format='plaintext', official=True))
)

class ConquestWarriorTransformation(TableBase):
    u"""The conditions under which a warrior must perform an action in order
    to transform to the next rank.

    Or most of them, anyway.  See also ConquestTransformationPokemon and
    ConquestTransformationWarrior.
    """
    __tablename__ = 'conquest_warrior_transformation'
    transformed_warrior_rank_id = Column(Integer, ForeignKey('conquest_warrior_ranks.id'), primary_key=True,
        info=dict(description=u'The ID of the post-transformation warrior rank.'))
    is_automatic = Column(Boolean, nullable=False,
        info=dict(description=u'True iff the transformation happens automatically in the story with no further requirements.'))
    required_link = Column(Integer, nullable=True,
        info=dict(description=u'The link percentage the warrior must reach with one of several specific Pokémon, if any.'))
    completed_episode_id = Column(Integer, ForeignKey('conquest_episodes.id'), nullable=True,
        info=dict(description=u'The ID of the episode the player must have completed, if any.'))
    current_episode_id = Column(Integer, ForeignKey('conquest_episodes.id'), nullable=True,
        info=dict(description=u'The ID of the episode the player must currently be playing, if any.'))
    distant_warrior_id = Column(Integer, ForeignKey('conquest_warriors.id'), nullable=True,
        info=dict(description=u'The ID of another warrior who must be in the army, but not in the same kingdom or in any adjacent kingdom.'))
    female_warlord_count = Column(Integer, nullable=True,
        info=dict(description=u'The number of female warlords who must be in the same nation.'))
    pokemon_count = Column(Integer, nullable=True,
        info=dict(description=u'The number of Pokémon that must be registered in the gallery.'))
    collection_type_id = Column(Integer, ForeignKey('types.id'), nullable=True,
        info=dict(description=u'The ID of a type all Pokémon of which must be registered in the gallery.'))
    warrior_count = Column(Integer, nullable=True,
        info=dict(description=u'The number of warriors that must be registered in the gallery.'))

class ContestCombo(TableBase):
    u"""Combo of two moves in a Contest.
    """
    __tablename__ = 'contest_combos'
    first_move_id = Column(Integer, ForeignKey('moves.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="The ID of the first move in the combo"))
    second_move_id = Column(Integer, ForeignKey('moves.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="The ID of the second and final move in the combo"))

class ContestEffect(TableBase):
    u"""Effect of a move when used in a Contest.
    """
    __tablename__ = 'contest_effects'
    __singlename__ = 'contest_effect'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A unique ID for this effect"))
    appeal = Column(SmallInteger, nullable=False,
        info=dict(description="The base number of hearts the user of this move gets"))
    jam = Column(SmallInteger, nullable=False,
        info=dict(description="The base number of hearts the user's opponent loses"))

create_translation_table('contest_effect_prose', ContestEffect, 'prose',
    flavor_text = Column(UnicodeText, nullable=True,
        info=dict(description="The in-game description of this effect", official=True, format='gametext')),
    effect = Column(UnicodeText, nullable=True,
        info=dict(description="A detailed description of the effect", format='plaintext')),
)

class ContestType(TableBase):
    u"""A Contest type, such as "cool" or "smart", and their associated Berry flavors and Pokéblock colors.
    """
    __tablename__ = 'contest_types'
    __singlename__ = 'contest_type'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A unique ID for this Contest type"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('contest_type_names', ContestType, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
    flavor = Column(UnicodeText, nullable=True,
        info=dict(description="The name of the corresponding Berry flavor", official=True, format='plaintext')),
    color = Column(UnicodeText, nullable=True,
        info=dict(description=u"The name of the corresponding Pokéblock color", official=True, format='plaintext')),
)

class EggGroup(TableBase):
    u"""An Egg group. Usually, two Pokémon can breed if they share an Egg Group.

    (exceptions are the Ditto and No Eggs groups)
    """
    __tablename__ = 'egg_groups'
    __singlename__ = 'egg_group'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A unique ID for this group"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u"An identifier.", format='identifier'))

create_translation_table('egg_group_prose', EggGroup, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class Encounter(TableBase):
    u"""Encounters with wild Pokémon.

    Bear with me, here.

    Within a given area in a given game, encounters are differentiated by the
    "slot" they are in and the state of the game world.

    What the player is doing to get an encounter, such as surfing or walking
    through tall grass, is called a method.  Each method has its own set of
    encounter slots.

    Within a method, slots are defined primarily by rarity.  Each slot can
    also be affected by world conditions; for example, the 20% slot for walking
    in tall grass is affected by whether a swarm is in effect in that area.
    "Is there a swarm?" is a condition; "there is a swarm" and "there is not a
    swarm" are the possible values of this condition.

    A slot (20% walking in grass) and any appropriate world conditions (no
    swarm) are thus enough to define a specific encounter.

    Well, okay, almost: each slot actually appears twice.
    """

    __tablename__ = 'encounters'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A unique ID for this encounter"))
    version_id = Column(Integer, ForeignKey('versions.id'), nullable=False, autoincrement=False,
        info=dict(description="The ID of the version this applies to"))
    location_area_id = Column(Integer, ForeignKey('location_areas.id'), nullable=False, autoincrement=False,
        info=dict(description="The ID of the location of this encounter"))
    encounter_slot_id = Column(Integer, ForeignKey('encounter_slots.id'), nullable=False, autoincrement=False,
        info=dict(description="The ID of the encounter slot, which determines method and rarity"))
    pokemon_id = Column(Integer, ForeignKey('pokemon.id'), nullable=False, autoincrement=False,
        info=dict(description=u"The ID of the encountered Pokémon"))
    min_level = Column(Integer, nullable=False, autoincrement=False,
        info=dict(description=u"The minimum level of the encountered Pokémon"))
    max_level = Column(Integer, nullable=False, autoincrement=False,
        info=dict(description=u"The maxmum level of the encountered Pokémon"))

class EncounterCondition(TableBase):
    u"""A conditions in the game world that affects Pokémon encounters, such as time of day.
    """

    __tablename__ = 'encounter_conditions'
    __singlename__ = 'encounter_condition'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A unique ID for this condition"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('encounter_condition_prose', EncounterCondition, 'prose',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
)

class EncounterConditionValue(TableBase):
    u"""A possible state for a condition; for example, the state of 'swarm' could be 'swarm' or 'no swarm'.
    """

    __tablename__ = 'encounter_condition_values'
    __singlename__ = 'encounter_condition_value'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    encounter_condition_id = Column(Integer, ForeignKey('encounter_conditions.id'), primary_key=False, nullable=False, autoincrement=False,
        info=dict(description="The ID of the encounter condition this is a value of"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))
    is_default = Column(Boolean, nullable=False,
        info=dict(description='Set if this value is the default state for the condition'))

create_translation_table('encounter_condition_value_prose', EncounterConditionValue, 'prose',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
)

class EncounterConditionValueMap(TableBase):
    u"""Maps encounters to the specific conditions under which they occur.
    """
    __tablename__ = 'encounter_condition_value_map'
    encounter_id = Column(Integer, ForeignKey('encounters.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="The ID of the encounter"))
    encounter_condition_value_id = Column(Integer, ForeignKey('encounter_condition_values.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="The ID of the encounter condition value"))

class EncounterMethod(TableBase):
    u"""A way the player can enter a wild encounter, e.g., surfing, fishing, or walking through tall grass.
    """

    __tablename__ = 'encounter_methods'
    __singlename__ = 'encounter_method'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A unique ID for the method"))
    identifier = Column(Unicode(79), nullable=False, unique=True,
        info=dict(description="An identifier", format='identifier'))
    order = Column(Integer, unique=True, nullable=False,
        info=dict(description="A good column for sorting on"))

create_translation_table('encounter_method_prose', EncounterMethod, 'prose',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
)

class EncounterSlot(TableBase):
    u"""An abstract "slot" within a method, associated with both some set of conditions and a rarity.

    Note that there are two encounters per slot, so the rarities will only add
    up to 50.
    """

    __tablename__ = 'encounter_slots'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A unique ID for this slot"))
    version_group_id = Column(Integer, ForeignKey('version_groups.id'), nullable=False, autoincrement=False,
        info=dict(description="The ID of the version group this slot is in"))
    encounter_method_id = Column(Integer, ForeignKey('encounter_methods.id'), primary_key=False, nullable=False, autoincrement=False,
        info=dict(description="The ID of the method"))
    slot = Column(Integer, nullable=True,
        info=dict(description="This slot's order for the location and method"))
    rarity = Column(Integer, nullable=True,
        info=dict(description="The chance of the encounter as a percentage"))

class EvolutionChain(TableBase):
    u"""A family of Pokémon that are linked by evolution
    """
    __tablename__ = 'evolution_chains'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    baby_trigger_item_id = Column(Integer, ForeignKey('items.id'), nullable=True,
        info=dict(description="Item that a parent must hold while breeding to produce a baby"))

class EvolutionTrigger(TableBase):
    u"""An evolution type, such as "level" or "trade".
    """
    __tablename__ = 'evolution_triggers'
    __singlename__ = 'evolution_trigger'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('evolution_trigger_prose', EvolutionTrigger, 'prose',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
)

class Experience(TableBase):
    u"""EXP needed for a certain level with a certain growth rate
    """
    __tablename__ = 'experience'
    growth_rate_id = Column(Integer, ForeignKey('growth_rates.id'), primary_key=True, nullable=False,
        info=dict(description="ID of the growth rate"))
    level = Column(Integer, primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="The level"))
    experience = Column(Integer, nullable=False,
        info=dict(description="The number of EXP points needed to get to that level"))

class Gender(TableBase):
    u"""A gender.
    """
    __tablename__ = 'genders'
    __singlename__ = 'gender'
    id = Column(Integer, primary_key=True, nullable=False, autoincrement=True,
        info=dict(description='An ID for this gender.'))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description='A readable identifier for this gender.', format='identifier'))

class Generation(TableBase):
    u"""A Generation of the Pokémon franchise
    """
    __tablename__ = 'generations'
    __singlename__ = 'generation'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    main_region_id = Column(Integer, ForeignKey('regions.id'), nullable=False,
        info=dict(description="ID of the region this generation's main games take place in"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u'An identifier', format='identifier'))

create_translation_table('generation_names', Generation, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class GrowthRate(TableBase):
    u"""Growth rate of a Pokémon, i.e. the EXP → level function.
    """
    __tablename__ = 'growth_rates'
    __singlename__ = 'growth_rate'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))
    formula = Column(UnicodeText, nullable=False,
        info=dict(description="The formula", format='latex'))

create_translation_table('growth_rate_prose', GrowthRate, 'prose',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
)

class Item(TableBase):
    u"""An Item from the games, like "Poké Ball" or "Bicycle".
    """
    __tablename__ = 'items'
    __singlename__ = 'item'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))
    category_id = Column(Integer, ForeignKey('item_categories.id'), nullable=False,
        info=dict(description="ID of a category this item belongs to"))
    cost = Column(Integer, nullable=False,
        info=dict(description=u"Cost of the item when bought. Items sell for half this price."))
    fling_power = Column(Integer, nullable=True,
        info=dict(description=u"Power of the move Fling when used with this item."))
    fling_effect_id = Column(Integer, ForeignKey('item_fling_effects.id'), nullable=True,
        info=dict(description=u"ID of the fling-effect of the move Fling when used with this item. Note that these are different from move effects."))

    @property
    def appears_underground(self):
        u"""True if the item appears underground, as specified by the appropriate flag
        """
        return any(flag.identifier == u'underground' for flag in self.flags)

create_translation_table('item_names', Item, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True, ripped=True)),
)
create_translation_table('item_prose', Item, 'prose',
    short_effect = Column(UnicodeText, nullable=True,
        info=dict(description="A short summary of the effect", format='markdown', string_getter=markdown.MarkdownString)),
    effect = Column(UnicodeText, nullable=True,
        info=dict(description=u"Detailed description of the item's effect.", format='markdown', string_getter=markdown.MarkdownString)),
)
create_translation_table('item_flavor_summaries', Item, 'flavor_summaries',
    flavor_summary = Column(UnicodeText, nullable=True,
        info=dict(description=u"Text containing facts from all flavor texts, for languages without official game translations", official=False, format='plaintext', ripped=True)),
)

class ItemCategory(TableBase):
    u"""An item category
    """
    # XXX: This is fanon, right?
    __tablename__ = 'item_categories'
    __singlename__ = 'item_category'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    pocket_id = Column(Integer, ForeignKey('item_pockets.id'), nullable=False,
        info=dict(description="ID of the pocket these items go to"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('item_category_prose', ItemCategory, 'prose',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
)

class ItemFlag(TableBase):
    u"""An item attribute such as "consumable" or "holdable".
    """
    __tablename__ = 'item_flags'
    __singlename__ = 'item_flag'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="Identifier of the flag", format='identifier'))

create_translation_table('item_flag_prose', ItemFlag, 'prose',
    name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
    description = Column(UnicodeText, nullable=True,
        info=dict(description="Short description of the flag", format='plaintext')),
)

class ItemFlagMap(TableBase):
    u"""Maps an item flag to its item.
    """
    __tablename__ = 'item_flag_map'
    item_id = Column(Integer, ForeignKey('items.id'), primary_key=True, autoincrement=False, nullable=False,
        info=dict(description="The ID of the item"))
    item_flag_id = Column(Integer, ForeignKey('item_flags.id'), primary_key=True, autoincrement=False, nullable=False,
        info=dict(description="The ID of the item flag"))

class ItemFlavorText(TableBase):
    u"""An in-game description of an item
    """
    __tablename__ = 'item_flavor_text'
    __singlename__ = 'item_flavor_text'
    summary_column = Item.flavor_summaries_table, 'flavor_summary'
    item_id = Column(Integer, ForeignKey('items.id'), primary_key=True, autoincrement=False, nullable=False,
        info=dict(description="The ID of the item"))
    version_group_id = Column(Integer, ForeignKey('version_groups.id'), primary_key=True, autoincrement=False, nullable=False,
        info=dict(description="ID of the version group that sports this text"))
    language_id = Column(Integer, ForeignKey('languages.id'), primary_key=True, nullable=False,
        info=dict(description="The language"))
    flavor_text = Column(UnicodeText, nullable=False,
        info=dict(description="The flavor text itself", official=True, format='gametext'))

class ItemFlingEffect(TableBase):
    u"""An effect of the move Fling when used with a specific item
    """
    __tablename__ = 'item_fling_effects'
    __singlename__ = 'item_fling_effect'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))

create_translation_table('item_fling_effect_prose', ItemFlingEffect, 'prose',
    effect = Column(UnicodeText, nullable=False,
        info=dict(description="Description of the effect", format='plaintext')),
)

class ItemGameIndex(TableBase):
    u"""The internal ID number a game uses for an item
    """
    __tablename__ = 'item_game_indices'
    item_id = Column(Integer, ForeignKey('items.id'), primary_key=True, autoincrement=False, nullable=False,
        info=dict(description="The database ID of the item"))
    generation_id = Column(Integer, ForeignKey('generations.id'), primary_key=True, autoincrement=False, nullable=False,
        info=dict(description="ID of the generation of games"))
    game_index = Column(Integer, nullable=False,
        info=dict(description="Internal ID of the item in the generation"))

class ItemPocket(TableBase):
    u"""A pocket that categorizes items
    """
    __tablename__ = 'item_pockets'
    __singlename__ = 'item_pocket'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier of this pocket", format='identifier'))

create_translation_table('item_pocket_names', ItemPocket, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class Location(TableBase):
    u"""A place in the Pokémon world
    """
    __tablename__ = 'locations'
    __singlename__ = 'location'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    region_id = Column(Integer, ForeignKey('regions.id'),
        info=dict(description="ID of the region this location is in"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('location_names', Location, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class LocationArea(TableBase):
    u"""A sub-area of a location
    """
    __tablename__ = 'location_areas'
    __singlename__ = 'location_area'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    location_id = Column(Integer, ForeignKey('locations.id'), nullable=False,
        info=dict(description="ID of the location this area is part of"))
    game_index = Column(Integer, nullable=False,
        info=dict(description="ID the games use for this area"))
    identifier = Column(Unicode(79), nullable=True,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('location_area_prose', LocationArea, 'prose',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
)

class LocationAreaEncounterRate(TableBase):
    # XXX: What's this exactly? Someone add the docstring & revise the descriptions
    __tablename__ = 'location_area_encounter_rates'
    location_area_id = Column(Integer, ForeignKey('location_areas.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="ID of the area"))
    encounter_method_id = Column(Integer, ForeignKey('encounter_methods.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="ID of the method"))
    version_id = Column(Integer, ForeignKey('versions.id'), primary_key=True, autoincrement=False,
        info=dict(description="ID of the version"))
    rate = Column(Integer, nullable=True,
        info=dict(description="The encounter rate"))  # units?

class LocationGameIndex(TableBase):
    u"""IDs the games use internally for locations
    """
    __tablename__ = 'location_game_indices'
    location_id = Column(Integer, ForeignKey('locations.id'), nullable=False, primary_key=True,
        info=dict(description="Database ID of the locaion"))
    generation_id = Column(Integer, ForeignKey('generations.id'), nullable=False, primary_key=True,
        info=dict(description="ID of the generation this entry to"))
    game_index = Column(Integer, nullable=False, primary_key=True, autoincrement=False,
        info=dict(description="Internal game ID of the location"))

class Machine(TableBase):
    u"""A TM or HM; numbered item that can teach a move to a Pokémon
    """
    __tablename__ = 'machines'
    machine_number = Column(Integer, primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="Number of the machine for TMs, or 100 + the number for HMs"))
    version_group_id = Column(Integer, ForeignKey('version_groups.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="Versions this entry applies to"))
    item_id = Column(Integer, ForeignKey('items.id'), nullable=False,
        info=dict(description="ID of the corresponding Item"))
    move_id = Column(Integer, ForeignKey('moves.id'), nullable=False,
        info=dict(description="ID of the taught move"))

    @property
    def is_hm(self):
        u"""True if this machine is a HM, False if it's a TM
        """
        return self.machine_number >= 100

class Move(TableBase):
    u"""A Move: technique or attack a Pokémon can learn to use
    """
    __tablename__ = 'moves'
    __singlename__ = 'move'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))
    generation_id = Column(Integer, ForeignKey('generations.id'), nullable=False,
        info=dict(description="ID of the generation this move first appeared in"))
    type_id = Column(Integer, ForeignKey('types.id'), nullable=False,
        info=dict(description="ID of the move's elemental type"))
    power = Column(SmallInteger, nullable=True,
        info=dict(description="Base power of the move, null if it does not have a set base power."))
    pp = Column(SmallInteger, nullable=True,
        info=dict(description="Base PP (Power Points) of the move, nullable if not applicable (e.g. Struggle and Shadow moves)."))
    accuracy = Column(SmallInteger, nullable=True,
        info=dict(description="Accuracy of the move; NULL means it never misses"))
    priority = Column(SmallInteger, nullable=False,
        info=dict(description="The move's priority bracket"))
    target_id = Column(Integer, ForeignKey('move_targets.id'), nullable=False,
        info=dict(description="ID of the target (range) of the move"))
    damage_class_id = Column(Integer, ForeignKey('move_damage_classes.id'), nullable=False,
        info=dict(description="ID of the damage class (physical/special) of the move"))
    effect_id = Column(Integer, ForeignKey('move_effects.id'), nullable=False,
        info=dict(description="ID of the move's effect"))
    effect_chance = Column(Integer, nullable=True,
        info=dict(description="The chance for a secondary effect. What this is a chance of is specified by the move's effect."))
    contest_type_id = Column(Integer, ForeignKey('contest_types.id'), nullable=True,
        info=dict(description="ID of the move's Contest type (e.g. cool or smart)"))
    contest_effect_id = Column(Integer, ForeignKey('contest_effects.id'), nullable=True,
        info=dict(description="ID of the move's Contest effect"))
    super_contest_effect_id = Column(Integer, ForeignKey('super_contest_effects.id'), nullable=True,
        info=dict(description="ID of the move's Super Contest effect"))

create_translation_table('move_names', Move, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True, ripped=True))
)
create_translation_table('move_flavor_summaries', Move, 'flavor_summaries',
    flavor_summary = Column(UnicodeText, nullable=True,
        info=dict(description=u"Text containing facts from all flavor texts, for languages without official game translations", official=False, format='plaintext', ripped=True)),
)

class MoveBattleStyle(TableBase):
    u"""A battle style of a move"""  # XXX: Explain better
    __tablename__ = 'move_battle_styles'
    __singlename__ = 'move_battle_style'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('move_battle_style_prose', MoveBattleStyle, 'prose',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
)

class MoveChangelog(TableBase):
    """History of changes to moves across main game versions."""
    __tablename__ = 'move_changelog'
    __singlename__ = 'move_changelog'
    move_id = Column(Integer, ForeignKey('moves.id'), primary_key=True, nullable=False,
        info=dict(description="ID of the move that changed"))
    changed_in_version_group_id = Column(Integer, ForeignKey('version_groups.id'), primary_key=True, nullable=False,
        info=dict(description="ID of the version group in which the move changed"))
    type_id = Column(Integer, ForeignKey('types.id'), nullable=True,
        info=dict(description="Prior type of the move, or NULL if unchanged"))
    power = Column(SmallInteger, nullable=True,
        info=dict(description="Prior base power of the move, or NULL if unchanged"))
    pp = Column(SmallInteger, nullable=True,
        info=dict(description="Prior base PP of the move, or NULL if unchanged"))
    accuracy = Column(SmallInteger, nullable=True,
        info=dict(description="Prior accuracy of the move, or NULL if unchanged"))
    effect_id = Column(Integer, ForeignKey('move_effects.id'), nullable=True,
        info=dict(description="Prior ID of the effect, or NULL if unchanged"))
    effect_chance = Column(Integer, nullable=True,
        info=dict(description="Prior effect chance, or NULL if unchanged"))

class MoveDamageClass(TableBase):
    u"""Any of the damage classes moves can have, i.e. physical, special, or non-damaging.
    """
    __tablename__ = 'move_damage_classes'
    __singlename__ = 'move_damage_class'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('move_damage_class_prose', MoveDamageClass, 'prose',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
    description = Column(UnicodeText, nullable=True,
        info=dict(description="A description of the class", format='plaintext')),
)

class MoveEffect(TableBase):
    u"""An effect of a move
    """
    __tablename__ = 'move_effects'
    __singlename__ = 'move_effect'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))

create_translation_table('move_effect_prose', MoveEffect, 'prose',
    short_effect = Column(UnicodeText, nullable=True,
        info=dict(description="A short summary of the effect", format='markdown')),
    effect = Column(UnicodeText, nullable=True,
        info=dict(description="A detailed description of the effect", format='markdown')),
)

class MoveEffectChangelog(TableBase):
    """History of changes to move effects across main game versions."""
    __tablename__ = 'move_effect_changelog'
    __singlename__ = 'move_effect_changelog'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    effect_id = Column(Integer, ForeignKey('move_effects.id'), nullable=False,
        info=dict(description="The ID of the effect that changed"))
    changed_in_version_group_id = Column(Integer, ForeignKey('version_groups.id'), nullable=False,
        info=dict(description="The ID of the version group in which the effect changed"))

    __table_args__ = (
        UniqueConstraint(effect_id, changed_in_version_group_id),
        {},
    )

create_translation_table('move_effect_changelog_prose', MoveEffectChangelog, 'prose',
    effect = Column(UnicodeText, nullable=False,
        info=dict(description="A description of the old behavior", format='markdown', string_getter=markdown.MarkdownString)),
)

class MoveFlag(TableBase):
    u"""A Move attribute such as "snatchable" or "contact".
    """
    __tablename__ = 'move_flags'
    __singlename__ = 'move_flag'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="A short identifier for the flag", format='identifier'))

class MoveFlagMap(TableBase):
    u"""Maps a move flag to a move
    """
    __tablename__ = 'move_flag_map'
    move_id = Column(Integer, ForeignKey('moves.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="ID of the move"))
    move_flag_id = Column(Integer, ForeignKey('move_flags.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="ID of the flag"))

create_translation_table('move_flag_prose', MoveFlag, 'prose',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
    description = Column(UnicodeText, nullable=True,
        info=dict(description="A short description of the flag", format='markdown', string_getter=markdown.MarkdownString)),
)

class MoveFlavorText(TableBase):
    u"""In-game description of a move
    """
    __tablename__ = 'move_flavor_text'
    summary_column = Move.flavor_summaries_table, 'flavor_summary'
    move_id = Column(Integer, ForeignKey('moves.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="ID of the move"))
    version_group_id = Column(Integer, ForeignKey('version_groups.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="ID of the version group this text appears in"))
    language_id = Column(Integer, ForeignKey('languages.id'), primary_key=True, nullable=False,
        info=dict(description="The language"))
    flavor_text = Column(UnicodeText, nullable=False,
        info=dict(description="The flavor text", official=True, format='gametext'))

class MoveMeta(TableBase):
    u"""Metadata for move effects, sorta-kinda ripped straight from the game"""
    __tablename__ = 'move_meta'
    move_id = Column(Integer, ForeignKey('moves.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="A numeric ID"))
    meta_category_id = Column(Integer, ForeignKey('move_meta_categories.id'), nullable=False,
        info=dict(description="ID of the move category"))
    meta_ailment_id = Column(Integer, ForeignKey('move_meta_ailments.id'), nullable=False,
        info=dict(description="ID of the caused ailment"))
    min_hits = Column(Integer, nullable=True, index=True,
        info=dict(description="Minimum number of hits per use"))
    max_hits = Column(Integer, nullable=True, index=True,
        info=dict(description="Maximum number of hits per use"))
    min_turns = Column(Integer, nullable=True, index=True,
        info=dict(description="Minimum number of turns the user is forced to use the move"))
    max_turns = Column(Integer, nullable=True, index=True,
        info=dict(description="Maximum number of turns the user is forced to use the move"))
    recoil = Column(Integer, nullable=False, index=True,
        info=dict(description="Recoil damage, in percent of damage done"))
    healing = Column(Integer, nullable=False, index=True,
        info=dict(description="Healing, in percent of user's max HP"))
    crit_rate = Column(Integer, nullable=False, index=True,
        info=dict(description="Critical hit rate bonus"))
    ailment_chance = Column(Integer, nullable=False, index=True,
        info=dict(description="Chance to cause an ailment, in percent"))
    flinch_chance = Column(Integer, nullable=False, index=True,
        info=dict(description="Chance to cause flinching, in percent"))
    stat_chance = Column(Integer, nullable=False, index=True,
        info=dict(description="Chance to cause a stat change, in percent"))

class MoveMetaAilment(TableBase):
    u"""Common status ailments moves can inflict on a single Pokémon, including
    major ailments like paralysis and minor ailments like trapping.
    """
    __tablename__ = 'move_meta_ailments'
    __singlename__ = 'move_meta_ailment'
    id = Column(Integer, primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False, index=True, unique=True,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('move_meta_ailment_names', MoveMetaAilment, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class MoveMetaCategory(TableBase):
    u"""Very general categories that loosely group move effects."""
    __tablename__ = 'move_meta_categories'
    __singlename__ = 'move_meta_category'
    id = Column(Integer, primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False, index=True, unique=True,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('move_meta_category_prose', MoveMetaCategory, 'prose',
    relation_lazy='joined',
    description = Column(UnicodeText, nullable=False,
        info=dict(description="A description of the category", format="plaintext", official=False)),
)

class MoveMetaStatChange(TableBase):
    u"""Stat changes moves (may) make."""
    __tablename__ = 'move_meta_stat_changes'
    move_id = Column(Integer, ForeignKey('moves.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="ID of the move"))
    stat_id = Column(Integer, ForeignKey('stats.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description="ID of the stat"))
    change = Column(Integer, nullable=False, index=True,
        info=dict(description="Amount of increase/decrease, in stages"))

class MoveTarget(TableBase):
    u"""Targetting or "range" of a move, e.g. "Affects all opponents" or "Affects user".
    """
    __tablename__ = 'move_targets'
    __singlename__ = 'move_target'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('move_target_prose', MoveTarget, 'prose',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
    description = Column(UnicodeText, nullable=True,
        info=dict(description="A description", format='plaintext')),
)

class Nature(TableBase):
    u"""A nature a Pokémon can have, such as Calm or Brave
    """
    __tablename__ = 'natures'
    __singlename__ = 'nature'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))
    decreased_stat_id = Column(Integer, ForeignKey('stats.id'), nullable=False,
        info=dict(description="ID of the stat that this nature decreases by 10% (if decreased_stat_id is the same, the effects cancel out)"))
    increased_stat_id = Column(Integer, ForeignKey('stats.id'), nullable=False,
        info=dict(description="ID of the stat that this nature increases by 10% (if decreased_stat_id is the same, the effects cancel out)"))
    hates_flavor_id = Column(Integer, ForeignKey('contest_types.id'), nullable=False,
        info=dict(description=u"ID of the Berry flavor the Pokémon hates (if likes_flavor_id is the same, the effects cancel out)"))
    likes_flavor_id = Column(Integer, ForeignKey('contest_types.id'), nullable=False,
        info=dict(description=u"ID of the Berry flavor the Pokémon likes (if hates_flavor_id is the same, the effects cancel out)"))

    @property
    def is_neutral(self):
        u"""Returns True iff this nature doesn't alter a Pokémon's stats,
        bestow taste preferences, etc.
        """
        return self.increased_stat_id == self.decreased_stat_id

create_translation_table('nature_names', Nature, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True, ripped=True)),
)

class NatureBattleStylePreference(TableBase):
    u"""Battle Palace move preference

    Specifies how likely a Pokémon with a specific Nature is to use a move of
    a particular battl style in Battle Palace or Battle Tent
    """
    __tablename__ = 'nature_battle_style_preferences'
    nature_id = Column(Integer, ForeignKey('natures.id'), primary_key=True, nullable=False,
        info=dict(description=u"ID of the Pokémon's nature"))
    move_battle_style_id = Column(Integer, ForeignKey('move_battle_styles.id'), primary_key=True, nullable=False,
        info=dict(description="ID of the battle style"))
    low_hp_preference = Column(Integer, nullable=False,
        info=dict(description=u"Chance of using the move, in percent, if HP is under ½"))
    high_hp_preference = Column(Integer, nullable=False,
        info=dict(description=u"Chance of using the move, in percent, if HP is over ½"))

class NaturePokeathlonStat(TableBase):
    u"""Specifies how a Nature affects a Pokéathlon stat
    """
    __tablename__ = 'nature_pokeathlon_stats'
    nature_id = Column(Integer, ForeignKey('natures.id'), primary_key=True, nullable=False,
        info=dict(description="ID of the nature"))
    pokeathlon_stat_id = Column(Integer, ForeignKey('pokeathlon_stats.id'), primary_key=True, nullable=False,
        info=dict(description="ID of the stat"))
    max_change = Column(Integer, nullable=False,
        info=dict(description="Maximum change"))

class PalPark(TableBase):
    u"""Data for the Pal Park mini-game in Generation IV
    """

    __tablename__ = 'pal_park'
    __singlename__ = 'pal_park'

    species_id = Column(Integer, ForeignKey('pokemon_species.id'), primary_key=True,
        info=dict(description="The Pokémon species this data pertains to"))

    area_id = Column(Integer, ForeignKey('pal_park_areas.id'), nullable=False,
        info=dict(description="The area in which this Pokémon is found"))
    base_score = Column(Integer, nullable=False,
        info=dict(description="Used in calculating the player's score at the end of a Pal Park run"))
    rate = Column(Integer, nullable=False,
        info=dict(description="Base rate for encountering this Pokémon"))

class PalParkArea(TableBase):
    u"""A distinct area of Pal Park in which Pokémon appear.
    """
    __tablename__ = 'pal_park_areas'
    __singlename__ = 'pal_park_area'

    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('pal_park_area_names', PalParkArea, 'names',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
)

class PokeathlonStat(TableBase):
    u"""A Pokéathlon stat, such as "Stamina" or "Jump".
    """
    __tablename__ = 'pokeathlon_stats'
    __singlename__ = 'pokeathlon_stat'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description="An identifier", format='identifier'))

create_translation_table('pokeathlon_stat_names', PokeathlonStat, 'names',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class Pokedex(TableBase):
    u"""A collection of Pokémon species ordered in a particular way
    """
    __tablename__ = 'pokedexes'
    __singlename__ = 'pokedex'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description="A numeric ID"))
    region_id = Column(Integer, ForeignKey('regions.id'), nullable=True,
        info=dict(description=u"ID of the region this Pokédex is used in, or None if it's global"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u"An identifier", format='identifier'))
    is_main_series = Column(Boolean, nullable=False,
        info=dict(description=u'True if this Pokédex appears in the main series.'))

create_translation_table('pokedex_prose', Pokedex, 'prose',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
    description = Column(UnicodeText, nullable=True,
        info=dict(description=u"A longer description of the Pokédex", format='plaintext')),
)

class PokedexVersionGroup(TableBase):
    u"""A mapping from Pokédexes to version groups in which they appear as the
    regional dex.
    """
    __tablename__ = 'pokedex_version_groups'
    __singlename__ = 'pokedex_version_group'
    pokedex_id = Column(Integer, ForeignKey('pokedexes.id'), primary_key=True,
        info=dict(description=u'The ID of the Pokédex.'))
    version_group_id = Column(Integer, ForeignKey('version_groups.id'), primary_key=True,
        info=dict(description=u'The ID of the version group.'))

class Pokemon(TableBase):
    u"""A Pokémon.  The core to this whole mess.

    This table defines "Pokémon" the same way the games do: a form with
    different types, moves, or other game-changing properties counts as a
    different Pokémon.  For example, this table contains four rows for Deoxys,
    but only one for Unown.
    """
    __tablename__ = 'pokemon'
    __singlename__ = 'pokemon'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u"A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u'An identifier, including form iff this row corresponds to a single, named form', format='identifier'))
    species_id = Column(Integer, ForeignKey('pokemon_species.id'),
        info=dict(description=u"ID of the species this Pokémon belongs to"))
    height = Column(Integer, nullable=False,
        info=dict(description=u"The height of the Pokémon, in decimeters (tenths of a meter)"))
    weight = Column(Integer, nullable=False,
        info=dict(description=u"The weight of the Pokémon, in tenths of a kilogram (decigrams)"))
    base_experience = Column(Integer, nullable=False,
        info=dict(description=u"The base EXP gained when defeating this Pokémon"))  # XXX: Is this correct?
    order = Column(Integer, nullable=False, index=True,
        info=dict(description=u"Order for sorting. Almost national order, except families are grouped together."))
    is_default = Column(Boolean, nullable=False, index=True,
        info=dict(description=u'Set for exactly one pokemon used as the default for each species.'))

    @property
    def name(self):
        u"""Returns a name for this Pokémon, specifiying the form iff it
        represents a specific PokemonForm.
        """
        if any(not form.is_default for form in self.forms):
            return self.species.name
        else:
            return self.default_form.pokemon_name or self.species.name

    def stat(self, stat_identifier):
        u"""Returns a PokemonStat record for the given stat name (or Stat row
        object).  Uses the normal has-many machinery, so all the stats are
        effectively cached.
        """
        if isinstance(stat_identifier, Stat):
            stat_identifier = stat_identifier.identifier

        for pokemon_stat in self.stats:
            if pokemon_stat.stat.identifier == stat_identifier:
                return pokemon_stat

        raise KeyError(u'No stat named %s' % stat_identifier)

    def base_stat(self, stat_identifier, default=0):
        u"""Return this Pokemon's base stat value for the given stat identifier,
        or default if missing."""

        if isinstance(stat_identifier, Stat):
            stat_identifier = stat_identifier.identifier

        for pokemon_stat in self.stats:
            if pokemon_stat.stat.identifier == stat_identifier:
                return pokemon_stat.base_stat

        return default

    @property
    def better_damage_class(self):
        u"""Returns the MoveDamageClass that this Pokémon is best suited for,
        based on its attack stats.

        If the attack stats are about equal (within 5), returns None.  The
        value None, not the damage class called 'None'.
        """

        try:
            phys = self.stat(u'attack')
            spec = self.stat(u'special-attack')
        except KeyError:
            return None

        diff = phys.base_stat - spec.base_stat

        if diff > 5:
            return phys.stat.damage_class
        elif diff < -5:
            return spec.stat.damage_class
        else:
            return None

class PokemonAbility(TableBase):
    u"""Maps an ability to a Pokémon that can have it
    """
    __tablename__ = 'pokemon_abilities'
    pokemon_id = Column(Integer, ForeignKey('pokemon.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the Pokémon"))
    ability_id = Column(Integer, ForeignKey('abilities.id'), nullable=False,
        info=dict(description=u"ID of the ability"))
    # XXX having both a method and a slot is kind of gross.  "slot" is a
    # misnomer, anyway: duplicate abilities don't appear in slot 2.
    # Probably should replace that with "order".
    is_hidden = Column(Boolean, nullable=False, index=True,
        info=dict(description=u"Whether this is a hidden ability"))
    slot = Column(Integer, primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"The ability slot, i.e. 1 or 2 for gen. IV"))

class PokemonColor(TableBase):
    u"""The "Pokédex color" of a Pokémon species. Usually based on the Pokémon's color.
    """
    __tablename__ = 'pokemon_colors'
    __singlename__ = 'pokemon_color'
    id = Column(Integer, primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the Pokémon"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u"An identifier", format='identifier'))

create_translation_table('pokemon_color_names', PokemonColor, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class PokemonDexNumber(TableBase):
    u"""The number of a species in a particular Pokédex (e.g. Jigglypuff is #138 in Hoenn's 'dex)
    """
    __tablename__ = 'pokemon_dex_numbers'
    species_id = Column(Integer, ForeignKey('pokemon_species.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the species"))
    pokedex_id = Column(Integer, ForeignKey('pokedexes.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the Pokédex"))
    pokedex_number = Column(Integer, nullable=False,
        info=dict(description=u"Number of the Pokémon in that the Pokédex"))

class PokemonEggGroup(TableBase):
    u"""Maps an Egg group to a species; each species belongs to one or two egg groups
    """
    __tablename__ = 'pokemon_egg_groups'
    species_id = Column(Integer, ForeignKey('pokemon_species.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the species"))
    egg_group_id = Column(Integer, ForeignKey('egg_groups.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the egg group"))

class PokemonEvolution(TableBase):
    u"""A required action ("trigger") and the conditions under which the trigger
    must occur to cause a Pokémon to evolve.

    Any condition may be null if it does not apply for a particular Pokémon.
    """
    __tablename__ = 'pokemon_evolution'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u"A numeric ID"))
    evolved_species_id = Column(Integer, ForeignKey('pokemon_species.id'), nullable=False,
        info=dict(description=u"The ID of the post-evolution species."))
    evolution_trigger_id = Column(Integer, ForeignKey('evolution_triggers.id'), nullable=False,
        info=dict(description=u"The ID of the evolution trigger."))
    trigger_item_id = Column(Integer, ForeignKey('items.id'), nullable=True,
        info=dict(description=u"The ID of the item that must be used on the Pokémon."))
    minimum_level = Column(Integer, nullable=True,
        info=dict(description=u"The minimum level for the Pokémon."))
    gender_id = Column(Integer, ForeignKey('genders.id'), nullable=True,
        info=dict(description=u"The ID of the Pokémon's required gender, or None if gender doesn't matter"))
    location_id = Column(Integer, ForeignKey('locations.id'), nullable=True,
        info=dict(description=u"The ID of the location the evolution must be triggered at."))
    held_item_id = Column(Integer, ForeignKey('items.id'), nullable=True,
        info=dict(description=u"The ID of the item the Pokémon must hold."))
    time_of_day = Column(Enum('day', 'night', name='pokemon_evolution_time_of_day'), nullable=True,
        info=dict(description=u"The required time of day."))
    known_move_id = Column(Integer, ForeignKey('moves.id'), nullable=True,
        info=dict(description=u"The ID of the move the Pokémon must know."))
    known_move_type_id = Column(Integer, ForeignKey('types.id'), nullable=True,
        info=dict(description=u'The ID of the type the Pokémon must know a move of.'))
    minimum_happiness = Column(Integer, nullable=True,
        info=dict(description=u"The minimum happiness value the Pokémon must have."))
    minimum_beauty = Column(Integer, nullable=True,
        info=dict(description=u"The minimum Beauty value the Pokémon must have."))
    minimum_affection = Column(Integer, nullable=True,
        info=dict(description=u'The minimum number of "affection" hearts the Pokémon must have in Pokémon-Amie.'))
    relative_physical_stats = Column(Integer, nullable=True,
        info=dict(description=u"The required relation between the Pokémon's Attack and Defense stats, as sgn(atk-def)."))
    party_species_id = Column(Integer, ForeignKey('pokemon_species.id'), nullable=True,
        info=dict(description=u"The ID of the species that must be present in the party."))
    party_type_id = Column(Integer, ForeignKey('types.id'), nullable=True,
        info=dict(description=u'The ID of a type that at least one party member must have.'))
    trade_species_id = Column(Integer, ForeignKey('pokemon_species.id'), nullable=True,
        info=dict(description=u"The ID of the species for which this one must be traded."))
    needs_overworld_rain = Column(Boolean, nullable=False,
        info=dict(description=u'True iff it needs to be raining outside of battle.'))
    turn_upside_down = Column(Boolean, nullable=False,
        info=dict(description=u'True iff the 3DS needs to be turned upside-down as this Pokémon levels up.'))

class PokemonForm(TableBase):
    u"""An individual form of a Pokémon.  This includes *every* variant (except
    color differences) of every Pokémon, regardless of how the games treat
    them.  Even Pokémon with no alternate forms have one row in this table, to
    represent their lone "normal" form.
    """
    __tablename__ = 'pokemon_forms'
    __singlename__ = 'pokemon_form'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u'A unique ID for this form.'))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u"A unique identifier for this form among all forms of all Pokémon", format='identifier'))
    form_identifier = Column(Unicode(79), nullable=True,
        info=dict(description=u"An identifier of the form, uniue among a species. May be None for the default form of the species.", format='identifier'))
    pokemon_id = Column(Integer, ForeignKey('pokemon.id'), nullable=False, autoincrement=False,
        info=dict(description=u'The ID of the base Pokémon for this form.'))
    introduced_in_version_group_id = Column(Integer, ForeignKey('version_groups.id'), autoincrement=False,
        info=dict(description=u'The ID of the version group in which this form first appeared.'))
    is_default = Column(Boolean, nullable=False,
        info=dict(description=u'Set for exactly one form used as the default for each pokemon (not necessarily species).'))
    is_battle_only = Column(Boolean, nullable=False,
        info=dict(description=u'Set iff the form can only appear in battle.'))
    is_mega = Column(Boolean, nullable=False,
        info=dict(description=u'Records whether this form is a Mega Evolution.'))
    form_order = Column(Integer, nullable=False, autoincrement=False,
        info=dict(description=u"The order in which forms should be sorted within a species' forms.  Multiple forms may have equal order, in which case they should fall back on sorting by name.  "
                              u"Used in generating `pokemon_forms.order` and `pokemon.order`."))
    order = Column(Integer, nullable=False, autoincrement=False,
        info=dict(description=u'The order in which forms should be sorted within all forms.  Multiple forms may have equal order, in which case they should fall back on sorting by name.'))

    @property
    def name(self):
        """Name of this form: the form_name, if set; otherwise the species name"""
        return self.pokemon_name or self.species.name

create_translation_table('pokemon_form_names', PokemonForm, 'names',
    relation_lazy='joined',
    form_name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description=u"The full form name, e.g. 'Sky Forme', for pokémon with different forms", format='plaintext', official=True)),
    pokemon_name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description=u"The full pokémon name, e.g. 'Sky Shaymin', for pokémon with different forms", format='plaintext', official=True)),
)

class PokemonFormGeneration(TableBase):
    u"""Links Pokémon forms to the generations they exist in"""
    __tablename__ = 'pokemon_form_generations'
    pokemon_form_id = Column(Integer, ForeignKey('pokemon_forms.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u'The ID of the Pokémon form.'))
    generation_id = Column(Integer, ForeignKey('generations.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u'The ID of the generation.'))
    game_index = Column(Integer, nullable=False,
        info=dict(description=u'The internal ID the games use for this form.'))

class PokemonFormPokeathlonStat(TableBase):
    u"""A Pokémon form's performance in one Pokéathlon stat."""
    __tablename__ = 'pokemon_form_pokeathlon_stats'
    pokemon_form_id = Column(Integer, ForeignKey('pokemon_forms.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u'The ID of the Pokémon form.'))
    pokeathlon_stat_id = Column(Integer, ForeignKey('pokeathlon_stats.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u'The ID of the Pokéathlon stat.'))
    minimum_stat = Column(Integer, nullable=False, autoincrement=False,
        info=dict(description=u'The minimum value for this stat for this Pokémon form.'))
    base_stat = Column(Integer, nullable=False, autoincrement=False,
        info=dict(description=u'The default value for this stat for this Pokémon form.'))
    maximum_stat = Column(Integer, nullable=False, autoincrement=False,
        info=dict(description=u'The maximum value for this stat for this Pokémon form.'))

class PokemonGameIndex(TableBase):
    u"""The number of a Pokémon a game uses internally
    """
    __tablename__ = 'pokemon_game_indices'
    pokemon_id = Column(Integer, ForeignKey('pokemon.id'), primary_key=True, autoincrement=False, nullable=False,
        info=dict(description=u"Database ID of the Pokémon"))
    version_id = Column(Integer, ForeignKey('versions.id'), primary_key=True, autoincrement=False, nullable=False,
        info=dict(description=u"Database ID of the version"))
    game_index = Column(Integer, nullable=False,
        info=dict(description=u"Internal ID the version's games use for the Pokémon"))

class PokemonHabitat(TableBase):
    u"""The habitat of a Pokémon, as given in the FireRed/LeafGreen version Pokédex
    """
    __tablename__ = 'pokemon_habitats'
    __singlename__ = 'pokemon_habitat'
    id = Column(Integer, primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u"An identifier", format='identifier'))

create_translation_table('pokemon_habitat_names', PokemonHabitat, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class PokemonItem(TableBase):
    u"""Record of an item a Pokémon can hold in the wild
    """
    __tablename__ = 'pokemon_items'
    pokemon_id = Column(Integer, ForeignKey('pokemon.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the Pokémon"))
    version_id = Column(Integer, ForeignKey('versions.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the version this applies to"))
    item_id = Column(Integer, ForeignKey('items.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the item"))
    rarity = Column(Integer, nullable=False,
        info=dict(description=u"Chance of the Pokémon holding the item, in percent"))

class PokemonMove(TableBase):
    u"""Record of a move a Pokémon can learn
    """
    __tablename__ = 'pokemon_moves'
    pokemon_id = Column(Integer, ForeignKey('pokemon.id'), nullable=False, index=True,
        info=dict(description=u"ID of the Pokémon"))
    version_group_id = Column(Integer, ForeignKey('version_groups.id'), nullable=False, index=True,
        info=dict(description=u"ID of the version group this applies to"))
    move_id = Column(Integer, ForeignKey('moves.id'), nullable=False, index=True,
        info=dict(description=u"ID of the move"))
    pokemon_move_method_id = Column(Integer, ForeignKey('pokemon_move_methods.id'), nullable=False, index=True,
        info=dict(description=u"ID of the method this move is learned by"))
    level = Column(Integer, nullable=True, index=True, autoincrement=False,
        info=dict(description=u"Level the move is learned at, if applicable"))
    order = Column(Integer, nullable=True,
        info=dict(description=u"A sort key to produce the correct ordering when all else is equal"))  # XXX: This needs a better description

    __table_args__ = (
        PrimaryKeyConstraint('pokemon_id', 'version_group_id', 'move_id', 'pokemon_move_method_id', 'level'),
        {},
    )

class PokemonMoveMethod(TableBase):
    u"""A method a move can be learned by, such as "Level up" or "Tutor".
    """
    __tablename__ = 'pokemon_move_methods'
    __singlename__ = 'pokemon_move_method'
    id = Column(Integer, primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u"An identifier", format='identifier'))

create_translation_table('pokemon_move_method_prose', PokemonMoveMethod, 'prose',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
    description = Column(UnicodeText, nullable=True,
        info=dict(description=u"A detailed description of how the method works", format='plaintext')),
)

class PokemonShape(TableBase):
    u"""The shape of a Pokémon's body.  Used for flavor in generation IV and V
    Pokédexes.
    """
    __tablename__ = 'pokemon_shapes'
    __singlename__ = 'pokemon_shape'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u"A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u"An identifier", format='identifier'))

create_translation_table('pokemon_shape_prose', PokemonShape, 'prose',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description="The name", format='plaintext', official=False)),
    awesome_name = Column(Unicode(79), nullable=True,
        info=dict(description=u"A splendiferous name of the body shape", format='plaintext')),
)

class PokemonSpecies(TableBase):
    u"""A Pokémon species: the standard 1–151.  Or 649.  Whatever.
    """
    __tablename__ = 'pokemon_species'
    __singlename__ = 'pokemon_species'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u"A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u"An identifier", format='identifier'))
    generation_id = Column(Integer, ForeignKey('generations.id'),
        info=dict(description=u"ID of the generation this species first appeared in"))
    evolves_from_species_id = Column(Integer, ForeignKey('pokemon_species.id'), nullable=True,
        info=dict(description=u"The species from which this one evolves"))
    evolution_chain_id = Column(Integer, ForeignKey('evolution_chains.id'),
        info=dict(description=u"ID of the species' evolution chain (a.k.a. family)"))
    color_id = Column(Integer, ForeignKey('pokemon_colors.id'), nullable=False,
        info=dict(description=u"ID of this Pokémon's Pokédex color, as used for a gimmick search function in the games."))
    shape_id = Column(Integer, ForeignKey('pokemon_shapes.id'), nullable=False,
        info=dict(description=u"ID of this Pokémon's body shape, as used for a gimmick search function in the games."))
    habitat_id = Column(Integer, ForeignKey('pokemon_habitats.id'), nullable=True,
        info=dict(description=u"ID of this Pokémon's habitat, as used for a gimmick search function in the games."))
    gender_rate = Column(Integer, nullable=False,
        info=dict(description=u"The chance of this Pokémon being female, in eighths; or -1 for genderless"))
    capture_rate = Column(Integer, nullable=False,
        info=dict(description=u"The base capture rate; up to 255"))
    base_happiness = Column(Integer, nullable=False,
        info=dict(description=u"The tameness when caught by a normal ball"))
    is_baby = Column(Boolean, nullable=False,
        info=dict(description=u"True iff the Pokémon is a baby, i.e. a lowest-stage Pokémon that cannot breed but whose evolved form can."))
    hatch_counter = Column(Integer, nullable=False,
        info=dict(description=u"Initial hatch counter: one must walk 255 × (hatch_counter + 1) steps before this Pokémon's egg hatches, unless utilizing bonuses like Flame Body's"))
    has_gender_differences = Column(Boolean, nullable=False,
        info=dict(description=u"Set iff the species exhibits enough sexual dimorphism to have separate sets of sprites in Gen IV and beyond."))
    growth_rate_id = Column(Integer, ForeignKey('growth_rates.id'), nullable=False,
        info=dict(description="ID of the growth rate for this family"))
    forms_switchable = Column(Boolean, nullable=False,
        info=dict(description=u"True iff a particular individual of this species can switch beween its different forms."))
    order = Column(Integer, nullable=False, index=True,
        info=dict(description=u'The order in which species should be sorted.  Based on National Dex order, except families are grouped together and sorted by stage.'))
    conquest_order = Column(Integer, nullable=True, index=True,
        info=dict(description=u'The order in which species should be sorted for Pokémon Conquest-related tables.  Matches gallery order.'))

create_translation_table('pokemon_species_names', PokemonSpecies, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=True, index=True,
        info=dict(description="The name", format='plaintext', official=True, ripped=True)),
    genus = Column(UnicodeText, nullable=True,
        info=dict(description=u'The short flavor text, such as "Seed" or "Lizard"; usually affixed with the word "Pokémon"',
        official=True, format='plaintext')),
)
create_translation_table('pokemon_species_flavor_summaries', PokemonSpecies, 'flavor_summaries',
    flavor_summary = Column(UnicodeText, nullable=True,
        info=dict(description=u"Text containing facts from all flavor texts, for languages without official game translations", official=False, format='plaintext', ripped=True)),
)
create_translation_table('pokemon_species_prose', PokemonSpecies, 'prose',
    form_description = Column(UnicodeText, nullable=True,
        info=dict(description=u"Description of how the forms work", format='markdown', string_getter=markdown.MarkdownString)),
)

class PokemonSpeciesFlavorText(TableBase):
    u"""In-game Pokédex descrption of a Pokémon.
    """
    __tablename__ = 'pokemon_species_flavor_text'
    summary_column = PokemonSpecies.flavor_summaries_table, 'flavor_summary'
    species_id = Column(Integer, ForeignKey('pokemon_species.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the Pokémon"))
    version_id = Column(Integer, ForeignKey('versions.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the version that has this flavor text"))
    language_id = Column(Integer, ForeignKey('languages.id'), primary_key=True, nullable=False,
        info=dict(description="The language"))
    flavor_text = Column(UnicodeText, nullable=False,
        info=dict(description=u"The flavor text", official=True, format='gametext'))

class PokemonStat(TableBase):
    u"""A stat value of a Pokémon
    """
    __tablename__ = 'pokemon_stats'
    pokemon_id = Column(Integer, ForeignKey('pokemon.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the Pokémon"))
    stat_id = Column(Integer, ForeignKey('stats.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the stat"))
    base_stat = Column(Integer, nullable=False,
        info=dict(description=u"The base stat"))
    effort = Column(Integer, nullable=False,
        info=dict(description=u"The effort increase in this stat gained when this Pokémon is defeated"))

class PokemonType(TableBase):
    u"""Maps a type to a Pokémon. Each Pokémon has 1 or 2 types.
    """
    __tablename__ = 'pokemon_types'
    pokemon_id = Column(Integer, ForeignKey('pokemon.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"ID of the Pokémon"))
    type_id = Column(Integer, ForeignKey('types.id'), nullable=False,
        info=dict(description=u"ID of the type"))
    slot = Column(Integer, primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"The type's slot, 1 or 2, used to sort types if there are two of them"))

class Region(TableBase):
    u"""Major areas of the world: Kanto, Johto, etc.
    """
    __tablename__ = 'regions'
    __singlename__ = 'region'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u"A numeric ID"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u"An identifier", format='identifier'))

create_translation_table('region_names', Region, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class Stat(TableBase):
    u"""A Stat, such as Attack or Speed
    """
    __tablename__ = 'stats'
    __singlename__ = 'stat'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u"A numeric ID"))
    damage_class_id = Column(Integer, ForeignKey('move_damage_classes.id'), nullable=True,
        info=dict(description=u"For offensive and defensive stats, the damage this stat relates to; otherwise None (the NULL value)"))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u"An identifier", format='identifier'))
    is_battle_only = Column(Boolean, nullable=False,
        info=dict(description=u"Whether this stat only exists within a battle"))
    game_index = Column(Integer, nullable=True,
        info=dict(description=u"The stat order the games use internally for the persistent stats.  NULL for battle-only stats."))

create_translation_table('stat_names', Stat, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class StatHint(TableBase):
    u"""Flavor text for genes that appears in a Pokémon's summary.  Sometimes
    called "characteristics".
    """
    __tablename__ = 'stat_hints'
    __singlename__ = 'stat_hint'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u"A numeric ID"))
    stat_id = Column(Integer, ForeignKey('stats.id'), nullable=False,
        info=dict(description=u"ID of the highest stat"))
    gene_mod_5 = Column(Integer, nullable=False, index=True,
        info=dict(description=u"Value of the highest stat modulo 5"))

create_translation_table('stat_hint_names', StatHint, 'names',
    relation_lazy='joined',
    message = Column(Unicode(79), nullable=False, index=True,
        info=dict(description=u"The text displayed", official=True, format='plaintext')),
)

class SuperContestCombo(TableBase):
    u"""Combo of two moves in a Super Contest.
    """
    __tablename__ = 'super_contest_combos'
    first_move_id = Column(Integer, ForeignKey('moves.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"The ID of the first move in the combo."))
    second_move_id = Column(Integer, ForeignKey('moves.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"The ID of the second and last move."))

class SuperContestEffect(TableBase):
    u"""An effect a move can have when used in the Super Contest
    """
    __tablename__ = 'super_contest_effects'
    __singlename__ = 'super_contest_effect'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u"This effect's unique ID."))
    appeal = Column(SmallInteger, nullable=False,
        info=dict(description=u"The number of hearts the user gains."))

create_translation_table('super_contest_effect_prose', SuperContestEffect, 'prose',
    flavor_text = Column(UnicodeText, nullable=False,
        info=dict(description=u"A description of the effect.", format='plaintext', official=True)),
)

class Type(TableBase):
    u"""Any of the elemental types Pokémon and moves can have."""
    __tablename__ = 'types'
    __singlename__ = 'type'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u"A unique ID for this type."))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u"An identifier", format='identifier'))
    generation_id = Column(Integer, ForeignKey('generations.id'), nullable=False,
        info=dict(description=u"The ID of the generation this type first appeared in."))
    damage_class_id = Column(Integer, ForeignKey('move_damage_classes.id'), nullable=True,
        info=dict(description=u"The ID of the damage class this type's moves had before Generation IV, null if not applicable (e.g. ???)."))

create_translation_table('type_names', Type, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class TypeEfficacy(TableBase):
    u"""The damage multiplier used when a move of a particular type damages a
    Pokémon of a particular other type.
    """
    __tablename__ = 'type_efficacy'
    damage_type_id = Column(Integer, ForeignKey('types.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"The ID of the damaging type."))
    target_type_id = Column(Integer, ForeignKey('types.id'), primary_key=True, nullable=False, autoincrement=False,
        info=dict(description=u"The ID of the defending Pokémon's type."))
    damage_factor = Column(Integer, nullable=False,
        info=dict(description=u"The multiplier, as a percentage of damage inflicted."))

class Version(TableBase):
    u"""An individual main-series Pokémon game."""
    __tablename__ = 'versions'
    __singlename__ = 'version'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u"A unique ID for this version."))
    version_group_id = Column(Integer, ForeignKey('version_groups.id'), nullable=False,
        info=dict(description=u"The ID of the version group this game belongs to."))
    identifier = Column(Unicode(79), nullable=False,
        info=dict(description=u'And identifier', format='identifier'))

create_translation_table('version_names', Version, 'names',
    relation_lazy='joined',
    name = Column(Unicode(79), nullable=False, index=True,
        info=dict(description="The name", format='plaintext', official=True)),
)

class VersionGroup(TableBase):
    u"""A group of versions, containing either two paired versions (such as Red
    and Blue) or a single game (such as Yellow.)
    """
    __tablename__ = 'version_groups'
    id = Column(Integer, primary_key=True, nullable=False,
        info=dict(description=u"This version group's unique ID."))
    identifier = Column(Unicode(79), nullable=False, unique=True,
        info=dict(description=u"This version group's unique textual identifier.", format='identifier'))
    generation_id = Column(Integer, ForeignKey('generations.id'), nullable=False,
        info=dict(description=u"The ID of the generation the games in this group belong to."))
    order = Column(Integer, nullable=True,
        info=dict(description=u"Order for sorting. Almost by date of release, except similar versions are grouped together."))

class VersionGroupPokemonMoveMethod(TableBase):
    u"""Maps a version group to a move learn methods it supports.

    "Supporting" means simply that the method appears in the game.
    For example, Breeding didn't exist in Gen.I, so it's not in this table.
    """
    __tablename__ = 'version_group_pokemon_move_methods'
    version_group_id = Column(Integer, ForeignKey('version_groups.id'), primary_key=True, nullable=False,
        info=dict(description=u"The ID of the version group."))
    pokemon_move_method_id = Column(Integer, ForeignKey('pokemon_move_methods.id'), primary_key=True, nullable=False,
        info=dict(description=u"The ID of the move method."))

class VersionGroupRegion(TableBase):
    u"""Maps a version group to a region that appears in it."""
    __tablename__ = 'version_group_regions'
    version_group_id = Column(Integer, ForeignKey('version_groups.id'), primary_key=True, nullable=False,
        info=dict(description=u"The ID of the version group."))
    region_id = Column(Integer, ForeignKey('regions.id'), primary_key=True, nullable=False,
        info=dict(description=u"The ID of the region."))


### Relationships down here, to avoid dependency ordering problems

Ability.changelog = relationship(AbilityChangelog,
    order_by=AbilityChangelog.changed_in_version_group_id.desc(),
    backref=backref('ability', innerjoin=True, lazy='joined'))
Ability.flavor_text = relationship(AbilityFlavorText,
    order_by=AbilityFlavorText.version_group_id,
    backref=backref('ability', innerjoin=True, lazy='joined'))
Ability.generation = relationship(Generation,
    innerjoin=True,
    backref='abilities')

AbilityChangelog.changed_in = relationship(VersionGroup,
    innerjoin=True, lazy='joined',
    backref='ability_changelog')

AbilityFlavorText.version_group = relationship(VersionGroup,
    innerjoin=True)
AbilityFlavorText.language = relationship(Language,
    innerjoin=True, lazy='joined')


Berry.berry_firmness = relationship(BerryFirmness,
    innerjoin=True,
    backref='berries')
Berry.firmness = association_proxy('berry_firmness', 'name')
Berry.flavors = relationship(BerryFlavor,
    order_by=BerryFlavor.contest_type_id,
    backref=backref('berry', innerjoin=True))
Berry.natural_gift_type = relationship(Type, innerjoin=True)

BerryFlavor.contest_type = relationship(ContestType, innerjoin=True)


ConquestEpisode.warriors = relationship(ConquestWarrior,
    secondary=ConquestEpisodeWarrior.__table__,
    innerjoin=True,
    backref='episodes')

ConquestKingdom.type = relationship(Type,
    uselist=False,
    innerjoin=True, lazy='joined',
    backref=backref('conquest_kingdom', uselist=False))

ConquestMaxLink.pokemon = relationship(PokemonSpecies,
    uselist=False,
    innerjoin=True, lazy='joined',
    backref=backref('conquest_max_links', lazy='dynamic',
                    order_by=ConquestMaxLink.warrior_rank_id))
ConquestMaxLink.warrior_rank = relationship(ConquestWarriorRank,
    uselist=False,
    innerjoin=True, lazy='joined',
    backref=backref('max_links', lazy='dynamic'))
ConquestMaxLink.warrior = association_proxy('warrior_rank', 'warrior')

ConquestMoveData.move_displacement = relationship(ConquestMoveDisplacement,
    uselist=False,
    backref='move_data')
ConquestMoveData.move = relationship(Move,
    uselist=False,
    innerjoin=True, lazy='joined',
    backref=backref('conquest_data', uselist=False))
ConquestMoveData.move_effect = relationship(ConquestMoveEffect,
    innerjoin=True, lazy='joined',
    backref='move_data')
ConquestMoveData.range = relationship(ConquestMoveRange,
    innerjoin=True, lazy='joined',
    backref='move_data')

ConquestMoveData.effect = markdown.MoveEffectProperty('effect')
ConquestMoveData.effect_map = markdown.MoveEffectPropertyMap('effect_map')
ConquestMoveData.short_effect = markdown.MoveEffectProperty('short_effect')
ConquestMoveData.short_effect_map = markdown.MoveEffectPropertyMap('short_effect_map')
ConquestMoveData.displacement = markdown.MoveEffectProperty('effect', relationship='move_displacement')

ConquestPokemonEvolution.gender = relationship(Gender,
    backref='conquest_evolutions')
ConquestPokemonEvolution.item = relationship(Item,
    backref='conquest_evolutions')
ConquestPokemonEvolution.kingdom = relationship(ConquestKingdom,
    backref='evolutions')
ConquestPokemonEvolution.stat = relationship(ConquestStat,
    backref='evolutions')

ConquestPokemonStat.pokemon = relationship(PokemonSpecies,
    uselist=False,
    innerjoin=True, lazy='joined',
    backref='conquest_stats')
ConquestPokemonStat.stat = relationship(ConquestStat,
    uselist=False,
    innerjoin=True, lazy='joined',
    backref='pokemon_stats')

ConquestWarrior.archetype = relationship(ConquestWarriorArchetype,
    uselist=False,
    backref=backref('warriors'))
ConquestWarrior.ranks = relationship(ConquestWarriorRank,
    order_by=ConquestWarriorRank.rank,
    innerjoin=True,
    backref=backref('warrior', uselist=False))
ConquestWarrior.types = relationship(Type,
    secondary=ConquestWarriorSpecialty.__table__,
    order_by=ConquestWarriorSpecialty.slot,
    innerjoin=True,
    backref='conquest_warriors')

ConquestWarriorRank.skill = relationship(ConquestWarriorSkill,
    uselist=False,
    innerjoin=True, lazy='joined',
    backref=backref('warrior_ranks', order_by=ConquestWarriorRank.id))
ConquestWarriorRank.stats = relationship(ConquestWarriorRankStatMap,
    innerjoin=True,
    order_by=ConquestWarriorRankStatMap.warrior_stat_id,
    backref=backref('warrior_rank', uselist=False, innerjoin=True, lazy='joined'))

ConquestWarriorRankStatMap.stat = relationship(ConquestWarriorStat,
    innerjoin=True, lazy='joined',
    uselist=False,
    backref='stat_map')

ConquestWarriorTransformation.completed_episode = relationship(ConquestEpisode,
    primaryjoin=ConquestWarriorTransformation.completed_episode_id==ConquestEpisode.id,
    uselist=False)
ConquestWarriorTransformation.current_episode = relationship(ConquestEpisode,
    primaryjoin=ConquestWarriorTransformation.current_episode_id==ConquestEpisode.id,
    uselist=False)
ConquestWarriorTransformation.distant_warrior = relationship(ConquestWarrior,
    uselist=False)
ConquestWarriorTransformation.pokemon = relationship(PokemonSpecies,
    secondary=ConquestTransformationPokemon.__table__,
    order_by=PokemonSpecies.conquest_order)
ConquestWarriorTransformation.present_warriors = relationship(ConquestWarrior,
    secondary=ConquestTransformationWarrior.__table__,
    order_by=ConquestWarrior.id)
ConquestWarriorTransformation.type = relationship(Type,
    uselist=False)
ConquestWarriorTransformation.warrior_rank = relationship(ConquestWarriorRank,
    uselist=False,
    innerjoin=True, lazy='joined',
    backref=backref('transformation', uselist=False, innerjoin=True))


ContestCombo.first = relationship(Move,
    primaryjoin=ContestCombo.first_move_id==Move.id,
    innerjoin=True, lazy='joined',
    backref='contest_combo_first')
ContestCombo.second = relationship(Move,
    primaryjoin=ContestCombo.second_move_id==Move.id,
    innerjoin=True, lazy='joined',
    backref='contest_combo_second')


Encounter.condition_values = relationship(EncounterConditionValue,
    secondary=EncounterConditionValueMap.__table__)
Encounter.location_area = relationship(LocationArea,
    innerjoin=True, lazy='joined',
    backref='encounters')
Encounter.pokemon = relationship(Pokemon,
    innerjoin=True, lazy='joined',
    backref='encounters')
Encounter.version = relationship(Version,
    innerjoin=True, lazy='joined',
    backref='encounters')
Encounter.slot = relationship(EncounterSlot,
    innerjoin=True, lazy='joined',
    backref='encounters')

EncounterConditionValue.condition = relationship(EncounterCondition,
    innerjoin=True, lazy='joined',
    backref='values')

EncounterSlot.method = relationship(EncounterMethod,
    innerjoin=True, lazy='joined',
    backref='slots')
EncounterSlot.version_group = relationship(VersionGroup, innerjoin=True)


EvolutionChain.baby_trigger_item = relationship(Item,
    backref='evolution_chains')


Experience.growth_rate = relationship(GrowthRate,
    innerjoin=True, lazy='joined',
    backref='experience_table')


Generation.versions = relationship(Version,
    secondary=VersionGroup.__table__,
    innerjoin=True)
Generation.main_region = relationship(Region, innerjoin=True)


GrowthRate.max_experience_obj = relationship(Experience,
    primaryjoin=and_(
        Experience.growth_rate_id == GrowthRate.id,
        Experience.level == 100),
    uselist=False, innerjoin=True)
GrowthRate.max_experience = association_proxy('max_experience_obj', 'experience')


Item.berry = relationship(Berry,
    uselist=False,
    backref='item')
Item.flags = relationship(ItemFlag,
    secondary=ItemFlagMap.__table__)
Item.flavor_text = relationship(ItemFlavorText,
    order_by=ItemFlavorText.version_group_id.asc(),
    backref=backref('item', innerjoin=True, lazy='joined'))
Item.fling_effect = relationship(ItemFlingEffect,
    backref='items')
Item.machines = relationship(Machine,
    order_by=Machine.version_group_id.asc())
Item.category = relationship(ItemCategory,
    innerjoin=True,
    backref=backref('items', order_by=Item.identifier.asc()))
Item.pocket = association_proxy('category', 'pocket')

ItemCategory.pocket = relationship(ItemPocket, innerjoin=True)

ItemFlavorText.version_group = relationship(VersionGroup,
    innerjoin=True, lazy='joined')
ItemFlavorText.language = relationship(Language,
    innerjoin=True, lazy='joined')

ItemGameIndex.item = relationship(Item,
    innerjoin=True, lazy='joined',
    backref='game_indices')
ItemGameIndex.generation = relationship(Generation,
    innerjoin=True, lazy='joined')

ItemPocket.categories = relationship(ItemCategory,
    innerjoin=True,
    order_by=ItemCategory.identifier.asc())


Location.region = relationship(Region,
    innerjoin=True,
    backref='locations')

LocationArea.location = relationship(Location,
    innerjoin=True, lazy='joined',
    backref='areas')

LocationAreaEncounterRate.location_area = relationship(LocationArea,
    innerjoin=True,
    backref='encounter_rates')
LocationAreaEncounterRate.method = relationship(EncounterMethod,
    innerjoin=True)

LocationGameIndex.location = relationship(Location,
    innerjoin=True, lazy='joined',
    backref='game_indices')
LocationGameIndex.generation = relationship(Generation,
    innerjoin=True, lazy='joined')


Machine.item = relationship(Item)
Machine.version_group = relationship(VersionGroup,
    innerjoin=True, lazy='joined')


Move.changelog = relationship(MoveChangelog,
    order_by=MoveChangelog.changed_in_version_group_id.desc(),
    backref=backref('move', innerjoin=True, lazy='joined'))
Move.contest_effect = relationship(ContestEffect,
    backref='moves')
Move.contest_combo_next = association_proxy('contest_combo_first', 'second')
Move.contest_combo_prev = association_proxy('contest_combo_second', 'first')
Move.contest_type = relationship(ContestType,
    backref='moves')
Move.damage_class = relationship(MoveDamageClass,
    innerjoin=True,
    backref='moves')
Move.flags = association_proxy('move_flags', 'flag')
Move.flavor_text = relationship(MoveFlavorText,
    order_by=MoveFlavorText.version_group_id, backref='move')
Move.generation = relationship(Generation,
    innerjoin=True,
    backref='moves')
# XXX should this be a dict mapping version group to number?
Move.machines = relationship(Machine,
    backref='move')
Move.meta = relationship(MoveMeta,
    uselist=False,
    backref='move')
Move.meta_stat_changes = relationship(MoveMetaStatChange)
Move.move_effect = relationship(MoveEffect,
    innerjoin=True,
    backref='moves')
Move.move_flags = relationship(MoveFlagMap,
    backref='move')
Move.super_contest_effect = relationship(SuperContestEffect,
    backref='moves')
Move.super_contest_combo_next = association_proxy('super_contest_combo_first', 'second')
Move.super_contest_combo_prev = association_proxy('super_contest_combo_second', 'first')
Move.target = relationship(MoveTarget,
    innerjoin=True,
    backref='moves')
Move.type = relationship(Type,
    innerjoin=True, lazy='joined',
    backref='moves')

Move.effect = markdown.MoveEffectProperty('effect')
Move.effect_map = markdown.MoveEffectPropertyMap('effect_map')
Move.short_effect = markdown.MoveEffectProperty('short_effect')
Move.short_effect_map = markdown.MoveEffectPropertyMap('short_effect_map')

MoveChangelog.changed_in = relationship(VersionGroup,
    innerjoin=True, lazy='joined',
    backref='move_changelog')
MoveChangelog.move_effect = relationship(MoveEffect,
    backref='move_changelog')
MoveChangelog.type = relationship(Type,
    backref='move_changelog')

MoveChangelog.effect = markdown.MoveEffectProperty('effect')
MoveChangelog.effect_map = markdown.MoveEffectPropertyMap('effect_map')
MoveChangelog.short_effect = markdown.MoveEffectProperty('short_effect')
MoveChangelog.short_effect_map = markdown.MoveEffectPropertyMap('short_effect_map')

MoveEffect.changelog = relationship(MoveEffectChangelog,
    order_by=MoveEffectChangelog.changed_in_version_group_id.desc(),
    backref='move_effect')

MoveEffectChangelog.changed_in = relationship(VersionGroup,
    innerjoin=True, lazy='joined',
    backref='move_effect_changelog')

MoveFlagMap.flag = relationship(MoveFlag, innerjoin=True, lazy='joined')

MoveFlavorText.version_group = relationship(VersionGroup,
    innerjoin=True, lazy='joined')
MoveFlavorText.language = relationship(Language,
    innerjoin=True, lazy='joined')

MoveMeta.category = relationship(MoveMetaCategory,
    innerjoin=True, lazy='joined',
    backref='move_meta')
MoveMeta.ailment = relationship(MoveMetaAilment,
    innerjoin=True, lazy='joined',
    backref='move_meta')

MoveMetaStatChange.stat = relationship(Stat,
    innerjoin=True, lazy='joined',
    backref='move_meta_stat_changes')


Nature.decreased_stat = relationship(Stat,
    primaryjoin=Nature.decreased_stat_id==Stat.id,
    innerjoin=True,
    backref='decreasing_natures')
Nature.increased_stat = relationship(Stat,
    primaryjoin=Nature.increased_stat_id==Stat.id,
    innerjoin=True,
    backref='increasing_natures')
Nature.hates_flavor = relationship(ContestType,
    primaryjoin=Nature.hates_flavor_id==ContestType.id,
    innerjoin=True,
    backref='hating_natures')
Nature.likes_flavor = relationship(ContestType,
    primaryjoin=Nature.likes_flavor_id==ContestType.id,
    innerjoin=True,
    backref='liking_natures')
Nature.battle_style_preferences = relationship(NatureBattleStylePreference,
    order_by=NatureBattleStylePreference.move_battle_style_id.asc(),
    backref='nature')
Nature.pokeathlon_effects = relationship(NaturePokeathlonStat,
    order_by=NaturePokeathlonStat.pokeathlon_stat_id.asc())

NatureBattleStylePreference.battle_style = relationship(MoveBattleStyle,
    innerjoin=True, lazy='joined',
    backref='nature_preferences')

NaturePokeathlonStat.pokeathlon_stat = relationship(PokeathlonStat,
    innerjoin=True, lazy='joined',
    backref='nature_effects')


PalPark.area = relationship(PalParkArea,
    innerjoin=True, lazy='joined')


Pokedex.region = relationship(Region,
    innerjoin=True,
    backref='pokedexes')
Pokedex.version_groups = relationship(VersionGroup,
    secondary=PokedexVersionGroup.__table__,
    innerjoin=True,
    order_by=VersionGroup.order.asc(),
    backref='pokedexes')


Pokemon.all_abilities = relationship(Ability,
    secondary=PokemonAbility.__table__,
    order_by=PokemonAbility.slot.asc(),
    backref=backref('all_pokemon', order_by=Pokemon.order.asc()),
    doc=u"All abilities the Pokémon can have, including the Hidden Ability")
Pokemon.abilities = relationship(Ability,
    secondary=PokemonAbility.__table__,
    primaryjoin=and_(
        Pokemon.id == PokemonAbility.pokemon_id,
        PokemonAbility.is_hidden == False,
    ),
    order_by=PokemonAbility.slot.asc(),
    backref=backref('pokemon', order_by=Pokemon.order.asc()),
    doc=u"Abilities the Pokémon can have in the wild")
Pokemon.hidden_ability = relationship(Ability,
    secondary=PokemonAbility.__table__,
    primaryjoin=and_(
        Pokemon.id == PokemonAbility.pokemon_id,
        PokemonAbility.is_hidden == True,
    ),
    uselist=False,
    backref=backref('hidden_pokemon', order_by=Pokemon.order),
    doc=u"The Pokémon's Hidden Ability")
Pokemon.pokemon_abilities = relationship(PokemonAbility,
    order_by=PokemonAbility.slot.asc(),
    backref=backref('pokemon', order_by=Pokemon.order.asc()),
    doc=u"All abilities the Pokémon can have, as bridge rows")
Pokemon.forms = relationship(PokemonForm,
    primaryjoin=Pokemon.id==PokemonForm.pokemon_id,
    order_by=(PokemonForm.order.asc(), PokemonForm.form_identifier.asc()),
    lazy='joined')
Pokemon.default_form = relationship(PokemonForm,
    primaryjoin=and_(
        Pokemon.id==PokemonForm.pokemon_id,
        PokemonForm.is_default==True),
    uselist=False, lazy='joined',
    doc=u"A representative form of this pokémon")
Pokemon.items = relationship(PokemonItem,
    backref='pokemon',
    order_by=PokemonItem.rarity.desc(),
    doc=u"Info about items this pokémon holds in the wild")
Pokemon.stats = relationship(PokemonStat,
    order_by=PokemonStat.stat_id.asc(),
    backref='pokemon')
Pokemon.species = relationship(PokemonSpecies,
    innerjoin=True,
    backref='pokemon')
Pokemon.types = relationship(Type,
    secondary=PokemonType.__table__,
    innerjoin=True, lazy='joined',
    order_by=PokemonType.slot.asc(),
    backref=backref('pokemon', order_by=Pokemon.order))

PokemonAbility.ability = relationship(Ability,
    innerjoin=True)

PokemonDexNumber.pokedex = relationship(Pokedex,
    innerjoin=True, lazy='joined')

PokemonEvolution.trigger = relationship(EvolutionTrigger,
    innerjoin=True, lazy='joined',
    backref='evolutions')
PokemonEvolution.trigger_item = relationship(Item,
    primaryjoin=PokemonEvolution.trigger_item_id==Item.id,
    backref='triggered_evolutions')
PokemonEvolution.held_item = relationship(Item,
    primaryjoin=PokemonEvolution.held_item_id==Item.id,
    backref='required_for_evolutions')
PokemonEvolution.location = relationship(Location,
    backref='triggered_evolutions')
PokemonEvolution.known_move = relationship(Move,
    backref='triggered_evolutions')
PokemonEvolution.known_move_type = relationship(Type,
    primaryjoin=PokemonEvolution.known_move_type_id==Type.id)
PokemonEvolution.party_species = relationship(PokemonSpecies,
    primaryjoin=PokemonEvolution.party_species_id==PokemonSpecies.id,
    backref='triggered_evolutions')
PokemonEvolution.party_type = relationship(Type,
    primaryjoin=PokemonEvolution.party_type_id==Type.id)
PokemonEvolution.trade_species = relationship(PokemonSpecies,
    primaryjoin=PokemonEvolution.trade_species_id==PokemonSpecies.id)
PokemonEvolution.gender = relationship(Gender,
    backref='required_for_evolutions')

PokemonForm.pokemon = relationship(Pokemon,
    primaryjoin=PokemonForm.pokemon_id==Pokemon.id,
    innerjoin=True, lazy='joined')
PokemonForm.species = association_proxy('pokemon', 'species')
PokemonForm.version_group = relationship(VersionGroup,
    innerjoin=True)
PokemonForm.pokeathlon_stats = relationship(PokemonFormPokeathlonStat,
    order_by=PokemonFormPokeathlonStat.pokeathlon_stat_id,
    backref='pokemon_form')

PokemonFormPokeathlonStat.pokeathlon_stat = relationship(PokeathlonStat,
    innerjoin=True, lazy='joined')

PokemonFormGeneration.form = relationship(PokemonForm,
    backref=backref('pokemon_form_generations',
        order_by=PokemonFormGeneration.generation_id))
PokemonFormGeneration.generation = relationship(Generation,
    backref=backref('pokemon_form_generations',
        order_by=PokemonFormGeneration.game_index))

PokemonItem.item = relationship(Item,
    innerjoin=True, lazy='joined',
    backref='pokemon')
PokemonItem.version = relationship(Version,
    innerjoin=True, lazy='joined')

PokemonMove.pokemon = relationship(Pokemon,
    innerjoin=True, lazy='joined',
    backref='pokemon_moves')
PokemonMove.version_group = relationship(VersionGroup,
    innerjoin=True, lazy='joined',
    backref='pokemon_moves')
PokemonMove.machine = relationship(Machine,
    primaryjoin=and_(
        Machine.version_group_id==PokemonMove.version_group_id,
        Machine.move_id==PokemonMove.move_id),
    foreign_keys=[Machine.version_group_id, Machine.move_id],
    uselist=False,
    backref='pokemon_moves')
PokemonMove.move = relationship(Move,
    innerjoin=True, lazy='joined',
    backref='pokemon_moves')
PokemonMove.method = relationship(PokemonMoveMethod,
    innerjoin=True, lazy='joined')

PokemonStat.stat = relationship(Stat,
    innerjoin=True, lazy='joined')

PokemonSpecies.parent_species = relationship(PokemonSpecies,
    primaryjoin=PokemonSpecies.evolves_from_species_id==PokemonSpecies.id,
    remote_side=[PokemonSpecies.id],
    backref=backref('child_species',
        doc=u"The species to which this one evolves"),
    doc=u"The species from which this one evolves")
PokemonSpecies.evolutions = relationship(PokemonEvolution,
    primaryjoin=PokemonSpecies.id==PokemonEvolution.evolved_species_id,
    backref=backref('evolved_species', innerjoin=True, lazy='joined'))
PokemonSpecies.flavor_text = relationship(PokemonSpeciesFlavorText,
    order_by=PokemonSpeciesFlavorText.version_id.asc(),
    backref='species')
PokemonSpecies.growth_rate = relationship(GrowthRate,
    innerjoin=True,
    backref='evolution_chains')
PokemonSpecies.habitat = relationship(PokemonHabitat,
    backref='species')
PokemonSpecies.color = relationship(PokemonColor,
    innerjoin=True,
    backref='species')
PokemonSpecies.egg_groups = relationship(EggGroup,
    secondary=PokemonEggGroup.__table__,
    order_by=PokemonEggGroup.egg_group_id.asc(),
    backref=backref('species', order_by=PokemonSpecies.order.asc()))
PokemonSpecies.forms = relationship(PokemonForm,
    secondary=Pokemon.__table__,
    primaryjoin=PokemonSpecies.id==Pokemon.species_id,
    secondaryjoin=Pokemon.id==PokemonForm.pokemon_id,
    order_by=(PokemonForm.order.asc(), PokemonForm.form_identifier.asc()))
PokemonSpecies.default_form = relationship(PokemonForm,
    secondary=Pokemon.__table__,
    primaryjoin=and_(PokemonSpecies.id==Pokemon.species_id,
            Pokemon.is_default==True),
    secondaryjoin=and_(Pokemon.id==PokemonForm.pokemon_id,
            PokemonForm.is_default==True),
    uselist=False,
    doc=u"A representative form of this species")
PokemonSpecies.default_pokemon = relationship(Pokemon,
    primaryjoin=and_(
        PokemonSpecies.id==Pokemon.species_id,
        Pokemon.is_default==True),
    uselist=False, lazy='joined')
PokemonSpecies.evolution_chain = relationship(EvolutionChain,
    backref=backref('species', order_by=PokemonSpecies.id.asc()))
PokemonSpecies.dex_numbers = relationship(PokemonDexNumber,
    innerjoin=True,
    order_by=PokemonDexNumber.pokedex_id.asc(),
    backref='species')
PokemonSpecies.generation = relationship(Generation,
    innerjoin=True,
    backref='species')
PokemonSpecies.shape = relationship(PokemonShape,
    innerjoin=True,
    backref='species')
PokemonSpecies.pal_park = relationship(PalPark,
    uselist=False,
    backref='species')

PokemonSpecies.conquest_abilities = relationship(Ability,
    secondary=ConquestPokemonAbility.__table__,
    order_by=ConquestPokemonAbility.slot,
    backref=backref('conquest_pokemon', order_by=PokemonSpecies.conquest_order,
                    innerjoin=True))
PokemonSpecies.conquest_move = relationship(Move,
    secondary=ConquestPokemonMove.__table__,
    uselist=False,
    backref=backref('conquest_pokemon', order_by=PokemonSpecies.conquest_order))
PokemonSpecies.conquest_evolution = relationship(ConquestPokemonEvolution,
    uselist=False,
    backref=backref('evolved_species', innerjoin=True, lazy='joined', uselist=False))

PokemonSpeciesFlavorText.version = relationship(Version, innerjoin=True, lazy='joined')
PokemonSpeciesFlavorText.language = relationship(Language, innerjoin=True, lazy='joined')

Region.generation = relationship(Generation, uselist=False)
Region.version_group_regions = relationship(VersionGroupRegion,
    order_by=VersionGroupRegion.version_group_id.asc(),
    backref='region')
Region.version_groups = relationship(VersionGroup,
    secondary=VersionGroupRegion.__table__,
    order_by=VersionGroup.order)


Stat.damage_class = relationship(MoveDamageClass,
    backref='stats')

StatHint.stat = relationship(Stat,
    innerjoin=True,
    backref='hints')


SuperContestCombo.first = relationship(Move,
    primaryjoin=SuperContestCombo.first_move_id==Move.id,
    innerjoin=True, lazy='joined',
    backref='super_contest_combo_first')
SuperContestCombo.second = relationship(Move,
    primaryjoin=SuperContestCombo.second_move_id==Move.id,
    innerjoin=True, lazy='joined',
    backref='super_contest_combo_second')


Type.damage_efficacies = relationship(TypeEfficacy,
    primaryjoin=Type.id==TypeEfficacy.damage_type_id,
    backref=backref('damage_type', innerjoin=True, lazy='joined'))
Type.target_efficacies = relationship(TypeEfficacy,
    primaryjoin=Type.id==TypeEfficacy.target_type_id,
    backref=backref('target_type', innerjoin=True, lazy='joined'))

Type.generation = relationship(Generation,
    innerjoin=True,
    backref='types')
Type.damage_class = relationship(MoveDamageClass,
    backref='types')


Version.generation = association_proxy('version_group', 'generation')

VersionGroup.versions = relationship(Version,
    innerjoin=True,
    order_by=Version.id,
    backref=backref('version_group', lazy='joined'))
VersionGroup.generation = relationship(Generation,
    innerjoin=True, lazy='joined',
    backref=backref('version_groups', order_by=VersionGroup.order))
VersionGroup.version_group_regions = relationship(VersionGroupRegion,
    backref='version_group')
VersionGroup.regions = association_proxy('version_group_regions', 'region')
VersionGroup.pokemon_move_methods = relationship(PokemonMoveMethod,
    secondary=VersionGroupPokemonMoveMethod.__table__,
    primaryjoin=and_(VersionGroup.id == VersionGroupPokemonMoveMethod.version_group_id),
    secondaryjoin=and_(PokemonMoveMethod.id == VersionGroupPokemonMoveMethod.pokemon_move_method_id),
    backref="version_groups")
VersionGroup.machines = relationship(Machine,
    innerjoin=True,
    order_by=Machine.machine_number)


VersionGroupPokemonMoveMethod.version_group = relationship(VersionGroup,
    backref='version_group_move_methods')
VersionGroupPokemonMoveMethod.pokemon_move_method = relationship(PokemonMoveMethod,
    backref='version_group_move_methods')

########NEW FILE########
__FILENAME__ = translations
#! /usr/bin/env python
u"""General handling of translations

The general idea is to get messages from somewhere: the source pokedex CSVs,
or the translation CSVs, etc., then merge them together in some way, and shove
them into the database.

If a message is translated, it has a source string attached to it, with the
original English version. Or at least it has a CRC of the original.
When that doesn't match, it means the English string changed and the
translation has to be updated.
Also this is why we can't dump translations from the database: there's no
original string info.

Some complications:

Flavor text is so repetitive that we take strings from all the version,
separate the unique ones by blank lines, let translators work on that, and then
put it in flavor_summary tables.

Routes names and other repetitive numeric things are replaced by e.g.
"Route {num}" so translators only have to work on each set once.

"""

import binascii
import csv
import heapq
import itertools
import os
import re
import sys
from collections import defaultdict

from pokedex.db import tables
from pokedex.defaults import get_default_csv_dir

default_source_lang = 'en'

# Top-level classes we want translations for: in order, and by name
# These are all mapped_classes that have translatable texts and aren't summarized
toplevel_classes = []
toplevel_class_by_name = {}

# summary_map[pokemon_prose]['flavor_summary'] == PokemonFlavorTexts
summary_map = {}

# translation_class_by_column[class_name, column_name] == translation_class
translation_class_by_column = {}

for cls in tables.mapped_classes:
    try:
        summary_class, col = cls.summary_column
    except AttributeError:
        if cls.translation_classes:
            toplevel_classes.append(cls)
            toplevel_class_by_name[cls.__name__] = cls
            for translation_class in cls.translation_classes:
                for column in translation_class.__table__.c:
                    translation_class_by_column[cls, column.name] = translation_class
    else:
        summary_map.setdefault(summary_class, {})[col] = cls

number_re = re.compile("[0-9]+")

def crc(string):
    """Return a hash to we use in translation CSV files"""
    return "%08x" % (binascii.crc32(string.encode('utf-8')) & 0xffffffff)
    # Two special values are also used in source_crc:
    # UNKNOWN: no source string was available
    # OFFICIAL: an official string from the main database

class Message(object):
    """Holds all info about a translatable or translated string

    cls: Name of the mapped class the message belongs to
    id: The id of the thing the message belongs to
    colname: name of the database column
    strings: A list of strings in the message, usualy of length 1.

    Optional attributes (None if not set):
    colsize: Max length of the database column
    source: The string this was translated from
    number_replacement: True if this is a translation with {num} placeholders
    pot: Name of the pot the message goes to (see pot_for_column)
    source_crc: CRC of the source
    origin: Some indication of where the string came from (CSV, PO, ...)
    fuzzy: True for fuzzy translations
    language_id: ID of the language
    official: True if this is a known-good translation
    """
    __slots__ = 'cls id colname strings colsize source number_replacement pot source_crc origin fuzzy language_id official'.split()
    def __init__(self, cls, id, colname, string,
            colsize=None, source=None, number_replacement=None, pot=None,
            source_crc=None, origin=None, fuzzy=None, language_id=None,
            official=None,
        ):
        self.cls = cls
        self.id = id
        self.colname = colname
        self.strings = [string]
        self.colsize = colsize
        self.source = source
        self.number_replacement = number_replacement
        self.pot = pot
        self.source_crc = source_crc
        if source and not source_crc:
             self.source_crc = crc(source)
        self.origin = origin
        self.fuzzy = fuzzy
        self.language_id = language_id
        self.official = official

    def merge(self, other):
        """Merge two messages, as required for flavor text summarizing
        """
        assert self.merge_key == other.merge_key
        for string in other.strings:
            if string not in self.strings:
                self.strings.append(string)
        self.colsize = self.colsize or other.colsize
        self.pot = self.pot or other.pot
        self.source = None
        self.source_crc = None
        self.number_replacement = None

    @property
    def string(self):
        return '\n\n'.join(self.strings)

    @property
    def merge_key(self):
        return self.cls, self.id, self.colname

    @property
    def sort_key(self):
        return self.merge_key, self.language_id, self.fuzzy

    @property
    def eq_key(self):
        return self.sort_key, self.strings

    def __eq__(self, other): return self.eq_key == other.eq_key
    def __ne__(self, other): return self.eq_key != other.eq_key
    def __gt__(self, other): return self.sort_key > other.sort_key
    def __lt__(self, other): return self.sort_key < other.sort_key
    def __ge__(self, other): return self.sort_key >= other.sort_key
    def __le__(self, other): return self.sort_key <= other.sort_key

    def __unicode__(self):
        string = '"%s"' % self.string
        if len(string) > 20:
            string = string[:15] + u'"...'
        template = u'<Message from {self.origin} for {self.cls}.{self.colname}:{self.id} -- {string}>'
        return template.format(self=self, string=string)

    def __str__(self):
        return unicode(self).encode('utf-8')

    def __repr__(self):
        return unicode(self).encode('utf-8')

class Translations(object):
    """Data and opertaions specific to a location on disk (and a source language)
    """
    def __init__(self, source_lang=default_source_lang, csv_directory=None, translation_directory=None):
        if csv_directory is None:
            csv_directory = get_default_csv_dir()

        if translation_directory is None:
            translation_directory = os.path.join(csv_directory, 'translations')

        self.source_lang = default_source_lang
        self.csv_directory = csv_directory
        self.translation_directory = translation_directory

        self.language_ids = {}
        self.language_identifiers = {}
        self.official_langs = []
        for row in self.reader_for_class(tables.Language, reader_class=csv.DictReader):
            self.language_ids[row['identifier']] = int(row['id'])
            self.language_identifiers[int(row['id'])] = row['identifier']
            if row['official'] and int(row['official']):
                self.official_langs.append(row['identifier'])

        self.source_lang_id = self.language_ids[self.source_lang]

    @classmethod
    def from_parsed_options(cls, options):
        return cls(options.source_lang, options.directory)

    @property
    def source(self):
        """All source (i.e. English) messages
        """
        return self.official_messages(self.source_lang)

    def official_messages(self, lang):
        """All official messages (i.e. from main database) for the given lang
        """
        # Cached as tuples, since they're used pretty often
        lang_id = self.language_ids[lang]
        try:
            return self._sources[lang_id]
        except AttributeError:
            self._sources = {}
            for message in self.yield_source_messages():
                self._sources.setdefault(message.language_id, []).append(message)
            self._sources = dict((k, tuple(merge_adjacent(v))) for k, v in self._sources.items())
            return self.official_messages(lang)
        except KeyError:
            # Looks like there are no messages in the DB for this language
            # This should only happen for non-official languages
            assert lang not in self.official_langs
            return ()

    def write_translations(self, lang, *streams):
        """Write a translation CSV containing messages from streams.

        Streams should be ordered by priority, from highest to lowest.

        Any official translations (from the main database) are added automatically.
        """
        writer = self.writer_for_lang(lang)

        writer.writerow('language_id table id column source_crc string'.split())

        messages = merge_translations(self.source, self.official_messages(lang), *streams)

        warnings = {}
        for source, sourcehash, string, exact in messages:
            if string and sourcehash != 'OFFICIAL':
                utf8len = len(string.encode('utf-8'))
                if source.colsize and utf8len > source.colsize:
                    key = source.cls, source.colname
                    warnings[key] = max(warnings.get(key, (0,)), (utf8len, source, string))
                else:
                    writer.writerow((
                            self.language_ids[lang],
                            source.cls,
                            source.id,
                            source.colname,
                            sourcehash,
                            string.encode('utf-8'),
                        ))
        for utf8len, source, string in warnings.values():
            template = u'Error: {size}B value for {colsize}B column! {key[0]}.{key[2]}:{key[1]}: {string}'
            warning = template.format(
                    key=source.merge_key,
                    string=string,
                    size=utf8len,
                    colsize=source.colsize,
                )
            if len(warning) > 79:
                warning = warning[:76] + u'...'
            print warning.encode('utf-8')

    def reader_for_class(self, cls, reader_class=csv.reader):
        tablename = cls.__table__.name
        csvpath = os.path.join(self.csv_directory, tablename + '.csv')
        return reader_class(open(csvpath, 'rb'), lineterminator='\n')

    def writer_for_lang(self, lang):
        csvpath = os.path.join(self.translation_directory, '%s.csv' % lang)
        return csv.writer(open(csvpath, 'wb'), lineterminator='\n')

    def yield_source_messages(self, language_id=None):
        """Yield all messages from source CSV files

        Messages from all languages are returned. The messages are not ordered
        properly, but splitting the stream by language (and filtering results
        by merge_adjacent) will produce proper streams.
        """
        if language_id is None:
            language_id = self.source_lang_id

        for cls in sorted(toplevel_classes, key=lambda c: c.__name__):
            streams = []
            for translation_class in cls.translation_classes:
                streams.append(yield_source_csv_messages(
                        translation_class,
                        cls,
                        self.reader_for_class(translation_class),
                    ))
                try:
                    colmap = summary_map[translation_class]
                except KeyError:
                    pass
                else:
                    for colname, summary_class in colmap.items():
                        column = translation_class.__table__.c[colname]
                        streams.append(yield_source_csv_messages(
                                summary_class,
                                cls,
                                self.reader_for_class(summary_class),
                                force_column=column,
                            ))
            for message in Merge(*streams):
                yield message

    def yield_target_messages(self, lang):
        """Yield messages from the data/csv/translations/<lang>.csv file
        """
        path = os.path.join(self.csv_directory, 'translations', '%s.csv' % lang)
        try:
            file = open(path, 'rb')
        except IOError:
            return ()
        return yield_translation_csv_messages(file)

    def yield_all_translations(self):
        stream = Merge()
        for lang in self.language_identifiers.values():
            stream.add_iterator(self.yield_target_messages(lang))
        return (message for message in stream if not message.official)

    def get_load_data(self, langs=None):
        """Yield (translation_class, data for INSERT) pairs for loading into the DB

        langs is either a list of language identifiers or None
        """
        if langs is None:
            langs = self.language_identifiers.values()
        stream = Merge()
        for lang in self.language_identifiers.values():
            stream.add_iterator(self.yield_target_messages(lang))
        stream = (message for message in stream if not message.official)
        count = 0
        class GroupDict(dict):
            """Dict to automatically set the foreign_id and local_language_id for new items
            """
            def __missing__(self, key):
                # depends on `cls` from outside scope
                id, language_id = key
                data = self[key] = defaultdict(lambda: None)
                column_names = (c.name for c in translation_class.__table__.columns)
                data.update(dict.fromkeys(column_names))
                data.update({
                        '%s_id' % cls.__singlename__: id,
                        'local_language_id': language_id,
                    })
                return data
        # Nested dict:
        # translation_class -> (lang, id) -> column -> value
        everything = defaultdict(GroupDict)
        # Group by object so we always have all of the messages for one DB row
        for (cls_name, id), group in group_by_object(stream):
            cls = toplevel_class_by_name[cls_name]
            for message in group:
                translation_class = translation_class_by_column[cls, message.colname]
                key = id, message.language_id
                colname = str(message.colname)
                everything[translation_class][key][colname] = message.string
                count += 1
            if count > 1000:
                for translation_class, key_data in everything.items():
                    yield translation_class, key_data.values()
                count = 0
                everything.clear()
        for translation_class, data_dict in everything.items():
            yield translation_class, data_dict.values()

def group_by_object(stream):
    """Group stream by object

    Yields ((class name, object ID), (list of messages)) pairs.
    """
    stream = iter(stream)
    current = stream.next()
    current_key = current.cls, current.id
    group = [current]
    for message in stream:
        if (message.cls, message.id) != current_key:
            yield current_key, group
            group = []
        group.append(message)
        current = message
        current_key = current.cls, current.id
    yield current_key, group

class Merge(object):
    """Merge several sorted iterators together

    Additional iterators may be added at any time with add_iterator.
    Accepts None for the initial iterators
    If the same value appears in more iterators, there will be duplicates in
    the output.
    """
    def __init__(self, *iterators):
        self.next_values = []
        for iterator in iterators:
            if iterator is not None:
                self.add_iterator(iterator)

    def add_iterator(self, iterator):
        iterator = iter(iterator)
        try:
            value = iterator.next()
        except StopIteration:
            return
        else:
            heapq.heappush(self.next_values, (value, iterator))

    def __iter__(self):
        return self

    def next(self):
        if self.next_values:
            value, iterator = heapq.heappop(self.next_values)
            self.add_iterator(iterator)
            return value
        else:
            raise StopIteration

def merge_adjacent(gen):
    """Merge adjacent messages that compare equal"""
    gen = iter(gen)
    last = gen.next()
    for this in gen:
        if this.merge_key == last.merge_key:
            last.merge(this)
        elif last < this:
            yield last
            last = this
        else:
            raise AssertionError('Bad order, %s > %s' % (last, this))
    yield last

def leftjoin(left_stream, right_stream, key=lambda x: x, unused=None):
    """A "left join" operation on sorted iterators

    Yields (left, right) pairs, where left comes from left_stream and right
    is the corresponding item from right, or None

    Note that if there are duplicates in right_stream, you won't get duplicate
    rows for them.

    If given, unused should be a one-arg function that will get called on all
    unused items in right_stream.
    """
    left_stream = iter(left_stream)
    right_stream = iter(right_stream)
    try:
        right = right_stream.next()
        for left in left_stream:
            while right and key(left) > key(right):
                if unused is not None:
                    unused(right)
                right = right_stream.next()
            if key(left) == key(right):
                yield left, right
                del left
                right = right_stream.next()
            else:
                yield left, None
    except StopIteration:
        try:
            yield left, None
        except NameError:
            pass
        for left in left_stream:
            yield left, None
    else:
        if unused is not None:
            try:
                unused(right)
            except NameError:
                pass
            for right in right_stream:
                unused(right)

def synchronize(reference, stream, key=lambda x: x, unused=None):
    """Just the right side part of leftjoin(), Nones included"""
    for left, right in leftjoin(reference, stream, key, unused):
        yield right

def yield_source_csv_messages(cls, foreign_cls, csvreader, force_column=None):
    """Yield all messages from one source CSV file.
    """
    columns = list(cls.__table__.c)
    column_names = csvreader.next()
    # Assumptions: rows are in lexicographic order
    #  (taking numeric values as numbers of course)
    # Assumptions about the order of columns:
    # 1. It's the same in the table and in CSV
    # 2. Primary key is at the beginning
    # 3. First thing in the PK is the object id
    # 4. Last thing in the PK is the language
    # 5. Everything that follows is some translatable text
    assert [cls.__table__.c[name] for name in column_names] == columns, ','.join(c.name for c in columns)
    pk = columns[:len(cls.__table__.primary_key.columns)]
    first_string_index = len(pk)
    return _yield_csv_messages(foreign_cls, columns, first_string_index, csvreader, force_column=force_column)

def _yield_csv_messages(foreign_cls, columns, first_string_index, csvreader, origin='source CSV', crc_value='OFFICIAL', force_column=None):
    language_index = first_string_index - 1
    assert 'language' in columns[language_index].name, columns[language_index].name
    string_columns = columns[first_string_index:]
    if force_column is not None:
        assert len(string_columns) == 1
        string_columns = [force_column]
    for values in csvreader:
        id = int(values[0])
        messages = []
        for string, column in zip(values[first_string_index:], string_columns):
            message = Message(
                    foreign_cls.__name__,
                    id,
                    column.name,
                    string.decode('utf-8'),
                    column.type.length,
                    pot=pot_for_column(cls, column, force_column is not None),
                    origin=origin,
                    official=True,
                    source_crc=crc_value,
                    language_id=int(values[language_index]),
                )
            messages.append(message)
        messages.sort()
        for message in messages:
            yield message

def yield_guessed_csv_messages(file):
    """Yield messages from a CSV file, using the header to figure out what the data means.
    """
    csvreader = csv.reader(file, lineterminator='\n')
    column_names = csvreader.next()
    if column_names == 'language_id,table,id,column,source_crc,string'.split(','):
        # A translation CSV
        return yield_translation_csv_messages(file, True)
    # Not a translation CSV, figure out what the columns mean
    assert column_names[0].endswith('_id')
    assert column_names[1] == 'local_language_id'
    first_string_index = 2
    foreign_singlename = column_names[0][:-len('_id')]
    columns = [None] * len(column_names)
    column_indexes = dict((name, i) for i, name in enumerate(column_names))
    for foreign_cls in toplevel_classes:
        if foreign_cls.__singlename__ == foreign_singlename:
            break
    else:
        raise ValueError("Foreign key column name %s in %s doesn't correspond to a table" % (column_names[0], file))
    for translation_class in foreign_cls.translation_classes:
        for column in translation_class.__table__.c:
            column_index = column_indexes.get(column.name)
            if column_index is not None:
                columns[column_index] = column
    assert all([c is not None for c in columns[first_string_index:]])
    return _yield_csv_messages(foreign_cls, columns, first_string_index, csvreader, origin=file.name, crc_value='UNKNOWN')

def yield_translation_csv_messages(file, no_header=False):
    """Yield messages from a translation CSV file
    """
    csvreader = csv.reader(file, lineterminator='\n')
    if not no_header:
        columns = csvreader.next()
        assert columns == 'language_id,table,id,column,source_crc,string'.split(',')
    for language_id, table, id, column, source_crc, string in csvreader:
        yield Message(
                table,
                int(id),
                column,
                string.decode('utf-8'),
                origin='target CSV',
                source_crc=source_crc,
                language_id=int(language_id),
            )

def pot_for_column(cls, column, summary=False):
    """Translatable texts get categorized into different POT files to help
       translators prioritize. The pots are:

    - flavor: Flavor texts: here, strings from multiple versions are summarized
    - ripped: Strings ripped from the games; translators for "official"
      languages don't need to bother with these
    - effects: Fanon descriptions of things; they usually use technical
      language
    - misc: Everything else; usually small texts

    Set source to true if this is a flavor summary column. Others are
    determined by the column itself.
    """
    if summary:
        return 'flavor'
    elif column.info.get('ripped'):
        return 'ripped'
    elif column.name.endswith('effect'):
        return 'effects'
    else:
        return 'misc'

def number_replace(source, string):
    numbers_iter = iter(number_re.findall(source))
    next_number = lambda match: numbers_iter.next()
    return re.sub(r'\{num\}', next_number, string)

def match_to_source(source, *translations):
    """Matches translated string(s) to source

    The first translation whose source matches the source message, or whose CRC
    matches, or which is official, and which is not fuzzy, it is used.
    If thre's no such translation, the first translation is used.

    Returns (source, source string CRC, string for CSV file, exact match?)
    If there are no translations, returns (source, None, None, None)

    Handles translations where numbers have been replaced by {num}, if they
    have source information.
    """
    first = True
    best_crc = None
    for translation in translations:
        if translation is None:
            continue
        if translation.number_replacement:
            current_string = number_replace(source.string, translation.string)
            current_source = number_replace(source.string, translation.source)
            current_crc = crc(current_source)
        elif '{num}' in translation.string:
            print (u'Warning: {num} appears in %s, but not marked for number replacement. Discarding!' % translation).encode('utf-8')
            continue
        else:
            current_string = translation.string
            current_source = translation.source
            current_crc = translation.source_crc
        if translation.fuzzy:
            match = False
        elif translation.official:
            match = True
        elif current_source:
            match = source.string == current_source
        else:
            match = current_crc == crc(source.string)
        if first or match:
            best_string = current_string
            best_crc = current_crc
            best_message = translation
        if match:
            break
        first = False
    if best_crc:
        return source, best_crc, best_string, match
    else:
        return source, None, None, None

def merge_translations(source_stream, *translation_streams, **kwargs):
    """For each source message, get its best translation from translations.

    Translations should be ordered by priority, highest to lowest.

    Messages that don't appear in translations at all aren't included.
    """
    source = tuple(source_stream)
    streams = [
            synchronize(source, t, key=lambda m: m.merge_key, unused=kwargs.get('unused'))
            for t in translation_streams
        ]
    for messages in itertools.izip(source, *streams):
        yield match_to_source(*messages)

########NEW FILE########
__FILENAME__ = util
"""Helpers for common ways to work with pokedex queries

These include identifier- and name-based lookup, filtering out base forms
of pokemon, and filtering/ordering by name.
"""

from sqlalchemy.orm import aliased
from sqlalchemy.sql.expression import func
from sqlalchemy.sql.functions import coalesce
from sqlalchemy.orm.exc import NoResultFound

from pokedex.db import tables

### Getter

def get(session, table, identifier=None, name=None, id=None, language=None):
    """Get one object from the database.

    session: The session to use (from pokedex.db.connect())
    table: The table to select from (such as pokedex.db.tables.Move)

    identifier: Identifier of the object
    name: The name of the object
    id: The ID number of the object

    language: A Language to use for name and form_name

    All conditions must match, so it's not a good idea to specify more than one
    of identifier/name/id at once.

    If zero or more than one objects matching the criteria are found, the
    appropriate SQLAlchemy exception is raised.
    """

    query = session.query(table)

    if identifier is not None:
        query = query.filter_by(identifier=identifier)

    if name is not None:
        query = filter_name(query, table, name, language)

    if id is not None:
        # ASSUMPTION: id is the primary key of the table.
        result = query.get(id)
        if result is None:
            # Keep the API
            raise NoResultFound
        else:
            return result

    return query.one()

### Helpers

def filter_name(query, table, name, language, name_attribute='name'):
    """Filter a query by name, return the resulting query

    query: The query to filter
    table: The table of named objects
    name: The name to look for. May be a tuple of alternatives.
    language: The language for "name", or None for the session default
    name_attribute: the attribute to use; defaults to 'name'
    """
    if language is None:
        query = query.filter(getattr(table, name_attribute) == name)
    else:
        names_table = table.names_table
        name_column = getattr(names_table, name_attribute)
        query = query.join(names_table)
        query = query.filter(names_table.foreign_id == table.id)
        query = query.filter(names_table.local_language_id == language.id)
        if isinstance(name, tuple):
            query = query.filter(name_column in name)
        else:
            query = query.filter(name_column == name)
    return query

def order_by_name(query, table, language=None, *extra_languages, **kwargs):
    """Order a query by name.

    query: The query to order
    table: Table of the named objects
    language: The language to order names by. If None, use the
        connection default.
    extra_languages: Extra languages to order by, should the translations for
        `language` be incomplete (or ambiguous).

    name_attribute (keyword argument): the attribute to use; defaults to 'name'

    Uses the identifier as a fallback ordering.
    """
    name_attribute = kwargs.pop('name', 'name')
    if kwargs:
        raise ValueError('Unexpected keyword arguments: %s' % kwargs.keys())
    order_columns = []
    if language is None:
        query = query.outerjoin(table.names_local)
        order_columns.append(func.lower(getattr(table.names_table, name_attribute)))
    else:
        extra_languages = (language, ) + extra_languages
    for language in extra_languages:
        names_table = aliased(table.names_table)
        query = query.outerjoin(names_table)
        query = query.filter(names_table.foreign_id == table.id)
        query = query.filter(names_table.local_language_id == language.id)
        order_columns.append(func.lower(getattr(names_table, name_attribute)))
    order_columns.append(table.identifier)
    query = query.order_by(coalesce(*order_columns))
    return query

########NEW FILE########
__FILENAME__ = defaults
""" pokedex.defaults - logic for finding default paths """

import os

def get_default_db_uri_with_origin():
    uri = os.environ.get('POKEDEX_DB_ENGINE', None)
    origin = 'environment'

    if uri is None:
        import pkg_resources
        sqlite_path = pkg_resources.resource_filename('pokedex',
                                                      'data/pokedex.sqlite')
        uri = 'sqlite:///' + sqlite_path
        origin = 'default'

    return uri, origin

def get_default_index_dir_with_origin():
    index_dir = os.environ.get('POKEDEX_INDEX_DIR', None)
    origin = 'environment'

    if index_dir is None:
        import pkg_resources
        index_dir = pkg_resources.resource_filename('pokedex',
                                                    'data/whoosh-index')
        origin = 'default'

    return index_dir, origin

def get_default_csv_dir_with_origin():
    import pkg_resources
    csv_dir = pkg_resources.resource_filename('pokedex', 'data/csv')
    origin = 'default'

    return csv_dir, origin


def get_default_db_uri():
    return get_default_db_uri_with_origin()[0]

def get_default_index_dir():
    return get_default_index_dir_with_origin()[0]

def get_default_csv_dir():
    return get_default_csv_dir_with_origin()[0]



########NEW FILE########
__FILENAME__ = tabledoc
# Encoding: UTF-8

u"""Automatic documentation generation for pokédex tables

This adds a "dex-table" directive to Sphinx, which works like "autoclass",
but documents Pokédex mapped classes.
"""
# XXX: This assumes all the tables are in pokedex.db.tables

import functools
import textwrap

from docutils import nodes
from docutils.statemachine import ViewList
from sphinx.util.compat import Directive, make_admonition
from sphinx.locale import _
from sphinx.domains.python import PyClasslike
from sphinx.util.docfields import Field, GroupedField, TypedField
from sphinx.ext.autodoc import ClassLevelDocumenter

from sqlalchemy import types
from sqlalchemy.orm.attributes import InstrumentedAttribute
from sqlalchemy.orm.properties import RelationshipProperty
from sqlalchemy.orm import Mapper, configure_mappers
from sqlalchemy.ext.associationproxy import AssociationProxy
from pokedex.db.markdown import MoveEffectPropertyMap, MoveEffectProperty

from pokedex.db import tables, markdown

# Make sure all the backrefs are in place
configure_mappers()


column_to_cls = {}
for cls in tables.mapped_classes:
    for column in cls.__table__.c:
        column_to_cls[column] = cls

class dextabledoc(nodes.Admonition, nodes.Element):
    pass

def visit_todo_node(self, node):
    self.visit_admonition(node)

def depart_todo_node(self, node):
    self.depart_admonition(node)

def column_type_str(column):
    """Extract the type name from a SQLA column
    """
    type_ = column.type
    # We're checking the specific type here: no issubclass
    if type(type_) in (types.Integer, types.SmallInteger):
        return 'int'
    if type(type_) == types.Boolean:
        return 'bool'
    if type(type_) == types.Unicode:
        return u'unicode – %s' % column.info['format']
    if type(type_) == types.UnicodeText:
        return u'unicode – %s' % column.info['format']
    if type(type_) == types.Enum:
        return 'enum: [%s]' % ', '.join(type_.enums)
    if type(type_) == markdown.MarkdownColumn:
        return 'markdown'
    raise ValueError(repr(type_))

common_columns = 'id identifier name'.split()

def column_header(c, class_name=None, transl_name=None, show_type=True,
        relation=None, relation_name=None):
    """Return the column header for the given column"""
    result = []
    if relation_name:
        name = relation_name
    else:
        name = c.name
    if class_name:
        result.append(u'%s.\ **%s**' % (class_name, name))
    else:
        result.append(u'**%s**' % c.name)
    if c.foreign_keys:
        for fk in c.foreign_keys:
            if fk.column in column_to_cls:
                foreign_cls = column_to_cls[fk.column]
                if relation_name and relation_name + '_id' == c.name:
                    result.append(u'(%s →' % c.name)
                elif relation_name:
                    result.append(u'(**%s** →' % c.name)
                else:
                    result.append(u'(→')
                result.append(u':class:`~pokedex.db.tables.%s`.%s)' % (
                        foreign_cls.__name__,
                        fk.column.name
                    ))
                break
    elif show_type:
        result.append(u'(*%s*)' % column_type_str(c))
    if transl_name:
        result.append(u'via *%s*' % transl_name)
    return ' '.join(result)


def with_header(header=None):
    """Decorator that adds a section header if there's a any output

    The decorated function should yield output lines; if there are any the
    header gets added.
    """
    def wrap(func):
        @functools.wraps(func)
        def wrapped(cls, remaining_attrs):
            result = list(func(cls, remaining_attrs))
            if result:
                # Sphinx/ReST doesn't allow "-----" just anywhere :(
                yield u''
                yield u'.. raw:: html'
                yield u''
                yield u'    <hr>'
                yield u''
                if header:
                    yield header + u':'
                    yield u''
                for row in result:
                    yield row
        return wrapped
    return wrap

### Section generation functions

def generate_table_header(cls, remaining_attrs):
    first_line, sep, next_lines = unicode(cls.__doc__).partition(u'\n')
    yield first_line
    for line in textwrap.dedent(next_lines).split('\n'):
        yield line
    yield ''

    yield u'Table name: *%s*' % cls.__tablename__
    try:
        yield u'(single: *%s*)' % cls.__singlename__
    except AttributeError:
        pass
    yield u''

    yield u'Primary key: %s.' % u', '.join(
        u'**%s**' % col.key for col in cls.__table__.primary_key.columns)
    yield u''

def generate_common(cls, remaining_attrs):
    common_col_headers = []
    for c in cls.__table__.c:
        if c.name in common_columns:
            common_col_headers.append(column_header(c, show_type=False))
            remaining_attrs.remove(c.name)
    for translation_class in cls.translation_classes:
        for c in translation_class.__table__.c:
            if c.name in common_columns:
                common_col_headers.append(column_header(c, None,
                        translation_class.__table__.name, show_type=False))
                remaining_attrs.remove(c.name)

    if common_col_headers:
        if len(common_col_headers) > 1:
            common_col_headers[-1] = 'and ' + common_col_headers[-1]
        if len(common_col_headers) > 2:
            separator = u', '
        else:
            separator = u' '
        yield u'Has'
        yield separator.join(common_col_headers) + '.'
        yield u''

@with_header(u'Columns')
def generate_columns(cls, remaining_attrs):
    name = cls.__name__
    for c in [c for c in cls.__table__.c if c.name not in common_columns]:
        remaining_attrs.remove(c.name)
        relation_name = c.name[:-3]
        if c.name.endswith('_id') and relation_name in remaining_attrs:
            relation = getattr(cls, relation_name)
            yield column_header(c, name,
                    relation=relation, relation_name=relation_name)
            remaining_attrs.remove(relation_name)
        else:
            yield column_header(c, name) + ':'
        yield u''
        yield u'  ' + unicode(c.info['description'])
        yield u''

@with_header(u'Internationalized strings')
def generate_strings(cls, remaining_attrs):
    for translation_class in cls.translation_classes:
        for c in translation_class.__table__.c:
            if 'format' in c.info:
                remaining_attrs.discard(c.name)
                remaining_attrs.discard(c.name + '_map')
                if c.name in common_columns:
                    continue
                yield column_header(c, cls.__name__,
                        translation_class.__table__.name)
                yield u''
                yield u'  ' + unicode(c.info['description'])
                yield u''

@with_header(u'Relationships')
def generate_relationships(cls, remaining_attrs):
    def isrelationship(prop):
        return isinstance(prop, InstrumentedAttribute) and isinstance(prop.property, RelationshipProperty)

    for attr_name in sorted(remaining_attrs):
        prop = getattr(cls, attr_name)
        if not isrelationship(prop):
            continue
        rel = prop.property
        yield u'%s.\ **%s**' % (cls.__name__, attr_name)
        class_name = u':class:`~pokedex.db.tables.%s`' % rel.mapper.class_.__name__
        if rel.uselist:
            class_name = u'[%s]' % class_name
        yield u'(→ %s)' % class_name
        if rel.doc:
            yield u''
            yield u'  ' + unicode(rel.doc)
        if rel.secondary is not None:
            yield u''
            yield '  Association table: ``%s``' % rel.secondary
        #if rel.primaryjoin is not None:
        #    yield u''
        #    yield '  Join condition: ``%s``' % rel.primaryjoin
        #    if rel.secondaryjoin is not None:
        #        yield '  , ``%s``' % rel.secondaryjoin
        if rel.order_by:
            yield u''
            yield u'  '
            yield '  Ordered by: ' + u', '.join(
                    u'``%s``' % o for o in rel.order_by)
        yield u''
        remaining_attrs.remove(attr_name)

@with_header(u'Association Proxies')
def generate_associationproxies(cls, remaining_attrs):
    for attr_name in sorted(remaining_attrs):
        prop = getattr(cls, attr_name)
        if isinstance(prop, AssociationProxy):
            yield u'%s.\ **%s**:' % (cls.__name__, attr_name)
            yield '``{prop.remote_attr.key}`` of ``self.{prop.local_attr.key}``'.format(
                    prop=prop)
            '''if 'description' in info:
                yield u''
                yield u'  ' + unicode(info['description'])'''
            yield u''
            remaining_attrs.remove(attr_name)


@with_header(u'Undocumented')
def generate_undocumented(cls, remaining_attrs):
    for c in sorted([c for c in remaining_attrs if isinstance(getattr(cls, c),
            (InstrumentedAttribute, AssociationProxy,
                MoveEffectPropertyMap, MoveEffectProperty))]):
        yield u''
        yield u'%s.\ **%s**' % (cls.__name__, c)
        remaining_attrs.remove(c)

@with_header(None)
def generate_other(cls, remaining_attrs):
    for c in sorted(remaining_attrs):
        yield u''
        member = getattr(cls, c)
        if callable(member):
            yield '.. automethod:: %s.%s' % (cls.__name__, c)
        else:
            yield '.. autoattribute:: %s.%s' % (cls.__name__, c)
        yield u''
    remaining_attrs.clear()


class DexTable(PyClasslike):
    """The actual Sphinx documentation generation whatchamacallit
    """
    doc_field_types = [
        TypedField('field', label='Fields',
            typerolename='obj', typenames=('fieldname', 'type')),
        ]

    def get_signature_prefix(self, sig):
        return ''
        #return u'mapped class '

    def run(self):
        section = nodes.section()
        super_result = super(DexTable, self).run()
        title_text = self.names[0][0]
        section += nodes.title(text=title_text)
        section += super_result
        section['ids'] = ['dex-table-%s' % title_text.lower()]
        return [section]

    def before_content(self):
        name = self.names[0][0]
        for cls in tables.mapped_classes:
            if name == cls.__name__:
                break
        else:
            raise ValueError('Table %s not found' % name)
        table = cls.__table__

        remaining_attrs = set(x for x in dir(cls) if not x.startswith('_'))
        remaining_attrs.difference_update(['metadata', 'translation_classes',
                'add_relationships', 'summary_column'])
        for transl_class in cls.translation_classes:
            remaining_attrs.difference_update([
                    transl_class.relation_name,
                    transl_class.relation_name + '_table',
                    transl_class.relation_name + '_local',
                ])

        generated_content = []  # Just a list of lines!

        generated_content.extend(generate_table_header(cls, remaining_attrs))
        generated_content.extend(generate_common(cls, remaining_attrs))
        generated_content.extend(generate_columns(cls, remaining_attrs))
        generated_content.extend(generate_strings(cls, remaining_attrs))
        generated_content.extend(generate_relationships(cls, remaining_attrs))
        generated_content.extend(generate_associationproxies(cls, remaining_attrs))
        generated_content.extend(generate_undocumented(cls, remaining_attrs))
        generated_content.extend(generate_other(cls, remaining_attrs))

        generated_content.append(u'')
        self.content = ViewList(generated_content + list(self.content))
        return super(DexTable, self).before_content()

    def get_index_text(self, modname, name_cls):
        return '%s (mapped class)' % name_cls[0]

def setup(app):
    app.add_directive('dex-table', DexTable)

    # XXX: Specify that this depends on pokedex.db.tables ...?

########NEW FILE########
__FILENAME__ = formulae
# encoding: utf8
"""Faithful translations of calculations the games make."""
from __future__ import division

from itertools import izip

def nCr(n, r):
    """n-choose-r.

    Thanks for the "compact" solution go to:
    http://stackoverflow.com/questions/2096573/counting-combinations-and-permutations-efficiently
    """

    return reduce(
        lambda x, y: x * y[0] / y[1],
        izip(xrange(n - r + 1, n + 1),
             xrange(1, r + 1)),
        1)


def calculated_stat(base_stat, level, iv, effort, nature=None):
    """Returns the calculated stat -- i.e. the value actually shown in the game
    on a Pokémon's status tab.
    """

    # Remember: this is from C; use floor division!
    stat = (base_stat * 2 + iv + effort // 4) * level // 100 + 5

    if nature:
        stat = int(stat * nature)

    return stat

def calculated_hp(base_stat, level, iv, effort, nature=None):
    """Similar to `calculated_stat`, except with a slightly different formula
    used specifically for HP.
    """

    # Shedinja's base stat of 1 is special; its HP is always 1
    if base_stat == 1:
        return 1

    return (base_stat * 2 + iv + effort // 4) * level // 100 + 10 + level

def earned_exp(base_exp, level):
    """Returns the amount of EXP earned when defeating a Pokémon at the given
    level.
    """

    return base_exp * level // 7

def capture_chance(percent_hp, capture_rate,
                   ball_bonus=10, status_bonus=1,
                   capture_bonus=10, capture_modifier=0):
    """Calculates the chance that a Pokémon will be caught, given its capture
    rate and the percentage of HP it has remaining.

    Bonuses are such that 10 means "unchanged".

    Returns five values: the chance of a capture, then the chance of the ball
    shaking three, two, one, or zero times.  Each of these is a float such that
    0.0 <= n <= 1.0.  Feel free to ignore all but the first.
    """

    # HG/SS Pokéballs modify capture rate rather than the ball bonus
    capture_rate = capture_rate * capture_bonus // 10 + capture_modifier
    if capture_rate < 1:
        capture_rate = 1
    elif capture_rate > 255:
        capture_rate = 255

    # A slight math note:
    # The actual formula uses (3 * max_hp - 2 * curr_hp) / (3 * max_hp)
    # This uses (1 - 2/3 * curr_hp/max_hp)
    # Integer division is taken into account by flooring immediately
    # afterwards, so there should be no appreciable rounding error.
    base_chance = int(
        capture_rate * ball_bonus // 10 * (1 - 2/3 * percent_hp)
    )
    base_chance = base_chance * status_bonus // 10

    # Shake index involves integer sqrt.  Lovely.
    isqrt = lambda x: int(x ** 0.5)
    if not base_chance:
        # This is very silly.  Due to what must be an oversight, it's possible
        # for the above formula to end with a zero chance to catch, which is
        # then thrown blindly into the below denominator.  Luckily, the games'
        # division function is a no-op with a denominator of zero..  which
        # means a base_chance of 0 is effectively a base chance of 1.
        base_chance = 1
    shake_index = 1048560 // isqrt(isqrt(16711680 // base_chance))

    # Iff base_chance < 255, then shake_index < 65535.
    # The Pokémon now has four chances to escape.  The game starts picking
    # random uint16s.  If such a random number is < shake_index, the Pokémon
    # stays in the ball, and it wobbles.  If the number is >= shake_index, the
    # ball breaks open then and there, and the capture fails.
    # If all four are < shake_index, the Pokémon is caught.

    # If shake_index >= 65535, all four randoms must be < it, and the Pokémon
    # will be caught.  Skip hard math
    if shake_index >= 65535:
        return (1.0, 0.0, 0.0, 0.0, 0.0)

    # This brings up an interesting invariant: sum(return_value) == 1.0.
    # Something is guaranteed to happen.

    # Alrighty.  Here's some probability.
    # The chance that a single random uint16 will be < shake_index, thus
    # keeping the Pokémon in the ball, is:
    p = shake_index / 65536

    # Now, the chance for n wobbles is the chance that the Pokémon will stay in
    # the ball for (n-1) attempts, then break out on the nth.
    # The chance of capture is just the chance that the Pokémon stays in the
    # ball for all four tries.

    # There are five cases: captured, wobbled three times, etc.
    return [
        p**4,  # capture
        p**3 * (1 - p),
        p**2 * (1 - p),
        p**1 * (1 - p),
               (1 - p),
    ]

########NEW FILE########
__FILENAME__ = lookup
# encoding: utf8
import os, os.path
import random
import re
import unicodedata

import whoosh
import whoosh.index
import whoosh.query
import whoosh.sorting
from whoosh.support import levenshtein

from pokedex.compatibility import namedtuple

from pokedex.db import connect
import pokedex.db.tables as tables
from pokedex.roomaji import romanize
from pokedex.defaults import get_default_index_dir

__all__ = ['PokedexLookup']


rx_is_number = re.compile('^\d+$')

LookupResult = namedtuple('LookupResult', [
    'object', 'indexed_name', 'name', 'language', 'iso639', 'iso3166', 'exact',
])

class UninitializedIndex(object):
    class UninitializedIndexError(Exception):
        pass

    def __nonzero__(self):
        """Dummy object should identify itself as False."""
        return False

    def __bool__(self):
        """Python 3000 version of the above.  Future-proofing rules!"""
        return False

    def __getattr__(self, *args, **kwargs):
        raise self.UninitializedIndexError(
            "The lookup index does not exist.  Please use `pokedex setup` "
            "or lookup.rebuild_index() to create it."
        )

def LanguageFacet(locale_ident, extra_weights={}):
    """Constructs a sorting function that bubbles results from the current
    locale (given by `locale_ident`) to the top of the list.

    `extra_weights` may be a dictionary of weights which will be factored in.
    Intended for use with spelling corrections, which come along with their own
    weightings.
    """
    def score(searcher, docnum):
        doc = searcher.stored_fields(docnum)
        weight = extra_weights.get(doc['name'], 1.0)

        doc_language = doc['language']
        if doc_language == locale_ident:
            # Bump up names in the current locale
            weight *= 2.0
        elif doc_language == u'roomaji':
            # Given that the Japanese names are the originals, it seems likely
            # that basically anyone might want to look them up.  Boost them a
            # little bit.
            weight *= 1.4

        # Higher weights should come FIRST, but sorts are ascending.  Negate
        # the weight to fix this
        return -weight

    return whoosh.sorting.FunctionFacet(score)

_table_order = dict(
    pokemon_species=1,
    pokemon_forms=1,
    moves=2,
    abilities=3,
    items=4,
    types=5,
    locations=6,
    natures=7,
    conquest_warriors=8,
    conquest_warrior_skills=9,
    conquest_kingdoms=10,
)
def _table_facet_impl(searcher, docnum):
    u"""Implements a sort that puts different "types" of results in a
    relatively natural order: Pokémon first, then moves, etc.
    """
    doc = searcher.stored_fields(docnum)
    return _table_order[doc['table']]
table_facet = whoosh.sorting.FunctionFacet(_table_facet_impl)


class PokedexLookup(object):
    MAX_FUZZY_RESULTS = 10
    MAX_EXACT_RESULTS = 43
    INTERMEDIATE_FACTOR = 2

    # Dictionary of table name => table class.
    # Need the table name so we can get the class from the table name after we
    # retrieve something from the index
    indexed_tables = dict(
        (cls.__tablename__, cls)
        for cls in (
            tables.Ability,
            tables.Item,
            tables.Location,
            tables.Move,
            tables.Nature,
            tables.PokemonSpecies,
            tables.PokemonForm,
            tables.Type,

            tables.ConquestKingdom,
            tables.ConquestWarrior,
            tables.ConquestWarriorSkill,
        )
    )


    def __init__(self, directory=None, session=None):
        """Opens the whoosh index stored in the named directory.  If the index
        doesn't already exist, it will be created.

        `directory`
            Directory containing the index.  Defaults to a location within the
            `pokedex` egg directory.

        `session`
            Used for creating the index and retrieving objects.  Defaults to an
            attempt to connect to the default SQLite database installed by
            `pokedex setup`.
        """

        # By the time this returns, self.index and self.session must be set

        # If a directory was not given, use the default
        if directory is None:
            directory = get_default_index_dir()

        self.directory = directory

        if session:
            self.session = session
        else:
            self.session = connect()

        # Attempt to open or create the index
        if not os.path.exists(directory) or not os.listdir(directory):
            # Directory doesn't exist OR is empty; caller needs to use
            # rebuild_index before doing anything.  Provide a dummy object that
            # complains when used
            self.index = UninitializedIndex()
            return

        # Otherwise, already exists; should be an index!  Bam, done.
        # Note that this will explode if the directory exists but doesn't
        # contain an index; that's a feature
        try:
            self.index = whoosh.index.open_dir(directory, indexname='MAIN')
        except whoosh.index.EmptyIndexError:
            raise IOError(
                "The index directory already contains files.  "
                "Please use a dedicated directory for the lookup index."
            )

    def rebuild_index(self):
        """Creates the index from scratch."""

        schema = whoosh.fields.Schema(
            name=whoosh.fields.ID(sortable=True, stored=True, spelling=True),
            table=whoosh.fields.ID(sortable=True, stored=True),
            row_id=whoosh.fields.ID(sortable=True, stored=True),
            language=whoosh.fields.STORED,
            iso639=whoosh.fields.ID(sortable=True, stored=True),
            iso3166=whoosh.fields.ID(sortable=True, stored=True),
            display_name=whoosh.fields.STORED,  # non-lowercased name
        )

        if os.path.exists(self.directory):
            # create_in() isn't totally reliable, so just nuke whatever's there
            # manually.  Try to be careful about this...
            for f in os.listdir(self.directory):
                if re.match('^_?(MAIN|SPELL)_', f):
                    os.remove(os.path.join(self.directory, f))
        else:
            os.mkdir(self.directory)

        self.index = whoosh.index.create_in(self.directory, schema=schema,
                                                            indexname='MAIN')
        writer = self.index.writer()

        # Index every name in all our tables of interest
        for cls in self.indexed_tables.values():
            q = self.session.query(cls).order_by(cls.id)

            for row in q.yield_per(5):
                row_key = dict(table=unicode(cls.__tablename__),
                               row_id=unicode(row.id))

                def add(name, language, iso639, iso3166):
                    normalized_name = self.normalize_name(name)

                    writer.add_document(
                        name=normalized_name, display_name=name,
                        language=language, iso639=iso639, iso3166=iso3166,
                        **row_key
                    )

                if cls == tables.PokemonForm:
                    name_map = 'pokemon_name_map'
                else:
                    name_map = 'name_map'

                for language, name in getattr(row, name_map, {}).items():
                    if not name:
                        continue

                    add(name, language.identifier,
                              language.iso639,
                              language.iso3166)

                    # Add generated Roomaji too
                    # XXX this should be a first-class concept, not
                    # piggybacking on Japanese
                    if language.identifier == 'ja':
                        add(romanize(name), language.identifier, language.iso639, language.iso3166)

        writer.commit()


    def normalize_name(self, name):
        """Strips irrelevant formatting junk from name input.

        Specifically: everything is lowercased, and accents are removed.
        """
        # http://stackoverflow.com/questions/517923/what-is-the-best-way-to-remove-accents-in-a-python-unicode-string
        # Makes sense to me.  Decompose by Unicode rules, then remove combining
        # characters, then recombine.  I'm explicitly doing it this way instead
        # of testing combining() because Korean characters apparently
        # decompose!  But the results are considered letters, not combining
        # characters, so testing for Mn works well, and combining them again
        # makes them look right.
        nkfd_form = unicodedata.normalize('NFKD', unicode(name))
        name = u"".join(c for c in nkfd_form
                        if unicodedata.category(c) != 'Mn')
        name = unicodedata.normalize('NFC', name)

        name = name.strip()
        name = name.lower()

        return name


    def _apply_valid_types(self, name, valid_types):
        """Combines the enforced `valid_types` with any from the search string
        itself and updates the query.

        For example, a name of 'a,b:foo' and valid_types of b,c will search for
        only `b`s named "foo".

        Returns `(name, merged_valid_types, term)`, where `name` has had any type
        prefix stripped, `merged_valid_types` combines the original
        `valid_types` with the type prefix, and `term` is a query term for
        limited to just the allowed types.  If there are no type restrictions
        at all, `term` will be None.
        """

        # Remove any type prefix (pokemon:133) first
        user_valid_types = []
        if ':' in name:
            prefix_chunk, name = name.split(':', 1)
            name = name.strip()

            prefixes = prefix_chunk.split(',')
            user_valid_types = []
            for prefix in prefixes:
                prefix = prefix.strip()
                if prefix:
                    user_valid_types.append(prefix)
                if prefix == 'pokemon':
                    # When the user says 'pokemon', they really meant both
                    # species & form.
                    user_valid_types.append('pokemon_species')
                    user_valid_types.append('pokemon_form')

        # Merge the valid types together.  Only types that appear in BOTH lists
        # may be used.
        # As a special case, if the user asked for types that are explicitly
        # forbidden, completely ignore what the user requested.
        # And, just to complicate matters: "type" and language need to be
        # considered separately.
        def merge_requirements(func):
            user = filter(func, user_valid_types)
            system = filter(func, valid_types)

            if user and system:
                merged = list(set(user) & set(system))
                if merged:
                    return merged
                else:
                    # No overlap; use the system restrictions
                    return system
            else:
                # One or the other is blank; use the one that's not
                return user or system

        # @foo means language must be foo; otherwise it's a table name
        lang_requirements = merge_requirements(lambda req: req[0] == u'@')
        type_requirements = merge_requirements(lambda req: req[0] != u'@')
        all_requirements = lang_requirements + type_requirements

        # Construct the term
        lang_terms = []
        for lang in lang_requirements:
            # Allow for either country or language codes
            lang_code = lang[1:]
            lang_terms.append(whoosh.query.Term(u'iso639', lang_code))
            lang_terms.append(whoosh.query.Term(u'iso3166', lang_code))

        type_terms = []
        for type in type_requirements:
            table_name = self._parse_table_name(type)

            # Quietly ignore bogus valid_types; more likely to DTRT
            if table_name:
                type_terms.append(whoosh.query.Term(u'table', table_name))

        # Combine both kinds of restriction
        all_terms = []
        if type_terms:
            all_terms.append(whoosh.query.Or(type_terms))
        if lang_terms:
            all_terms.append(whoosh.query.Or(lang_terms))

        return name, all_requirements, whoosh.query.And(all_terms)


    def _parse_table_name(self, name):
        """Takes a singular table name, table name, or table object and returns
        the table name.

        Returns None for a bogus name.
        """
        # Table object
        if hasattr(name, '__tablename__'):
            return getattr(name, '__tablename__')

        # Table name
        for table in self.indexed_tables.values():
            if name in (table.__tablename__, table.__singlename__):
                return table.__tablename__

        # Bogus.  Be nice and return dummy
        return None

    def _whoosh_records_to_results(self, records, exact=True):
        """Converts a list of whoosh's indexed records to LookupResult tuples
        containing database objects.
        """
        # XXX cache me?
        languages = dict(
            (row.identifier, row)
            for row in self.session.query(tables.Language)
        )
        # XXX this 'exact' thing is getting kinda leaky.  would like a better
        # way to handle it, since only lookup() cares about fuzzy results
        seen = {}
        results = []
        for record in records:
            # Skip dupes
            seen_key = record['table'], record['row_id']
            if seen_key in seen:
                continue
            seen[seen_key] = True

            # XXX minimize queries here?
            cls = self.indexed_tables[record['table']]
            obj = self.session.query(cls).get(record['row_id'])

            results.append(LookupResult(object=obj,
                                        indexed_name=record['name'],
                                        name=record['display_name'],
                                        language=languages[record['language']],
                                        iso639=record['iso639'],
                                        iso3166=record['iso3166'],
                                        exact=exact))

        return results

    def _get_current_locale(self):
        """Returns the session's current default language, as an ORM row."""
        return self.session.query(tables.Language).get(
            self.session.default_language_id)


    def lookup(self, input, valid_types=[], exact_only=False):
        """Attempts to find some sort of object, given a name.

        Returns a list of named (object, name, language, iso639, iso3166,
        exact) tuples.  `object` is a database object, `name` is the name under
        which the object was found, `language` and the two isos are the name
        and country codes of the language in which the name was found, and
        `exact` is True iff this was an exact match.

        This function currently ONLY does fuzzy matching if there are no exact
        matches.

        Extraneous whitespace is removed with extreme prejudice.

        Recognizes:
        - Names: "Eevee", "Surf", "Run Away", "Payapa Berry", etc.
        - Foreign names: "Iibui", "Eivui"
        - Fuzzy names in whatever language: "Evee", "Ibui"
        - IDs: "133", "192", "250"
        Also:
        - Type restrictions.  "type:psychic" will only return the type.  This
          is how to make ID lookup useful.  Multiple type specs can be entered
          with commas, as "move,item:1".
        - Language restrictions.  "@fr:charge" will only return Tackle, which
          is called "Charge" in French.  These can be combined with type
          restrictions, e.g., "@fr,move:charge".

        `input`
            Name of the thing to look for.

        `valid_types`
            A list of type or language restrictions, e.g., `['pokemon',
            '@ja']`.  If this is provided, only results in one of the given
            tables will be returned.

        `exact_only`
            If True, only exact matches are returned.  If set to False (the
            default), and the provided `name` doesn't match anything exactly,
            spelling correction will be attempted.
        """

        name = self.normalize_name(input)
        exact = True

        # Pop off any type prefix and merge with valid_types
        name, merged_valid_types, type_term = \
            self._apply_valid_types(name, valid_types)

        # Random lookup
        if name == 'random':
            return self.random_lookup(valid_types=merged_valid_types)

        # Do different things depending what the query looks like
        # Note: Term objects do an exact match, so we don't have to worry about
        # a query parser tripping on weird characters in the input
        try:
            # Let Python try to convert to a number, so 0xff works
            name_as_number = int(name, base=0)
        except ValueError:
            # Oh well
            name_as_number = None

        if '*' in name or '?' in name:
            exact_only = True
            query = whoosh.query.Wildcard(u'name', name)
        elif name_as_number is not None:
            # Don't spell-check numbers!
            exact_only = True
            query = whoosh.query.Term(u'row_id', unicode(name_as_number))
        else:
            # Not an integer
            query = whoosh.query.Term(u'name', name)

        if type_term:
            query = query & type_term


        ### Actual searching
        # Limits; result limits are constants, and intermediate results (before
        # duplicate items are stripped out) are capped at the result limit
        # times another constant.
        # Fuzzy are capped at 10, beyond which something is probably very
        # wrong.  Exact matches -- that is, wildcards and ids -- are far less
        # constrained.
        if exact_only:
            max_results = self.MAX_EXACT_RESULTS
        else:
            max_results = self.MAX_FUZZY_RESULTS

        locale = self._get_current_locale()
        facet = whoosh.sorting.MultiFacet([
            LanguageFacet(locale.identifier),
            table_facet,
            "name",
        ])
        searcher = self.index.searcher()
        results = searcher.search(
            query,
            limit=int(max_results * self.INTERMEDIATE_FACTOR),
            sortedby=facet,
        )

        # Look for some fuzzy matches if necessary
        if not exact_only and not results:
            exact = False
            results = []

            fuzzy_query_parts = []
            fuzzy_weights = {}
            corrector = searcher.corrector('name')
            for suggestion in corrector.suggest(name, limit=max_results):
                fuzzy_query_parts.append(whoosh.query.Term('name', suggestion))
                distance = levenshtein.relative(name, suggestion)
                fuzzy_weights[suggestion] = distance

            if not fuzzy_query_parts:
                # Nothing at all; don't try querying
                return []

            fuzzy_query = whoosh.query.Or(fuzzy_query_parts)
            if type_term:
                fuzzy_query = fuzzy_query & type_term

            sorter = LanguageFacet(
                locale.identifier, extra_weights=fuzzy_weights)
            results = searcher.search(fuzzy_query, sortedby=sorter)

        ### Convert results to db objects
        objects = self._whoosh_records_to_results(results, exact=exact)

        # Truncate and return
        return objects[:max_results]


    def random_lookup(self, valid_types=[]):
        """Returns a random lookup result from one of the provided
        `valid_types`.
        """

        table_names = []
        for valid_type in valid_types:
            table_name = self._parse_table_name(valid_type)
            # Skip anything not recognized.  Could be, say, a language code.
            # XXX The vast majority of Pokémon forms are unnamed and unindexed,
            #     which can produce blank results.  So skip them too for now.
            if table_name and table_name != 'pokemon_forms':
                table_names.append(table_name)

        if not table_names:
            # n.b.: It's possible we got a list of valid_types and none of them
            # were valid, but this function is guaranteed to return
            # *something*, so it politely selects from the entire index instead
            table_names = self.indexed_tables.keys()
            table_names.remove('pokemon_forms')

        # Pick a random table, then pick a random item from it.  Small tables
        # like Type will have an unnatural bias.  The alternative is that a
        # simple search for "random" will do some eight queries, counting the
        # rows in every single indexed table, and that's awful.
        # XXX Can we improve on this, reasonably?
        table_name = random.choice(table_names)
        count = self.session.query(self.indexed_tables[table_name]).count()
        id, = self.session.query(self.indexed_tables[table_name].id) \
            .offset(random.randint(0, count - 1)) \
            .first()

        return self.lookup(unicode(id), valid_types=[table_name])

    def prefix_lookup(self, prefix, valid_types=[]):
        """Returns terms starting with the given exact prefix.

        Type prefixes are recognized, but no other name munging is done.
        """

        # Pop off any type prefix and merge with valid_types
        prefix, merged_valid_types, type_term = \
            self._apply_valid_types(prefix, valid_types)

        query = whoosh.query.Prefix(u'name', self.normalize_name(prefix))

        if type_term:
            query = query & type_term

        locale = self._get_current_locale()
        searcher = self.index.searcher()
        facet = LanguageFacet(locale.identifier)
        results = searcher.search(query, sortedby=facet)  # XXX , limit=self.MAX_LOOKUP_RESULTS)

        return self._whoosh_records_to_results(results)

########NEW FILE########
__FILENAME__ = main
# encoding: utf8
from optparse import OptionParser
import os
import sys

import pokedex.db
import pokedex.db.load
import pokedex.db.tables
import pokedex.lookup
from pokedex import defaults

def main(*argv):
    if len(argv) <= 1:
        command_help()

    command = argv[1]
    args = argv[2:]

    # XXX there must be a better way to get Unicode argv
    # XXX this doesn't work on Windows durp
    enc = sys.stdin.encoding or 'utf8'
    args = [_.decode(enc) for _ in args]

    # Find the command as a function in this file
    func = globals().get("command_%s" % command, None)
    if func:
        func(*args)
    else:
        command_help()

def setuptools_entry():
    main(*sys.argv)


def get_parser(verbose=True):
    """Returns an OptionParser prepopulated with the global options.

    `verbose` is whether or not the options should be verbose by default.
    """
    parser = OptionParser()
    parser.add_option('-e', '--engine', dest='engine_uri', default=None)
    parser.add_option('-i', '--index', dest='index_dir', default=None)
    parser.add_option('-q', '--quiet', dest='verbose', default=verbose, action='store_false')
    parser.add_option('-v', '--verbose', dest='verbose', default=verbose, action='store_true')
    return parser

def get_session(options):
    """Given a parsed options object, connects to the database and returns a
    session.
    """

    engine_uri = options.engine_uri
    got_from = 'command line'

    if engine_uri is None:
        engine_uri, got_from = defaults.get_default_db_uri_with_origin()

    session = pokedex.db.connect(engine_uri)

    if options.verbose:
        print "Connected to database %(engine)s (from %(got_from)s)" \
            % dict(engine=session.bind.url, got_from=got_from)

    return session

def get_lookup(options, session=None, recreate=False):
    """Given a parsed options object, opens the whoosh index and returns a
    PokedexLookup object.
    """

    if recreate and not session:
        raise ValueError("get_lookup() needs an explicit session to regen the index")

    index_dir = options.index_dir
    got_from = 'command line'

    if index_dir is None:
        index_dir, got_from = defaults.get_default_index_dir_with_origin()

    if options.verbose:
        print "Opened lookup index %(index_dir)s (from %(got_from)s)" \
            % dict(index_dir=index_dir, got_from=got_from)

    lookup = pokedex.lookup.PokedexLookup(index_dir, session=session)

    if recreate:
        lookup.rebuild_index()

    return lookup

def get_csv_directory(options):
    """Prints and returns the csv directory we're about to use."""

    if not options.verbose:
        return

    csvdir = options.directory
    got_from = 'command line'

    if csvdir is None:
        csvdir, got_from = defaults.get_default_csv_dir_with_origin()

    print "Using CSV directory %(csvdir)s (from %(got_from)s)" \
        % dict(csvdir=csvdir, got_from=got_from)

    return csvdir


### Plumbing commands

def command_dump(*args):
    parser = get_parser(verbose=True)
    parser.add_option('-d', '--directory', dest='directory', default=None)
    parser.add_option('-l', '--langs', dest='langs', default='en',
        help="Comma-separated list of languages to dump all strings for. "
            "Default is English ('en')")
    options, tables = parser.parse_args(list(args))

    session = get_session(options)
    get_csv_directory(options)

    langs = [l.strip() for l in options.langs.split(',')]

    pokedex.db.load.dump(session, directory=options.directory,
                                  tables=tables,
                                  verbose=options.verbose,
                                  langs=langs)

def command_load(*args):
    parser = get_parser(verbose=True)
    parser.add_option('-d', '--directory', dest='directory', default=None)
    parser.add_option('-D', '--drop-tables', dest='drop_tables', default=False, action='store_true')
    parser.add_option('-r', '--recursive', dest='recursive', default=False, action='store_true')
    parser.add_option('-S', '--safe', dest='safe', default=False, action='store_true',
        help="Do not use backend-specific optimalizations.")
    parser.add_option('-l', '--langs', dest='langs', default=None,
        help="Comma-separated list of extra languages to load, or 'none' for none. "
            "Default is to load 'em all. Example: 'fr,de'")
    options, tables = parser.parse_args(list(args))

    if not options.engine_uri:
        print "WARNING: You're reloading the default database, but not the lookup index.  They"
        print "         might get out of sync, and pokedex commands may not work correctly!"
        print "To fix this, run `pokedex reindex` when this command finishes.  Or, just use"
        print "`pokedex setup` to do both at once."
        print

    if options.langs == 'none':
        langs = []
    elif options.langs is None:
        langs = None
    else:
        langs = [l.strip() for l in options.langs.split(',')]

    session = get_session(options)
    get_csv_directory(options)

    pokedex.db.load.load(session, directory=options.directory,
                                  drop_tables=options.drop_tables,
                                  tables=tables,
                                  verbose=options.verbose,
                                  safe=options.safe,
                                  recursive=options.recursive,
                                  langs=langs)

def command_reindex(*args):
    parser = get_parser(verbose=True)
    options, _ = parser.parse_args(list(args))

    session = get_session(options)
    lookup = get_lookup(options, session=session, recreate=True)

    print "Recreated lookup index."


def command_setup(*args):
    parser = get_parser(verbose=False)
    options, _ = parser.parse_args(list(args))

    options.directory = None

    session = get_session(options)
    get_csv_directory(options)
    pokedex.db.load.load(session, directory=None, drop_tables=True,
                                  verbose=options.verbose,
                                  safe=False)

    lookup = get_lookup(options, session=session, recreate=True)

    print "Recreated lookup index."


def command_status(*args):
    parser = get_parser(verbose=True)
    options, _ = parser.parse_args(list(args))
    options.verbose = True
    options.directory = None

    # Database, and a lame check for whether it's been inited at least once
    session = get_session(options)
    print "  - OK!  Connected successfully."

    if pokedex.db.tables.Pokemon.__table__.exists(session.bind):
        print "  - OK!  Database seems to contain some data."
    else:
        print "  - WARNING: Database appears to be empty."

    # CSV; simple checks that the dir exists
    csvdir = get_csv_directory(options)
    if not os.path.exists(csvdir):
        print "  - ERROR: No such directory!"
    elif not os.path.isdir(csvdir):
        print "  - ERROR: Not a directory!"
    else:
        print "  - OK!  Directory exists."

        if os.access(csvdir, os.R_OK):
            print "  - OK!  Can read from directory."
        else:
            print "  - ERROR: Can't read from directory!"

        if os.access(csvdir, os.W_OK):
            print "  - OK!  Can write to directory."
        else:
            print "  - WARNING: Can't write to directory!  " \
                "`dump` will not work.  You may need to sudo."

    # Index; the PokedexLookup constructor covers most tests and will
    # cheerfully bomb if they fail
    lookup = get_lookup(options, recreate=False)
    print "  - OK!  Opened successfully."


### User-facing commands

def command_lookup(*args):
    parser = get_parser(verbose=False)
    options, words = parser.parse_args(list(args))

    name = u' '.join(words)

    session = get_session(options)
    lookup = get_lookup(options, session=session, recreate=False)

    results = lookup.lookup(name)
    if not results:
        print "No matches."
    elif results[0].exact:
        print "Matched:"
    else:
        print "Fuzzy-matched:"

    for result in results:
        if hasattr(result.object, 'full_name'):
            name = result.object.full_name
        else:
            name = result.object.name

        print "%s: %s" % (result.object.__tablename__, name),
        if result.language:
            print "(%s in %s)" % (result.name, result.language)
        else:
            print


def command_help():
    print u"""pokedex -- a command-line Pokédex interface
usage: pokedex {command} [options...]
Run `pokedex setup` first, or nothing will work!
See https://github.com/veekun/pokedex/wiki/CLI for more documentation.

Commands:
    help                Displays this message.
    lookup [thing]      Look up something in the Pokédex.

System commands:
    load                Load Pokédex data into a database from CSV files.
    dump                Dump Pokédex data from a database into CSV files.
    reindex             Rebuilds the lookup index from the database.
    setup               Combines load and reindex.
    status              No effect, but prints which engine, index, and csv
                        directory would be used for other commands.

Global options:
    -e|--engine=URI     By default, all commands try to use a SQLite database
                        in the pokedex install directory.  Use this option (or
                        a POKEDEX_DB_ENGINE environment variable) to specify an
                        alternate database.
    -i|--index=DIR      By default, all commands try to put the lookup index in
                        the pokedex install directory.  Use this option (or a
                        POKEDEX_INDEX_DIR environment variable) to specify an
                        alternate loction.
    -q|--quiet          Don't print system output.  This is the default for
                        non-system commands and setup.
    -v|--verbose        Print system output.  This is the default for system
                        commands, except setup.

System options:
    -d|--directory=DIR  By default, load and dump will use the CSV files in the
                        pokedex install directory.  Use this option to specify
                        a different directory.

Load options:
    -D|--drop-tables    Drop all tables before loading data.
    -S|--safe           Disable engine-specific optimizations.
    -r|--recursive      Load (and drop) all dependent tables.
    -l|--langs          Load translations for the given languages.
                        By default, all available translations are loaded.
                        Separate multiple languages by a comma (-l en,de,fr)

Dump options:
    -l|--langs          Dump unofficial texts for given languages.
                        By default, English (en) is dumped.
                        Separate multiple languages by a comma (-l en,de,fr)
                        Use 'none' to not dump any unofficial texts.

    Additionally, load and dump accept a list of table names (possibly with
    wildcards) and/or csv fileames as an argument list.
""".encode(sys.getdefaultencoding(), 'replace')

    sys.exit(0)


if __name__ == '__main__':
    main(*sys.argv)

########NEW FILE########
__FILENAME__ = roomaji
# encoding: utf8
"""Provides `romanize()` for romanizing simple Japanese text.

Also provides available romanizers in a dictionary keyed by language identifier.
"""

class Romanizer(object):
    def __init__(self, parent=None, **tables):
        """Create a Romanizer

        parent: A LookupTables to base this one on
        tables: Dicts that become the object's attributes. If a parent is given,
            its tables are used, and updated with the given ones
        """
        self.parent = parent
        if parent:
            self.tables = parent.tables
            for name, table in tables.items():
                # Take a copy -- don't want to clobber the parent's tables
                self.tables[name] = dict(self.tables[name])
                self.tables[name].update(table)
        else:
            self.tables = tables

        for name, table in self.tables.items():
            setattr(self, name, table)

    def romanize(self, string):
        """Convert a string of kana to roomaji."""

        vowels = ['a', 'e', 'i', 'o', 'u', 'y']

        characters = []
        last_kana = None  # Used for ー; っ or ッ; ん or ン
        last_char = None  # Used for small kana combos
        for char in string:
            # Full-width Latin
            if 0xff01 <= ord(char) <= 0xff5e:
                if last_kana == 'sokuon':
                    raise ValueError("Sokuon cannot precede Latin characters.")

                # XXX Real Unicode decomposition would be nicer
                char = chr(ord(char) - 0xff01 + 0x21)
                characters.append(char)

                last_kana = None

            # Small vowel kana
            elif char in self.roomaji_small_kana:
                combo = last_char + char
                if combo in self.roomaji_small_kana_combos:
                    characters[-1] = self.roomaji_small_kana_combos[combo]

                else:
                    # If we don't know what it is...  act dumb and treat it as a
                    # full-size vowel.  Better than bailing, and seems to occur a
                    # lot, e.g. ピィ is "pii"
                    characters.append(self.roomaji_small_kana[char])

                last_kana = self.roomaji_small_kana[char]

            # Youon
            elif char in self.roomaji_youon:
                if not last_kana or last_kana[-1] != 'i' or last_kana == 'i':
                    raise ValueError("Youon must follow an -i sound.")

                # Drop the -i and append the ya/yu/yo sound
                new_sound = self.roomaji_youon[char]
                if last_kana in self.y_drop:
                    # Strip the y-
                    new_char = self.y_drop[last_kana] + new_sound[1:]
                else:
                    new_char = last_kana[:-1] + new_sound

                characters[-1] = new_char
                last_kana = new_char

            # Sokuon
            elif char in (u'っ', u'ッ'):
                # Remember it and double the consonant next time around
                last_kana = 'sokuon'

            # Extended vowel or n
            elif char == u'ー':
                if last_kana[-1] not in vowels:
                    raise ValueError(u"'ー' must follow by a vowel.")
                if last_kana[-1] in self.lengthened_vowels:
                    characters[-1] = characters[-1][:-1]
                    characters.append(self.lengthened_vowels[last_kana[-1]])
                else:
                    characters.append(last_kana[-1])

                last_kana = None

            # Regular ol' kana
            elif char in self.roomaji_kana:
                kana = self.roomaji_kana[char]

                if last_kana == 'sokuon':
                    if kana[0] in vowels:
                        raise ValueError("Sokuon cannot precede a vowel.")

                    characters.append(kana[0])
                elif last_kana == 'n' and kana[0] in vowels:
                    characters.append("'")

                # Special characters fo doubled kana
                if kana[0] in self.lengthened_vowels and characters and kana == characters[-1][-1]:
                    kana = self.lengthened_vowels[kana[0]]
                    characters[-1] = characters[-1][:-1]

                characters.append(kana)

                last_kana = kana

            # Not Japanese?
            else:
                if last_kana == 'sokuon':
                    raise ValueError("Sokuon must be followed by another kana.")

                characters.append(char)

                last_kana = None

            last_char = char


        if last_kana == 'sokuon':
            raise ValueError("Sokuon cannot be the last character.")

        return unicode(''.join(characters))


romanizers = dict()

romanizers['en'] = Romanizer(
    roomaji_kana={
        # Hiragana
        u'あ': 'a',     u'い': 'i',     u'う': 'u',     u'え': 'e',     u'お': 'o',
        u'か': 'ka',    u'き': 'ki',    u'く': 'ku',    u'け': 'ke',    u'こ': 'ko',
        u'さ': 'sa',    u'し': 'shi',   u'す': 'su',    u'せ': 'se',    u'そ': 'so',
        u'た': 'ta',    u'ち': 'chi',   u'つ': 'tsu',   u'て': 'te',    u'と': 'to',
        u'な': 'na',    u'に': 'ni',    u'ぬ': 'nu',    u'ね': 'ne',    u'の': 'no',
        u'は': 'ha',    u'ひ': 'hi',    u'ふ': 'fu',    u'へ': 'he',    u'ほ': 'ho',
        u'ま': 'ma',    u'み': 'mi',    u'む': 'mu',    u'め': 'me',    u'も': 'mo',
        u'や': 'ya',                    u'ゆ': 'yu',                    u'よ': 'yo',
        u'ら': 'ra',    u'り': 'ri',    u'る': 'ru',    u'れ': 're',    u'ろ': 'ro',
        u'わ': 'wa',    u'ゐ': 'wi',                    u'ゑ': 'we',    u'を': 'wo',
                                                                        u'ん': 'n',
        u'が': 'ga',    u'ぎ': 'gi',    u'ぐ': 'gu',    u'げ': 'ge',    u'ご': 'go',
        u'ざ': 'za',    u'じ': 'ji',    u'ず': 'zu',    u'ぜ': 'ze',    u'ぞ': 'zo',
        u'だ': 'da',    u'ぢ': 'ji',    u'づ': 'dzu',   u'で': 'de',    u'ど': 'do',
        u'ば': 'ba',    u'び': 'bi',    u'ぶ': 'bu',    u'べ': 'be',    u'ぼ': 'bo',
        u'ぱ': 'pa',    u'ぴ': 'pi',    u'ぷ': 'pu',    u'ぺ': 'pe',    u'ぽ': 'po',

        # Katakana
        u'ア': 'a',     u'イ': 'i',     u'ウ': 'u',     u'エ': 'e',     u'オ': 'o',
        u'カ': 'ka',    u'キ': 'ki',    u'ク': 'ku',    u'ケ': 'ke',    u'コ': 'ko',
        u'サ': 'sa',    u'シ': 'shi',   u'ス': 'su',    u'セ': 'se',    u'ソ': 'so',
        u'タ': 'ta',    u'チ': 'chi',   u'ツ': 'tsu',   u'テ': 'te',    u'ト': 'to',
        u'ナ': 'na',    u'ニ': 'ni',    u'ヌ': 'nu',    u'ネ': 'ne',    u'ノ': 'no',
        u'ハ': 'ha',    u'ヒ': 'hi',    u'フ': 'fu',    u'ヘ': 'he',    u'ホ': 'ho',
        u'マ': 'ma',    u'ミ': 'mi',    u'ム': 'mu',    u'メ': 'me',    u'モ': 'mo',
        u'ヤ': 'ya',                    u'ユ': 'yu',                    u'ヨ': 'yo',
        u'ラ': 'ra',    u'リ': 'ri',    u'ル': 'ru',    u'レ': 're',    u'ロ': 'ro',
        u'ワ': 'wa',    u'ヰ': 'wi',                    u'ヱ': 'we',    u'ヲ': 'wo',
                                                                        u'ン': 'n',
        u'ガ': 'ga',    u'ギ': 'gi',    u'グ': 'gu',    u'ゲ': 'ge',    u'ゴ': 'go',
        u'ザ': 'za',    u'ジ': 'ji',    u'ズ': 'zu',    u'ゼ': 'ze',    u'ゾ': 'zo',
        u'ダ': 'da',    u'ヂ': 'ji',    u'ヅ': 'dzu',   u'デ': 'de',    u'ド': 'do',
        u'バ': 'ba',    u'ビ': 'bi',    u'ブ': 'bu',    u'ベ': 'be',    u'ボ': 'bo',
        u'パ': 'pa',    u'ピ': 'pi',    u'プ': 'pu',    u'ペ': 'pe',    u'ポ': 'po',
                                        u'ヴ': 'vu',
    },

    roomaji_youon={
        # Hiragana
        u'ゃ': 'ya',                    u'ゅ': 'yu',                    u'ょ': 'yo',

        # Katakana
        u'ャ': 'ya',                    u'ュ': 'yu',                    u'ョ': 'yo',
    },

    # XXX If romanize() ever handles hiragana, it will need to make sure that the
    # preceding character was a katakana
    # This does not include every small kana combination, but should include every
    # one used in a Pokémon name.  An exhaustive list would be..  very long
    roomaji_small_kana={
        u'ァ': 'a',     u'ィ': 'i',     u'ゥ': 'u',     u'ェ': 'e',     u'ォ': 'o',
    },
    roomaji_small_kana_combos={
        # These are, by the way, fairly arbitrary.  "shi xi" to mean "sy" is
        # particularly weird, but it seems to be what GF intends

        # Simple vowel replacement
                        u'ウィ': 'wi',  u'ウゥ': 'wu',  u'ウェ': 'we',  u'ウォ': 'wo',
        u'ヴァ': 'va',  u'ヴィ': 'vi',                  u'ヴェ': 've',  u'ヴォ': 'vo',
                                                        u'チェ': 'che',
                                                        u'シェ': 'she',
                                                        u'ジェ': 'je',
        u'テァ': 'tha', u'ティ': 'ti',  u'テゥ': 'thu', u'テェ': 'tye', u'テォ': 'tho',
        u'デァ': 'dha', u'ディ': 'di',  u'デゥ': 'dhu', u'デェ': 'dye', u'デォ': 'dho',
        u'ファ': 'fa',  u'フィ': 'fi',  u'ホゥ': 'hu',  u'フェ': 'fe',  u'フォ': 'fo',

        # Not so much
        u'シィ': 'sy',
        u'ミィ': 'my',
        u'ビィ': 'by',
        u'ピィ': 'py',
    },
    lengthened_vowels={},
    y_drop={'chi': 'ch', 'shi': 'sh', 'ji': 'j'},
)

romanizers['cs'] = Romanizer(parent=romanizers['en'],
    roomaji_kana={
        u'し': u'ši', u'ち': u'či', u'つ': u'cu',
        u'や': u'ja', u'ゆ': u'ju', u'よ': u'jo',
        u'じ': u'dži', u'ぢ': u'dži',
        u'シ': u'ši', u'チ': u'či', u'ツ': u'cu',
        u'ヤ': u'ja', u'ユ': u'ju', u'ヨ': 'jo',
        u'ジ': u'dži', u'ヂ': u'dži',
    },
    roomaji_youon={
        u'ゃ': 'ja', u'ゅ': 'ju', u'ょ': 'jo',
        u'ャ': 'ja', u'ュ': 'ju', u'ョ': 'jo',
    },
    roomaji_small_kana_combos={
        u'チェ': u'če', u'シェ': u'še', u'ジェ': u'dže',
        u'テェ': u'tje', u'デェ': u'dje',
        u'シィ': u'sí', u'ミィ': u'mí', u'ビィ': u'bí', u'ピィ': u'pí',
    },
    lengthened_vowels={'a': u'á', 'e': u'é', 'i': u'í', 'o': u'ó', 'u': u'ú'},
    y_drop={u'či': u'č', u'ši': u'š', u'dži': u'dž', u'ni': u'ňj'},
)

def romanize(string, lang='en'):
    """Convert a string of kana to roomaji."""

    # Get the correct romanizer; fall back to English
    romanizer = romanizers.get(lang, 'en')

    # Romanize away!
    return romanizer.romanize(string)

########NEW FILE########
__FILENAME__ = _pokemon_struct
# encoding: utf8
u"""Defines a construct `pokemon_struct`, containing the structure of a single
Pokémon saved within a game -- often seen as a .pkm file.  This is the same
format sent back and forth over the GTS.
"""

import datetime

from construct import *

# TODO:
# - strings should be validated, going both in and out
# - strings need to pad themselves when being re-encoded
# - strings sometimes need specific padding christ
# - date_met is not optional
# - some way to be more lenient with junk data, or at least
# - higher-level validation; see XXXes below
# - personality indirectly influences IVs due to PRNG use

# The entire gen 4 character table:
character_table = {
    0x0002: u'ぁ',
    0x0003: u'あ',
    0x0004: u'ぃ',
    0x0005: u'い',
    0x0006: u'ぅ',
    0x0007: u'う',
    0x0008: u'ぇ',
    0x0009: u'え',
    0x000a: u'ぉ',
    0x000b: u'お',
    0x000c: u'か',
    0x000d: u'が',
    0x000e: u'き',
    0x000f: u'ぎ',
    0x0010: u'く',
    0x0011: u'ぐ',
    0x0012: u'け',
    0x0013: u'げ',
    0x0014: u'こ',
    0x0015: u'ご',
    0x0016: u'さ',
    0x0017: u'ざ',
    0x0018: u'し',
    0x0019: u'じ',
    0x001a: u'す',
    0x001b: u'ず',
    0x001c: u'せ',
    0x001d: u'ぜ',
    0x001e: u'そ',
    0x001f: u'ぞ',
    0x0020: u'た',
    0x0021: u'だ',
    0x0022: u'ち',
    0x0023: u'ぢ',
    0x0024: u'っ',
    0x0025: u'つ',
    0x0026: u'づ',
    0x0027: u'て',
    0x0028: u'で',
    0x0029: u'と',
    0x002a: u'ど',
    0x002b: u'な',
    0x002c: u'に',
    0x002d: u'ぬ',
    0x002e: u'ね',
    0x002f: u'の',
    0x0030: u'は',
    0x0031: u'ば',
    0x0032: u'ぱ',
    0x0033: u'ひ',
    0x0034: u'び',
    0x0035: u'ぴ',
    0x0036: u'ふ',
    0x0037: u'ぶ',
    0x0038: u'ぷ',
    0x0039: u'へ',
    0x003a: u'べ',
    0x003b: u'ぺ',
    0x003c: u'ほ',
    0x003d: u'ぼ',
    0x003e: u'ぽ',
    0x003f: u'ま',
    0x0040: u'み',
    0x0041: u'む',
    0x0042: u'め',
    0x0043: u'も',
    0x0044: u'ゃ',
    0x0045: u'や',
    0x0046: u'ゅ',
    0x0047: u'ゆ',
    0x0048: u'ょ',
    0x0049: u'よ',
    0x004a: u'ら',
    0x004b: u'り',
    0x004c: u'る',
    0x004d: u'れ',
    0x004e: u'ろ',
    0x004f: u'わ',
    0x0050: u'を',
    0x0051: u'ん',
    0x0052: u'ァ',
    0x0053: u'ア',
    0x0054: u'ィ',
    0x0055: u'イ',
    0x0056: u'ゥ',
    0x0057: u'ウ',
    0x0058: u'ェ',
    0x0059: u'エ',
    0x005a: u'ォ',
    0x005b: u'オ',
    0x005c: u'カ',
    0x005d: u'ガ',
    0x005e: u'キ',
    0x005f: u'ギ',
    0x0060: u'ク',
    0x0061: u'グ',
    0x0062: u'ケ',
    0x0063: u'ゲ',
    0x0064: u'コ',
    0x0065: u'ゴ',
    0x0066: u'サ',
    0x0067: u'ザ',
    0x0068: u'シ',
    0x0069: u'ジ',
    0x006a: u'ス',
    0x006b: u'ズ',
    0x006c: u'セ',
    0x006d: u'ゼ',
    0x006e: u'ソ',
    0x006f: u'ゾ',
    0x0070: u'タ',
    0x0071: u'ダ',
    0x0072: u'チ',
    0x0073: u'ヂ',
    0x0074: u'ッ',
    0x0075: u'ツ',
    0x0076: u'ヅ',
    0x0077: u'テ',
    0x0078: u'デ',
    0x0079: u'ト',
    0x007a: u'ド',
    0x007b: u'ナ',
    0x007c: u'ニ',
    0x007d: u'ヌ',
    0x007e: u'ネ',
    0x007f: u'ノ',
    0x0080: u'ハ',
    0x0081: u'バ',
    0x0082: u'パ',
    0x0083: u'ヒ',
    0x0084: u'ビ',
    0x0085: u'ピ',
    0x0086: u'フ',
    0x0087: u'ブ',
    0x0088: u'プ',
    0x0089: u'ヘ',
    0x008a: u'ベ',
    0x008b: u'ペ',
    0x008c: u'ホ',
    0x008d: u'ボ',
    0x008e: u'ポ',
    0x008f: u'マ',
    0x0090: u'ミ',
    0x0091: u'ム',
    0x0092: u'メ',
    0x0093: u'モ',
    0x0094: u'ャ',
    0x0095: u'ヤ',
    0x0096: u'ュ',
    0x0097: u'ユ',
    0x0098: u'ョ',
    0x0099: u'ヨ',
    0x009a: u'ラ',
    0x009b: u'リ',
    0x009c: u'ル',
    0x009d: u'レ',
    0x009e: u'ロ',
    0x009f: u'ワ',
    0x00a0: u'ヲ',
    0x00a1: u'ン',
    0x00a2: u'０',
    0x00a3: u'１',
    0x00a4: u'２',
    0x00a5: u'３',
    0x00a6: u'４',
    0x00a7: u'５',
    0x00a8: u'６',
    0x00a9: u'７',
    0x00aa: u'８',
    0x00ab: u'９',
    0x00ac: u'Ａ',
    0x00ad: u'Ｂ',
    0x00ae: u'Ｃ',
    0x00af: u'Ｄ',
    0x00b0: u'Ｅ',
    0x00b1: u'Ｆ',
    0x00b2: u'Ｇ',
    0x00b3: u'Ｈ',
    0x00b4: u'Ｉ',
    0x00b5: u'Ｊ',
    0x00b6: u'Ｋ',
    0x00b7: u'Ｌ',
    0x00b8: u'Ｍ',
    0x00b9: u'Ｎ',
    0x00ba: u'Ｏ',
    0x00bb: u'Ｐ',
    0x00bc: u'Ｑ',
    0x00bd: u'Ｒ',
    0x00be: u'Ｓ',
    0x00bf: u'Ｔ',
    0x00c0: u'Ｕ',
    0x00c1: u'Ｖ',
    0x00c2: u'Ｗ',
    0x00c3: u'Ｘ',
    0x00c4: u'Ｙ',
    0x00c5: u'Ｚ',
    0x00c6: u'ａ',
    0x00c7: u'ｂ',
    0x00c8: u'ｃ',
    0x00c9: u'ｄ',
    0x00ca: u'ｅ',
    0x00cb: u'ｆ',
    0x00cc: u'ｇ',
    0x00cd: u'ｈ',
    0x00ce: u'ｉ',
    0x00cf: u'ｊ',
    0x00d0: u'ｋ',
    0x00d1: u'ｌ',
    0x00d2: u'ｍ',
    0x00d3: u'ｎ',
    0x00d4: u'ｏ',
    0x00d5: u'ｐ',
    0x00d6: u'ｑ',
    0x00d7: u'ｒ',
    0x00d8: u'ｓ',
    0x00d9: u'ｔ',
    0x00da: u'ｕ',
    0x00db: u'ｖ',
    0x00dc: u'ｗ',
    0x00dd: u'ｘ',
    0x00de: u'ｙ',
    0x00df: u'ｚ',
    0x00e0: u'à',
    0x00e1: u'！',
    0x00e2: u'？',
    0x00e3: u'、',
    0x00e4: u'。',
    0x00e5: u'…',
    0x00e6: u'・',
    0x00e7: u'／',
    0x00e8: u'「',
    0x00e9: u'」',
    0x00ea: u'『',
    0x00eb: u'』',
    0x00ec: u'（',
    0x00ed: u'）',
    0x00ee: u'♂',
    0x00ef: u'♀',
    0x00f0: u'＋',
    0x00f1: u'ー',
    0x00f2: u'×',
    0x00f3: u'÷',
    0x00f4: u'=',
    0x00f5: u'~',
    0x00f6: u'：',
    0x00f7: u'；',
    0x00f8: u'．',
    0x00f9: u'，',
    0x00fa: u'♠',
    0x00fb: u'♣',
    0x00fc: u'♥',
    0x00fd: u'♦',
    0x00fe: u'★',
    0x00ff: u'◎',
    0x0100: u'○',
    0x0101: u'□',
    0x0102: u'△',
    0x0103: u'◇',
    0x0104: u'＠',
    0x0105: u'♪',
    0x0106: u'%',
    0x0107: u'☀',
    0x0108: u'☁',
    0x0109: u'☂',
    0x010a: u'☃',
    0x010f: u'⤴',
    0x0110: u'⤵',
    0x0112: u'円',
    0x0116: u'✉',
    0x011b: u'←',
    0x011c: u'↑',
    0x011d: u'↓',
    0x011e: u'→',
    0x0120: u'&',
    0x0121: u'0',
    0x0122: u'1',
    0x0123: u'2',
    0x0124: u'3',
    0x0125: u'4',
    0x0126: u'5',
    0x0127: u'6',
    0x0128: u'7',
    0x0129: u'8',
    0x012a: u'9',
    0x012b: u'A',
    0x012c: u'B',
    0x012d: u'C',
    0x012e: u'D',
    0x012f: u'E',
    0x0130: u'F',
    0x0131: u'G',
    0x0132: u'H',
    0x0133: u'I',
    0x0134: u'J',
    0x0135: u'K',
    0x0136: u'L',
    0x0137: u'M',
    0x0138: u'N',
    0x0139: u'O',
    0x013a: u'P',
    0x013b: u'Q',
    0x013c: u'R',
    0x013d: u'S',
    0x013e: u'T',
    0x013f: u'U',
    0x0140: u'V',
    0x0141: u'W',
    0x0142: u'X',
    0x0143: u'Y',
    0x0144: u'Z',
    0x0145: u'a',
    0x0146: u'b',
    0x0147: u'c',
    0x0148: u'd',
    0x0149: u'e',
    0x014a: u'f',
    0x014b: u'g',
    0x014c: u'h',
    0x014d: u'i',
    0x014e: u'j',
    0x014f: u'k',
    0x0150: u'l',
    0x0151: u'm',
    0x0152: u'n',
    0x0153: u'o',
    0x0154: u'p',
    0x0155: u'q',
    0x0156: u'r',
    0x0157: u's',
    0x0158: u't',
    0x0159: u'u',
    0x015a: u'v',
    0x015b: u'w',
    0x015c: u'x',
    0x015d: u'y',
    0x015e: u'z',
    0x015f: u'À',
    0x0160: u'Á',
    0x0161: u'Â',
    0x0163: u'Ä',
    0x0166: u'Ç',
    0x0167: u'È',
    0x0168: u'É',
    0x0169: u'Ê',
    0x016a: u'Ë',
    0x016b: u'Ì',
    0x016c: u'Í',
    0x016d: u'Î',
    0x016e: u'Ï',
    0x0170: u'Ñ',
    0x0171: u'Ò',
    0x0172: u'Ó',
    0x0173: u'Ô',
    0x0175: u'Ö',
    0x0176: u'×',
    0x0178: u'Ù',
    0x0179: u'Ú',
    0x017a: u'Û',
    0x017b: u'Ü',
    0x017e: u'ß',
    0x017f: u'à',
    0x0180: u'á',
    0x0181: u'â',
    0x0183: u'ä',
    0x0186: u'ç',
    0x0187: u'è',
    0x0188: u'é',
    0x0189: u'ê',
    0x018a: u'ë',
    0x018b: u'ì',
    0x018c: u'í',
    0x018d: u'î',
    0x018e: u'ï',
    0x0190: u'ñ',
    0x0191: u'ò',
    0x0192: u'ó',
    0x0193: u'ô',
    0x0195: u'ö',
    0x0196: u'÷',
    0x0198: u'ù',
    0x0199: u'ú',
    0x019a: u'û',
    0x019b: u'ü',
    0x019f: u'Œ',
    0x01a0: u'œ',
    0x01a3: u'ª',
    0x01a4: u'º',
    0x01a5: u'þ',
    0x01a6: u'Þ',
    0x01a7: u'ʳ',
    0x01a8: u'¥',
    0x01a9: u'¡',
    0x01aa: u'¿',
    0x01ab: u'!',
    0x01ac: u'?',
    0x01ad: u',',
    0x01ae: u'.',
    0x01af: u'…',
    0x01b0: u'·',
    0x01b1: u'/',
    0x01b2: u'‘',
    0x01b3: u'\'',
    0x01b3: u'’',
    0x01b4: u'“',
    0x01b5: u'”',
    0x01b6: u'„',
    0x01b7: u'«',
    0x01b8: u'»',
    0x01b9: u'(',
    0x01ba: u')',
    0x01bb: u'♂',
    0x01bc: u'♀',
    0x01bd: u'+',
    0x01be: u'-',
    0x01bf: u'*',
    0x01c0: u'#',
    0x01c1: u'=',
    0x01c2: u'&',
    0x01c3: u'~',
    0x01c4: u':',
    0x01c5: u';',
    0x01c6: u'♠',
    0x01c7: u'♣',
    0x01c8: u'♥',
    0x01c9: u'♦',
    0x01ca: u'★',
    0x01cb: u'◎',
    0x01cc: u'○',
    0x01cd: u'□',
    0x01ce: u'△',
    0x01cf: u'◇',
    0x01d0: u'@',
    0x01d1: u'♪',
    0x01d2: u'%',
    0x01d3: u'☀',
    0x01d4: u'☁',
    0x01d5: u'☂',
    0x01d6: u'☃',
    0x01db: u'⤴',
    0x01dc: u'⤵',
    0x01de: u' ',
    0xe000: u'\n',
    0x25bc: u'\f',
    0x25bd: u'\r',
}

# And the reverse dict, used with str.translate()
inverse_character_table = dict()
for in_, out in character_table.iteritems():
    inverse_character_table[ord(out)] = in_


def LittleEndianBitStruct(*args):
    """Construct's bit structs read a byte at a time in the order they appear,
    reading each bit from most to least significant.  Alas, this doesn't work
    at all for a 32-bit bit field, because the bytes are 'backwards' in
    little-endian files.

    So this acts as a bit struct, but reverses the order of bytes before
    reading/writing, so ALL the bits are read from most to least significant.
    """
    return Buffered(
        BitStruct(*args),
        encoder=lambda s: s[::-1],
        decoder=lambda s: s[::-1],
        resizer=lambda _: _,
    )

class PokemonStringAdapter(Adapter):
    u"""Adapter that encodes/decodes Pokémon-formatted text stored in a regular
    String struct.
    """
    def _decode(self, obj, context):
        decoded_text = obj.decode('utf16')

        # Real string ends at the \uffff character
        if u'\uffff' in decoded_text:
            decoded_text = decoded_text[0:decoded_text.index(u'\uffff')]
            # XXX save "trash bytes" somewhere..?

        return decoded_text.translate(character_table)

    def _encode(self, obj, context):
        #padded_text = (obj + u'\xffff' + '\x00' * 12)
        padded_text = obj
        decoded_text = padded_text.translate(inverse_character_table)
        return decoded_text.encode('utf16')

class DateAdapter(Adapter):
    """Converts between a three-byte string and a Python date.

    Only dates in 2000 or later will work!
    """
    def _decode(self, obj, context):
        if obj == '\x00\x00\x00':
            return None

        y, m, d = (ord(byte) for byte in obj)
        y += 2000
        return datetime.date(y, m, d)

    def _encode(self, obj, context):
        if obj is None:
            return '\x00\x00\x00'

        y, m, d = obj.year - 2000, obj.month, obj.day
        return ''.join(chr(n) for n in (y, m, d))

class PokemonFormAdapter(Adapter):
    """Converts form ids to form names, and vice versa."""
    pokemon_forms = {
        # Unown
        201: 'abcdefghijklmnopqrstuvwxyz!?',

        # Deoxys
        386: ['normal', 'attack', 'defense', 'speed'],

        # Burmy and Wormadam
        412: ['plant', 'sandy', 'trash'],
        413: ['plant', 'sandy', 'trash'],

        # Shellos and Gastrodon
        422: ['west', 'east'],
        423: ['west', 'east'],

        # Rotom
        479: ['normal', 'heat', 'wash', 'frost', 'fan', 'cut'],

        # Giratina
        487: ['altered', 'origin'],

        # Shaymin
        492: ['land', 'sky'],

        # Arceus
        493: [
            'normal', 'fighting', 'flying', 'poison', 'ground', 'rock',
            'bug', 'ghost', 'steel', 'fire', 'water', 'grass',
            'thunder', 'psychic', 'ice', 'dragon', 'dark', '???',
        ],
    }

    def _decode(self, obj, context):
        try:
            forms = self.pokemon_forms[ context['national_id'] ]
        except KeyError:
            return None

        return forms[obj >> 3]

    def _encode(self, obj, context):
        try:
            forms = self.pokemon_forms[ context['national_id'] ]
        except KeyError:
            return None

        return forms.index(obj) << 3



# And here we go.
# Docs: http://projectpokemon.org/wiki/Pokemon_NDS_Structure
pokemon_struct = Struct('pokemon_struct',
    # Header
    ULInt32('personality'),  # XXX aughgh http://bulbapedia.bulbagarden.net/wiki/Personality
    Padding(2),
    ULInt16('checksum'),  # XXX should be checked or calculated

    # Block A
    ULInt16('national_id'),
    ULInt16('held_item_id'),
    ULInt16('original_trainer_id'),
    ULInt16('original_trainer_secret_id'),
    ULInt32('exp'),
    ULInt8('happiness'),
    ULInt8('ability_id'),  # XXX needs to match personality + species
    BitStruct('markings',
        Padding(2),
        Flag('diamond'),
        Flag('star'),
        Flag('heart'),
        Flag('square'),
        Flag('triangle'),
        Flag('circle'),
    ),
    Enum(
        ULInt8('original_country'),
        jp=1,
        us=2,
        fr=3,
        it=4,
        de=5,
        es=7,
        kr=8,
    ),

    # XXX sum cannot surpass 510
    ULInt8('effort_hp'),
    ULInt8('effort_attack'),
    ULInt8('effort_defense'),
    ULInt8('effort_speed'),
    ULInt8('effort_special_attack'),
    ULInt8('effort_special_defense'),

    ULInt8('contest_cool'),
    ULInt8('contest_beauty'),
    ULInt8('contest_cute'),
    ULInt8('contest_smart'),
    ULInt8('contest_tough'),
    ULInt8('contest_sheen'),

    LittleEndianBitStruct('sinnoh_ribbons',
        Padding(4),
        Flag('premier_ribbon'),
        Flag('classic_ribbon'),
        Flag('carnival_ribbon'),
        Flag('festival_ribbon'),
        Flag('blue_ribbon'),
        Flag('green_ribbon'),
        Flag('red_ribbon'),
        Flag('legend_ribbon'),
        Flag('history_ribbon'),
        Flag('record_ribbon'),
        Flag('footprint_ribbon'),
        Flag('gorgeous_royal_ribbon'),
        Flag('royal_ribbon'),
        Flag('gorgeous_ribbon'),
        Flag('smile_ribbon'),
        Flag('snooze_ribbon'),
        Flag('relax_ribbon'),
        Flag('careless_ribbon'),
        Flag('downcast_ribbon'),
        Flag('shock_ribbon'),
        Flag('alert_ribbon'),
        Flag('world_ability_ribbon'),
        Flag('pair_ability_ribbon'),
        Flag('multi_ability_ribbon'),
        Flag('double_ability_ribbon'),
        Flag('great_ability_ribbon'),
        Flag('ability_ribbon'),
        Flag('sinnoh_champ_ribbon'),
    ),

    # Block B
    ULInt16('move1_id'),
    ULInt16('move2_id'),
    ULInt16('move3_id'),
    ULInt16('move4_id'),
    ULInt8('move1_pp'),
    ULInt8('move2_pp'),
    ULInt8('move3_pp'),
    ULInt8('move4_pp'),
    ULInt8('move1_pp_ups'),
    ULInt8('move2_pp_ups'),
    ULInt8('move3_pp_ups'),
    ULInt8('move4_pp_ups'),

    LittleEndianBitStruct('ivs',
        Flag('is_nicknamed'),
        Flag('is_egg'),
        BitField('iv_special_defense', 5),
        BitField('iv_special_attack', 5),
        BitField('iv_speed', 5),
        BitField('iv_defense', 5),
        BitField('iv_attack', 5),
        BitField('iv_hp', 5),
    ),
    LittleEndianBitStruct('hoenn_ribbons',
        Flag('world_ribbon'),
        Flag('earth_ribbon'),
        Flag('national_ribbon'),
        Flag('country_ribbon'),
        Flag('sky_ribbon'),
        Flag('land_ribbon'),
        Flag('marine_ribbon'),
        Flag('effort_ribbon'),
        Flag('artist_ribbon'),
        Flag('victory_ribbon'),
        Flag('winning_ribbon'),
        Flag('champion_ribbon'),
        Flag('tough_ribbon_master'),
        Flag('tough_ribbon_hyper'),
        Flag('tough_ribbon_super'),
        Flag('tough_ribbon'),
        Flag('smart_ribbon_master'),
        Flag('smart_ribbon_hyper'),
        Flag('smart_ribbon_super'),
        Flag('smart_ribbon'),
        Flag('cute_ribbon_master'),
        Flag('cute_ribbon_hyper'),
        Flag('cute_ribbon_super'),
        Flag('cute_ribbon'),
        Flag('beauty_ribbon_master'),
        Flag('beauty_ribbon_hyper'),
        Flag('beauty_ribbon_super'),
        Flag('beauty_ribbon'),
        Flag('cool_ribbon_master'),
        Flag('cool_ribbon_hyper'),
        Flag('cool_ribbon_super'),
        Flag('cool_ribbon'),
    ),
    EmbeddedBitStruct(
        PokemonFormAdapter(BitField('alternate_form', 5)),
        Enum(BitField('gender', 2),
            genderless = 2,
            male = 0,
            female = 1,
        ),
        Flag('fateful_encounter'),
    ),
    BitStruct('shining_leaves',
        Padding(2),
        Flag('crown'),
        Flag('leaf5'),
        Flag('leaf4'),
        Flag('leaf3'),
        Flag('leaf2'),
        Flag('leaf1'),
    ),
    Padding(2),
    ULInt16('pt_egg_location_id'),
    ULInt16('pt_met_location_id'),

    # Block C
    PokemonStringAdapter(String('nickname', 22)),
    Padding(1),
    Enum(ULInt8('original_version'),
        sapphire = 1,
        ruby = 2,
        emerald = 3,
        firered = 4,
        leafgreen = 5,
        heartgold = 7,
        soulsilver = 8,
        diamond = 10,
        pearl = 11,
        platinum = 12,
        orre = 15,
    ),
    LittleEndianBitStruct('sinnoh_contest_ribbons',
        Padding(12),
        Flag('tough_ribbon_master'),
        Flag('tough_ribbon_ultra'),
        Flag('tough_ribbon_great'),
        Flag('tough_ribbon'),
        Flag('smart_ribbon_master'),
        Flag('smart_ribbon_ultra'),
        Flag('smart_ribbon_great'),
        Flag('smart_ribbon'),
        Flag('cute_ribbon_master'),
        Flag('cute_ribbon_ultra'),
        Flag('cute_ribbon_great'),
        Flag('cute_ribbon'),
        Flag('beauty_ribbon_master'),
        Flag('beauty_ribbon_ultra'),
        Flag('beauty_ribbon_great'),
        Flag('beauty_ribbon'),
        Flag('cool_ribbon_master'),
        Flag('cool_ribbon_ultra'),
        Flag('cool_ribbon_great'),
        Flag('cool_ribbon'),
    ),
    Padding(4),

    # Block D
    PokemonStringAdapter(String('original_trainer_name', 16)),
    DateAdapter(String('date_egg_received', 3)),
    DateAdapter(String('date_met', 3)),
    ULInt16('dp_egg_location_id'),
    ULInt16('dp_met_location_id'),
    ULInt8('pokerus'),
    ULInt8('dppt_pokeball'),
    EmbeddedBitStruct(
        Enum(Flag('original_trainer_gender'),
            male = False,
            female = True,
        ),
        BitField('met_at_level', 7),
    ),
    Enum(ULInt8('encounter_type'),
        special = 0,        # egg; pal park; event; honey tree; shaymin
        grass = 2,          # or darkrai
        dialga_palkia = 4,
        cave = 5,           # or giratina or hall of origin
        water = 7,
        building = 9,
        safari_zone = 10,   # includes great marsh
        gift = 12,          # starter; fossil; ingame trade?
        # distortion_world = ???,
        hgss_gift = 24,     # starter; fossil; bebe's eevee  (pt only??)
    ),
    ULInt8('hgss_pokeball'),
    Padding(1),
)

########NEW FILE########
__FILENAME__ = test_database_sanity

import pytest

from sqlalchemy.orm import aliased, joinedload, lazyload
from sqlalchemy.orm.exc import NoResultFound
from sqlalchemy.sql import func

from pokedex.db import connect, tables, util

def test_encounter_slots():
    # Encounters have a version, which has a version group; encounters also
    # have an encounter_slot, which has a version group.  The two version
    # groups should match, universally.
    session = connect()

    version_group_a = aliased(tables.VersionGroup)
    version_group_b = aliased(tables.VersionGroup)

    sanity_q = session.query(tables.Encounter) \
        .join((tables.EncounterSlot, tables.Encounter.slot)) \
        .join((version_group_a, tables.EncounterSlot.version_group)) \
        .join((tables.Version, tables.Encounter.version)) \
        .join((version_group_b, tables.Version.version_group)) \
        .filter(version_group_a.id != version_group_b.id)

    # Encounter slots all match the encounters they belong to
    assert sanity_q.count() == 0

def test_nonzero_autoincrement_ids():
    """Check that autoincrementing ids don't contain zeroes

    MySQL doesn't like these, see e.g. bug #580
    """

    session = connect()
    for cls in tables.mapped_classes:
        if 'id' in cls.__table__.c:
            if cls.__table__.c.id.autoincrement:
                def nonzero_id(cls):
                    with pytest.raises(NoResultFound):
                        util.get(session, cls, id=0)
                nonzero_id.description = "No zero id in %s" % cls.__name__
                yield nonzero_id, cls

def test_unique_form_order():
    """Check that tone PokemonForm.order value isn't used for more species
    """

    session = connect()

    species_by_form_order = {}

    query = session.query(tables.PokemonForm)
    query = query.options(joinedload('pokemon.species'))

    for form in query:
        print form.name
        try:
            previous_species = species_by_form_order[form.order]
        except KeyError:
            species_by_form_order[form.order] = form.species
        else:
            assert previous_species == form.species, (
                "PokemonForm.order == %s is used for %s and %s" % (
                        form.order,
                        species_by_form_order[form.order].name,
                        form.species.name))

def test_default_forms():
    """Check that each pokemon has one default form and each species has one
    default pokemon."""

    session = connect()

    q = session.query(tables.Pokemon)
    q = q.join(tables.PokemonForm)
    q = q.filter(tables.PokemonForm.is_default==True)
    q = q.options(lazyload('*'))
    q = q.group_by(tables.Pokemon)
    q = q.add_columns(func.count(tables.PokemonForm.id))

    for pokemon, num_default_forms in q:
        if num_default_forms == 0:
            raise AssertionError("pokemon %s has no default forms" % pokemon.name)
        elif num_default_forms > 1:
            raise AssertionError("pokemon %s has %d default forms" % (pokemon.name, num_default_forms))

    q = session.query(tables.PokemonSpecies)
    q = q.join(tables.Pokemon)
    q = q.filter(tables.Pokemon.is_default==True)
    q = q.options(lazyload('*'))
    q = q.group_by(tables.PokemonSpecies)
    q = q.add_columns(func.count(tables.Pokemon.id))

    for species, num_default_pokemon in q:
        if num_default_pokemon == 0:
            raise AssertionError("species %s has no default pokemon" % species.name)
        elif num_default_pokemon > 1:
            raise AssertionError("species %s has %d default pokemon" % (species.name, num_default_pokemon))

########NEW FILE########
__FILENAME__ = test_docs
import os
import re

from pokedex.db.tables import mapped_classes

def test_main_tables():
    """Check that tables.py and main-tables.rst are in sync: every table should
    be documented, and every documented table should exist."""

    main_tables_path = os.path.join(os.path.dirname(__file__), '../../doc/main-tables.rst')

    with open(main_tables_path) as f:
        doc_class_names = set(
            re.findall(r'^\.\. dex-table:: (\w+)$', f.read(), re.MULTILINE)
        )

    mapped_class_names = set(cls.__name__ for cls in mapped_classes)

    # EXTRA ITEMS IN THE LEFT SET: tables defined but not documented
    # EXTRA ITEMS IN THE RIGHT SET: tables documented but not defined
    assert mapped_class_names == doc_class_names


########NEW FILE########
__FILENAME__ = test_lookup
# Encoding: UTF-8

from pokedex.tests import *

from pokedex.lookup import PokedexLookup

lookup = PokedexLookup()

@positional_params(
        # Simple lookups
        (u'Eevee',          'pokemon_species',133),
        (u'Scratch',        'moves',        10),
        (u'Master Ball',    'items',        1),
        (u'normal',         'types',        1),
        (u'Run Away',       'abilities',    50),

        # Funny characters
        (u'Mr. Mime',       'pokemon_species', 122),
        (u"Farfetch'd",     'pokemon_species', 83),
        (u'Poké Ball',      'items',           4),

        # Forms
        (u'Rotom',          'pokemon_species', 479),
        (u'Wash Rotom',     'pokemon_forms',   10059),
        (u'East Shellos',   'pokemon_forms',   10039),

        # Other languages
        (u'イーブイ',       'pokemon_species', 133),
        (u'Iibui',          'pokemon_species', 133),
        (u'Eievui',         'pokemon_species', 133),
        (u'이브이',         'pokemon_species', 133),
        (u'伊布',           'pokemon_species', 133),
        (u'Evoli',          'pokemon_species', 133),
    )
def test_exact_lookup(input, table, id):
    results = lookup.lookup(input)
    assert len(results) == 1
    assert results[0].exact == True

    row = results[0].object
    assert row.__tablename__ == table
    assert row.id == id


def test_id_lookup():
    results = lookup.lookup(u'1')
    assert len(results) >= 5
    assert all(result.object.id == 1 for result in results)


def test_multi_lookup():
    results = lookup.lookup(u'Metronome')
    assert len(results) == 2
    assert results[0].exact


def test_type_lookup():
    results = lookup.lookup(u'pokemon:1')
    assert results[0].object.__tablename__ == 'pokemon_species'
    assert len(results) == 1
    assert results[0].object.name == u'Bulbasaur'

    results = lookup.lookup(u'1', valid_types=['pokemon_species'])
    assert results[0].object.name == u'Bulbasaur'


def test_language_lookup():
    # There are two objects named "charge": the move Charge, and the move
    # Tackle, which is called "Charge" in French.
    results = lookup.lookup(u'charge')
    assert len(results) > 1

    results = lookup.lookup(u'@fr:charge')
    assert results[0].iso639 == u'fr'
    assert len(results) == 1
    assert results[0].object.name == u'Tackle'

    results = lookup.lookup(u'charge', valid_types=['@fr'])
    assert results[0].object.name == u'Tackle'

    results = lookup.lookup(u'@fr,move:charge')
    assert results[0].object.name == u'Tackle'

    results = lookup.lookup(u'@fr:charge', valid_types=['move'])
    assert results[0].object.name, u'Tackle'


@positional_params(
        # Regular English names
        (u'chamander',          u'Charmander'),
        (u'pokeball',           u'Poké Ball'),

        # Names with squiggles in them
        (u'farfetchd',          u"Farfetch'd"),
        (u'porygonz',           u'Porygon-Z'),

        # Sufficiently long foreign names
        (u'カクレオ',           u'Kecleon'),
        (u'Yamikrasu',          u'Murkrow'),
    )
def test_fuzzy_lookup(misspelling, name):
    results = lookup.lookup(misspelling)
    first_result = results[0]
    assert first_result.object.name == name


def test_nidoran():
    results = lookup.lookup(u'Nidoran')
    top_names = [result.object.name for result in results[0:2]]
    assert u'Nidoran♂' in top_names
    assert u'Nidoran♀' in top_names


@positional_params(
        (u'pokemon:*meleon',    u'Charmeleon'),
        (u'item:master*',       u'Master Ball'),
        (u'ee?ee',              u'Eevee'),
    )
def test_wildcard_lookup(wildcard, name):
    results = lookup.lookup(wildcard)
    first_result = results[0]
    assert first_result.object.name == name


def test_bare_random():
    for i in range(5):
        results = lookup.lookup(u'random')
        assert len(results) == 1


@positional_params(
        [u'pokemon_species'],
        [u'moves'],
        [u'items'],
        [u'abilities'],
        [u'types'],
    )
def test_qualified_random(table_name):
    results = lookup.lookup(u'random', valid_types=[table_name])
    assert len(results) == 1
    assert results[0].object.__tablename__ == table_name


def test_crash_empty_prefix():
    """Searching for ':foo' used to crash, augh!"""
    results = lookup.lookup(u':Eevee')
    assert results[0].object.name == u'Eevee'

########NEW FILE########
__FILENAME__ = test_media
"""Test the media accessors.

If run directly from the command line, also tests the accessors and the names
of all the media by getting just about everything in a naive brute-force way.
This, of course, takes a lot of time to run.
"""

import pytest

import os
import re

from pokedex.db import tables, connect
from pokedex.util import media

def pytest_addoption(parser):
    group = parser.getgroup("pokedex")
    group.addoption("--media-root", dest="media_root", action="store", default=None,
        help="path to pokedex-media")

def pytest_funcarg__root(request):
    root = request.config.option.media_root
    if not root:
        root = os.path.join(os.path.dirname(__file__), *'../data/media'.split('/'))
        if not media.BaseMedia(root).available:
            raise pytest.skip("Media unavailable")
    return root

session = connect()

path_re = re.compile('^[-a-z0-9./]*$')

def test_totodile(root):
    """Totodile's female sprite -- same as male"""
    totodile = session.query(tables.PokemonSpecies).filter_by(identifier=u'totodile').one()
    accessor = media.PokemonSpeciesMedia(root, totodile)
    assert accessor.sprite() == accessor.sprite(female=True)

def test_chimecho(root):
    """Chimecho's Platinum female backsprite -- diffeent from male"""
    chimecho = session.query(tables.PokemonSpecies).filter_by(identifier=u'chimecho').one()
    accessor = media.PokemonSpeciesMedia(root, chimecho)
    male = accessor.sprite('platinum', back=True, frame=2)
    female = accessor.sprite('platinum', back=True, female=True, frame=2)
    assert male != female

def test_venonat(root):
    """Venonat's shiny Yellow sprite -- same as non-shiny"""
    venonat = session.query(tables.PokemonSpecies).filter_by(identifier=u'venonat').one()
    accessor = media.PokemonSpeciesMedia(root, venonat)
    assert accessor.sprite('yellow') == accessor.sprite('yellow', shiny=True)

def test_arceus_icon(root):
    """Arceus fire-form icon -- same as base icon"""
    arceus = session.query(tables.PokemonSpecies).filter_by(identifier=u'arceus').one()
    accessor = media.PokemonSpeciesMedia(root, arceus)
    fire_arceus = [f for f in arceus.forms if f.form_identifier == 'fire'][0]
    fire_accessor = media.PokemonFormMedia(root, fire_arceus)
    assert accessor.icon() == fire_accessor.icon()

def test_strict_castform(root):
    """Castform rainy form overworld with strict -- unavailable"""
    with pytest.raises(ValueError):
        castform = session.query(tables.PokemonSpecies).filter_by(identifier=u'castform').first()
        rainy_castform = [f for f in castform.forms if f.form_identifier == 'rainy'][0]
        print rainy_castform
        rainy_castform = media.PokemonFormMedia(root, rainy_castform)
        rainy_castform.overworld('up', strict=True)

def test_strict_exeggcute(root):
    """Exeggcutes's female backsprite, with strict -- unavailable"""
    with pytest.raises(ValueError):
        exeggcute = session.query(tables.PokemonSpecies).filter_by(identifier=u'exeggcute').one()
        accessor = media.PokemonSpeciesMedia(root, exeggcute)
        accessor.sprite(female=True, strict=True)



def get_all_filenames(root):
    all_filenames = set()

    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = [dirname for dirname in dirnames if dirname != '.git']
        for filename in filenames:
            path = os.path.join(dirpath, filename)
            assert path_re.match(path), path
            all_filenames.add(path)

    return all_filenames

def hit(filenames, method, *args, **kwargs):
    """
    Run the given accessor method with args & kwargs; if found remove the
    result path from filenames and return True, else return False.
    """
    try:
        medium = method(*args, **kwargs)
        #print 'Hit', medium.relative_path
        assert medium.exists
    except ValueError, e:
        #print 'DNF', e
        return False
    except:
        print 'Error while processing', method, args, kwargs
        raise
    try:
        filenames.remove(medium.path)
    except KeyError:
        pass
    return True

@pytest.mark.skipif("not config.getvalue('all')", reason='`--all` not specified')
def test_get_everything(root, pytestconfig):
    """
    For every the accessor method, loop over the Cartesian products of all
    possible values for its arguments.
    Make sure we get every file in the repo, and that we get a file whenever
    we should.

    Well, there are exceptions of course.
    """
    assert pytestconfig.getvalue('all')

    versions = list(session.query(tables.Version).all())
    versions.append('red-green')

    # We don't have any graphics for Colosseum or XD
    versions.remove(session.query(tables.Version).filter_by(identifier=u'colosseum').one())
    versions.remove(session.query(tables.Version).filter_by(identifier=u'xd').one())

    black = session.query(tables.Version).filter_by(identifier=u'black').one()

    filenames = get_all_filenames(root)

    # Some small stuff first

    for damage_class in session.query(tables.MoveDamageClass).all():
        assert hit(filenames, media.DamageClassMedia(root, damage_class).icon)

    for habitat in session.query(tables.PokemonHabitat).all():
        assert hit(filenames, media.HabitatMedia(root, habitat).icon)

    for shape in session.query(tables.PokemonShape).all():
        assert hit(filenames, media.ShapeMedia(root, shape).icon)

    for item_pocket in session.query(tables.ItemPocket).all():
        assert hit(filenames, media.ItemPocketMedia(root, item_pocket).icon)
        assert hit(filenames, media.ItemPocketMedia(root, item_pocket).icon, selected=True)

    for contest_type in session.query(tables.ContestType).all():
        assert hit(filenames, media.ContestTypeMedia(root, contest_type).icon)

    for elemental_type in session.query(tables.Type).all():
        assert hit(filenames, media.TypeMedia(root, elemental_type).icon)

    # Items
    versions_for_items = [
            None,
            session.query(tables.Version).filter_by(identifier='emerald').one(),
        ]

    for item in session.query(tables.Item).all():
        accessor = media.ItemMedia(root, item)
        assert hit(filenames, accessor.berry_image) or not item.berry
        for rotation in (0, 90, 180, 270):
            assert hit(filenames, accessor.underground, rotation=rotation) or (
                    not item.appears_underground or rotation)
        for version in versions_for_items:
            success = hit(filenames, accessor.sprite, version=version)
            if version is None:
                assert success

    for color in 'red green blue pale prism'.split():
        for big in (True, False):
            accessor = media.UndergroundSphereMedia(root, color=color, big=big)
            assert hit(filenames, accessor.underground)

    for rock_type in 'i ii o o-big s t z'.split():
        accessor = media.UndergroundRockMedia(root, rock_type)
        for rotation in (0, 90, 180, 270):
            success = hit(filenames, accessor.underground, rotation=rotation)
            assert success or rotation

    # Pokemon!
    accessors = []

    accessors.append(media.UnknownPokemonMedia(root))
    accessors.append(media.EggMedia(root))
    manaphy = session.query(tables.PokemonSpecies).filter_by(identifier=u'manaphy').one()
    accessors.append(media.EggMedia(root, manaphy))
    accessors.append(media.SubstituteMedia(root))

    for form in session.query(tables.PokemonForm).all():
        accessors.append(media.PokemonFormMedia(root, form))

    for pokemon in session.query(tables.PokemonSpecies).all():
        accessors.append(media.PokemonSpeciesMedia(root, pokemon))

    for accessor in accessors:
        assert hit(filenames, accessor.footprint) or not accessor.is_proper
        assert hit(filenames, accessor.trozei) or not accessor.is_proper or (
                accessor.introduced_in > 3)
        assert hit(filenames, accessor.cry) or not accessor.is_proper
        assert hit(filenames, accessor.cropped_sprite) or not accessor.is_proper
        for female in (True, False):
            assert hit(filenames, accessor.icon, female=female) or not accessor.is_proper
            assert hit(filenames, accessor.sugimori, female=female) or (
                    not accessor.is_proper or int(accessor.species_id) >= 647)
            for shiny in (True, False):
                for frame in (1, 2):
                    for direction in 'up down left right'.split():
                        assert hit(filenames, accessor.overworld,
                                direction=direction,
                                shiny=shiny,
                                female=female,
                                frame=frame,
                            ) or not accessor.is_proper or (
                                    accessor.introduced_in > 4)
                    for version in versions:
                        for animated in (True, False):
                            for back in (True, False):
                                for color in (None, 'gray', 'gbc'):
                                    success = hit(filenames,
                                            accessor.sprite,
                                            version,
                                            animated=animated,
                                            back=back,
                                            color=color,
                                            shiny=shiny,
                                            female=female,
                                            frame=frame,
                                        )
                                    if (version == black and not animated
                                        and not back and not color and not
                                        shiny and not female and
                                        frame == 1):
                                        # All pokemon are in Black
                                        assert success or not accessor.is_proper
                                    if (str(accessor.species_id) == '1'
                                        and not animated and not color and
                                        frame == 1):
                                        # Bulbasaur is in all versions
                                        assert success

    # Remove exceptions
    exceptions = [os.path.join(root, dirname) for dirname in
            'chrome fonts ribbons'.split()]
    exceptions.append(os.path.join(root, 'items', 'hm-'))
    exceptions = tuple(exceptions)

    unaccessed_filenames = set(filenames)
    for filename in filenames:
        if filename.startswith(exceptions):
            unaccessed_filenames.remove(filename)
        if filename.endswith('-beta.png'):
            unaccessed_filenames.remove(filename)

    if unaccessed_filenames:
        print 'Unaccessed files:'
        for filename in unaccessed_filenames:
            print filename

    assert unaccessed_filenames == set()

    return (not filenames)

########NEW FILE########
__FILENAME__ = test_roomaji
# encoding: utf8

import pokedex.roomaji
from pokedex.tests import positional_params

@positional_params(
        (u'ヤミカラス',         'yamikarasu'),

        # Elongated vowel
        (u'イーブイ',           'iibui'),
        (u'ホーホー',           'hoohoo'),
        (u'ピカチュウ',         u'pikachuu'),

        # Combined characters
        (u'ニャース',           'nyaasu'),
        (u'ジャ',               'ja'),
        (u'ぎゃくてん',         'gyakuten'),
        (u'ウェザーボール',     'wezaabooru'),

        # Special katakana combinations
        (u'ラティアス',         'ratiasu'),
        (u'ウィー',             'wii'),
        (u'セレビィ',           'sereby'),
    )
def test_roomaji(kana, roomaji):
    result = pokedex.roomaji.romanize(kana)
    assert result == roomaji


@positional_params(
        (u'ヤミカラス',         u'jamikarasu'),

        # Elongated vowel
        (u'イーブイ',           u'íbui'),
        (u'ホーホー',           u'hóhó'),
        (u'ピカチュウ',         u'pikačú'),

        # Combined characters
        (u'ニャース',           u'ňjásu'),
        (u'ジャ',              u'dža'),
        (u'ぎゃくてん',         u'gjakuten'),
        (u'ウェザーボール',     u'wezábóru'),

        # Special katakana combinations
        (u'ラティアス',         u'ratiasu'),
        (u'ウィー',             u'wí'),
        (u'セレビィ',           u'serebí'),
    )
def test_roomaji_cs(kana, roomaji):
    result = pokedex.roomaji.romanize(kana, 'cs')
    assert result == roomaji

########NEW FILE########
__FILENAME__ = test_schema
# encoding: utf8

from pokedex.tests import single_params

from sqlalchemy import Column, Integer, String, create_engine
from sqlalchemy.orm import class_mapper, joinedload, sessionmaker
from sqlalchemy.orm.session import Session
from sqlalchemy.ext.declarative import declarative_base

from pokedex.db import tables, markdown
from pokedex.db.multilang import MultilangScopedSession, MultilangSession, \
    create_translation_table

@single_params(*dir(tables))
def test_variable_names(varname):
    """We want pokedex.db.tables to export tables using the class name"""
    table = getattr(tables, varname)
    try:
        if not issubclass(table, tables.TableBase) or table is tables.TableBase:
            return
    except TypeError:
        return
    classname = table.__name__
    if classname and varname[0].isupper():
        assert varname == classname, '%s refers to %s' % (varname, classname)

@single_params(*tables.mapped_classes)
def test_variable_names_2(table):
    """We also want all of the tables exported"""
    assert getattr(tables, table.__name__) is table

def test_class_order():
    """The declarative classes should be defined in alphabetical order.
    Except for Language which should be first.
    """
    class_names = [table.__name__ for table in tables.mapped_classes]
    def key(name):
        return name != 'Language', name
    print [(a,b) for (a,b) in zip(class_names, sorted(class_names, key=key)) if a!=b]
    assert class_names == sorted(class_names, key=key)

def test_i18n_table_creation():
    """Creates and manipulates a magical i18n table, completely independent of
    the existing schema and data.  Makes sure that the expected behavior of the
    various proxies and columns works.
    """
    Base = declarative_base()
    engine = create_engine("sqlite:///:memory:", echo=True)

    Base.metadata.bind = engine

    # Need this for the foreign keys to work!
    class Language(Base):
        __tablename__ = 'languages'
        id = Column(Integer, primary_key=True, nullable=False)
        identifier = Column(String(2), nullable=False, unique=True)

    class Foo(Base):
        __tablename__ = 'foos'
        __singlename__ = 'foo'
        id = Column(Integer, primary_key=True, nullable=False)
        translation_classes = []

    FooText = create_translation_table('foo_text', Foo, 'texts',
        language_class=Language,
        name = Column(String(100)),
    )

    # OK, create all the tables and gimme a session
    Base.metadata.create_all()
    sm = sessionmaker(class_=MultilangSession)
    sess = MultilangScopedSession(sm)

    # Create some languages and foos to bind together
    lang_en = Language(identifier='en')
    sess.add(lang_en)
    lang_jp = Language(identifier='jp')
    sess.add(lang_jp)
    lang_ru = Language(identifier='ru')
    sess.add(lang_ru)

    foo = Foo()
    sess.add(foo)

    # Commit so the above get primary keys filled in, then give the
    # session the language id
    sess.commit()
    # Note that this won't apply to sessions created in other threads, but that
    # ought not be a problem!
    sess.default_language_id = lang_en.id

    # Give our foo some names, as directly as possible
    foo_text = FooText()
    foo_text.foreign_id = foo.id
    foo_text.local_language_id = lang_en.id
    foo_text.name = 'english'
    sess.add(foo_text)

    foo_text = FooText()
    foo_text.foo_id = foo.id
    foo_text.local_language_id = lang_jp.id
    foo_text.name = 'nihongo'
    sess.add(foo_text)

    # Commit!  This will expire all of the above.
    sess.commit()

    ### Test 1: re-fetch foo and check its attributes
    foo = sess.query(Foo).params(_default_language='en').one()

    # Dictionary of language identifiers => names
    assert foo.name_map[lang_en] == 'english'
    assert foo.name_map[lang_jp] == 'nihongo'

    # Default language, currently English
    assert foo.name == 'english'

    sess.expire_all()

    ### Test 2: querying by default language name should work
    foo = sess.query(Foo).filter_by(name='english').one()

    assert foo.name == 'english'

    sess.expire_all()

    ### Test 3: joinedload on the default name should appear to work
    # THIS SHOULD WORK SOMEDAY
    #    .options(joinedload(Foo.name)) \
    foo = sess.query(Foo) \
        .options(joinedload(Foo.texts_local)) \
        .one()

    assert foo.name == 'english'

    sess.expire_all()

    ### Test 4: joinedload on all the names should appear to work
    # THIS SHOULD ALSO WORK SOMEDAY
    #    .options(joinedload(Foo.name_map)) \
    foo = sess.query(Foo) \
        .options(joinedload(Foo.texts)) \
        .one()

    assert foo.name_map[lang_en] == 'english'
    assert foo.name_map[lang_jp] == 'nihongo'

    sess.expire_all()

    ### Test 5: Mutating the dict collection should work
    foo = sess.query(Foo).one()

    foo.name_map[lang_en] = 'different english'
    foo.name_map[lang_ru] = 'new russian'

    sess.commit()

    assert foo.name_map[lang_en] == 'different english'
    assert foo.name_map[lang_ru] == 'new russian'

classes = []
for cls in tables.mapped_classes:
    classes.append(cls)
    classes += cls.translation_classes
@single_params(*classes)
def test_texts(cls):
    """Check DB schema for integrity of text columns & translations.

    Mostly protects against copy/paste oversights and rebase hiccups.
    If there's a reason to relax the tests, do it
    """
    if hasattr(cls, 'local_language') or hasattr(cls, 'language'):
        good_formats = 'markdown plaintext gametext'.split()
        assert_text = '%s is language-specific'
    else:
        good_formats = 'identifier latex'.split()
        assert_text = '%s is not language-specific'
    columns = sorted(cls.__table__.c, key=lambda c: c.name)
    text_columns = []
    for column in columns:
        format = column.info.get('format', None)
        if format is not None:
            if format not in good_formats:
                raise AssertionError(assert_text % column)
            if (format != 'identifier') and (column.name == 'identifier'):
                raise AssertionError('%s: identifier column name/type mismatch' % column)
            if column.info.get('official', None) and format not in 'gametext plaintext':
                raise AssertionError('%s: official text with bad format' % column)
            text_columns.append(column)
        else:
            if isinstance(column.type, tables.Unicode):
                raise AssertionError('%s: text column without format' % column)
        if column.name == 'name' and format != 'plaintext':
            raise AssertionError('%s: non-plaintext name' % column)
        # No mention of English in the description
        assert 'English' not in column.info['description'], column
    # If there's more than one text column in a translation table,
    # they have to be nullable, to support missing translations
    if hasattr(cls, 'local_language') and len(text_columns) > 1:
        for column in text_columns:
            assert column.nullable

@single_params(*tables.mapped_classes)
def test_identifiers_with_names(table):
    """Test that named tables have identifiers
    """
    for translation_class in table.translation_classes:
        if hasattr(translation_class, 'name'):
            assert hasattr(table, 'identifier'), table

########NEW FILE########
__FILENAME__ = test_strings
# Encoding: UTF-8

import pytest
from sqlalchemy.orm.exc import NoResultFound

from pokedex.tests import positional_params

from pokedex.db import tables, connect, util, markdown

connection = connect()

def test_filter():
    q = connection.query(tables.PokemonSpecies).filter(
            tables.PokemonSpecies.name == u"Marowak")
    assert q.one().identifier == 'marowak'

def test_languages():
    q = connection.query(tables.PokemonSpecies).filter(
            tables.PokemonSpecies.name == u"Mightyena")
    pkmn = q.one()
    for lang, name in (
            ('en', u'Mightyena'),
            ('ja', u'グラエナ'),
            ('roomaji', u'Guraena'),
            ('fr', u'Grahyèna'),
        ):
        language = connection.query(tables.Language).filter_by(
                identifier=lang).one()
        assert pkmn.name_map[language] == name

def test_bad_lang():
    with pytest.raises(KeyError):
        q = connection.query(tables.PokemonSpecies).filter(
                tables.PokemonSpecies.name == u"Mightyena")
        pkmn = q.one()
        pkmn.names["identifier of a language that doesn't exist"]

def test_mutating():
    item = connection.query(tables.Item).filter_by(
            identifier=u"jade-orb").one()
    language = connection.query(tables.Language).filter_by(
            identifier=u"de").one()
    item.name_map[language] = u"foo"
    assert item.name_map[language] == "foo"
    item.name_map[language] = u"xyzzy"
    assert item.name_map[language] == "xyzzy"

def test_mutating_default():
    item = connection.query(tables.Item).filter_by(
            identifier=u"jade-orb").one()
    item.name = u"foo"
    assert item.name == "foo"

def test_string_mapping():
    item = connection.query(tables.Item).filter_by(
            identifier=u"jade-orb").one()
    assert len(item.name_map) == len(item.names)
    for lang in item.names:
        assert item.name_map[lang] == item.names[lang].name
        assert lang in item.name_map
    assert "language that doesn't exist" not in item.name_map
    assert tables.Language() not in item.name_map

def test_new_language():
    item = connection.query(tables.Item).filter_by(
            identifier=u"jade-orb").one()
    language = tables.Language()
    language.id = -1
    language.identifier = u'test'
    language.iso639 = language.iso3166 = u'--'
    language.official = False
    connection.add(language)
    item.name_map[language] = u"foo"
    assert item.name_map[language] == "foo"
    assert language in item.name_map
    item.name_map[language] = u"xyzzy"
    assert item.name_map[language] == "xyzzy"

def test_markdown():
    move = connection.query(tables.Move).filter_by(
            identifier=u"thunderbolt").one()
    language = connection.query(tables.Language).filter_by(
            identifier=u"en").one()
    assert '10%' in move.effect.as_text()
    assert '10%' in move.effect_map[language].as_text()
    assert '10%' in move.effect.as_html()
    assert '10%' in move.effect_map[language].as_html()
    assert '10%' in unicode(move.effect)
    assert '10%' in unicode(move.effect_map[language])
    assert '10%' in move.effect.__html__()
    assert '10%' in move.effect_map[language].__html__()

def test_markdown_string():
    en = util.get(connection, tables.Language, 'en')
    md = markdown.MarkdownString('[]{move:thunderbolt} [paralyzes]{mechanic:paralysis} []{form:sky shaymin}. []{pokemon:mewthree} does not exist.', connection, en)
    assert unicode(md) == 'Thunderbolt paralyzes Sky Shaymin. mewthree does not exist.'
    assert md.as_html() == '<p><span>Thunderbolt</span> <span>paralyzes</span> <span>Sky Shaymin</span>. <span>mewthree</span> does not exist.</p>'

    class ObjectTestExtension(markdown.PokedexLinkExtension):
        def object_url(self, category, obj):
            if isinstance(obj, tables.PokemonForm):
                return "%s/%s %s" % (category, obj.form_identifier,
                        obj.species.identifier)
            else:
                return "%s/%s" % (category, obj.identifier)

    class IdentifierTestExtension(markdown.PokedexLinkExtension):
        def identifier_url(self, category, ident):
            return "%s/%s" % (category, ident)

    assert md.as_html(extension=ObjectTestExtension(connection)) == (
            '<p><a href="move/thunderbolt">Thunderbolt</a> <span>paralyzes</span> <a href="form/sky shaymin">Sky Shaymin</a>. <span>mewthree</span> does not exist.</p>')
    assert md.as_html(extension=IdentifierTestExtension(connection)) == (
            '<p><a href="move/thunderbolt">Thunderbolt</a> <a href="mechanic/paralysis">paralyzes</a> <a href="form/sky shaymin">Sky Shaymin</a>. <a href="pokemon/mewthree">mewthree</a> does not exist.</p>')

def markdown_column_params():
    """Check all markdown values

    Scans the database schema for Markdown columns, runs through every value
    in each, and ensures that it's valid Markdown.
    """

    # Move effects have their own special wrappers.  Explicitly test them separately
    yield tables.Move, None, 'effect'
    yield tables.Move, None, 'short_effect'

    for cls in tables.mapped_classes:
        for translation_cls in cls.translation_classes:
            for column in translation_cls.__table__.c:
                if column.info.get('string_getter') == markdown.MarkdownString:
                    yield cls, translation_cls, column.name

@positional_params(*markdown_column_params())
def test_markdown_values(parent_class, translation_class, column_name):
    """Implementation for the above"""
    query = connection.query(parent_class)
    if translation_class:
        query = query.join(translation_class)


    class TestExtension(markdown.PokedexLinkExtension):
        def object_url(self, category, obj):
            "Swallow good links"
            return 'ok'

        def identifier_url(self, category, ident):
            "Only allow mechanic links here (good links handled in object_url)"
            # Note: 'key' is a closed variable that gets set in the loop below
            assert category == 'mechanic', (
                    '%s: unknown link target: {%s:%s}' %
                    (key, category, ident))

    test_extension = TestExtension(connection)

    for item in query:
        for language, md_text in getattr(item, column_name + '_map').items():

            if md_text is None:
                continue

            key = u"Markdown in {0} #{1}'s {2} (lang={3})".format(
                    parent_class.__name__, item.id, column_name, language.identifier)

            text = md_text.as_html(extension=test_extension)

            error_message = u"{0} leaves syntax cruft:\n{1}"
            error_message = error_message.format(key, text)

            assert not any(char in text for char in '[]{}'), error_message

########NEW FILE########
__FILENAME__ = test_translations
# Encoding: UTF-8

import csv

import pytest

from pokedex.db import translations, tables

fake_version_names = (
        'version_id,local_language_id,name',
        '1,0,name1', '2,0,name2', '3,0,name3', '3,1,othername3',
    )

fake_translation_csv = (
        'language_id,table,id,column,source_crc,string',
        '0,Version,1,name,,name1',
        '0,Version,2,name,,name2',
        '0,Version,3,name,,name3',
        '1,Version,3,name,,othername3',
    )

def test_yield_source_csv_messages():
    check_version_message_stream(translations.yield_source_csv_messages(
            tables.Version.names_table,
            tables.Version,
            csv.reader(iter(fake_version_names)),
        ))

def test_yield_guessed_csv_messages():
    check_version_message_stream(translations.yield_guessed_csv_messages(
            iter(fake_translation_csv),
        ))

def test_yield_translation_csv_messages():
    check_version_message_stream(translations.yield_translation_csv_messages(
            iter(fake_translation_csv),
        ))

def check_version_message_stream(messages):
    messages = list(messages)
    assert messages[0].string == 'name1'
    assert messages[1].string == 'name2'
    assert messages[2].string == 'name3'
    assert messages[3].string == 'othername3'
    for message in messages[:3]:
        assert message.language_id == 0
    assert messages[3].language_id == 1
    for id, message in zip((1, 2, 3, 3), messages):
        assert message.merge_key == ('Version', id, 'name'), message.key

def get_messages(*rows):
    return list(translations.yield_translation_csv_messages(iter(rows), True))

def test_merge_translations():
    source = get_messages(
            '0,Table,1,col,,none',
            '0,Table,2,col,,new',
            '0,Table,3,col,,existing',
            '0,Table,4,col,,both',
            '0,Table,5,col,,(gap)',
            '0,Table,6,col,,new-bad',
            '0,Table,7,col,,existing-bad',
            '0,Table,8,col,,both-bad',
            '0,Table,9,col,,new-bad-ex-good',
            '0,Table,10,col,,new-good-ex-bad',
            '0,Table,11,col,,(gap)',
            '0,Table,12,col,,"Numbers: 1, 2, and 003"',
            '0,Table,13,col,,"Numbers: 3, 2, and 001"',
        )
    new = get_messages(
            '0,Table,2,col,%s,new' % translations.crc('new'),
            '0,Table,4,col,%s,new' % translations.crc('both'),
            '0,Table,6,col,%s,new' % translations.crc('----'),
            '0,Table,8,col,%s,new' % translations.crc('----'),
            '0,Table,9,col,%s,new' % translations.crc('----'),
            '0,Table,10,col,%s,new' % translations.crc('new-good-ex-bad'),
            '0,Table,12,col,%s,{num} {num} {num}' % translations.crc('Numbers: {num}, {num}, and {num}'),
            '0,Table,13,col,%s,{num} {num} {num}' % translations.crc('----'),
            '0,Table,100,col,%s,unused' % translations.crc('----'),
        )
    new[-3].number_replacement = True
    new[-3].source = 'Numbers: 1, 2, and 003'
    new[-2].number_replacement = True
    new[-2].source = '----'
    existing = get_messages(
            '0,Table,3,col,%s,existing' % translations.crc('existing'),
            '0,Table,4,col,%s,existing' % translations.crc('both'),
            '0,Table,7,col,%s,existing' % translations.crc('----'),
            '0,Table,8,col,%s,existing' % translations.crc('----'),
            '0,Table,9,col,%s,existing' % translations.crc('new-bad-ex-good'),
            '0,Table,10,col,%s,existing' % translations.crc('----'),
            '0,Table,100,col,%s,unused' % translations.crc('----'),
        )
    expected_list = (
            ('none', None, None),
            ('new', True, 'new'),
            ('existing', True, 'existing'),
            ('both', True, 'new'),
            ('(gap)', None, None),
            ('new-bad', False, 'new'),
            ('existing-bad', False, 'existing'),
            ('both-bad', False, 'new'),
            ('new-bad-ex-good', True, 'existing'),
            ('new-good-ex-bad', True, 'new'),
            ('(gap)', None, None),
            ('Numbers: 1, 2, and 003', True, '1 2 003'),
            ('Numbers: 3, 2, and 001', False, '3 2 001'),
        )
    unused = []
    result_stream = list(translations.merge_translations(source, new, [], existing, unused=unused.append))
    for result, expected in zip(result_stream, expected_list):
        res_src, res_crc, res_str, res_match = result
        exp_src, exp_match, exp_str = expected
        print result, expected
        assert res_src.string == exp_src
        assert res_str == exp_str, (res_str, exp_str)
        if exp_match is None:
            assert res_crc is None
        elif exp_match is True:
            assert res_crc == translations.crc(res_src.string)
        elif exp_match is False:
            assert res_crc == translations.crc('----')
        assert res_match == exp_match
    print 'unused:', unused
    for message in unused:
        assert message.string == 'unused'
        assert message.id == 100

def test_merge():
    check_merge((0, 1, 2, 3))
    check_merge((0, 1), (2, 3))
    check_merge((2, 3), (0, 1))
    check_merge((0, 2), (1, 3))
    check_merge((0, 3), (1, 2))
    check_merge((0, 1), (2, 3), (2, 3))

def check_merge(*sequences):
    merged = list(translations.Merge(*sequences))
    concatenated = [val for seq in sequences for val in seq]
    assert merged == sorted(concatenated)

def test_merge_dynamic_add():
    merge = translations.Merge((1, 2, 3))
    def adder():
        for val in (1, 2, 3):
            yield val
            merge.add_iterator([4])
    merge.add_iterator(adder())
    assert tuple(merge) == (1, 1, 2, 2, 3, 3, 4, 4, 4)

def test_merge_adjacent():
    messages = get_messages(
            '0,Table,1,col,,strA',
            '0,Table,2,col,,strB',
            '0,Table,2,col,,strC',
            '0,Table,2,col,,strB',
            '0,Table,2,col,,strD',
            '0,Table,3,col,,strE',
        )
    result = [m.string for m in translations.merge_adjacent(messages)]
    expected = ['strA', 'strB\n\nstrC\n\nstrD', 'strE']
    assert result == expected

def test_leftjoin():
    check_leftjoin([], [], [], [])
    check_leftjoin([], [1], [], [1])
    check_leftjoin([], [1, 2], [], [1, 2])
    check_leftjoin([1], [], [(1, None)], [])
    check_leftjoin([1], [1], [(1, 1)], [])
    check_leftjoin([1], [2], [(1, None)], [2])
    check_leftjoin([1, 2], [1], [(1, 1), (2, None)], [])
    check_leftjoin([1, 2], [1, 2], [(1, 1), (2, 2)], [])
    check_leftjoin([1], [1, 2], [(1, 1)], [2])
    check_leftjoin([1, 2], [1, 3], [(1, 1), (2, None)], [3])
    check_leftjoin([1, 2, 3], [1, 3], [(1, 1), (2, None), (3, 3)], [])
    check_leftjoin([1, 2, 2, 3], [1, 3], [(1, 1), (2, None), (2, None), (3, 3)], [])
    check_leftjoin([1, 2, 2, 3], [2, 2, 2], [(1, None), (2, 2), (2, 2), (3, None)], [2])

def check_leftjoin(seqa, seqb, expected, expected_unused):
    unused = []
    result = list(translations.leftjoin(seqa, seqb, unused=unused.append))
    assert result == list(expected)
    assert unused == list(expected_unused)

########NEW FILE########
__FILENAME__ = test_util
# Encoding: utf8

import pytest

from pokedex.tests import single_params
from pokedex.db import connect, tables, util

session = connect()

def test_get_item_identifier():
    item = util.get(session, tables.Item, identifier='master-ball')
    assert item.name == 'Master Ball'

def test_get_item_name():
    item = util.get(session, tables.Item, name='Awakening')
    assert item.name == 'Awakening'

def test_get_english_by_identifier():
    language = util.get(session, tables.Language, 'en')
    assert language.name == 'English'

@single_params(*'burmy shaymin unown cresselia'.split())
def test_get_pokemon_identifier(identifier):
    poke = util.get(session, tables.PokemonSpecies, identifier=identifier)
    assert poke.identifier == identifier

@single_params(*'Burmy Shaymin Unown Cresselia'.split())
def test_get_pokemon_name(name):
    poke = util.get(session, tables.PokemonSpecies, name=name)
    assert poke.name == name

@single_params(*'Cheniti Shaymin Zarbi Cresselia'.split())
def test_get_pokemon_name_explicit_language(name):
    french = util.get(session, tables.Language, 'fr')
    poke = util.get(session, tables.PokemonSpecies, name=name, language=french)
    assert poke.name_map[french] == name, poke.name_map[french]

def test_types_french_order():
    french = util.get(session, tables.Language, 'fr')
    types = session.query(tables.Type).filter(tables.Type.id < 10000)
    types = list(util.order_by_name(types, tables.Type, language=french))
    assert types[0].name_map[french] == 'Acier', types[0].name_map[french]
    assert types[-1].name_map[french] == 'Vol', types[-1].name_map[french]

@single_params(*range(1, 10) * 2)
def test_get_pokemon_id(id):
    result = util.get(session, tables.Pokemon, id=id)
    assert result.id == id
    assert result.__tablename__ == 'pokemon'

########NEW FILE########
__FILENAME__ = media

"""Media accessors

All media accessor __init__s take a `root` argument, which should be a path
to the root of the media directory.
Alternatively, `root` can be a custom MediaFile subclass.

Most __init__s take an ORM object as a second argument.

Their various methods take a number of arguments specifying exactly which
file you want (such as the female sprite, backsprite, etc.).
ValueError is raised when the specified file cannot be found.

The accessors use fallbacks: for example Bulbasaur's males and females look the
same, so if you request Bulbasaur's female sprite, it will give you the common
image. Or for a Pokemon without individual form sprites, you will get the
common base sprite. Or for versions witout shiny Pokemon, you will always
get the non-shiny version (that's how shiny Pokemon looked there!).
However arguments such as `animated` don't use fallbacks.
You can set `strict` to True to disable these fallbacks and cause ValueError
to be raised when the exact specific file you asked for is not found. This is
useful for listing non-duplicate sprites, for example.

Use keyword arguments when calling the media-getting methods, unless noted
otherwise.

The returned "file" objects have useful attributes like relative_path,
path, and open().

All images are in the PNG format, except animations (GIF). All sounds are OGGs.
"""

import os
from functools import partial

class MediaFile(object):
    """Represents a file: picture, sound, etc.

    Attributes:
    path_elements: List of directory/file names that make up relative_path
    relative_path: Filesystem path relative to the root
    path: Absolute path to the file

    exists: True if the file exists

    media_available: false if no media is available at the given root.

    open(): Open the file
    """
    def __init__(self, root, *path_elements):
        self.path_elements = path_elements
        self.root = root

    @property
    def relative_path(self):
        return os.path.join(*self.path_elements)

    @property
    def path(self):
        return os.path.join(self.root, *self.path_elements)

    def open(self):
        """Open this file for reading, in the appropriate mode (i.e. binary)
        """
        return open(self.path, 'rb')

    @property
    def exists(self):
        return os.path.exists(self.path)

    @property
    def media_available(self):
        return os.path.isdir(self.root)

    def __eq__(self, other):
        return self.path == other.path

    def __ne__(self, other):
        return self.path != other.path

    def __str__(self):
        return '<Pokedex file %s>' % self.relative_path

class BaseMedia(object):
    def __init__(self, root):
        if isinstance(root, basestring):
            self.file_class = partial(MediaFile, root)
        else:
            self.file_class = root

    @property
    def available(self):
        return self.file_class().media_available

    def from_path_elements(self, path_elements, basename, extension,
            surely_exists=False):
        filename = basename + extension
        path_elements = [self.toplevel_dir] + path_elements + [filename]
        mfile = self.file_class(*path_elements)
        if surely_exists or mfile.exists:
            return mfile
        else:
            raise ValueError('File %s not found' % mfile.path)

class _BasePokemonMedia(BaseMedia):
    toplevel_dir = 'pokemon'
    has_gender_differences = False
    is_species = False
    is_proper = False
    introduced_in = 0

    # Info about of what's inside the pokemon main sprite directories, so we
    # don't have to check directory existence all the time.
    _pokemon_sprite_info = {
            'red-blue': (1, set('back gray'.split())),
            'red-green': (1, set('back gray'.split())),
            'yellow': (1, set('back gray gbc'.split())),
            'gold': (2, set('back shiny'.split())),
            'silver': (2, set('back shiny'.split())),
            'crystal': (2, set('animated back shiny'.split())),
            'ruby-sapphire': (3, set('back shiny'.split())),
            'emerald': (3, set('animated back shiny frame2'.split())),
            'firered-leafgreen': (3, set('back shiny'.split())),
            'diamond-pearl': (4, set('back shiny female frame2'.split())),
            'platinum': (4, set('back shiny female frame2'.split())),
            'heartgold-soulsilver': (4, set('back shiny female frame2'.split())),
            'black-white': (5, set('back shiny female'.split())),
        }

    def __init__(self, root, species_id, form_postfix=None):
        BaseMedia.__init__(self, root)
        self.species_id = str(species_id)
        self.form_postfix = form_postfix

    def _get_file(self, path_elements, extension, strict, surely_exists=False):
        basename = str(self.species_id)
        if self.form_postfix:
            fullname = basename + self.form_postfix
            try:
                return self.from_path_elements(
                        path_elements, fullname, extension,
                        surely_exists=surely_exists)
            except ValueError:
                if strict:
                    raise
        return self.from_path_elements(path_elements, basename, extension,
                surely_exists=surely_exists)

    def sprite(self,
            version='black-white',

            # The media directories are in this order:
            animated=False,
            back=False,
            color=None,
            shiny=False,
            female=False,
            frame=None,

            strict=False,
        ):
        """Get a main sprite sprite for a pokemon.

        Everything except version should be given as a keyword argument.

        Either specify version as an ORM object, or give the version path as
        a string (which is the only way to get 'red-green'). Leave the default
        for the latest version.

        animated: get a GIF animation (currently Crystal & Emerald only)
        back: get a backsprite instead of a front one
        color: can be 'color' (RGBY only) or 'gbc' (Yellow only)
        shiny: get a shiny sprite. In old versions, gives a normal sprite unless
            `strict` is set
        female: get a female sprite instead of male. For pokemon with no sexual
            dimorphism, gets the common sprite unless `strict` is set.
        frame: set to 2 to get the second frame of the animation
            (Emerald, DPP, and HG/SS only)

        If the sprite is not found, raise a ValueError.
        """
        if isinstance(version, basestring):
            version_dir = version
            try:
                generation, info = self._pokemon_sprite_info[version_dir]
            except KeyError:
                raise ValueError('Version directory %s not found', version_dir)
        else:
            version_dir = version.identifier
            try:
                generation, info = self._pokemon_sprite_info[version_dir]
            except KeyError:
                version_group = version.version_group
                version_dir = '-'.join(
                        v.identifier for v in version_group.versions)
                try:
                    generation, info = self._pokemon_sprite_info[version_dir]
                except KeyError:
                    raise ValueError('Version directory %s not found', version_dir)
        if generation < self.introduced_in:
            raise ValueError("Pokemon %s didn't exist in %s" % (
                    self.species_id, version_dir))
        path_elements = ['main-sprites', version_dir]
        if animated:
            if 'animated' not in info:
                raise ValueError("No animated sprites for %s" % version_dir)
            path_elements.append('animated')
            extension = '.gif'
        else:
            extension = '.png'
        if back:
            if version_dir == 'emerald':
                # Emerald backsprites are the same as ruby/sapphire
                if strict:
                    raise ValueError("Emerald uses R/S backsprites")
                if animated:
                    raise ValueError("No animated backsprites for Emerald")
                path_elements[1] = version_dir = 'ruby-sapphire'
            if version_dir == 'crystal' and animated:
                raise ValueError("No animated backsprites for Crystal")
            path_elements.append('back')
        if color == 'gray':
            if 'gray' not in info:
                raise ValueError("No grayscale sprites for %s" % version_dir)
            path_elements.append('gray')
        elif color == 'gbc':
            if 'gbc' not in info:
                raise ValueError("No GBC sprites for %s" % version_dir)
            path_elements.append('gbc')
        elif color:
            raise ValueError("Unknown color scheme: %s" % color)
        if shiny:
            if 'shiny' in info:
                path_elements.append('shiny')
            elif strict:
                raise ValueError("No shiny sprites for %s" % version_dir)
        if female:
            female_sprite = self.has_gender_differences
            # Chimecho's female back frame 2 sprite has one hand in
            # a slightly different pose, in Platinum and HGSS
            # (we have duplicate sprites frame 1, for convenience)
            if self.species_id == '358' and back and version_dir in (
                    'platinum', 'heartgold-soulsilver'):
                female_sprite = True
            female_sprite = female_sprite and 'female' in info
            if female_sprite:
                path_elements.append('female')
            elif strict:
                raise ValueError(
                    'Pokemon %s has no gender differences' % self.species_id)
        if not frame or frame == 1:
            pass
        elif frame == 2:
            if 'frame2' in info:
                path_elements.append('frame%s' % frame)
            else:
                raise ValueError("No frame 2 for %s" % version_dir)
        else:
            raise ValueError("Bad frame %s" % frame)
        return self._get_file(path_elements, extension, strict=strict,
                # Avoid a stat in the common case
                surely_exists=(self.is_species and version_dir == 'black-white'
                    and not back and not female))

    def _maybe_female(self, path_elements, female, strict):
        if female:
            if self.has_gender_differences:
                elements = path_elements + ['female']
                try:
                    return self._get_file(elements, '.png', strict=strict)
                except ValueError:
                    if strict:
                        raise
            elif strict:
                raise ValueError(
                    'Pokemon %s has no gender differences' % self.species_id)
        return self._get_file(path_elements, '.png', strict=strict)

    def icon(self, female=False, strict=False):
        """Get the Pokemon's menu icon"""
        return self._maybe_female(['icons'], female, strict)

    def sugimori(self, female=False, strict=False):
        """Get the Pokemon's official art, drawn by Ken Sugimori"""
        return self._maybe_female(['sugimori'], female, strict)

    def overworld(self,
            direction='down',
            shiny=False,
            female=False,
            frame=1,
            strict=False,
        ):
        """Get an overworld sprite

        direction: 'up', 'down', 'left', or 'right'
        shiny: true for a shiny sprite
        female: true for female sprite (or the common one for both M & F)
        frame: 2 for the second animation frame

        strict: disable fallback for `female`
        """
        path_elements = ['overworld']
        if shiny:
            path_elements.append('shiny')
        if female:
            if self.has_gender_differences:
                path_elements.append('female')
            elif strict:
                raise ValueError('No female overworld sprite')
            else:
                female = False
        path_elements.append(direction)
        if frame and frame > 1:
            path_elements.append('frame%s' % frame)
        try:
            return self._get_file(path_elements, '.png', strict=strict)
        except ValueError:
            if female and not strict:
                path_elements.remove('female')
                return self._get_file(path_elements, '.png', strict=strict)
            else:
                raise

    def footprint(self, strict=False):
        """Get the Pokemon's footprint"""
        return self._get_file(['footprints'], '.png', strict=strict)

    def trozei(self, strict=False):
        """Get the Pokemon's animated Trozei sprite"""
        return self._get_file(['trozei'], '.gif', strict=strict)

    def cry(self, strict=False):
        """Get the Pokemon's cry"""
        return self._get_file(['cries'], '.ogg', strict=strict)

    def cropped_sprite(self, strict=False):
        """Get the Pokemon's cropped sprite"""
        return self._get_file(['cropped'], '.png', strict=strict)

class PokemonFormMedia(_BasePokemonMedia):
    """Media related to a PokemonForm
    """
    is_proper = True

    def __init__(self, root, pokemon_form):
        species_id = pokemon_form.species.id
        if pokemon_form.form_identifier:
            form_postfix = '-' + pokemon_form.form_identifier
        else:
            form_postfix = None
        _BasePokemonMedia.__init__(self, root, species_id, form_postfix)
        self.form = pokemon_form
        species = pokemon_form.species
        self.has_gender_differences = species.has_gender_differences
        self.introduced_in = pokemon_form.version_group.generation_id

class PokemonSpeciesMedia(_BasePokemonMedia):
    """Media related to a PokemonSpecies
    """
    is_species = True
    is_proper = True

    def __init__(self, root, species):
        _BasePokemonMedia.__init__(self, root, species.id)
        self.has_gender_differences = species.has_gender_differences
        self.introduced_in = species.generation_id

class UnknownPokemonMedia(_BasePokemonMedia):
    """Media related to the unknown Pokemon ("?")

    Note that not a lot of files are available for it.
    """
    def __init__(self, root):
        _BasePokemonMedia.__init__(self, root, '0')

class EggMedia(_BasePokemonMedia):
    """Media related to a pokemon egg

    Note that not a lot of files are available for these.

    Give a Manaphy as `species` to get the Manaphy egg.
    """
    def __init__(self, root, species=None):
        if species and species.identifier == 'manaphy':
            postfix = '-manaphy'
        else:
            postfix = None
        _BasePokemonMedia.__init__(self, root, 'egg', postfix)

class SubstituteMedia(_BasePokemonMedia):
    """Media related to the Substitute sprite

    Note that not a lot of files are available for Substitute.
    """
    def __init__(self, root):
        _BasePokemonMedia.__init__(self, root, 'substitute')

class _BaseItemMedia(BaseMedia):
    toplevel_dir = 'items'
    def underground(self, rotation=0):
        """Get the item's sprite as it appears in the Sinnoh underground

        Rotation can be 0, 90, 180, or 270.
        """
        if rotation:
            basename = self.identifier + '-%s' % rotation
        else:
            basename = self.identifier
        return self.from_path_elements(['underground'], basename, '.png')

class ItemMedia(_BaseItemMedia):
    """Media related to an item
    """
    def __init__(self, root, item):
        _BaseItemMedia.__init__(self, root)
        self.item = item
        self.identifier = item.identifier

    def sprite(self, version=None):
        """Get the item's sprite

        If version is not given, use the latest version.
        """
        identifier = self.identifier
        # Handle machines
        # We check the identifier, so that we don't query the machine
        # information for any item.
        if identifier.startswith(('tm', 'hm')):
            try:
                int(identifier[2:])
            except ValueError:
                # Not really a TM/HM
                pass
            else:
                machines = self.item.machines
                if version:
                    try:
                        machine = [
                                m for m in machines
                                if m.version_group == version.version_group
                            ][0]
                    except IndexError:
                        raise ValueError("%s doesn't exist in %s" % (
                                identifier, version.identifier))
                else:
                    # They're ordered, so get the last one
                    machine = machines[-1]
                type_identifier = machine.move.type.identifier
                identifier = identifier[:2] + '-' + type_identifier
        elif identifier.startswith('data-card-'):
            try:
                int(identifier[10:])
            except ValueError:
                # Not a real data card???
                pass
            else:
                identifier = 'data-card'
        if version is not None:
            generation_id = version.generation.id
            if generation_id <= 3 and identifier == 'dowsing-mchn':
                identifier = 'itemfinder'
            try:
                gen = 'gen%s' % generation_id
                return self.from_path_elements([gen], identifier, '.png')
            except ValueError:
                pass
        return self.from_path_elements([], identifier, '.png',
                surely_exists=True)

    def underground(self, rotation=0):
        """Get the item's sprite as it appears in the Sinnoh underground

        Rotation can be 0, 90, 180, or 270.
        """
        if not self.item.appears_underground:
            raise ValueError("%s doesn't appear underground" % self.identifier)
        return super(ItemMedia, self).underground(rotation=rotation)

    def berry_image(self):
        """Get a berry's big sprite
        """
        if not self.item.berry:
            raise ValueError("%s is not a berry" % self.identifier)
        return self.from_path_elements(['berries'], self.identifier, '.png')

class UndergroundRockMedia(_BaseItemMedia):
    """Media related to a rock in the Sinnoh underground

    rock_type can be one of: i, ii, o, o-big, s, t, z
    """
    def __init__(self, root, rock_type):
        _BaseItemMedia.__init__(self, root)
        self.identifier = 'rock-%s' % rock_type

class UndergroundSphereMedia(_BaseItemMedia):
    """Media related to a sphere in the Sinnoh underground

    color can be one of: red, blue, green, pale, prism
    """
    def __init__(self, root, color, big=False):
        _BaseItemMedia.__init__(self, root)
        self.identifier = '%s-sphere' % color
        if big:
            self.identifier += '-big'

class _SimpleIconMedia(BaseMedia):
    def __init__(self, root, thing):
        BaseMedia.__init__(self, root)
        self.identifier = thing.identifier

    def icon(self):
        return self.from_path_elements([], self.identifier, '.png')

class DamageClassMedia(_SimpleIconMedia):
    toplevel_dir = 'damage-classes'

class HabitatMedia(_SimpleIconMedia):
    toplevel_dir = 'habitats'

class ShapeMedia(_SimpleIconMedia):
    toplevel_dir = 'shapes'

class ItemPocketMedia(_SimpleIconMedia):
    toplevel_dir = 'item-pockets'
    def icon(self, selected=False):
        if selected:
            return self.from_path_elements(
                    ['selected'], self.identifier, '.png')
        else:
            return self.from_path_elements([], self.identifier, '.png')

class _LanguageIconMedia(_SimpleIconMedia):
    def icon(self, lang='en'):
        return self.from_path_elements([lang], self.identifier, '.png')

class ContestTypeMedia(_LanguageIconMedia):
    toplevel_dir = 'contest-types'

class TypeMedia(_LanguageIconMedia):
    toplevel_dir = 'types'

''' XXX: No accessors for:
chrome
fonts
ribbons
'''

########NEW FILE########
__FILENAME__ = __main__
import sys

import pokedex.main

pokedex.main.main(*sys.argv)

########NEW FILE########
__FILENAME__ = add-bw-locations
#!/usr/bin/env python2
"""
This is an unmaintained one-shot script, only included in the repo for
reference.
"""

from codecs import open

from pokedex.db import connect, identifier_from_name
from pokedex.db.tables import Language
from pokedex.db.tables import Location, LocationGameIndex

session = connect()

en = session.query(Language).filter_by(identifier='en').one() # English
ja = session.query(Language).filter_by(identifier='ja').one() # Japanese

with open("bw-location-names-en", "r", "utf-8") as f:
    en_names = [line.rstrip("\n") for line in f]
with open("bw-location-names-kanji", "r", "utf-8") as f:
    ja_names = [line.rstrip("\n") for line in f]

locations = {}
for i, name in enumerate(zip(en_names, ja_names)):
    if i == 0:
        continue

    en_name, ja_name = name
    if not en_name:
        continue

    if name in locations:
        loc = locations[name]
    else:
        loc = Location()
        if en_name:
            loc.name_map[en] = en_name
        if ja_name:
            loc.name_map[ja] = ja_name
        loc.region_id = 5 # Unova
        loc.identifier = identifier_from_name(en_name)

        locations[name] = loc

    lgi = LocationGameIndex()
    lgi.location = loc
    lgi.generation_id = 5 # Gen 5
    lgi.game_index = i

    session.add(loc)
    session.add(lgi)

session.commit()

########NEW FILE########
__FILENAME__ = disambiguate-location-identifiers
# Encoding: UTF-8
"""Automatically disambiguate location identifiers

This is an unmaintained one-shot script, only included in the repo for reference.


Disambiguates identifiers that aren't unique, Routes and Sea Routes, and
generic names like 'villa' or 'game corner' that could appear in future
generations again.

Does this by prepending the region name, and if that isn't enough, appends
numbers.
"""

import sys
import re
from collections import defaultdict

from pokedex.db import connect, tables

ambiguous_re = re.compile(r'^(sea-)?route-\d+$')

ambiguous_set = set('foreign-building game-corner global-terminal lighthouse '
    'restaurant flower-shop cycle-shop cafe shopping-mall villa'.split())

def main(*argv):
    session = connect()

    location_dict = defaultdict(list)
    for location in session.query(tables.Location).order_by(tables.Location.id):
        location_dict[location.identifier].append(location)

    changes = False
    for identifier, locations in sorted(location_dict.items()):
        disambiguate = any((
                len(locations) > 1,
                ambiguous_re.match(identifier),
                identifier in ambiguous_set,
            ))
        print len(locations), ' *'[disambiguate], identifier,
        if disambiguate:
            changes = True
            print u'→'.encode('utf-8'),
            by_region = defaultdict(list)
            for location in locations:
                if location.region:
                    by_region[location.region.identifier].append(location)
                else:
                    by_region[None].append(location)
            for region_identifier, region_locations in by_region.items():
                if region_identifier:
                    new_identifier = '%s-%s' % (region_identifier, identifier)
                else:
                    # No change
                    new_identifier = identifier
                if len(region_locations) == 1:
                    location = region_locations[0]
                    # The region was enough
                    print new_identifier,
                    location.identifier = new_identifier
                else:
                    # Need to number the locations :(
                    for i, location in enumerate(region_locations, start=1):
                        numbered_identifier = '%s-%s' % (new_identifier, i)
                        print numbered_identifier,
                        location.identifier = numbered_identifier
        print

    if changes:
        if argv and argv[0] == '--commit':
            session.commit()
            print 'Committed'
        else:
            print 'Run with --commit to commit changes'
    else:
        print 'No changes needed'


if __name__ == '__main__':
    main(*sys.argv[1:])
########NEW FILE########
__FILENAME__ = fill-pokemon_form_generations
# Encoding: UTF-8
"""Fill the pokemon_form_generations table

This is an unmaintained one-shot script, only included in the repo for reference.


"""


from sqlalchemy.sql import exists, func
from sqlalchemy.orm import lazyload, eagerload, eagerload_all
from sqlalchemy import and_, or_, not_

from pokedex.db import connect, tables, load

session = connect()

session.query(tables.PokemonFormGeneration).delete()

generations = list(session.query(tables.Generation).order_by(
        tables.Generation.id))

q = session.query(tables.PokemonForm)
q = q.options(eagerload_all('pokemon', 'species'))
q = q.order_by(tables.PokemonForm.order)

form_orders = dict(
    unown=list('abcdefghijklmnopqrstuvwxyz') + ['exclamation', 'question'],

    deoxys=['normal', 'attack', 'defense', 'speed'],

    burmy=['plant', 'sandy', 'trash'],
    wormadam=['plant', 'sandy', 'trash'],

    shellos=['west', 'east'],
    gastrodon=['west', 'east'],

    rotom=[None, 'heat', 'wash', 'frost', 'fan', 'mow'],

    giratina=['altered', 'origin'],

    shaymin=['land', 'sky'],

    castform=[None, 'sunny', 'rainy', 'snowy'],
    basculin=['red-striped', 'blue-striped'],
    darmanitan=['standard', 'zen'],
    deerling=['spring', 'summer', 'autumn', 'winter'],
    sawsbuck=['spring', 'summer', 'autumn', 'winter'],
    meloetta=['aria', 'pirouette'],
    genesect=[None, 'douse', 'shock', 'burn', 'chill'],
    cherrim=['overcast', 'sunshine'],
)

arceus = {4: '''normal fighting flying poison ground rock bug ghost steel
    unknown fire water grass electric psychic ice dragon dark'''.split()}
arceus[5] = list(arceus[4])
arceus[5].remove('unknown')

for form in q:
    species_ident = form.species.identifier
    form_ident = form.form_identifier
    is_default = form.is_default and form.pokemon.is_default
    print form_ident, species_ident
    for gen in generations:
        game_index = None
        if gen.id >= form.version_group.generation_id:
            if gen.id < 4:
                # forms not really implemented yet
                if species_ident == 'pichu':
                    if is_default:
                        game_index = 0
                    else:
                        continue
                elif species_ident in ('unown', 'castform'):
                    lst = form_orders[species_ident]
                    game_index = lst.index(form_ident)
                elif species_ident == 'deoxys':
                    game_index = 0
                elif is_default:
                    game_index = 0
            else:
                try:
                    lst = form_orders[species_ident]
                except KeyError:
                    if species_ident == 'pichu' and form_ident == 'spiky-eared':
                        if gen.id == 4:
                            game_index = 1
                        else:
                            continue
                    elif species_ident == 'cherrim':
                        if gen.id < 5:
                            if is_default:
                                game_index = 0
                            else:
                                continue
                        else:
                            lst = ['overcast', 'sunshine']
                            game_index = lst.index(form_ident)
                    elif species_ident == 'castform':
                        if gen.id < 5:
                            if is_default:
                                game_index = 0
                            else:
                                continue
                        else:
                            lst = [None, 'sunny', 'rainy', 'snowy']
                            game_index = lst.index(form_ident)
                    elif species_ident == 'arceus':
                        if gen.id >= 5 and form_ident == 'unknown':
                            continue
                        else:
                            lst = arceus[gen.id]
                            game_index = lst.index(form_ident)
                    elif form.is_default and form.pokemon.is_default:
                        game_index = 0
                    else:
                        raise AssertionError()
                else:
                    game_index = lst.index(form_ident)
            obj = tables.PokemonFormGeneration(form=form, generation=gen,
                    game_index=game_index)
            session.add(obj)

q = session.query(tables.PokemonFormGeneration)
for species in session.query(tables.PokemonSpecies).options(
        eagerload_all('forms', 'pokemon_form_generations')):
    if len(species.forms) > 1:
        print species.name
    for gen in generations:
        if len(species.forms) == 1:
            pfg = q.get((species.forms[0].id, gen.id))
            assert pfg is None or pfg.game_index == 0
            continue
        forms = [(q.get((f.id, gen.id)), f) for f in species.forms if q.get((f.id, gen.id))]
        forms = [(pfg.game_index, f) for pfg, f in forms if pfg]
        if forms:
            forms.sort()
            pl = ["%s=%s" % (gi, f.form_identifier) for gi, f in forms]
            print '   ', gen.id, ' '.join(pl)

load.dump(session, tables=['pokemon_form_generations'])
print "Dumped to CSV, rolling back transaction"
session.rollback()

########NEW FILE########
__FILENAME__ = gen_iii_tutors
from struct import Struct
from sys import argv

max_pokemon = 411  # Gen III indices are a Gen-I-esque mess past Celebi

# I got the first fifteen from FR by looking at tutor NPCs' scripts.  I got the
# full list from Emerald by searching for the first fifteen; the list starts at
# 0x61500C.
moves = ['mega-punch', 'swords-dance', 'mega-kick', 'body-slam', 'double-edge',
    'counter', 'seismic-toss', 'mimic', 'metronome', 'softboiled',
    'dream-eater', 'thunder-wave', 'explosion', 'rock-slide', 'substitute',

    # Emerald only
    'dynamicpunch', 'rollout', 'psych-up', 'snore', 'icy-wind', 'endure',
    'mud-slap', 'ice-punch', 'swagger', 'sleep-talk', 'swift', 'defense-curl',
    'thunderpunch', 'fire-punch', 'fury-cutter']

query_template = """
insert into pokemon_moves (pokemon_id, version_group_id, move_id,
  pokemon_move_method_id, level, "order") values (
    (select pokemon_id from pokemon_game_indices where version_id={version}
     and game_index={game_index}),
    {version_group},
    (select id from moves where identifier='{move}'),
    3, 0, null
);
"""

version_constants = {
    'POKEMON FIRE': {
        'version_id': 10,
        'version_group_id': 7,
        'offset': 0x459B80,
        'moves': 15
    },

    'POKEMON LEAF': {
        'version_id': 11,
        'version_group_id': 7,
        'offset': 0x4595A0,
        'moves': 15
    },

    'POKEMON EMER': {
        'version_id': 9,
        'version_group_id': 6,
        'offset': 0x61504C,
        'moves': 30
    }
}

with open(argv[1], 'rb') as rom:
    rom.seek(0xA0)
    version = rom.read(12).decode('ASCII')
    stuff = version_constants[version]

    # Flags go from least significant bit to most significant, and then to the
    # next byte, just like TMs, but there are few enough of them that we can
    # treat the whole field as a little-endian int.
    if stuff['moves'] == 15:
        flag_struct = Struct('<H')
    else:
        flag_struct = Struct('<L')

    rom.seek(stuff['offset'])

    # For LeafGreen, we want to skip straight to Defense Deoxys.
    if version == 'POKEMON LEAF':
        ids = [410]
        rom.seek(2 * 409, 1)
    else:
        ids = range(1, max_pokemon + 1)

    for pokemon in ids:
        # Read the flags
        flags, = flag_struct.unpack(rom.read(flag_struct.size))
        for move in range(stuff['moves']):
            if flags & 1:
                # This Pokémon learns this move!  Dump an SQL insert.
                print(query_template.format(
                    version=stuff['version_id'],
                    game_index=pokemon,
                    version_group=stuff['version_group_id'],
                    move=moves[move],
                ))
            flags >>= 1

########NEW FILE########
__FILENAME__ = gen_iv_tutors
from struct import Struct

max_pokemon = 507

# As usual, I'm just going to dump SQL
print('begin;')

# Delete the previous tutor data, except for the special tutors that aren't
# stored as flags
print("""delete from pokemon_moves where version_group_id in (9, 10)
    and pokemon_move_method_id=3
    and move_id not in (select id from moves where identifier in
        ('blast-burn', 'hydro-cannon', 'frenzy-plant', 'draco-meteor'));
""")

# A template for inserting a pokemon_moves record.  No internal Pokémon indices
# change between Pt and HG/SS, so we'll just use Pt's.
insert_template = """insert into pokemon_moves (pokemon_id, version_group_id,
    move_id, pokemon_move_method_id, level, "order")
values (
    (select pokemon_id from pokemon_game_indices where game_index={pokemon}
        and version_id=14),
    {version_group}, {move}, 3, 0, null
);
"""

# PLATINUM
move_struct = Struct('<H10x')  # We don't care about shard costs or anything
move_count = 38
moves = []

with open('/tmp/pt/overlay9/overlay_00000005.bin', 'rb') as overlay:
    overlay.seek(0x2FF64)

    for move in range(move_count):
        move = overlay.read(move_struct.size)
        move, = move_struct.unpack(move)
        moves.append(move)

    # The Eggs don't get dummy flags; it goes straight to Attack Deoxys
    for pokemon in range(1, max_pokemon + 1 - 2):
        if pokemon > 493:
            pokemon += 2

        for n, move in enumerate(moves):
            if n % 8 == 0:
                flag_byte, = overlay.read(1)

            if flag_byte & 1:
                print(insert_template.format(
                    pokemon=pokemon,
                    version_group=9,
                    move=move
                ))

            flag_byte >>= 1


# HEARTGOLD
move_struct = Struct('<H2x')  # Costs are just BP so there's less to skip
move_count = 52
moves = []

# The move list for HG is in a compressed overlay, which I decompressed
# beforehand with magical's lzss3.py -- https://github.com/magical/nlzss
with open('/tmp/overlays/overlay_00000001.bin', 'rb') as overlay:
    overlay.seek(0x23AE0)

    for move in range(move_count):
        move = overlay.read(move_struct.size)
        move, = move_struct.unpack(move)
        moves.append(move)

# And the flags are in their own file, padded to an easy length this time.
# This seemed nice at first but it made it harder to find the move list...
flag_struct = Struct('<Q')
with open('/tmp/hg/fsroot/fielddata/wazaoshie/waza_oshie.bin', 'rb') as flagbin:
    for pokemon in range(1, max_pokemon + 1 - 2):
        if pokemon > 493:
            pokemon += 2

        flags, = flag_struct.unpack(flagbin.read(8))

        for n, move in enumerate(moves):
            if flags & 1:
                print(insert_template.format(
                    pokemon=pokemon,
                    version_group=10,
                    move=move
                ))

            flags >>= 1

# Duplicate moves for the Castforms
print("""
insert into pokemon_moves (pokemon_id, version_group_id, move_id,
    pokemon_move_method_id, level, "order")
select p.id, pm.version_group_id, pm.move_id, 3, 0, null
from pokemon_moves pm
join pokemon p on pm.pokemon_id=p.species_id and p.is_default=False
where p.species_id=351 and pm.pokemon_move_method_id=3 and pm.version_group_id in
    (9, 10);
""")

print('commit;')

########NEW FILE########
__FILENAME__ = markdown-identifiers
# Encoding: UTF-8
"""Rewrite markdown links from [Label]{category:thing} to just {category:thing}

There was a version of this script that rewrote stuff from an even earlier
format. Git log should find it without problems.

This is an unmaintained one-shot script, only included in the repo for
reference.

"""

from functools import partial
import sys
import re

from sqlalchemy.orm.exc import MultipleResultsFound
from sqlalchemy.sql.expression import func

from pokedex.db import connect, tables, util

sanity_re = re.compile(ur"^[-A-Za-z0-9 é\[\]{}.%':;,×/()\"|–`—!*♂♀\\]$")

# RE that matches anything that might look like a link
fuzzy_link_re = re.compile(r"""
    \[
        [^]]+
    \]?
    \{
        [^}]+
    \}""", re.VERBOSE)

# Very specific RE that matches links that appear in source Markdown strings
strict_link_re = re.compile(r"""
            \[
                (?P<label>
                    [-A-Za-z 0-9'.]{,30}
                )
            \]
            \{
                (?P<category>
                    [a-z]{,20}
                )
            :
                (?P<target>
                    [-a-z 0-9]{,40}
                )
            \}
        """, re.VERBOSE)

# Format of the resulting links
result_link_re = re.compile(r"""
        ^
            \[
                (?P<label>
                    [^]]*
                )
            \]
            \{
                (?P<category>
                    [a-z]+
                )
            :
                (?P<target>
                    [-a-z0-9]+
                )
            \}
        $
        """, re.VERBOSE)

english_id = 9

manual_replacements = {
        '[Pewter Museum of Science]{location:pewter-city}':
                'the Museum of Science in {location:pewter-city}',
        '[Oreburgh Mining Museum]{location:mining-museum}':
                '{location:mining-museum} in {location:oreburgh-city}',
    }

def is_md_col(column):
    return column.info.get('format') == 'markdown'

def get_replacement(session, entire_text, context, matchobj):
    label = matchobj.group('label')
    category = matchobj.group('category')
    target = matchobj.group('target') or label
    try:
        result = manual_replacements[matchobj.group(0)]
    except KeyError:
        if category == 'mechanic':
            target = target.lower()
            target = target.replace(' ', '-')
            wanted_label = ''
        else:
            query = None
            if category == 'item':
                table = tables.Item
            elif category == 'ability':
                table = tables.Ability
            elif category == 'move':
                table = tables.Move
            elif category == 'type':
                table = tables.Type
            elif category == 'pokemon':
                table = tables.Pokemon
            elif category == 'location':
                table = tables.Location
            else:
                print
                print repr(entire_text)
                print repr(matchobj.group(0))
                raise ValueError('Category %s not implemented' % category)
            try:
                thingy = util.get(session, table, target)
                wanted_label = thingy.name
            except:
                print
                print repr(entire_text)
                print repr(matchobj.group(0))
                raise
        if wanted_label.lower() == label.lower():
            result = "[]{%s:%s}" % (category, target)
        else:
            result = "[%s]{%s:%s}" % (label, category, target)
            if wanted_label:
                print
                print context
                print "%-40s" % matchobj.group(0),
                print '%s != %s' % (label, wanted_label)
        assert result_link_re.match(result), result
    return result

def main(argv):
    session = connect()
    for cls in tables.mapped_classes:
        for translation_class in cls.translation_classes:
            columns = translation_class.__table__.c
            md_columns = [c for c in columns if c.info.get('format') == 'markdown']
            if not md_columns:
                continue
            for row in session.query(translation_class):
                if row.local_language_id != english_id:
                    continue
                for column in md_columns:
                    markdown = getattr(row, column.name)
                    if not markdown:
                        continue
                    text = unicode(markdown)
                    # Make sure everything that remotely looks like a link is one
                    links = fuzzy_link_re.findall(text)
                    if not links:
                        continue
                    for link in links:
                        assert strict_link_re.findall(link), (strict_link_re.findall(link), [link])
                    # Do the replacement
                    context = '%s %s %s' % (translation_class.__name__, row.foreign_id, column.name)
                    replaced = strict_link_re.sub(
                            partial(get_replacement, session, text, context),
                            text,
                        )
                    setattr(row, column.name, replaced)

    if argv and argv[0] == '--commit':
        session.commit()
        print 'Committed'
    else:
        print 'Run with --commit to commit changes'

if __name__ == '__main__':
    main(sys.argv[1:])

########NEW FILE########
__FILENAME__ = migration-i18n
# Encoding: UTF-8

"""Moves/transforms values in CSVs in an ad-hoc way, based mainly on column name

Auto-creates identifiers from names
Auto-creates names from identifiers
Copies IDs for foreign keys
Creates autoincrement-style IDs when missing
Sets text language to 9 (en), except when it sets to 1 (jp)

And looks good doing it!

This is an unmaintained one-shot script, only included in the repo for
reference.
"""

import csv
import re
import os
from StringIO import StringIO
from collections import namedtuple, defaultdict

from sqlalchemy.orm import class_mapper

from pokedex.db import tables, load

english_id = 9
japanese_id = 1

bw_version_group_id = 11

dir = load.get_default_csv_dir()

def tuple_key(tup):
    """Return a sort key for mixed int/string tuples.

    Strings sort first.
    """
    def generator():
        for item in tup:
            try:
                yield (1, int(item))
            except ValueError:
                yield (0, item)
    return tuple(generator())

class MakeFieldFuncs:
    """Various ways to get a new value from the old one"""
    @staticmethod
    def copy(field_name, source, **kwargs):
        """Plain copy"""
        return source[field_name]

    @staticmethod
    def main(field_name, source, **kwargs):
        """Populate aux table from the main table"""
        return source[field_name]

    @staticmethod
    def Main(field_name, source, **kwargs):
        """Capitalize"""
        return source[field_name].capitalize()

    @staticmethod
    def ident(source, **kwargs):
        """Craft an identifier from the 'identifier' or 'name' column"""
        return name2ident(source.get('identifier', source.get('name')))

    @staticmethod
    def Name(source, **kwargs):
        """Capitalize the name (or identifier) column"""
        name = source.get('name', source.get('identifier', None))
        name = ' '.join(word.capitalize() for word in name.split(' '))
        return name

    @staticmethod
    def f_id(source, **kwargs):
        """Capitalize the identifier column"""
        return source['identifier'].capitalize()

    @staticmethod
    def name(source, **kwargs):
        """Get the original name"""
        return source['name']

    @staticmethod
    def newid(i, source, **kwargs):
        """Assign a new "auto-incremented" id"""
        source['id'] = i  # hack to make srcid work
        return i

    @staticmethod
    def en(source, **kwargs):
        """Assign the value for English -- unless it's Japanese"""
        if source.get('version_group_id', None) == str(bw_version_group_id):
            return japanese_id
        return english_id

    @staticmethod
    def srcid(source, field_name, **kwargs):
        """The original table's id"""
        try:
            return source['id']
        except KeyError:
            if field_name == 'pokemon_form_group_id':
                # This one reuses another table's ID
                return source['pokemon_id']
            else:
                raise

def name2ident(name):
    ident = name.decode('utf-8').lower()
    ident = ident.replace(u'+', ' plus ')
    ident = re.sub(u'[ _–]+', u'-', ident)
    ident = re.sub(u'[\'./;’(),:]', u'', ident)
    ident = ident.replace(u'é', 'e')
    ident = ident.replace(u'♀', '-f')
    ident = ident.replace(u'♂', '-m')
    if ident in ('???', '????'):
        ident = 'unknown'
    elif ident == '!':
        ident = 'exclamation'
    elif ident == '?':
        ident = 'question'
    for c in ident:
        assert c in "abcdefghijklmnopqrstuvwxyz0123456789-", repr(ident)
    return ident


FieldSpec = namedtuple('FieldSpec', 'out name func')

def main():
    for table in sorted(tables.all_tables(), key=lambda t: t.__name__):
        datafilename = dir + '/' + table.__tablename__ + '.csv'
        classname = table.__name__
        if hasattr(table, 'object_table'):
            # This is an auxilliary table; it'll be processed with the main one
            continue
        else:
            print "%s: %s" % (classname, table.__tablename__)
        with open(datafilename) as datafile:
            datacsv = csv.reader(datafile, lineterminator='\n')
            orig_fields = datacsv.next()
            columns = class_mapper(table).c
            new_fields = []
            main_out = []
            outputs = {datafilename: main_out}
            name_out = None
            srcfiles = [datafilename]
            # Set new_fields to a list of FieldSpec object, one for each field we want in the csv
            for column in columns:
                name = column.name
                if name == 'identifier':
                    new_fields.append(FieldSpec(datafilename, column.name, MakeFieldFuncs.ident))
                elif name in orig_fields:
                    new_fields.append(FieldSpec(datafilename, column.name, MakeFieldFuncs.copy))
                elif name == 'id':
                    new_fields.append(FieldSpec(datafilename, column.name, MakeFieldFuncs.newid))
                elif name == 'language_id':
                    new_fields.insert(2, FieldSpec(datafilename, column.name, MakeFieldFuncs.en))
                else:
                    raise AssertionError(name)
            # Remember headers
            headers = {datafilename: list(field.name for field in new_fields)}
            # Pretty prnt :)
            for field in new_fields:
                print '    [{0.func.func_name:5}] {0.name}'.format(field)
            # Do pretty much the same for aux tables
            aux_tables = []
            for attrname in 'text_table prose_table'.split():
                aux_table = getattr(table, attrname, None)
                if aux_table:
                    aux_datafilename = dir + '/' + aux_table.__tablename__ + '.csv'
                    print "  %s: %s" % (aux_table.__name__, aux_table.__tablename__)
                    srcfiles.append(datafilename)
                    aux_tables.append(aux_table)
                    columns = class_mapper(aux_table).c
                    aux_out = []
                    outputs[aux_datafilename] = aux_out
                    aux_fields = []
                    for column in columns:
                        name = column.name
                        if name == 'language_id':
                            aux_fields.insert(1, FieldSpec(aux_datafilename, column.name, MakeFieldFuncs.en))
                        elif name == 'name' and table.__name__ == 'ItemFlag':
                            aux_fields.append(FieldSpec(aux_datafilename, column.name, MakeFieldFuncs.f_id))
                        elif name == 'description' and table.__name__ == 'ItemFlag':
                            aux_fields.append(FieldSpec(aux_datafilename, column.name, MakeFieldFuncs.name))
                        elif name in orig_fields and name == 'name' and table.__name__ in 'PokemonColor ContestType BerryFirmness'.split():
                            # Capitalize these names
                            aux_fields.append(FieldSpec(aux_datafilename, column.name, MakeFieldFuncs.Name))
                        elif name in orig_fields and name in 'color flavor'.split() and table.__name__ == 'ContestType':
                            aux_fields.append(FieldSpec(aux_datafilename, column.name, MakeFieldFuncs.Main))
                        elif name in orig_fields:
                            aux_fields.append(FieldSpec(aux_datafilename, column.name, MakeFieldFuncs.main))
                        elif name == table.__singlename__ + '_id':
                            aux_fields.append(FieldSpec(aux_datafilename, column.name, MakeFieldFuncs.srcid))
                        elif name == 'name':
                            aux_fields.append(FieldSpec(aux_datafilename, column.name, MakeFieldFuncs.Name))
                        elif name == 'lang_id':
                            aux_fields.append(FieldSpec(aux_datafilename, column.name, MakeFieldFuncs.srcid))
                        else:
                            print orig_fields
                            raise AssertionError(name)
                        if name == 'name':
                            # If this table contains the name, remember that
                            name_fields = aux_fields
                            name_out = aux_out
                    # Sort aux tables nicely
                    def key(f):
                        if f.func == MakeFieldFuncs.srcid:
                            return 0
                        elif f.name == 'language_id':
                            return 1
                        elif f.name == 'name':
                            return 2
                        else:
                            return 10
                    aux_fields.sort(key=key)
                    new_fields += aux_fields
                    headers[aux_datafilename] = list(field.name for field in aux_fields)
                    # Pretty print :)
                    for field in aux_fields:
                        print '    [{0.func.func_name:5}] {0.name}'.format(field)
            # Do nothing if the table's the same
            if all(field.func == MakeFieldFuncs.copy for field in new_fields):
                print u'  → skipping'
                continue
            # Otherwise read the file
            # outputs will be a (filename -> list of rows) dict
            print u'  → reading'
            for autoincrement_id, src_row in enumerate(datacsv, start=1):
                row = dict(zip(orig_fields, src_row))
                new_rows = defaultdict(list)
                for field in new_fields:
                    new_rows[field.out].append(field.func(
                            source=row,
                            field_name=field.name,
                            i=autoincrement_id,
                        ))
                for name, row in new_rows.items():
                    outputs[name].append(row)
        # If there was a _names table, read that and append it to the
        # aux table that has names
        try:
            name_datafilename = dir + '/' + table.__singlename__ + '_names.csv'
            name_file = open(name_datafilename)
        except (AttributeError, IOError):
            pass
        else:
            print u'  → reading foreign names'
            with name_file:
                namecsv = csv.reader(name_file, lineterminator='\n')
                src_fields = namecsv.next()
                obj_id_fieldname = table.__singlename__ + '_id'
                assert src_fields == [obj_id_fieldname, 'language_id', 'name']
                for name_row in namecsv:
                    name_dict = dict(zip(src_fields, name_row))
                    row = []
                    for field in name_fields:
                        row.append(name_dict.get(field.name, ''))
                    name_out.append(row)
            os.unlink(name_datafilename)
        # For all out files, write a header & sorted rows
        print u'  → writing'
        for filename, rows in outputs.items():
            with open(filename, 'w') as outfile:
                outcsv = csv.writer(outfile, lineterminator='\n')
                outcsv.writerow(headers[filename])
                rows.sort(key=tuple_key)
                for row in rows:
                    outcsv.writerow(row)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = palpark
#!/usr/bin/env python2

"""Dump /arc/ppark.narc.

This is an unmaintained one-shot script, only included in the repo for
reference.

"""


import sys
from struct import pack, unpack
import binascii

import pokedex.db
from pokedex.db.tables import PalPark

types = [
    '',
    'grass',
    'fire',
    'water',
    'bug',
    'normal',
    'poison',
    'electric',
    'ground',
    'fighting',
    'psychic',
    'rock',
    'ghost',
    'ice',
    'steel',
    'dragon',
    'dark',
    'flying',
]

areas = {
    1: 'forest',
    2: 'mountain',
    3: 'field',
    0x200: 'pond',
    0x400: 'sea',
}

session = pokedex.db.connect()()

with open(sys.argv[1], "rb") as f:
    f.seek(0x3C)
    for i in range(0xb8e // 6):
        data = f.read(6)
        area, score, rate, t1, t2 = unpack("<HBBBB", data)

        print(i+1, binascii.hexlify(data).decode(),
                   areas[area], score, rate, types[t1], types[t2])

        obj = PalPark()
        obj.species_id = i+1
        obj.area = areas[area]
        obj.base_score = score
        obj.rate = rate

        session.add(obj)


session.commit()

########NEW FILE########
__FILENAME__ = pokemon_species
# Encoding: UTF-8
"""Reorganize Pokemon, PokemonForm, etc. to Species, Pokemon, etc.

This is an unmaintained one-shot script, only included in the repo for
reference.

"""

import csv
import os

from pokedex import defaults

number_of_species = 649
high_id_start = 10000

csv_dir = defaults.get_default_csv_dir()

def to_dict(filename):
    fullname = os.path.join(csv_dir, filename)
    reader = csv.reader(open(fullname))
    column_names = reader.next()
    entries = dict()
    for row in reader:
        row_dict = dict(zip(column_names, row))
        entries[row_dict.get('id', row_dict.get('pokemon_id'))] = row_dict
    return entries, column_names

pokemon, pokemon_columns = to_dict('pokemon.csv')
forms, form_columns = to_dict('pokemon_forms.csv')
form_groups, form_group_columns = to_dict('pokemon_form_groups.csv')
evolution_chains, evolution_chain_columns = to_dict('evolution_chains.csv')

result_columns = dict(
    species='''id identifier generation_id evolves_from_species_id
        evolution_chain_id color_id shape_id habitat_id
        growth_rate_id gender_rate capture_rate base_happiness is_baby
        hatch_counter has_gender_differences forms_switchable'''.split(),
    pokemon='''id species_id height weight base_experience order'''.split(),
    form='''id form_identifier pokemon_id introduced_in_version_group_id
        is_default is_battle_only order'''.split(),
    chain='''id baby_trigger_item_id'''.split(),
    )

def normalize_id(id):
    id = int(id)
    if id > number_of_species:
        id = id - high_id_start + number_of_species
    return id

def put(dct, entry):
    """Put entry in dct. If already there, check it's the same.
    """
    id = int(entry['id'])
    if id in dct:
        if entry == dct[id]:
            pass
        else:
            print entry
            print dct[id]
            assert False
    else:
        dct[id] = entry

forms_switchable = dict(
        castform=True,
        unown=False,
        darmanitan=True,
        basculin=False,
        rotom=True,
        shaymin=True,
        deerling=True,
        sawsbuck=True,
        arceus=True,
        pichu=False,
        giratina=True,
        burmy=True,
        wormadam=False,
        deoxys=True,
        genesect=True,
        meloetta=True,
        gastrodon=False,
        cherrim=True,
        shellos=False,
    )

result_species = dict()
result_pokemon = dict()
result_forms = dict()
result_chains = dict()

for form_id, source_form in forms.items():
    pokemon_id = source_form['unique_pokemon_id'] or source_form['form_base_pokemon_id']
    species_id = source_form['form_base_pokemon_id']
    source_pokemon = pokemon[pokemon_id]
    source_evolution_chain = evolution_chains[source_pokemon['evolution_chain_id']]
    try:
        source_group = form_groups[species_id]
    except KeyError:
        source_group = dict(is_battle_only=0)
    all_fields = dict(source_form)
    all_fields.update(source_group)
    all_fields.update(source_pokemon)
    all_fields.update(source_evolution_chain)
    del all_fields['id']
    new_species = dict()
    for column_name in result_columns['species']:
        if column_name == 'id':
            new_species[column_name] = normalize_id(species_id)
        elif column_name == 'evolves_from_species_id':
            new_species[column_name] = pokemon[species_id]['evolves_from_pokemon_id']
        elif column_name == 'shape_id':
            new_species[column_name] = all_fields['pokemon_shape_id']
        elif column_name == 'forms_switchable':
            if species_id in form_groups:
                new_species[column_name] = forms_switchable[source_pokemon['identifier']]
            else:
                new_species[column_name] = 0
        else:
            new_species[column_name] = all_fields[column_name]
    put(result_species, new_species)
    new_pokemon = dict()
    for column_name in result_columns['pokemon']:
        if column_name == 'id':
            new_pokemon[column_name] = normalize_id(pokemon_id)
        elif column_name == 'species_id':
            new_pokemon[column_name] = species_id
        else:
            new_pokemon[column_name] = all_fields[column_name]
    put(result_pokemon, new_pokemon)
    new_form = dict()
    for column_name in result_columns['form']:
        if column_name == 'id':
            new_form[column_name] = normalize_id(form_id)
        elif column_name == 'pokemon_id':
            new_form[column_name] = normalize_id(pokemon_id)
        elif column_name == 'form_identifier':
            new_form[column_name] = source_form['identifier']
        elif column_name == 'is_battle_only':
            if source_form['unique_pokemon_id'] == source_form['form_base_pokemon_id']:
                # Default form, herefore not battle-only
                new_form[column_name] = '0'
            else:
                # Keep
                new_form[column_name] = all_fields[column_name]
        else:
            new_form[column_name] = all_fields[column_name]
    put(result_forms, new_form)
    new_chain = dict(source_evolution_chain)
    del new_chain['growth_rate_id']
    put(result_chains, new_chain)

def write_csv(dct, fieldnames, filename):
    fullname = os.path.join(csv_dir, filename)
    reader = csv.DictWriter(open(fullname, 'w'), fieldnames)
    reader.writerow(dict((n,n) for n in fieldnames))
    for id, row in sorted(dct.items()):
        reader.writerow(row)

write_csv(result_species, result_columns['species'], 'pokemon_species.csv')
write_csv(result_pokemon, result_columns['pokemon'], 'pokemon.csv')
write_csv(result_forms, result_columns['form'], 'pokemon_forms.csv')
write_csv(result_chains, result_columns['chain'], 'evolution_chains.csv')


########NEW FILE########
__FILENAME__ = set_pokemon_order
#!/usr/bin/env python2

import sqlite3

conn = sqlite3.connect("pokedex/data/pokedex.sqlite")

cur = conn.execute(
    """select p.id, p.name, pf.name
    from pokemon p
    join evolution_chains ec on p.evolution_chain_id = ec.id
    left join pokemon_forms pf on p.id = pf.unique_pokemon_id
    order by ec.id, is_baby = 0, coalesce(pf.form_base_pokemon_id, p.id),
             pf."order", pf.name
    ;""")

idmap = []

for i, row in enumerate(cur):
    idmap.append((1 + i, row[0]))

conn.executemany(
    """update pokemon set "order" = ? where id = ?""",
    idmap,
)

conn.commit()


########NEW FILE########
__FILENAME__ = version-group-pokemon-move-methods
# Encoding: UTF-8
"""Fill the version_group_pokemon_move_methods table

This is an unmaintained one-shot script, only included in the repo for reference.


"""


from sqlalchemy.sql import exists, func
from sqlalchemy.orm import lazyload
from sqlalchemy import and_, or_, not_

from pokedex.db import connect, tables, load

session = connect()

session.query(tables.VersionGroupPokemonMoveMethod).delete()

q = session.query(tables.VersionGroup, tables.PokemonMoveMethod)
q = q.filter(exists().where(and_(
        tables.PokemonMove.pokemon_move_method_id == tables.PokemonMoveMethod.id,
        tables.PokemonMove.version_group_id == tables.VersionGroup.id)))
q = q.options(lazyload('*'))
for version_group, pokemon_move_method in q:
    entry = tables.VersionGroupPokemonMoveMethod(
            version_group=version_group,
            pokemon_move_method=pokemon_move_method,
        )
    session.add(entry)


load.dump(session, tables=['version_group_pokemon_move_methods'])
print "Dumped to CSV, rolling back transaction"
session.rollback()

########NEW FILE########
__FILENAME__ = xd-tutors
# Encoding: UTF-8
"""Add XD tutors to the database

This is an unmaintained one-shot script, only included in the repo for reference.

"""

from pokedex.db import connect, tables, util

session = connect()

emerald = util.get(session, tables.Version, 'emerald')
fire_red = util.get(session, tables.Version, 'firered')
emerald_version_group = emerald.version_group
xd_version_group = util.get(session, tables.Version, 'xd').version_group
colo_version_group = util.get(session, tables.Version, 'colosseum').version_group

tutor = util.get(session, tables.PokemonMoveMethod, 'tutor')
level_up = util.get(session, tables.PokemonMoveMethod, 'level-up')

# According to every source I could find, the following can be taught to
# exactly the same set of Pokémon which learn it from the FR/LG/E tutor: --ete
for move_identifier in '''
        body-slam
        double-edge
        dream-eater
        icy-wind
        mimic
        seismic-toss
        substitute
        swagger
        thunder-wave
        '''.split():
    move = util.get(session, tables.Move, move_identifier)
    print move
    query = session.query(tables.PokemonMove.pokemon_id)
    query = query.filter_by(method=tutor)
    query = query.filter_by(move=move)
    em = set(p for (p, ) in query.filter_by(version_group=emerald.version_group).all())
    fr = set(p for (p, ) in query.filter_by(version_group=fire_red.version_group).all())
    assert not fr or not em.symmetric_difference(fr)
    for pokemon_id in em:
        pokemon_move = tables.PokemonMove()
        pokemon_move.pokemon_id = pokemon_id
        pokemon_move.move = move
        pokemon_move.method = tutor
        pokemon_move.level = 0
        pokemon_move.version_group = xd_version_group
        session.add(pokemon_move)

# These are only found in XD:
xd_tutor_data = {
    'nightmare': 'butterfree clefairy clefable jigglypuff wigglytuff meowth '
        'persian abra kadabra alakazam slowpoke slowbro gastly haunter gengar '
        'drowzee hypno exeggcute exeggutor lickitung starmie mr-mime jynx '
        'lapras porygon mewtwo mew hoothoot noctowl cleffa igglybuff natu xatu '
        'aipom espeon umbreon murkrow slowking misdreavus girafarig dunsparce '
        'sneasel houndour houndoom porygon2 stantler smoochum tyranitar lugia '
        'ho-oh celebi ralts kirlia gardevoir masquerain shedinja sableye '
        'roselia gulpin swalot spinda shuppet banette duskull dusclops '
        'chimecho absol jirachi deoxys '.split(),
    'selfdestruct': 'geodude graveler golem grimer muk shellder cloyster '
        'gastly haunter gengar onix voltorb electrode exeggcute exeggutor '
        'koffing weezing snorlax mewtwo mew sudowoodo pineco forretress '
        'steelix qwilfish slugma magcargo corsola seedot nuzleaf shiftry '
        'nosepass gulpin swalot wailmer wailord camerupt torkoal lunatone '
        'solrock baltoy claydol glalie metang metagross regirock regice '
        'registeel'.split(),
    'sky-attack': 'pidgey pidgeotto pidgeot spearow fearow doduo dodrio '
        'aerodactyl articuno zapdos moltres mew hoothoot noctowl togetic '
        'natu xatu murkrow delibird skarmory ho-oh taillow swellow wingull '
        'pelipper swablu altaria'.split(),
    'faint-attack': ['mew'],
    'fake-out': ['mew'],
    'hypnosis': ['mew'],
    'night-shade': ['mew'],
    'role-play': ['mew'],
    'zap-cannon': ['mew'],
    }

for move_identifier, pokemon_identifiers in xd_tutor_data.items():
    move = util.get(session, tables.Move, move_identifier)
    for pokemon_identifier in pokemon_identifiers:
        species = util.get(session, tables.PokemonSpecies, pokemon_identifier)
        try:
            pokemon, = species.pokemon
        except ValueError:
            assert pokemon_identifier == 'deoxys'
            pokemon = species.default_pokemon
        print move, pokemon

        pokemon_move = tables.PokemonMove()
        pokemon_move.pokemon = pokemon
        pokemon_move.move = move
        pokemon_move.method = tutor
        pokemon_move.level = 0
        pokemon_move.version_group = xd_version_group
        session.add(pokemon_move)

# And unfortunately, we have to copy level-up moves. To both XD and Colosseum.
for pokemon_id, move_id, level, order in set(
        session.query(
                tables.PokemonMove.pokemon_id,
                tables.PokemonMove.move_id,
                tables.PokemonMove.level,
                tables.PokemonMove.order,
            )
        .filter_by(method=level_up)
        .filter_by(version_group=emerald_version_group)
    ):
    for version_group in xd_version_group, colo_version_group:
        print pokemon_id, move_id
        pokemon_move = tables.PokemonMove()
        pokemon_move.pokemon_id = pokemon_id
        pokemon_move.move_id = move_id
        pokemon_move.method = level_up
        pokemon_move.level = level
        pokemon_move.order = order
        pokemon_move.version_group = version_group
        session.add(pokemon_move)


session.commit()

########NEW FILE########
