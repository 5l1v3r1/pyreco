__FILENAME__ = annotations
# -*- coding: utf-8 -*-
# Copyright (c) 2013, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

""" 
This module contains manual annotations for the gl backends. Together
with the header files, we can generatre the full ES 2.0 API.

Every function-annotations consists of sections that apply to one or
more backends. If no backends are specified in the first section, it
applies to all backends.
"""

import ctypes


## bind / gen / delete stuff

def deleteBuffer(buffer):
    # --- desktop angle
    n = 1  
    buffers = (ctypes.c_uint*n)(buffer)  
    ()  
    # --- pyopengl
    GL.glDeleteBuffers(1, [buffer])

def deleteFramebuffer(framebuffer):
    # --- desktop angle
    n = 1  
    framebuffers = (ctypes.c_uint*n)(framebuffer)  
    ()
    # --- pyopengl
    FBO.glDeleteFramebuffers(1, [framebuffer])

def deleteRenderbuffer(renderbuffer):
    # --- desktop angle
    n = 1  
    renderbuffers = (ctypes.c_uint*n)(renderbuffer)  
    ()
    # --- pyopengl
    FBO.glDeleteRenderbuffers(1, [renderbuffer])

def deleteTexture(texture):
    # --- desktop angle
    n = 1  
    textures = (ctypes.c_uint*n)(texture)  
    ()
    # --- pyopengl
    GL.glDeleteTextures([texture])


def createBuffer():
    # --- desktop angle
    n = 1
    buffers = (ctypes.c_uint*n)()
    ()  
    return buffers[0]
    # --- pyopengl
    return GL.glGenBuffers(1)
    # --- mock
    return 1

def createFramebuffer():
    # --- desktop angle
    n = 1
    framebuffers = (ctypes.c_uint*n)()
    ()
    return framebuffers[0]
    # --- pyopengl
    return FBO.glGenFramebuffers(1)
    # --- mock
    return 1

def createRenderbuffer():
    # --- desktop angle
    n = 1
    renderbuffers = (ctypes.c_uint*n)()
    ()
    return renderbuffers[0]
    # --- pyopengl
    return FBO.glGenRenderbuffers(1)
    # --- mock
    return 1

def createTexture():
    # --- desktop angle
    n = 1
    textures = (ctypes.c_uint*n)()
    ()
    return textures[0]
    # --- pyopengl
    return GL.glGenTextures(1)
    # --- mock
    return 1


## Image stuff

def texImage2D(target, level, internalformat, format, type, pixels):
    border = 0
    # --- desktop angle
    if isinstance(pixels, (tuple, list)):
        height, width = pixels
        pixels = ctypes.c_void_p(0)
        pixels = None
    else:
        if not pixels.flags['C_CONTIGUOUS']:
            pixels = pixels.copy('C')
        pixels_ = pixels
        pixels = pixels_.ctypes.data
        height, width = pixels_.shape[:2]
    ()
    # --- pyopengl
    if isinstance(pixels, (tuple, list)):
        height, width = pixels
        pixels = None
    else:
        height, width = pixels.shape[:2]
    GL.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels)
    


def texSubImage2D(target, level, xoffset, yoffset, format, type, pixels):
    # --- desktop angle
    if not pixels.flags['C_CONTIGUOUS']:
        pixels = pixels.copy('C')
    pixels_ = pixels
    pixels = pixels_.ctypes.data
    height, width = pixels_.shape[:2]
    ()
    # --- pyopengl
    height, width = pixels.shape[:2]
    GL.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels)


def readPixels(x, y, width, height, format, type):
    # --- desktop angle mock
    # GL_ALPHA, GL_RGB, GL_RGBA
    t = {6406:1, 6407:3, 6408:4}[format]
    # we kind of only support type GL_UNSIGNED_BYTE
    size = int(width*height*t)
    # --- desktop angle
    pixels = ctypes.create_string_buffer(size)
    ()
    return pixels[:]
    # --- mock
    return size * b'\x00'


def compressedTexImage2D(target, level, internalformat, width, height, border=0, data=None):
    # border = 0  # set in args
    # --- desktop angle
    if not data.flags['C_CONTIGUOUS']:
        data = data.copy('C')
    data_ = data
    size = data_.size
    data = data_.ctypes.data
    ()
    # --- pyopengl
    size = data.size
    GL.glCompressedTexImage2D(target, level, internalformat, width, height, border, size, data)


def compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data):
    # --- desktop angle
    if not data.flags['C_CONTIGUOUS']:
        data = data.copy('C')
    data_ = data
    size = data_.size
    data = data_.ctypes.data
    ()
    # --- pyopengl
    size = data.size
    GL.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, size, data)


## Buffer data


def bufferData(target, data, usage):
    """ Data can be numpy array or the size of data to allocate.
    """
    # --- desktop angle
    if isinstance(data, int):
        size = data
        data = ctypes.c_voidp(0)
    else:
        if not data.flags['C_CONTIGUOUS'] or not data.flags['ALIGNED']:
            data = data.copy('C')
        data_ = data
        size = data_.nbytes
        data = data_.ctypes.data
    ()
    # --- pyopengl
    if isinstance(data, int):
        size = data
        data = None
    else:
        size = data.nbytes
    GL.glBufferData(target, size, data, usage)


def bufferSubData(target, offset, data):
    # --- desktop angle
    if not data.flags['C_CONTIGUOUS']:
        data = data.copy('C')
    data_ = data
    size = data_.nbytes
    data = data_.ctypes.data
    ()
    # --- pyopengl
    size = data.nbytes
    GL.glBufferSubData(target, offset, size, data)


def drawElements(mode, count, type, offset):
    # --- desktop angle
    if offset is None:
        offset = ctypes.c_void_p(0)
    elif isinstance(offset, ctypes.c_void_p):
        pass
    elif isinstance(offset, (int, ctypes.c_int)):
        offset = ctypes.c_void_p(int(offset))
    else:
        if not offset.flags['C_CONTIGUOUS']:
            offset = offset.copy('C')
        offset_ = offset
        offset = offset.ctypes.data
    indices = offset
    ()
    # --- pyopengl
    if offset is None:
        offset = ctypes.c_void_p(0)
    elif isinstance(offset, (int, ctypes.c_int)):
        offset = ctypes.c_void_p(int(offset))
    ()


def vertexAttribPointer(indx, size, type, normalized, stride, offset):
    # --- desktop angle
    if offset is None:
        offset = ctypes.c_void_p(0)
    elif isinstance(offset, ctypes.c_void_p):
        pass
    elif isinstance(offset, (int, ctypes.c_int)):
        offset = ctypes.c_void_p(int(offset))
    else:
        if not offset.flags['C_CONTIGUOUS']:
            offset = offset.copy('C')
        offset_ = offset
        offset = offset.ctypes.data
        # We need to ensure that the data exists at draw time :(
        # PyOpenGL does this too
        key = '_vert_attr_'+str(indx)
        setattr(glVertexAttribPointer, key, offset_)
    ptr = offset
    ()
    # --- pyopengl
    if offset is None:
        offset = ctypes.c_void_p(0)
    elif isinstance(offset, (int, ctypes.c_int)):
        offset = ctypes.c_void_p(int(offset))
    ()


def bindAttribLocation(program, index, name):
    # --- desktop angle
    name = ctypes.c_char_p(name.encode('utf-8'))
    ()
    # --- pyopengl
    name = name.encode('utf-8')
    ()


## Setters


def shaderSource(shader, source):
    # Some implementation do not like getting a list of single chars
    if isinstance(source, (tuple, list)):
        strings = [s for s in source]
    else:
        strings = [source]
    # --- desktop angle
    count = len(strings)  
    string = (ctypes.c_char_p*count)(*[s.encode('utf-8') for s in strings])  
    length = (ctypes.c_int*count)(*[len(s) for s in strings])  
    ()
    # --- pyopengl
    GL.glShaderSource(shader, strings)


## Getters

def _getBooleanv(pname):
    # --- desktop angle
    params = (ctypes.c_bool*1)()
    ()
    return params[0]

def _getIntegerv(pname):
    # --- desktop angle
    n = 16
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*n)(*[d for i in range(n)])
    ()
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)

def _getFloatv(pname):
    # --- desktop angle
    n = 16
    d = float('Inf')
    params = (ctypes.c_float*n)(*[d for i in range(n)])
    ()
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)

# def _getString(pname):
#     # --- desktop angle
#     ()
#     return res.value
#     # --- mock
#     return ''


def getParameter(pname):
    if pname in [33902, 33901, 32773, 3106, 2931, 2928, 
                 2849, 32824, 10752, 32938]:
        # GL_ALIASED_LINE_WIDTH_RANGE GL_ALIASED_POINT_SIZE_RANGE
        # GL_BLEND_COLOR GL_COLOR_CLEAR_VALUE GL_DEPTH_CLEAR_VALUE
        # GL_DEPTH_RANGE GL_LINE_WIDTH GL_POLYGON_OFFSET_FACTOR
        # GL_POLYGON_OFFSET_UNITS GL_SAMPLE_COVERAGE_VALUE
        return _glGetFloatv(pname)
    elif pname in [7936, 7937, 7938, 35724, 7939]:
        # GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION, 
        # GL_EXTENSIONS are strings
        pass  # string handled below
    else:
        return _glGetIntegerv(pname)
    name = pname
    # --- desktop angle
    ()
    return res.decode('utf-8') if res else ''
    # --- pyopengl
    res = GL.glGetString(pname)
    return res.decode('utf-8')


def getUniform(program, location):
    # --- desktop angle
    n = 16
    d = float('Inf')
    params = (ctypes.c_float*n)(*[d for i in range(n)])
    ()
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)
    # --- pyopengl
    n = 16
    d = float('Inf')
    params = (ctypes.c_float*n)(*[d for i in range(n)])
    GL.glGetUniformfv(program, location, params)
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)


def getVertexAttrib(index, pname):
    # --- desktop angle
    n = 4
    d = float('Inf')
    params = (ctypes.c_float*n)(*[d for i in range(n)])
    ()
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)
    # --- pyopengl
    try:  # maybe they will fix it
        ()
    except TypeError:
        n = 4
        d = float('Inf')
        params = (ctypes.c_float*n)(*[d for i in range(n)])
        GL.glGetVertexAttribfv(index, pname, params)
        params = [p for p in params if p!=d]
        if len(params) == 1:
            return params[0]
        else:
            return tuple(params)


def getTexParameter(target, pname):
    # --- desktop angle
    d = float('Inf')
    params = (ctypes.c_float*1)(d)
    ()
    return params[0]


def getActiveAttrib(program, index):
    # --- desktop angle pyopengl
    bufsize = 256
    length = (ctypes.c_int*1)()
    size = (ctypes.c_int*1)()
    type = (ctypes.c_uint*1)()
    name = ctypes.create_string_buffer(bufsize)
    # --- desktop angle
    ()
    name = name[:length[0]].decode('utf-8')
    return name, size[0], type[0]
    # --- pyopengl
    # pyopengl has a bug, this is a patch
    GL.glGetActiveAttrib(program, index, bufsize, length, size, type, name)
    name = name[:length[0]].decode('utf-8')
    return name, size[0], type[0]
    # --- mock
    return 'mock_val', 1, 5126


def getVertexAttribOffset(index, pname):
    # --- desktop angle
    pointer = (ctypes.c_void_p*1)()
    ()
    return pointer[0] or 0
    # --- pyopengl
    try:  # maybe the fixed it
        ()
    except TypeError:
        pointer = (ctypes.c_void_p*1)()
        GL.glGetVertexAttribPointerv(index, pname, pointer)
        return pointer[0] or 0
    # --- mock
    return 0

    
def getActiveUniform(program, index):
    # --- desktop angle
    bufsize = 256
    length = (ctypes.c_int*1)()
    size = (ctypes.c_int*1)()
    type = (ctypes.c_uint*1)()
    name = ctypes.create_string_buffer(bufsize)
    ()
    name = name[:length[0]].decode('utf-8')
    return name, size[0], type[0]
    # --- pyopengl
    name, size, type = GL.glGetActiveUniform(program, index)
    return name.decode('utf-8'), size, type


def getAttachedShaders(program):
    # --- desktop angle
    maxcount = 256
    count = (ctypes.c_int*1)()
    shaders = (ctypes.c_uint*maxcount)()
    ()
    return tuple(shaders[:count[0]])


def getAttribLocation(program, name):
    # --- desktop angle
    name = ctypes.c_char_p(name.encode('utf-8'))
    ()
    return res
    # --- pyopengl
    name = name.encode('utf-8')
    ()
    

def getUniformLocation(program, name):
    # --- desktop angle
    name = ctypes.c_char_p(name.encode('utf-8'))
    ()
    return res
    # --- pyopengl
    name = name.encode('utf-8')
    ()

def getProgramInfoLog(program):
    # --- desktop angle
    bufsize = 1024
    length = (ctypes.c_int*1)()
    infolog = ctypes.create_string_buffer(bufsize)
    ()
    return infolog[:length[0]].decode('utf-8')
    # --- pyopengl
    res = GL.glGetProgramInfoLog(program)
    return res.decode('utf-8')

def getShaderInfoLog(shader):
    # --- desktop angle
    bufsize = 1024
    length = (ctypes.c_int*1)()
    infolog = ctypes.create_string_buffer(bufsize)
    ()
    return infolog[:length[0]].decode('utf-8')
    # --- pyopengl
    res = GL.glGetShaderInfoLog(shader)
    return res.decode('utf-8')

def getProgramParameter(program, pname):
    # --- desktop angle
    params = (ctypes.c_int*1)()
    ()
    return params[0]

def getShaderParameter(shader, pname):
    # --- desktop angle
    params = (ctypes.c_int*1)()
    ()
    return params[0]

def getShaderPrecisionFormat(shadertype, precisiontype):
    # --- desktop angle
    range = (ctypes.c_int*1)()
    precision = (ctypes.c_int*1)()
    ()
    return range[0], precision[0]

def getShaderSource(shader):
    # --- desktop angle
    bufsize = 1024*1024
    length = (ctypes.c_int*1)()
    source = (ctypes.c_char*bufsize)()
    ()
    return source.value[:length[0]].decode('utf-8')
    # --- pyopengl
    res = GL.glGetShaderSource(shader)
    return res.decode('utf-8')
    

def getBufferParameter(target, pname):
    # --- desktop angle
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    ()
    return params[0]


def getFramebufferAttachmentParameter(target, attachment, pname):
    # --- desktop angle
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    ()
    return params[0]
    # --- pyopengl
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    FBO.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params)
    return params[0]


def getRenderbufferParameter(target, pname):
    # --- desktop angle
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    ()
    return params[0]
    # --- pyopengl
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    FBO.glGetRenderbufferParameteriv(target, pname, params)
    return params[0]



## ============================================================================


class FunctionAnnotation:
    def __init__(self, name, args, output):
        self.name = name
        self.args = args
        self.output = output
        self.lines = []  # (line, comment) tuples
    
    def __repr__(self):
        return '<FunctionAnnotation for %s>' % self.name
        
    def get_lines(self, call, backend):
        """ Get the lines for this function based on the given backend. 
        The given API call is inserted at the correct location.
        """
        backend_selector = backend  # first lines are for all backends
        lines = []
        for line in self.lines:
            if line.lstrip().startswith('# ---'):
                backend_selector = line
                continue
            if backend in backend_selector:
                if line.strip() == '()':
                    indent = line.split('(')[0][4:]
                    line = indent + call
                lines.append(line)
        return lines
    
    def is_arg_set(self, name):
        """ Get whether a given variable name is set.
        This allows checking whether a variable that is an input to the C
        function is not an input for the Python function, and may be an output.
        """
        needle = '%s =' % name
        for line, comment in self.lines:
            if line.startswith(needle):
                return True
        else:
            return False



def parse_anotations():
    """ Parse this annotations file and produce a dictionary of
    FunctionAnnotation objects.
    """
    
    functions = {}
    function = None
    
    for line in open(__file__, 'rt').readlines():
        # Stop?
        if '='*40 in line:
            break
        
        if line.startswith('def '):
            name = line.split(' ')[1].split('(')[0]
            args = line.split('(')[1].split(')')[0].split(', ')
            args = [arg for arg in args if arg]
            out =  line.partition('->')[2].strip()
            function = FunctionAnnotation(name, args, out)
            functions[name] = function
            continue
        elif not function:
            continue
        
        # Add line
        line = line.rstrip()
        indent = len(line) - len(line.strip())
        if line.strip() and indent >=4:
            function.lines.append(line)

    return functions


if __name__ == '__main__':
    print(parse_anotations().keys())
    
########NEW FILE########
__FILENAME__ = createglapi
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (c) 2013, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""
Scipt to generate code for our gl API, including all its backends.

The files involved in the code generation process are:

  * gl2.h - the C header file for the GL ES 2.0 API
  * webgl.idl - the interface definition language for WebGL
  * annotations.py - manual annotations for non-trivial functions
  * headerparser.py - parses .h and .idl files 
  * createglapi.py - uses all of the above to generate the actual code

Rationale
---------

The GL ES 2.0 API is relatively small. Therefore a fully automated build
process like PyOpenGL now has is not really necessary. I tried to
automate what we can and simply do the rest with manual annotations.
Some groups of functions (like glUniform and friends) are handled in
*this* file.

Even though the API is quite small, we want to generate several
implementations, such as desktop, Angle, a generic proxy, webgl, a mock
backend and possibly more. Therefore automation is crucial.

Further notes
-------------

This file is pretty big and even though I tried to make the code as clear
as possible, it's not always that easy to read. In effect this code is
not so easy to maintain. I hope it is at least clear enough so it can be
used to maintain the GL API itself.

"""

import os
import sys
import ctypes  # not actually used, but handy to have imported during dev

import headerparser
from annotations import parse_anotations

from OpenGL import GL  # For checking

THISDIR = os.path.abspath(os.path.dirname(__file__))
GLDIR = os.path.join(THISDIR, '..', 'vispy', 'gloo', 'gl')

PREAMBLE = '''"""

THIS CODE IS AUTO-GENERATED. DO NOT EDIT.

%s

"""
'''

## Create parsers

# Create a parser for desktop and web gl
parser1 = headerparser.Parser(os.path.join(THISDIR, 'headers', 'gl2.h'))
headerparser.CONSTANTS = {}
parser2 = headerparser.Parser(os.path.join(THISDIR, 'headers', 'webgl.idl'))

# Get annotations
annotations = parse_anotations()


## Check constants and generate API module

# Get names
names1 = set(parser1.constant_names)
names2 = set(parser2.constant_names)

# Check names correspondence
if names1 == names2:
    print('Constants in gl2 and webgl are equal')
else:
    print('===== Extra names in gl2 =====')
    print(', '.join(names1.difference(names2)))
    print('===== Extra names in webgl =====')
    print(', '.join(names2.difference(names1)))
    print('===========')

# Test value correspondence
superset = names1.intersection(names2)
#
constants = {}
for c1 in parser1.constants.values():
    if c1.shortname in superset:
        constants[c1.shortname] = c1.value
#
assert len(constants) == len(superset)
#
for c2 in parser2.constants.values():
    if c2.shortname in constants:
        assert c2.value == constants[c2.shortname]
print('Hooray! All constants that occur in both namespaces have equal values.')


DEFINE_ENUM = """
class Enum(int):
    ''' Enum (integer) with a meaningfull repr. '''
    def __new__(cls, name, value):
        base = int.__new__(cls, value)
        base.name = name
        return base
    def __repr__(self):
        return self.name
"""

DEFINE_CONST_MAP = """
ENUM_MAP = {}
for ob in list(globals().values()):
    if repr(ob).startswith('GL_'):
        ENUM_MAP[int(ob)] = ob
del ob
"""

def create_constants_module(parser, extension=False):

    # Initialize
    lines = []
    lines.append(PREAMBLE % 'Constants for OpenGL ES 2.0.')
    
    # Define ENUM
    lines.append(DEFINE_ENUM)
    lines.append('')
    
    # For extensions, we only take the OES ones, and remove the OES
    if extension:
        constantDefs = []
        for c in parser.constants.values():
            if 'OES' in c.oname:
                c.oname = c.oname.replace('OES','')
                c.oname = c.oname.replace('__','_').strip('_')
                constantDefs.append(c)
    else:
        constantDefs = parser.constants.values()

    # Insert constants
    for c in sorted(constantDefs, key=lambda x: x.oname):
        if isinstance(c.value, int):
            lines.append('%s = Enum(%r, %r)' % (c.oname, c.oname, c.value))
        else:
            lines.append('%s = %r' % (c.oname, c.value))
    lines.append('')
    
    lines.append(DEFINE_CONST_MAP)
    
    # Write the file
    fname = '_constants_ext.py' if extension else '_constants.py'
    with open(os.path.join(GLDIR, fname), 'wb') as f:
        f.write(('\n'.join(lines)).encode('utf-8'))
    print('wrote %s' % fname)
    

create_constants_module(parser1)


## List functions

IGNORE_FUNCTIONS = ['releaseShaderCompiler', 'shaderBinary']

WEBGL_EQUIVALENTS = {   
    'genBuffers': 'createBuffer',
    'genFramebuffers': 'createFramebuffer',
    'genRenderbuffers': 'createRenderbuffer',
    'genTextures': 'createTexture',
    
    'deleteBuffers': 'deleteBuffer',
    'deleteFramebuffers': 'deleteFramebuffer',
    'deleteRenderbuffers': 'deleteRenderbuffer',
    'deleteTextures': 'deleteTexture',
    
    'clearDepthf': 'clearDepth',
    'depthRangef': 'depthRange',
    
    'getBufferParameteriv': 'getBufferParameter',
    'getRenderbufferParameteriv': 'getRenderbufferParameter',
    'getFramebufferAttachmentParameteriv': 'getFramebufferAttachmentParameter',
    
    'getVertexAttribPointerv': 'getVertexAttribOffset',
    
    'getProgramiv': 'getProgramParameter',
    'getShaderiv': 'getShaderParameter',
    
    'getBooleanv': 'getParameter',
    'getFloatv': 'getParameter',
    'getIntegerv': 'getParameter',
    'getString': 'getParameter',  # getParameter is getString + getFloat
    }

# Types that we convert easily from Python to C (and back)
EASY_TYPES = {  'void': (type(None), 'c_voidp'),  # only for output
                'GLenum': (int, 'c_uint'),
                'GLboolean': (bool, 'c_bool'),
                'GLuint': (int, 'c_uint'),
                'GLint': (int, 'c_int'),
                'GLbitfield': (int, 'c_uint'),
                'GLsizei': (int, 'c_int'),
                'GLfloat': (float, 'c_float'),
                'GLclampf': (float, 'c_float'),
             }

# Types that dont map 1-on-1 to Python values, but that we know
# how to set the ctypes argtypes for. 
HARDER_TYPES = {
                'GLenum*':('', 'POINTER(ctypes.c_uint)'),
                'GLboolean*':('', 'POINTER(ctypes.c_bool)'),
                'GLuint*':('', 'POINTER(ctypes.c_uint)'),
                'GLint*':('', 'POINTER(ctypes.c_int)'),
                'GLsizei*':('', 'POINTER(ctypes.c_int)'),
                'GLfloat*':('', 'POINTER(ctypes.c_float)'),
                
                'GLubyte*':('', 'c_char_p'),
                'GLchar*':('', 'c_char_p'),
                'GLchar**':('', 'POINTER(ctypes.c_char_p)'),
                'GLvoid*':('', 'c_void_p'),  # or c_voidp?
                'GLvoid**':('', 'POINTER(ctypes.c_void_p)'),
                'GLintptr':('', 'c_int'), 
                'GLsizeiptr':('', 'c_int'),
                }

# Together the EASY_TYPES and HARDER_TYPES should cover all types that
# ES 2.0 uses.
KNOWN_TYPES = EASY_TYPES.copy()
KNOWN_TYPES.update(HARDER_TYPES)


def apiname(funcname):
    """ Define what name the API uses, the short or the gl version.
    """
    if funcname.startswith('gl'):
        return funcname
    else:
        if funcname.startswith('_'):
            return '_gl' + funcname[1].upper() + funcname[2:]
        else:
            return 'gl' + funcname[0].upper() + funcname[1:]


class FunctionDescription:
    def __init__(self, name, es2func, wglfunc, annfunc):
        self.name = name
        self.apiname = apiname(name)
        self.es2 = es2func
        self.wgl = wglfunc
        self.ann = annfunc
        self.args = []


# Keep track of what webGL names we "used"
used_webgl_names = set()

# Also keep track of what functions we could handle automatically, 
# and which not. Just for reporting.
functions_auto = set()
functions_anno = set()
functions_todo = set()


def combine_function_definitions():
    """ Process function definitions of ES 2.0, WebGL and annotations.
    We try to combine information from these three sources to find the
    arguments for the Python API. In this "merging" process we also
    check for inconsistencies between the API definitions.
    """
    functions = []
    have_getParameter = False
    
    for name in parser1.function_names:
        if name in IGNORE_FUNCTIONS:
            continue
        
        # Get es2 function
        es2func = parser1.functions[name]
        
        # Get webgl version
        lookupname = WEBGL_EQUIVALENTS.get(es2func.shortname, es2func.shortname)
        wglfunc = parser2.functions.get(lookupname, None)
        if wglfunc:
            used_webgl_names.add(lookupname)
        else:
            print('WARNING: %s not available in WebGL' % es2func.shortname)
        
        # Convert name
        name = WEBGL_EQUIVALENTS.get(name, name)
        
        # Avoid duplicates for getParameter
        if name == 'getParameter':
            if es2func.shortname != 'getString':
                name =  '_' + es2func.shortname
        
        # Get annotated version
        annfunc = annotations.get(name, None)
        
        # Create description instance
        des = FunctionDescription(name, es2func, wglfunc, annfunc)
        functions.append(des)
        
        # Get information about arguments
        if True:
            argnames_es2 = [arg.name for arg in es2func.args[1:]]
        if wglfunc:
            argnames_wgl = [arg.name for arg in wglfunc.args[1:]]
        if annfunc:
            argnames_ann = annfunc.args  # Can contain 'argname=default'
            argnames_ann = [arg.split('=')[0] for arg in argnames_ann]
        
        # Set argumenets specification of our GL API
        # Also check and report when we deviate from the WebGL API
        if wglfunc and argnames_es2 == argnames_wgl:
            if annfunc and argnames_ann != argnames_es2:
                des.args = argnames_ann
                print('WARNING: %s: Annotation overload even though webgl and es2 match.'%name)
            else:
                des.args = argnames_es2
        elif wglfunc:
            if annfunc and argnames_ann != argnames_wgl:
                des.args = argnames_ann
                print('WARNING: %s: Annotation overload webgl args.'%name)
            else:
                #print('WARNING: %s: assuming wgl args.'%name)
                des.args = argnames_wgl
        else:
            print('WARNING: %s: Could not determine args!!'%name)
        
        # Go over all functions to test if they are in OpenGL
        for func in [es2func, wglfunc]:
            if func is None: 
                continue
            group = func.group or [func]
            for f in group:
                # Check opengl
                if f.oname.startswith('gl') and not hasattr(GL, f.glname):
                    print('WARNING: %s seems not available in PyOpenGL' % f.glname)
    
    return functions


## Get full function definitions and report
# Get functions
functions = combine_function_definitions()

# Check which WebGL functions we did not find/use
for name in set(parser2.function_names).difference(used_webgl_names):
    print('WARNING: WebGL function %s not in Desktop' % name)

# Report status
print('Could generate %i functions automatically, and %i with annotations' %
      (len(functions_auto), len(functions_anno)))
print('Need more info for %i functions.' % len(functions_todo))
if not functions_todo:
    print('Hooray! All %i functions are covered!' % len(functions))



## Define generators

class ApiGenerator:
    """ Base API generator class. We derive several subclasses to implement
    the different backends.
    """
    
    DESCRIPTION = "GL API X"
    PREAMBLE = ""
    
    def __init__(self):
        self.lines = []
    
    def save(self):
        # Remove too many whitespace
        text = '\n'.join(self.lines) + '\n'
        for i in range(10):
            text = text.replace('\n\n\n\n', '\n\n\n')
        # Write
        with open(self.filename, 'wb') as f:
            f.write((PREAMBLE % self.DESCRIPTION).encode('utf-8'))
            for line in self.PREAMBLE.splitlines():
                f.write(line[4:].encode('utf-8')+b'\n')
            f.write(b'\n')
            f.write(text.encode('utf-8'))
    
    def add_function(self, des):
        if des.es2.group:
            if des.name.startswith('get'):
                assert len(des.es2.group) == 2  # vi and fv
                des.es2 = des.es2.group[0]  # f comes before 1
                self._add_function(des)
            else:
                self._add_function_group(des)
        else:
            self._add_function(des)
        self.lines.append('\n')  # two lines between each function
    
    
    def _add_function_group(self, des):
        lines = self.lines
        handled = True
        
        # Create map to es2 function objects
        es2funcs = {}
        for f in des.es2.group:
            cname = f.shortname
            es2funcs[cname] = f
        
        if des.name == 'uniform':
            for t in ('float', 'int'):
                for i in (1,2,3,4):
                    args = ', '.join(['v%i'%j for j in range(1,i+1)])
                    cname = 'uniform%i%s' % (i, t[0])
                    sig = '%s(location, %s)' % (apiname(cname), args)
                    self._add_group_function(des, sig, es2funcs[cname])
            for t in ('float', 'int'):
                for i in (1,2,3,4):
                    cname = 'uniform%i%sv' % (i, t[0])
                    sig = '%s(location, count, values)' % apiname(cname)
                    self._add_group_function(des, sig, es2funcs[cname])
        elif des.name == 'uniformMatrix':
            for i in (2,3,4):
                cname = 'uniformMatrix%ifv' % i
                sig = '%s(location, count, transpose, values)' % apiname(cname)
                self._add_group_function(des, sig, es2funcs[cname])
        elif des.name == 'vertexAttrib':
            for i in (1,2,3,4):
                args = ', '.join(['v%i'%j for j in range(1,i+1)])
                cname = 'vertexAttrib%if' % i
                sig = '%s(index, %s)' % (apiname(cname), args)
                self._add_group_function(des, sig, es2funcs[cname])
        elif des.name == 'texParameter':
            for t in ('float', 'int'):
                cname = 'texParameter%s' % t[0]
                sig = '%s(target, pname, param)' % apiname(cname)
                self._add_group_function(des, sig, es2funcs[cname])
        else:
            handled = False
        
        if handled:
            functions_auto.add(des.name)
        else:
            functions_todo.add(des.name)
            lines.append('# todo: Dont know group %s' % des.name)
    
    def _add_function(self, des):
        # Need to be overloaded in subclass
        raise NotImplementedError()
    
    def _add_group_function(self, des, sig, es2func):
        # Need to be overloaded in subclass
        raise NotImplementedError()



class ProxyApiGenerator(ApiGenerator):
    """ Generator for the general proxy class that will be loaded into gloo.gl.
    """
    
    filename = os.path.join(GLDIR, '_proxy.py')
    DESCRIPTION = 'Base proxy API for GL ES 2.0.'
    PREAMBLE = '''
    class BaseGLProxy(object):
        """ Base proxy class for the GL ES 2.0 API. Subclasses should
        implement __call__ to process the API calls.
        """
       
        def __call__(self, funcname, returns, *args):
            raise NotImplementedError()
        
        
        def glShaderSource_compat(self, handle, code):
            return self("glShaderSource_compat", True, handle, code)
    '''
    
    def _returns(self, des):
        shortame = des.name
        for prefix in ("get", "is", "check", "create", "read"):
            if shortame.startswith(prefix):
                return True
        else:
            return False
    
    
    def _add_function(self, des):
        ret = self._returns(des)
        prefix = 'return ' if ret else ''
        argstr = ', '.join(des.args)
        self.lines.append('    def %s(self, %s):' % (des.apiname, argstr))
        self.lines.append('        %sself("%s", %r, %s)' % 
                          (prefix, apiname(des.name),ret, argstr))
    
    def _add_group_function(self, des, sig, es2func):
        ret = self._returns(des)
        prefix = 'return ' if ret else ''
        funcname = apiname(sig.split('(')[0])
        args = sig.split('(', 1)[1].split(')')[0]
        #self.lines.append('    def %s:' % sig)
        self.lines.append('    def %s(self, %s):' % (funcname, args))
        self.lines.append('        %sself("%s", %r, %s)' % 
                          (prefix, funcname, ret, args))



class DesktopApiGenerator(ApiGenerator):
    """ Generator for the desktop GL backend.
    """
    
    filename = os.path.join(GLDIR, '_desktop.py')
    write_c_sig = True
    define_argtypes_in_module = False
    
    DESCRIPTION = "Subset of desktop GL API compatible with GL ES 2.0"
    PREAMBLE = """
    import ctypes
    from .desktop import _lib, _get_gl_func
    """
    
    def _get_argtype_str(self, es2func):
        ce_arg_types = [arg.ctype for arg in es2func.args[1:]]
        ct_arg_types = [KNOWN_TYPES.get(arg.ctype, None) for arg in es2func.args]
        # Set argument types on ctypes function
        if None in ct_arg_types:
            argstr = 'UNKNOWN_ARGTYPES'
        elif es2func.group:
            argstr = 'UNKNOWN_ARGTYPES'
        else:
            argstr = ', '.join(['ctypes.%s' % t[1] for t in ct_arg_types[1:]])
            argstr = '()' if not argstr else '(%s,)' % argstr
        # Set output arg (if available)
        if ct_arg_types[0][0] != type(None):
            resstr = 'ctypes.%s' % ct_arg_types[0][1]
        else:
            resstr = 'None'
        return resstr, argstr
    
    
    def _write_argtypes(self, es2func):
        lines = self.lines
        ce_arg_types = [arg.ctype for arg in es2func.args[1:]]
        ct_arg_types = [KNOWN_TYPES.get(arg.ctype, None) for arg in es2func.args]
        # Set argument types on ctypes function
        if None in ct_arg_types:
            lines.append('# todo: unknown argtypes')
        elif es2func.group:
            lines.append('# todo: oops, dont set argtypes for group!')
        else:
            if ct_arg_types[1:]:
                argstr = ', '.join(['ctypes.%s' % t[1] for t in ct_arg_types[1:]])
                lines.append('_lib.%s.argtypes = %s,' % (es2func.glname, argstr))
            else:
                lines.append('_lib.%s.argtypes = ()' % es2func.glname)
        # Set output arg (if available)
        if ct_arg_types[0][0] != type(None):
            lines.append('_lib.%s.restype = ctypes.%s' % (es2func.glname, ct_arg_types[0][1]))
    
    def _native_call_line(self, name, es2func, cargstr=None, prefix='', indent=4):
        #'_lib.%s(%s)' % (des.es2.glname, cargstr)
        resstr, argstr = self._get_argtype_str(es2func)
        if cargstr is None:
            cargs = [arg.name for arg in es2func.args[1:]]
            cargstr = ', '.join(cargs)
        
        lines = 'try:\n'
        lines += '    nativefunc = %s._native\n' % apiname(name)
        lines += 'except AttributeError:\n'
        lines += '    nativefunc = %s._native = _get_gl_func("%s", %s, %s)\n' % (
                apiname(name), es2func.glname, resstr, argstr)
        lines += '%snativefunc(%s)\n' % (prefix, cargstr)
        
        #lines += 'check_error("%s")' % name
        
        lines = [' '*indent + line for line in lines.splitlines()]
        return '\n'.join(lines)
        
    
    def _add_function(self, des):
        lines = self.lines
        es2func = des.es2
        
        # Write arg types
        if self.define_argtypes_in_module:
            self._write_argtypes(es2func)
        
        # Get names and types of C-API
        ce_arg_types = [arg.ctype for arg in es2func.args[1:]]
        ce_arg_names = [arg.name for arg in es2func.args[1:]]
        ct_arg_types = [KNOWN_TYPES.get(arg.ctype, None) for arg in es2func.args]
        ct_arg_types_easy = [EASY_TYPES.get(arg.ctype, None) for arg in es2func.args]
        
        # Write C function signature, for debugging and development
        if self.write_c_sig:
            argnamesstr = ', '.join([c_type+' '+c_name for c_type, c_name in zip(ce_arg_types, ce_arg_names)])
            lines.append('# %s = %s(%s)' % (es2func.args[0].ctype, es2func.oname, argnamesstr))
        
        # Write Python function def
        lines.append('def %s(%s):' % (des.apiname,  ', '.join(des.args)))
        
        # Construct C function call
        cargs = [arg.name for arg in des.es2.args[1:]]
        cargstr = ', '.join(cargs)
        #callline = '_lib.%s(%s)' % (des.es2.glname, cargstr)
        
        # Now write the body of the function ...
        if des.ann:
            prefix = 'res = '
            # Annotation available
            functions_anno.add(des.name)
            callline = self._native_call_line(des.name, es2func, prefix=prefix)
            lines.extend( des.ann.get_lines(callline, 'desktop') )
        
        elif es2func.group:
            # Group?
            functions_todo.add(des.name)
            lines.append('    pass  # todo: Oops. this is a group!')
        elif None in ct_arg_types_easy:
            functions_todo.add(des.name)
            lines.append('    pass  # todo: Not all easy types!')
        elif des.args != [arg.name for arg in des.wgl.args[1:]]:
            functions_todo.add(des.name)
            lines.append('    pass  # todo: ES 2.0 and WebGL args do not match!')
        else:
            # This one is easy!
            functions_auto.add(des.name)
            # Get prefix
            prefix = ''
            if ct_arg_types[0][0] != type(None):
                prefix = 'return '
            elif des.es2.shortname.startswith('get'):
                raise RuntimeError('Get func returns void?')
            # Set string
            callline = self._native_call_line(des.name, des.es2, prefix=prefix)
            lines.append(callline)
        
        
        if 'desktop' in self.__class__.__name__.lower():
            # Post-fix special cases for desktop gl. See discussion in #201
            # glDepthRangef and glClearDepthf are not always available,
            # and sometimes they do not work if they are
            if es2func.oname in ('glDepthRangef', 'glClearDepthf'):
                for i in range(1,10):
                    line = lines[-i]
                    if not line.strip() or line.startswith('#'):
                        break
                    line = line.replace('c_float', 'c_double')
                    line = line.replace('glDepthRangef', 'glDepthRange')
                    line = line.replace('glClearDepthf', 'glClearDepth')
                    lines[-i] = line
    
    
    def _add_group_function(self, des, sig, es2func):
        lines = self.lines
        handled = True
        
        call_line = self._native_call_line
        
        if self.define_argtypes_in_module:
            self._write_argtypes(es2func)
        
        funcname = sig.split('(', 1)[0]
        args = sig.split('(', 1)[1].split(')')[0]
        cfuncname = 'gl' + funcname[0].upper() + funcname[1:]
        
        if des.name == 'uniform':
            if funcname[-1] != 'v':
                lines.append('def %s:' % sig)
                lines.append(call_line(funcname, es2func, args))
            else:
                t = {'f':'float', 'i':'int'}[funcname[-2]]
                lines.append('def %s:' % sig)
                lines.append('    values = [%s(val) for val in values]' % t)
                lines.append('    values = (ctypes.c_%s*len(values))(*values)' % t)
                lines.append(call_line(funcname, es2func, 'location, count, values'))
        elif des.name == 'uniformMatrix':
            lines.append('def %s:' % sig)
            lines.append('    if not values.flags["C_CONTIGUOUS"]:')
            lines.append('        values = values.copy()')
            lines.append('    assert values.dtype.name == "float32"')
            lines.append('    values_ = values')
            lines.append('    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))')
            lines.append(call_line(funcname, es2func, 'location, count, transpose, values'))
        elif des.name == 'vertexAttrib':
            lines.append('def %s:' % sig)
            lines.append(call_line(funcname, es2func, args))
        elif des.name == 'texParameter':
            lines.append('def %s:' % sig)
            lines.append(call_line(funcname, es2func, args))
        
        else:
            raise ValueError('unknown group func')


class AngleApiGenrator(DesktopApiGenerator):
    """ Generator for the Angle backend (GL to Directx conversion on
    Windows). Very similar to the desktop API, but we do not need that
    deferred loading of GL functions here.
    """
    
    filename = os.path.join(GLDIR, '_angle.py')
    write_c_sig = True
    define_argtypes_in_module = True
    
    DESCRIPTION = "GL ES 2.0 API based on the Angle library (i.e. DirectX)"
    PREAMBLE = """
    import ctypes
    from .angle import _lib
    """
    
    def _native_call_line(self, name, es2func, cargstr=None, prefix='', indent=4):
        resstr, argstr = self._get_argtype_str(es2func)
        if cargstr is None:
            cargs = [arg.name for arg in es2func.args[1:]]
            cargstr = ', '.join(cargs)
        return ' '*indent + '%s_lib.%s(%s)' % (prefix, es2func.glname, cargstr)



class PyOpenGLApiGenrator(ApiGenerator):
    """ Generator for a fallback pyopengl backend.
    """
    
    filename = os.path.join(GLDIR, '_pyopengl.py')
    DESCRIPTION = 'Proxy API for GL ES 2.0 subset, via the PyOpenGL library.'
    PREAMBLE = """
    import ctypes
    from OpenGL import GL
    import OpenGL.GL.framebufferobjects as FBO
    """
    
    def __init__(self):
        ApiGenerator.__init__(self)
        self._functions_to_import = []

    def _add_function(self, des):
        # Fix for FBO?
        mod = 'GL'
        if 'renderbuffer' in des.name.lower() or 'framebuffer' in des.name.lower():
            mod = 'FBO'
        # Get call line
        argstr = ', '.join(des.args)
        call_line = '    return %s.%s(%s)' % (mod, des.es2.glname, argstr)
        # Get annotation lines
        ann_lines = []
        if des.ann is not None:
            ann_lines = des.ann.get_lines(call_line, 'pyopengl')
        # Use annotation or not
        if ann_lines:
            self.lines.append('def %s(%s):' % (des.apiname, argstr))
            self.lines.extend(ann_lines)
        else:
            # To be imported from OpenGL.GL
            self._functions_to_import.append((des.es2.glname, des.apiname))
    
    def _add_group_function(self, des, sig, es2func):
        # All group functions can be directly imported from OpenGL
        funcname = apiname(sig.split('(')[0])
        self._functions_to_import.append((funcname, funcname))
    
    def save(self):
        # Write remaining functions
        self.lines.append('# List of functions that we should import from OpenGL.GL')
        self.lines.append('_functions_to_import = [')
        for name1, name2 in self._functions_to_import:
            self.lines.append('    ("%s", "%s"),' % (name1, name2))
        self.lines.append('    ]')
        
        # Really save
        ApiGenerator.save(self)


## Generate

# Generate
for Gen in [ProxyApiGenerator, DesktopApiGenerator, AngleApiGenrator, 
            PyOpenGLApiGenrator]:
    gen = Gen()
    for des in functions:
        gen.add_function(des)
    gen.save()



########NEW FILE########
__FILENAME__ = headerparser
# -*- coding: utf-8 -*-
# Copyright (c) 2013, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

""" Code to parse a header file and create a list of constants,
functions (with arguments). This information can then be used to
autogenerate our OpenGL API.
"""

import os
import sys


def getwords(line):
    """ Get words on a line.
    """
    line = line.replace('\t', ' ').strip()
    return [w for w in line.split(' ') if w]


# Keep track of all constants in case they are "reused" (i.e. aliases)
CONSTANTS = {}


class Parser:
    """ Class to parse header files. It can deal with gl2.h and webgl.idl,
    as well as some desktop OpenGL header files. It produces a list of
    ConstantDefition objects and FunctionDefinition objects, which can 
    be accessed via a dict.
    """

    def __init__(self, header_file, parse_now=True):
        # Get filenames for C and Py
        self._c_fname = c_fname = os.path.split(header_file)[1]

        # Get absolute filenames
        self._c_filename = header_file

        # Init intermediate results
        self._functionDefs = []
        self._constantDefs = []

        # Init output
        self._functions = {}
        self._constants = {}

        # We are aware of the line number
        self._linenr = 0

        # Some stats
        self.stat_types = set()

        if parse_now:
            self.parse()

    def __iadd__(self, definition):
        """ Add an output line. Can be multiple lines.
        """
        # Create comment
        definition.comment = 'line %i of %s' % (self._linenr, self._c_fname)
        # Add to lists
        if isinstance(definition, FunctionDefinition):
            self._functionDefs.append(definition)
        elif isinstance(definition, ConstantDefinition):
            self._constantDefs.append(definition)
        return self

    def _get_line(self):
        # Get a stripped line, and keep track of line nr, skip empty lines
        line = ''
        while not line:
            line = self._file.readline()
            if not line:
                raise StopIteration()
            line = line.strip()
            self._linenr += 1
        return line

    def _get_lines(self):
        # Easy iterator
        while True:
            yield self._get_line()

    def parse(self):
        """ Parse the header file!
        """

        # Open file
        self._file = open(self._c_filename, 'rt', encoding='utf-8')

        # Parse the file
        for line in self._get_lines():
            if line.startswith('#define'):
                self += ConstantDefinition(line)
            elif line.startswith('const GLenum'):
                self += ConstantDefinition(line)
            elif '(' in line:
                while ')' not in line:
                    line += self._get_line()
                if line.endswith(');'):
                    self += FunctionDefinition(line)

        # Remove invalid defs
        self._functionDefs = [d for d in self._functionDefs if d.isvalid]
        self._constantDefs = [d for d in self._constantDefs if d.isvalid]

        # Collect multipe similar functions in groups
        self._functionDefs.sort(key=lambda x: x.glname)
        keyDef = None
        keyDefs = []
        for funcDef in [f for f in self._functionDefs]:
            # Check if we need a new keydef
            if funcDef.extrachars:
                # Create new keydef or use old one?
                if keyDef and keyDef.glname == funcDef.keyname:
                    pass  # Keep same keydef
                else:
                    keyDef = FunctionGroup(funcDef.line)  # New keydef
                    keyDef._set_name(funcDef.keyname)
                    keyDefs.append(keyDef)
                # Add to group
                keyDef.group.append(funcDef)
        # Process function groups
        for keyDef in keyDefs:
            if len(keyDef.group) > 1:
                self._functionDefs.append(keyDef)
                for d in keyDef.group:
                    self._functionDefs.remove(d)

        # Sort constants and functions
        self._functionDefs.sort(key=lambda x: x.glname)
        self._constantDefs.sort(key=lambda x: x.glname)

        # Get dicts
        for definition in self._functionDefs:
            self._functions[definition.shortname] = definition
        for definition in self._constantDefs:
            self._constants[definition.shortname] = definition

        # Get some stats
        for funcDef in self._functionDefs:
            for arg in funcDef.args:
                self.stat_types.add(arg.ctype)

        # Show stats
        n1 = len([d for d in self._constantDefs])
        n2 = len([d for d in self._functionDefs])
        n3 = len([d for d in self._functionDefs if d.group])
        n4 = sum([len(d.group) for d in self._functionDefs if d.group])
        print('Found %i constants and %i unique functions (%i groups contain %i functions)").' % (
            n1, n2, n3, n4))

        print('C-types found in args:', self.stat_types)

    @property
    def constant_names(self):
        """ Sorted list of constant names.
        """
        return [d.shortname for d in self._constantDefs]

    @property
    def function_names(self):
        """ Sorted list of function names.
        """
        return [d.shortname for d in self._functionDefs]

    @property
    def constants(self):
        """ Dict with all the constants.
        """
        return self._constants

    @property
    def functions(self):
        """ Dict witj all the functions.
        """
        return self._functions

    def show_groups(self):
        for d in self._functionDefs:
            if isinstance(d.group, list):
                print(d.keyname)
                for d2 in d.group:
                    print('  ', d2.glname)



class Definition:
    """ Abstract class to represent a constant or function definition.
    """

    def __init__(self, line):
        self.line = line
        self.isvalid = True
        self.comment = ''
        self.oname = ''  # original name
        self.shortname = self.glname = ''  # short and long name
        self.parse_line(line)

    def parse_line(self, line):
        # Do initial parsing of the incoming line
        # (which may be multiline, actually)
        pass

    def _set_name(self, name):
        # Store original name
        self.oname = name
        # Store plain name
        if name.startswith('GL_'):
            name = name[3:]
        elif name.startswith('gl'):
            name = name[2].lower() + name[3:]
        self.shortname = name
        # Store gl name
        if name.upper() == name:
            name = 'GL_' + name
        else:
            name = 'gl' + name[0].upper() + name[1:]
        self.glname = name



class ConstantDefinition(Definition):

    def parse_line(self, line):
        """ Set cname and value attributes.
        """
        self.value = None
        line = line.split('/*', 1)[0]
        _, *args = getwords(line)
        self.isvalid = False
        if len(args) == 1:
            pass
        elif len(args) == 2:
            # Set name
            name, val = args
            self.isvalid = bool(name)
            self._set_name(name)
            self._set_value_from_string(val)
        elif '=' in args:
            name, val = args[-3], args[-1]
            self.isvalid = bool(name)
            self._set_name(name)
            self._set_value_from_string(val)
        else:
            print('Dont know what to do with "%s"' % line)

        # For when this constant is reused to set another constant
        if self.value is not None:
            CONSTANTS[self.oname] = self.value

    def _set_value_from_string(self, val):
        # Set value
        val = val.strip(';')
        if val.startswith('0x'):
            self.value = int(val[2:].rstrip('ul'), 16)
        elif val[0] in '0123456789':
            self.value = int(val)
        elif val.startswith("'"):
            self.value = val
        elif val in CONSTANTS:
            self.value = CONSTANTS[val]
        else:
            print('Warning: Dont know what to do with "%s"' % line)



class FunctionDefinition(Definition):
    
    SKIPTYPECHARS = 'if'  # 'bsifd'
    ALLSKIPCHARS = SKIPTYPECHARS + 'v1234'
    
    def parse_line(self, line):
        """ Set cname, keyname, cargs attributes.
        The list of args always has one entry and the first entry is always
        the output (can be void).
        """
        # Parse components
        beforeBrace, args = line.split('(', 1)
        betweenBraces, _ = args.split(')', 1)
        *prefix, name = getwords(beforeBrace)

        # Store name
        self._set_name(name)

        # Possibly, this function belongs to a collection of similar functions,
        # which we are going to replace with one function in Python.
        self.keyname = self.glname.rstrip('v').rstrip(self.SKIPTYPECHARS).rstrip('1234')
        self.extrachars = self.matchKeyName(self.keyname)
        
        # If this is a list, this instance represents the group
        # If this is True, this instance is in a group (but not the
        # representative)
        self.group = None

        # Create list of Argument instances
        self.cargs = [arg.strip() for arg in betweenBraces.split(',')]
        self.args = []
        # Set output arg
        self.args.append(Argument(' '.join(prefix), False))
        # Parse input arguments,
        for arg in self.cargs:
            if arg and arg != 'void':
                self.args.append(Argument(arg))

    def matchKeyName(self, keyname):
        if self.glname.startswith(keyname):
            extrachars = self.glname[len(keyname):]
            if all([(c in self.ALLSKIPCHARS) for c in extrachars]):
                return extrachars



class FunctionGroup(FunctionDefinition):

    def parse_line(self, line):
        FunctionDefinition.parse_line(self, line)
        self.group = []



class Argument:

    def __init__(self, argAsString, cinput=True):
        # Parse string
        components = [c for c in argAsString.split(' ') if c]
        if len(components) == 1:
            name = 'unknown_name'
            type = components[0]
        else:
            name = components[-1]
            type = components[-2]
            if 'const' in type:
                type = components[-3]  # glShaderSource has "const GLchar* const* string"
        # Store stuff
        self.orig = tuple(components)
        self.name = name.lstrip('*')
        self.isptr = argAsString.count('*')  # Number of stars
        self.ctype = type.strip('*') + '*'*self.isptr
        # Status flags
        self.cinput = cinput



if __name__ == '__main__':
    THISDIR = os.path.abspath(os.path.dirname(__file__))

    # Some tests ...
    gl2 = Parser(os.path.join(THISDIR, 'headers', 'gl2.h'))
    import OpenGL.GL
    pygl = set([name for name in dir(OpenGL.GL)])

    # Test if all functions are in pyopengl
    for keyfunc in gl2._functionDefs:
        group = keyfunc.group or [keyfunc]
        for f in group:
            if f.glname not in pygl:
                print('Not in pyopengl:', f.glname)

    # Test if constant match with these in pyopengl
    for d in gl2._constantDefs:
        v1 = d.value
        try:
            v2 = getattr(OpenGL.GL, d.glname)
        except AttributeError:
            print(d.glname, 'is not in pyopengl')
        else:
            if v1 != v2:
                print(d.glname, 'does not match: %r vs %r' % (v1, int(v2)))

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# vispy documentation build configuration file, created by
# sphinx-quickstart on Sat May  4 16:52:02 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
#sys.path.insert(0, os.path.abspath('.'))
curpath = os.path.dirname(__file__)
sys.path.append(os.path.abspath('ext'))

# -- General configuration -----------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.pngmath',
              'sphinx.ext.autosummary',  # 'plot2rst',
              'sphinx.ext.intersphinx',
              'numpydoc',
              'vispy_ext', ]  # 'scriptnamemangler',]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'vispy'
copyright = u'2013, vispy contributers'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
import vispy
# The short X.Y version.
version = vispy.__version__[:3]
# The full version, including alpha/beta/rc tags.
release = vispy.__version__


# -- General configuration -----------------------------------------------

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------

# The theme to use for HTML and HTML Help pages. Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'scikit-image'

# Theme options are theme-specific and customize the look and feel of a theme
# further. For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['themes']

# The name for this set of Sphinx documents. If None, it defaults to
# "<project> v<release> documentation".
html_title = 'vispy v%s docs' % version

# A shorter title for the navigation bar. Default is the same as html_title.
#html_short_title = None

# The name of an image file (within the static path) to use as favicon of the
# docs. This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = []  # '_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    '**': ['navigation.html',
           'localtoc.html',
           'versions.html'],
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it. The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'vispydoc'


# -- Options for LaTeX output --------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('contents', 'vispy.tex', u'The visoy Documentation',
     u'vispy development team', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
latex_preamble = r'''
\usepackage{enumitem}
\setlistdepth{100}

\usepackage{amsmath}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}

% In the parameters section, place a newline after the Parameters header
\usepackage{expdlist}
\let\latexdescription=\description
\def\description{\latexdescription{}{} \breaklabel}

% Make Examples/etc section headers smaller and more compact
\makeatletter
\titleformat{\paragraph}{\normalsize\py@HeaderFamily}%
{\py@TitleColor}{0em}{\py@TitleColor}{\py@NormalColor}
\titlespacing*{\paragraph}{0pt}{1ex}{0pt}
\makeatother

'''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
latex_use_modindex = False

# -----------------------------------------------------------------------------
# Numpy extensions
# -----------------------------------------------------------------------------
numpydoc_show_class_members = False

# -----------------------------------------------------------------------------
# Plots
# -----------------------------------------------------------------------------
plot_basedir = os.path.join(curpath, "plots")
plot_pre_code = """
import numpy as np
import matplotlib.pyplot as plt
np.random.seed(0)

import matplotlib
matplotlib.rcParams.update({
'font.size': 14,
'axes.titlesize': 12,
'axes.labelsize': 10,
'xtick.labelsize': 8,
'ytick.labelsize': 8,
'legend.fontsize': 10,
'figure.subplot.bottom': 0.2,
'figure.subplot.left': 0.2,
'figure.subplot.right': 0.9,
'figure.subplot.top': 0.85,
'figure.subplot.wspace': 0.4,
'text.usetex': False,
})

"""
plot_include_source = True
plot_formats = [('png', 100), ('pdf', 100)]

plot2rst_index_name = 'README'
plot2rst_rcparams = {'image.cmap': 'gray',
                     'image.interpolation': 'none'}

# -----------------------------------------------------------------------------
# intersphinx
# -----------------------------------------------------------------------------
_python_doc_base = 'http://docs.python.org/2.7'
intersphinx_mapping = {
    _python_doc_base: None,
    'http://docs.scipy.org/doc/numpy': None,
    'http://docs.scipy.org/doc/scipy/reference': None,
    'http://vispy.org/stable': None
}

########NEW FILE########
__FILENAME__ = docscrape
"""Extract reference documentation from the NumPy source tree.

"""

import inspect
import textwrap
import re
import pydoc
try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO
from warnings import warn


class Reader(object):

    """A line-based string reader.

    """

    def __init__(self, data):
        """
        Parameters
        ----------
        data : str
           String with lines separated by '\n'.

        """
        if isinstance(data, list):
            self._str = data
        else:
            self._str = data.split('\n')  # store string as list of lines

        self.reset()

    def __getitem__(self, n):
        return self._str[n]

    def reset(self):
        self._l = 0  # current line nr

    def read(self):
        if not self.eof():
            out = self[self._l]
            self._l += 1
            return out
        else:
            return ''

    def seek_next_non_empty_line(self):
        for l in self[self._l:]:
            if l.strip():
                break
            else:
                self._l += 1

    def eof(self):
        return self._l >= len(self._str)

    def read_to_condition(self, condition_func):
        start = self._l
        for line in self[start:]:
            if condition_func(line):
                return self[start:self._l]
            self._l += 1
            if self.eof():
                return self[start:self._l + 1]
        return []

    def read_to_next_empty_line(self):
        self.seek_next_non_empty_line()

        def is_empty(line):
            return not line.strip()
        return self.read_to_condition(is_empty)

    def read_to_next_unindented_line(self):
        def is_unindented(line):
            return (line.strip() and (len(line.lstrip()) == len(line)))
        return self.read_to_condition(is_unindented)

    def peek(self, n=0):
        if self._l + n < len(self._str):
            return self[self._l + n]
        else:
            return ''

    def is_empty(self):
        return not ''.join(self._str).strip()


class NumpyDocString(object):

    def __init__(self, docstring, config={}):
        docstring = textwrap.dedent(docstring).split('\n')

        self._doc = Reader(docstring)
        self._parsed_data = {
            'Signature': '',
            'Summary': [''],
            'Extended Summary': [],
            'Parameters': [],
            'Returns': [],
            'Raises': [],
            'Warns': [],
            'Other Parameters': [],
            'Attributes': [],
            'Methods': [],
            'See Also': [],
            'Notes': [],
            'Warnings': [],
            'References': '',
            'Examples': '',
            'index': {}
        }

        self._parse()

    def __getitem__(self, key):
        return self._parsed_data[key]

    def __setitem__(self, key, val):
        if not key in self._parsed_data:
            warn("Unknown section %s" % key)
        else:
            self._parsed_data[key] = val

    def _is_at_section(self):
        self._doc.seek_next_non_empty_line()

        if self._doc.eof():
            return False

        l1 = self._doc.peek().strip()  # e.g. Parameters

        if l1.startswith('.. index::'):
            return True

        l2 = self._doc.peek(1).strip()  # ---------- or ==========
        return l2.startswith('-' * len(l1)) or l2.startswith('=' * len(l1))

    def _strip(self, doc):
        i = 0
        j = 0
        for i, line in enumerate(doc):
            if line.strip():
                break

        for j, line in enumerate(doc[::-1]):
            if line.strip():
                break

        return doc[i:len(doc) - j]

    def _read_to_next_section(self):
        section = self._doc.read_to_next_empty_line()

        while not self._is_at_section() and not self._doc.eof():
            if not self._doc.peek(-1).strip():  # previous line was empty
                section += ['']

            section += self._doc.read_to_next_empty_line()

        return section

    def _read_sections(self):
        while not self._doc.eof():
            data = self._read_to_next_section()
            name = data[0].strip()

            if name.startswith('..'):  # index section
                yield name, data[1:]
            elif len(data) < 2:
                yield StopIteration
            else:
                yield name, self._strip(data[2:])

    def _parse_param_list(self, content):
        r = Reader(content)
        params = []
        while not r.eof():
            header = r.read().strip()
            if ' : ' in header:
                arg_name, arg_type = header.split(' : ')[:2]
            else:
                arg_name, arg_type = header, ''

            desc = r.read_to_next_unindented_line()
            desc = dedent_lines(desc)

            params.append((arg_name, arg_type, desc))

        return params

    _name_rgx = re.compile(r"^\s*(:(?P<role>\w+):`(?P<name>[a-zA-Z0-9_.-]+)`|"
                           r" (?P<name2>[a-zA-Z0-9_.-]+))\s*", re.X)

    def _parse_see_also(self, content):
        """
        func_name : Descriptive text
            continued text
        another_func_name : Descriptive text
        func_name1, func_name2, :meth:`func_name`, func_name3

        """
        items = []

        def parse_item_name(text):
            """Match ':role:`name`' or 'name'"""
            m = self._name_rgx.match(text)
            if m:
                g = m.groups()
                if g[1] is None:
                    return g[3], None
                else:
                    return g[2], g[1]
            raise ValueError("%s is not a item name" % text)

        def push_item(name, rest):
            if not name:
                return
            name, role = parse_item_name(name)
            items.append((name, list(rest), role))
            del rest[:]

        current_func = None
        rest = []

        for line in content:
            if not line.strip():
                continue

            m = self._name_rgx.match(line)
            if m and line[m.end():].strip().startswith(':'):
                push_item(current_func, rest)
                current_func, line = line[:m.end()], line[m.end():]
                rest = [line.split(':', 1)[1].strip()]
                if not rest[0]:
                    rest = []
            elif not line.startswith(' '):
                push_item(current_func, rest)
                current_func = None
                if ',' in line:
                    for func in line.split(','):
                        push_item(func, [])
                elif line.strip():
                    current_func = line
            elif current_func is not None:
                rest.append(line.strip())
        push_item(current_func, rest)
        return items

    def _parse_index(self, section, content):
        """
        .. index: default
           :refguide: something, else, and more

        """
        def strip_each_in(lst):
            return [s.strip() for s in lst]

        out = {}
        section = section.split('::')
        if len(section) > 1:
            out['default'] = strip_each_in(section[1].split(','))[0]
        for line in content:
            line = line.split(':')
            if len(line) > 2:
                out[line[1]] = strip_each_in(line[2].split(','))
        return out

    def _parse_summary(self):
        """Grab signature (if given) and summary"""
        if self._is_at_section():
            return

        summary = self._doc.read_to_next_empty_line()
        summary_str = " ".join([s.strip() for s in summary]).strip()
        if re.compile('^([\w., ]+=)?\s*[\w\.]+\(.*\)$').match(summary_str):
            self['Signature'] = summary_str
            if not self._is_at_section():
                self['Summary'] = self._doc.read_to_next_empty_line()
        else:
            self['Summary'] = summary

        if not self._is_at_section():
            self['Extended Summary'] = self._read_to_next_section()

    def _parse(self):
        self._doc.reset()
        self._parse_summary()

        for (section, content) in self._read_sections():
            if not section.startswith('..'):
                section = ' '.join([s.capitalize()
                                   for s in section.split(' ')])
            if section in ('Parameters', 'Attributes', 'Methods',
                           'Returns', 'Raises', 'Warns'):
                self[section] = self._parse_param_list(content)
            elif section.startswith('.. index::'):
                self['index'] = self._parse_index(section, content)
            elif section == 'See Also':
                self['See Also'] = self._parse_see_also(content)
            else:
                self[section] = content

    # string conversion routines

    def _str_header(self, name, symbol='-'):
        return [name, len(name) * symbol]

    def _str_indent(self, doc, indent=4):
        out = []
        for line in doc:
            out += [' ' * indent + line]
        return out

    def _str_signature(self):
        if self['Signature']:
            return [self['Signature'].replace('*', '\*')] + ['']
        else:
            return ['']

    def _str_summary(self):
        if self['Summary']:
            return self['Summary'] + ['']
        else:
            return []

    def _str_extended_summary(self):
        if self['Extended Summary']:
            return self['Extended Summary'] + ['']
        else:
            return []

    def _str_param_list(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            for param, param_type, desc in self[name]:
                out += ['%s : %s' % (param, param_type)]
                out += self._str_indent(desc)
            out += ['']
        return out

    def _str_section(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            out += self[name]
            out += ['']
        return out

    def _str_see_also(self, func_role):
        if not self['See Also']:
            return []
        out = []
        out += self._str_header("See Also")
        last_had_desc = True
        for func, desc, role in self['See Also']:
            if role:
                link = ':%s:`%s`' % (role, func)
            elif func_role:
                link = ':%s:`%s`' % (func_role, func)
            else:
                link = "`%s`_" % func
            if desc or last_had_desc:
                out += ['']
                out += [link]
            else:
                out[-1] += ", %s" % link
            if desc:
                out += self._str_indent([' '.join(desc)])
                last_had_desc = True
            else:
                last_had_desc = False
        out += ['']
        return out

    def _str_index(self):
        idx = self['index']
        out = []
        out += ['.. index:: %s' % idx.get('default', '')]
        for section, references in idx.items():
            if section == 'default':
                continue
            out += ['   :%s: %s' % (section, ', '.join(references))]
        return out

    def __str__(self, func_role=''):
        out = []
        out += self._str_signature()
        out += self._str_summary()
        out += self._str_extended_summary()
        for param_list in ('Parameters', 'Returns', 'Raises'):
            out += self._str_param_list(param_list)
        out += self._str_section('Warnings')
        out += self._str_see_also(func_role)
        for s in ('Notes', 'References', 'Examples'):
            out += self._str_section(s)
        for param_list in ('Attributes', 'Methods'):
            out += self._str_param_list(param_list)
        out += self._str_index()
        return '\n'.join(out)


def indent(str, indent=4):
    indent_str = ' ' * indent
    if str is None:
        return indent_str
    lines = str.split('\n')
    return '\n'.join(indent_str + l for l in lines)


def dedent_lines(lines):
    """Deindent a list of lines maximally"""
    return textwrap.dedent("\n".join(lines)).split("\n")


def header(text, style='-'):
    return text + '\n' + style * len(text) + '\n'


class FunctionDoc(NumpyDocString):

    def __init__(self, func, role='func', doc=None, config={}):
        self._f = func
        self._role = role  # e.g. "func" or "meth"

        if doc is None:
            if func is None:
                raise ValueError("No function or docstring given")
            doc = inspect.getdoc(func) or ''
        NumpyDocString.__init__(self, doc)

        if not self['Signature'] and func is not None:
            func, func_name = self.get_func()
            try:
                # try to read signature
                argspec = inspect.getargspec(func)
                argspec = inspect.formatargspec(*argspec)
                argspec = argspec.replace('*', '\*')
                signature = '%s%s' % (func_name, argspec)
            except TypeError as e:
                signature = '%s()' % func_name
            self['Signature'] = signature

    def get_func(self):
        func_name = getattr(self._f, '__name__', self.__class__.__name__)
        if inspect.isclass(self._f):
            func = getattr(self._f, '__call__', self._f.__init__)
        else:
            func = self._f
        return func, func_name

    def __str__(self):
        out = ''

        func, func_name = self.get_func()
        signature = self['Signature'].replace('*', '\*')

        roles = {'func': 'function',
                 'meth': 'method'}

        if self._role:
            if not self._role in roles:
                print("Warning: invalid role %s" % self._role)
            out += '.. %s:: %s\n    \n\n' % (roles.get(self._role, ''),
                                             func_name)

        out += super(FunctionDoc, self).__str__(func_role=self._role)
        return out


class ClassDoc(NumpyDocString):

    def __init__(self, cls, doc=None, modulename='', func_doc=FunctionDoc,
                 config={}):
        if not inspect.isclass(cls) and cls is not None:
            raise ValueError("Expected a class or None, but got %r" % cls)
        self._cls = cls

        if modulename and not modulename.endswith('.'):
            modulename += '.'
        self._mod = modulename

        if doc is None:
            if cls is None:
                raise ValueError("No class or documentation string given")
            doc = pydoc.getdoc(cls)

        NumpyDocString.__init__(self, doc)

        if config.get('show_class_members', True):
            if not self['Methods']:
                self['Methods'] = [(name, '', '')
                                   for name in sorted(self.methods)]
            if not self['Attributes']:
                self['Attributes'] = [(name, '', '')
                                      for name in sorted(self.properties)]

    @property
    def methods(self):
        if self._cls is None:
            return []
        return [name for name, func in inspect.getmembers(self._cls)
                if not name.startswith('_') and callable(func)]

    @property
    def properties(self):
        if self._cls is None:
            return []
        return [name for name, func in inspect.getmembers(self._cls)
                if not name.startswith('_') and func is None]

########NEW FILE########
__FILENAME__ = docscrape_sphinx
import re
import inspect
import textwrap
import pydoc
import sphinx
from docscrape import NumpyDocString, FunctionDoc, ClassDoc


class SphinxDocString(NumpyDocString):

    def __init__(self, docstring, config={}):
        self.use_plots = config.get('use_plots', False)
        NumpyDocString.__init__(self, docstring, config=config)

    # string conversion routines
    def _str_header(self, name, symbol='`'):
        return ['.. rubric:: ' + name, '']

    def _str_field_list(self, name):
        return [':' + name + ':']

    def _str_indent(self, doc, indent=4):
        out = []
        for line in doc:
            out += [' ' * indent + line]
        return out

    def _str_signature(self):
        return ['']
        if self['Signature']:
            return ['``%s``' % self['Signature']] + ['']
        else:
            return ['']

    def _str_summary(self):
        return self['Summary'] + ['']

    def _str_extended_summary(self):
        return self['Extended Summary'] + ['']

    def _str_param_list(self, name):
        out = []
        if self[name]:
            out += self._str_field_list(name)
            out += ['']
            for param, param_type, desc in self[name]:
                out += self._str_indent(['**%s** : %s' % (param.strip(),
                                                          param_type)])
                out += ['']
                out += self._str_indent(desc, 8)
                out += ['']
        return out

    @property
    def _obj(self):
        if hasattr(self, '_cls'):
            return self._cls
        elif hasattr(self, '_f'):
            return self._f
        return None

    def _str_member_list(self, name):
        """
        Generate a member listing, autosummary:: table where possible,
        and a table where not.

        """
        out = []
        if self[name]:
            out += ['.. rubric:: %s' % name, '']
            prefix = getattr(self, '_name', '')

            if prefix:
                prefix = '~%s.' % prefix

            autosum = []
            others = []
            for param, param_type, desc in self[name]:
                param = param.strip()
                if not self._obj or hasattr(self._obj, param):
                    autosum += ["   %s%s" % (prefix, param)]
                else:
                    others.append((param, param_type, desc))

            if autosum:
                out += ['.. autosummary::', '   :toctree:', '']
                out += autosum

            if others:
                maxlen_0 = max([len(x[0]) for x in others])
                maxlen_1 = max([len(x[1]) for x in others])
                hdr = "=" * maxlen_0 + "  " + "=" * maxlen_1 + "  " + "=" * 10
                fmt = '%%%ds  %%%ds  ' % (maxlen_0, maxlen_1)
                n_indent = maxlen_0 + maxlen_1 + 4
                out += [hdr]
                for param, param_type, desc in others:
                    out += [fmt % (param.strip(), param_type)]
                    out += self._str_indent(desc, n_indent)
                out += [hdr]
            out += ['']
        return out

    def _str_section(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            out += ['']
            content = textwrap.dedent("\n".join(self[name])).split("\n")
            out += content
            out += ['']
        return out

    def _str_see_also(self, func_role):
        out = []
        if self['See Also']:
            see_also = super(SphinxDocString, self)._str_see_also(func_role)
            out = ['.. seealso::', '']
            out += self._str_indent(see_also[2:])
        return out

    def _str_warnings(self):
        out = []
        if self['Warnings']:
            out = ['.. warning::', '']
            out += self._str_indent(self['Warnings'])
        return out

    def _str_index(self):
        idx = self['index']
        out = []
        if len(idx) == 0:
            return out

        out += ['.. index:: %s' % idx.get('default', '')]
        for section, references in idx.items():
            if section == 'default':
                continue
            elif section == 'refguide':
                out += ['   single: %s' % (', '.join(references))]
            else:
                out += ['   %s: %s' % (section, ','.join(references))]
        return out

    def _str_references(self):
        out = []
        if self['References']:
            out += self._str_header('References')
            if isinstance(self['References'], str):
                self['References'] = [self['References']]
            out.extend(self['References'])
            out += ['']
            # Latex collects all references to a separate bibliography,
            # so we need to insert links to it
            if sphinx.__version__ >= "0.6":
                out += ['.. only:: latex', '']
            else:
                out += ['.. latexonly::', '']
            items = []
            for line in self['References']:
                m = re.match(r'.. \[([a-z0-9._-]+)\]', line, re.I)
                if m:
                    items.append(m.group(1))
            out += ['   ' + ", ".join(["[%s]_" % item for item in items]), '']
        return out

    def _str_examples(self):
        examples_str = "\n".join(self['Examples'])

        if (self.use_plots and 'import matplotlib' in examples_str
                and 'plot::' not in examples_str):
            out = []
            out += self._str_header('Examples')
            out += ['.. plot::', '']
            out += self._str_indent(self['Examples'])
            out += ['']
            return out
        else:
            return self._str_section('Examples')

    def __str__(self, indent=0, func_role="obj"):
        out = []
        out += self._str_signature()
        out += self._str_index() + ['']
        out += self._str_summary()
        out += self._str_extended_summary()
        for param_list in ('Parameters', 'Returns', 'Raises'):
            out += self._str_param_list(param_list)
        out += self._str_warnings()
        out += self._str_see_also(func_role)
        out += self._str_section('Notes')
        out += self._str_references()
        out += self._str_examples()
        for param_list in ('Attributes', 'Methods'):
            out += self._str_member_list(param_list)
        out = self._str_indent(out, indent)
        return '\n'.join(out)


class SphinxFunctionDoc(SphinxDocString, FunctionDoc):

    def __init__(self, obj, doc=None, config={}):
        self.use_plots = config.get('use_plots', False)
        FunctionDoc.__init__(self, obj, doc=doc, config=config)


class SphinxClassDoc(SphinxDocString, ClassDoc):

    def __init__(self, obj, doc=None, func_doc=None, config={}):
        self.use_plots = config.get('use_plots', False)
        ClassDoc.__init__(self, obj, doc=doc, func_doc=None, config=config)


class SphinxObjDoc(SphinxDocString):

    def __init__(self, obj, doc=None, config={}):
        self._f = obj
        SphinxDocString.__init__(self, doc, config=config)


def get_doc_object(obj, what=None, doc=None, config={}):
    if what is None:
        if inspect.isclass(obj):
            what = 'class'
        elif inspect.ismodule(obj):
            what = 'module'
        elif callable(obj):
            what = 'function'
        else:
            what = 'object'
    if what == 'class':
        return SphinxClassDoc(obj, func_doc=SphinxFunctionDoc, doc=doc,
                              config=config)
    elif what in ('function', 'method'):
        return SphinxFunctionDoc(obj, doc=doc, config=config)
    else:
        if doc is None:
            doc = pydoc.getdoc(obj)
        return SphinxObjDoc(obj, doc, config=config)

########NEW FILE########
__FILENAME__ = examplesgenerator
""" Called from vispy_conf.py to generate the examples for the docs from the
example Python files.
"""

from __future__ import print_function, division

import os
import sys
import shutil

try:
    from urllib2 import urlopen
except ImportError:
    from urllib.request import urlopen  # Py3k


THIS_DIR = os.path.dirname(os.path.abspath(__file__))
DOC_DIR = os.path.abspath(os.path.join(THIS_DIR, '..'))
EXAMPLES_DIR = os.path.abspath(os.path.join(DOC_DIR, '..', 'examples'))
OUTPUT_DIR = os.path.join(DOC_DIR, 'examples')


def clean():
    # Clear examples dir
    if os.path.isdir(OUTPUT_DIR):
        shutil.rmtree(OUTPUT_DIR)
    # Clean examples file
    fname = os.path.join(DOC_DIR, 'examples.rst')
    if os.path.isfile(fname):
        os.remove(fname)


def main():

    clean()

    if not os.path.isdir(OUTPUT_DIR):
        os.mkdir(OUTPUT_DIR)

    # Get examples and sort
    examples = list(get_example_filenames(EXAMPLES_DIR))
    examples.sort(key=lambda x: x[1])

    create_examples(examples)
    create_examples_list(examples)


def get_example_filenames(examples_dir):
    """ Yield (filename, name) elements for all examples. The examples
    are organized in directories, therefore the name can contain a
    forward slash.
    """
    for (dirpath, dirnames, filenames) in os.walk(examples_dir):
        for fname in filenames:
            if not fname.endswith('.py'):
                continue
            filename = os.path.join(dirpath, fname)
            name = filename[len(examples_dir):].lstrip('/\\')[:-3]
            name = name.replace('\\', '/')
            yield filename, name


def create_examples(examples):

    # Create doc file for each example
    for filename, name in examples:
        print('Writing example %s' % name)

        # Create title
        lines = []
        lines.append(name)
        lines.append('-' * len(lines[-1]))
        lines.append('')

        # Get source
        in_gallery = False
        doclines = []
        sourcelines = []
        with open(os.path.join(EXAMPLES_DIR, name + '.py')) as f:
            for line in f.readlines():
                line = line.rstrip()
                if line.startswith('# vispy:') and 'gallery' in line:
                    in_gallery = True
                if not doclines:
                    if line.startswith('"""'):
                        doclines.append(line.lstrip('" '))
                        sourcelines = []
                    else:
                        sourcelines.append('    ' + line)
                elif not sourcelines:
                    if '"""' in line:
                        sourcelines.append('    ' + line.partition('"""')[0])
                    else:
                        doclines.append(line)
                else:
                    sourcelines.append('    ' + line)

        # Add desciprion
        lines.extend(doclines)
        lines.append('')

        # Add source code
        lines.append('.. code-block:: python')
        lines.append('    ')
        lines.extend(sourcelines)
        lines.append('')

        # Write
        output_filename = os.path.join(OUTPUT_DIR, name + '.rst')
        output_dir = os.path.dirname(output_filename)
        if not os.path.isdir(output_dir):
            os.makedirs(output_dir)
        with open(output_filename, 'w') as f:
            f.write('\n'.join(lines))


def create_examples_list(examples):

    # Create TOC
    lines = []
    lines.append('List of examples')
    lines.append('=' * len(lines[-1]))
    lines.append('')

    # Add entry for each example that we know
    for _, name in examples:
        lines.append('* :doc:`examples/%s`' % name)

    # Write file
    with open(os.path.join(DOC_DIR, 'examples.rst'), 'w') as f:
        f.write('\n'.join(lines))


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = glapigenerator
""" Called from vispy_ext.py to generate the GL API.
"""

import os
from vispy.gloo import gl

THISDIR = os.path.dirname(os.path.abspath(__file__))
DOCSDIR = os.path.join(THISDIR, '..')


def clean():
    fname = os.path.join(DOCSDIR, 'gl.rst')
    if os.path.isfile(fname):
        os.remove(fname)


def parse_api(ob):
    # Parse the namespace
    const_names = []
    func_names = []
    for name in dir(ob):
        if name.startswith('GL_'):
            const_names.append(name)
        elif name.startswith('gl'):
            func_names.append(name)
    return const_names, func_names


def main():

    lines = []

    # Get info
    gl_const_names, gl_func_names = parse_api(gl)

    # Write title
    lines.append('OpenGL ES 2.0 API')
    lines.append('=' * len(lines[-1]))
    lines.append('')

    # Some info
    lines.append(
        'The ``vispy.gloo.gl`` namespace provides the OpenGL ES 2.0 API,')
    lines.append('Consisting of %i constants and %i functions ' %
                 (len(gl_const_names), len(gl_func_names)))

    # Write class header
    lines.append('**vispy.gloo.gl**\n')

    # Write constants and functions
    for name in sorted(gl_func_names):
        lines.append('  * %s()' % name)
    for name in sorted(gl_const_names):
        lines.append('  * %s' % name)

    # Write file
    with open(os.path.join(DOCSDIR, 'gl.rst'), 'w') as f:
        f.write('\n'.join(lines))


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = gloooverviewgenerator
""" Called from vispy_ext.py to generate the overview section of the
gloo docs. This section is simply added to gloo.__doc__.
"""

from vispy import gloo


def main():
    gloo.__doc__ += generate_overview_docs()


def clean():
    pass


def get_docs_for_class(klass):
    """ Get props and methods for a class.
    """

    # Prepare
    baseatts = dir(gloo.GLObject)
    functype = type(gloo.GLObject.activate)
    proptype = type(gloo.GLObject.handle)
    props, funcs = set(), set()

    for att in sorted(dir(klass)):
        if klass is not gloo.GLObject and att in baseatts:
            continue
        if att.startswith('_') or att.lower() != att:
            continue
        # Get ob and module name
        attob = getattr(klass, att)
        modulename = klass.__module__.split('.')[-1]
        # Get actual klass
        actualklass = klass
        while True:
            tmp = actualklass.__base__
            if att in dir(tmp):
                actualklass = tmp
            else:
                break
        if actualklass == klass:
            modulename = ''
        # Append
        if isinstance(attob, functype):
            funcs.add(' :meth:`~%s.%s.%s`,' % (
                modulename, actualklass.__name__, att))
        elif isinstance(attob, proptype):
            props.add(' :attr:`~%s.%s.%s`,' % (
                modulename, actualklass.__name__, att))
    # Done
    return props, funcs


def generate_overview_docs():
    """ Generate the overview section for the gloo docs.
    """

    lines = []
    lines.append('Overview')
    lines.append('=' * len(lines[-1]))
    klasseses = ((getattr(gloo, d),) for d in dir(gloo) if d[0].isupper())
    for klasses in klasseses:
        # Init line
        line = '*'
        for klass in klasses:
            line += ' :class:`%s`,' % klass.__name__
        line = line[:-1]
        # Get atts for these classes, sort by name, prop/func
        funcs, props = set(), set()
        for klass in klasses:
            props_, funcs_ = get_docs_for_class(klass)
            props.update(props_)
            funcs.update(funcs_)
        # Add props and funcs
        if props:
            line += '\n\n  * properties:'
            for item in sorted(props):
                line += item
        if funcs:
            line += '\n\n  * methods:'
            for item in sorted(funcs):
                line += item
            # Add line, strip last char
            lines.append(line[:-1])

    return '\n'.join(lines)

########NEW FILE########
__FILENAME__ = numpydoc
"""
========
numpydoc
========

Sphinx extension that handles docstrings in the Numpy standard format. [1]

It will:

- Convert Parameters etc. sections to field lists.
- Convert See Also section to a See also entry.
- Renumber references.
- Extract the signature from the docstring, if it can't be determined otherwise.

.. [1] http://projects.scipy.org/numpy/wiki/CodingStyleGuidelines#docstring-standard

"""

import os
import re
import pydoc
import sys
from docscrape_sphinx import get_doc_object, SphinxDocString
from sphinx.util.compat import Directive
import inspect
if sys.version_info > (3,):
    unicode = str


def mangle_docstrings(app, what, name, obj, options, lines,
                      reference_offset=[0]):

    cfg = dict(use_plots=app.config.numpydoc_use_plots,
               show_class_members=app.config.numpydoc_show_class_members)

    if what == 'module':
        # Strip top title
        title_re = re.compile(r'^\s*[#*=]{4,}\n[a-z0-9 -]+\n[#*=]{4,}\s*',
                              re.I | re.S)
        lines[:] = title_re.sub(u'', u"\n".join(lines)).split(u"\n")
    else:
        doc = get_doc_object(obj, what, u"\n".join(lines), config=cfg)
        lines[:] = unicode(doc).split(u"\n")

    if app.config.numpydoc_edit_link and hasattr(obj, '__name__') and \
            obj.__name__:
        if hasattr(obj, '__module__'):
            v = dict(full_name=u"%s.%s" % (obj.__module__, obj.__name__))
        else:
            v = dict(full_name=obj.__name__)
        lines += [u'', u'.. htmlonly::', '']
        lines += [u'    %s' % x for x in
                  (app.config.numpydoc_edit_link % v).split("\n")]

    # replace reference numbers so that there are no duplicates
    references = []
    for line in lines:
        line = line.strip()
        m = re.match(r'^.. \[([a-z0-9_.-])\]', line, re.I)
        if m:
            references.append(m.group(1))

    # start renaming from the longest string, to avoid overwriting parts
    references.sort(key=lambda x: -len(x))
    if references:
        for i, line in enumerate(lines):
            for r in references:
                if re.match(r'^\d+$', r):
                    new_r = u"R%d" % (reference_offset[0] + int(r))
                else:
                    new_r = u"%s%d" % (r, reference_offset[0])
                lines[i] = lines[i].replace(u'[%s]_' % r,
                                            u'[%s]_' % new_r)
                lines[i] = lines[i].replace(u'.. [%s]' % r,
                                            u'.. [%s]' % new_r)

    reference_offset[0] += len(references)


def mangle_signature(app, what, name, obj, options, sig, retann):
    # Do not try to inspect classes that don't define `__init__`
    if (inspect.isclass(obj) and
        (not hasattr(obj, '__init__') or
         'initializes x; see ' in pydoc.getdoc(obj.__init__))):
        return '', ''

    if not (callable(obj) or hasattr(obj, '__argspec_is_invalid_')):
        return
    if not hasattr(obj, '__doc__'):
        return

    doc = SphinxDocString(pydoc.getdoc(obj))
    if doc['Signature']:
        sig = re.sub(u"^[^(]*", u"", doc['Signature'])
        return sig, u''


def setup(app, get_doc_object_=get_doc_object):
    global get_doc_object
    get_doc_object = get_doc_object_

    app.connect('autodoc-process-docstring', mangle_docstrings)
    app.connect('autodoc-process-signature', mangle_signature)
    app.add_config_value('numpydoc_edit_link', None, False)
    app.add_config_value('numpydoc_use_plots', None, False)
    app.add_config_value('numpydoc_show_class_members', True, True)

    # Extra mangling domains
    app.add_domain(NumpyPythonDomain)
    app.add_domain(NumpyCDomain)

#------------------------------------------------------------------------------
# Docstring-mangling domains
#------------------------------------------------------------------------------

from docutils.statemachine import ViewList
from sphinx.domains.c import CDomain
from sphinx.domains.python import PythonDomain


class ManglingDomainBase(object):
    directive_mangling_map = {}

    def __init__(self, *a, **kw):
        super(ManglingDomainBase, self).__init__(*a, **kw)
        self.wrap_mangling_directives()

    def wrap_mangling_directives(self):
        for name, objtype in self.directive_mangling_map.items():
            self.directives[name] = wrap_mangling_directive(
                self.directives[name], objtype)


class NumpyPythonDomain(ManglingDomainBase, PythonDomain):
    name = 'np'
    directive_mangling_map = {
        'function': 'function',
        'class': 'class',
        'exception': 'class',
        'method': 'function',
        'classmethod': 'function',
        'staticmethod': 'function',
        'attribute': 'attribute',
    }


class NumpyCDomain(ManglingDomainBase, CDomain):
    name = 'np-c'
    directive_mangling_map = {
        'function': 'function',
        'member': 'attribute',
        'macro': 'function',
        'type': 'class',
        'var': 'object',
    }


def wrap_mangling_directive(base_directive, objtype):
    class directive(base_directive):

        def run(self):
            env = self.state.document.settings.env

            name = None
            if self.arguments:
                m = re.match(r'^(.*\s+)?(.*?)(\(.*)?', self.arguments[0])
                name = m.group(2).strip()

            if not name:
                name = self.arguments[0]

            lines = list(self.content)
            mangle_docstrings(env.app, objtype, name, None, None, lines)
            self.content = ViewList(lines, self.content.parent)

            return base_directive.run(self)

    return directive

########NEW FILE########
__FILENAME__ = scriptnamemangler
"""
Readthedocs replaces some javascript sources to pull them from their own
special server. Somehow their docstools.js is incompatibe, breaking
the search tool of the docs. This hopefully fixes that.
"""

import os
import shutil

THISDIR = os.path.abspath(os.path.dirname(__file__))
HTMLDIR = os.path.join(THISDIR, '..', '_build', 'html')


def init():
    pass


def clean(app, *args):
    # Rename doctools.js
    shutil.copy(os.path.join(HTMLDIR, '_static', 'doctools.js'),
                os.path.join(HTMLDIR, '_static', 'doctools_.js'))
    # Change reference
    search_html = os.path.join(HTMLDIR, 'search.html')
    text = open(search_html, 'rt').read()
    text = text.replace('/doctools.js', '/doctools_.js')
    open(search_html, 'wt').write(text)


def setup(app):
    init()
    app.connect('build-finished', clean)

########NEW FILE########
__FILENAME__ = vispy_ext
""" Invoke various functionality for vispy docs.
"""

import examplesgenerator
import glapigenerator
import gloooverviewgenerator


def init():
    print('Generating examples.')
    examplesgenerator.main()
    print('Generating GL API.')
    glapigenerator.main()
    print('Generating gloo overview section.')
    gloooverviewgenerator.main()


def clean(app, *args):
    examplesgenerator.clean()
    glapigenerator.clean()
    gloooverviewgenerator.clean()


def setup(app):
    init()
    app.connect('build-finished', clean)

########NEW FILE########
__FILENAME__ = simple-glut
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
from vispy.gloo import gl


def on_display():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
    glut.glutSwapBuffers()


def on_keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def on_idle():
    global t, t0, frames
    t = glut.glutGet(glut.GLUT_ELAPSED_TIME)
    frames = frames + 1
    elapsed = (t - t0) / 1000.0
    if elapsed > 2.5:
        print("FPS : %.2f (%d frames in %.2f second)"
              % (frames / elapsed, frames, elapsed))
        t0, frames = t, 0
    glut.glutPostRedisplay()


if __name__ == '__main__':
    import sys
    import OpenGL.GLUT as glut

    glut.glutInit(sys.argv)
    glut.glutInitDisplayMode(
        glut.GLUT_DOUBLE | glut.GLUT_RGB | glut.GLUT_DEPTH)
    glut.glutInitWindowSize(512, 512)
    glut.glutCreateWindow("Do nothing benchmark (GLUT)")
    glut.glutDisplayFunc(on_display)
    glut.glutKeyboardFunc(on_keyboard)

    t0, frames, t = glut.glutGet(glut.GLUT_ELAPSED_TIME), 0, 0
    glut.glutIdleFunc(on_idle)
    glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = simple-vispy
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
import time
from vispy import app
from vispy.gloo import gl

app.use('qt')
# app.use('glut')
# app.use('pyglet')

canvas = app.Canvas(size=(512, 512), title = "Do nothing benchmark (vispy)",
                    close_keys='escape')


@canvas.connect
def on_paint(event):
    global t, t0, frames
    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

    t = time.time()
    frames = frames + 1
    elapsed = (t - t0)  # seconds
    if elapsed > 2.5:
        print("FPS : %.2f (%d frames in %.2f second)"
              % (frames / elapsed, frames, elapsed))
        t0, frames = t, 0
    canvas.update()

t0, frames, t = time.time(), 0, 0
canvas.show()
app.run()

########NEW FILE########
__FILENAME__ = atom
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: Nicolas P .Rougier
# Date:   06/03/2014
# Abstract: Fake electrons orbiting
# Keywords: Sprites, atom, particles
# -----------------------------------------------------------------------------

import numpy as np
from vispy import gloo
from vispy import app
from vispy.util.transforms import perspective, translate, rotate

# Create vertices
n, p = 100, 150
data = np.zeros(p * n, [('a_position', np.float32, 2),
                        ('a_color',    np.float32, 4),
                        ('a_rotation', np.float32, 4)])
trail = .5 * np.pi
data['a_position'][:, 0] = np.resize(np.linspace(0, trail, n), p * n)
data['a_position'][:, 0] += np.repeat(np.random.uniform(0, 2 * np.pi, p), n)
data['a_position'][:, 1] = np.repeat(np.linspace(0, 2 * np.pi, p), n)

data['a_color'] = 1, 1, 1, 1
data['a_color'] = np.repeat(
    np.random.uniform(0.75, 1.00, (p, 4)).astype(np.float32), n, axis=0)
data['a_color'][:, 3] = np.resize(np.linspace(0, 1, n), p * n)

data['a_rotation'] = np.repeat(
    np.random.uniform(0, 2 * np.pi, (p, 4)).astype(np.float32), n, axis=0)


vert = """
#version 120
uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
uniform float u_size;
uniform float u_clock;

attribute vec2 a_position;
attribute vec4 a_color;
attribute vec4 a_rotation;
varying vec4 v_color;

mat4 build_rotation(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    return mat4(oc * axis.x * axis.x + c,
                oc * axis.x * axis.y - axis.z * s,
                oc * axis.z * axis.x + axis.y * s,
                0.0,
                oc * axis.x * axis.y + axis.z * s,
                oc * axis.y * axis.y + c,
                oc * axis.y * axis.z - axis.x * s,
                0.0,
                oc * axis.z * axis.x - axis.y * s,
                oc * axis.y * axis.z + axis.x * s,
                oc * axis.z * axis.z + c,
                0.0,
                0.0, 0.0, 0.0, 1.0);
}


void main (void) {
    v_color = a_color;

    float x0 = 1.5;
    float z0 = 0.0;

    float theta = a_position.x + u_clock;
    float x1 = x0*cos(theta) + z0*sin(theta);
    float y1 = 0.0;
    float z1 = (z0*cos(theta) - x0*sin(theta))/2.0;

    mat4 R = build_rotation(a_rotation.xyz, a_rotation.w);
    gl_Position = u_projection * u_view * u_model * R * vec4(x1,y1,z1,1);
    gl_PointSize = 8.0 * u_size * sqrt(v_color.a);
}
"""

frag = """
#version 120
varying vec4 v_color;
varying float v_size;
void main()
{
    float d = 2*(length(gl_PointCoord.xy - vec2(0.5,0.5)));
    gl_FragColor = vec4(v_color.rgb, v_color.a*(1-d));
}
"""


# ------------------------------------------------------------ Canvas class ---
class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')
        self.size = 800, 800
        self.title = "Atom [zoom with mouse scroll"

        self.program = gloo.Program(vert, frag)
        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)
        self.translate = 6.5
        translate(self.view, 0, 0, -self.translate)

        self.program.bind(gloo.VertexBuffer(data))
        self.program['u_model'] = self.model
        self.program['u_view'] = self.view
        self.program['u_size'] = 5 / self.translate

        self.theta = 0
        self.phi = 0
        self.clock = 0
        self.stop_rotation = False

        self.timer = app.Timer(1.0 / 60)
        self.timer.connect(self.on_timer)
        self.timer.start()

    def on_initialize(self, event):
        gloo.set_state('translucent', depth_test=False)

    def on_key_press(self, event):
        if event.text == ' ':
            self.stop_rotation = not self.stop_rotation

    def on_timer(self, event):
        if not self.stop_rotation:
            self.theta += .05
            self.phi += .05
            self.model = np.eye(4, dtype=np.float32)
            rotate(self.model, self.theta, 0, 0, 1)
            rotate(self.model, self.phi, 0, 1, 0)
            self.program['u_model'] = self.model
        self.clock += np.pi / 100
        self.program['u_clock'] = self.clock
        self.update()

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)
        self.projection = perspective(45.0, width / float(height), 1.0, 1000.0)
        self.program['u_projection'] = self.projection

    def on_mouse_wheel(self, event):
        self.translate += event.delta[1]
        self.translate = max(2, self.translate)
        self.view = np.eye(4, dtype=np.float32)
        translate(self.view, 0, 0, -self.translate)

        self.program['u_view'] = self.view
        self.program['u_size'] = 5 / self.translate
        self.update()

    def on_paint(self, event):
        gloo.clear((0, 0, 0, 1))
        self.program.draw('points')


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = boids
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 30

"""
Demonstration of boids simulation. Boids is an artificial life
program, developed by Craig Reynolds in 1986, which simulates the
flocking behaviour of birds.
Based on code from glumpy by Nicolas Rougier.
"""

import time

import numpy as np
from scipy.spatial import cKDTree

from vispy import gloo
from vispy import app

# Create boids
n = 1000
particles = np.zeros(2 + n, [('position', 'f4', 3),
                             ('position_1', 'f4', 3),
                             ('position_2', 'f4', 3),
                             ('velocity', 'f4', 3),
                             ('color', 'f4', 4),
                             ('size', 'f4', 1)])
boids = particles[2:]
target = particles[0]
predator = particles[1]

boids['position'] = np.random.uniform(-0.25, +0.25, (n, 3))
boids['velocity'] = np.random.uniform(-0.00, +0.00, (n, 3))
boids['size'] = 4
boids['color'] = 1, 1, 1, 1

target['size'] = 16
target['color'][:] = 1, 1, 0, 1
predator['size'] = 16
predator['color'][:] = 1, 0, 0, 1
target['position'][:] = 0.25, 0.0, 0

VERT_SHADER = """
attribute vec3 position;
attribute vec4 color;
attribute float size;

varying vec4 v_color;
void main (void) {
    gl_Position = vec4(position, 1.0);
    v_color = color;
    gl_PointSize = size;
}
"""

FRAG_SHADER = """
varying vec4 v_color;
void main()
{
    float x = 2.0*gl_PointCoord.x - 1.0;
    float y = 2.0*gl_PointCoord.y - 1.0;
    float a = 1.0 - (x*x + y*y);
    gl_FragColor = vec4(v_color.rgb, a*v_color.a);
}

"""


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')

        # Time
        self._t = time.time()
        self._pos = 0.0, 0.0
        self._button = None

        # Create program
        self.program = gloo.Program(VERT_SHADER, FRAG_SHADER)

        # Create vertex buffers
        self.vbo_position = gloo.VertexBuffer(particles['position'])
        self.vbo_color = gloo.VertexBuffer(particles['color'])
        self.vbo_size = gloo.VertexBuffer(particles['size'])

        # Bind vertex buffers
        self.program['color'] = self.vbo_color
        self.program['size'] = self.vbo_size
        self.program['position'] = self.vbo_position

    def on_initialize(self, event):
        gloo.set_state(clear_color=(0, 0, 0, 1), blend=True,
                       blend_func=('src_alpha', 'one'))

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)

    def on_mouse_press(self, event):
        self._button = event.button
        self.on_mouse_move(event)

    def on_mouse_release(self, event):
        self._button = None
        self.on_mouse_move(event)

    def on_mouse_move(self, event):
        if not self._button:
            return
        w, h = self.size
        x, y = event.pos
        sx = 2 * x / float(w) - 1.0
        sy = - (2 * y / float(h) - 1.0)

        if self._button == 1:
            target['position'][:] = sx, sy, 0
        elif self._button == 2:
            predator['position'][:] = sx, sy, 0

    def on_paint(self, event):
        gloo.clear()

        # Draw
        self.program.draw('points')

        # Next iteration
        self._t = self.iteration(time.time() - self._t)

        # Invoke a new draw
        self.update()

    def iteration(self, dt):
        t = self._t

        t += 0.5 * dt
        #target[...] = np.array([np.sin(t),np.sin(2*t),np.cos(3*t)])*.1

        t += 0.5 * dt
        #predator[...] = np.array([np.sin(t),np.sin(2*t),np.cos(3*t)])*.2

        boids['position_2'] = boids['position_1']
        boids['position_1'] = boids['position']
        n = len(boids)
        P = boids['position']
        V = boids['velocity']

        # Cohesion: steer to move toward the average position of local
        # flockmates
        C = -(P - P.sum(axis=0) / n)

        # Alignment: steer towards the average heading of local flockmates
        A = -(V - V.sum(axis=0) / n)

        # Repulsion: steer to avoid crowding local flockmates
        D, I = cKDTree(P).query(P, 5)
        M = np.repeat(D < 0.05, 3, axis=1).reshape(n, 5, 3)
        Z = np.repeat(P, 5, axis=0).reshape(n, 5, 3)
        R = -((P[I] - Z) * M).sum(axis=1)

        # Target : Follow target
        T = target['position'] - P

        # Predator : Move away from predator
        dP = P - predator['position']
        D = np.maximum(0, 0.3 -
                       np.sqrt(dP[:, 0] ** 2 +
                               dP[:, 1] ** 2 +
                               dP[:, 2] ** 2))
        D = np.repeat(D, 3, axis=0).reshape(n, 3)
        dP *= D

        #boids['velocity'] += 0.0005*C + 0.01*A + 0.01*R + 0.0005*T + 0.0025*dP
        boids['velocity'] += 0.0005 * C + 0.01 * \
            A + 0.01 * R + 0.0005 * T + 0.025 * dP
        boids['position'] += boids['velocity']

        self.vbo_position.set_data(particles['position'])

        return t


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = cloud
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 1

"""
Demonstrating a cloud of points.
"""

import numpy as np

from vispy import gloo
from vispy import app
from vispy.util.transforms import perspective, translate, rotate


# Create vertices
n = 1000000
data = np.zeros(n, [('a_position', np.float32, 3),
                    ('a_bg_color', np.float32, 4),
                    ('a_fg_color', np.float32, 4),
                    ('a_size', np.float32, 1)])
data['a_position'] = 0.45 * np.random.randn(n, 3)
data['a_bg_color'] = np.random.uniform(0.85, 1.00, (n, 4))
data['a_fg_color'] = 0, 0, 0, 1
data['a_size'] = np.random.uniform(5, 10, n)
u_linewidth = 1.0
u_antialias = 1.0
u_size = 1


vert = """
#version 120

// Uniforms
// ------------------------------------
uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
uniform float u_linewidth;
uniform float u_antialias;
uniform float u_size;

// Attributes
// ------------------------------------
attribute vec3  a_position;
attribute vec4  a_fg_color;
attribute vec4  a_bg_color;
attribute float a_size;

// Varyings
// ------------------------------------
varying vec4 v_fg_color;
varying vec4 v_bg_color;
varying float v_size;
varying float v_linewidth;
varying float v_antialias;

void main (void) {
    v_size = a_size * u_size;
    v_linewidth = u_linewidth;
    v_antialias = u_antialias;
    v_fg_color  = a_fg_color;
    v_bg_color  = a_bg_color;
    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);
    gl_PointSize = v_size + 2*(v_linewidth + 1.5*v_antialias);
}
"""

frag = """
#version 120

// Constants
// ------------------------------------


// Varyings
// ------------------------------------
varying vec4 v_fg_color;
varying vec4 v_bg_color;
varying float v_size;
varying float v_linewidth;
varying float v_antialias;

// Functions
// ------------------------------------

// ----------------
float disc(vec2 P, float size)
{
    float r = length((P.xy - vec2(0.5,0.5))*size);
    r -= v_size/2;
    return r;
}

// ----------------
float arrow_right(vec2 P, float size)
{
    float r1 = abs(P.x -.50)*size + abs(P.y -.5)*size - v_size/2;
    float r2 = abs(P.x -.25)*size + abs(P.y -.5)*size - v_size/2;
    float r = max(r1,-r2);
    return r;
}

// ----------------
float ring(vec2 P, float size)
{
    float r1 = length((gl_PointCoord.xy - vec2(0.5,0.5))*size) - v_size/2;
    float r2 = length((gl_PointCoord.xy - vec2(0.5,0.5))*size) - v_size/4;
    float r = max(r1,-r2);
    return r;
}

// ----------------
float clober(vec2 P, float size)
{
    const float PI = 3.14159265358979323846264;
    const float t1 = -PI/2;
    const vec2  c1 = 0.2*vec2(cos(t1),sin(t1));
    const float t2 = t1+2*PI/3;
    const vec2  c2 = 0.2*vec2(cos(t2),sin(t2));
    const float t3 = t2+2*PI/3;
    const vec2  c3 = 0.2*vec2(cos(t3),sin(t3));

    float r1 = length((gl_PointCoord.xy- vec2(0.5,0.5) - c1)*size);
    r1 -= v_size/3;
    float r2 = length((gl_PointCoord.xy- vec2(0.5,0.5) - c2)*size);
    r2 -= v_size/3;
    float r3 = length((gl_PointCoord.xy- vec2(0.5,0.5) - c3)*size);
    r3 -= v_size/3;
    float r = min(min(r1,r2),r3);
    return r;
}

// ----------------
float square(vec2 P, float size)
{
    float r = max(abs(gl_PointCoord.x -.5)*size,
                  abs(gl_PointCoord.y -.5)*size);
    r -= v_size/2;
    return r;
}

// ----------------
float diamond(vec2 P, float size)
{
    float r = abs(gl_PointCoord.x -.5)*size + abs(gl_PointCoord.y -.5)*size;
    r -= v_size/2;
    return r;
}

// ----------------
float vbar(vec2 P, float size)
{
    float r1 = max(abs(gl_PointCoord.x -.75)*size,
                   abs(gl_PointCoord.x -.25)*size);
    float r3 = max(abs(gl_PointCoord.x -.5)*size,
                   abs(gl_PointCoord.y -.5)*size);
    float r = max(r1,r3);
    r -= v_size/2;
    return r;
}

// ----------------
float hbar(vec2 P, float size)
{
    float r2 = max(abs(gl_PointCoord.y -.75)*size,
                   abs(gl_PointCoord.y -.25)*size);
    float r3 = max(abs(gl_PointCoord.x -.5)*size,
                   abs(gl_PointCoord.y -.5)*size);
    float r = max(r2,r3);
    r -= v_size/2;
    return r;
}

// ----------------
float cross(vec2 P, float size)
{
    float r1 = max(abs(gl_PointCoord.x -.75)*size,
                   abs(gl_PointCoord.x -.25)*size);
    float r2 = max(abs(gl_PointCoord.y -.75)*size,
                   abs(gl_PointCoord.y -.25)*size);
    float r3 = max(abs(gl_PointCoord.x -.5)*size,
                   abs(gl_PointCoord.y -.5)*size);
    float r = max(min(r1,r2),r3);
    r -= v_size/2;
    return r;
}


// Main
// ------------------------------------
void main()
{
    float size = v_size +2*(v_linewidth + 1.5*v_antialias);
    float t = v_linewidth/2.0-v_antialias;

    float r = disc(gl_PointCoord, size);
    // float r = square(gl_PointCoord, size);
    // float r = ring(gl_PointCoord, size);
    // float r = arrow_right(gl_PointCoord, size);
    // float r = diamond(gl_PointCoord, size);
    // float r = cross(gl_PointCoord, size);
    // float r = clober(gl_PointCoord, size);
    // float r = hbar(gl_PointCoord, size);
    // float r = vbar(gl_PointCoord, size);


    float d = abs(r) - t;
    if( r > (v_linewidth/2.0+v_antialias))
    {
        discard;
    }
    else if( d < 0.0 )
    {
       gl_FragColor = v_fg_color;
    }
    else
    {
        float alpha = d/v_antialias;
        alpha = exp(-alpha*alpha);
        if (r > 0)
            gl_FragColor = vec4(v_fg_color.rgb, alpha*v_fg_color.a);
        else
            gl_FragColor = mix(v_bg_color, v_fg_color, alpha);
    }
}
"""


# ------------------------------------------------------------ Canvas class ---
class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')
        self.size = 800, 600

        self.program = gloo.Program(vert, frag)
        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)
        self.translate = 5
        translate(self.view, 0, 0, -self.translate)

        self.program.bind(gloo.VertexBuffer(data))
        self.program['u_linewidth'] = u_linewidth
        self.program['u_antialias'] = u_antialias
        self.program['u_model'] = self.model
        self.program['u_view'] = self.view
        self.program['u_size'] = 5 / self.translate

        self.theta = 0
        self.phi = 0

        self.timer = app.Timer(1.0 / 60)
        self.timer.connect(self.on_timer)
        self.timer.start()

    def on_initialize(self, event):
        gloo.set_state('translucent', clear_color=(1, 1, 1, 1))

    def on_key_press(self, event):
        if event.text == ' ':
            if self.timer.running:
                self.timer.stop()
            else:
                self.timer.start()

    def on_timer(self, event):
        self.theta += .5
        self.phi += .5
        self.model = np.eye(4, dtype=np.float32)
        rotate(self.model, self.theta, 0, 0, 1)
        rotate(self.model, self.phi, 0, 1, 0)
        self.program['u_model'] = self.model
        self.update()

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)
        self.projection = perspective(45.0, width / float(height), 1.0, 1000.0)
        self.program['u_projection'] = self.projection

    def on_mouse_wheel(self, event):
        self.translate += event.delta[1]
        self.translate = max(2, self.translate)
        self.view = np.eye(4, dtype=np.float32)
        translate(self.view, 0, 0, -self.translate)

        self.program['u_view'] = self.view
        self.program['u_size'] = 5 / self.translate
        self.update()

    def on_paint(self, event):
        gloo.clear()
        self.program.draw('points')


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = donut
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: Nicolas P .Rougier
# Date:   04/03/2014
# -----------------------------------------------------------------------------
"""
Mesmerizing donut
"""

import numpy as np
from vispy import gloo
from vispy import app
from vispy.util.transforms import perspective, translate, rotate

# Create vertices
n, p = 50, 40
data = np.zeros(p * n, [('a_position', np.float32, 2),
                        ('a_bg_color', np.float32, 4),
                        ('a_fg_color', np.float32, 4),
                        ('a_size',     np.float32, 1)])
data['a_position'][:, 0] = np.resize(np.linspace(0, 2 * np.pi, n), p * n)
data['a_position'][:, 1] = np.repeat(np.linspace(0, 2 * np.pi, p), n)
data['a_bg_color'] = np.random.uniform(0.75, 1.00, (n * p, 4))
data['a_bg_color'][:, 3] = 1
data['a_fg_color'] = 0, 0, 0, 1
data['a_size'] = np.random.uniform(8, 8, n * p)
u_linewidth = 1.0
u_antialias = 1.0
u_size = 1


vert = """
#version 120

uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
uniform float u_linewidth;
uniform float u_antialias;
uniform float u_size;
uniform float u_clock;

attribute vec2  a_position;
attribute vec4  a_fg_color;
attribute vec4  a_bg_color;
attribute float a_size;

varying vec4 v_fg_color;
varying vec4 v_bg_color;
varying float v_size;
varying float v_linewidth;
varying float v_antialias;

void main (void) {
    v_size = a_size * u_size;
    v_linewidth = u_linewidth;
    v_antialias = u_antialias;
    v_fg_color  = a_fg_color;
    v_bg_color  = a_bg_color;

    float x0 = 0.5;
    float z0 = 0.0;

    float theta = a_position.x + u_clock;
    float x1 = x0*cos(theta) + z0*sin(theta) - 1.0;
    float y1 = 0.0;
    float z1 = z0*cos(theta) - x0*sin(theta);

    float phi = a_position.y;
    float x2 = x1*cos(phi) + y1*sin(phi);
    float y2 = y1*cos(phi) - x1*sin(phi);
    float z2 = z1;

    gl_Position = u_projection * u_view * u_model * vec4(x2,y2,z2,1);
    gl_PointSize = v_size + 2*(v_linewidth + 1.5*v_antialias);
}
"""

frag = """
#version 120

varying vec4 v_fg_color;
varying vec4 v_bg_color;
varying float v_size;
varying float v_linewidth;
varying float v_antialias;
void main()
{
    float size = v_size +2*(v_linewidth + 1.5*v_antialias);
    float t = v_linewidth/2.0-v_antialias;
    float r = length((gl_PointCoord.xy - vec2(0.5,0.5))*size) - v_size/2;
    float d = abs(r) - t;
    if( r > (v_linewidth/2.0+v_antialias))
    {
        discard;
    }
    else if( d < 0.0 )
    {
       gl_FragColor = v_fg_color;
    }
    else
    {
        float alpha = d/v_antialias;
        alpha = exp(-alpha*alpha);
        if (r > 0)
            gl_FragColor = vec4(v_fg_color.rgb, alpha*v_fg_color.a);
        else
            gl_FragColor = mix(v_bg_color, v_fg_color, alpha);
    }
}
"""


# ------------------------------------------------------------ Canvas class ---
class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')
        self.size = 800, 800
        self.title = "D'oh ! A big donut"

        self.program = gloo.Program(vert, frag)
        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)
        self.translate = 5
        translate(self.view, 0, 0, -self.translate)

        self.program.bind(gloo.VertexBuffer(data))
        self.program['u_linewidth'] = u_linewidth
        self.program['u_antialias'] = u_antialias
        self.program['u_model'] = self.model
        self.program['u_view'] = self.view
        self.program['u_size'] = 5 / self.translate

        self.theta = 0
        self.phi = 0
        self.clock = 0
        self.stop_rotation = False

        self.timer = app.Timer(1.0 / 60)
        self.timer.connect(self.on_timer)
        self.timer.start()

    def on_initialize(self, event):
        gloo.set_state('translucent', clear_color=(1, 1, 1, 1))

    def on_key_press(self, event):
        if event.text == ' ':
            self.stop_rotation = not self.stop_rotation

    def on_timer(self, event):
        if not self.stop_rotation:
            self.theta += .5
            self.phi += .5
            self.model = np.eye(4, dtype=np.float32)
            rotate(self.model, self.theta, 0, 0, 1)
            rotate(self.model, self.phi, 0, 1, 0)
            self.program['u_model'] = self.model
        self.clock += np.pi / 1000
        self.program['u_clock'] = self.clock
        self.update()

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)
        self.projection = perspective(45.0, width / float(height), 1.0, 1000.0)
        self.program['u_projection'] = self.projection

    def on_mouse_wheel(self, event):
        self.translate += event.delta[1]
        self.translate = max(2, self.translate)
        self.view = np.eye(4, dtype=np.float32)
        translate(self.view, 0, 0, -self.translate)

        self.program['u_view'] = self.view
        self.program['u_size'] = 5 / self.translate
        self.update()

    def on_paint(self, event):
        gloo.clear()
        self.program.draw('points')


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = fireworks
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 20

"""
Example demonstrating simulation of fireworks using point sprites.
(adapted from the "OpenGL ES 2.0 Programming Guide")

This example demonstrates a series of explosions that last one second. The
visualization during the explosion is highly optimized using a Vertex Buffer
Object (VBO). After each explosion, vertex data for the next explosion are
calculated, such that each explostion is unique.
"""

import time
import numpy as np
from vispy import gloo
from vispy import app

# Create a texture
radius = 32
im1 = np.random.normal(
    0.8, 0.3, (radius * 2 + 1, radius * 2 + 1)).astype(np.float32)

# Mask it with a disk
L = np.linspace(-radius, radius, 2 * radius + 1)
(X, Y) = np.meshgrid(L, L)
im1 *= np.array((X ** 2 + Y ** 2) <= radius * radius, dtype='float32')

# Set number of particles, you should be able to scale this to 100000
N = 10000

# Create vertex data container
data = np.zeros(N, [('a_lifetime', np.float32, 1),
                    ('a_startPosition', np.float32, 3),
                    ('a_endPosition', np.float32, 3)])


VERT_SHADER = """
#version 120
uniform float u_time;
uniform vec3 u_centerPosition;
attribute float a_lifetime;
attribute vec3 a_startPosition;
attribute vec3 a_endPosition;
varying float v_lifetime;

void main () {
    if (u_time <= a_lifetime)
    {
        gl_Position.xyz = a_startPosition + (u_time * a_endPosition);
        gl_Position.xyz += u_centerPosition;
        gl_Position.y -= 1.0 * u_time * u_time;
        gl_Position.w = 1.0;
    }
    else
        gl_Position = vec4(-1000, -1000, 0, 0);

    v_lifetime = 1.0 - (u_time / a_lifetime);
    v_lifetime = clamp(v_lifetime, 0.0, 1.0);
    gl_PointSize = (v_lifetime * v_lifetime) * 40.0;
}
"""

FRAG_SHADER = """
#version 120

uniform sampler2D texture1;
uniform vec4 u_color;
varying float v_lifetime;
uniform sampler2D s_texture;

void main()
{
    vec4 texColor;
    texColor = texture2D(s_texture, gl_PointCoord);
    gl_FragColor = vec4(u_color) * texColor;
    gl_FragColor.a *= v_lifetime;
}
"""


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')
        self.size = 800, 600

        # Create program
        self._program = gloo.Program(VERT_SHADER, FRAG_SHADER)
        self._program.bind(gloo.VertexBuffer(data))
        self._program['s_texture'] = gloo.Texture2D(im1)

        # Create first explosion
        self._new_explosion()

    def on_initialize(self, event):
        # Enable blending
        gloo.set_state(blend=True, clear_color=(0, 0, 0, 1),
                       blend_func=('src_alpha', 'one'))

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)

    def on_paint(self, event):

        # Clear
        gloo.clear()

        # Draw
        self._program['u_time'] = time.time() - self._starttime
        self._program.draw('points')

        # Invoke a new draw
        self.update()

        # New explosion?
        if time.time() - self._starttime > 1.5:
            self._new_explosion()

    def _new_explosion(self):

        # New centerpos
        centerpos = np.random.uniform(-0.5, 0.5, (3,))
        self._program['u_centerPosition'] = centerpos

        # New color, scale alpha with N
        alpha = 1.0 / N ** 0.08
        color = np.random.uniform(0.1, 0.9, (3,))

        self._program['u_color'] = tuple(color) + (alpha,)

        # Create new vertex data
        data['a_lifetime'] = np.random.normal(2.0, 0.5, (N,))
        data['a_startPosition'] = np.random.normal(0.0, 0.2, (N, 3))
        data['a_endPosition'] = np.random.normal(0.0, 1.2, (N, 3))

        # Set time to zero
        self._starttime = time.time()


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = galaxy
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 2
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""
Just a very fake galaxy.
Astronomers and cosmologists will kill me !
"""

import numpy as np

from vispy import gloo
from vispy import app
from vispy.util.transforms import perspective, translate, rotate

# Manual galaxy creation
# (did you really expect a simulation in less than 250 python lines ?)


def make_arm(n, angle):
    R = np.linspace(10, 450 + 50 * np.random.uniform(.5, 1.), n)
    R += 40 * np.random.normal(0, 2., n) * np.linspace(1, .1, n)
    T = angle + np.linspace(0, 2.5 * np.pi, n) + \
        np.pi / 6 * np.random.normal(0, .5, n)
    S = 8 + 2 * np.abs(np.random.normal(0, 1, n))
    S *= np.linspace(1, .85, n)
    P = np.zeros((n, 3), dtype=np.float32)
    X, Y, Z = P[:, 0], P[:, 1], P[:, 2]
    X[...] = R * np.cos(T)
    Y[...] = R * np.sin(T) * 1.1
    D = np.sqrt(X * X + Y * Y)
    Z[...] = 8 * np.random.normal(0, 2 - D / 512., n)
    X += (D * np.random.uniform(0, 1, n) > 250) * \
        (.05 * D * np.random.uniform(-1, 1, n))
    Y += (D * np.random.uniform(0, 1, n) > 250) * \
        (.05 * D * np.random.uniform(-1, 1, n))
    Z += (D * np.random.uniform(0, 1, n) > 250) * \
        (.05 * D * np.random.uniform(-1, 1, n))
    D = (D - D.min()) / (D.max() - D.min())

    return P / 256, S / 2, D
p = 50000
n = 3 * p

data = np.zeros(n, [('a_position', np.float32, 3),
                    ('a_size', np.float32, 1),
                    ('a_dist', np.float32, 1)])
for i in range(3):
    P, S, D = make_arm(p, i * 2 * np.pi / 3)
    data['a_dist'][(i + 0) * p:(i + 1) * p] = D
    data['a_position'][(i + 0) * p:(i + 1) * p] = P
    data['a_size'][(i + 0) * p:(i + 1) * p] = S


# Very simple colormap
cmap = np.array([[255, 124, 0], [255, 163, 76],
                 [255, 192, 130], [255, 214, 173],
                 [255, 232, 212], [246, 238, 237],
                 [237, 240, 253], [217, 228, 255],
                 [202, 219, 255], [191, 212, 255],
                 [182, 206, 255], [174, 202, 255],
                 [168, 198, 255], [162, 195, 255],
                 [158, 192, 255], [155, 189, 255],
                 [151, 187, 255], [148, 185, 255],
                 [145, 183, 255], [143, 182, 255],
                 [141, 181, 255], [140, 179, 255],
                 [139, 179, 255],
                 [137, 177, 255]], dtype=np.uint8).reshape(1, 24, 3)


VERT_SHADER = """
#version 120
// Uniforms
// ------------------------------------
uniform mat4  u_model;
uniform mat4  u_view;
uniform mat4  u_projection;
uniform float u_size;


// Attributes
// ------------------------------------
attribute vec3  a_position;
attribute float a_size;
attribute float a_dist;

// Varyings
// ------------------------------------
varying float v_size;
varying float v_dist;

void main (void) {
    v_size  = a_size*u_size*.75;
    v_dist  = a_dist;
    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);
    gl_PointSize = v_size;
}
"""

FRAG_SHADER = """
#version 120
// Uniforms
// ------------------------------------
uniform sampler2D u_colormap;

// Varyings
// ------------------------------------
varying float v_size;
varying float v_dist;

// Main
// ------------------------------------
void main()
{
    float a = 2*(length(gl_PointCoord.xy - vec2(0.5,0.5)) / sqrt(2.0));
    vec3 color = texture2D(u_colormap, vec2(v_dist,.5)).rgb;
    gl_FragColor = vec4(color,(1-a)*.25);
}
"""


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')
        self.size = 800, 600
        self.title = "A very fake galaxy [mouse scroll to zoom]"

        self.program = gloo.Program(VERT_SHADER, FRAG_SHADER)
        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)
        self.theta, self.phi = 0, 0

        self.translate = 5
        translate(self.view, 0, 0, -self.translate)

        self.program.bind(gloo.VertexBuffer(data))
        self.program['u_colormap'] = gloo.Texture2D(cmap)
        self.program['u_size'] = 5. / self.translate
        self.program['u_model'] = self.model
        self.program['u_view'] = self.view

        self.timer = app.Timer(1.0 / 60)
        self.timer.connect(self.on_timer)

    def on_initialize(self, event):
        gloo.set_state(depth_test=False, blend=True,
                       blend_func=('src_alpha', 'one'),
                       clear_color=(0, 0, 0, 1))
        # Start the timer upon initialization.
        self.timer.start()

    def on_key_press(self, event):
        if event.text == ' ':
            if self.timer.running:
                self.timer.stop()
            else:
                self.timer.start()

    def on_timer(self, event):
        self.theta += .11
        self.phi += .13
        self.model = np.eye(4, dtype=np.float32)
        rotate(self.model, self.theta, 0, 0, 1)
        rotate(self.model, self.phi, 0, 1, 0)
        self.program['u_model'] = self.model
        self.update()

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)
        self.projection = perspective(45.0, width / float(height), 1.0, 1000.0)
        self.program['u_projection'] = self.projection

    def on_mouse_wheel(self, event):
        self.translate += event.delta[1]
        self.translate = max(2, self.translate)
        self.view = np.eye(4, dtype=np.float32)
        translate(self.view, 0, 0, -self.translate)
        self.program['u_view'] = self.view
        self.program['u_size'] = 5 / self.translate
        self.update()

    def on_paint(self, event):
        gloo.clear()
        self.program.draw('points')

if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = game-of-life
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author:   Nicolas P .Rougier
# Date:     06/03/2014
# Abstract: GPU computing using the framebuffer
# Keywords: framebuffer, GPU computing, cellular automata
# -----------------------------------------------------------------------------
import sys
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut
from vispy.gloo import Program, FrameBuffer, DepthBuffer


render_vertex = """
attribute vec2 position;
attribute vec2 texcoord;
varying vec2 v_texcoord;
void main()
{
    gl_Position = vec4(position, 0.0, 1.0);
    v_texcoord = texcoord;
}
"""

render_fragment = """
uniform int pingpong;
uniform sampler2D texture;
varying vec2 v_texcoord;
void main()
{
    float v;
    v = texture2D(texture, v_texcoord)[pingpong];
    gl_FragColor = vec4(1.0-v, 1.0-v, 1.0-v, 1.0);
}
"""

compute_vertex = """
attribute vec2 position;
attribute vec2 texcoord;
varying vec2 v_texcoord;
void main()
{
    gl_Position = vec4(position, 0.0, 1.0);
    v_texcoord = texcoord;
}
"""

compute_fragment = """
uniform int pingpong;
uniform sampler2D texture;
uniform float dx;          // horizontal distance between texels
uniform float dy;          // vertical distance between texels
varying vec2 v_texcoord;
void main(void)
{
    vec2  p = v_texcoord;
    float old_state, new_state, count;

    old_state = texture2D(texture, p)[pingpong];
    count = texture2D(texture, p + vec2(-dx,-dy))[pingpong]
            + texture2D(texture, p + vec2( dx,-dy))[pingpong]
            + texture2D(texture, p + vec2(-dx, dy))[pingpong]
            + texture2D(texture, p + vec2( dx, dy))[pingpong]
            + texture2D(texture, p + vec2(-dx, 0.0))[pingpong]
            + texture2D(texture, p + vec2( dx, 0.0))[pingpong]
            + texture2D(texture, p + vec2(0.0,-dy))[pingpong]
            + texture2D(texture, p + vec2(0.0, dy))[pingpong];

    new_state = old_state;
    if( old_state > 0.5 ) {
        // Any live cell with fewer than two live neighbours dies
        // as if caused by under-population.
        if( count  < 1.5 )
            new_state = 0.0;

        // Any live cell with two or three live neighbours
        // lives on to the next generation.

        // Any live cell with more than three live neighbours dies,
        //  as if by overcrowding.
        else if( count > 3.5 )
            new_state = 0.0;
    } else {
        // Any dead cell with exactly three live neighbours becomes
        //  a live cell, as if by reproduction.
       if( (count > 2.5) && (count < 3.5) )
           new_state = 1.0;
    }

    gl_FragColor[1-pingpong] = new_state;
    gl_FragColor[pingpong] = old_state;
}
"""


def display():
    global comp_w, comp_h, disp_w, disp_h

    framebuffer.activate()
    gl.glViewport(0, 0, comp_w, comp_h)
    compute["texture"].interpolation = gl.GL_NEAREST
    compute.draw(gl.GL_TRIANGLE_STRIP)
    framebuffer.deactivate()

    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    gl.glViewport(0, 0, disp_w, disp_h)
    render["texture"].interpolation = gl.GL_LINEAR
    render.draw(gl.GL_TRIANGLE_STRIP)
    glut.glutSwapBuffers()


def reshape(width, height):
    global disp_w, disp_h
    gl.glViewport(0, 0, width, height)
    disp_w, disp_h = width, height


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def idle():
    global pingpong
    pingpong = 1 - pingpong
    compute["pingpong"] = pingpong
    render["pingpong"] = pingpong
    glut.glutPostRedisplay()


# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA)
glut.glutCreateWindow("Conway game of life")
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutIdleFunc(idle)


# Build programs
# --------------
comp_w, comp_h = 512, 512
disp_w, disp_h = 512, 512
Z = np.zeros((comp_h, comp_w, 4), dtype=np.float32)
Z[...] = np.random.randint(0, 2, (comp_h, comp_w, 4))
Z[:256, :256, :] = 0
gun = """
........................O...........
......................O.O...........
............OO......OO............OO
...........O...O....OO............OO
OO........O.....O...OO..............
OO........O...O.OO....O.O...........
..........O.....O.......O...........
...........O...O....................
............OO......................"""
x, y = 0, 0
for i in range(len(gun)):
    if gun[i] == '\n':
        y += 1
        x = 0
    elif gun[i] == 'O':
        Z[y, x] = 1
    x += 1

pingpong = 1
compute = Program(compute_vertex, compute_fragment, 4)
compute["texture"] = Z
compute["position"] = [(-1, -1), (-1, +1), (+1, -1), (+1, +1)]
compute["texcoord"] = [(0, 0), (0, 1), (1, 0), (1, 1)]
compute['dx'] = 1.0 / comp_w
compute['dy'] = 1.0 / comp_h
compute['pingpong'] = pingpong

render = Program(render_vertex, render_fragment, 4)
render["position"] = [(-1, -1), (-1, +1), (+1, -1), (+1, +1)]
render["texcoord"] = [(0, 0), (0, 1), (1, 0), (1, 1)]
render["texture"] = compute["texture"]
render['pingpong'] = pingpong

framebuffer = FrameBuffer(color=compute["texture"],
                          depth=DepthBuffer((comp_w, comp_h)))

# OpenGL initialization
# --------------------------------------
gl.glDisable(gl.GL_DEPTH_TEST)
gl.glClearColor(0, 0, 0, 1)

# Start
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = graph
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 60

"""
Dynamic planar graph layout.
"""

import numpy as np
from vispy import gloo
from vispy import app
from vispy.gloo import gl
import markers

vs = """
attribute vec3 a_position;
attribute vec4 a_fg_color;
attribute vec4 a_bg_color;
attribute float a_size;
attribute float a_linewidth;

void main(){
    gl_Position = vec4(a_position, 1.);
}
"""

fs = """
void main(){
    gl_FragColor = vec4(0., 0., 0., 1.);
}
"""

n = 100
ne = 100
data = np.zeros(n, dtype=[('a_position', np.float32, 3),
                          ('a_fg_color', np.float32, 4),
                          ('a_bg_color', np.float32, 4),
                          ('a_size', np.float32, 1),
                          ('a_linewidth', np.float32, 1),
                          ])
edges = np.random.randint(size=(ne, 2), low=0, high=n).astype(np.uint32)
data['a_position'] = np.hstack((.25 * np.random.randn(n, 2), np.zeros((n, 1))))
data['a_fg_color'] = 0, 0, 0, 1
color = np.random.uniform(0.5, 1., (n, 3))
data['a_bg_color'] = np.hstack((color, np.ones((n, 1))))
data['a_size'] = np.random.randint(size=n, low=10, high=30)
data['a_linewidth'] = 2
u_antialias = 1


class Canvas(app.Canvas):

    def __init__(self, **kwargs):
        # Initialize the canvas for real
        app.Canvas.__init__(self, close_keys='escape', **kwargs)
        self.size = 512, 512
        self.position = 50, 50
        
        self.vbo = gloo.VertexBuffer(data)
        self.index = gloo.IndexBuffer(edges)
        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)

        self.program = gloo.Program(markers.vert, markers.frag + markers.disc)
        self.program.bind(self.vbo)
        self.program['u_size'] = 1
        self.program['u_antialias'] = u_antialias
        self.program['u_model'] = self.model
        self.program['u_view'] = self.view
        self.program['u_projection'] = self.projection

        self.program_e = gloo.Program(vs, fs)
        self.program_e.bind(self.vbo)

        # self.timer = app.Timer(.01)
        # self.timer.connect(self.on_timer)
        # self.timer.start()

    def on_initialize(self, event):
        gl.glClearColor(1, 1, 1, 1)
        gl.glDisable(gl.GL_DEPTH_TEST)
        gl.glEnable(gl.GL_BLEND)
        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)

    def on_key_press(self, event):
        if event.text == ' ':
            if self.timer.running:
                self.timer.stop()
            else:
                self.timer.start()

    def on_timer(self, event):
        self.update()

    def on_resize(self, event):
        width, height = event.size
        gl.glViewport(0, 0, width, height)

    def on_paint(self, event):
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
        self.program_e.draw(gl.GL_LINES, self.index)
        self.program.draw(gl.GL_POINTS)

if __name__ == '__main__':
    c = Canvas(title="Graph")
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = grayscott
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author:   Nicolas P .Rougier
# Date:     06/03/2014
# Abstract: GPU computing usingthe framebuffer
# Keywords: framebuffer, GPU computing, reaction-diffusion
# -----------------------------------------------------------------------------
import sys
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut
from vispy.gloo import Program, FrameBuffer, DepthBuffer


render_vertex = """
attribute vec2 position;
attribute vec2 texcoord;
varying vec2 v_texcoord;
void main()
{
    gl_Position = vec4(position, 0.0, 1.0);
    v_texcoord = texcoord;
}
"""

render_fragment = """
uniform int pingpong;
uniform sampler2D texture;
varying vec2 v_texcoord;
void main()
{
    float v;
    if( pingpong == 0 )
        v = texture2D(texture, v_texcoord).r;
    else
        v = texture2D(texture, v_texcoord).b;
    gl_FragColor = vec4(1.0-v, 1.0-v, 1.0-v, 1.0);
}
"""

compute_vertex = """
attribute vec2 position;
attribute vec2 texcoord;
varying vec2 v_texcoord;
void main()
{
    gl_Position = vec4(position, 0.0, 1.0);
    v_texcoord = texcoord;
}
"""

compute_fragment = """
uniform int pingpong;
uniform sampler2D texture; // U,V:= r,g, other channels ignored
uniform sampler2D params;  // rU,rV,f,k := r,g,b,a
uniform float dx;          // horizontal distance between texels
uniform float dy;          // vertical distance between texels
uniform float dd;          // unit of distance
uniform float dt;          // unit of time
varying vec2 v_texcoord;
void main(void)
{
    float center = -(4.0+4.0/sqrt(2.0));  // -1 * other weights
    float diag   = 1.0/sqrt(2.0);         // weight for diagonals
    vec2 p = v_texcoord;                  // center coordinates

    vec2 c,l;
    if( pingpong == 0 ) {
        c = texture2D(texture, p).rg;    // central value
        // Compute Laplacian
        l = ( texture2D(texture, p + vec2(-dx,-dy)).rg
            + texture2D(texture, p + vec2( dx,-dy)).rg
            + texture2D(texture, p + vec2(-dx, dy)).rg
            + texture2D(texture, p + vec2( dx, dy)).rg) * diag
            + texture2D(texture, p + vec2(-dx, 0.0)).rg
            + texture2D(texture, p + vec2( dx, 0.0)).rg
            + texture2D(texture, p + vec2(0.0,-dy)).rg
            + texture2D(texture, p + vec2(0.0, dy)).rg
            + c * center;
    } else {
        c = texture2D(texture, p).ba;    // central value
        // Compute Laplacian
        l = ( texture2D(texture, p + vec2(-dx,-dy)).ba
            + texture2D(texture, p + vec2( dx,-dy)).ba
            + texture2D(texture, p + vec2(-dx, dy)).ba
            + texture2D(texture, p + vec2( dx, dy)).ba) * diag
            + texture2D(texture, p + vec2(-dx, 0.0)).ba
            + texture2D(texture, p + vec2( dx, 0.0)).ba
            + texture2D(texture, p + vec2(0.0,-dy)).ba
            + texture2D(texture, p + vec2(0.0, dy)).ba
            + c * center;
    }

    float u = c.r;           // compute some temporary
    float v = c.g;           // values which might save
    float lu = l.r;          // a few GPU cycles
    float lv = l.g;
    float uvv = u * v * v;

    vec4 q = texture2D(params, p).rgba;
    float ru = q.r;          // rate of diffusion of U
    float rv = q.g;          // rate of diffusion of V
    float f  = q.b;          // some coupling parameter
    float k  = q.a;          // another coupling parameter

    float du = ru * lu / dd - uvv + f * (1.0 - u); // Gray-Scott equation
    float dv = rv * lv / dd + uvv - (f + k) * v;   // diffusion+-reaction

    u += du * dt;
    v += dv * dt;

    if( pingpong == 1 ) {
        gl_FragColor = vec4(clamp(u, 0.0, 1.0), clamp(v, 0.0, 1.0), c);
    } else {
        gl_FragColor = vec4(c, clamp(u, 0.0, 1.0), clamp(v, 0.0, 1.0));
    }
}
"""


def display():
    global comp_w, comp_h, disp_w, disp_h

    framebuffer.activate()
    gl.glViewport(0, 0, comp_w, comp_h)
    compute["texture"].interpolation = gl.GL_NEAREST
    compute.draw(gl.GL_TRIANGLE_STRIP)
    framebuffer.deactivate()

    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    gl.glViewport(0, 0, disp_w, disp_h)
    render["texture"].interpolation = gl.GL_LINEAR
    render.draw(gl.GL_TRIANGLE_STRIP)
    glut.glutSwapBuffers()


def reshape(width, height):
    global disp_w, disp_h
    gl.glViewport(0, 0, width, height)
    disp_w, disp_h = width, height


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def idle():
    global pingpong
    pingpong = 1 - pingpong
    compute["pingpong"] = pingpong
    render["pingpong"] = pingpong
    glut.glutPostRedisplay()


# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA)
glut.glutCreateWindow('Grayscott Reaction-Diffusion')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutIdleFunc(idle)


# Parameters
# ----------
scale = 4
comp_w, comp_h = 256, 256
disp_w, disp_h = 512, 512
dt = 1.0
dd = 1.5
species = {
    # name : [r_u, r_v, f, k]
    'Bacteria 1': [0.16, 0.08, 0.035, 0.065],
    'Bacteria 2': [0.14, 0.06, 0.035, 0.065],
    'Coral': [0.16, 0.08, 0.060, 0.062],
    'Fingerprint': [0.19, 0.05, 0.060, 0.062],
    'Spirals': [0.10, 0.10, 0.018, 0.050],
    'Spirals Dense': [0.12, 0.08, 0.020, 0.050],
    'Spirals Fast': [0.10, 0.16, 0.020, 0.050],
    'Unstable': [0.16, 0.08, 0.020, 0.055],
    'Worms 1': [0.16, 0.08, 0.050, 0.065],
    'Worms 2': [0.16, 0.08, 0.054, 0.063],
    'Zebrafish': [0.16, 0.08, 0.035, 0.060]
}
P = np.zeros((comp_h, comp_w, 4), dtype=np.float32)
P[:, :] = species['Unstable']

UV = np.zeros((comp_h, comp_w, 4), dtype=np.float32)
UV[:, :, 0] = 1.0
r = 32
UV[comp_h / 2 - r:comp_h / 2 + r, comp_w / 2 - r:comp_w / 2 + r, 0] = 0.50
UV[comp_h / 2 - r:comp_h / 2 + r, comp_w / 2 - r:comp_w / 2 + r, 1] = 0.25
UV += np.random.uniform(0.0, 0.01, (comp_h, comp_w, 4))
UV[:, :, 2] = UV[:, :, 0]
UV[:, :, 3] = UV[:, :, 1]

pingpong = 1
compute = Program(compute_vertex, compute_fragment, 4)
compute["params"] = P
compute["texture"] = UV
compute["position"] = [(-1, -1), (-1, +1), (+1, -1), (+1, +1)]
compute["texcoord"] = [(0, 0), (0, 1), (1, 0), (1, 1)]
compute['dt'] = dt
compute['dx'] = 1.0 / comp_w
compute['dy'] = 1.0 / comp_h
compute['dd'] = dd
compute['pingpong'] = pingpong

render = Program(render_vertex, render_fragment, 4)
render["position"] = [(-1, -1), (-1, +1), (+1, -1), (+1, +1)]
render["texcoord"] = [(0, 0), (0, 1), (1, 0), (1, 1)]
render["texture"] = compute["texture"]
render['pingpong'] = pingpong

framebuffer = FrameBuffer(color=compute["texture"],
                          depth=DepthBuffer((comp_w, comp_h)))

# OpenGL initialization
# --------------------------------------
gl.glDisable(gl.GL_DEPTH_TEST)
gl.glClearColor(0, 0, 0, 1)

# Start
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = mandelbrot
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: John David Reaver
# Date:   04/29/2014
# -----------------------------------------------------------------------------

from vispy import app, gloo

# Shader source code
# -----------------------------------------------------------------------------
vertex = """
attribute vec2 position;

void main()
{
    gl_Position = vec4(position, 0, 1.0);
}
"""

fragment = """
uniform vec2 resolution;
uniform vec2 center;
uniform float scale;
uniform int iter;

// Jet color scheme
vec4 color_scheme(float x) {
    vec3 a, b;
    float c;
    if (x < 0.34) {
        a = vec3(0, 0, 0.5);
        b = vec3(0, 0.8, 0.95);
        c = (x - 0.0) / (0.34 - 0.0);
    } else if (x < 0.64) {
        a = vec3(0, 0.8, 0.95);
        b = vec3(0.85, 1, 0.04);
        c = (x - 0.34) / (0.64 - 0.34);
    } else if (x < 0.89) {
        a = vec3(0.85, 1, 0.04);
        b = vec3(0.96, 0.7, 0);
        c = (x - 0.64) / (0.89 - 0.64);
    } else {
        a = vec3(0.96, 0.7, 0);
        b = vec3(0.5, 0, 0);
        c = (x - 0.89) / (1.0 - 0.89);
    }
    return vec4(mix(a, b, c), 1.0);
}

void main() {
    vec2 z, c;

    // Recover coordinates from pixel coordinates
    c.x = (gl_FragCoord.x / resolution.x - 0.5) * scale + center.x;
    c.y = (gl_FragCoord.y / resolution.y - 0.5) * scale + center.y;

    // Main Mandelbrot computation
    int i;
    z = c;
    for(i = 0; i < iter; i++) {
        float x = (z.x * z.x - z.y * z.y) + c.x;
        float y = (z.y * z.x + z.x * z.y) + c.y;

        if((x * x + y * y) > 4.0) break;
        z.x = x;
        z.y = y;
    }

    // Convert iterations to color
    float color = 1.0 - float(i) / float(iter);
    gl_FragColor = color_scheme(color);

}
"""


# vispy Canvas
# -----------------------------------------------------------------------------
class Canvas(app.Canvas):

    def __init__(self, *args, **kwargs):
        app.Canvas.__init__(self, *args, **kwargs)
        self.program = gloo.Program(vertex, fragment)

        # Draw a rectangle that takes up the whole screen. All of the work is
        # done in the shader.
        self.program["position"] = [(-1, -1), (-1, 1), (1, 1),
                                    (-1, -1), (1, 1), (1, -1)]

        self.scale = self.program["scale"] = 3
        self.center = self.program["center"] = [-0.5, 0]
        self.iterations = self.program["iter"] = 300
        self.program['resolution'] = self.size

        self.bounds = [-2, 2]
        self.min_scale = 0.00005
        self.max_scale = 4

        self.timer = app.Timer(1.0 / 60)  # change rendering speed here
        self.timer.connect(lambda x: self.update())
        self.timer.start()

    def on_initialize(self, event):
        gloo.set_clear_color(color=(0., 0., 0., 1.))

    def on_paint(self, event):
        self.program.draw()

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)
        self.program['resolution'] = [width, height]

    def on_mouse_move(self, event):
        """Pan the view based on the change in mouse position."""
        if event.is_dragging and event.buttons[0] == 1:
            x0, y0 = event.last_event.pos[0], event.last_event.pos[1]
            x1, y1 = event.pos[0], event.pos[1]
            X0, Y0 = self.pixel_to_coords(float(x0), float(y0))
            X1, Y1 = self.pixel_to_coords(float(x1), float(y1))
            self.translate_center(X1 - X0, Y1 - Y0)

    def translate_center(self, dx, dy):
        """Translates the center point, and keeps it in bounds."""
        center = self.center
        center[0] -= dx
        center[1] -= dy
        center[0] = min(max(center[0], self.bounds[0]), self.bounds[1])
        center[1] = min(max(center[1], self.bounds[0]), self.bounds[1])
        self.program["center"] = self.center = center

    def pixel_to_coords(self, x, y):
        """Convert pixel coordinates to Mandelbrot set coordinates."""
        rx, ry = self.size
        nx = (x / rx - 0.5) * self.scale + self.center[0]
        ny = ((ry - y) / ry - 0.5) * self.scale + self.center[1]
        return [nx, ny]

    def on_mouse_wheel(self, event):
        """Use the mouse wheel to zoom."""
        delta = event.delta[1]
        if delta > 0:  # Zoom in
            factor = 0.9
        elif delta < 0:  # Zoom out
            factor = 1 / 0.9
        for _ in range(int(abs(delta))):
            self.zoom(factor, event.pos)

    def on_key_press(self, event):
        """Use + or - to zoom in and out.

        The mouse wheel can be used to zoom, but some people don't have mouse
        wheels :)

        """
        if event.text == '+':
            self.zoom(0.9)
        elif event.text == '-':
            self.zoom(1/0.9)

    def zoom(self, factor, mouse_coords=None):
        """Factors less than zero zoom in, and greater than zero zoom out.

        If mouse_coords is given, the point under the mouse stays stationary
        while zooming. mouse_coords should come from MouseEvent.pos.

        """
        if mouse_coords:  # Record the position of the mouse
            x, y = float(mouse_coords[0]), float(mouse_coords[1])
            x0, y0 = self.pixel_to_coords(x, y)

        self.scale *= factor
        self.scale = max(min(self.scale, self.max_scale), self.min_scale)
        self.program["scale"] = self.scale

        if mouse_coords:  # Translate so the mouse point is stationary
            x1, y1 = self.pixel_to_coords(x, y)
            self.translate_center(x1 - x0, y1 - y0)


if __name__ == '__main__':
    canvas = Canvas(size=(800, 800), close_keys='ESCAPE')
    canvas.show()
    app.run()

########NEW FILE########
__FILENAME__ = markers
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
"""
Marker shader definitions. You need to combine marker_frag with one of the
available marker function (marker_disc, marker_diamond, ...)
"""


vert = """
#version 120

// Uniforms
// ------------------------------------
uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
uniform float u_antialias;
uniform float u_size;

// Attributes
// ------------------------------------
attribute vec3  a_position;
attribute vec4  a_fg_color;
attribute vec4  a_bg_color;
attribute float a_linewidth;
attribute float a_size;

// Varyings
// ------------------------------------
varying vec4 v_fg_color;
varying vec4 v_bg_color;
varying float v_size;
varying float v_linewidth;
varying float v_antialias;

void main (void) {
    v_size = a_size * u_size;
    v_linewidth = a_linewidth;
    v_antialias = u_antialias;
    v_fg_color  = a_fg_color;
    v_bg_color  = a_bg_color;
    gl_Position = u_projection * u_view * u_model *
        vec4(a_position*u_size,1.0);
    gl_PointSize = v_size + 2*(v_linewidth + 1.5*v_antialias);
}
"""


frag = """
#version 120

// Constants
// ------------------------------------

// Varyings
// ------------------------------------
varying vec4 v_fg_color;
varying vec4 v_bg_color;
varying float v_size;
varying float v_linewidth;
varying float v_antialias;

// Functions
// ------------------------------------
float marker(vec2 P, float size);


// Main
// ------------------------------------
void main()
{
    float size = v_size +2*(v_linewidth + 1.5*v_antialias);
    float t = v_linewidth/2.0-v_antialias;

    // The marker function needs to be linked with this shader
    float r = marker(gl_PointCoord, size);

    float d = abs(r) - t;
    if( r > (v_linewidth/2.0+v_antialias))
    {
        discard;
    }
    else if( d < 0.0 )
    {
       gl_FragColor = v_fg_color;
    }
    else
    {
        float alpha = d/v_antialias;
        alpha = exp(-alpha*alpha);
        if (r > 0)
            gl_FragColor = vec4(v_fg_color.rgb, alpha*v_fg_color.a);
        else
            gl_FragColor = mix(v_bg_color, v_fg_color, alpha);
    }
}
"""


disc = """
float marker(vec2 P, float size)
{
    float r = length((P.xy - vec2(0.5,0.5))*size);
    r -= v_size/2;
    return r;
}
"""


arrow = """
float marker(vec2 P, float size)
{
    float r1 = abs(P.x -.50)*size + abs(P.y -.5)*size - v_size/2;
    float r2 = abs(P.x -.25)*size + abs(P.y -.5)*size - v_size/2;
    float r = max(r1,-r2);
    return r;
}
"""


ring = """
float marker(vec2 P, float size)
{
    float r1 = length((P.xy - vec2(0.5,0.5))*size) - v_size/2;
    float r2 = length((P.xy - vec2(0.5,0.5))*size) - v_size/4;
    float r = max(r1,-r2);
    return r;
}
"""


clobber = """
float marker(vec2 P, float size)
{
    const float PI = 3.14159265358979323846264;
    const float t1 = -PI/2;
    const vec2  c1 = 0.2*vec2(cos(t1),sin(t1));
    const float t2 = t1+2*PI/3;
    const vec2  c2 = 0.2*vec2(cos(t2),sin(t2));
    const float t3 = t2+2*PI/3;
    const vec2  c3 = 0.2*vec2(cos(t3),sin(t3));

    float r1 = length((P.xy- vec2(0.5,0.5) - c1)*size);
    r1 -= v_size/3;
    float r2 = length((P.xy- vec2(0.5,0.5) - c2)*size);
    r2 -= v_size/3;
    float r3 = length((P.xy- vec2(0.5,0.5) - c3)*size);
    r3 -= v_size/3;
    float r = min(min(r1,r2),r3);
    return r;
}
"""


square = """
float marker(vec2 P, float size)
{
    float r = max(abs(P.x -.5)*size, abs(P.y -.5)*size);
    r -= v_size/2;
    return r;
}
"""


diamond = """
float marker(vec2 P, float size)
{
    float r = abs(P.x -.5)*size + abs(P.y -.5)*size;
    r -= v_size/2;
    return r;
}
"""


vbar = """
float marker(vec2 P, float size)
{
    float r1 = max(abs(P.x - 0.75)*size, abs(P.x - 0.25)*size);
    float r3 = max(abs(P.x - 0.50)*size, abs(P.y - 0.50)*size);
    float r = max(r1,r3);
    r -= v_size/2;
    return r;
}
"""


hbar = """
float marker(vec2 P, float size)
{
    float r2 = max(abs(P.y - 0.75)*size, abs(P.y - 0.25)*size);
    float r3 = max(abs(P.x - 0.50)*size, abs(P.y - 0.50)*size);
    float r = max(r2,r3);
    r -= v_size/2;
    return r;
}
"""


cross = """
float marker(vec2 P, float size)
{
    float r1 = max(abs(P.x - 0.75)*size, abs(P.x - 0.25)*size);
    float r2 = max(abs(P.y - 0.75)*size, abs(P.y - 0.25)*size);
    float r3 = max(abs(P.x - 0.50)*size, abs(P.y - 0.50)*size);
    float r = max(min(r1,r2),r3);
    r -= v_size/2;
    return r;
}
"""

tailed_arrow = """
float marker(vec2 P, float size)
{

   //arrow_right
    float r1 = abs(P.x -.50)*size + abs(P.y -.5)*size - v_size/2;
    float r2 = abs(P.x -.25)*size + abs(P.y -.5)*size - v_size/2;
    float arrow = max(r1,-r2);

    //hbar
    float r3 = (abs(P.y-.5)*2+.3)*v_size-v_size/2;
    float r4 = (P.x -.775)*size;
    float r6 = abs(P.x -.5)*size-v_size/2;
    float limit = (P.x -.5)*size + abs(P.y -.5)*size - v_size/2;
    float hbar = max(limit,max(max(r3,r4),r6));

    return min(arrow,hbar);
}
"""

########NEW FILE########
__FILENAME__ = molecular_viewer
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# 2014, Aurore Deschildre, Gael Goret, Cyrille Rossant, Nicolas P. Rougier.
# Distributed under the terms of the new BSD License.
# -----------------------------------------------------------------------------
import numpy as np

from vispy import gloo
from vispy import app
from vispy.util.transforms import perspective, translate, rotate
from vispy.util import get_data_file

vertex = """
#version 120

uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
uniform vec3 u_light_position;
uniform vec3 u_light_spec_position;

attribute vec3  a_position;
attribute vec3  a_color;
attribute float a_radius;

varying vec3  v_color;
varying vec4  v_eye_position;
varying float v_radius;
varying vec3  v_light_direction;

void main (void) {
    v_radius = a_radius;
    v_color = a_color;

    v_eye_position = u_view * u_model * vec4(a_position,1.0);
    v_light_direction = normalize(u_light_position);
    float dist = length(v_eye_position.xyz);

    gl_Position = u_projection * v_eye_position;

    // stackoverflow.com/questions/8608844/...
    //  ... resizing-point-sprites-based-on-distance-from-the-camera
    vec4  proj_corner = u_projection * vec4(a_radius, a_radius, v_eye_position.z, v_eye_position.w);  // # noqa
    gl_PointSize = 512.0 * proj_corner.x / proj_corner.w;
}
"""

fragment = """
#version 120

uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
uniform vec3 u_light_position;
uniform vec3 u_light_spec_position;

varying vec3  v_color;
varying vec4  v_eye_position;
varying float v_radius;
varying vec3  v_light_direction;
void main()
{
    // r^2 = (x - x0)^2 + (y - y0)^2 + (z - z0)^2
    vec2 texcoord = gl_PointCoord* 2.0 - vec2(1.0);
    float x = texcoord.x;
    float y = texcoord.y;
    float d = 1.0 - x*x - y*y;
    if (d <= 0.0)
        discard;

    float z = sqrt(d);
    vec4 pos = v_eye_position;
    pos.z += v_radius*z;
    vec3 pos2 = pos.xyz;
    pos = u_projection * pos;
    gl_FragDepth = 0.5*(pos.z / pos.w)+0.5;
    vec3 normal = vec3(x,y,z);
    float diffuse = clamp(dot(normal, v_light_direction), 0.0, 1.0);

    // Specular lighting.
    vec3 M = pos2.xyz;
    vec3 O = v_eye_position.xyz;
    vec3 L = u_light_spec_position;
    vec3 K = normalize(normalize(L - M) + normalize(O - M));
    // WARNING: abs() is necessary, otherwise weird bugs may appear with some
    // GPU drivers...
    float specular = clamp(pow(abs(dot(normal, K)), 40.), 0.0, 1.0);
    vec3 v_light = vec3(1., 1., 1.);
    gl_FragColor.rgb = (.15*v_color + .55*diffuse * v_color
                        + .35*specular * v_light);
}
"""


class MolecularViewerCanvas(app.Canvas):

    def __init__(self, fname):
        app.Canvas.__init__(self, title='Molecular viewer',
                            close_keys='escape')
        self.size = 1200, 800

        self.program = gloo.Program(vertex, fragment)
        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)
        self.translate = 40
        translate(self.view, 0, 0, -self.translate)

        self.load_molecule(fname)
        self.load_data()

        self.theta = 0
        self.phi = 0

        self.timer = app.Timer(1.0 / 30)  # change rendering speed here
        self.timer.connect(self.on_timer)
        self.timer.start()

    def load_molecule(self, fname):
        molecule = np.load(fname)['molecule']
        self._nAtoms = molecule.shape[0]

        # The x,y,z values store in one array
        self.coords = molecule[:, :3]

        # The array that will store the color and alpha scale for all the atoms
        self.atomsColours = molecule[:, 3:6]

        # The array that will store the scale for all the atoms.
        self.atomsScales = molecule[:, 6]

    def load_data(self):
        n = self._nAtoms

        data = np.zeros(n, [('a_position', np.float32, 3),
                            ('a_color', np.float32, 3),
                            ('a_radius', np.float32, 1)])

        data['a_position'] = self.coords
        data['a_color'] = self.atomsColours
        data['a_radius'] = self.atomsScales

        self.program.bind(gloo.VertexBuffer(data))

        self.program['u_model'] = self.model
        self.program['u_view'] = self.view
        self.program['u_light_position'] = 0., 0., 2.
        self.program['u_light_spec_position'] = -5., 5., -5.

    def on_initialize(self, event):
        gloo.set_state(depth_test=True, clear_color=(0, 0, 0, 1))

    def on_key_press(self, event):
        if event.text == ' ':
            if self.timer.running:
                self.timer.stop()
            else:
                self.timer.start()
        # if event.text == 'A':
            # self.

    def on_timer(self, event):
        self.theta += .5
        self.phi += .5
        self.model = np.eye(4, dtype=np.float32)

        rotate(self.model, self.theta, 0, 0, 1)
        rotate(self.model, self.phi, 0, 1, 0)

        self.program['u_model'] = self.model
        self.update()

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)
        self.projection = perspective(25.0, width / float(height), 2.0, 100.0)
        self.program['u_projection'] = self.projection

    def on_mouse_wheel(self, event):
        self.translate -= event.delta[1]
        self.translate = max(-1, self.translate)
        self.view = np.eye(4, dtype=np.float32)

        translate(self.view, 0, 0, -self.translate)

        self.program['u_view'] = self.view
        self.update()

    def on_paint(self, event):
        gloo.clear()
        self.program.draw('points')


def main(fname):
    mvc = MolecularViewerCanvas(fname)
    mvc.show()
    app.run()

if __name__ == '__main__':
    fname = get_data_file('molecular_viewer/micelle.npz')
    main(fname)

########NEW FILE########
__FILENAME__ = rain
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author:   Nicolas P .Rougier
# Date:     06/03/2014
# Abstract: Water ripple effect following mouse
# Keywords: antialias, water, mouse
# -----------------------------------------------------------------------------
import sys
import numpy as np
import OpenGL.GLUT as glut

from vispy import gloo
from vispy.gloo import Program, VertexBuffer
from vispy.util.transforms import ortho

vertex = """
#version 120

uniform mat4  u_model;
uniform mat4  u_view;
uniform mat4  u_projection;
uniform float u_linewidth;
uniform float u_antialias;

attribute vec3  a_position;
attribute vec4  a_fg_color;
attribute float a_size;

varying vec4  v_fg_color;
varying float v_size;

void main (void)
{
    v_size = a_size;
    v_fg_color = a_fg_color;
    if( a_fg_color.a > 0.0)
    {
        gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);
        gl_PointSize = v_size + u_linewidth + 2*1.5*u_antialias;
    }
    else
    {
        gl_Position = u_projection * u_view * u_model * vec4(-1,-1,0,1);
        gl_PointSize = 0.0;
    }
}
"""

fragment = """
#version 120

uniform float u_linewidth;
uniform float u_antialias;
varying vec4  v_fg_color;
varying vec4  v_bg_color;
varying float v_size;
float disc(vec2 P, float size)
{
    return length((P.xy - vec2(0.5,0.5))*size);
}
void main()
{
    if( v_fg_color.a <= 0.0)
        discard;
    float actual_size = v_size + u_linewidth + 2*1.5*u_antialias;
    float t = u_linewidth/2.0 - u_antialias;
    float r = disc(gl_PointCoord, actual_size);
    float d = abs(r - v_size/2.0) - t;
    if( d < 0.0 )
    {
         gl_FragColor = v_fg_color;
    }
    else if( abs(d) > 2.5*u_antialias )
    {
         discard;
    }
    else
    {
        d /= u_antialias;
        gl_FragColor = vec4(v_fg_color.rgb, exp(-d*d)*v_fg_color.a);
    }
}
"""


def display():
    gloo.clear()
    program.draw('points')
    glut.glutSwapBuffers()


def reshape(width, height):
    gloo.set_viewport(0, 0, width, height)
    projection = ortho(0, width, 0, height, -1, +1)
    program['u_projection'] = projection


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def timer(fps):
    glut.glutTimerFunc(1000 / fps, timer, fps)
    data['a_fg_color'][..., 3] -= 0.01
    data['a_size'] += 1.0
    vdata.set_data(data)
    glut.glutPostRedisplay()


def on_passive_motion(x, y):
    global index
    _, _, _, h = gloo.get_parameter('viewport')
    data['a_position'][index] = x, h - y
    data['a_size'][index] = 5
    data['a_fg_color'][index] = 0, 0, 0, 1
    index = (index + 1) % 500
    glut.glutPostRedisplay()


# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
glut.glutCreateWindow('Rain [Move mouse]')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutPassiveMotionFunc(on_passive_motion)
glut.glutTimerFunc(1000 / 60, timer, 60)

# Build data
# --------------------------------------
n = 500
data = np.zeros(n, [('a_position', np.float32, 2),
                    ('a_fg_color', np.float32, 4),
                    ('a_size',     np.float32, 1)])
index = 0

# Build program
# --------------------------------------
program = Program(vertex, fragment)
vdata = VertexBuffer(data)
program.bind(vdata)
program['u_antialias'] = 1.00
program['u_linewidth'] = 1.00

# Build view, model, projection
# --------------------------------------
program['u_model'] = np.eye(4, dtype=np.float32)
program['u_view'] = np.eye(4, dtype=np.float32)

# OpenGL initalization
# --------------------------------------
gloo.set_clear_color((1.0, 1.0, 1.0, 1.0))
gloo.set_state(blend=True, blend_func=('src_alpha', 'one_minus_src_alpha'))
gloo.gl_initialize()

# Start
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = show-markers
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 2

""" Display markers at different sizes and line thicknessess.
"""

import os
import sys

import numpy as np

from vispy import app
from vispy.util.transforms import ortho
from vispy.gloo import Program, VertexBuffer
from vispy import gloo

sys.path.insert(0, os.path.dirname(__file__))
import markers


n = 540
data = np.zeros(n, dtype=[('a_position', np.float32, 3),
                          ('a_fg_color', np.float32, 4),
                          ('a_bg_color', np.float32, 4),
                          ('a_size', np.float32, 1),
                          ('a_linewidth', np.float32, 1)])
data['a_fg_color'] = 0, 0, 0, 1
data['a_bg_color'] = 1, 1, 1, 1
data['a_linewidth'] = 1
u_antialias = 1

radius, theta, dtheta = 255.0, 0.0, 5.5 / 180.0 * np.pi
for i in range(500):
    theta += dtheta
    x = 256 + radius * np.cos(theta)
    y = 256 + 32 + radius * np.sin(theta)
    r = 10.1 - i * 0.02
    radius -= 0.45
    data['a_position'][i] = x, y, 0
    data['a_size'][i] = 2 * r

for i in range(40):
    r = 4
    thickness = (i + 1) / 10.0
    x = 20 + i * 12.5 - 2 * r
    y = 16
    data['a_position'][500 + i] = x, y, 0
    data['a_size'][500 + i] = 2 * r
    data['a_linewidth'][500 + i] = thickness


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')

        # This size is used for comparison with agg (via matplotlib)
        self.size = 512, 512 + 2 * 32
        self.title = "Markers demo [press space to change marker]"

        self.vbo = VertexBuffer(data)
        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = ortho(0, self.size[0], 0, self.size[1], -1, 1)
        self.programs = [
            Program(markers.vert, markers.frag + markers.tailed_arrow),
            Program(markers.vert, markers.frag + markers.disc),
            Program(markers.vert, markers.frag + markers.diamond),
            Program(markers.vert, markers.frag + markers.square),
            Program(markers.vert, markers.frag + markers.cross),
            Program(markers.vert, markers.frag + markers.arrow),
            Program(markers.vert, markers.frag + markers.vbar),
            Program(markers.vert, markers.frag + markers.hbar),
            Program(markers.vert, markers.frag + markers.clobber),
            Program(markers.vert, markers.frag + markers.ring)]

        for program in self.programs:
            program.bind(self.vbo)
            program["u_antialias"] = u_antialias,
            program["u_size"] = 1
            program["u_model"] = self.model
            program["u_view"] = self.view
            program["u_projection"] = self.projection
        self.index = 0
        self.program = self.programs[self.index]

    def on_initialize(self, event):
        gloo.set_state(depth_test=False, blend=True, clear_color=(1, 1, 1, 1),
                       blend_func=('src_alpha', 'one_minus_src_alpha'))

    def on_key_press(self, event):
        if event.text == ' ':
            self.index = (self.index + 1) % (len(self.programs))
            self.program = self.programs[self.index]
            self.program['u_projection'] = self.projection
            self.program['u_size'] = self.u_size
            self.update()

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)
        self.projection = ortho(0, width, 0, height, -100, 100)
        self.u_size = width / 512.0
        self.program['u_projection'] = self.projection
        self.program['u_size'] = self.u_size

    def on_paint(self, event):
        gloo.clear()
        self.program.draw('points')

if __name__ == '__main__':
    canvas = Canvas()
    canvas.show()
    app.run()

########NEW FILE########
__FILENAME__ = spacy
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# 2014, Almar Klein
# Distributed under the terms of the new BSD License.
# -----------------------------------------------------------------------------

""" Visualization of traveling through space.
"""

import time

import numpy as np

from vispy import gloo
from vispy import app
from vispy.util.transforms import perspective


vertex = """
#version 120

uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
uniform float u_time_offset;

attribute vec3  a_position;
attribute float a_offset;

varying float v_pointsize;

void main (void) {
   
    vec3 pos = a_position;
    pos.z = pos.z - a_offset - u_time_offset;
    vec4 v_eye_position = u_view * u_model * vec4(pos, 1.0);
    gl_Position = u_projection * v_eye_position;

    // stackoverflow.com/questions/8608844/...
    //  ... resizing-point-sprites-based-on-distance-from-the-camera
    float radius = 1;
    vec4 corner = vec4(radius, radius, v_eye_position.z, v_eye_position.w);
    vec4  proj_corner = u_projection * corner;
    gl_PointSize = 100.0 * proj_corner.x / proj_corner.w;
    v_pointsize = gl_PointSize;
}
"""

fragment = """
#version 120
varying float v_pointsize;
void main()
{
    float x = 2.0*gl_PointCoord.x - 1.0;
    float y = 2.0*gl_PointCoord.y - 1.0;
    float a = 0.9 - (x*x + y*y);
    a = a * min(1.0, v_pointsize/1.5);
    gl_FragColor = vec4(1.0, 1.0, 1.0, a);
}
"""

N = 100000  # Number of stars 
SIZE = 100
SPEED = 4.0  # time in seconds to go through one block
NBLOCKS = 10


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, title='Spacy', close_keys='escape')
        self.size = 800, 600
        
        self.program = gloo.Program(vertex, fragment)
        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)
        
        self.timer = app.Timer(1.0 / 30)  # change rendering speed here
        self.timer.connect(lambda x: self.update())
        self.timer.start()
        
        # Set uniforms (some are set later)
        self.program['u_model'] = self.model
        self.program['u_view'] = self.view
        
        # Set attributes
        self.program['a_position'] = np.zeros((N, 3), np.float32)
        self.program['a_offset'] = np.zeros((N,), np.float32)
        
        # Init
        self._timeout = 0
        self._active_block = 0
        for i in range(NBLOCKS):
            self._generate_stars()
        self._timeout = time.time() + SPEED
    
    def on_initialize(self, event):
        gloo.set_state(clear_color=(0.0, 0.0, 0.0, 0.0), depth_test=False,
                       blend=True, blend_equation='func_add',
                       blend_func=('src_alpha', 'one_minus_src_alpha'))

    def on_key_press(self, event):
        if event.text == ' ':
            if self.timer.running:
                self.timer.stop()
            else:
                self.timer.start()

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)
        far = SIZE*(NBLOCKS-2)
        self.projection = perspective(25.0, width / float(height), 1.0, far)
        self.program['u_projection'] = self.projection

    def on_paint(self, event):
        # Set time offset. Factor runs from 1 to 0
        # the time offset goes from 0 to size
        factor = (self._timeout - time.time()) / SPEED
        self.program['u_time_offset'] = -(1-factor) * SIZE
        
        # Draw
        gloo.clear()
        self.program.draw('points')
        
        # Build new starts if the first block is fully behind us
        if factor < 0:
            self._generate_stars()
    
    def on_close(self, event):
        self.timer.stop()
    
    def _generate_stars(self):
        
        # Get number of stars in each block
        blocksize = N // NBLOCKS
        
        # Update active block
        self._active_block += 1
        if self._active_block >= NBLOCKS:
            self._active_block = 0
        
        # Create new position data for the active block
        pos = np.zeros((blocksize, 3), 'float32') 
        pos[:, :2] = np.random.normal(0.0, SIZE/2, (blocksize, 2))  # x-y
        pos[:, 2] = np.random.uniform(0, SIZE, (blocksize,))  # z
        start_index = self._active_block * blocksize
        self.program['a_position'].set_data(pos, offset=start_index) 
        
        #print(start_index)
        
        # Set offsets - active block gets offset 0
        for i in range(NBLOCKS):
            val = i - self._active_block
            if val < 0:
                val += NBLOCKS
            values = np.ones((blocksize, 1), 'float32') * val * SIZE
            start_index = i*blocksize
            self.program['a_offset'].set_data(values, offset=start_index) 
        
        # Reset timer
        self._timeout += SPEED


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = terrain
# !/usr/bin/env python
# -*- coding: utf-8 -*-

""" Terrain generation using diamond-square alogrithm 
and Scipy for Delaunay triangulation
"""

from vispy import gloo
from vispy import app
from vispy.gloo import gl
from vispy.util.transforms import perspective, translate, xrotate, yrotate
from vispy.util.transforms import zrotate
import numpy as np
from scipy.spatial import Delaunay

# Arrays for storing generated points and triangles
points = []
triangles = []
height = 0.0


def generate_terrain(r_min, r_max, c_min, c_max, disp):
    """Recursively generates terrain using diamond-square algorithm
    and stores the vertices in points
    """
    a = points[r_min][c_min][2]
    b = points[r_min][c_max][2]
    c = points[r_max][c_min][2]
    d = points[r_max][c_max][2]

    r_mid = (r_min + r_max)/2
    c_mid = (c_min + c_max)/2

    e = (a+b+c+d)/4 + np.random.uniform(0, disp)

    points[r_mid][c_mid][2] = e

    points[r_min][c_mid][2] = (a + b + e)/3 + np.random.uniform(0, disp)
    points[r_max][c_mid][2] = (c + d + e)/3 + np.random.uniform(0, disp)
    points[r_mid][c_min][2] = (a + c + e)/3 + np.random.uniform(0, disp)
    points[r_mid][c_max][2] = (b + d + e)/3 + np.random.uniform(0, disp)

    new_disp = disp * (2 ** (-0.5))

    if (r_mid - r_min > 1 or c_mid - c_min > 1):
        generate_terrain(r_min, r_mid, c_min, c_mid, new_disp)
    if (r_max - r_mid > 1 or c_mid - c_min > 1):
        generate_terrain(r_mid, r_max, c_min, c_mid, new_disp)
    if (r_mid - r_min > 1 or c_max - c_mid > 1):
        generate_terrain(r_min, r_mid, c_mid, c_max, new_disp)
    if (r_max - r_mid > 1 or c_max - c_mid > 1):
        generate_terrain(r_mid, r_max, c_mid, c_max, new_disp)


def generate_points(length=3):
    """Generates points via recursive function and generate triangles using
    Scipy Delaunay triangulation

    Parameters
    ----------
    length : int
        (2 ** length + 1 by 2 ** length + 1) number of points is generated

    """
    print("Points are being generated...")
    global points, triangles, height
    size = 2**(length) + 1
    points = np.indices((size, size, 1)).T[0].transpose((1, 0, 2))
    points = points.astype(np.float32)
    generate_terrain(0, size-1, 0, size-1, length)
    height = length
    points = np.resize(points, (size*size, 3))
    points2 = np.delete(points, 2, 1)
    tri = Delaunay(points2)
    triangles = points[tri.simplices]
    triangles = np.vstack(triangles)
    print("Points successfully generated.")

VERT_SHADER = """
uniform   float u_height;
uniform   mat4 u_model;
uniform   mat4 u_view;
uniform   mat4 u_projection;

attribute vec3  a_position;

varying vec4 v_color;

void main (void) {
    gl_Position = u_projection * u_view * u_model * vec4(a_position, 1.0);
    v_color = vec4(0.0, a_position[2] * a_position[2] / (u_height * u_height
                   * u_height), 0.1, 1.0);
}
"""

FRAG_SHADER = """
varying vec4 v_color;

void main()
{
    gl_FragColor = v_color;
}
"""


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')

        self.program = gloo.Program(VERT_SHADER, FRAG_SHADER)
        #Sets the view to an appropriate position over the terrain
        self.default_view = np.array([[0.8, 0.2, -0.48, 0],
                                     [-0.5, 0.3, -0.78, 0],
                                     [-0.01, 0.9, -0.3, 0],
                                     [-4.5, -21.5, -7.4, 1]],
                                     dtype=np.float32)
        self.view = self.default_view
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)

        self.translate = [0, 0, 0]
        self.rotate = [0, 0, 0]

        self.program['u_height'] = height
        self.program['u_model'] = self.model
        self.program['u_view'] = self.view

        self.program['a_position'] = gloo.VertexBuffer(triangles)

    def on_initialize(self, event):
        gl.glClearColor(0, 0, 0, 1)
        gl.glEnable(gl.GL_DEPTH_TEST)        

    def on_key_press(self, event):
        """Controls -
        a(A) - move left
        d(D) - move right
        w(W) - move up
        s(S) - move down
        x/X - rotate about x-axis cw/anti-cw
        y/Y - rotate about y-axis cw/anti-cw
        z/Z - rotate about z-axis cw/anti-cw
        space - reset view
        p(P) - print current view
        i(I) - zoom in
        o(O) - zoom out
        """
        self.translate = [0, 0, 0]
        self.rotate = [0, 0, 0]

        if(event.text == 'p' or event.text == 'P'):
            print(self.view)
        elif(event.text == 'd' or event.text == 'D'):
            self.translate[0] = 0.3
        elif(event.text == 'a' or event.text == 'A'):
            self.translate[0] = -0.3
        elif(event.text == 'w' or event.text == 'W'):
            self.translate[1] = 0.3
        elif(event.text == 's' or event.text == 'S'):
            self.translate[1] = -0.3
        elif(event.text == 'o' or event.text == 'O'):
            self.translate[2] = 0.3
        elif(event.text == 'i' or event.text == 'I'):
            self.translate[2] = -0.3
        elif(event.text == 'x'):
            self.rotate = [1, 0, 0]
        elif(event.text == 'X'):
            self.rotate = [-1, 0, 0]
        elif(event.text == 'y'):
            self.rotate = [0, 1, 0]
        elif(event.text == 'Y'):
            self.rotate = [0, -1, 0]
        elif(event.text == 'z'):
            self.rotate = [0, 0, 1]
        elif(event.text == 'Z'):
            self.rotate = [0, 0, -1]
        elif(event.text == ' '):
            self.view = self.default_view

        translate(self.view, -self.translate[0], -self.translate[1],
                  -self.translate[2])
        xrotate(self.view, self.rotate[0])
        yrotate(self.view, self.rotate[1])
        zrotate(self.view, self.rotate[2])

        self.program['u_view'] = self.view
        self.update()

    def on_resize(self, event):
        width, height = event.size
        gl.glViewport(0, 0, width, height)
        self.projection = perspective(60.0, width / float(height), 1.0, 100.0)
        self.program['u_projection'] = self.projection

    def on_paint(self, event):
        # Clear
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
        # Draw
        self.program.draw(gl.GL_TRIANGLES)


if __name__ == '__main__':
    generate_points(8)
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = unstructured_2d
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author:   Per Rosengren
# Date:     18/03/2014
# Abstract: Unstructured2D canvas example
# Keywords: unstructured delaunay colormap
# Require: scipy
# ----------------------------------------------------------------------------
"""Unstructured2D canvas example.

Takes unstructured 2D locations, with corresponding 1 or 2 dimensional
scalar "values". Plots the values looked up from colormaps and
interpolated between the locations.
"""

import numpy as np
from vispy import gloo
from vispy import app
from vispy.gloo import gl
from vispy.util.transforms import ortho

import scipy.spatial


class Unstructured2d(app.Canvas):

    def __init__(self,
                 x=None, y=None, u=None, v=None,
                 colormap=None, data_lim=None,
                 dir_x_right=True, dir_y_top=True,
                 **kwargs):
        app.Canvas.__init__(self, close_keys='escape', **kwargs)
        self.create_shader(colormap)
        self.create_mesh(x, y, u, v)
        self.program.bind(self.vbo)
        if data_lim is not None:
            self._data_lim = data_lim
        else:
            self._data_lim = [[x.min(), x.max()], [y.min(), y.max()]]
        self._dir_x_right = dir_x_right
        self._dir_y_top = dir_y_top

    def create_shader(self, colormap):
        if len(colormap.shape) == 2:
            args = dict(
                n_dims="1",
                tex_t="float",
                texture2D_arg="vec2(v_texcoord, 0.)")
        else:
            args = dict(
                n_dims="2",
                tex_t="vec2",
                texture2D_arg="v_texcoord")
        vertex = """
            uniform mat4 model;
            uniform mat4 view;
            uniform mat4 projection;
            uniform sampler2D texture;
            
            attribute vec2 position;
            attribute {tex_t} texcoord;
            
            varying {tex_t} v_texcoord;
            void main()
            {{
                gl_Position = projection * vec4(position, 0.0, 1.0);
                v_texcoord = texcoord;
            }}
        """.format(**args)

        fragment = """
            uniform sampler2D texture;
            varying {tex_t} v_texcoord;
            void main()
            {{
                gl_FragColor = texture2D(texture, {texture2D_arg});
            }}
        """.format(**args)

        self.program = gloo.Program(vertex, fragment)
        if len(colormap.shape) == 2:
            self.program['texture'] = colormap[None, :, :]
        else:
            self.program['texture'] = colormap
        self.program['texture'].interpolation = gl.GL_LINEAR
        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)
        self.program['model'] = self.model
        self.program['view'] = self.view

    def create_mesh(self, x, y, u, v):
        tri = scipy.spatial.Delaunay(np.column_stack([x, y]))
        edges = tri.simplices.astype(np.uint32)
        uv = []
        for c in [u, v]:
            if c is not None:
                c = c.astype('f4')
                c = .5 + .5 * c / np.abs(c).max()
                uv.append(c)
        data = np.column_stack(
            [
                x.astype('f4'),
                y.astype('f4')
            ] + uv
        ).view(dtype=[('position', 'f4', 2),
                      ('texcoord', 'f4', 2 if v is not None else 1),
                      ])
        self.vbo = gloo.VertexBuffer(data)
        self.index = gloo.IndexBuffer(edges)

    def on_initialize(self, event):
        gl.glClearColor(1, 1, 1, 1)
        gl.glDisable(gl.GL_DEPTH_TEST)
        gl.glEnable(gl.GL_BLEND)
        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)

    def on_paint(self, event):
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
        self.program.draw(gl.GL_TRIANGLES, self.index)

    def on_resize(self, event):
        self.resize(*event.size)

    def resize(self, width, height):
        gl.glViewport(0, 0, width, height)
        data_width = self._data_lim[0][1] - self._data_lim[0][0]
        data_height = self._data_lim[1][1] - self._data_lim[1][0]
        data_aspect = data_width / float(data_height)
        frame_aspect = width / float(height)
        if frame_aspect >= data_aspect:
            padding = (frame_aspect * data_height - data_width) / 2.
            frame_lim = [
                [self._data_lim[0][0] - padding,
                 self._data_lim[0][1] + padding],
                [self._data_lim[1][0],
                 self._data_lim[1][1]]]
        else:
            padding = (data_width / frame_aspect - data_height) / 2.
            frame_lim = [
                [self._data_lim[0][0],
                 self._data_lim[0][1]],
                [self._data_lim[1][0] - padding,
                 self._data_lim[1][1] + padding]]
        args_ortho = frame_lim[0][::(1 if self._dir_x_right else -1)]
        args_ortho += frame_lim[1][::(1 if self._dir_y_top else -1)]
        args_ortho += -1000, 1000
        self.program['projection'] = ortho(*args_ortho)


def create_colormap2d_hsv(size=512):
    import matplotlib.colors
    import math
    u, v = np.meshgrid(np.linspace(-1, 1, size), np.linspace(-1, 1, size))
    hsv = np.ones((size, size, 3), dtype=np.float32)
    hsv[:, :, 0] = (np.arctan2(u, v) / (2 * math.pi) + .5)
    hsv[:, :, 1] = np.minimum(1., np.sqrt(u ** 2 + v ** 2))
    rgb = matplotlib.colors.hsv_to_rgb(hsv)
    return rgb


def create_colormap2d_4dirs(size=512):
    rgb = np.ones((size, size, 3), dtype=np.float32)
    hs = size / 2
    u, v = np.meshgrid(np.linspace(1, 0, hs), np.linspace(1, 0, hs))
    rgb[:hs, :hs, 0] = 1.
    rgb[:hs, :hs, 1] = 1. - v + u / 2.
    rgb[:hs, :hs, 2] = 1. - np.maximum(u, v)
    u = u[:, ::-1]
    rgb[:hs, hs:, 0] = 1. - u + v
    rgb[:hs, hs:, 1] = 1. - np.maximum(u, v)
    rgb[:hs, hs:, 2] = 1. - v + u
    v = v[::-1, :]
    rgb[hs:, hs:, 0] = 1. - np.maximum(u, v)
    rgb[hs:, hs:, 1] = 1. - u + v
    rgb[hs:, hs:, 2] = 1. - v + u
    u = u[:, ::-1]
    rgb[hs:, :hs, 0] = 1. - v + u / 2.
    rgb[hs:, :hs, 1] = 1.
    rgb[hs:, :hs, 2] = 1. - np.maximum(u, v)
    rgb = np.minimum(1., rgb)
    return rgb


def create_colormap1d_hot(size=512):
    rgb = np.ones((size, 3), dtype=np.float32)
    hs = size / 2
    u = np.linspace(1, 0, hs)
    rgb[:hs, 0] = 1 - u
    rgb[:hs, 1] = 1 - u
    u = u[::-1]
    rgb[hs:, 1] = 1 - u
    rgb[hs:, 2] = 1 - u
    return rgb

if __name__ == '__main__':
    loc = np.random.random_sample(size=(100, 2))
    np.random.shuffle(loc)
    vec = np.empty_like(loc)
    vec[:, 0] = np.cos(loc[:, 0] * 10)
    vec[:, 1] = np.cos(loc[:, 1] * 13)
    width = 500
    height = 500
    c1 = Unstructured2d(title="Unstructured 2D - 2D colormap",
                        size=(width, height), position=(0, 0),
                        x=loc[:, 0], y=loc[:, 1], u=vec[:, 0], v=vec[:, 1],
                        colormap=create_colormap2d_4dirs(size=128))
    c2 = Unstructured2d(title="Unstructured 2D - 1D colormap",
                        size=(width, height), position=(width + 20, 0),
                        x=loc[:, 0], y=loc[:, 1], u=vec[:, 0],
                        colormap=create_colormap1d_hot(size=128))
    c1.show()
    c2.show()
    app.run()

########NEW FILE########
__FILENAME__ = glsl-sandbox-cube
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
A GLSL sandbox application based on the spinning cube. Requires PySide
or PyQt4.
"""

import numpy as np
from vispy import app, gloo, dataio
from vispy.util.transforms import perspective, translate, rotate

# Force using qt and take QtCore+QtGui from backend module,
# since we do not know whether PySide or PyQt4 is used
app.use('qt')
QtCore = app.default_app.backend_module.QtCore,
QtGui = app.default_app.backend_module.QtGui


VERT_CODE = """
uniform   mat4 u_model;
uniform   mat4 u_view;
uniform   mat4 u_projection;

attribute vec3 a_position;
attribute vec2 a_texcoord;

varying vec2 v_texcoord;

void main()
{
    v_texcoord = a_texcoord;
    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);
    //gl_Position = vec4(a_position,1.0);
}
"""


FRAG_CODE = """
uniform sampler2D u_texture;
varying vec2 v_texcoord;

void main()
{
    float ty = v_texcoord.y;
    float tx = sin(ty*50.0)*0.01 + v_texcoord.x;
    gl_FragColor = texture2D(u_texture, vec2(tx, ty));
    
}
"""


# Read cube data
positions, faces, normals, texcoords = dataio.read_mesh('cube.obj')
colors = np.random.uniform(0, 1, positions.shape).astype('float32')

faces_buffer = gloo.IndexBuffer(faces.astype(np.uint16))


class Canvas(app.Canvas):

    def __init__(self, **kwargs):
        app.Canvas.__init__(self, **kwargs)
        self.geometry = 0, 0, 400, 400

        self.program = gloo.Program(VERT_CODE, FRAG_CODE)

        # Set attributes
        self.program['a_position'] = gloo.VertexBuffer(positions)
        self.program['a_texcoord'] = gloo.VertexBuffer(texcoords)

        self.program['u_texture'] = gloo.Texture2D(dataio.crate())

        # Handle transformations
        self.init_transforms()

        self.timer = app.Timer(1.0 / 60)
        self.timer.connect(self.update_transforms)
        self.timer.start()

    def on_initialize(self, event):
        gloo.set_clear_color((1, 1, 1, 1))
        gloo.set_state(depth_test=True)

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)
        self.projection = perspective(45.0, width / float(height), 2.0, 10.0)
        self.program['u_projection'] = self.projection

    def on_paint(self, event):

        gloo.clear()
        self.program.draw('triangles', faces_buffer)

    def init_transforms(self):
        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)

        self.theta = 0
        self.phi = 0

        translate(self.view, 0, 0, -5)
        self.program['u_model'] = self.model
        self.program['u_view'] = self.view

    def update_transforms(self, event):
        self.theta += .5
        self.phi += .5
        self.model = np.eye(4, dtype=np.float32)
        rotate(self.model, self.theta, 0, 0, 1)
        rotate(self.model, self.phi, 0, 1, 0)
        self.program['u_model'] = self.model
        self.update()


class TextField(QtGui.QPlainTextEdit):

    def __init__(self, parent):
        QtGui.QPlainTextEdit.__init__(self, parent)
        # Set font to monospaced (TypeWriter)
        font = QtGui.QFont('')
        font.setStyleHint(font.TypeWriter, font.PreferDefault)
        font.setPointSize(8)
        self.setFont(font)


class MainWindow(QtGui.QWidget):

    def __init__(self):
        QtGui.QWidget.__init__(self, None)

        self.setMinimumSize(600, 400)

        # Create two labels and a button
        self.vertLabel = QtGui.QLabel("Vertex code", self)
        self.fragLabel = QtGui.QLabel("Fragment code", self)
        self.theButton = QtGui.QPushButton("Compile!", self)
        self.theButton.clicked.connect(self.on_compile)

        # Create two editors
        self.vertEdit = TextField(self)
        self.vertEdit.setPlainText(VERT_CODE)
        self.fragEdit = TextField(self)
        self.fragEdit.setPlainText(FRAG_CODE)

        # Create a canvas
        self.canvas = Canvas()
        self.canvas.create_native()
        self.canvas.native.setParent(self)

        # Layout
        hlayout = QtGui.QHBoxLayout(self)
        self.setLayout(hlayout)
        vlayout = QtGui.QVBoxLayout()
        #
        hlayout.addLayout(vlayout, 1)
        hlayout.addWidget(self.canvas.native, 1)
        #
        vlayout.addWidget(self.vertLabel, 0)
        vlayout.addWidget(self.vertEdit, 1)
        vlayout.addWidget(self.fragLabel, 0)
        vlayout.addWidget(self.fragEdit, 1)
        vlayout.addWidget(self.theButton, 0)

    def on_compile(self):
        vert_code = str(self.vertEdit.toPlainText())
        frag_code = str(self.fragEdit.toPlainText())
        self.canvas.program.shaders[0].code = vert_code
        self.canvas.program.shaders[1].code = frag_code


if __name__ == '__main__':
    app.create()
    m = MainWindow()
    m.show()
    app.run()

########NEW FILE########
__FILENAME__ = animate-images
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 2
"""
Example demonstrating showing a, image with a fixed ratio.
"""

import numpy as np

from vispy.util.transforms import ortho
from vispy import gloo
from vispy import app
from vispy.gloo import gl


# Image to be displayed
W, H = 64, 48
I = np.random.uniform(0, 1, (W, H)).astype(np.float32)

# A simple texture quad
data = np.zeros(4, dtype=[('a_position', np.float32, 2),
                          ('a_texcoord', np.float32, 2)])
data['a_position'] = np.array([[0, 0], [W, 0], [0, H], [W, H]])
data['a_texcoord'] = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])


VERT_SHADER = """
// Uniforms
uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
uniform float u_antialias;

// Attributes
attribute vec2 a_position;
attribute vec2 a_texcoord;

// Varyings
varying vec2 v_texcoord;

// Main
void main (void)
{
    v_texcoord = a_texcoord;
    gl_Position = u_projection * u_view * u_model * vec4(a_position,0.0,1.0);
}
"""

FRAG_SHADER = """
uniform sampler2D u_texture;
varying vec2 v_texcoord;
void main()
{
    gl_FragColor = texture2D(u_texture, v_texcoord);
    gl_FragColor.a = 1.0;
}

"""


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')
        self.size = W * 5, H * 5

        self.program = gloo.Program(VERT_SHADER, FRAG_SHADER)
        self.texture = gloo.Texture2D(I)
        self.texture.interpolation = gl.GL_LINEAR

        self.program['u_texture'] = self.texture
        self.program.bind(gloo.VertexBuffer(data))

        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)

        self.program['u_model'] = self.model
        self.program['u_view'] = self.view
        self.projection = ortho(0, W, 0, H, -1, 1)
        self.program['u_projection'] = self.projection

    def on_initialize(self, event):
        gl.glClearColor(1, 1, 1, 1)

    def on_resize(self, event):
        width, height = event.size
        gl.glViewport(0, 0, width, height)
        self.projection = ortho(0, width, 0, height, -100, 100)
        self.program['u_projection'] = self.projection

        # Compute thje new size of the quad
        r = width / float(height)
        R = W / float(H)
        if r < R:
            w, h = width, width / R
            x, y = 0, int((height - h) / 2)
        else:
            w, h = height * R, height
            x, y = int((width - w) / 2), 0
        data['a_position'] = np.array(
            [[x, y], [x + w, y], [x, y + h], [x + w, y + h]])
        self.program.bind(gloo.VertexBuffer(data))

    def on_paint(self, event):
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
        I[...] = np.random.uniform(0, 1, (W, H)).astype(np.float32)
        self.texture.set_data(I)
        self.program.draw(gl.GL_TRIANGLE_STRIP)
        self.update()


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = animate-shape
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 3

"""
Example demonstrating showing a quad. Like hello_quad1.py, but now
with Texture2D and VertexBuffer, and optionally using an ElementBuffer to
draw the vertices.
"""

import time
import numpy as np

from vispy import gloo
from vispy import app


# Create a texture
im1 = np.zeros((100, 100, 3), 'float32')
im1[:50, :, 0] = 1.0
im1[:, :50, 1] = 1.0
im1[50:, 50:, 2] = 1.0

# Create vetices and texture coords, combined in one array for high performance
vertex_data = np.zeros(4, dtype=[('a_position', np.float32, 3),
                                 ('a_texcoord', np.float32, 2)])
vertex_data['a_position'] = np.array([[-0.8, -0.8, 0.0], [+0.7, -0.7, 0.0],
                                      [-0.7, +0.7, 0.0], [+0.8, +0.8, 0.0, ]])
vertex_data['a_texcoord'] = np.array([[0.0, 0.0], [0.0, 1.0],
                                      [1.0, 0.0], [1.0, 1.0]])

# Create indices and an ElementBuffer for it
indices = np.array([0, 1, 2, 1, 2, 3], np.uint16)
indices_buffer = gloo.IndexBuffer(indices)
client_indices_buffer = gloo.IndexBuffer(indices, client=True)


VERT_SHADER = """ // simple vertex shader

attribute vec3 a_position;
attribute vec2 a_texcoord;
uniform float sizeFactor;
//attribute float sizeFactor;

void main (void) {
    // Pass tex coords
    gl_TexCoord[0] = vec4(a_texcoord.x, a_texcoord.y, 0.0, 0.0);
    // Calculate position
    gl_Position = sizeFactor*vec4(a_position.x, a_position.y, a_position.z,
                                                        1.0/sizeFactor);
}
"""

FRAG_SHADER = """ // simple fragment shader
uniform sampler2D texture1;

void main()
{
    gl_FragColor = texture2D(texture1, gl_TexCoord[0].st);
}

"""


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')

        # Create program
        self._program = gloo.Program(VERT_SHADER, FRAG_SHADER)

        # Create vertex buffer
        self._vbo = gloo.VertexBuffer(vertex_data)

        # Set uniforms, samplers, attributes
        # We create one VBO with all vertex data (array of structures)
        # and create two views from it for the attributes.
        self._program['texture1'] = gloo.Texture2D(im1)
        self._program.bind(self._vbo)  # This does:
        #self._program['a_position'] = self._vbo['a_position']
        #self._program['a_texcoords'] = self._vbo['a_texcoords']

    def on_initialize(self, event):
        gloo.set_clear_color((1, 1, 1, 1))

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)

    def on_paint(self, event):

        # Clear
        gloo.clear()

        # Draw
        self._program['sizeFactor'] = 0.5 + np.sin(time.time() * 3) * 0.2

        # Draw (pick one!)
        # self._program.draw(gl.GL_TRIANGLE_STRIP)
        self._program.draw('triangles', indices_buffer)
        # self._program.draw(gl.GL_TRIANGLES, client_indices_buffer)  # Not
        # recommended

        self.update()


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = client-buffers
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# This code of this example should be considered public domain.

"""
This is the boids demo coded using a client buffer. This means that
the data is *not* stored on the GPU in a vertex buffer object, but
instead send to the GPU on each draw.

Note that in general you should avoid client buffers and use
vertex buffers. This is example just demonstrates the technique.

In this particular example the attribute data is updated on each draw,
so the performance of both methods should be more or less similar.

The main difference is that one should use the ``client=True`` keyword
argument when creating a VertexBuffer or ElementBuffer.

"""

import time
import numpy as np
from scipy.spatial import cKDTree

from vispy.gloo import gl
from vispy import app
from vispy.gloo import Program, VertexBuffer


# Create boids
n = 1000
particles = np.zeros(2 + n, [('position', 'f4', 3),
                             ('position_1', 'f4', 3),
                             ('position_2', 'f4', 3),
                             ('velocity', 'f4', 3),
                             ('color', 'f4', 4),
                             ('size', 'f4', 1)])
boids = particles[2:]
target = particles[0]
predator = particles[1]

boids['position'] = np.random.uniform(-0.25, +0.25, (n, 3))
boids['velocity'] = np.random.uniform(-0.00, +0.00, (n, 3))
boids['size'] = 4
boids['color'] = 1, 1, 1, 1

target['size'] = 16
target['color'][:] = 1, 1, 0, 1
predator['size'] = 16
predator['color'][:] = 1, 0, 0, 1


VERT_SHADER = """
attribute vec3 position;
attribute vec4 color;
attribute float size;

varying vec4 v_color;
void main (void) {
    gl_Position = vec4(position, 1.0);
    v_color = color;
    gl_PointSize = size;
}
"""

FRAG_SHADER = """
varying vec4 v_color;
void main()
{
    float x = 2.0*gl_PointCoord.x - 1.0;
    float y = 2.0*gl_PointCoord.y - 1.0;
    float a = 1.0 - (x*x + y*y);
    gl_FragColor = vec4(v_color.rgb, a*v_color.a);
}

"""


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')

        # Time
        self._t = time.time()
        self._pos = 0.0, 0.0
        self._button = None

        # Create program
        self.program = Program(VERT_SHADER, FRAG_SHADER)
        self.program['color'] = VertexBuffer(particles['color'], client=True)
        self.program['size'] = VertexBuffer(particles['size'], client=True)

    def on_initialize(self, event):
        gl.glClearColor(0, 0, 0, 1)

        gl.glEnable(gl.GL_BLEND)
        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE)

    def on_resize(self, event):
        width, height = event.size
        gl.glViewport(0, 0, width, height)

    def on_mouse_press(self, event):
        self._button = event.button
        self.on_mouse_move(event)

    def on_mouse_release(self, event):
        self._button = None
        self.on_mouse_move(event)

    def on_mouse_move(self, event):
        if not self._button:
            return
        w, h = self.size
        x, y = event.pos
        sx = 2 * x / float(w) - 1.0
        sy = - (2 * y / float(h) - 1.0)

        if self._button == 1:
            target['position'][:] = sx, sy, 0
        elif self._button == 2:
            predator['position'][:] = sx, sy, 0

    def on_paint(self, event):
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

        # Draw
        self.program['position'] = VertexBuffer(
            particles['position'],
            client=True)
        self.program.draw(gl.GL_POINTS)

        # Next iteration
        self._t = self.iteration(time.time() - self._t)

        # Invoke a new draw
        self.update()

    def iteration(self, dt):
        t = self._t

        t += 0.5 * dt
        #target[...] = np.array([np.sin(t),np.sin(2*t),np.cos(3*t)])*.1

        t += 0.5 * dt
        #predator[...] = np.array([np.sin(t),np.sin(2*t),np.cos(3*t)])*.2

        boids['position_2'] = boids['position_1']
        boids['position_1'] = boids['position']
        n = len(boids)
        P = boids['position']
        V = boids['velocity']

        # Cohesion: steer to move toward the average position of local
        # flockmates
        C = -(P - P.sum(axis=0) / n)

        # Alignment: steer towards the average heading of local flockmates
        A = -(V - V.sum(axis=0) / n)

        # Repulsion: steer to avoid crowding local flockmates
        D, I = cKDTree(P).query(P, 5)
        M = np.repeat(D < 0.05, 3, axis=1).reshape(n, 5, 3)
        Z = np.repeat(P, 5, axis=0).reshape(n, 5, 3)
        R = -((P[I] - Z) * M).sum(axis=1)

        # Target : Follow target
        T = target['position'] - P

        # Predator : Move away from predator
        dP = P - predator['position']
        D = np.maximum(0, 0.3 -
                       np.sqrt(dP[:, 0] ** 2 +
                               dP[:, 1] ** 2 +
                               dP[:, 2] ** 2))
        D = np.repeat(D, 3, axis=0).reshape(n, 3)
        dP *= D

        #boids['velocity'] += 0.0005*C + 0.01*A + 0.01*R + 0.0005*T + 0.0025*dP
        boids['velocity'] += 0.0005 * C + 0.01 * \
            A + 0.01 * R + 0.0005 * T + 0.025 * dP
        boids['position'] += boids['velocity']

        return t


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = display-lines
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 2

""" Show a bunch of lines.
This example demonstrates how multiple line-pieces can be drawn
using one call, by discarting some fragments.
"""

import numpy as np
from vispy import gloo
from vispy import app
from vispy.util.transforms import perspective, translate, rotate

# app.use('glut')

# Create vetices
n = 100
a_position = np.random.uniform(-1, 1, (n, 3)).astype(np.float32)
a_id = np.random.randint(0, 30, (n, 1))
a_id = np.sort(a_id, axis=0).astype(np.float32)


VERT_SHADER = """
uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
attribute vec3 a_position;
attribute float a_id;
varying float v_id;
void main (void) {
    v_id = a_id;
    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);
}
"""

FRAG_SHADER = """
varying float v_id;
void main()
{
    float f = fract(v_id);
    // The second useless test is needed on OSX 10.8 (fuck)
    if( (f > 0.0001) && (f < .9999f) )
        discard;
    else
        gl_FragColor = vec4(0,0,0,1);
}
"""


class Canvas(app.Canvas):

    # ---------------------------------
    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')

        self.program = gloo.Program(VERT_SHADER, FRAG_SHADER)

        # Set uniform and attribute
        self.program['a_id'] = gloo.VertexBuffer(a_id)
        self.program['a_position'] = gloo.VertexBuffer(a_position)

        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)

        self.translate = 5
        translate(self.view, 0, 0, -self.translate)
        self.program['u_model'] = self.model
        self.program['u_view'] = self.view

        self.theta = 0
        self.phi = 0

        self.timer = app.Timer(1.0 / 60)
        self.timer.connect(self.on_timer)
        # self.timer.start()

    # ---------------------------------
    def on_initialize(self, event):
        gloo.set_clear_color((1, 1, 1, 1))
        gloo.set_state('translucent')

    # ---------------------------------
    def on_key_press(self, event):
        if event.text == ' ':
            if self.timer.running:
                self.timer.stop()
            else:
                self.timer.start()

    # ---------------------------------
    def on_timer(self, event):
        self.theta += .5
        self.phi += .5
        self.model = np.eye(4, dtype=np.float32)
        rotate(self.model, self.theta, 0, 0, 1)
        rotate(self.model, self.phi, 0, 1, 0)
        self.program['u_model'] = self.model
        self.update()

    # ---------------------------------
    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)
        self.projection = perspective(45.0, width / float(height), 1.0, 1000.0)
        self.program['u_projection'] = self.projection

    # ---------------------------------
    def on_mouse_wheel(self, event):
        self.translate += event.delta[1]
        self.translate = max(2, self.translate)
        self.view = np.eye(4, dtype=np.float32)
        translate(self.view, 0, 0, -self.translate)
        self.program['u_view'] = self.view
        self.update()

    # ---------------------------------
    def on_paint(self, event):
        gloo.clear()
        self.program.draw('line_strip')


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = display-points
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 2

""" Simple example plotting 2D points.
"""

from vispy import gloo
from vispy import app
from vispy.gloo import gl
import numpy as np

# Create vetices
n = 10000
v_position = 0.25 * np.random.randn(n, 2).astype(np.float32)
v_color = np.random.uniform(0, 1, (n, 3)).astype(np.float32)
v_size = np.random.uniform(2, 12, (n, 1)).astype(np.float32)

VERT_SHADER = """
attribute vec3  a_position;
attribute vec3  a_color;
attribute float a_size;

varying vec4 v_fg_color;
varying vec4 v_bg_color;
varying float v_radius;
varying float v_linewidth;
varying float v_antialias;

void main (void) {
    v_radius = a_size;
    v_linewidth = 1.0;
    v_antialias = 1.0;
    v_fg_color  = vec4(0.0,0.0,0.0,0.5);
    v_bg_color  = vec4(a_color,    1.0);

    gl_Position = vec4(a_position, 1.0);
    gl_PointSize = 2.0*(v_radius + v_linewidth + 1.5*v_antialias);
}
"""

FRAG_SHADER = """
#version 120

varying vec4 v_fg_color;
varying vec4 v_bg_color;
varying float v_radius;
varying float v_linewidth;
varying float v_antialias;
void main()
{
    float size = 2.0*(v_radius + v_linewidth + 1.5*v_antialias);
    float t = v_linewidth/2.0-v_antialias;
    float r = length((gl_PointCoord.xy - vec2(0.5,0.5))*size);
    float d = abs(r - v_radius) - t;
    if( d < 0.0 )
        gl_FragColor = v_fg_color;
    else
    {
        float alpha = d/v_antialias;
        alpha = exp(-alpha*alpha);
        if (r > v_radius)
            gl_FragColor = vec4(v_fg_color.rgb, alpha*v_fg_color.a);
        else
            gl_FragColor = mix(v_bg_color, v_fg_color, alpha);
    }
}
"""


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')

        self.program = gloo.Program(VERT_SHADER, FRAG_SHADER)

        # Set uniform and attribute
        self.program['a_color'] = gloo.VertexBuffer(v_color)
        self.program['a_position'] = gloo.VertexBuffer(v_position)
        self.program['a_size'] = gloo.VertexBuffer(v_size)

    def on_initialize(self, event):
        gl.glClearColor(1, 1, 1, 1)

        gl.glEnable(gl.GL_BLEND)
        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)

    def on_resize(self, event):
        width, height = event.size
        gl.glViewport(0, 0, width, height)

    def on_paint(self, event):
        # Clear
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
        # Draw
        self.program.draw(gl.GL_POINTS)


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = display-shape
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 2

"""
Simple example demonstrating showing a quad.
gloo objects that this example demonstrates: Program.
"""

from vispy import gloo
from vispy import app
import numpy as np

# Create vetices
vPosition = np.array([[-0.8, -0.8, 0.0], [+0.7, -0.7, 0.0],
                      [-0.7, +0.7, 0.0], [+0.8, +0.8, 0.0, ]], np.float32)


VERT_SHADER = """ // simple vertex shader
attribute vec3 a_position;
void main (void) {
    gl_Position = vec4(a_position, 1.0);
}
"""

FRAG_SHADER = """ // simple fragment shader
uniform vec4 u_color;
void main()
{
    gl_FragColor = u_color;
}
"""


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')

        # Create program
        self._program = gloo.Program(VERT_SHADER, FRAG_SHADER)

        # Set uniform and attribute
        self._program['u_color'] = 0.2, 1.0, 0.4, 1
        self._program['a_position'] = gloo.VertexBuffer(vPosition)

    def on_initialize(self, event):
        gloo.set_clear_color((1, 1, 1, 1))

    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)

    def on_paint(self, event):
        gloo.clear()
        self._program.draw('triangle_strip')


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = hello-fbo
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 3

"""
Minimal example demonstrating the use of frame buffer objects (FBO).
This example blurs the output image.
"""


from vispy import gloo
from vispy import app
from vispy.gloo import gl
import numpy as np

# Create vetices
vPosition = np.array([[-0.8, -0.8, 0.0], [+0.7, -0.7, 0.0],
                      [-0.7, +0.7, 0.0], [+0.8, +0.8, 0.0, ]], np.float32)
vPosition_full = np.array([[-1.0, -1.0, 0.0], [+1.0, -1.0, 0.0],
                           [-1.0, +1.0, 0.0], [+1.0, +1.0, 0.0, ]], np.float32)
vTexcoord = np.array([[0.0, 0.0], [0.0, 1.0],
                      [1.0, 0.0], [1.0, 1.0]], np.float32)

# For initial quad
VERT_SHADER1 = """
attribute vec3 a_position;
void main (void) {
    gl_Position = vec4(a_position, 1.0);
}
"""

FRAG_SHADER1 = """
uniform vec4 u_color;
void main()
{
    gl_FragColor = u_color;
}
"""

# To render the result of the FBO
VERT_SHADER2 = """
attribute vec3 a_position;
attribute vec2 a_texcoord;
varying vec2 v_texcoord;
void main (void) {
    // Pass tex coords
    v_texcoord = a_texcoord;
    // Calculate position
    gl_Position = vec4(a_position.x, a_position.y, a_position.z, 1.0);
}
"""

FRAG_SHADER2 = """
uniform sampler2D u_texture1;
varying vec2 v_texcoord;
const float c_zero = 0.0;
const int c_sze = 5;
void main()
{
    float scalefactor = 1.0 / (c_sze * c_sze * 4 + 1);
    gl_FragColor = vec4(c_zero, c_zero, c_zero, 1.0);
    for (int y=-c_sze; y<=c_sze; y++) {
        for (int x=-c_sze; x<=c_sze; x++) {
            vec2 step = vec2(x,y) * 0.01;
            vec3 color = texture2D(u_texture1, v_texcoord.st+step).rgb;
            gl_FragColor.rgb += color * scalefactor;
        }
    }
}
"""


SIZE = 50


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')
        self.size = 560, 420

        # Create texture to render to
        self._rendertex = gloo.Texture2D()

        # Create FBO, attach the color buffer and depth buffer
        self._fbo = gloo.FrameBuffer(self._rendertex, gloo.RenderBuffer())

        # Create program to render a shape
        self._program1 = gloo.Program(gloo.VertexShader(VERT_SHADER1),
                                      gloo.FragmentShader(FRAG_SHADER1))
        self._program1['u_color'] = 0.9, 1.0, 0.4, 1
        self._program1['a_position'] = gloo.VertexBuffer(vPosition)

        # Create program to render FBO result
        self._program2 = gloo.Program(gloo.VertexShader(VERT_SHADER2),
                                      gloo.FragmentShader(FRAG_SHADER2))
        self._program2['a_position'] = gloo.VertexBuffer(vPosition)
        self._program2['a_texcoord'] = gloo.VertexBuffer(vTexcoord)
        self._program2['u_texture1'] = self._rendertex

    def on_resize(self, event):
        width, height = event.size
        gl.glViewport(0, 0, width, height)

    def on_paint(self, event):

        # Set geometry (is no-op if the size does not change)
        self._fbo.set_size(*self.size)

        # Draw the same scene as as in hello_quad.py, but draw it to the FBO
        with self._fbo:
            # Init
            gl.glClearColor(0, 0.0, 0.5, 1)
            gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
            # Draw
            self._program1.draw(gl.GL_TRIANGLE_STRIP)

        # Now draw result to a full-screen quad
        # Init
        gl.glClearColor(1, 1, 1, 1)
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
        # Draw
        self._program2.draw(gl.GL_TRIANGLE_STRIP)


if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = rotate-cube
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 50
"""
This example shows how to display 3D objects.
You should see a colored outlined spinning cube.
"""

import numpy as np
from vispy import app, gloo
from vispy.util.transforms import perspective, translate, rotate


vert = """
// Uniforms
// ------------------------------------
uniform   mat4 u_model;
uniform   mat4 u_view;
uniform   mat4 u_projection;
uniform   vec4 u_color;

// Attributes
// ------------------------------------
attribute vec3 a_position;
attribute vec4 a_color;

// Varying
// ------------------------------------
varying vec4 v_color;

void main()
{
    v_color = a_color * u_color;
    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);
}
"""


frag = """
// Varying
// ------------------------------------
varying vec4 v_color;

void main()
{
    gl_FragColor = v_color;
}
"""


# -----------------------------------------------------------------------------
def cube():
    """
    Build vertices for a colored cube.

    V  is the vertices
    I1 is the indices for a filled cube (use with GL_TRIANGLES)
    I2 is the indices for an outline cube (use with GL_LINES)
    """
    vtype = [('a_position', np.float32, 3),
             ('a_normal', np.float32, 3),
             ('a_color', np.float32, 4)]
    # Vertices positions
    v = [[1, 1, 1], [-1, 1, 1], [-1, -1, 1], [1, -1, 1],
         [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, -1]]
    # Face Normals
    n = [[0, 0, 1], [1, 0, 0], [0, 1, 0],
         [-1, 0, 1], [0, -1, 0], [0, 0, -1]]
    # Vertice colors
    c = [[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 1, 0, 1],
         [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 0, 1]]

    V = np.array([(v[0], n[0], c[0]), (v[1], n[0], c[1]),
                  (v[2], n[0], c[2]), (v[3], n[0], c[3]),
                  (v[0], n[1], c[0]), (v[3], n[1], c[3]),
                  (v[4], n[1], c[4]), (v[5], n[1], c[5]),
                  (v[0], n[2], c[0]), (v[5], n[2], c[5]),
                  (v[6], n[2], c[6]), (v[1], n[2], c[1]),
                  (v[1], n[3], c[1]), (v[6], n[3], c[6]),
                  (v[7], n[3], c[7]), (v[2], n[3], c[2]),
                  (v[7], n[4], c[7]), (v[4], n[4], c[4]),
                  (v[3], n[4], c[3]), (v[2], n[4], c[2]),
                  (v[4], n[5], c[4]), (v[7], n[5], c[7]),
                  (v[6], n[5], c[6]), (v[5], n[5], c[5])],
                 dtype=vtype)
    I1 = np.resize(np.array([0, 1, 2, 0, 2, 3], dtype=np.uint32), 6 * (2 * 3))
    I1 += np.repeat(4 * np.arange(2 * 3), 6)

    I2 = np.resize(
        np.array([0, 1, 1, 2, 2, 3, 3, 0], dtype=np.uint32), 6 * (2 * 4))
    I2 += np.repeat(4 * np.arange(6), 8)

    return V, I1, I2


# -----------------------------------------------------------------------------
class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')
        self.size = 800, 600

        self.vertices, self.filled, self.outline = cube()
        self.filled_buf = gloo.IndexBuffer(self.filled)
        self.outline_buf = gloo.IndexBuffer(self.outline)

        self.program = gloo.Program(vert, frag)
        self.program.bind(gloo.VertexBuffer(self.vertices))

        self.view = np.eye(4, dtype=np.float32)
        self.model = np.eye(4, dtype=np.float32)
        self.projection = np.eye(4, dtype=np.float32)

        translate(self.view, 0, 0, -5)
        self.program['u_model'] = self.model
        self.program['u_view'] = self.view

        self.theta = 0
        self.phi = 0

        self._timer = app.Timer(1.0 / 60)
        self._timer.connect(self.on_timer)
        self._timer.start()

    # ---------------------------------
    def on_initialize(self, event):
        gloo.set_clear_color((1, 1, 1, 1))
        gloo.set_state('opaque')
        gloo.set_polygon_offset(1, 1)
        # gl.glEnable( gl.GL_LINE_SMOOTH )

    # ---------------------------------
    def on_timer(self, event):
        self.theta += .5
        self.phi += .5
        self.model = np.eye(4, dtype=np.float32)
        rotate(self.model, self.theta, 0, 0, 1)
        rotate(self.model, self.phi, 0, 1, 0)
        self.program['u_model'] = self.model
        self.update()

    # ---------------------------------
    def on_resize(self, event):
        width, height = event.size
        gloo.set_viewport(0, 0, width, height)
        self.projection = perspective(45.0, width / float(height), 2.0, 10.0)
        self.program['u_projection'] = self.projection

    # ---------------------------------
    def on_paint(self, event):
        gloo.clear()

        # Filled cube
        
        gloo.set_state(blend=False, depth_test=True, polygon_offset_fill=True)
        self.program['u_color'] = 1, 1, 1, 1
        self.program.draw('triangles', self.filled_buf)

        # Outline
        gloo.set_state(blend=True, depth_test=True, polygon_offset_fill=False)
        gloo.set_depth_mask(False)
        self.program['u_color'] = 0, 0, 0, 1
        self.program.draw('lines', self.outline_buf)
        gloo.set_depth_mask(True)


# -----------------------------------------------------------------------------
if __name__ == '__main__':
    c = Canvas()
    c.show()
    app.run()

########NEW FILE########
__FILENAME__ = split-screen
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 2

""" Example demonstrating two viewports in one window, and how one can
propagate events to the viewports. Note that stuff like this will be
part of the future higher lever visuals layer.
"""

import numpy as np
from vispy import app, gloo
from vispy.gloo import gl
from vispy.util.event import EmitterGroup


VERT_SHADER = """
attribute vec3 a_position;
uniform float u_size;
uniform vec4 u_color;

varying vec4 v_color;
void main (void) {
    gl_Position = vec4(a_position, 1.0);
    v_color = u_color;
    gl_PointSize = u_size;
}
"""

FRAG_SHADER = """
varying vec4 v_color;
void main()
{
    float x = 2.0*gl_PointCoord.x - 1.0;
    float y = 2.0*gl_PointCoord.y - 1.0;
    float a = 1.0 - (x*x + y*y);
    gl_FragColor = vec4(v_color.rgb, a*v_color.a);
}

"""


class ViewPort(object):

    """ Represents a rectangular region on the screen.
    Resize and mouse events are propagated to here, as well
    as the paint event.
    """

    def __init__(self, bgcolor):
        self._bgcolor = bgcolor
        self.events = EmitterGroup(source=self,
                                   resize=app.canvas.ResizeEvent,
                                   mouse_press=app.canvas.MouseEvent,
                                   mouse_release=app.canvas.MouseEvent,
                                   mouse_move=app.canvas.MouseEvent,
                                   mouse_wheel=app.canvas.MouseEvent,
                                   )

        # Create program
        self.program = gloo.Program(VERT_SHADER, FRAG_SHADER)
        self.program['u_size'] = 20.0
        self.program['u_color'] = bgcolor

        # Create position
        self.vbo = gloo.VertexBuffer(('', 'float32', 3))
        self.program['a_position'] = self.vbo

        # Init
        self._pos = 25, 25
        self._size = 1, 1

    def on_mouse_move(self, event):
        self._pos = event.pos

    def on_mouse_press(self, event):
        self.program['u_size'] = 30.0

    def on_mouse_release(self, event):
        self.program['u_size'] = 20.0

    def on_resize(self, event):
        self._size = event.size

    def on_paint(self):
        x = 2.0 * self._pos[0] / self._size[0] - 1.0
        y = 2.0 * self._pos[1] / self._size[1] - 1.0
        data = np.array([[x, -y, 0]], np.float32)
        self.vbo.set_data(data)
        self.program.draw(gl.GL_POINTS)


class Canvas(app.Canvas):

    def __init__(self):
        app.Canvas.__init__(self, close_keys='escape')
        self.size = 400, 200
        self.left = ViewPort((1.0, 0.5, 0.5, 1.0))
        self.right = ViewPort((0.5, 1.0, 0.5, 1.0))

    def on_initialize(self, event):
        gl.glClearColor(0, 0, 0, 1)
        gl.glEnable(gl.GL_BLEND)
        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE)

    def on_paint(self, event):
        # Paint events are "manually" propagated to the viewport instances,
        # because we first want to set the glViewport for each one.

        # Prepare
        gl.glClear(gl.GL_COLOR_BUFFER_BIT)
        w1 = self.size[0] // 2
        w2 = self.size[0] - w1
        # Left
        gl.glViewport(0, 0, w1, self.size[1])
        self.left.on_paint()
        # Right
        gl.glViewport(w1, 0, w2, self.size[1])
        self.right.on_paint()

        # Invoke new draw
        self.update()

    def on_resize(self, event):
        w1 = event.size[0] // 2
        w2 = event.size[0] - w1
        h = event.size[1]
        self.left.events.resize(size=(w1, h))
        self.right.events.resize(size=(w2, h))

    def on_mouse_press(self, event):
        viewport, pos = self._get_viewport(event.pos)
        self._re_emit_mouse_event(viewport.events.mouse_press, pos, event)

    def on_mouse_release(self, event):
        viewport, pos = self._get_viewport(event.pos)
        self._re_emit_mouse_event(viewport.events.mouse_release, pos, event)

    def on_mouse_move(self, event):
        viewport, pos = self._get_viewport(event.pos)
        self._re_emit_mouse_event(viewport.events.mouse_move, pos, event)

    def on_mouse_wheel(self, event):
        viewport, pos = self._get_viewport(event.pos)
        self._re_emit_mouse_event(viewport.events.mouse_wheel, pos, event)

    def _get_viewport(self, pos):
        """ Based on a given position, get the viewport and the pos
        relative to that viewport.
        """
        halfwidth = self.size[0] // 2
        if pos[0] < halfwidth:
            viewport = self.left
            pos = pos
        else:
            viewport = self.right
            pos = pos[0] - halfwidth, pos[1]
        return viewport, pos

    def _re_emit_mouse_event(self, emitter, pos, event):
        emitter(pos=pos, button=event.button, modifiers=event.modifiers,
                delta=event.delta)


if __name__ == '__main__':
    canvas = Canvas()
    canvas.show()
    app.run()

########NEW FILE########
__FILENAME__ = start
# !/usr/bin/env python
# -*- coding: utf-8 -*-
""" Probably the simplest vispy example
"""

from vispy import app
from vispy import gloo

c = app.Canvas(show=True, close_keys='escape')


@c.connect
def on_paint(event):
    gloo.set_clear_color((0.2, 0.4, 0.6, 1.0))
    gloo.clear()

if __name__ == '__main__':
    app.run()

########NEW FILE########
__FILENAME__ = hex-grid
#! /usr/bin/env python
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Nicolas P. Rougier. All rights reserved.
# Distributed under the terms of the new BSD License.
# -----------------------------------------------------------------------------
import sys
import OpenGL.GL as gl
import OpenGL.GLUT as glut

from vispy.gloo import Program

vertex = """
    attribute vec2 a_texcoord;
    attribute vec2 a_position;
    varying vec2 v_texcoord;
    void main()
    {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texcoord = a_texcoord;
    } """

fragment = """
    uniform vec2  u_size;
    uniform vec2  u_translate;
    uniform float u_scale;
    uniform vec4  u_grid_color;
    uniform float u_grid_thickness;
    uniform float u_grid_antialias;

    varying vec2 v_texcoord;

    float
    distance_to_line(vec2 P1, vec2 P2, vec2 P3)
    {
        float u = (P3.x-P1.x)*(P2.x-P1.x) + (P3.y-P1.y)*(P2.y - P1.y);
        u /= (P2.x-P1.x)*(P2.x-P1.x) + (P2.y-P1.y)*(P2.y-P1.y);
        vec2 P = P1 + u*(P2-P1);
        return sqrt( (P.x-P3.x)*(P.x-P3.x) +(P.y-P3.y)*(P.y-P3.y) );
    }

    void main()
    {
        float R = 16.0*u_scale;
        float S = 1.5*R;
        float W = 2.0*R;
        float H = sqrt(3.0)*R;

        float i,j;
        float x = v_texcoord.x * u_size.x - u_translate.x;
        float y = v_texcoord.y * u_size.y - u_translate.y;

        i = floor(x/S);
        j = floor((y - mod(i,2.0)*H/2.0)/H );
        float cy0 = j*H + H/2. *(1.0 + mod(i,2.0));
        float cx0 = i*S + W/2.;

        i = floor(x/S) - 1.;
        j = floor((y - mod(i,2.0)*H/2.0)/H );
        float cy1 = j*H + H/2. *(1.0 + mod(i,2.0));
        float cx1 = i*S + W/2.;

        float t = u_grid_thickness/2.0-u_grid_antialias;
        float radius = R*.85;

        float X = abs(x-cx0);
        float Y = abs(y-cy0);
        float d0 = abs(Y-H/2.);
        float d1 = distance_to_line(
               vec2(W/4.,H/2.), vec2(W/2., 0.0), vec2(X,Y));
        if (X > (W-S))
        {
            d0=2.*d1;
        }


        float temp=y; y=x; x=temp;
        x = (x - H/2.) / H;
        float t1 = y / R;
        float t2 = floor(x + t1);
        float r = floor((floor(t1 - x) + t2) / 3.);
        float q = floor((floor(2. * x + 1.) + t2) / 3.) - r;
        r = floor(r);
        q = floor(q);
        vec4 color = vec4(min(q/10.0,1.0), min(r/10.0,1.0), 0.0, 1.0);

        float d = min(d0,d1)-t;
        if( d < 0.0 )
        {
            gl_FragColor = u_grid_color;
        }
        else
        {
            float alpha = d/u_grid_antialias;
            alpha = exp(-alpha*alpha);
            gl_FragColor = vec4(u_grid_color.rgb, alpha) + (1.-alpha)*color;
            // gl_FragColor = vec4(u_grid_color.rgb, alpha);
        }

    } """


def display():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    program.draw(gl.GL_TRIANGLE_STRIP)
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)
    program['u_size'] = width, height


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def on_motion(x, y):
    global mouse, translate, scale
    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)
    y = h - y
    dx, dy = x - mouse[0], y - mouse[1]
    translate = [translate[0] + dx, translate[1] + dy]
    mouse = x, y
    program['u_translate'] = translate
    glut.glutPostRedisplay()


def on_passive_motion(x, y):
    global mouse
    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)
    mouse = x, h - y


def on_scroll(dx, dy):
    global mouse, translate, scale
    x, y = mouse
    s = min(max(0.25, scale + .001 * dy * scale), 200)
    translate[0] = x - s * (x - translate[0]) / scale
    translate[1] = y - s * (y - translate[1]) / scale
    translate = [translate[0], translate[1]]
    scale = s
    program['u_translate'] = translate
    program['u_scale'] = scale
    glut.glutPostRedisplay()


def on_mouse(button, state, x, y):
    if button == 3:
        on_scroll(0, +3)
    elif button == 4:
        on_scroll(0, -3)
    else:
        return


# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA)
glut.glutCreateWindow('Infinite hexagonal grid')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutMotionFunc(on_motion)
glut.glutMouseFunc(on_mouse)
glut.glutPassiveMotionFunc(on_passive_motion)

# Build program & data
# --------------------------------------
program = Program(vertex, fragment, 4)
program['a_position'] = (-1, -1), (-1, +1), (+1, -1), (+1, +1)
program['a_texcoord'] = (0, 0), (0, +1), (+1, 0), (+1, +1)
program['u_grid_color'] = 0, 0, 0, 1
program['u_grid_thickness'] = 1
program['u_grid_antialias'] = .75
program['u_translate'] = 0, 0
program['u_scale'] = 1.0
program['u_size'] = 512, 512

mouse = 400, 400
translate = [0, 0]
scale = 1

# OpenGL initalization
# --------------------------------------
gl.glClearColor(1, 1, 1, 1)
gl.glEnable(gl.GL_BLEND)
gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)

# Start
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = linear-grid
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author:   Nicolas P .Rougier
# Date:     06/03/2014
# Abstract: Show antialiased linear grid
# Keywords: grid, antialias, log, linear
# -----------------------------------------------------------------------------
import sys
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut
from vispy.gloo import Program

vertex = """
    attribute vec2 a_texcoord;
    attribute vec2 a_position;
    varying vec2 v_texcoord;
    void main()
    {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texcoord = a_texcoord;
    } """

fragment = """
    float
    compute_alpha(float d, float width, float antialias)
    {
        d -= width/2.0 - antialias;
        if( d < 0.0 )
        {
            return 1.0;
        }
        else
        {
            float alpha = d/antialias;
            return exp(-alpha*alpha);
        }
    }

    uniform vec2      u_size;
    uniform vec2      u_translate;
    uniform float     u_scale;
    uniform float     u_antialias;

    uniform float     u_major_grid_width;
    uniform float     u_minor_grid_width;
    uniform vec4      u_major_grid_color;
    uniform vec4      u_minor_grid_color;
    uniform vec2      u_major_tick_size;
    uniform vec2      u_minor_tick_size;
    uniform float     u_major_tick_width;
    uniform float     u_minor_tick_width;
    uniform vec4      u_major_tick_color;
    uniform vec4      u_minor_tick_color;
    uniform sampler2D u_grid;

    varying vec2 v_texcoord;
    void main()
    {
        float x = v_texcoord.x * u_size.x; // - u_translate.x;
        float y = v_texcoord.y * u_size.y; // - u_translate.y;

        float Mx = abs(x-texture2D(u_grid, vec2(v_texcoord.x,0.5)).x - 0.315);
        float My = abs(y-texture2D(u_grid, vec2(v_texcoord.y,0.5)).y - 0.315);
        float mx = abs(x-texture2D(u_grid, vec2(v_texcoord.x,0.5)).z - 0.315);
        float my = abs(y-texture2D(u_grid, vec2(v_texcoord.y,0.5)).w - 0.315);

        // Major grid
        float M = min(Mx,My);

        // Minor grid
        float m = min(mx,my);

        vec4 color = u_major_grid_color;
        float alpha1 = compute_alpha( M, u_major_grid_width, u_antialias);
        float alpha2 = compute_alpha( m, u_minor_grid_width, u_antialias);
        float alpha  = alpha1;
        if( alpha2 > alpha1*1.5 )
        {
            alpha = alpha2;
            color = u_minor_grid_color;
        }


        // Top major ticks
        if( y > (u_size.y - u_major_tick_size.y) )
        {
            float a = compute_alpha(Mx, u_major_tick_width, u_antialias);
            if (a > alpha)
            {
               alpha = a;
               color = u_major_tick_color;
            }
        }

        // Bottom major ticks
        else if( y < u_major_tick_size.y )
        {
            float a = compute_alpha(Mx, u_major_tick_width, u_antialias);
            if (a > alpha)
            {
               alpha = a;
               color = u_major_tick_color;
            }
        }

        // Left major ticks
        if( x < u_major_tick_size.x )
        {
            float a = compute_alpha(My, u_major_tick_width, u_antialias);
            if (a > alpha )
            {
               alpha = a;
               color = u_major_tick_color;
            }
        }

        // Right major ticks
        else if( x > (u_size.x - u_major_tick_size.x) )
        {
            float a = compute_alpha(My, u_major_tick_width, u_antialias);
            if (a > alpha )
            {
               alpha = a;
               color = u_major_tick_color;
            }
        }

        // Top minor ticks
        if( y > (u_size.y - u_minor_tick_size.y) )
        {
            float a = compute_alpha(mx, u_minor_tick_width, u_antialias);
            if (a > alpha)
            {
               alpha = a;
               color = u_minor_tick_color;
            }
        }

        // Bottom minor ticks
        else if( y < u_minor_tick_size.y )
        {
            float a = compute_alpha(mx, u_minor_tick_width, u_antialias);
            if (a > alpha)
            {
               alpha = a;
               color = u_minor_tick_color;
            }
        }

        // Left minor ticks
        if( x < u_minor_tick_size.x )
        {
            float a = compute_alpha(my, u_minor_tick_width, u_antialias);
            if (a > alpha )
            {
               alpha = a;
               color = u_minor_tick_color;
            }
        }

        // Right major ticks
        else if( x > (u_size.x - u_minor_tick_size.x) )
        {
            float a = compute_alpha(my, u_minor_tick_width, u_antialias);
            if (a > alpha )
            {
               alpha = a;
               color = u_minor_tick_color;
            }
        }

        gl_FragColor = vec4(color.xyz, alpha*color.a);
    }
    """


def find_closest(A, target):
    # A must be sorted
    idx = A.searchsorted(target)
    idx = np.clip(idx, 1, len(A) - 1)
    left = A[idx - 1]
    right = A[idx]
    idx -= target - left < right - target
    return idx


def update_grid(w, h):

    n = Z.shape[1]
    t1 = major_grid[0] * scale
    t2 = minor_grid[0] * scale
    t3 = major_grid[1] * scale
    t4 = minor_grid[1] * scale

    # Linear grid
    I1 = np.arange(
        np.fmod(translate[0], t1), np.fmod(translate[0], t1) + w + t1, t1)
    I2 = np.arange(
        np.fmod(translate[0], t2), np.fmod(translate[0], t2) + w + t2, t2)
    I3 = np.arange(
        np.fmod(translate[1], t3), np.fmod(translate[1], t3) + h + t3, t3)
    I4 = np.arange(
        np.fmod(translate[1], t4), np.fmod(translate[1], t4) + h + t4, t4)

    # We are here in screen space and we want integer coordinates
    np.floor(I1, out=I1)
    np.floor(I2, out=I2)
    np.floor(I3, out=I3)
    np.floor(I4, out=I4)

    L = np.linspace(0, w, n)
    Z[..., 0] = I1[find_closest(I1, L)]
    Z[..., 2] = I2[find_closest(I2, L)]
    L = np.linspace(0, h, n)
    Z[..., 1] = I3[find_closest(I3, L)]
    Z[..., 3] = I4[find_closest(I4, L)]

    program['u_grid'][...] = Z
    program['u_size'] = w, h


def display():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    program.draw(gl.GL_TRIANGLE_STRIP)
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)
    update_grid(width, height)


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def on_motion(x, y):
    global mouse, translate, scale
    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)
    y = h - y
    dx, dy = x - mouse[0], y - mouse[1]
    translate = [translate[0] + dx, translate[1] + dy]
    mouse = x, y
    program['u_translate'] = translate
    update_grid(w, h)
    glut.glutPostRedisplay()


def on_passive_motion(x, y):
    global mouse
    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)
    mouse = x, h - y


def on_scroll(dx, dy):
    global mouse, translate, scale
    x, y = mouse
    s = min(max(0.25, scale + .001 * dy * scale), 200)
    translate[0] = x - s * (x - translate[0]) / scale
    translate[1] = y - s * (y - translate[1]) / scale
    translate = [translate[0], translate[1]]
    scale = s
    program['u_translate'] = translate
    program['u_scale'] = scale
    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)
    update_grid(w, h)
    glut.glutPostRedisplay()


def on_mouse(button, state, x, y):
    if button == 3:
        on_scroll(0, +3)
    elif button == 4:
        on_scroll(0, -3)
    else:
        return

# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA)
glut.glutCreateWindow('Infinite grid')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutMotionFunc(on_motion)
glut.glutMouseFunc(on_mouse)
glut.glutPassiveMotionFunc(on_passive_motion)

# Build program & data
# --------------------------------------
program = Program(vertex, fragment, 4)
program['a_position'] = (-1, -1), (-1, +1), (+1, -1), (+1, +1)
program['a_texcoord'] = (0, 0), (0, +1), (+1, 0), (+1, +1)
program['u_major_grid_width'] = 1.0
program['u_minor_grid_width'] = 1.0
program['u_major_grid_color'] = 0, 0, 0, .75
program['u_minor_grid_color'] = 0, 0, 0, .25
program['u_major_tick_size'] = 10, 10
program['u_minor_tick_size'] = 5, 5
program['u_major_tick_width'] = 2.0
program['u_minor_tick_width'] = 1.1
program['u_major_tick_color'] = 0, 0, 0, 1
program['u_minor_tick_color'] = 0, 0, 0, 1
program['u_antialias'] = 1.0
program['u_translate'] = 0, 0
program['u_scale'] = 1.0
program['u_size'] = 512, 512
major_grid = np.array([64, 64])
minor_grid = np.array([8, 8])
Z = np.zeros((1, 2 * 1024, 4), dtype=np.float32)
program['u_grid'] = Z
program['u_grid'].interpolation = gl.GL_NEAREST

mouse = 256, 256
translate = [0, 0]
scale = 1

# OpenGL initalization
# --------------------------------------
gl.glClearColor(1, 1, 1, 1)
gl.glEnable(gl.GL_BLEND)
gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)

# Start
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = log-grid
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author:   Nicolas P .Rougier
# Date:     06/03/2014
# Abstract: Show antialiased logarithmic grid
# Keywords: grid, antialias, log, linear
# -----------------------------------------------------------------------------
import sys
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut
from vispy.gloo import Program

vertex = """
    attribute vec2 a_texcoord;
    attribute vec2 a_position;
    varying vec2 v_texcoord;
    void main()
    {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texcoord = a_texcoord;
    } """

fragment = """
    float
    compute_alpha(float d, float width, float antialias)
    {
        d -= width/2.0 - antialias;
        if( d < 0.0 )
        {
            return 1.0;
        }
        else
        {
            float alpha = d/antialias;
            return exp(-alpha*alpha);
        }
    }

    uniform vec2      u_size;
    uniform vec2      u_translate;
    uniform float     u_scale;
    uniform float     u_antialias;

    uniform float     u_major_grid_width;
    uniform float     u_minor_grid_width;
    uniform vec4      u_major_grid_color;
    uniform vec4      u_minor_grid_color;
    uniform vec2      u_major_tick_size;
    uniform vec2      u_minor_tick_size;
    uniform float     u_major_tick_width;
    uniform float     u_minor_tick_width;
    uniform vec4      u_major_tick_color;
    uniform vec4      u_minor_tick_color;
    uniform sampler2D u_grid;

    varying vec2 v_texcoord;
    void main()
    {
        float x = v_texcoord.x * u_size.x; // - u_translate.x;
        float y = v_texcoord.y * u_size.y; // - u_translate.y;

        float Mx = abs(x-texture2D(u_grid, vec2(v_texcoord.x,0.5)).x - 0.315);
        float My = abs(y-texture2D(u_grid, vec2(v_texcoord.y,0.5)).y - 0.315);
        float mx = abs(x-texture2D(u_grid, vec2(v_texcoord.x,0.5)).z - 0.315);
        float my = abs(y-texture2D(u_grid, vec2(v_texcoord.y,0.5)).w - 0.315);

        // Major grid
        float M = min(Mx,My);

        // Minor grid
        float m = min(mx,my);

        vec4 color = u_major_grid_color;
        float alpha1 = compute_alpha( M, u_major_grid_width, u_antialias);
        float alpha2 = compute_alpha( m, u_minor_grid_width, u_antialias);
        float alpha  = alpha1;
        if( alpha2 > alpha1*1.5 )
        {
            alpha = alpha2;
            color = u_minor_grid_color;
        }


        // Top major ticks
        if( y > (u_size.y - u_major_tick_size.y) )
        {
            float a = compute_alpha(Mx, u_major_tick_width, u_antialias);
            if (a > alpha)
            {
               alpha = a;
               color = u_major_tick_color;
            }
        }

        // Bottom major ticks
        else if( y < u_major_tick_size.y )
        {
            float a = compute_alpha(Mx, u_major_tick_width, u_antialias);
            if (a > alpha)
            {
               alpha = a;
               color = u_major_tick_color;
            }
        }

        // Left major ticks
        if( x < u_major_tick_size.x )
        {
            float a = compute_alpha(My, u_major_tick_width, u_antialias);
            if (a > alpha )
            {
               alpha = a;
               color = u_major_tick_color;
            }
        }

        // Right major ticks
        else if( x > (u_size.x - u_major_tick_size.x) )
        {
            float a = compute_alpha(My, u_major_tick_width, u_antialias);
            if (a > alpha )
            {
               alpha = a;
               color = u_major_tick_color;
            }
        }

        // Top minor ticks
        if( y > (u_size.y - u_minor_tick_size.y) )
        {
            float a = compute_alpha(mx, u_minor_tick_width, u_antialias);
            if (a > alpha)
            {
               alpha = a;
               color = u_minor_tick_color;
            }
        }

        // Bottom minor ticks
        else if( y < u_minor_tick_size.y )
        {
            float a = compute_alpha(mx, u_minor_tick_width, u_antialias);
            if (a > alpha)
            {
               alpha = a;
               color = u_minor_tick_color;
            }
        }

        // Left minor ticks
        if( x < u_minor_tick_size.x )
        {
            float a = compute_alpha(my, u_minor_tick_width, u_antialias);
            if (a > alpha )
            {
               alpha = a;
               color = u_minor_tick_color;
            }
        }

        // Right major ticks
        else if( x > (u_size.x - u_minor_tick_size.x) )
        {
            float a = compute_alpha(my, u_minor_tick_width, u_antialias);
            if (a > alpha )
            {
               alpha = a;
               color = u_minor_tick_color;
            }
        }

        gl_FragColor = vec4(color.xyz, alpha*color.a);
    }
    """


def find_closest(A, target):
    # A must be sorted
    idx = A.searchsorted(target)
    idx = np.clip(idx, 1, len(A) - 1)
    left = A[idx - 1]
    right = A[idx]
    idx -= target - left < right - target
    return idx


def update_grid(w, h):

    n = Z.shape[1]

    # Logarithmic grid
    I1 = np.logspace(np.log10(1), np.log10(2 * w), 5) * scale
    I2 = np.logspace(np.log10(1), np.log10(2 * w), 50) * scale
    I3 = np.logspace(np.log10(1), np.log10(2 * h), 5) * scale
    I4 = np.logspace(np.log10(1), np.log10(2 * h), 50) * scale

    # We are here in screen space and we want integer coordinates
    np.floor(I1, out=I1)
    np.floor(I2, out=I2)
    np.floor(I3, out=I3)
    np.floor(I4, out=I4)

    L = np.linspace(0, w, n)
    Z[..., 0] = I1[find_closest(I1, L)]
    Z[..., 2] = I2[find_closest(I2, L)]
    L = np.linspace(0, h, n)
    Z[..., 1] = I3[find_closest(I3, L)]
    Z[..., 3] = I4[find_closest(I4, L)]

    program['u_grid'][...] = Z
    program['u_size'] = w, h


def display():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    program.draw(gl.GL_TRIANGLE_STRIP)
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)
    update_grid(width, height)


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def on_motion(x, y):
    global mouse, translate, scale
    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)
    y = h - y
    dx, dy = x - mouse[0], y - mouse[1]
    translate = [translate[0] + dx, translate[1] + dy]
    mouse = x, y
    program['u_translate'] = translate
    update_grid(w, h)
    glut.glutPostRedisplay()


def on_passive_motion(x, y):
    global mouse
    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)
    mouse = x, h - y


def on_scroll(dx, dy):
    global mouse, translate, scale
    x, y = mouse
    s = min(max(0.25, scale + .001 * dy * scale), 200)
    translate[0] = x - s * (x - translate[0]) / scale
    translate[1] = y - s * (y - translate[1]) / scale
    translate = [translate[0], translate[1]]
    scale = s
    program['u_translate'] = translate
    program['u_scale'] = scale
    _, _, w, h = gl.glGetIntegerv(gl.GL_VIEWPORT)
    update_grid(w, h)
    glut.glutPostRedisplay()


def on_mouse(button, state, x, y):
    if button == 3:
        on_scroll(0, +3)
    elif button == 4:
        on_scroll(0, -3)
    else:
        return

# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA)
glut.glutCreateWindow('Infinite grid')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutMotionFunc(on_motion)
glut.glutMouseFunc(on_mouse)
glut.glutPassiveMotionFunc(on_passive_motion)

# Build program & data
# --------------------------------------
program = Program(vertex, fragment, 4)
program['a_position'] = (-1, -1), (-1, +1), (+1, -1), (+1, +1)
program['a_texcoord'] = (0, 0), (0, +1), (+1, 0), (+1, +1)
program['u_major_grid_width'] = 1.0
program['u_minor_grid_width'] = 1.0
program['u_major_grid_color'] = 0, 0, 0, .75
program['u_minor_grid_color'] = 0, 0, 0, .25
program['u_major_tick_size'] = 10, 10
program['u_minor_tick_size'] = 5, 5
program['u_major_tick_width'] = 2.0
program['u_minor_tick_width'] = 1.1
program['u_major_tick_color'] = 0, 0, 0, 1
program['u_minor_tick_color'] = 0, 0, 0, 1
program['u_antialias'] = 1.0
program['u_translate'] = 0, 0
program['u_scale'] = 1.0
program['u_size'] = 512, 512
major_grid = np.array([64, 64])
minor_grid = np.array([8, 8])
Z = np.zeros((1, 2 * 1024, 4), dtype=np.float32)
program['u_grid'] = Z
program['u_grid'].interpolation = gl.GL_NEAREST

mouse = 256, 256
translate = [0, 0]
scale = 1

# OpenGL initalization
# --------------------------------------
gl.glClearColor(1, 1, 1, 1)
gl.glEnable(gl.GL_BLEND)
gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)

# Start
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = post-processing
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author:   Nicolas P .Rougier
# Date:     04/03/2014
# Abstract: Show post-processing technique using framebuffer
# Keywords: framebuffer, gloo, cube, post-processing
# -----------------------------------------------------------------------------
import sys
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut

from vispy.util.cube import cube
from vispy.util.transforms import perspective, translate, rotate
from vispy.gloo import Program, VertexBuffer, IndexBuffer, Texture2D
from vispy.gloo import FrameBuffer, DepthBuffer

cube_vertex = """
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
attribute vec3 position;
attribute vec2 texcoord;
varying vec2 v_texcoord;
void main()
{
    gl_Position = projection * view * model * vec4(position,1.0);
    v_texcoord = texcoord;
}
"""

cube_fragment = """
uniform sampler2D texture;
varying vec2 v_texcoord;
void main()
{
    float r = texture2D(texture, v_texcoord).r;
    gl_FragColor = vec4(r,r,r,1);
}
"""

quad_vertex = """
attribute vec2 position;
attribute vec2 texcoord;
varying vec2 v_texcoord;
void main()
{
    gl_Position = vec4(position, 0.0, 1.0);
    v_texcoord = texcoord;
}
"""

quad_fragment = """
uniform sampler2D texture;
varying vec2 v_texcoord;
void main()
{
    vec2 d = 5.0 * vec2(sin(v_texcoord.y*50.0),0)/512.0;

    // Inverse video
    if( v_texcoord.x > 0.5 ) {
        gl_FragColor.rgb = 1.0-texture2D(texture, v_texcoord+d).rgb;
    } else {
        gl_FragColor = texture2D(texture, v_texcoord);
    }
}
"""


def checkerboard(grid_num=8, grid_size=32):
    row_even = grid_num / 2 * [0, 1]
    row_odd = grid_num / 2 * [1, 0]
    Z = np.row_stack(grid_num / 2 * (row_even, row_odd)).astype(np.uint8)
    return 255 * Z.repeat(grid_size, axis=0).repeat(grid_size, axis=1)


def display():
    framebuffer.activate()
    gl.glViewport(0, 0, 512, 512)
    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
    gl.glEnable(gl.GL_DEPTH_TEST)
    cube.draw(gl.GL_TRIANGLES, indices)
    framebuffer.deactivate()
    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    gl.glDisable(gl.GL_DEPTH_TEST)
    quad.draw(gl.GL_TRIANGLE_STRIP)
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)
    projection = perspective(30.0, width / float(height), 2.0, 10.0)
    cube['projection'] = projection


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def timer(fps):
    global theta, phi
    theta += .5
    phi += .5
    model = np.eye(4, dtype=np.float32)
    rotate(model, theta, 0, 0, 1)
    rotate(model, phi, 0, 1, 0)
    cube['model'] = model
    glut.glutTimerFunc(1000 / fps, timer, fps)
    glut.glutPostRedisplay()


# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
glut.glutCreateWindow('Framebuffer post-processing')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutTimerFunc(1000 / 60, timer, 60)

# Build cube data
# --------------------------------------
vertices, indices, _ = cube()
vertices = VertexBuffer(vertices)
indices = IndexBuffer(indices)

# Build program
# --------------------------------------
view = np.eye(4, dtype=np.float32)
model = np.eye(4, dtype=np.float32)
projection = np.eye(4, dtype=np.float32)
translate(view, 0, 0, -7)
phi, theta = 60, 20
rotate(model, theta, 0, 0, 1)
rotate(model, phi, 0, 1, 0)

cube = Program(cube_vertex, cube_fragment)
cube.bind(vertices)
cube["texture"] = checkerboard()
cube["texture"].interpolation = gl.GL_LINEAR
cube['model'] = model
cube['view'] = view

depth = DepthBuffer((512, 512))
color = Texture2D(shape=(512, 512, 3), dtype=np.dtype(np.float32))
framebuffer = FrameBuffer(color=color, depth=depth)

quad = Program(quad_vertex, quad_fragment, count=4)
quad['texcoord'] = [(0, 0), (0, 1), (1, 0), (1, 1)]
quad['position'] = [(-1, -1), (-1, +1), (+1, -1), (+1, +1)]
quad['texture'] = color
quad["texture"].interpolation = gl.GL_LINEAR

# OpenGL initalization
# --------------------------------------
gl.glClearColor(.3, .3, .35, 1)
gl.glEnable(gl.GL_DEPTH_TEST)

# Start
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = app-event
# !/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This example shows how to retrieve event information from a callback.
You should see information displayed for any event you triggered.
"""

import vispy.gloo.gl as gl
import vispy.app as app


class Canvas(app.Canvas):

    def __init__(self, *args, **kwargs):
        app.Canvas.__init__(self, *args, **kwargs)
        self.title = 'App demo'

    def on_initialize(self, event):
        print('initializing!')

    def on_close(self, event):
        print('closing!')

    def on_resize(self, event):
        print('Resize %r' % (event.size, ))

    def on_key_press(self, event):
        modifiers = [key.name for key in event.modifiers]
        print('Key pressed - text: %r, key: %s, modifiers: %r' % (
            event.text, event.key.name, modifiers))

    def on_key_release(self, event):
        modifiers = [key.name for key in event.modifiers]
        print('Key released - text: %r, key: %s, modifiers: %r' % (
            event.text, event.key.name, modifiers))

    def on_mouse_press(self, event):
        self.print_mouse_event(event, 'Mouse press')

    def on_mouse_release(self, event):
        self.print_mouse_event(event, 'Mouse release')

    def on_mouse_move(self, event):
        if (event.pos[0] < self.size[0] * 0.5
                and event.pos[1] < self.size[1] * 0.5):
            self.print_mouse_event(event, 'Mouse move')

    def on_mouse_wheel(self, event):
        self.print_mouse_event(event, 'Mouse wheel')

    def print_mouse_event(self, event, what):
        modifiers = ', '.join([key.name for key in event.modifiers])
        print('%s - pos: %r, button: %i, modifiers: %s, delta: %r' %
              (what, event.pos, event.button, modifiers, event.delta))

    def on_paint(self, event):
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)


if __name__ == '__main__':
    canvas = Canvas(close_keys='escape')
    canvas.show()
    app.run()

########NEW FILE########
__FILENAME__ = app-glfw
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This example shows how to actively select and test the glfw backend.

You should see a black window and any mouse or keyboard event should be
detected. A timer is also run every second and it should print "tick !"
every second.
"""

from vispy import app, keys
from vispy.gloo import gl
app.use('glfw')


class Canvas(app.Canvas):

    def __init__(self, *args, **kwargs):
        app.Canvas.__init__(self, *args, **kwargs)
        timer = app.Timer(1.0)
        timer.connect(self.on_timer)
        timer.start()

    def on_initialize(self, event):
        gl.glClearColor(0, 0, 0, 1)
        print('on_initialize')

    def on_close(self, event):
        print('on_close')

    def on_resize(self, event):
        print('on_resize (%dx%d)' % event.size)

    def on_key_press(self, event):
        print('on_key_press: %s' % event.text)
        if event.key == keys.ESCAPE:
            self.app.quit()

    def on_key_release(self, event):
        print('on_key_release')

    def on_mouse_press(self, event):
        print('on_mouse_press: %d' % event.button)

    def on_mouse_release(self, event):
        print('on_mouse_release')
        print(event.trail())

    def on_mouse_move(self, event):
        print('on_mouse_move (%dx%d)' % event.pos)

    def on_mouse_wheel(self, event):
        print('on_mouse_wheel: %r' % (event.delta,))

    def on_paint(self, event):
        print('on_paint')
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

    def on_timer(self, event):
        print('tick !')

# -----------------------------------------------------------------------------
if __name__ == '__main__':
    canvas = Canvas(close_keys='escape')
    canvas.show()
    app.run()

########NEW FILE########
__FILENAME__ = app-glut
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This example shows how to actively select and test the glut backend.

You should see a black window and any mouse or keyboard event should be
detected. A timer is also run every second and it should print "tick !"
every second.

Notes
-----
Depending on on your glut implementation (native or freeglut), the mouse wheel
event may or may not be detected. Furthermore, glut has no utf-8 support and
non ascii-key will most likely produces garbage.
"""

from vispy import app
from vispy.gloo import gl
app.use('glut')


class Canvas(app.Canvas):

    def __init__(self, *args, **kwargs):
        app.Canvas.__init__(self, *args, **kwargs)
        timer = app.Timer(1.0)
        timer.connect(self.on_timer)
        timer.start()

    def on_initialize(self, event):
        gl.glClearColor(0, 0, 0, 1)
        print('on_initialize')

    def on_close(self, event):
        print('on_close')

    def on_resize(self, event):
        print('on_resize (%dx%d)' % event.size)

    def on_key_press(self, event):
        print('on_key_press: %s' % event.text)

    def on_key_release(self, event):
        print('on_key_release')

    def on_mouse_press(self, event):
        print('on_mouse_press: %d' % event.button)

    def on_mouse_release(self, event):
        print('on_mouse_release')
        print(event.trail())

    def on_mouse_move(self, event):
        print('on_mouse_move (%dx%d)' % event.pos)

    def on_mouse_wheel(self, event):
        print('on_mouse_wheel: %r' % (event.delta,))

    def on_paint(self, event):
        print('on_paint')
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

    def on_timer(self, event):
        print('tick !')

# -----------------------------------------------------------------------------
if __name__ == '__main__':
    canvas = Canvas(close_keys='escape')
    canvas.show()
    app.run()

########NEW FILE########
__FILENAME__ = app-pyglet
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This example shows how to actively select and test the pyglet backend.

You should see a black window and any mouse or keyboard event should be
detected. A timer is also run every second and it should print "tick !"
every second.
"""

from vispy import app
from vispy.gloo import gl
app.use('pyglet')


class Canvas(app.Canvas):

    def __init__(self, *args, **kwargs):
        app.Canvas.__init__(self, *args, **kwargs)
        timer = app.Timer(1.0)
        timer.connect(self.on_timer)
        timer.start()

    def on_initialize(self, event):
        gl.glClearColor(0, 0, 0, 1)
        print('on_initialize')

    def on_close(self, event):
        print('on_close')

    def on_resize(self, event):
        print('on_resize (%dx%d)' % event.size)

    def on_key_press(self, event):
        print('on_key_press: %s' % event.text)

    def on_key_release(self, event):
        print('on_key_release')

    def on_mouse_press(self, event):
        print('on_mouse_press: %d' % event.button)

    def on_mouse_release(self, event):
        print('on_mouse_release')
        print(event.trail())

    def on_mouse_move(self, event):
        print('on_mouse_move (%dx%d)' % event.pos)

    def on_mouse_wheel(self, event):
        print('on_mouse_wheel: %r' % (event.delta,))

    def on_paint(self, event):
        print('on_paint')
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

    def on_timer(self, event):
        print('tick !')

# -----------------------------------------------------------------------------
if __name__ == '__main__':
    canvas = Canvas(close_keys='escape')
    canvas.show()
    app.run()

########NEW FILE########
__FILENAME__ = app-qt
# !/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This example shows how to actively select and test the qt backend.

You should see a black window and any mouse or keyboard event should be
detected. A timer is also run every second and it should print "tick !"
every second.
"""

from vispy import app
from vispy.gloo import gl
app.use('qt')


class Canvas(app.Canvas):

    def __init__(self, *args, **kwargs):
        app.Canvas.__init__(self, *args, **kwargs)
        timer = app.Timer(1.0)
        timer.connect(self.on_timer)
        timer.start()

    def on_initialize(self, event):
        gl.glClearColor(0, 0, 0, 1)
        print('on_initialize')

    def on_close(self, event):
        print('on_close')

    def on_resize(self, event):
        print('on_resize (%dx%d)' % event.size)

    def on_key_press(self, event):
        print('on_key_press: %s' % event.text)

    def on_key_release(self, event):
        print('on_key_release')

    def on_mouse_press(self, event):
        print('on_mouse_press: %d' % event.button)

    def on_mouse_release(self, event):
        print('on_mouse_release')
        print(event.trail())

    def on_mouse_move(self, event):
        print('on_mouse_move (%dx%d)' % event.pos)

    def on_mouse_wheel(self, event):
        print('on_mouse_wheel: %r' % (event.delta,))

    def on_paint(self, event):
        print('on_paint')
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

    def on_timer(self, event):
        print('tick ! (%s)' % event.dt)

# -----------------------------------------------------------------------------
if __name__ == '__main__':
    canvas = Canvas(close_keys='escape')
    canvas.show()
    app.run()

########NEW FILE########
__FILENAME__ = fps
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 20

"""
This is a very minimal example that opens a window and makes the background
color to change from black to white to black ...

The backend (one of 'qt', 'glut', 'pyglet') is chosen automatically depending
on what is available on your machine.
"""

import math
from vispy import app
from vispy.gloo import gl


class Canvas(app.Canvas):

    def __init__(self, *args, **kwargs):
        app.Canvas.__init__(self, *args, **kwargs)
        timer = app.Timer(1 / 60.0)
        timer.connect(self.on_timer)
        timer.start()
        self.tick = 0

    def on_paint(self, event):
        gl.glClear(gl.GL_COLOR_BUFFER_BIT)

    def on_timer(self, event):
        self.tick += 1 / 60.0
        c = abs(math.sin(self.tick))
        gl.glClearColor(c, c, c, 1)
        self.update()

    def show_fps(self, fps):
        print("FPS - %.2f" % fps)

if __name__ == '__main__':
    canvas = Canvas(close_keys='escape')
    canvas.show()
    canvas.measure_fps(1, canvas.show_fps)
    app.run()

########NEW FILE########
__FILENAME__ = simple
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# vispy: gallery 20

"""
This is a very minimal example that opens a window and makes the background
color to change from black to white to black ...

The backend (one of 'qt', 'glut', 'pyglet') is chosen automatically depending
on what is available on your machine.
"""

import math
from vispy import app
from vispy.gloo import gl


class Canvas(app.Canvas):

    def __init__(self, *args, **kwargs):
        app.Canvas.__init__(self, *args, **kwargs)
        timer = app.Timer(1 / 60.0)
        timer.connect(self.on_timer)
        timer.start()
        self.tick = 0

    def on_paint(self, event):
        gl.glClear(gl.GL_COLOR_BUFFER_BIT)

    def on_timer(self, event):
        self.tick += 1 / 60.0
        c = abs(math.sin(self.tick))
        gl.glClearColor(c, c, c, 1)
        self.update()

if __name__ == '__main__':
    canvas = Canvas(close_keys='escape')
    canvas.show()
    app.run()

########NEW FILE########
__FILENAME__ = cube
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: Nicolas P .Rougier
# Date:   04/03/2014
# -----------------------------------------------------------------------------
import sys
import math
import ctypes
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut


def checkerboard(grid_num=8, grid_size=32):
    row_even = grid_num / 2 * [0, 1]
    row_odd = grid_num / 2 * [1, 0]
    Z = np.row_stack(grid_num / 2 * (row_even, row_odd)).astype(np.uint8)
    return 255 * Z.repeat(grid_size, axis=0).repeat(grid_size, axis=1)


def rotate(M, angle, x, y, z, point=None):
    angle = math.pi * angle / 180
    c, s = math.cos(angle), math.sin(angle)
    n = math.sqrt(x * x + y * y + z * z)
    x /= n
    y /= n
    z /= n
    cx, cy, cz = (1 - c) * x, (1 - c) * y, (1 - c) * z
    R = np.array([[cx * x + c, cy * x - z * s, cz * x + y * s, 0],
                  [cx * y + z * s, cy * y + c, cz * y - x * s, 0],
                  [cx * z - y * s, cy * z + x * s, cz * z + c, 0],
                  [0, 0, 0, 1]], dtype=M.dtype).T
    M[...] = np.dot(M, R)
    return M


def translate(M, x, y=None, z=None):
    y = x if y is None else y
    z = x if z is None else z
    T = np.array([[1.0, 0.0, 0.0, x],
                  [0.0, 1.0, 0.0, y],
                  [0.0, 0.0, 1.0, z],
                  [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype).T
    M[...] = np.dot(M, T)
    return M


def frustum(left, right, bottom, top, znear, zfar):
    M = np.zeros((4, 4), dtype=np.float32)
    M[0, 0] = +2.0 * znear / (right - left)
    M[2, 0] = (right + left) / (right - left)
    M[1, 1] = +2.0 * znear / (top - bottom)
    M[3, 1] = (top + bottom) / (top - bottom)
    M[2, 2] = -(zfar + znear) / (zfar - znear)
    M[3, 2] = -2.0 * znear * zfar / (zfar - znear)
    M[2, 3] = -1.0
    return M


def perspective(fovy, aspect, znear, zfar):
    h = math.tan(fovy / 360.0 * math.pi) * znear
    w = h * aspect
    return frustum(-w, w, -h, h, znear, zfar)


def makecube():
    """ Generate vertices & indices for a filled cube """

    vtype = [('a_position', np.float32, 3),
             ('a_texcoord', np.float32, 2)]
    itype = np.uint32

    # Vertices positions
    p = np.array([[1, 1, 1], [-1, 1, 1], [-1, -1, 1], [1, -1, 1],
                  [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, -1]])

    # Texture coords
    t = np.array([[0, 0], [0, 1], [1, 1], [1, 0]])

    faces_p = [0, 1, 2, 3, 0, 3, 4, 5, 0, 5, 6,
               1, 1, 6, 7, 2, 7, 4, 3, 2, 4, 7, 6, 5]
    faces_t = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2,
               3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]

    vertices = np.zeros(24, vtype)
    vertices['a_position'] = p[faces_p]
    vertices['a_texcoord'] = t[faces_t]

    indices = np.resize(
        np.array([0, 1, 2, 0, 2, 3], dtype=itype), 6 * (2 * 3))
    indices += np.repeat(4 * np.arange(6), 6)

    return vertices, indices


cube_vertex = """
uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
attribute vec3 a_position;
attribute vec2 a_texcoord;
varying vec2 v_texcoord;
void main()
{
    gl_Position = u_projection * u_view * u_model * vec4(a_position,1.0);
    v_texcoord = a_texcoord;
}
"""

cube_fragment = """
uniform sampler2D u_texture;
varying vec2 v_texcoord;
void main()
{
    gl_FragColor = texture2D(u_texture, v_texcoord);
}
"""


def display():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
    gl.glDrawElements(
        gl.GL_TRIANGLES, icube_data.size, gl.GL_UNSIGNED_INT, None)
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)
    projection = perspective(35.0, width / float(height), 2.0, 10.0)
    loc = gl.glGetUniformLocation(cube, "u_projection")
    gl.glUniformMatrix4fv(loc, 1, False, projection)


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def timer(fps):
    global theta, phi
    theta += .5
    phi += .5
    model = np.eye(4, dtype=np.float32)
    rotate(model, theta, 0, 0, 1)
    rotate(model, phi, 0, 1, 0)
    loc = gl.glGetUniformLocation(cube, "u_model")
    gl.glUniformMatrix4fv(loc, 1, False, model)
    glut.glutTimerFunc(1000 / fps, timer, fps)
    glut.glutPostRedisplay()


# GLUT init
# --------------------------------------
glut.glutInit()
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
glut.glutCreateWindow('Rotating cube (GL version)')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutDisplayFunc(display)
glut.glutKeyboardFunc(keyboard)
glut.glutTimerFunc(1000 / 60, timer, 60)

# Build & activate cube program
# --------------------------------------
cube = gl.glCreateProgram()
vertex = gl.glCreateShader(gl.GL_VERTEX_SHADER)
fragment = gl.glCreateShader(gl.GL_FRAGMENT_SHADER)
gl.glShaderSource(vertex, cube_vertex)
gl.glShaderSource(fragment, cube_fragment)
gl.glCompileShader(vertex)
gl.glCompileShader(fragment)
gl.glAttachShader(cube, vertex)
gl.glAttachShader(cube, fragment)
gl.glLinkProgram(cube)
gl.glDetachShader(cube, vertex)
gl.glDetachShader(cube, fragment)
gl.glUseProgram(cube)

# Get data & build cube buffers
# --------------------------------------
vcube_data, icube_data = makecube()
vcube = gl.glGenBuffers(1)
gl.glBindBuffer(gl.GL_ARRAY_BUFFER, vcube)
gl.glBufferData(
    gl.GL_ARRAY_BUFFER, vcube_data.nbytes, vcube_data, gl.GL_STATIC_DRAW)
icube = gl.glGenBuffers(1)
gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, icube)
gl.glBufferData(gl.GL_ELEMENT_ARRAY_BUFFER,
                icube_data.nbytes, icube_data, gl.GL_STATIC_DRAW)

# Bind cube attributes
# --------------------------------------
stride = vcube_data.strides[0]
offset = ctypes.c_void_p(0)
loc = gl.glGetAttribLocation(cube, "a_position")
gl.glEnableVertexAttribArray(loc)
gl.glVertexAttribPointer(loc, 3, gl.GL_FLOAT, False, stride, offset)

offset = ctypes.c_void_p(vcube_data.dtype["a_position"].itemsize)
loc = gl.glGetAttribLocation(cube, "a_texcoord")
gl.glEnableVertexAttribArray(loc)
gl.glVertexAttribPointer(loc, 2, gl.GL_FLOAT, False, stride, offset)

# Create & bind cube texture
# --------------------------------------
crate = checkerboard()
texture = gl.glGenTextures(1)
gl.glTexParameterf(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_LINEAR)
gl.glTexParameterf(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_LINEAR)
gl.glTexParameterf(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_CLAMP_TO_EDGE)
gl.glTexParameterf(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_CLAMP_TO_EDGE)
gl.glTexImage2D(gl.GL_TEXTURE_2D, 0, gl.GL_INTENSITY,
                crate.shape[1], crate.shape[0],
                0, gl.GL_RED, gl.GL_UNSIGNED_BYTE, crate)
loc = gl.glGetUniformLocation(cube, "u_texture")
gl.glUniform1i(loc, texture)
gl.glBindTexture(gl.GL_TEXTURE_2D, 0)

# Create & bind cube matrices
# --------------------------------------
view = np.eye(4, dtype=np.float32)
model = np.eye(4, dtype=np.float32)
projection = np.eye(4, dtype=np.float32)
translate(view, 0, 0, -7)
phi, theta = 60, 20
rotate(model, theta, 0, 0, 1)
rotate(model, phi, 0, 1, 0)
loc = gl.glGetUniformLocation(cube, "u_model")
gl.glUniformMatrix4fv(loc, 1, False, model)
loc = gl.glGetUniformLocation(cube, "u_view")
gl.glUniformMatrix4fv(loc, 1, False, view)
loc = gl.glGetUniformLocation(cube, "u_projection")
gl.glUniformMatrix4fv(loc, 1, False, projection)

# OpenGL initalization
# --------------------------------------
gl.glClearColor(0.30, 0.30, 0.35, 1.00)
gl.glEnable(gl.GL_DEPTH_TEST)

# Enter mainloop
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = fireworks
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author:   Almar Klein & Nicolas P .Rougier
# Date:     04/03/2014
# Topic:    Fireworks !
# Keywords: oarticles, gl, sprites
# -----------------------------------------------------------------------------
"""
Example demonstrating simulation of fireworks using point sprites.
(adapted from the "OpenGL ES 2.0 Programming Guide")

This example demonstrates a series of explosions that last one second. The
visualization during the explosion is highly optimized using a Vertex Buffer
Object (VBO). After each explosion, vertex data for the next explosion are
calculated, such that each explostion is unique.
"""
import sys
import ctypes
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut


vertex_code = """
#version 120

uniform float time;
uniform vec3 center;
attribute float lifetime;
attribute vec3 start;
attribute vec3 end;
varying float v_lifetime;
void main () {
    if (time < lifetime) {
        gl_Position.xyz = start + (time * end) + center;
        gl_Position.w = 1.0;
        gl_Position.y -= 1.5 * time * time;
    } else {
        gl_Position = vec4(-1000, -1000, 0, 0);
    }
    v_lifetime = clamp(1.0 - (time / lifetime), 0.0, 1.0);
    gl_PointSize = (v_lifetime * v_lifetime) * 40.0;
}
"""

fragment_code = """
#version 120

uniform vec4 color;
varying float v_lifetime;
void main()
{
    float d = 1 - length(gl_PointCoord - vec2(.5,.5)) / (sqrt(2)/2);
    gl_FragColor = d*color;
    gl_FragColor.a = d;
    gl_FragColor.a *= v_lifetime;
}
"""


def display():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
    gl.glDrawArrays(gl.GL_POINTS, 0, len(data))
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def new_explosion():
    n = len(data)

    color = np.random.uniform(0.1, 0.9, 4).astype(np.float32)
    color[3] = 1.0 / n ** 0.08
    loc = gl.glGetUniformLocation(program, "color")
    gl.glUniform4f(loc, *color)

    center = np.random.uniform(-0.5, 0.5, 3)
    loc = gl.glGetUniformLocation(program, "center")
    gl.glUniform3f(loc, *center)

    data['lifetime'] = np.random.normal(2.0, 0.5, (n,))
    data['start'] = np.random.normal(0.0, 0.2, (n, 3))
    data['end'] = np.random.normal(0.0, 1.2, (n, 3))
    gl.glBufferData(gl.GL_ARRAY_BUFFER, data.nbytes, data, gl.GL_DYNAMIC_DRAW)


def timer(fps):
    global elapsed_time

    elapsed_time += 1.0 / fps
    if elapsed_time > 1.5:
        new_explosion()
        elapsed_time = 0.0

    loc = gl.glGetUniformLocation(program, "time")
    gl.glUniform1f(loc, elapsed_time)

    glut.glutTimerFunc(1000 / fps, timer, fps)
    glut.glutPostRedisplay()


# GLUT init
# --------------------------------------
glut.glutInit()
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
glut.glutCreateWindow("GL Fireworks")
glut.glutReshapeWindow(800, 600)
glut.glutReshapeFunc(reshape)
glut.glutDisplayFunc(display)
glut.glutKeyboardFunc(keyboard)
glut.glutTimerFunc(1000 / 60, timer, 60)

# Build & activate program
# --------------------------------------
program = gl.glCreateProgram()
vertex = gl.glCreateShader(gl.GL_VERTEX_SHADER)
fragment = gl.glCreateShader(gl.GL_FRAGMENT_SHADER)
gl.glShaderSource(vertex, vertex_code)
gl.glShaderSource(fragment, fragment_code)
gl.glCompileShader(vertex)
gl.glCompileShader(fragment)
gl.glAttachShader(program, vertex)
gl.glAttachShader(program, fragment)
gl.glLinkProgram(program)
gl.glDetachShader(program, vertex)
gl.glDetachShader(program, fragment)
gl.glUseProgram(program)

# Build vertex buffer
# --------------------------------------
n = 10000
data = np.zeros(n, dtype=[('lifetime', np.float32, 1),
                          ('start',    np.float32, 3),
                          ('end',      np.float32, 3)])
vbuffer = gl.glGenBuffers(1)
gl.glBindBuffer(gl.GL_ARRAY_BUFFER, vbuffer)
gl.glBufferData(gl.GL_ARRAY_BUFFER, data.nbytes, data, gl.GL_DYNAMIC_DRAW)

# Bind buffer attributes
# --------------------------------------
stride = data.strides[0]

offset = ctypes.c_void_p(0)
loc = gl.glGetAttribLocation(program, "lifetime")
gl.glEnableVertexAttribArray(loc)
gl.glVertexAttribPointer(loc, 1, gl.GL_FLOAT, False, stride, offset)

offset = ctypes.c_void_p(data.dtype["lifetime"].itemsize)
loc = gl.glGetAttribLocation(program, "start")
gl.glEnableVertexAttribArray(loc)
gl.glVertexAttribPointer(loc, 3, gl.GL_FLOAT, False, stride, offset)

offset = ctypes.c_void_p(data.dtype["start"].itemsize)
loc = gl.glGetAttribLocation(program, "end")
gl.glEnableVertexAttribArray(loc)
gl.glVertexAttribPointer(loc, 3, gl.GL_FLOAT, False, stride, offset)


# OpenGL initalization
# --------------------------------------
elapsed_time = 0
gl.glClearColor(0, 0, 0, 1)
gl.glDisable(gl.GL_DEPTH_TEST)
gl.glEnable(gl.GL_BLEND)
gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE)
gl.glEnable(gl.GL_VERTEX_PROGRAM_POINT_SIZE)
gl.glEnable(gl.GL_POINT_SPRITE)
new_explosion()

# Enter mainloop
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = quad
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: Nicolas P .Rougier
# Date:   04/03/2014
# -----------------------------------------------------------------------------
import sys
import ctypes
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut

vertex_code = """
    uniform float scale;
    attribute vec4 color;
    attribute vec2 position;
    varying vec4 v_color;
    void main()
    {
        gl_Position = vec4(scale*position, 0.0, 1.0);
        v_color = color;
    } """

fragment_code = """
    varying vec4 v_color;
    void main()
    {
        gl_FragColor = v_color;
    } """


def display():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    gl.glDrawArrays(gl.GL_TRIANGLE_STRIP, 0, 4)
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


# GLUT init
# --------------------------------------
glut.glutInit()
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA)
glut.glutCreateWindow('Hello world!')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutDisplayFunc(display)
glut.glutKeyboardFunc(keyboard)

# Build data
# --------------------------------------
data = np.zeros(4, [("position", np.float32, 2),
                    ("color",    np.float32, 4)])
data['color'] = [(1, 0, 0, 1), (0, 1, 0, 1), (0, 0, 1, 1), (1, 1, 0, 1)]
data['position'] = [(-1, -1),   (-1, +1),   (+1, -1),   (+1, +1)]

# Build & activate program
# --------------------------------------

# Request a program and shader slots from GPU
program = gl.glCreateProgram()
vertex = gl.glCreateShader(gl.GL_VERTEX_SHADER)
fragment = gl.glCreateShader(gl.GL_FRAGMENT_SHADER)

# Set shaders source
gl.glShaderSource(vertex, vertex_code)
gl.glShaderSource(fragment, fragment_code)

# Compile shaders
gl.glCompileShader(vertex)
gl.glCompileShader(fragment)

# Attach shader objects to the program
gl.glAttachShader(program, vertex)
gl.glAttachShader(program, fragment)

# Build program
gl.glLinkProgram(program)

# Get rid of shaders (no more needed)
gl.glDetachShader(program, vertex)
gl.glDetachShader(program, fragment)

# Make program the default program
gl.glUseProgram(program)


# Build buffer
# --------------------------------------

# Request a buffer slot from GPU
buffer = gl.glGenBuffers(1)

# Make this buffer the default one
gl.glBindBuffer(gl.GL_ARRAY_BUFFER, buffer)

# Upload data
gl.glBufferData(gl.GL_ARRAY_BUFFER, data.nbytes, data, gl.GL_DYNAMIC_DRAW)


# Bind attributes
# --------------------------------------
stride = data.strides[0]
offset = ctypes.c_void_p(0)
loc = gl.glGetAttribLocation(program, "position")
gl.glEnableVertexAttribArray(loc)
gl.glBindBuffer(gl.GL_ARRAY_BUFFER, buffer)
gl.glVertexAttribPointer(loc, 3, gl.GL_FLOAT, False, stride, offset)

offset = ctypes.c_void_p(data.dtype["position"].itemsize)
loc = gl.glGetAttribLocation(program, "color")
gl.glEnableVertexAttribArray(loc)
gl.glBindBuffer(gl.GL_ARRAY_BUFFER, buffer)
gl.glVertexAttribPointer(loc, 4, gl.GL_FLOAT, False, stride, offset)

# Bind uniforms
# --------------------------------------
loc = gl.glGetUniformLocation(program, "scale")
gl.glUniform1f(loc, 1.0)

# Enter mainloop
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = colored-cube
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: Nicolas P .Rougier
# Date:   04/03/2014
# -----------------------------------------------------------------------------
import sys
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut

from vispy.gloo import Program, VertexBuffer, IndexBuffer
from vispy.util.transforms import perspective, translate, rotate
from vispy.util.cube import cube


vertex = """
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
attribute vec3 position;
attribute vec4 color;
varying vec4 v_color;
void main()
{
    v_color = color;
    gl_Position = projection * view * model * vec4(position,1.0);
}
"""

fragment = """
varying vec4 v_color;
void main()
{
    gl_FragColor = v_color;
}
"""


def display():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
    program.draw(gl.GL_TRIANGLES, indices)
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)
    projection = perspective(45.0, width / float(height), 2.0, 10.0)
    program['projection'] = projection


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def timer(fps):
    global theta, phi
    theta += .5
    phi += .5
    model = np.eye(4, dtype=np.float32)
    rotate(model, theta, 0, 0, 1)
    rotate(model, phi, 0, 1, 0)
    program['model'] = model
    glut.glutTimerFunc(1000 / fps, timer, fps)
    glut.glutPostRedisplay()


# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
glut.glutCreateWindow('Colored Cube')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutTimerFunc(1000 / 60, timer, 60)

# Build cube data
# --------------------------------------
V, I, _ = cube()
vertices = VertexBuffer(V)
indices = IndexBuffer(I)

# Build program
# --------------------------------------
program = Program(vertex, fragment)
program.bind(vertices)

# Build view, model, projection & normal
# --------------------------------------
view = np.eye(4, dtype=np.float32)
model = np.eye(4, dtype=np.float32)
projection = np.eye(4, dtype=np.float32)
translate(view, 0, 0, -5)
program['model'] = model
program['view'] = view
phi, theta = 0, 0

# OpenGL initalization
# --------------------------------------
gl.glClearColor(0.30, 0.30, 0.35, 1.00)
gl.glEnable(gl.GL_DEPTH_TEST)

# Start
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = colored-quad
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: Nicolas P .Rougier
# Date:   04/03/2014
# -----------------------------------------------------------------------------
import sys
import OpenGL.GL as gl
import OpenGL.GLUT as glut
from vispy.gloo import Program

vertex = """
    attribute vec4 color;
    attribute vec2 position;
    varying vec4 v_color;
    void main()
    {
        gl_Position = vec4(position, 0.0, 1.0);
        v_color = color;
    } """

fragment = """
    varying vec4 v_color;
    void main()
    {
        gl_FragColor = v_color;
    } """


def display():
    gl.glClearColor(1, 1, 1, 1)
    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    program.draw(gl.GL_TRIANGLE_STRIP)
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()

# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA)
glut.glutCreateWindow('Colored quad')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)

# Build program & data
# ----------------------------------------
program = Program(vertex, fragment, count=4)
program['color'] = [(1, 0, 0, 1), (0, 1, 0, 1), (0, 0, 1, 1), (1, 1, 0, 1)]
program['position'] = [(-1, -1),   (-1, +1),   (+1, -1),   (+1, +1)]

# Enter mainloop
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = lighted-cube
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: Nicolas P .Rougier
# Date:   04/03/2014
# -----------------------------------------------------------------------------
import sys
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut

from vispy.gloo import Program, VertexBuffer, IndexBuffer
from vispy.util.transforms import perspective, translate, rotate
from vispy.util.cube import cube


vertex = """
uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
uniform vec4 u_color;

attribute vec3 position;
attribute vec3 normal;
attribute vec4 color;

varying vec3 v_position;
varying vec3 v_normal;
varying vec4 v_color;

void main()
{
    v_normal = normal;
    v_position = position;
    v_color = color * u_color;
    gl_Position = u_projection * u_view * u_model * vec4(position,1.0);
}
"""

fragment = """
uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_normal;

uniform vec3 u_light_intensity;
uniform vec3 u_light_position;

varying vec3 v_position;
varying vec3 v_normal;
varying vec4 v_color;

void main()
{
    // Calculate normal in world coordinates
    vec3 normal = normalize(u_normal * vec4(v_normal,1.0)).xyz;

    // Calculate the location of this fragment (pixel) in world coordinates
    vec3 position = vec3(u_view*u_model * vec4(v_position, 1));

    // Calculate the vector from this pixels surface to the light source
    vec3 surfaceToLight = u_light_position - position;

    // Calculate the cosine of the angle of incidence (brightness)
    float brightness = dot(normal, surfaceToLight) /
                      (length(surfaceToLight) * length(normal));
    brightness = max(min(brightness,1.0),0.0);

    // Calculate final color of the pixel, based on:
    // 1. The angle of incidence: brightness
    // 2. The color/intensities of the light: light.intensities
    // 3. The texture and texture coord: texture(tex, fragTexCoord)

    gl_FragColor = v_color * brightness * vec4(u_light_intensity, 1);
}
"""


def display():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
    # program.draw(gl.GL_TRIANGLES, indices)

    # Filled cube
    gl.glDisable(gl.GL_BLEND)
    gl.glEnable(gl.GL_DEPTH_TEST)
    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)
    program['u_color'] = 1, 1, 1, 1
    program.draw(gl.GL_TRIANGLES, faces)

    # Outlined cube
    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)
    gl.glEnable(gl.GL_BLEND)
    gl.glDepthMask(gl.GL_FALSE)
    program['u_color'] = 0, 0, 0, 1
    program.draw(gl.GL_LINES, outline)
    gl.glDepthMask(gl.GL_TRUE)

    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)
    projection = perspective(45.0, width / float(height), 2.0, 10.0)
    program['u_projection'] = projection


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def timer(fps):
    global theta, phi
    theta += .5
    phi += .5
    model = np.eye(4, dtype=np.float32)
    rotate(model, theta, 0, 0, 1)
    rotate(model, phi, 0, 1, 0)
    normal = np.array(np.matrix(np.dot(view, model)).I.T)
    program['u_model'] = model
    program['u_normal'] = normal
    glut.glutTimerFunc(1000 / fps, timer, fps)
    glut.glutPostRedisplay()


# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
glut.glutCreateWindow('Lighted Cube')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutTimerFunc(1000 / 60, timer, 60)

# Build cube data
# --------------------------------------
V, F, O = cube()
vertices = VertexBuffer(V)
faces = IndexBuffer(F)
outline = IndexBuffer(O)

# Build view, model, projection & normal
# --------------------------------------
view = np.eye(4, dtype=np.float32)
model = np.eye(4, dtype=np.float32)
projection = np.eye(4, dtype=np.float32)
translate(view, 0, 0, -5)
normal = np.array(np.matrix(np.dot(view, model)).I.T)

# Build program
# --------------------------------------
program = Program(vertex, fragment)
program.bind(vertices)
program["u_light_position"] = 2, 2, 2
program["u_light_intensity"] = 1, 1, 1
program["u_model"] = model
program["u_view"] = view
program["u_normal"] = normal
phi, theta = 0, 0

# OpenGL initalization
# --------------------------------------
gl.glClearColor(0.30, 0.30, 0.35, 1.00)
gl.glEnable(gl.GL_DEPTH_TEST)
gl.glPolygonOffset(1, 1)
gl.glEnable(gl.GL_LINE_SMOOTH)
gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
gl.glLineWidth(0.75)

# Start
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = outlined-cube
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: Nicolas P .Rougier
# Date:   04/03/2014
# -----------------------------------------------------------------------------
import sys
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut

from vispy.gloo import Program, VertexBuffer, IndexBuffer
from vispy.util.transforms import perspective, translate, rotate
from vispy.util.cube import cube

vertex = """
uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
uniform vec4 u_color;
attribute vec3 position;
attribute vec4 color;
varying vec4 v_color;
void main()
{
    v_color = u_color * color;
    gl_Position = u_projection * u_view * u_model * vec4(position,1.0);
}
"""

fragment = """
varying vec4 v_color;
void main()
{
    gl_FragColor = v_color;
}
"""


def display():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

    # Filled cube
    gl.glDisable(gl.GL_BLEND)
    gl.glEnable(gl.GL_DEPTH_TEST)
    gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)
    program['u_color'] = 1, 1, 1, 1
    program.draw(gl.GL_TRIANGLES, faces)

    # Outlined cube
    gl.glDisable(gl.GL_POLYGON_OFFSET_FILL)
    gl.glEnable(gl.GL_BLEND)
    gl.glDepthMask(gl.GL_FALSE)
    program['u_color'] = 0, 0, 0, 1
    program.draw(gl.GL_LINES, outline)
    gl.glDepthMask(gl.GL_TRUE)

    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)
    projection = perspective(45.0, width / float(height), 2.0, 10.0)
    program['u_projection'] = projection


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def timer(fps):
    global theta, phi
    theta += .5
    phi += .5
    model = np.eye(4, dtype=np.float32)
    rotate(model, theta, 0, 0, 1)
    rotate(model, phi, 0, 1, 0)
    program['u_model'] = model
    glut.glutTimerFunc(1000 / fps, timer, fps)
    glut.glutPostRedisplay()


# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
glut.glutCreateWindow('Rotating Cube')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutTimerFunc(1000 / 60, timer, 60)

# Build cube data
# --------------------------------------
V, I, O = cube()
vertices = VertexBuffer(V)
faces = IndexBuffer(I)
outline = IndexBuffer(O)

# Build program
# --------------------------------------
program = Program(vertex, fragment)
program.bind(vertices)

# Build view, model, projection & normal
# --------------------------------------
view = np.eye(4, dtype=np.float32)
model = np.eye(4, dtype=np.float32)
projection = np.eye(4, dtype=np.float32)
translate(view, 0, 0, -5)
program['u_model'] = model
program['u_view'] = view
phi, theta = 0, 0

# OpenGL initalization
# --------------------------------------
gl.glClearColor(0.30, 0.30, 0.35, 1.00)
gl.glEnable(gl.GL_DEPTH_TEST)
gl.glPolygonOffset(1, 1)
gl.glEnable(gl.GL_LINE_SMOOTH)
gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
gl.glLineWidth(0.75)

# Start
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = rotating-quad
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: Nicolas P .Rougier
# Date:   04/03/2014
# -----------------------------------------------------------------------------
import sys
import OpenGL.GL as gl
import OpenGL.GLUT as glut
from vispy.gloo import Program

vertex = """
    uniform float theta;
    attribute vec4 color;
    attribute vec2 position;
    varying vec4 v_color;
    void main()
    {
        float ct = cos(theta);
        float st = sin(theta);
        float x = 0.75* (position.x*ct - position.y*st);
        float y = 0.75* (position.x*st + position.y*ct);
        gl_Position = vec4(x, y, 0.0, 1.0);
        v_color = color;
    } """

fragment = """
    varying vec4 v_color;
    void main()
    {
        gl_FragColor = v_color;
    } """


def display():
    gl.glClearColor(1, 1, 1, 1)
    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    program.draw(gl.GL_TRIANGLE_STRIP)
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def timer(fps):
    global clock
    clock += 0.001 * 1000.0 / fps
    program['theta'] = clock
    glut.glutTimerFunc(1000 / fps, timer, fps)
    glut.glutPostRedisplay()

# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA)
glut.glutCreateWindow('Hello world!')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutTimerFunc(1000 / 60, timer, 60)

# Build program & data
# ----------------------------------------
program = Program(vertex, fragment, count=4)
program['color'] = [(1, 0, 0, 1), (0, 1, 0, 1), (0, 0, 1, 1), (1, 1, 0, 1)]
program['position'] = [(-1, -1),   (-1, +1),   (+1, -1),   (+1, +1)]
clock = 0

# Enter mainloop
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = textured-cube
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: Nicolas P .Rougier
# Date:   04/03/2014
# -----------------------------------------------------------------------------
import sys
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut

from vispy.gloo import Program, VertexBuffer, IndexBuffer
from vispy.util.transforms import perspective, translate, rotate
from vispy.util.cube import cube


vertex = """
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform sampler2D texture;

attribute vec3 position;
attribute vec2 texcoord;

varying vec2 v_texcoord;
void main()
{
    gl_Position = projection * view * model * vec4(position,1.0);
    v_texcoord = texcoord;
}
"""

fragment = """
uniform sampler2D texture;
varying vec2 v_texcoord;
void main()
{
    gl_FragColor = texture2D(texture, v_texcoord);
}
"""


def checkerboard(grid_num=8, grid_size=32):
    row_even = grid_num / 2 * [0, 1]
    row_odd = grid_num / 2 * [1, 0]
    Z = np.row_stack(grid_num / 2 * (row_even, row_odd)).astype(np.uint8)
    return 255 * Z.repeat(grid_size, axis=0).repeat(grid_size, axis=1)


def display():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
    program.draw(gl.GL_TRIANGLES, indices)
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)
    projection = perspective(45.0, width / float(height), 2.0, 10.0)
    program['projection'] = projection


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()


def timer(fps):
    global theta, phi
    theta += .5
    phi += .5
    model = np.eye(4, dtype=np.float32)
    rotate(model, theta, 0, 0, 1)
    rotate(model, phi, 0, 1, 0)
    program['model'] = model
    glut.glutTimerFunc(1000 / fps, timer, fps)
    glut.glutPostRedisplay()


# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
glut.glutCreateWindow('Rotating Cube')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)
glut.glutTimerFunc(1000 / 60, timer, 60)

# Build cube data
# --------------------------------------
V, I, _ = cube()
vertices = VertexBuffer(V)
indices = IndexBuffer(I)

# Build program
# --------------------------------------
program = Program(vertex, fragment)
program.bind(vertices)

# Build view, model, projection & normal
# --------------------------------------
view = np.eye(4, dtype=np.float32)
model = np.eye(4, dtype=np.float32)
projection = np.eye(4, dtype=np.float32)
translate(view, 0, 0, -5)
program['model'] = model
program['view'] = view
program['texture'] = checkerboard()

phi, theta = 0, 0

# OpenGL initalization
# --------------------------------------
gl.glClearColor(0.30, 0.30, 0.35, 1.00)
gl.glEnable(gl.GL_DEPTH_TEST)

# Start
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = textured-quad
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Nicolas P. Rougier. All rights reserved.
# Distributed under the terms of the new BSD License.
# -----------------------------------------------------------------------------
import sys
import numpy as np
import OpenGL.GL as gl
import OpenGL.GLUT as glut
from vispy.gloo import Program

vertex = """
    attribute vec2 position;
    attribute vec2 texcoord;
    varying vec2 v_texcoord;
    void main()
    {
        gl_Position = vec4(position, 0.0, 1.0);
        v_texcoord = texcoord;
    } """

fragment = """
    uniform sampler2D texture;
    varying vec2 v_texcoord;
    void main()
    {
        gl_FragColor = texture2D(texture, v_texcoord);
    } """


def checkerboard(grid_num=8, grid_size=32):
    row_even = grid_num / 2 * [0, 1]
    row_odd = grid_num / 2 * [1, 0]
    Z = np.row_stack(grid_num / 2 * (row_even, row_odd)).astype(np.uint8)
    return 255 * Z.repeat(grid_size, axis=0).repeat(grid_size, axis=1)


def display():
    gl.glClearColor(1, 1, 1, 1)
    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    program.draw(gl.GL_TRIANGLE_STRIP)
    glut.glutSwapBuffers()


def reshape(width, height):
    gl.glViewport(0, 0, width, height)


def keyboard(key, x, y):
    if key == '\033':
        sys.exit()

# Glut init
# --------------------------------------
glut.glutInit(sys.argv)
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA)
glut.glutCreateWindow('Textured quad')
glut.glutReshapeWindow(512, 512)
glut.glutReshapeFunc(reshape)
glut.glutKeyboardFunc(keyboard)
glut.glutDisplayFunc(display)

# Build program & data
# ----------------------------------------
program = Program(vertex, fragment, count=4)
program['position'] = [(-1, -1),   (-1, +1),   (+1, -1),   (+1, +1)]
program['texcoord'] = [(0, 0), (1, 0), (0, 1), (1, 1)]
program['texture'] = checkerboard()

# Enter mainloop
# --------------------------------------
glut.glutMainLoop()

########NEW FILE########
__FILENAME__ = make
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for mo

"""
Convenience tools for vispy developers

    make.py command [arg]

"""

from __future__ import division, print_function

import sys
import os
import time
import shutil
import subprocess
import re

# Save where we came frome and where this module lives
START_DIR = os.path.abspath(os.getcwd())
THIS_DIR = os.path.abspath(os.path.dirname(__file__))

# Get root directory of the package, by looking for setup.py
for subdir in ['.', '..']:
    ROOT_DIR = os.path.abspath(os.path.join(THIS_DIR, subdir))
    if os.path.isfile(os.path.join(ROOT_DIR, 'setup.py')):
        break
else:
    sys.exit('Cannot find root dir')


# Define directories and repos of interest
DOC_DIR = os.path.join(ROOT_DIR, 'doc')
#
WEBSITE_DIR = os.path.join(ROOT_DIR, '_website')
WEBSITE_REPO = 'git@github.com:vispy/vispy-website'
#
PAGES_DIR = os.path.join(ROOT_DIR, '_gh-pages')
PAGES_REPO = 'git@github.com:vispy/vispy.github.com.git'
#
IMAGES_DIR = os.path.join(ROOT_DIR, '_images')
IMAGES_REPO = 'git@github.com:vispy/images.git'


class Maker:

    """ Collection of make commands.

    To create a new command, create a method with a short name, give it
    a docstring, and make it do something useful :)

    """

    def __init__(self, argv):
        """ Parse command line arguments. """
        # Get function to call
        if len(argv) == 1:
            func, arg = self.help, ''
        else:
            command = argv[1].strip()
            arg = ' '.join(argv[2:]).strip()
            func = getattr(self, command, None)
        # Call it if we can
        if func is not None:
            func(arg)
        else:
            sys.exit('Invalid command: "%s"' % command)

    def help(self, arg):
        """ Show help message. Use 'help X' to get more help on command X. """
        if arg:
            command = arg
            func = getattr(self, command, None)
            if func is not None:
                doc = getattr(self, command).__doc__.strip()
                print('make.py %s [arg]\n\n        %s' % (command, doc))
                print()
            else:
                sys.exit('Cannot show help on unknown command: "%s"' % command)

        else:
            print(__doc__.strip() + '\n\nCommands:\n')
            for command in sorted(dir(self)):
                if command.startswith('_'):
                    continue
                preamble = command.ljust(11)  # longest command is 9 or 10
                #doc = getattr(self, command).__doc__.splitlines()[0].strip()
                doc = getattr(self, command).__doc__.strip()
                print(' %s  %s' % (preamble, doc))
            print()

    def doc(self, arg):
        """ Make API documentation. Subcommands:
                * html - build html
                * show - show the docs in your browser
        """
        # Prepare
        build_dir = os.path.join(DOC_DIR, '_build')
        if not arg:
            return self.help('doc')
        # Go
        if 'html' == arg:
            sphinx_clean(build_dir)
            sphinx_build(DOC_DIR, build_dir)
        elif 'show' == arg:
            sphinx_show(os.path.join(build_dir, 'html'))
        else:
            sys.exit('Command "doc" does not have subcommand "%s"' % arg)

    def website(self, arg):
        """ Build website. Website source is put in '_website'. Subcommands:
                * html - build html
                * show - show the website in your browser
                * upload - upload (commit+push) the resulting html to github
        """
        # Prepare
        build_dir = os.path.join(WEBSITE_DIR, '_build')
        html_dir = os.path.join(build_dir, 'html')
        if not arg:
            return self.help('website')

        # Clone repo for website if needed, make up-to-date otherwise
        if not os.path.isdir(WEBSITE_DIR):
            os.chdir(ROOT_DIR)
            sh("git clone %s %s" % (WEBSITE_REPO, WEBSITE_DIR))
        else:
            print('Updating website repo')
            os.chdir(WEBSITE_DIR)
            sh('git pull')

        # Go
        if 'html' == arg:
            sphinx_clean(build_dir)
            sphinx_build(WEBSITE_DIR, build_dir)
            sphinx_copy_pages(html_dir, PAGES_DIR, PAGES_REPO)
        elif 'show' == arg:
            sphinx_show(PAGES_DIR)
        elif 'upload' == arg:
            sphinx_upload(PAGES_DIR)
            print()
            print(
                "Do not forget to also commit+push your changes to '_website'")
        else:
            sys.exit('Command "website" does not have subcommand "%s"' % arg)

    def test(self, arg):
        """ Run tests:
                * full - run all tests
                * nose - run nose tests (also for each backend)
                * any backend name (e.g. pyside, pyqt4, glut, sdl2, etc.) - 
                  run tests for the given backend
                * nobackend - run tests that do not require a backend
                * extra - run extra tests (line endings and style)
                * lineendings - test line ending consistency
                * flake - flake style testing (PEP8 and more)
        """
        if not arg:
            return self.help('test')
        from vispy import test
        try:
            test(*(arg.split()))
        except Exception:
            raise SystemExit(1)

    def images(self, arg):
        """ Create images (screenshots). Subcommands:
                * gallery - make screenshots for the gallery
                * test - make screenshots for testing
                * upload - upload the images repository
        """
        if not arg:
            return self.help('images')

        # Clone repo for images if needed, make up-to-date otherwise
        if not os.path.isdir(IMAGES_DIR):
            os.chdir(ROOT_DIR)
            sh("git clone %s %s" % (IMAGES_REPO, IMAGES_DIR))
        else:
            print('Updating images repo')
            os.chdir(IMAGES_DIR)
            sh('git pull')

        # Create subdirs if needed
        for subdir in ['gallery', 'thumbs', 'test']:
            subdir = os.path.join(IMAGES_DIR, subdir)
            if not os.path.isdir(subdir):
                os.mkdir(subdir)

        # Go
        if arg == 'gallery':
            self._images_screenshots()
            self._images_thumbnails()
        elif arg == 'test':
            sys.exit('images test command not yet implemented')
        elif arg == 'upload':
            sphinx_upload(IMAGES_DIR)
        else:
            sys.exit('Command "website" does not have subcommand "%s"' % arg)

    def _images_screenshots(self):
        # Prepare
        import imp
        from vispy.util.dataio import imsave
        from vispy.gloo import _screenshot
        examples_dir = os.path.join(ROOT_DIR, 'examples')
        gallery_dir = os.path.join(IMAGES_DIR, 'gallery')

        # Process all files ...
        for filename, name in get_example_filenames(examples_dir):
            name = name.replace('/', '__')  # We use flat names
            imagefilename = os.path.join(gallery_dir, name + '.png')

            # Check if should make a screenshot
            frames = []
            lines = open(filename, 'rt').read().splitlines()
            for line in lines[:10]:
                if line.startswith('# vispy:') and 'gallery' in line:
                    # Get what frames to grab
                    frames = line.split('gallery')[1].strip()
                    frames = frames or '0'
                    frames = [int(i) for i in frames.split(':')]
                    if not frames:
                        frames = [0]
                    if len(frames) > 1:
                        frames = list(range(*frames))
                    break
            else:
                continue  # gallery hint not found

            # Check if we need to take a sceenshot
            if os.path.isfile(imagefilename):
                print('Screenshot for %s already present (skip).' % name)
                continue

            # Import module and prepare
            m = imp.load_source('vispy_example_' + name, filename)
            m.done = False
            m.frame = -1
            m.images = []

            # Create a canvas and grab a screenshot
            def grabscreenshot(event):
                if m.done:
                    return  # Grab only once
                m.frame += 1
                if m.frame in frames:
                    frames.remove(m.frame)
                    print('Grabbing a screenshot for %s' % name)
                    im = _screenshot((0, 0, c.size[0], c.size[1]))
                    m.images.append(im)
                if not frames:
                    m.done = True
            c = m.Canvas()
            c.events.paint.connect(grabscreenshot)
            c.show()
            while not m.done:
                m.app.process_events()
            c.close()

            # Save
            imsave(imagefilename, m.images[0])  # Alwats show one image
            if len(m.images) > 1:
                import imageio  # multiple gif not properly supported yet
                imageio.mimsave(imagefilename[:-3] + '.gif', m.images)

    def _images_thumbnails(self):
        from vispy.util.dataio import imsave, imread
        from skimage.transform import resize
        import numpy as np
        gallery_dir = os.path.join(IMAGES_DIR, 'gallery')
        thumbs_dir = os.path.join(IMAGES_DIR, 'thumbs')
        for fname in os.listdir(gallery_dir):
            filename1 = os.path.join(gallery_dir, fname)
            filename2 = os.path.join(thumbs_dir, fname)
            #
            im = imread(filename1)
            newx = 200
            newy = int(newx * im.shape[0] / im.shape[1])
            im = (resize(im, (newy, newx), 2) * 255).astype(np.uint8)
            imsave(filename2, im)
            print('Created thumbnail %s' % fname)

    def copyright(self, arg):
        """ Update all copyright notices to the current year.
        """
        # Initialize
        TEMPLATE = "# Copyright (c) %i, Vispy Development Team."
        CURYEAR = int(time.strftime('%Y'))
        OLDTEXT = TEMPLATE % (CURYEAR - 1)
        NEWTEXT = TEMPLATE % CURYEAR
        # Initialize counts
        count_ok, count_replaced = 0, 0

        # Processing the whole root directory
        for dirpath, dirnames, filenames in os.walk(ROOT_DIR):
            # Check if we should skip this directory
            reldirpath = os.path.relpath(dirpath, ROOT_DIR)
            if reldirpath[0] in '._' or reldirpath.endswith('__pycache__'):
                continue
            if os.path.split(reldirpath)[0] in ('build', 'dist'):
                continue
            # Process files
            for fname in filenames:
                if not fname.endswith('.py'):
                    continue
                # Open and check
                filename = os.path.join(dirpath, fname)
                text = open(filename, 'rt').read()
                if NEWTEXT in text:
                    count_ok += 1
                elif OLDTEXT in text:
                    text = text.replace(OLDTEXT, NEWTEXT)
                    open(filename, 'wt').write(text)
                    print(
                        '  Update copyright year in %s/%s' %
                        (reldirpath, fname))
                    count_replaced += 1
                elif 'copyright' in text[:200].lower():
                    print(
                        '  Unknown copyright mentioned in %s/%s' %
                        (reldirpath, fname))
        # Report
        print('Replaced %i copyright statements' % count_replaced)
        print('Found %i copyright statements up to date' % count_ok)


# Functions used by the maker

if sys.version_info[0] < 3:
    input = raw_input  # noqa


def sh(cmd):
    """Execute command in a subshell, return status code."""
    return subprocess.check_call(cmd, shell=True)


def sh2(cmd):
    """Execute command in a subshell, return stdout.
    Stderr is unbuffered from the subshell."""
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
    out = p.communicate()[0]
    retcode = p.returncode
    if retcode:
        raise subprocess.CalledProcessError(retcode, cmd)
    else:
        return out.rstrip().decode('utf-8', 'ignore')


def sphinx_clean(build_dir):
    if os.path.isdir(build_dir):
        shutil.rmtree(build_dir)
    os.mkdir(build_dir)
    print('Cleared build directory.')


def sphinx_build(src_dir, build_dir):
    import sphinx
    sphinx.main(('sphinx-build',  # Dummy
                 '-b', 'html',
                 '-d', os.path.join(build_dir, 'doctrees'),
                 src_dir,  # Source
                 os.path.join(build_dir, 'html'),  # Dest
                 ))
    print("Build finished. The HTML pages are in %s/html." % build_dir)


def sphinx_show(html_dir):
    index_html = os.path.join(html_dir, 'index.html')
    if not os.path.isfile(index_html):
        sys.exit('Cannot show pages, build the html first.')
    import webbrowser
    webbrowser.open_new_tab(index_html)


def sphinx_copy_pages(html_dir, pages_dir, pages_repo):
    # Create the pages repo if needed
    if not os.path.isdir(pages_dir):
        os.chdir(ROOT_DIR)
        sh("git clone %s %s" % (pages_repo, pages_dir))
    # Ensure that its up to date
    os.chdir(pages_dir)
    sh('git checkout master -q')
    sh('git pull -q')
    # This is pretty unforgiving: we unconditionally nuke the destination
    # directory, and then copy the html tree in there
    tmp_git_dir = os.path.join(ROOT_DIR, pages_dir + '_git')
    shutil.move(os.path.join(pages_dir, '.git'), tmp_git_dir)
    try:
        shutil.rmtree(pages_dir)
        shutil.copytree(html_dir, pages_dir)
        shutil.move(tmp_git_dir, os.path.join(pages_dir, '.git'))
    finally:
        if os.path.isdir(tmp_git_dir):
            shutil.rmtree(tmp_git_dir)
    # Copy individual files
    for fname in ['CNAME', 'README.md', 'conf.py', '.nojekyll', 'Makefile']:
        shutil.copyfile(os.path.join(WEBSITE_DIR, fname),
                        os.path.join(pages_dir, fname))
    # Messages
    os.chdir(pages_dir)
    sh('git status')
    print()
    print("Website copied to _gh-pages. Above you can see its status:")
    print("  Run 'make.py website show' to view.")
    print("  Run 'make.py website upload' to commit and push.")


def sphinx_upload(repo_dir):
    # Check head
    os.chdir(repo_dir)
    status = sh2('git status | head -1')
    branch = re.match('\# On branch (.*)$', status).group(1)
    if branch != 'master':
        e = 'On %r, git branch is %r, MUST be "master"' % (repo_dir,
                                                           branch)
        raise RuntimeError(e)
    # Show repo and ask confirmation
    print()
    print('You are about to commit to:')
    sh('git config --get remote.origin.url')
    print()
    print('Most recent 3 commits:')
    sys.stdout.flush()
    sh('git --no-pager log --oneline -n 3')
    ok = input('Are you sure you want to commit and push? (y/[n]): ')
    ok = ok or 'n'
    # If ok, add, commit, push
    if ok.lower() == 'y':
        sh('git add .')
        sh('git commit -am"Update (automated commit)"')
        print()
        sh('git push')


def get_example_filenames(example_dir):
    """ Yield (filename, name) elements for all examples. The examples
    are organized in directories, therefore the name can contain a
    forward slash.
    """
    for (dirpath, dirnames, filenames) in os.walk(example_dir):
        for fname in filenames:
            if not fname.endswith('.py'):
                continue
            filename = os.path.join(dirpath, fname)
            name = filename[len(example_dir):].lstrip('/\\')[:-3]
            name = name.replace('\\', '/')
            yield filename, name


if __name__ == '__main__':
    try:
        Maker(sys.argv)
        # Maker(('bla', 'gallery'))
    finally:
        os.chdir(START_DIR)

########NEW FILE########
__FILENAME__ = __main__

from __future__ import print_function, division

import os
import sys
from make import Maker

START_DIR = os.path.abspath(os.getcwd())

try:
    Maker(sys.argv)
finally:
    os.chdir(START_DIR)

########NEW FILE########
__FILENAME__ = application
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""
Implements the global singleton app object.

"""

from __future__ import division

import os
import sys

from. import backends
from .backends import BACKENDS, BACKENDMAP, ATTEMPTED_BACKENDS
from .. import config
from .base import BaseApplicationBackend as ApplicationBackend  # noqa
from ..util import logger


class Application(object):
    """Representation of the vispy application

    This wraps a native GUI application instance. Vispy has a default
    instance of this class at vispy.app.default_app.

    Parameters
    ----------
    backend : str | None
        Backend to use. See ``use()`` for details.

    Notes
    -----
    There are multiple stages for an Application object:
        * Backend-less - the state when it is just initialized
        * Backend selected - use() has been successfully called. Note that
          the Canvas calls use() without arguments right before creating
          its backend widget.
        * Native application is created - the Canvas probes the
          Application.native property to ensure that there is a native
          application right before a native widget is created.
    """

    def __init__(self, backend=None):
        self._backend_module = None
        self._backend = None
        if backend is not None:
            self.use(backend)

    def __repr__(self):
        name = self.backend_name
        if not name:
            return '<Vispy app with no backend>'
        else:
            return '<Vispy app, wrapping the %s GUI toolkit>' % name

    @property
    def backend_name(self):
        """ The name of the GUI backend that this app wraps.
        """
        if self._backend is not None:
            return self._backend._vispy_get_backend_name()
        else:
            return ''

    @property
    def backend_module(self):
        """ The module object that defines the backend.
        """
        return self._backend_module

    def process_events(self):
        """ Process all pending GUI events. If the mainloop is not
        running, this should be done regularly to keep the visualization
        interactive and to keep the event system going.
        """
        return self._backend._vispy_process_events()

    def create(self):
        """ Create the native application.
        """
        self.use()  # Ensure it exists
        self.native

    def run(self):
        """ Enter the native GUI event loop.
        """
        return self._backend._vispy_run()

    def quit(self):
        """ Quit the native GUI event loop.
        """
        return self._backend._vispy_quit()

    @property
    def native(self):
        """ The native GUI application instance.
        """
        return self._backend._vispy_get_native_app()

    def use(self, backend_name=None):
        """Select a backend by name.

        If the backend name is omitted, will choose a suitable backend
        automatically. It is an error to try to select a particular backend
        if one is already selected. Available backends: 'PySide', 'PyQt4',
        'Glut', 'Glfw', 'Pyglet', 'qt'. The latter will use PySide or
        PyQt4, whichever works.

        If a backend name is provided, and that backend could not be
        loaded, an error is raised.

        If no backend name is provided, this function will first check
        if the GUI toolkit corresponding to each backend is already
        imported, and try that backend first. If this is unsuccessful,
        it will try the 'default_backend' provided in the vispy config.
        If still not succesful, it will try each backend in a
        predetermined order.

        """
        test_name = os.getenv('_VISPY_TESTING_TYPE', None)
        if backend_name is not None:
            if backend_name.lower() not in BACKENDMAP:
                raise ValueError('backend_name must be one of %s or None, not '
                                 '%s' % (BACKENDMAP, backend_name))
        # See if we're in a specific testing mode
        elif test_name is not None:
            backend_name = test_name.lower()
            assert backend_name in BACKENDMAP

        # Should we try and load any backend, or just this specific one?
        try_others = backend_name is None

        # Check if already selected
        if self._backend is not None:
            names = self.backend_name.lower().replace('(', ' ').strip(') ')
            names = [name for name in names.split(' ') if name]
            if backend_name and backend_name.lower() not in names:
                raise RuntimeError('Can only select a backend once.')
            return

        # Get backends to try ...
        backends_to_try = []
        if not try_others:
            # We should never hit this, since we check above
            assert backend_name.lower() in BACKENDMAP.keys()
            # Add it
            backends_to_try.append(backend_name.lower())
        else:
            # See if a backend is loaded
            for name, module_name, native_module_name in BACKENDS:
                if native_module_name and native_module_name in sys.modules:
                    backends_to_try.append(name.lower())
            # See if a default is given
            default_backend = config['default_backend'].lower()
            if default_backend.lower() in BACKENDMAP.keys():
                if default_backend not in backends_to_try:
                    backends_to_try.append(default_backend)
            # After this, try each one
            for name, module_name, native_module_name in BACKENDS:
                name = name.lower()
                if name not in backends_to_try:
                    backends_to_try.append(name)

        # Now try each one
        for key in backends_to_try:
            name, module_name, native_module_name = BACKENDMAP[key]
            ATTEMPTED_BACKENDS.append(name)
            mod_name = 'backends.' + module_name
            __import__(mod_name, globals(), level=1)
            mod = getattr(backends, module_name)
            if not mod.available:
                msg = ('Could not import backend "%s":\n%s'
                       % (name, str(mod.why_not)))
                if not try_others:
                    raise RuntimeError(msg)
                else:
                    logger.info(msg)
            else:
                # Success!
                self._backend_module = mod
                logger.info('Selected backend %s' % module_name)
                break
        else:
            raise RuntimeError('Could not import any of the backends.')

        # Store classes for app backend and canvas backend
        self._backend = self.backend_module.ApplicationBackend()

########NEW FILE########
__FILENAME__ = _glfw
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
"""
vispy backend for glfw.
"""

# Note: to install GLFW on Ubuntu:
# $ git clone git://github.com/glfw/glfw.git
# $ cd glfw
# $ cmake -DBUILD_SHARED_LIBS=true -DGLFW_BUILD_EXAMPLES=false \
#         -DGLFW_BUILD_TESTS=false -DGLFW_BUILD_DOCS=false .
# $ make
# $ sudo make install
# $ sudo apt-get -qq install libx11-dev

# On OSX, consider using brew.

from __future__ import division

import atexit
from time import sleep

from ..base import (BaseApplicationBackend, BaseCanvasBackend,
                    BaseTimerBackend, BaseSharedContext)
from ...util import keys
from ...util.ptime import time


# -------------------------------------------------------------------- init ---

try:
    from ...ext import glfw

    # Map native keys to vispy keys
    KEYMAP = {
        glfw.GLFW_KEY_LEFT_SHIFT: keys.SHIFT,
        glfw.GLFW_KEY_RIGHT_SHIFT: keys.SHIFT,
        glfw.GLFW_KEY_LEFT_CONTROL: keys.CONTROL,
        glfw.GLFW_KEY_RIGHT_CONTROL: keys.CONTROL,
        glfw.GLFW_KEY_LEFT_ALT: keys.ALT,
        glfw.GLFW_KEY_RIGHT_ALT: keys.ALT,
        glfw.GLFW_KEY_LEFT_SUPER: keys.META,
        glfw.GLFW_KEY_RIGHT_SUPER: keys.META,

        glfw.GLFW_KEY_LEFT: keys.LEFT,
        glfw.GLFW_KEY_UP: keys.UP,
        glfw.GLFW_KEY_RIGHT: keys.RIGHT,
        glfw.GLFW_KEY_DOWN: keys.DOWN,
        glfw.GLFW_KEY_PAGE_UP: keys.PAGEUP,
        glfw.GLFW_KEY_PAGE_DOWN: keys.PAGEDOWN,

        glfw.GLFW_KEY_INSERT: keys.INSERT,
        glfw.GLFW_KEY_DELETE: keys.DELETE,
        glfw.GLFW_KEY_HOME: keys.HOME,
        glfw.GLFW_KEY_END: keys.END,

        glfw.GLFW_KEY_ESCAPE: keys.ESCAPE,
        glfw.GLFW_KEY_BACKSPACE: keys.BACKSPACE,

        glfw.GLFW_KEY_F1: keys.F1,
        glfw.GLFW_KEY_F2: keys.F2,
        glfw.GLFW_KEY_F3: keys.F3,
        glfw.GLFW_KEY_F4: keys.F4,
        glfw.GLFW_KEY_F5: keys.F5,
        glfw.GLFW_KEY_F6: keys.F6,
        glfw.GLFW_KEY_F7: keys.F7,
        glfw.GLFW_KEY_F8: keys.F8,
        glfw.GLFW_KEY_F9: keys.F9,
        glfw.GLFW_KEY_F10: keys.F10,
        glfw.GLFW_KEY_F11: keys.F11,
        glfw.GLFW_KEY_F12: keys.F12,

        glfw.GLFW_KEY_SPACE: keys.SPACE,
        glfw.GLFW_KEY_ENTER: keys.ENTER,
        '\r': keys.ENTER,
        glfw.GLFW_KEY_TAB: keys.TAB,
    }

    BUTTONMAP = {glfw.GLFW_MOUSE_BUTTON_LEFT: 1,
                 glfw.GLFW_MOUSE_BUTTON_RIGHT: 2,
                 glfw.GLFW_MOUSE_BUTTON_MIDDLE: 3
                 }
except Exception as exp:
    available, testable, why_not, which = False, False, str(exp), None
else:
    available, testable, why_not = True, True, None
    which = 'glfw ' + str(glfw.__version__)

MOD_KEYS = [keys.SHIFT, keys.ALT, keys.CONTROL, keys.META]
_GLFW_INITIALIZED = False
_VP_GLFW_ALL_WINDOWS = []


def _get_glfw_windows():
    wins = list()
    for win in _VP_GLFW_ALL_WINDOWS:
        if isinstance(win, CanvasBackend):
            wins.append(win)
    return wins


# -------------------------------------------------------------- capability ---

capability = dict(  # things that can be set by the backend
    title=True,
    size=True,
    position=True,
    show=True,
    vsync=True,
    resizable=True,
    decorate=True,
    fullscreen=True,
    context=True,
    multi_window=True,
    scroll=True,
)


# ------------------------------------------------------- set_configuration ---

def _set_config(c):
    """Set gl configuration for GLFW """
    glfw.glfwWindowHint(glfw.GLFW_RED_BITS, c['red_size'])
    glfw.glfwWindowHint(glfw.GLFW_GREEN_BITS, c['green_size'])
    glfw.glfwWindowHint(glfw.GLFW_BLUE_BITS, c['blue_size'])
    glfw.glfwWindowHint(glfw.GLFW_ALPHA_BITS, c['alpha_size'])

    glfw.glfwWindowHint(glfw.GLFW_ACCUM_RED_BITS, 0)
    glfw.glfwWindowHint(glfw.GLFW_ACCUM_GREEN_BITS, 0)
    glfw.glfwWindowHint(glfw.GLFW_ACCUM_BLUE_BITS, 0)
    glfw.glfwWindowHint(glfw.GLFW_ACCUM_ALPHA_BITS, 0)

    glfw.glfwWindowHint(glfw.GLFW_DEPTH_BITS, c['depth_size'])
    glfw.glfwWindowHint(glfw.GLFW_STENCIL_BITS, c['stencil_size'])
    #glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, c['major_version'])
    #glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, c['minor_version'])
    #glfw.glfwWindowHint(glfw.GLFW_SRGB_CAPABLE, c['srgb'])
    glfw.glfwWindowHint(glfw.GLFW_SAMPLES, c['samples'])
    glfw.glfwWindowHint(glfw.GLFW_STEREO, c['stereo'])
    if not c['double_buffer']:
        raise RuntimeError('GLFW must double buffer, consider using a '
                           'different backend, or using double buffering')


class SharedContext(BaseSharedContext):
    _backend = 'glfw'


# ------------------------------------------------------------- application ---

class ApplicationBackend(BaseApplicationBackend):

    def __init__(self):
        BaseApplicationBackend.__init__(self)
        self._timers = list()

    def _add_timer(self, timer):
        if timer not in self._timers:
            self._timers.append(timer)

    def _vispy_get_backend_name(self):
        return 'Glfw'

    def _vispy_process_events(self):
        glfw.glfwPollEvents()
        for timer in self._timers:
            timer._tick()
        wins = _get_glfw_windows()
        for win in wins:
            if win._needs_draw:
                win._needs_draw = False
                win._on_draw()

    def _vispy_run(self):
        wins = _get_glfw_windows()
        while all(w._id is not None and not glfw.glfwWindowShouldClose(w._id)
                  for w in wins):
            self._vispy_process_events()
        self._vispy_quit()  # to clean up

    def _vispy_quit(self):
        # Close windows
        wins = _get_glfw_windows()
        for win in wins:
            win._vispy_close()
        # tear down timers
        for timer in self._timers:
            timer._vispy_stop()
        self._timers = []

    def _vispy_get_native_app(self):
        global _GLFW_INITIALIZED
        if not _GLFW_INITIALIZED:
            if not glfw.glfwInit():  # only ever call once
                raise OSError('Could not init glfw')
            atexit.register(glfw.glfwTerminate)
            _GLFW_INITIALIZED = True
        return glfw


# ------------------------------------------------------------------ canvas ---

class CanvasBackend(BaseCanvasBackend):

    """ Glfw backend for Canvas abstract class."""

    def __init__(self, **kwargs):
        BaseCanvasBackend.__init__(self, capability, SharedContext)
        title, size, position, show, vsync, resize, dec, fs, context = \
            self._process_backend_kwargs(kwargs)
        # Init GLFW, add window hints, and create window
        if isinstance(context, dict):
            _set_config(context)
            share = None
        else:
            share = context.value
        glfw.glfwWindowHint(glfw.GLFW_REFRESH_RATE, 0)  # highest possible
        glfw.glfwSwapInterval(1 if vsync else 0)
        glfw.glfwWindowHint(glfw.GLFW_RESIZABLE, int(resize))
        glfw.glfwWindowHint(glfw.GLFW_DECORATED, int(dec))
        glfw.glfwWindowHint(glfw.GLFW_VISIBLE, 0)  # start out hidden
        if fs is not False:
            if fs is True:
                monitor = glfw.glfwGetPrimaryMonitor()
            else:
                monitor = glfw.glfwGetMonitors()
                if fs >= len(monitor):
                    raise ValueError('fullscreen must be <= %s'
                                     % len(monitor))
                monitor = monitor[fs]
        else:
            monitor = None
        self._id = glfw.glfwCreateWindow(width=size[0], height=size[1],
                                         title=title, monitor=monitor,
                                         share=share)
        if not self._id:
            raise RuntimeError('Could not create window')
        _VP_GLFW_ALL_WINDOWS.append(self)
        self._mod = list()

        # Register callbacks
        glfw.glfwSetWindowRefreshCallback(self._id, self._on_draw)
        glfw.glfwSetFramebufferSizeCallback(self._id, self._on_resize)
        glfw.glfwSetKeyCallback(self._id, self._on_key_press)
        glfw.glfwSetMouseButtonCallback(self._id, self._on_mouse_button)
        glfw.glfwSetScrollCallback(self._id, self._on_mouse_scroll)
        glfw.glfwSetCursorPosCallback(self._id, self._on_mouse_motion)
        glfw.glfwSetWindowCloseCallback(self._id, self._on_close)
        self._vispy_canvas_ = None
        self._needs_draw = False
        self._vispy_set_current()
        if position is not None:
            self._vispy_set_position(*position)
        if show:
            glfw.glfwShowWindow(self._id)

    @property
    def _vispy_context(self):
        """Context to return for sharing"""
        return SharedContext(self._id)

    ####################################
    # Deal with events we get from vispy
    @property
    def _vispy_canvas(self):
        """ The parent canvas/window """
        return self._vispy_canvas_

    @_vispy_canvas.setter
    def _vispy_canvas(self, vc):
        # Init events when the property is set by Canvas
        self._vispy_canvas_ = vc
        if vc is not None:
            self._vispy_set_current()
            self._vispy_canvas.events.initialize()
        return self._vispy_canvas

    def _vispy_warmup(self):
        etime = time() + 0.25
        while time() < etime:
            sleep(0.01)
            self._vispy_set_current()
            self._vispy_canvas.app.process_events()

    def _vispy_set_current(self):
        if self._id is None:
            return
        # Make this the current context
        glfw.glfwMakeContextCurrent(self._id)

    def _vispy_swap_buffers(self):
        if self._id is None:
            return
        # Swap front and back buffer
        glfw.glfwSwapBuffers(self._id)

    def _vispy_set_title(self, title):
        if self._id is None:
            return
        # Set the window title. Has no effect for widgets
        glfw.glfwSetWindowTitle(self._id, title)

    def _vispy_set_size(self, w, h):
        if self._id is None:
            return
        # Set size of the widget or window
        glfw.glfwSetWindowSize(self._id, w, h)

    def _vispy_set_position(self, x, y):
        if self._id is None:
            return
        # Set position of the widget or window. May have no effect for widgets
        glfw.glfwSetWindowPos(self._id, x, y)

    def _vispy_set_visible(self, visible):
        # Show or hide the window or widget
        if self._id is None:
            return
        if visible:
            glfw.glfwShowWindow(self._id)
            # this ensures that the show takes effect
            self._vispy_update()
        else:
            glfw.glfwHideWindow(self._id)

    def _vispy_update(self):
        # Invoke a redraw, passing it on to the canvas
        if self._vispy_canvas is None or self._id is None:
            return
        # Mark that this window wants to be painted on the next loop iter
        self._needs_draw = True

    def _vispy_close(self):
        # Force the window or widget to shut down
        if self._id is not None:
            #glfw.glfwSetWindowShouldClose()  # Does not really cause a close
            self._vispy_set_visible(False)
            self._id, id_ = None, self._id
            glfw.glfwPollEvents()
            glfw.glfwDestroyWindow(id_)

    def _vispy_get_size(self):
        if self._id is None:
            return
        w, h = glfw.glfwGetFramebufferSize(self._id)
        return w, h

    def _vispy_get_position(self):
        if self._id is None:
            return
        x, y = glfw.glfwGetWindowPos(self._id)
        return x, y

    ##########################################
    # Notify vispy of events triggered by GLFW
    def _on_resize(self, _id, w, h):
        if self._vispy_canvas is None:
            return
        self._vispy_canvas.events.resize(size=(w, h))

    def _on_close(self, _id):
        if self._vispy_canvas is None:
            return
        self._vispy_canvas.events.close()

    def _on_draw(self, _id=None):
        if self._vispy_canvas is None or self._id is None:
            return
        self._vispy_set_current()
        self._vispy_canvas.events.paint(region=None)  # (0, 0, w, h))

    def _on_mouse_button(self, _id, button, action, mod):
        if self._vispy_canvas is None and self._id is not None:
            return
        pos = glfw.glfwGetCursorPos(self._id)
        if button < 3:
            # Mouse click event
            button = BUTTONMAP.get(button, 0)
            if action == glfw.GLFW_PRESS:
                fun = self._vispy_mouse_press
            elif action == glfw.GLFW_RELEASE:
                fun = self._vispy_mouse_release
            else:
                return
            fun(pos=pos, button=button, modifiers=self._mod)

    def _on_mouse_scroll(self, _id, x_off, y_off):
        if self._vispy_canvas is None and self._id is not None:
            return
        pos = glfw.glfwGetCursorPos(self._id)
        delta = (float(x_off), float(y_off))
        self._vispy_canvas.events.mouse_wheel(pos=pos, delta=delta,
                                              modifiers=self._mod)

    def _on_mouse_motion(self, _id, x, y):
        if self._vispy_canvas is None:
            return
        self._vispy_mouse_move(pos=(x, y), modifiers=self._mod)

    def _on_key_press(self, _id, key, scancode, action, mod):
        if self._vispy_canvas is None:
            return
        key, text = self._process_key(key)
        if action == glfw.GLFW_PRESS:
            fun = self._vispy_canvas.events.key_press
            down = True
        elif action == glfw.GLFW_RELEASE:
            fun = self._vispy_canvas.events.key_release
            down = False
        else:
            return
        self._process_mod(key, down=down)
        fun(key=key, text=text, modifiers=self._mod)

    def _process_key(self, key):
        if key in KEYMAP:
            return KEYMAP[key], ''
        elif 32 <= key <= 127:
            return keys.Key(chr(key)), chr(key)
        else:
            return None, ''

    def _process_mod(self, key, down):
        """Process (possible) keyboard modifiers

        GLFW provides "mod" with many callbacks, but not (critically) the
        scroll callback, so we keep track on our own here.
        """
        if key in MOD_KEYS:
            if down:
                if key not in self._mod:
                    self._mod.append(key)
            elif key in self._mod:
                self._mod.pop(self._mod.index(key))
        return self._mod


# ------------------------------------------------------------------- timer ---

class TimerBackend(BaseTimerBackend):

    def __init__(self, vispy_timer):
        BaseTimerBackend.__init__(self, vispy_timer)
        vispy_timer._app._backend._add_timer(self)
        self._vispy_stop()

    def _vispy_start(self, interval):
        self._interval = interval
        self._next_time = time() + self._interval

    def _vispy_stop(self):
        self._next_time = float('inf')

    def _tick(self):
        if time() >= self._next_time:
            self._vispy_timer._timeout()
            self._next_time = time() + self._interval

########NEW FILE########
__FILENAME__ = _glut
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""
vispy backend for glut.
"""

from __future__ import division

import sys
from time import sleep, time

from ..base import (BaseApplicationBackend, BaseCanvasBackend,
                    BaseTimerBackend, BaseSharedContext)
from ...util import ptime, keys, logger

# -------------------------------------------------------------------- init ---

try:
    import OpenGL.error
    import OpenGL.GLUT as glut

    # glut.GLUT_ACTIVE_SHIFT: keys.SHIFT,
    # glut.GLUT_ACTIVE_CTRL: keys.CONTROL,
    # glut.GLUT_ACTIVE_ALT: keys.ALT,
    # -1: keys.META,

    # Map native keys to vispy keys
    KEYMAP = {
        -1: keys.SHIFT,
        -2: keys.CONTROL,
        -3: keys.ALT,
        -4: keys.META,

        glut.GLUT_KEY_LEFT: keys.LEFT,
        glut.GLUT_KEY_UP: keys.UP,
        glut.GLUT_KEY_RIGHT: keys.RIGHT,
        glut.GLUT_KEY_DOWN: keys.DOWN,
        glut.GLUT_KEY_PAGE_UP: keys.PAGEUP,
        glut.GLUT_KEY_PAGE_DOWN: keys.PAGEDOWN,

        glut.GLUT_KEY_INSERT: keys.INSERT,
        chr(127): keys.DELETE,
        glut.GLUT_KEY_HOME: keys.HOME,
        glut.GLUT_KEY_END: keys.END,

        chr(27): keys.ESCAPE,
        chr(8): keys.BACKSPACE,

        glut.GLUT_KEY_F1: keys.F1,
        glut.GLUT_KEY_F2: keys.F2,
        glut.GLUT_KEY_F3: keys.F3,
        glut.GLUT_KEY_F4: keys.F4,
        glut.GLUT_KEY_F5: keys.F5,
        glut.GLUT_KEY_F6: keys.F6,
        glut.GLUT_KEY_F7: keys.F7,
        glut.GLUT_KEY_F8: keys.F8,
        glut.GLUT_KEY_F9: keys.F9,
        glut.GLUT_KEY_F10: keys.F10,
        glut.GLUT_KEY_F11: keys.F11,
        glut.GLUT_KEY_F12: keys.F12,

        ' ': keys.SPACE,
        '\r': keys.ENTER,
        '\n': keys.ENTER,
        '\t': keys.TAB,
    }

    BUTTONMAP = {glut.GLUT_LEFT_BUTTON: 1,
                 glut.GLUT_RIGHT_BUTTON: 2,
                 glut.GLUT_MIDDLE_BUTTON: 3
                 }

    def _get_glut_process_func():
        if hasattr(glut, 'glutMainLoopEvent') and bool(glut.glutMainLoopEvent):
            func = glut.glutMainLoopEvent
        elif hasattr(glut, 'glutCheckLoop') and bool(glut.glutCheckLoop):
            func = glut.glutCheckLoop  # Darwin
        else:
            msg = ('Your implementation of GLUT does not allow '
                   'interactivity. Consider installing freeglut.')
            raise RuntimeError(msg)
        return func
except Exception as exp:
    available, testable, why_not, which = False, False, str(exp), None
else:
    available, why_not, testable = True, None, True
    try:
        _get_glut_process_func()
    except RuntimeError:
        testable, why_not = False, 'No process_func'
    which = 'from OpenGL %s' % OpenGL.__version__


_GLUT_INITIALIZED = False
_VP_GLUT_ALL_WINDOWS = []

# -------------------------------------------------------------- capability ---

capability = dict(  # things that can be set by the backend
    title=True,
    size=True,
    position=True,
    show=True,
    vsync=False,
    resizable=False,
    decorate=False,
    fullscreen=True,
    context=False,
    multi_window=False,
    scroll=False,
)


# ------------------------------------------------------- set_configuration ---

def _set_config(config):
    """Set gl configuration"""
    s = ""
    st = '~' if sys.platform == 'darwin' else '='
    ge = '>=' if sys.platform == 'darwin' else '='
    s += "red%s%d " % (ge, config['red_size'])
    s += "green%s%d " % (ge, config['green_size'])
    s += "blue%s%d " % (ge, config['blue_size'])
    s += "alpha%s%d " % (ge, config['alpha_size'])
    s += "depth%s%d " % (ge, config['depth_size'])
    s += "stencil%s%d " % (st, config['stencil_size'])
    s += "samples%s%d " % (st, config['samples']) if config['samples'] else ""
    s += "acca=0 " if sys.platform == 'darwin' else ""
    if sys.platform == 'darwin':
        s += "double=1 " if config['double_buffer'] else "single=1 "
        s += "stereo=%d " % config['stereo']
    else:  # freeglut
        s += "double " if config['double_buffer'] else "single "
        s += "stereo " if config['stereo'] else ""
    glut.glutInitDisplayString(s.encode('ASCII'))


class SharedContext(BaseSharedContext):
    _backend = 'glut'


# ------------------------------------------------------------- application ---

class ApplicationBackend(BaseApplicationBackend):

    def __init__(self):
        BaseApplicationBackend.__init__(self)
        self._timers = []

    def _add_timer(self, timer):
        if timer not in self._timers:
            self._timers.append(timer)

    def _vispy_get_backend_name(self):
        return 'Glut'

    def _vispy_process_events(self):
        # Determine what function to use, if any
        try:
            func = _get_glut_process_func()
        except RuntimeError:
            self._vispy_process_events = lambda: None
            raise
        # Set for future use, and call!
        self._proc_fun = func
        self._vispy_process_events = self._process_events_and_timer
        self._process_events_and_timer()

    def _process_events_and_timer(self):
        # helper to both call glutMainLoopEvent and tick the timers
        self._proc_fun()
        for timer in self._timers:
            timer._idle_callback()

    def _vispy_run(self):
        self._vispy_get_native_app()  # Force exist
        return glut.glutMainLoop()

    def _vispy_quit(self):
        for timer in self._timers:
            timer._vispy_stop()
        self._timers = []
        if hasattr(glut, 'glutLeaveMainLoop') and bool(glut.glutLeaveMainLoop):
            glut.glutLeaveMainLoop()
        else:
            for win in _VP_GLUT_ALL_WINDOWS:
                win._vispy_close()

    def _vispy_get_native_app(self):
        global _GLUT_INITIALIZED
        if not _GLUT_INITIALIZED:
            glut.glutInit(['vispy'.encode('ASCII')])
            # Prevent exit when closing window
            try:
                glut.glutSetOption(glut.GLUT_ACTION_ON_WINDOW_CLOSE,
                                   glut.GLUT_ACTION_CONTINUE_EXECUTION)
            except Exception:
                pass
            _GLUT_INITIALIZED = True
        return glut


def _set_close_fun(id_, fun):
    # Set close function. See issue #10. For some reason, the function
    # can still not exist even if we checked its boolean status.
    glut.glutSetWindow(id_)
    closeFuncSet = False
    if bool(glut.glutWMCloseFunc):  # OSX specific test
        try:
            glut.glutWMCloseFunc(fun)
            closeFuncSet = True
        except OpenGL.error.NullFunctionError:
            pass
    if not closeFuncSet:
        try:
            glut.glutCloseFunc(fun)
            closeFuncSet = True
        except OpenGL.error.NullFunctionError:
            pass


# ------------------------------------------------------------------ canvas ---

class CanvasBackend(BaseCanvasBackend):

    """ GLUT backend for Canvas abstract class."""

    def __init__(self, **kwargs):
        BaseCanvasBackend.__init__(self, capability, SharedContext)
        title, size, position, show, vsync, resize, dec, fs, context = \
            self._process_backend_kwargs(kwargs)
        _set_config(context)
        glut.glutInitWindowSize(size[0], size[1])
        self._id = glut.glutCreateWindow(title.encode('ASCII'))
        if not self._id:
            raise RuntimeError('could not create window')
        glut.glutSetWindow(self._id)
        _VP_GLUT_ALL_WINDOWS.append(self)
        if fs is not False:
            if isinstance(fs, int):
                logger.warn('Cannot specify monitor for glut fullscreen, '
                            'using default')
            glut.glutFullScreen()

        # Cache of modifiers so we can send modifiers along with mouse motion
        self._modifiers_cache = ()
        self._closed = False  # Keep track whether the widget is closed

        # Register callbacks
        glut.glutDisplayFunc(self.on_draw)
        glut.glutReshapeFunc(self.on_resize)
        # glut.glutVisibilityFunc(self.on_show)
        glut.glutKeyboardFunc(self.on_key_press)
        glut.glutSpecialFunc(self.on_key_press)
        glut.glutKeyboardUpFunc(self.on_key_release)
        glut.glutMouseFunc(self.on_mouse_action)
        glut.glutMotionFunc(self.on_mouse_motion)
        glut.glutPassiveMotionFunc(self.on_mouse_motion)
        _set_close_fun(self._id, self.on_close)
        self._vispy_canvas_ = None
        if position is not None:
            self._vispy_set_position(*position)
        if not show:
            glut.glutHideWindow()

    @property
    def _vispy_context(self):
        """Context to return for sharing"""
        return SharedContext(None)  # cannot share in GLUT

    def _vispy_warmup(self):
        etime = time() + 0.4  # empirically determined :(
        while time() < etime:
            sleep(0.01)
            self._vispy_set_current()
            self._vispy_canvas.app.process_events()

    @property
    def _vispy_canvas(self):
        """ The parent canvas/window """
        return self._vispy_canvas_

    @_vispy_canvas.setter
    def _vispy_canvas(self, vc):
        # Init events when the property is set by Canvas
        self._vispy_canvas_ = vc
        if vc is not None:
            self._vispy_canvas.events.initialize()

    def _vispy_set_current(self):
        # Make this the current context
        glut.glutSetWindow(self._id)

    def _vispy_swap_buffers(self):
        # Swap front and back buffer
        glut.glutSetWindow(self._id)
        glut.glutSwapBuffers()

    def _vispy_set_title(self, title):
        # Set the window title. Has no effect for widgets
        glut.glutSetWindow(self._id)
        glut.glutSetWindowTitle(title.encode('ASCII'))

    def _vispy_set_size(self, w, h):
        # Set size of the widget or window
        glut.glutSetWindow(self._id)
        glut.glutReshapeWindow(w, h)

    def _vispy_set_position(self, x, y):
        # Set position of the widget or window. May have no effect for widgets
        glut.glutSetWindow(self._id)
        glut.glutPositionWindow(x, y)

    def _vispy_set_visible(self, visible):
        # Show or hide the window or widget
        glut.glutSetWindow(self._id)
        if visible:
            glut.glutShowWindow()
        else:
            glut.glutHideWindow()

    def _vispy_update(self):
        # Invoke a redraw
        glut.glutSetWindow(self._id)
        glut.glutPostRedisplay()

    def _vispy_close(self):
        # Force the window or widget to shut down
        if self._closed:
            return
        # sometimes the context is already destroyed
        try:
            # prevent segfaults during garbage col
            _set_close_fun(self._id, None)
        except Exception:
            pass
        self._closed = True
        self._vispy_set_visible(False)
        # Try destroying the widget. Not in close event, because it isnt called
        try:
            glut.glutDestroyWindow(self._id)
        except Exception:
            pass

    def _vispy_get_size(self):
        glut.glutSetWindow(self._id)
        w = glut.glutGet(glut.GLUT_WINDOW_WIDTH)
        h = glut.glutGet(glut.GLUT_WINDOW_HEIGHT)
        return w, h

    def _vispy_get_position(self):
        glut.glutSetWindow(self._id)
        x = glut.glutGet(glut.GLUT_WINDOW_X)
        y = glut.glutGet(glut.GLUT_WINDOW_Y)
        return x, y

    def on_resize(self, w, h):
        if self._vispy_canvas is None:
            return
        self._vispy_canvas.events.resize(size=(w, h))

    def on_close(self):
        if self._vispy_canvas is None:
            return
        self._vispy_canvas.events.close()

    def on_draw(self, dummy=None):
        if self._vispy_canvas is None:
            return
        #w = glut.glutGet(glut.GLUT_WINDOW_WIDTH)
        #h = glut.glutGet(glut.GLUT_WINDOW_HEIGHT)
        self._vispy_set_current()
        self._vispy_canvas.events.paint(region=None)  # (0, 0, w, h))

    def on_mouse_action(self, button, state, x, y):
        if self._vispy_canvas is None:
            return
        action = {glut.GLUT_UP: 'release', glut.GLUT_DOWN: 'press'}[state]
        mod = self._modifiers(False)

        if button < 3:
            # Mouse click event
            button = BUTTONMAP.get(button, 0)
            if action == 'press':
                self._vispy_mouse_press(pos=(x, y), button=button,
                                        modifiers=mod)
            else:
                self._vispy_mouse_release(pos=(x, y), button=button,
                                          modifiers=mod)

        elif button in (3, 4):
            # Wheel event
            deltay = 1.0 if button == 3 else -1.0
            self._vispy_canvas.events.mouse_wheel(pos=(x, y),
                                                  delta=(0.0, deltay),
                                                  modifiers=mod)

    def on_mouse_motion(self, x, y):
        if self._vispy_canvas is None:
            return
        self._vispy_mouse_move(
            pos=(x, y),
            modifiers=self._modifiers(False),
        )

    def on_key_press(self, key, x, y):
        key, text = self._process_key(key)
        self._vispy_canvas.events.key_press(key=key, text=text,
                                            modifiers=self._modifiers())

    def on_key_release(self, key, x, y):
        key, text = self._process_key(key)
        self._vispy_canvas.events.key_release(key=key, text=text,
                                              modifiers=self._modifiers())

    def _process_key(self, key):
        if key in KEYMAP:
            if isinstance(key, int):
                return KEYMAP[key], ''
            else:
                return KEYMAP[key], key
        elif isinstance(key, int):
            return None, ''  # unsupported special char
        else:
            return keys.Key(key.upper()), key

    def _modifiers(self, query_now=True):
        if query_now:
            glutmod = glut.glutGetModifiers()
            mod = ()
            if glut.GLUT_ACTIVE_SHIFT & glutmod:
                mod += keys.SHIFT,
            if glut.GLUT_ACTIVE_CTRL & glutmod:
                mod += keys.CONTROL,
            if glut.GLUT_ACTIVE_ALT & glutmod:
                mod += keys.ALT,
            self._modifiers_cache = mod
        return self._modifiers_cache


# ------------------------------------------------------------------- timer ---

# Note: we could also build a timer using glutTimerFunc, but this causes
# trouble because timer callbacks appear to take precedence over all others.
# Thus, a fast timer can block new display events.
class TimerBackend(BaseTimerBackend):
    def __init__(self, vispy_timer):
        BaseTimerBackend.__init__(self, vispy_timer)
        self._schedule = list()
        glut.glutIdleFunc(self._idle_callback)
        # tell application instance about existence
        vispy_timer._app._backend._add_timer(self)

    def _idle_callback(self):
        now = ptime.time()
        new_schedule = []

        # see whether there are any timers ready
        while len(self._schedule) > 0 and self._schedule[0][0] <= now:
            timer = self._schedule.pop(0)[1]
            timer._vispy_timer._timeout()
            if timer._vispy_timer.running:
                new_schedule.append((now + timer._vispy_timer.interval, timer))

        # schedule next round of timeouts
        if len(new_schedule) > 0:
            self._schedule.extend(new_schedule)
            self._schedule.sort()

    def _vispy_start(self, interval):
        now = ptime.time()
        self._schedule.append((now + interval, self))

    def _vispy_stop(self):
        pass

    def _vispy_get_native_timer(self):
        return True  # glut has no native timer objects.

########NEW FILE########
__FILENAME__ = _pyglet
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""
vispy backend for pyglet.
"""

from __future__ import division

from distutils.version import LooseVersion
from time import sleep

from ..base import (BaseApplicationBackend, BaseCanvasBackend,
                    BaseTimerBackend, BaseSharedContext)
from ...util import keys
from ...util.ptime import time


# -------------------------------------------------------------------- init ---

try:
    import pyglet
    version = pyglet.version
    if LooseVersion(version) < LooseVersion('1.2'):
        help_ = ('You can install the latest pyglet using:\n    '
                 'pip install http://pyglet.googlecode.com/archive/tip.zip')
        raise ImportError('Pyglet version too old (%s), need >= 1.2\n%s'
                          % (version, help_))

    # Map native keys to vispy keys
    KEYMAP = {
        pyglet.window.key.LSHIFT: keys.SHIFT,
        pyglet.window.key.RSHIFT: keys.SHIFT,
        pyglet.window.key.LCTRL: keys.CONTROL,
        pyglet.window.key.RCTRL: keys.CONTROL,
        pyglet.window.key.LALT: keys.ALT,
        pyglet.window.key.RALT: keys.ALT,
        pyglet.window.key.LMETA: keys.META,
        pyglet.window.key.RMETA: keys.META,

        pyglet.window.key.LEFT: keys.LEFT,
        pyglet.window.key.UP: keys.UP,
        pyglet.window.key.RIGHT: keys.RIGHT,
        pyglet.window.key.DOWN: keys.DOWN,
        pyglet.window.key.PAGEUP: keys.PAGEUP,
        pyglet.window.key.PAGEDOWN: keys.PAGEDOWN,

        pyglet.window.key.INSERT: keys.INSERT,
        pyglet.window.key.DELETE: keys.DELETE,
        pyglet.window.key.HOME: keys.HOME,
        pyglet.window.key.END: keys.END,

        pyglet.window.key.ESCAPE: keys.ESCAPE,
        pyglet.window.key.BACKSPACE: keys.BACKSPACE,

        pyglet.window.key.F1: keys.F1,
        pyglet.window.key.F2: keys.F2,
        pyglet.window.key.F3: keys.F3,
        pyglet.window.key.F4: keys.F4,
        pyglet.window.key.F5: keys.F5,
        pyglet.window.key.F6: keys.F6,
        pyglet.window.key.F7: keys.F7,
        pyglet.window.key.F8: keys.F8,
        pyglet.window.key.F9: keys.F9,
        pyglet.window.key.F10: keys.F10,
        pyglet.window.key.F11: keys.F11,
        pyglet.window.key.F12: keys.F12,

        pyglet.window.key.SPACE: keys.SPACE,
        pyglet.window.key.ENTER: keys.ENTER,  # == pyglet.window.key.RETURN
        pyglet.window.key.NUM_ENTER: keys.ENTER,
        pyglet.window.key.TAB: keys.TAB,
    }

    BUTTONMAP = {pyglet.window.mouse.LEFT: 1,
                 pyglet.window.mouse.RIGHT: 2,
                 pyglet.window.mouse.MIDDLE: 3
                 }
except Exception as exp:
    available, testable, why_not, which = False, False, str(exp), None

    class _Window(object):
        pass
else:
    available, testable, why_not = True, True, None
    which = 'pyglet ' + str(pyglet.version)
    _Window = pyglet.window.Window


# -------------------------------------------------------------- capability ---

capability = dict(  # things that can be set by the backend
    title=True,
    size=True,
    position=True,
    show=True,
    vsync=True,
    resizable=True,
    decorate=True,
    fullscreen=True,
    context=True,
    multi_window=True,
    scroll=True,
)


# ------------------------------------------------------- set_configuration ---

def _set_config(config):
    """Set gl configuration"""
    pyglet_config = pyglet.gl.Config()

    pyglet_config.red_size = config['red_size']
    pyglet_config.green_size = config['green_size']
    pyglet_config.blue_size = config['blue_size']
    pyglet_config.alpha_size = config['alpha_size']

    pyglet_config.accum_red_size = 0
    pyglet_config.accum_green_size = 0
    pyglet_config.accum_blue_size = 0
    pyglet_config.accum_alpha_size = 0

    pyglet_config.depth_size = config['depth_size']
    pyglet_config.stencil_size = config['stencil_size']
    pyglet_config.double_buffer = config['double_buffer']
    pyglet_config.stereo = config['stereo']
    pyglet_config.samples = config['samples']
    return pyglet_config


class SharedContext(BaseSharedContext):
    _backend = 'pyglet'


# ------------------------------------------------------------- application ---

class ApplicationBackend(BaseApplicationBackend):

    def __init__(self):
        BaseApplicationBackend.__init__(self)

    def _vispy_get_backend_name(self):
        return 'Pyglet'

    def _vispy_process_events(self):
        # pyglet.app.platform_event_loop.step(0.0)
        pyglet.clock.tick()
        for window in pyglet.app.windows:
            window.switch_to()
            window.dispatch_events()
            window.dispatch_event('on_draw')

    def _vispy_run(self):
        return pyglet.app.run()

    def _vispy_quit(self):
        return pyglet.app.exit()

    def _vispy_get_native_app(self):
        return pyglet.app


# ------------------------------------------------------------------ canvas ---

class CanvasBackend(_Window, BaseCanvasBackend):

    """ Pyglet backend for Canvas abstract class."""

    def __init__(self, **kwargs):
        BaseCanvasBackend.__init__(self, capability, SharedContext)
        title, size, position, show, vsync, resize, dec, fs, context = \
            self._process_backend_kwargs(kwargs)
        if not isinstance(context, (dict, SharedContext)):
            raise TypeError('context must be a dict or pyglet SharedContext')
        if not isinstance(context, SharedContext):
            config = _set_config(context)  # transform to Pyglet config
        else:
            # contexts are shared by default in Pyglet, so we shouldn't need
            # to do anything to share them...
            config = None
        style = (pyglet.window.Window.WINDOW_STYLE_DEFAULT if dec else
                 pyglet.window.Window.WINDOW_STYLE_BORDERLESS)
        # We keep track of modifier keys so we can pass them to mouse_motion
        self._current_modifiers = set()
        #self._buttons_accepted = 0
        self._draw_ok = False  # whether it is ok to draw yet
        self._pending_position = None
        if fs is not False:
            screen = pyglet.window.get_platform().get_default_display()
            if fs is True:
                screen = screen.get_default_screen()
            else:
                screen = screen.get_screens()
                if fs >= len(screen):
                    raise RuntimeError('fullscreen must be < %s'
                                       % len(screen))
                screen = screen[fs]
        else:
            screen = None
        pyglet.window.Window.__init__(self, width=size[0], height=size[1],
                                      caption=title, visible=show,
                                      config=config, vsync=vsync,
                                      resizable=resize, style=style,
                                      screen=screen)
        if position is not None:
            self._vispy_set_position(*position)

    @property
    def _vispy_context(self):
        """Context to return for sharing"""
        return SharedContext(None)

    def _vispy_warmup(self):
        etime = time() + 0.1
        while time() < etime:
            sleep(0.01)
            self._vispy_set_current()
            self._vispy_canvas.app.process_events()

    # Override these ...
    def flip(self):
        # Is called by event loop after each draw
        pass

    def on_draw(self):
        # Is called by event loop after each event, whatever event ... really
        if not self._draw_ok:
            self._draw_ok = True
            self.our_paint_func()

    def draw_mouse_cursor(self):
        # Prevent legacy OpenGL
        pass

    def _vispy_set_current(self):
        # Make this the current context
        self.switch_to()

    def _vispy_swap_buffers(self):
        # Swap front and back buffer
        pyglet.window.Window.flip(self)

    def _vispy_set_title(self, title):
        # Set the window title. Has no effect for widgets
        self.set_caption(title)

    def _vispy_set_size(self, w, h):
        # Set size of the widget or window
        self.set_size(w, h)

    def _vispy_set_position(self, x, y):
        # Set positionof the widget or window. May have no effect for widgets
        if self._draw_ok:
            self.set_location(x, y)
        else:
            self._pending_position = x, y

    def _vispy_set_visible(self, visible):
        # Show or hide the window or widget
        self.set_visible(visible)

    def _vispy_update(self):
        # Invoke a redraw
        pyglet.clock.schedule_once(self.our_paint_func, 0.0)

    def _vispy_close(self):
        # Force the window or widget to shut down
        # In Pyglet close is equivalent to destroy (window becomes invalid)
        self.close()

    def _vispy_get_size(self):
        x, y = self.get_size()
        return x, y

    def _vispy_get_position(self):
        w, h = self.get_location()
        return w, h

    def on_show(self):
        if self._vispy_canvas is None:
            return
        self._vispy_set_current()
        self._vispy_canvas.events.initialize()
        # Set location now if we must. For some reason we get weird
        # offsets in viewport if set_location is called before the
        # widget is shown.
        if self._pending_position:
            x, y = self._pending_position
            self._pending_position = None
            self.set_location(x, y)
        # Redraw
        self._vispy_update()

    def on_close(self):
        if self._vispy_canvas is None:
            return
        self._vispy_canvas.events.close()
        #self.close()  # Or the window wont close
        # AK: seems so wrong to try a close in the close event handler ...

    def on_resize(self, w, h):
        if self._vispy_canvas is None:
            return
        self._vispy_canvas.events.resize(size=(w, h))
        # self._vispy_update()

    def our_paint_func(self, dummy=None):
        if not self._draw_ok or self._vispy_canvas is None:
            return
        # (0, 0, self.width, self.height))
        self._vispy_set_current()
        self._vispy_canvas.events.paint(region=None)

    def on_mouse_press(self, x, y, button, modifiers=None):
        if self._vispy_canvas is None:
            return
        self._vispy_mouse_press(
            pos=(x, self.get_size()[1] - y),
            button=BUTTONMAP.get(button, 0),
            modifiers=self._modifiers(),
        )
#         if ev2.handled:
#             self._buttons_accepted |= button

    def on_mouse_release(self, x, y, button, modifiers=None):
        if self._vispy_canvas is None:
            return
        if True:  # (button & self._buttons_accepted) > 0:
            self._vispy_mouse_release(
                pos=(x, self.get_size()[1] - y),
                button=BUTTONMAP.get(button, 0),
                modifiers=self._modifiers(),
            )
            #self._buttons_accepted &= ~button

    def on_mouse_motion(self, x, y, dx, dy):
        if self._vispy_canvas is None:
            return
        self._vispy_mouse_move(
            pos=(x, self.get_size()[1] - y),
            modifiers=self._modifiers(),
        )

    def on_mouse_drag(self, x, y, dx, dy, button, modifiers):
        self.on_mouse_motion(x, y, dx, dy)

    def on_mouse_scroll(self, x, y, scroll_x, scroll_y):
        if self._vispy_canvas is None:
            return
        self._vispy_canvas.events.mouse_wheel(
            delta=(float(scroll_x), float(scroll_y)),
            pos=(x, y),
            modifiers=self._modifiers(),
        )

    def on_key_press(self, key, modifiers):
        # Process modifiers
        if key in (pyglet.window.key.LCTRL, pyglet.window.key.RCTRL,
                   pyglet.window.key.LALT, pyglet.window.key.RALT,
                   pyglet.window.key.LSHIFT, pyglet.window.key.RSHIFT):
            self._current_modifiers.add(key)
        # Emit
        self._vispy_canvas.events.key_press(
            key=self._processKey(key),
            text='',  # Handlers that trigger on text wont see this event
            modifiers=self._modifiers(modifiers))

    def on_text(self, text):
        # Typically this is called after on_key_press and before
        # on_key_release
        self._vispy_canvas.events.key_press(
            key=None,  # Handlers that trigger on key wont see this event
            text=text,
            modifiers=self._modifiers())

    def on_key_release(self, key, modifiers):
        # Process modifiers
        if key in (pyglet.window.key.LCTRL, pyglet.window.key.RCTRL,
                   pyglet.window.key.LALT, pyglet.window.key.RALT,
                   pyglet.window.key.LSHIFT, pyglet.window.key.RSHIFT):
            self._current_modifiers.discard(key)
        # Get txt
        try:
            text = chr(key)
        except Exception:
            text = ''
        # Emit
        self._vispy_canvas.events.key_release(
            key=self._processKey(key), text=text,
            modifiers=self._modifiers(modifiers))

    def _processKey(self, key):
        if 97 <= key <= 122:
            key -= 32
        if key in KEYMAP:
            return KEYMAP[key]
        elif key >= 32 and key <= 127:
            return keys.Key(chr(key))
        else:
            return None

    def _modifiers(self, pygletmod=None):
        mod = ()
        if pygletmod is None:
            pygletmod = self._current_modifiers
        if isinstance(pygletmod, set):
            for key in pygletmod:
                mod += KEYMAP[key],
        else:
            if pygletmod & pyglet.window.key.MOD_SHIFT:
                mod += keys.SHIFT,
            if pygletmod & pyglet.window.key.MOD_CTRL:
                mod += keys.CONTROL,
            if pygletmod & pyglet.window.key.MOD_ALT:
                mod += keys.ALT,
        return mod


# ------------------------------------------------------------------- timer ---

class TimerBackend(BaseTimerBackend):

    def _vispy_start(self, interval):
        interval = self._vispy_timer._interval
        if self._vispy_timer.max_iterations == 1:
            pyglet.clock.schedule_once(self._vispy_timer._timeout, interval)
        else:
            # seems pyglet does not give the expected behavior when interval==0
            if interval == 0:
                interval = 1e-9
            pyglet.clock.schedule_interval(
                self._vispy_timer._timeout,
                interval)

    def _vispy_stop(self):
        pyglet.clock.unschedule(self._vispy_timer._timeout)

    def _vispy_get_native_timer(self):
        return pyglet.clock

########NEW FILE########
__FILENAME__ = _qt
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""
vispy backend for Qt (PySide and PyQt4).
"""

from __future__ import division

from time import sleep, time

from ... import config
from ..base import (BaseApplicationBackend, BaseCanvasBackend,
                    BaseTimerBackend, BaseSharedContext)
from ...util import keys
from . import ATTEMPTED_BACKENDS
from ...ext.six import text_type
from ...util import logger

# Get what qt lib to try
if len(ATTEMPTED_BACKENDS):
    qt_lib = ATTEMPTED_BACKENDS[-1].lower()
    if qt_lib.lower() == 'qt':
        qt_lib = config['qt_lib'].lower()
    # in case the last app we ran was something else (e.g., Pyglet)
    if qt_lib not in ['pyqt', 'pyqt4', 'pyside', 'qt']:
        qt_lib = 'any'
else:
    qt_lib = 'any'

# -------------------------------------------------------------------- init ---

try:
    # Import PySide or PyQt4
    if qt_lib in ('any', 'qt'):
        try:
            from PyQt4 import QtGui, QtCore, QtOpenGL
        except ImportError:
            from PySide import QtGui, QtCore, QtOpenGL
    elif qt_lib in ('pyqt', 'pyqt4'):
        from PyQt4 import QtGui, QtCore, QtOpenGL
    elif qt_lib == 'pyside':
        from PySide import QtGui, QtCore, QtOpenGL
    else:
        raise Exception("Do not recognize Qt library '%s'. Options are "
                        "'pyqt4', 'pyside', or 'qt'])." % str(qt_lib))

    # todo: add support for distinguishing left and right shift/ctrl/alt keys.
    # Linux scan codes:  (left, right)
    #   Shift  50, 62
    #   Ctrl   37, 105
    #   Alt    64, 108
    KEYMAP = {
        QtCore.Qt.Key_Shift: keys.SHIFT,
        QtCore.Qt.Key_Control: keys.CONTROL,
        QtCore.Qt.Key_Alt: keys.ALT,
        QtCore.Qt.Key_AltGr: keys.ALT,
        QtCore.Qt.Key_Meta: keys.META,

        QtCore.Qt.Key_Left: keys.LEFT,
        QtCore.Qt.Key_Up: keys.UP,
        QtCore.Qt.Key_Right: keys.RIGHT,
        QtCore.Qt.Key_Down: keys.DOWN,
        QtCore.Qt.Key_PageUp: keys.PAGEUP,
        QtCore.Qt.Key_PageDown: keys.PAGEDOWN,

        QtCore.Qt.Key_Insert: keys.INSERT,
        QtCore.Qt.Key_Delete: keys.DELETE,
        QtCore.Qt.Key_Home: keys.HOME,
        QtCore.Qt.Key_End: keys.END,

        QtCore.Qt.Key_Escape: keys.ESCAPE,
        QtCore.Qt.Key_Backspace: keys.BACKSPACE,

        QtCore.Qt.Key_F1: keys.F1,
        QtCore.Qt.Key_F2: keys.F2,
        QtCore.Qt.Key_F3: keys.F3,
        QtCore.Qt.Key_F4: keys.F4,
        QtCore.Qt.Key_F5: keys.F5,
        QtCore.Qt.Key_F6: keys.F6,
        QtCore.Qt.Key_F7: keys.F7,
        QtCore.Qt.Key_F8: keys.F8,
        QtCore.Qt.Key_F9: keys.F9,
        QtCore.Qt.Key_F10: keys.F10,
        QtCore.Qt.Key_F11: keys.F11,
        QtCore.Qt.Key_F12: keys.F12,

        QtCore.Qt.Key_Space: keys.SPACE,
        QtCore.Qt.Key_Enter: keys.ENTER,
        QtCore.Qt.Key_Return: keys.ENTER,
        QtCore.Qt.Key_Tab: keys.TAB,
    }
    BUTTONMAP = {0: 0, 1: 1, 2: 2, 4: 3, 8: 4, 16: 5}
except Exception as exp:
    available, testable, why_not, which = False, False, str(exp), None

    class _QGLWidget(object):
        pass

    _QTimer = _QGLWidget
else:
    available, testable, why_not = True, True, None
    _QGLWidget = QtOpenGL.QGLWidget
    _QTimer = QtCore.QTimer
    if hasattr(QtCore, 'PYQT_VERSION_STR'):
        has_uic = True
        which = ('PyQt4', QtCore.PYQT_VERSION_STR, QtCore.QT_VERSION_STR)
    else:
        has_uic = False
        import PySide
        which = ('PySide', PySide.__version__, QtCore.__version__)


# -------------------------------------------------------------- capability ---

capability = dict(  # things that can be set by the backend
    title=True,
    size=True,
    position=True,
    show=True,
    vsync=True,
    resizable=True,
    decorate=True,
    fullscreen=True,
    context=True,
    multi_window=True,
    scroll=True,
)


# ------------------------------------------------------- set_configuration ---
def _set_config(c):
    """Set the OpenGL configuration"""
    glformat = QtOpenGL.QGLFormat()
    glformat.setRedBufferSize(c['red_size'])
    glformat.setGreenBufferSize(c['green_size'])
    glformat.setBlueBufferSize(c['blue_size'])
    glformat.setAlphaBufferSize(c['alpha_size'])
    glformat.setAccum(False)
    glformat.setRgba(True)
    glformat.setDoubleBuffer(True if c['double_buffer'] else False)
    glformat.setDepth(True if c['depth_size'] else False)
    glformat.setDepthBufferSize(c['depth_size'] if c['depth_size'] else 0)
    glformat.setStencil(True if c['stencil_size'] else False)
    glformat.setStencilBufferSize(c['stencil_size'] if c['stencil_size']
                                  else 0)
    glformat.setSampleBuffers(True if c['samples'] else False)
    glformat.setSamples(c['samples'] if c['samples'] else 0)
    glformat.setStereo(c['stereo'])
    return glformat


class SharedContext(BaseSharedContext):
    _backend = 'qt'


# ------------------------------------------------------------- application ---

class ApplicationBackend(BaseApplicationBackend):

    def __init__(self):
        BaseApplicationBackend.__init__(self)

    def _vispy_get_backend_name(self):
        if 'pyside' in QtCore.__name__.lower():
            return 'PySide (qt)'
        else:
            return 'PyQt4 (qt)'

    def _vispy_process_events(self):
        app = self._vispy_get_native_app()
        app.flush()
        app.processEvents()

    def _vispy_run(self):
        app = self._vispy_get_native_app()
        if hasattr(app, '_in_event_loop') and app._in_event_loop:
            pass  # Already in event loop
        else:
            return app.exec_()

    def _vispy_quit(self):
        return self._vispy_get_native_app().quit()

    def _vispy_get_native_app(self):
        # Get native app in save way. Taken from guisupport.py
        app = QtGui.QApplication.instance()
        if app is None:
            app = QtGui.QApplication([''])
        # Store so it won't be deleted, but not on a vispy object,
        # or an application may produce error when closed
        QtGui._qApp = app
        # Return
        return app


# ------------------------------------------------------------------ canvas ---

class CanvasBackend(_QGLWidget, BaseCanvasBackend):

    """Qt backend for Canvas abstract class."""

    def __init__(self, *args, **kwargs):
        self._initialized = False
        BaseCanvasBackend.__init__(self, capability, SharedContext)
        title, size, position, show, vsync, resize, dec, fs, context = \
            self._process_backend_kwargs(kwargs)
        if isinstance(context, dict):
            glformat = _set_config(context)
            glformat.setSwapInterval(1 if vsync else 0)
            widget = kwargs.pop('shareWidget', None)
        else:
            glformat = QtOpenGL.QGLFormat.defaultFormat()
            if 'shareWidget' in kwargs:
                raise RuntimeError('cannot use vispy to share context and '
                                   'use built-in shareWidget')
            widget = context.value
        f = QtCore.Qt.Widget if dec else QtCore.Qt.FramelessWindowHint
        parent = kwargs.pop('parent', None)
        # first arg can be glformat, or a shared context
        QtOpenGL.QGLWidget.__init__(self, glformat, parent, widget, f)
        self._initialized = True
        if not self.isValid():
            raise RuntimeError('context could not be created')
        self.setAutoBufferSwap(False)  # to make consistent with other backends
        self.setMouseTracking(True)
        self._vispy_set_title(title)
        self._vispy_set_size(*size)
        if fs is not False:
            if isinstance(fs, int):
                logger.warn('Cannot specify monitor number for Qt fullscreen, '
                            'using default')
            self._vispy_show_func = self.showFullScreen
        else:
            self._vispy_show_func = self.show
        if not resize:
            self.setFixedSize(self.size())
        if position is not None:
            self._vispy_set_position(*position)
        if show:
            self._vispy_set_visible(True)

    @property
    def _vispy_context(self):
        """Context to return for sharing"""
        return SharedContext(self)

    def _vispy_warmup(self):
        etime = time() + 0.25
        while time() < etime:
            sleep(0.01)
            self._vispy_set_current()
            self._vispy_canvas.app.process_events()

    def _vispy_set_current(self):
        # Make this the current context
        if self._vispy_canvas is None:
            return
        self.makeCurrent()

    def _vispy_swap_buffers(self):
        # Swap front and back buffer
        if self._vispy_canvas is None:
            return
        self.swapBuffers()

    def _vispy_set_title(self, title):
        # Set the window title. Has no effect for widgets
        if self._vispy_canvas is None:
            return
        self.setWindowTitle(title)

    def _vispy_set_size(self, w, h):
        # Set size of the widget or window
        self.resize(w, h)

    def _vispy_set_position(self, x, y):
        # Set location of the widget or window. May have no effect for widgets
        self.move(x, y)

    def _vispy_set_visible(self, visible):
        # Show or hide the window or widget
        self._vispy_show_func() if visible else self.hide()

    def _vispy_update(self):
        if self._vispy_canvas is None:
            return
        # Invoke a redraw
        self.update()

    def _vispy_close(self):
        # Force the window or widget to shut down
        self.close()
        self.doneCurrent()
        self.context().reset()

    def _vispy_get_position(self):
        g = self.geometry()
        return g.x(), g.y()

    def _vispy_get_size(self):
        g = self.geometry()
        return g.width(), g.height()

    def initializeGL(self):
        if self._vispy_canvas is None:
            return
        self._vispy_canvas.events.initialize()

    def resizeGL(self, w, h):
        if self._vispy_canvas is None:
            return
        self._vispy_canvas.events.resize(size=(w, h))

    def paintGL(self):
        if self._vispy_canvas is None:
            return
        # (0, 0, self.width(), self.height()))
        self._vispy_set_current()
        self._vispy_canvas.events.paint(region=None)

    def closeEvent(self, ev):
        if self._vispy_canvas is None:
            return
        self._vispy_canvas.events.close()

    def mousePressEvent(self, ev):
        if self._vispy_canvas is None:
            return
        self._vispy_mouse_press(
            native=ev,
            pos=(ev.pos().x(), ev.pos().y()),
            button=BUTTONMAP.get(ev.button(), 0),
            modifiers = self._modifiers(ev),
        )

    def mouseReleaseEvent(self, ev):
        if self._vispy_canvas is None:
            return
        self._vispy_mouse_release(
            native=ev,
            pos=(ev.pos().x(), ev.pos().y()),
            button=BUTTONMAP[ev.button()],
            modifiers = self._modifiers(ev),
        )

    def mouseMoveEvent(self, ev):
        if self._vispy_canvas is None:
            return
        self._vispy_mouse_move(
            native=ev,
            pos=(ev.pos().x(), ev.pos().y()),
            modifiers=self._modifiers(ev),
        )

    def wheelEvent(self, ev):
        if self._vispy_canvas is None:
            return
        # Get scrolling
        deltax, deltay = 0.0, 0.0
        if ev.orientation == QtCore.Qt.Horizontal:
            deltax = ev.delta() / 120.0
        else:
            deltay = ev.delta() / 120.0
        # Emit event
        self._vispy_canvas.events.mouse_wheel(
            native=ev,
            delta=(deltax, deltay),
            pos=(ev.pos().x(), ev.pos().y()),
            modifiers=self._modifiers(ev),
        )

    def keyPressEvent(self, ev):
        self._keyEvent(self._vispy_canvas.events.key_press, ev)

    def keyReleaseEvent(self, ev):
        self._keyEvent(self._vispy_canvas.events.key_release, ev)

    def _keyEvent(self, func, ev):
        # evaluates the keycode of qt, and transform to vispy key.
        key = int(ev.key())
        if key in KEYMAP:
            key = KEYMAP[key]
        elif key >= 32 and key <= 127:
            key = keys.Key(chr(key))
        else:
            key = None
        mod = self._modifiers(ev)
        func(native=ev, key=key, text=text_type(ev.text()), modifiers=mod)

    def _modifiers(self, event):
        # Convert the QT modifier state into a tuple of active modifier keys.
        mod = ()
        qtmod = event.modifiers()
        for q, v in ([QtCore.Qt.ShiftModifier, keys.SHIFT],
                     [QtCore.Qt.ControlModifier, keys.CONTROL],
                     [QtCore.Qt.AltModifier, keys.ALT],
                     [QtCore.Qt.MetaModifier, keys.META]):
            if q & qtmod:
                mod += (v,)
        return mod


# ------------------------------------------------------------------- timer ---

class TimerBackend(BaseTimerBackend, _QTimer):

    def __init__(self, vispy_timer):
        if QtGui.QApplication.instance() is None:
            global QAPP
            QAPP = QtGui.QApplication([])
        BaseTimerBackend.__init__(self, vispy_timer)
        QtCore.QTimer.__init__(self)
        self.timeout.connect(self._vispy_timeout)

    def _vispy_start(self, interval):
        self.start(interval * 1000.)

    def _vispy_stop(self):
        self.stop()

    def _vispy_timeout(self):
        self._vispy_timer._timeout()

########NEW FILE########
__FILENAME__ = _sdl2
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
"""
vispy backend for sdl2.
"""

from __future__ import division

import atexit
import ctypes
from time import sleep

from ..base import (BaseApplicationBackend, BaseCanvasBackend,
                    BaseTimerBackend, BaseSharedContext)
from ...util import keys, logger
from ...util.ptime import time


# -------------------------------------------------------------------- init ---

try:
    import sdl2
    import sdl2.ext

    # Map native keys to vispy keys
    KEYMAP = {
        # http://www.ginkgobitter.org/sdl/?SDL_Keycode
        sdl2.SDLK_LSHIFT: keys.SHIFT,
        sdl2.SDLK_RSHIFT: keys.SHIFT,
        sdl2.SDLK_LCTRL: keys.CONTROL,
        sdl2.SDLK_RCTRL: keys.CONTROL,
        sdl2.SDLK_LALT: keys.ALT,
        sdl2.SDLK_RALT: keys.ALT,
        sdl2.SDLK_LGUI: keys.META,
        sdl2.SDLK_RGUI: keys.META,

        sdl2.SDLK_LEFT: keys.LEFT,
        sdl2.SDLK_UP: keys.UP,
        sdl2.SDLK_RIGHT: keys.RIGHT,
        sdl2.SDLK_DOWN: keys.DOWN,
        sdl2.SDLK_PAGEUP: keys.PAGEUP,
        sdl2.SDLK_PAGEDOWN: keys.PAGEDOWN,

        sdl2.SDLK_INSERT: keys.INSERT,
        sdl2.SDLK_DELETE: keys.DELETE,
        sdl2.SDLK_HOME: keys.HOME,
        sdl2.SDLK_END: keys.END,

        sdl2.SDLK_ESCAPE: keys.ESCAPE,
        sdl2.SDLK_BACKSPACE: keys.BACKSPACE,

        sdl2.SDLK_F1: keys.F1,
        sdl2.SDLK_F2: keys.F2,
        sdl2.SDLK_F3: keys.F3,
        sdl2.SDLK_F4: keys.F4,
        sdl2.SDLK_F5: keys.F5,
        sdl2.SDLK_F6: keys.F6,
        sdl2.SDLK_F7: keys.F7,
        sdl2.SDLK_F8: keys.F8,
        sdl2.SDLK_F9: keys.F9,
        sdl2.SDLK_F10: keys.F10,
        sdl2.SDLK_F11: keys.F11,
        sdl2.SDLK_F12: keys.F12,

        sdl2.SDLK_SPACE: keys.SPACE,
        sdl2.SDLK_RETURN: keys.ENTER,
        sdl2.SDLK_TAB: keys.TAB,
    }

    BUTTONMAP = {sdl2.SDL_BUTTON_LEFT: 1,
                 sdl2.SDL_BUTTON_MIDDLE: 2,
                 sdl2.SDL_BUTTON_RIGHT: 3
                 }
except Exception as exp:
    available, testable, why_not, which = False, False, str(exp), None
else:
    available, testable, why_not = True, True, None
    which = 'sdl2 %d.%d.%d' % sdl2.version_info[:3]

_SDL2_INITIALIZED = False
_VP_SDL2_ALL_WINDOWS = {}


def _get_sdl2_windows():
    return list(_VP_SDL2_ALL_WINDOWS.values())


# -------------------------------------------------------------- capability ---

capability = dict(  # things that can be set by the backend
    title=True,
    size=True,
    position=True,
    show=True,
    vsync=True,
    resizable=True,
    decorate=True,
    fullscreen=True,
    context=True,
    multi_window=True,
    scroll=True,
)


# ------------------------------------------------------- set_configuration ---

def _set_config(c):
    """Set gl configuration for SDL2"""
    func = sdl2.SDL_GL_SetAttribute
    func(sdl2.SDL_GL_RED_SIZE, c['red_size'])
    func(sdl2.SDL_GL_GREEN_SIZE, c['green_size'])
    func(sdl2.SDL_GL_BLUE_SIZE, c['blue_size'])
    func(sdl2.SDL_GL_ALPHA_SIZE, c['alpha_size'])
    func(sdl2.SDL_GL_DEPTH_SIZE, c['depth_size'])
    func(sdl2.SDL_GL_STENCIL_SIZE, c['stencil_size'])
    func(sdl2.SDL_GL_DOUBLEBUFFER, 1 if c['double_buffer'] else 0)
    samps = c['samples']
    func(sdl2.SDL_GL_MULTISAMPLEBUFFERS, 1 if samps > 0 else 0)
    func(sdl2.SDL_GL_MULTISAMPLESAMPLES, samps if samps > 0 else 0)
    func(sdl2.SDL_GL_STEREO, c['stereo'])


class SharedContext(BaseSharedContext):
    _backend = 'sdl2'


# ------------------------------------------------------------- application ---

class ApplicationBackend(BaseApplicationBackend):

    def __init__(self):
        BaseApplicationBackend.__init__(self)
        self._timers = list()

    def _add_timer(self, timer):
        if timer not in self._timers:
            self._timers.append(timer)

    def _vispy_get_backend_name(self):
        return 'SDL2'

    def _vispy_process_events(self):
        events = sdl2.ext.get_events()
        while len(events) > 0:
            for event in events:
                _id = event.window.windowID
                if _id in _VP_SDL2_ALL_WINDOWS:
                    win = _VP_SDL2_ALL_WINDOWS[_id]
                    win._on_event(event)
            events = sdl2.ext.get_events()
        for timer in self._timers:
            timer._tick()
        wins = _get_sdl2_windows()
        for win in wins:
            if win._needs_draw:
                win._needs_draw = False
                win._on_draw()

    def _vispy_run(self):
        wins = _get_sdl2_windows()
        while all(w._id is not None for w in wins):
            self._vispy_process_events()
        self._vispy_quit()  # to clean up

    def _vispy_quit(self):
        # Close windows
        wins = _get_sdl2_windows()
        for win in wins:
            win._vispy_close()
        # tear down timers
        for timer in self._timers:
            timer._vispy_stop()
        self._timers = []

    def _vispy_get_native_app(self):
        global _SDL2_INITIALIZED
        if not _SDL2_INITIALIZED:
            sdl2.ext.init()
            atexit.register(sdl2.ext.quit)
            _SDL2_INITIALIZED = True
        return sdl2


# ------------------------------------------------------------------ canvas ---

class CanvasBackend(BaseCanvasBackend):

    """ SDL2 backend for Canvas abstract class."""

    def __init__(self, **kwargs):
        BaseCanvasBackend.__init__(self, capability, SharedContext)
        title, size, position, show, vsync, resize, dec, fs, context = \
            self._process_backend_kwargs(kwargs)
        # Init SDL2, add window hints, and create window
        if isinstance(context, dict):
            _set_config(context)
            share = None
        else:
            share = context.value
            sdl2.SDL_GL_MakeCurrent(*share)  # old window must be current
            sdl2.SDL_GL_SetAttribute(sdl2.SDL_GL_SHARE_WITH_CURRENT_CONTEXT, 1)

        sdl2.SDL_GL_SetSwapInterval(1 if vsync else 0)
        flags = sdl2.SDL_WINDOW_OPENGL
        flags |= sdl2.SDL_WINDOW_SHOWN  # start out shown
        flags |= sdl2.SDL_WINDOW_ALLOW_HIGHDPI
        flags |= sdl2.SDL_WINDOW_RESIZABLE if resize else 0
        flags |= sdl2.SDL_WINDOW_BORDERLESS if not dec else 0
        if fs is not False:
            if isinstance(fs, int):
                logger.warn('Cannot specify monitor number for SDL2 '
                            'fullscreen, using default')
            flags |= sdl2.SDL_WINDOW_FULLSCREEN
        self._mods = list()
        if position is None:
            position = [sdl2.SDL_WINDOWPOS_UNDEFINED] * 2
        self._id = sdl2.ext.Window(title, size, position, flags)
        if not self._id.window:
            raise RuntimeError('Could not create window')
        if share is None:
            self._native_context = sdl2.SDL_GL_CreateContext(self._id.window)
        else:
            self._native_context = sdl2.SDL_GL_CreateContext(share[0])
        self._sdl_id = sdl2.SDL_GetWindowID(self._id.window)
        _VP_SDL2_ALL_WINDOWS[self._sdl_id] = self
        self._vispy_canvas_ = None
        self._needs_draw = False
        self._vispy_set_current()
        if not show:
            self._vispy_set_visible(False)

    @property
    def _vispy_context(self):
        """Context to return for sharing"""
        return SharedContext((self._id.window, self._native_context))

    ####################################
    # Deal with events we get from vispy
    @property
    def _vispy_canvas(self):
        """ The parent canvas/window """
        return self._vispy_canvas_

    @_vispy_canvas.setter
    def _vispy_canvas(self, vc):
        # Init events when the property is set by Canvas
        self._vispy_canvas_ = vc
        if vc is not None:
            self._vispy_set_current()
            print('init')
            self._vispy_canvas.events.initialize()
        return self._vispy_canvas

    def _vispy_warmup(self):
        etime = time() + 0.1
        while time() < etime:
            sleep(0.01)
            self._vispy_set_current()
            self._vispy_canvas.app.process_events()

    def _vispy_set_current(self):
        if self._id is None:
            return
        # Make this the current context
        sdl2.SDL_GL_MakeCurrent(self._id.window, self._native_context)

    def _vispy_swap_buffers(self):
        if self._id is None:
            return
        # Swap front and back buffer
        sdl2.SDL_GL_SwapWindow(self._id.window)

    def _vispy_set_title(self, title):
        if self._id is None:
            return
        # Set the window title. Has no effect for widgets
        sdl2.SDL_SetWindowTitle(self._id.window, title.encode('UTF-8'))

    def _vispy_set_size(self, w, h):
        if self._id is None:
            return
        # Set size of the widget or window
        sdl2.SDL_SetWindowSize(self._id.window, w, h)

    def _vispy_set_position(self, x, y):
        if self._id is None:
            return
        # Set position of the widget or window. May have no effect for widgets
        sdl2.SDL_SetWindowPosition(self._id.window, x, y)

    def _vispy_set_visible(self, visible):
        # Show or hide the window or widget
        if self._id is None:
            return
        if visible:
            self._id.show()
            # this ensures that the show takes effect
            self._vispy_update()
        else:
            self._id.hide()

    def _vispy_update(self):
        # Invoke a redraw, passing it on to the canvas
        if self._vispy_canvas is None or self._id is None:
            return
        # Mark that this window wants to be painted on the next loop iter
        self._needs_draw = True

    def _vispy_close(self):
        # Force the window or widget to shut down
        if self._id is not None:
            _id = self._id.window
            self._id = None
            sdl2.SDL_DestroyWindow(_id)
            del _VP_SDL2_ALL_WINDOWS[self._sdl_id]
            self._sdl_id = None

    def _vispy_get_size(self):
        if self._id is None:
            return
        w, h = ctypes.c_int(), ctypes.c_int()
        sdl2.SDL_GetWindowSize(self._id.window,
                               ctypes.byref(w), ctypes.byref(h))
        w, h = w.value, h.value
        return w, h

    def _vispy_get_position(self):
        if self._id is None:
            return
        x, y = ctypes.c_int(), ctypes.c_int()
        sdl2.SDL_GetWindowPosition(self._id.window,
                                   ctypes.byref(x), ctypes.byref(y))
        x, y = x.value, y.value
        return x, y

    ##########################################
    # Notify vispy of events triggered by SDL2
    def _get_mouse_position(self):
        if self._id is None:
            return (0, 0)
        x, y = ctypes.c_int(), ctypes.c_int()
        sdl2.SDL_GetMouseState(ctypes.byref(x), ctypes.byref(y))
        return x.value, y.value

    def _on_draw(self):
        if self._vispy_canvas is None or self._id is None:
            return
        self._vispy_set_current()
        self._vispy_canvas.events.paint(region=None)  # (0, 0, w, h))

    def _on_event(self, event):
        if self._vispy_canvas is None:
            return
        # triage event to proper handler
        if event.type == sdl2.SDL_QUIT:
            self._vispy_canvas.events.close()
        elif event.type == sdl2.SDL_WINDOWEVENT:
            if event.window.event == sdl2.SDL_WINDOWEVENT_RESIZED:
                w, h = event.window.data1, event.window.data2
                self._vispy_canvas.events.resize(size=(w, h))
            elif event.window.event == sdl2.SDL_WINDOWEVENT_CLOSE:
                self._vispy_canvas.events.close()
        elif event.type == sdl2.SDL_MOUSEMOTION:
            x, y = event.motion.x, event.motion.y
            self._vispy_mouse_move(pos=(x, y), modifiers=self._mods)
        elif event.type in (sdl2.SDL_MOUSEBUTTONDOWN,
                            sdl2.SDL_MOUSEBUTTONUP):
            x, y = event.button.x, event.button.y
            button = event.button.button
            if button in BUTTONMAP:
                button = BUTTONMAP.get(button, 0)
                if event.type == sdl2.SDL_MOUSEBUTTONDOWN:
                    func = self._vispy_mouse_press
                else:
                    func = self._vispy_mouse_release
                func(pos=(x, y), button=button, modifiers=self._mods)
        elif event.type == sdl2.SDL_MOUSEWHEEL:
            pos = self._get_mouse_position()
            delta = float(event.wheel.x), float(event.wheel.y)
            self._vispy_canvas.events.mouse_wheel(pos=pos, delta=delta,
                                                  modifiers=self._mods)
        elif event.type in (sdl2.SDL_KEYDOWN, sdl2.SDL_KEYUP):
            down = (event.type == sdl2.SDL_KEYDOWN)
            keysym = event.key.keysym
            mods = keysym.mod
            key = keysym.sym
            self._process_mod(mods, down)
            if key in KEYMAP:
                key, text = KEYMAP[key], ''
            elif key >= 32 and key <= 127:
                key, text = keys.Key(chr(key)), chr(key)
            else:
                key, text = None, ''
            if down:
                fun = self._vispy_canvas.events.key_press
            else:
                fun = self._vispy_canvas.events.key_release
            fun(key=key, text=text, modifiers=self._mods)

    def _process_mod(self, key, down):
        _modifiers = list()
        if key & (sdl2.SDLK_LSHIFT | sdl2.SDLK_RSHIFT):
            _modifiers.append(keys.SHIFT)
        if key & (sdl2.SDLK_LCTRL | sdl2.SDLK_RCTRL):
            _modifiers.append(keys.CONTROL)
        if key & (sdl2.SDLK_LALT | sdl2.SDLK_RALT):
            _modifiers.append(keys.ALT)
        if key & (sdl2.SDLK_LGUI | sdl2.SDLK_RGUI):
            _modifiers.append(keys.META)
        for mod in _modifiers:
            if mod not in self._mods:
                if down:
                    self._mods.append(mod)
            elif not down:
                self._mods.pop(self._mods.index(mod))

# ------------------------------------------------------------------- timer ---


# XXX should probably use SDL_Timer (and SDL_INIT_TIMER)

class TimerBackend(BaseTimerBackend):

    def __init__(self, vispy_timer):
        BaseTimerBackend.__init__(self, vispy_timer)
        vispy_timer._app._backend._add_timer(self)
        self._vispy_stop()

    def _vispy_start(self, interval):
        self._interval = interval
        self._next_time = time() + self._interval

    def _vispy_stop(self):
        self._next_time = float('inf')

    def _tick(self):
        if time() >= self._next_time:
            self._vispy_timer._timeout()
            self._next_time = time() + self._interval

########NEW FILE########
__FILENAME__ = _template
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

""" This module provides an template for creating backends for vispy.
It clearly indicates what methods should be implemented and what events
should be emitted.
"""

from __future__ import division

from ..base import (BaseApplicationBackend, BaseCanvasBackend,
                    BaseTimerBackend, BaseSharedContext)
from ...util import keys


# -------------------------------------------------------------------- init ---

# Map native keys to vispy keys
KEYMAP = {
    -1: keys.SHIFT,
    -2: keys.CONTROL,
    -3: keys.ALT,
    -4: keys.META,

    -5: keys.LEFT,
    -6: keys.UP,
    -7: keys.RIGHT,
    -8: keys.DOWN,
    -9: keys.PAGEUP,
    -10: keys.PAGEDOWN,

    -11: keys.INSERT,
    -12: keys.DELETE,
    -13: keys.HOME,
    -14: keys.END,

    -15: keys.ESCAPE,
    -16: keys.BACKSPACE,

    -17: keys.SPACE,
    -18: keys.ENTER,
    -19: keys.TAB,

    -20: keys.F1,
    -21: keys.F2,
    -22: keys.F3,
    -23: keys.F4,
    -24: keys.F5,
    -25: keys.F6,
    -26: keys.F7,
    -27: keys.F8,
    -28: keys.F9,
    -29: keys.F10,
    -30: keys.F11,
    -31: keys.F12,
}


# -------------------------------------------------------------- capability ---

capability = dict(
    position=False,
    size=False,
    multi_window=False,
    scroll=False,
    no_decoration=False,
    no_sizing=False,
    fullscreen=False,
    unicode=False,
    gl_version=False,
    gl_profile=False,
    share_context=False,
)


# ------------------------------------------------------- set_configuration ---
def _set_config(c):
    """Set gl configuration for template"""
    raise NotImplementedError


class SharedContext(BaseSharedContext):
    _backend = 'template'


# ------------------------------------------------------------- application ---

class ApplicationBackend(BaseApplicationBackend):

    def __init__(self):
        BaseApplicationBackend.__init__(self)

    def _vispy_get_backend_name(self):
        return 'ThisBackendsName'

    def _vispy_process_events(self):
        raise NotImplementedError()

    def _vispy_run(self):
        raise NotImplementedError()

    def _vispy_quit(self):
        raise NotImplementedError()

    def _vispy_get_native_app(self):
        raise NotImplementedError()


# ------------------------------------------------------------------ canvas ---

# You can mix this class with the native widget
class CanvasBackend(BaseCanvasBackend):

    def __init__(self, vispy_canvas, *args, **kwargs):
        #NativeWidgetClass.__init__(self, *args, **kwargs)
        BaseCanvasBackend.__init__(self, vispy_canvas, SharedContext)

    def _vispy_set_current(self):
        # Make this the current context
        raise NotImplementedError()

    def _vispy_swap_buffers(self):
        # Swap front and back buffer
        raise NotImplementedError()

    def _vispy_set_title(self, title):
        # Set the window title. Has no effect for widgets
        raise NotImplementedError()

    def _vispy_set_size(self, w, h):
        # Set size of the widget or window
        raise NotImplementedError()

    def _vispy_set_position(self, x, y):
        # Set location of the widget or window. May have no effect for widgets
        raise NotImplementedError()

    def _vispy_set_visible(self, visible):
        # Show or hide the window or widget
        raise NotImplementedError()

    def _vispy_update(self):
        # Invoke a redraw
        raise NotImplementedError()

    def _vispy_close(self):
        # Force the window or widget to shut down
        raise NotImplementedError()

    def _vispy_get_size(self):
        # Should return widget size
        raise NotImplementedError()

    def _vispy_get_position(self):
        # Should return widget position
        raise NotImplementedError()

    def _vispy_get_native_canvas(self):
        # Should return the native widget object.
        # If this is self, this method can be omitted.
        return self

    def events_to_emit(self):
        """ Shown here in one method, but most backends will probably
        have one method for each event.
        """
        raise NotImplementedError
        """
        if self._vispy_canvas is None:
            return

        self._vispy_canvas.events.initialize()
        self._vispy_canvas.events.resize(size=(w, h))
        self._vispy_canvas.events.paint(region=None)
        self._vispy_canvas.events.close()

        self._vispy_canvas.events.mouse_press(
            pos=(
                x,
                y),
            button=1,
            modifiers=())
        self._vispy_canvas.events.mouse_release(
            pos=(
                x,
                y),
            button=1,
            modifiers=())
        self._vispy_canvas.events.mouse_move(pos=(x, y), modifiers=())
        self._vispy_canvas.events.mouse_wheel(
            pos=(
                x, y), delta=(
                0, 0), modifiers=())

        self._vispy_canvas.events.key_press(key=key, text=text, modifiers=())
        self._vispy_canvas.events.key_release(key=key, text=text, modifiers=())
        """


# ------------------------------------------------------------------- timer ---

class TimerBackend(BaseTimerBackend):  # Can be mixed with native timer class

    def __init__(self, vispy_timer):
        BaseTimerBackend.__init__(self, vispy_timer)

    def _vispy_start(self, interval):
        raise NotImplementedError()

    def _vispy_stop(self):
        raise NotImplementedError()

    def _vispy_timeout(self):
        raise NotImplementedError()

    def _vispy_get_native_timer(self):
        # Should return the native widget object.
        # If this is self, this method can be omitted.
        return self

########NEW FILE########
__FILENAME__ = _test
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

available = False
why_not = 'test backend should be skipped'
testable = False
which = None

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8 -*-

from inspect import getargspec
from copy import deepcopy

from ._config import get_default_config


class BaseApplicationBackend(object):
    """BaseApplicationBackend()

    Abstract class that provides an interface between backends and Application.
    Each backend must implement a subclass of ApplicationBackend, and
    implement all its _vispy_xxx methods.
    """

    def _vispy_get_backend_name(self):
        raise NotImplementedError()

    def _vispy_process_events(self):
        raise NotImplementedError()

    def _vispy_run(self):
        raise NotImplementedError()

    def _vispy_quit(self):
        raise NotImplementedError()

    def _vispy_get_native_app(self):
        # Should return the native application object
        return self


class BaseCanvasBackend(object):
    """BaseCanvasBackend(vispy_canvas, capability, context_type)

    Abstract class that provides an interface between backends and Canvas.
    Each backend must implement a subclass of CanvasBackend, and
    implement all its _vispy_xxx methods. Also, also a backend must
    make sure to generate the following events: 'initialize', 'resize',
    'paint', 'mouse_press', 'mouse_release', 'mouse_move',
    'mouse_wheel', 'key_press', 'key_release', 'close'.
    """

    def __init__(self, capability, context_type):
        # Initially the backend starts out with no canvas.
        # Canvas takes care of setting this for us.
        self._vispy_canvas = None

        # Data used in the construction of new mouse events
        self._vispy_mouse_data = {
            'buttons': [],
            'press_event': None,
            'last_event': None,
        }
        self._vispy_capability = capability
        self._vispy_context_type = context_type

    def _process_backend_kwargs(self, kwargs):
        """Removes vispy-specific kwargs for CanvasBackend"""
        # these are the output arguments
        keys = ['title', 'size', 'position', 'show', 'vsync', 'resizable',
                'decorate', 'fullscreen']
        from .canvas import Canvas
        outs = list()
        spec = getargspec(Canvas.__init__)
        for key in keys:
            default = spec.defaults[spec.args.index(key) - 1]
            out = kwargs.get(key, default)
            if out != default and self._vispy_capability[key] is False:
                raise RuntimeError('Cannot set property %s using this '
                                   'backend' % key)
            outs.append(out)

        # now we add context, which we have to treat slightly differently
        default_config = get_default_config()
        context = kwargs.get('context', default_config)
        can_share = self._vispy_capability['context']
        # check the type
        if isinstance(context, self._vispy_context_type):
            if not can_share:
                raise RuntimeError('Cannot share context with this backend')
        elif isinstance(context, dict):
            # first, fill in context with any missing entries
            context = deepcopy(context)
            for key, val in default_config.items():
                context[key] = context.get(key, default_config[key])
            # now make sure everything is of the proper type
            for key, val in context.items():
                if key not in default_config:
                    raise KeyError('context has unknown key %s' % key)
                needed = type(default_config[key])
                if not isinstance(val, needed):
                    raise TypeError('context["%s"] is of incorrect type (got '
                                    '%s need %s)' % (key, type(val), needed))
        else:
            raise TypeError('context must be a dict or SharedContext from '
                            'a Canvas with the same backend, not %s'
                            % type(context))
        outs.append(context)
        return outs

    def _vispy_set_current(self):
        # Make this the current context
        raise NotImplementedError()

    def _vispy_swap_buffers(self):
        # Swap front and back buffer
        raise NotImplementedError()

    def _vispy_set_title(self, title):
        # Set the window title. Has no effect for widgets
        raise NotImplementedError()

    def _vispy_set_size(self, w, h):
        # Set size of the widget or window
        raise NotImplementedError()

    def _vispy_set_position(self, x, y):
        # Set location of the widget or window. May have no effect for widgets
        raise NotImplementedError()

    def _vispy_set_visible(self, visible):
        # Show or hide the window or widget
        raise NotImplementedError()

    def _vispy_update(self):
        # Invoke a redraw
        raise NotImplementedError()

    def _vispy_close(self):
        # Force the window or widget to shut down
        raise NotImplementedError()

    def _vispy_get_size(self):
        # Should return widget size
        raise NotImplementedError()

    def _vispy_get_position(self):
        # Should return widget position
        raise NotImplementedError()

    def _vispy_get_geometry(self):
        # Should return widget (x, y, w, h)
        x, y = self._vispy_get_position()
        w, h = self._vispy_get_size()
        return x, y, w, h

    def _vispy_get_native_canvas(self):
        # Should return the native widget object
        # Most backends would not need to implement this
        return self

    def _vispy_mouse_press(self, **kwds):
        # default method for delivering mouse press events to the canvas
        kwds.update(self._vispy_mouse_data)
        ev = self._vispy_canvas.events.mouse_press(**kwds)
        if self._vispy_mouse_data['press_event'] is None:
            self._vispy_mouse_data['press_event'] = ev

        self._vispy_mouse_data['buttons'].append(ev.button)
        self._vispy_mouse_data['last_event'] = ev
        return ev

    def _vispy_mouse_move(self, **kwds):
        # default method for delivering mouse move events to the canvas
        kwds.update(self._vispy_mouse_data)

        # Break the chain of prior mouse events if no buttons are pressed
        # (this means that during a mouse drag, we have full access to every
        # move event generated since the drag started)
        if self._vispy_mouse_data['press_event'] is None:
            last_event = self._vispy_mouse_data['last_event']
            if last_event is not None:
                last_event._forget_last_event()

        ev = self._vispy_canvas.events.mouse_move(**kwds)
        self._vispy_mouse_data['last_event'] = ev
        return ev

    def _vispy_mouse_release(self, **kwds):
        # default method for delivering mouse release events to the canvas
        kwds.update(self._vispy_mouse_data)
        ev = self._vispy_canvas.events.mouse_release(**kwds)
        if ev.button == self._vispy_mouse_data['press_event'].button:
            self._vispy_mouse_data['press_event'] = None

        self._vispy_mouse_data['buttons'].remove(ev.button)
        self._vispy_mouse_data['last_event'] = ev
        return ev


class BaseTimerBackend(object):
    """BaseTimerBackend(vispy_timer)

    Abstract class that provides an interface between backends and Timer.
    Each backend must implement a subclass of TimerBackend, and
    implement all its _vispy_xxx methods.
    """

    def __init__(self, vispy_timer):
        self._vispy_timer = vispy_timer

    def _vispy_start(self, interval):
        raise NotImplementedError

    def _vispy_stop(self):
        raise NotImplementedError

    def _vispy_get_native_timer(self):
        # Should return the native timer object
        # Most backends would not need to implement this
        return self


class BaseSharedContext(object):
    """An object encapsulating data necessary for a shared OpenGL context

    The data are backend dependent."""
    def __init__(self, value):
        self._value = value

    @property
    def value(self):
        return self._value

    def __repr__(self):
        return ("<SharedContext for %s backend" % self._backend)

########NEW FILE########
__FILENAME__ = canvas
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

from __future__ import division, print_function

import numpy as np

from ._default_app import default_app
from ..util.event import EmitterGroup, Event
from ..util.ptime import time
from ..ext.six import string_types
from .application import Application
from ._config import get_default_config

# todo: add functions for asking about current mouse/keyboard state
# todo: add hover enter/exit events
# todo: add focus events


def _gloo_initialize(event):
    from ..gloo import gl_initialize
    gl_initialize()


class Canvas(object):
    """Representation of a GUI element with an OpenGL context

    Receives the following events:
    initialize, resize, paint, mouse_press, mouse_release, mouse_move,
    mouse_wheel, key_press, key_release, stylus, touch, close

    Parameters
    ----------
    title : str
        The widget title
    size : (width, height)
        The size of the window.
    position : (x, y)
        The position of the window in screen coordinates.
    show : bool
        Whether to show the widget immediately. Default False.
    autoswap : bool
        Whether to swap the buffers automatically after a paint event.
        Default True. If True, the ``swap_buffers`` Canvas method will
        be called last (by default) by the ``canvas.paint`` event handler.
    app : Application | str
        Give vispy Application instance to use as a backend.
        (vispy.app is used by default.) If str, then an application
        using the chosen backend (e.g., 'pyglet') will be created.
        Note the canvas application can be accessed at ``canvas.app``.
    create_native : bool
        Whether to create the widget immediately. Default True.
    init_gloo : bool
        Initialize standard values in gloo (e.g., ``GL_POINT_SPRITE``).
    vsync : bool
        Enable vertical synchronization.
    resizable : bool
        Allow the window to be resized.
    decorate : bool
        Decorate the window.
    fullscreen : bool | int
        If False, windowed mode is used (default). If True, the default
        monitor is used. If int, the given monitor number is used.
    context : dict | instance SharedContext | None
        OpenGL configuration to use when creating the context for the canvas,
        or a context to share. If None, ``vispy.app.get_default_config`` will
        be used to set the OpenGL context parameters. Alternatively, the
        ``canvas.context`` property from an existing canvas (using the
        same backend) will return a ``SharedContext`` that can be used,
        thereby sharing the existing context.
    close_keys : str | list of str
        Key to use that will cause the canvas to be closed.
    """

    def __init__(self, title='Vispy canvas', size=(800, 600), position=None,
                 show=False, autoswap=True, app=None, create_native=True,
                 init_gloo=True, vsync=False, resizable=True, decorate=True,
                 fullscreen=False, context=None, close_keys=()):
        self.events = EmitterGroup(source=self,
                                   initialize=Event,
                                   resize=ResizeEvent,
                                   paint=PaintEvent,
                                   mouse_press=MouseEvent,
                                   mouse_release=MouseEvent,
                                   mouse_move=MouseEvent,
                                   mouse_wheel=MouseEvent,
                                   key_press=KeyEvent,
                                   key_release=KeyEvent,
                                   stylus=Event,
                                   touch=Event,
                                   close=Event)
        size = [int(s) for s in size]
        if len(size) != 2:
            raise ValueError('size must be a 2-element list')
        title = str(title)
        if not isinstance(fullscreen, (bool, int)):
            raise TypeError('fullscreen must be bool or int')
        if context is None:
            context = get_default_config()

        # Initialize backend attribute
        self._backend = None
        if init_gloo:
            self.events.initialize.connect(_gloo_initialize,
                                           ref='gloo_initialize')

        # store arguments that get set on Canvas init
        kwargs = dict(title=title, size=size, position=position, show=show,
                      vsync=vsync, resizable=resizable, decorate=decorate,
                      fullscreen=fullscreen, context=context)
        self._backend_kwargs = kwargs

        # Initialise some values
        self._autoswap = autoswap
        self._title = title
        self._frame_count = 0
        self._fps = 0
        self._basetime = time()
        self._fps_callback = None

        # Get app instance
        if isinstance(app, string_types):
            app = Application(app)
        self._app = default_app if app is None else app

        # Create widget now
        if create_native:
            self.create_native()

        # Close keys
        def close_keys_check(event):
            if event.key in self.close_keys:
                self.close()
        if isinstance(close_keys, string_types):
            close_keys = [close_keys]
        self.close_keys = close_keys
        self.events.key_press.connect(close_keys_check, ref=True)

    def create_native(self):
        """ Create the native widget if not already done so. If the widget
        is already created, this function does nothing.
        """
        if self._backend is not None:
            return
        # Make sure that the app is active
        self._app.use()
        assert self._app.native
        # Instantiate the backend with the right class
        be = self._app.backend_module.CanvasBackend(**self._backend_kwargs)
        self._set_backend(be)

    def _set_backend(self, backend):
        """ Set backend<->canvas references and autoswap
        """
        assert backend is not None  # should never happen
        self._backend = backend
        self._backend._vispy_canvas = self
        if self._autoswap:
            # append to the end
            self.events.paint.connect((self, 'swap_buffers'),
                                      ref=True, position='last')

    @property
    def context(self):
        """ The OpenGL context of the native widget
        """
        return self._backend._vispy_context

    @property
    def app(self):
        """ The vispy Application instance on which this Canvas is based.
        """
        return self._app

    @property
    def native(self):
        """ The native widget object on which this Canvas is based.
        """
        return self._backend._vispy_get_native_canvas()

    def connect(self, fun):
        """ Connect a function to an event. The name of the function
        should be on_X, with X the name of the event (e.g. 'on_paint').

        This method is typically used as a decorater on a function
        definition for an event handler.
        """
        # Get and check name
        name = fun.__name__
        if not name.startswith('on_'):
            raise ValueError('When connecting a function based on its name, '
                             'the name should start with "on_"')
        eventname = name[3:]
        # Get emitter
        try:
            emitter = self.events[eventname]
        except KeyError:
            raise ValueError(
                'Event "%s" not available on this canvas.' %
                eventname)
        # Connect
        emitter.connect(fun)

    # ---------------------------------------------------------------- size ---
    @property
    def size(self):
        """ The size of canvas/window """
        return self._backend._vispy_get_size()

    @size.setter
    def size(self, size):
        return self._backend._vispy_set_size(size[0], size[1])

    # ------------------------------------------------------------ position ---
    @property
    def position(self):
        """ The position of canvas/window relative to screen """
        return self._backend._vispy_get_position()

    @position.setter
    def position(self, position):
        assert len(position) == 2
        return self._backend._vispy_set_position(position[0], position[1])

    # --------------------------------------------------------------- title ---
    @property
    def title(self):
        """ The title of canvas/window """
        return self._title

    @title.setter
    def title(self, title):
        self._title = title
        self._backend._vispy_set_title(title)

    # ----------------------------------------------------------------- fps ---
    @property
    def fps(self):
        """ The fps of canvas/window, measured as the rate that events.paint
        is emitted. """
        return self._fps

    def swap_buffers(self, event=None):
        """ Swap GL buffers such that the offscreen buffer becomes visible.
        """
        self._backend._vispy_swap_buffers()

    def show(self, visible=True):
        """ Show (or hide) the canvas """
        return self._backend._vispy_set_visible(visible)

    def update(self):
        """ Inform the backend that the Canvas needs to be repainted """
        if self._backend is not None:
            return self._backend._vispy_update()
        else:
            return

    def close(self):
        """ Close the canvas

        Note: This will usually destroy the GL context. For Qt, the context
        (and widget) will be destroyed only if the widget is top-level.
        To avoid having the widget destroyed (more like standard Qt
        behavior), consider making the widget a sub-widget.
        """
        if self._backend is not None:
            self._backend._vispy_close()
            self._backend._vispy_canvas = None

    def _update_fps(self, event):
        """ Updates the fps after every window and resets the basetime
        and frame count to current time and 0, respectively
        """
        self._frame_count += 1
        diff = time() - self._basetime
        if (diff > self._fps_window):
            self._fps = self._frame_count/diff
            self._basetime = time()
            self._frame_count = 0
            self._fps_callback(self.fps)

    def measure_fps(self, window=1, callback=print):
        """Measure the current FPS

        Sets the update window, connects the paint event to
        update_fps and sets the callback function
        If no callback is passed, measurement stops.

        Parameters
        ----------
        window : int
            The window number.
        callback : function
            The function to call with the FPS. Default is ``print``.
        """
        # Connect update_fps function to paint
        self.events.paint.disconnect(self._update_fps)
        if callback:
            self._fps_window = window
            self.events.paint.connect(self._update_fps)
            self._fps_callback = callback
        else:
            self._fps_callback = None

    # ---------------------------------------------------------------- misc ---
    def __repr__(self):
        return ('<Vispy canvas (%s backend) at %s>'
                % (self.app.backend_name, hex(id(self))))

    def __enter__(self):
        self.show()
        self._backend._vispy_warmup()
        return self

    def __exit__(self, type, value, traceback):
        self.swap_buffers()  # ensure all GL calls are complete
        self.close()

    # def mouse_event(self, event):
        #"""Called when a mouse input event has occurred (the mouse has moved,
        # a button was pressed/released, or the wheel has moved)."""

    # def key_event(self, event):
        #"""Called when a keyboard event has occurred (a key was pressed or
        # released while the canvas has focus)."""

    # def touch_event(self, event):
        #"""Called when the user touches the screen over a Canvas.

        # Event properties:
        #     event.touches
        #     [ (x,y,pressure), ... ]
        #"""

    # def stylus_event(self, event):
        #"""Called when a stylus has been used to interact with the Canvas.

        # Event properties:
        #     event.device
        #     event.pos  (x,y)
        #     event.pressure
        #     event.angle
        #"""

    # def initialize_event(self, event):
        #"""Called when the OpenGL context is initialy made available for this
        # Canvas."""

    # def resize_event(self, event):
        #"""Called when the Canvas is resized.

        # Event properties:
        #     event.size  (w,h)
        #"""

    # def paint_event(self, event):
        #"""Called when all or part of the Canvas needs to be repainted.

        # Event properties:
        #     event.region  (x,y,w,h) region of Canvas requiring repaint
        #"""


# Event subclasses specific to the Canvas
class MouseEvent(Event):

    """Mouse event class

    Note that each event object has an attribute for each of the input
    arguments listed below.

    Parameters
    ----------
    type : str
       String indicating the event type (e.g. mouse_press, key_release)
    pos : (int, int)
        The position of the mouse (in screen coordinates).
    button : int
        The button that generated this event (can be None).
        Left=1, right=2, middle=3.
    buttons : [int, ...]
        The list of buttons depressed during this event.
    modifiers : tuple of Key instances
        Tuple that specifies which modifier keys were pressed down at the
        time of the event (shift, control, alt, meta).
    delta : (float, float)
        The amount of scrolling in horizontal and vertical direction. One
        "tick" corresponds to a delta of 1.0.
    press_event : MouseEvent
        The press event that was generated at the start of the current drag,
        if any.
    last_event : MouseEvent
        The MouseEvent immediately preceding the current event. During drag
        operations, all generated events retain their last_event properties,
        allowing the entire drag to be reconstructed.
    native : object (optional)
       The native GUI event object
    **kwds : keyword arguments
        All extra keyword arguments become attributes of the event object.

    """

    def __init__(self, type, pos=None, button=None, buttons=None,
                 modifiers=None, delta=None, last_event=None, press_event=None,
                 **kwds):
        Event.__init__(self, type, **kwds)
        self._pos = (0, 0) if (pos is None) else (pos[0], pos[1])
        self._button = int(button) if (button is not None) else 0
        self._buttons = [] if (buttons is None) else buttons
        self._modifiers = tuple(modifiers or ())
        self._delta = (0.0, 0.0) if (delta is None) else (delta[0], delta[1])
        self._last_event = last_event
        self._press_event = press_event

    @property
    def pos(self):
        return self._pos

    @property
    def button(self):
        return self._button

    @property
    def buttons(self):
        return self._buttons

    @property
    def modifiers(self):
        return self._modifiers

    @property
    def delta(self):
        return self._delta

    @property
    def press_event(self):
        return self._press_event

    @property
    def last_event(self):
        return self._last_event

    def _forget_last_event(self):
        # Needed to break otherwise endless last-event chains
        self._last_event = None

    @property
    def is_dragging(self):
        """ Indicates whether this event is part of a mouse drag operation.
        """
        return self.press_event is not None

    def drag_events(self):
        """ Return a list of all mouse events in the current drag operation.

        Returns None if there is no current drag operation.
        """
        if not self.is_dragging:
            return None

        event = self
        events = []
        while True:
            # mouse_press events can only be the start of a trail
            if event is None or event.type == 'mouse_press':
                break
            events.append(event)
            event = event.last_event

        return events[::-1]

    def trail(self):
        """ Return an (N, 2) array of mouse coordinates for every event in the
        current mouse drag operation.

        Returns None if there is no current drag operation.
        """
        events = self.drag_events()
        if events is None:
            return None

        trail = np.empty((len(events), 2), dtype=int)
        for i, ev in enumerate(events):
            trail[i] = ev.pos

        return trail


class KeyEvent(Event):

    """Key event class

    Note that each event object has an attribute for each of the input
    arguments listed below.

    Parameters
    ----------
    type : str
       String indicating the event type (e.g. mouse_press, key_release)
    key : vispy.keys.Key instance
        The Key object for this event. Can be compared to string names.
    text : str
        The text representation of the key (can be an empty string).
    modifiers : tuple of Key instances
        Tuple that specifies which modifier keys were pressed down at the
        time of the event (shift, control, alt, meta).
    native : object (optional)
       The native GUI event object
    **kwds : keyword arguments
        All extra keyword arguments become attributes of the event object.
    """

    def __init__(self, type, key=None, text='', modifiers=None, **kwds):
        Event.__init__(self, type, **kwds)
        self._key = key
        self._text = text
        self._modifiers = tuple(modifiers or ())

    @property
    def key(self):
        return self._key

    @property
    def text(self):
        return self._text

    @property
    def modifiers(self):
        return self._modifiers


class ResizeEvent(Event):

    """ Resize event class

    Note that each event object has an attribute for each of the input
    arguments listed below.

    Parameters
    ----------
    type : str
       String indicating the event type (e.g. mouse_press, key_release)
    size : (int, int)
        The new size of the Canvas.
    native : object (optional)
       The native GUI event object
    **kwds : extra keyword arguments
        All extra keyword arguments become attributes of the event object.
    """

    def __init__(self, type, size=None, **kwds):
        Event.__init__(self, type, **kwds)
        self._size = tuple(size)

    @property
    def size(self):
        return self._size


class PaintEvent(Event):

    """ Paint event class

    This type of event is sent to Canvas.events.paint when a repaint
    is required.

    Note that each event object has an attribute for each of the input
    arguments listed below.

    Parameters
    ----------
    type : str
       String indicating the event type (e.g. mouse_press, key_release)
    region : (int, int, int, int) or None
        The region of the canvas which needs to be repainted (x, y, w, h).
        If None, the entire canvas must be repainted.
    native : object (optional)
       The native GUI event object
    **kwds : extra keyword arguments
        All extra keyword arguments become attributes of the event object.
    """

    def __init__(self, type, region=None, **kwds):
        Event.__init__(self, type, **kwds)
        self._region = region

    @property
    def region(self):
        return self._region

########NEW FILE########
__FILENAME__ = test_app
import numpy as np
import sys
from collections import namedtuple
from time import sleep

from numpy.testing import assert_array_equal
from nose.tools import assert_equal, assert_true, assert_raises

from vispy.app import default_app, Canvas, Timer, MouseEvent, KeyEvent
from vispy.app.base import BaseApplicationBackend
from vispy.testing import requires_application, SkipTest, assert_is
from vispy.util import keys

from vispy.gloo.program import (Program, VertexBuffer, IndexBuffer)
from vispy.gloo.shader import VertexShader, FragmentShader
from vispy.gloo.util import _screenshot
from vispy.gloo import gl

gl.use('desktop debug')


def on_nonexist(self, *args):
    return


def on_mouse_move(self, *args):
    return


def _on_mouse_move(self, *args):
    return


def _test_callbacks(canvas):
    """Tests input capabilities, triaging based on backend"""
    backend_name = canvas._app.backend_name
    backend = canvas._backend
    if backend_name.lower() == 'pyglet':
        # Test Pyglet callbacks can take reasonable args
        backend.on_resize(100, 100)
        backend.our_paint_func()
        backend.on_mouse_press(10, 10, 1)
        backend.on_mouse_release(10, 11, 1)
        backend.on_mouse_motion(10, 12, 0, 1)
        backend.on_mouse_drag(10, 13, 0, 1, 1, 0)
        backend.on_mouse_scroll(10, 13, 1, 1)
        backend.on_key_press(10, 0)
        backend.on_key_release(10, 0)
        backend.on_text('foo')
    elif backend_name.lower() == 'glfw':
        # Test GLFW callbacks can take reasonable args
        _id = backend._id
        backend._on_draw(_id)
        backend._on_resize(_id, 100, 100)
        backend._on_key_press(_id, 50, 50, 1, 0)
        backend._on_mouse_button(_id, 1, 1, 0)
        backend._on_mouse_scroll(_id, 1, 0)
        backend._on_mouse_motion(_id, 10, 10)
        backend._on_close(_id)
    elif 'qt' in backend_name.lower():
        # constructing fake Qt events is too hard :(
        pass
    elif 'sdl2' in backend_name.lower():
        event = namedtuple('event', ['type', 'window', 'motion', 'button',
                                     'wheel', 'key'])
        event.type = 512  # WINDOWEVENT
        event.window = namedtuple('window', ['event', 'data1', 'data2'])
        event.motion = namedtuple('motion', ['x', 'y'])
        event.button = namedtuple('button', ['x', 'y', 'button'])
        event.wheel = namedtuple('wheel', ['x', 'y'])
        event.key = namedtuple('key', ['keysym'])
        event.key.keysym = namedtuple('keysym', ['mod', 'sym'])

        event.window.event = 5  # WINDOWEVENT_RESIZED
        event.window.data1 = 10
        event.window.data2 = 20
        backend._on_event(event)

        event.type = 1024  # SDL_MOUSEMOTION
        event.motion.x, event.motion.y = 1, 1
        backend._on_event(event)

        event.type = 1025  # MOUSEBUTTONDOWN
        event.button.x, event.button.y, event.button.button = 1, 1, 1
        backend._on_event(event)
        event.type = 1026  # MOUSEBUTTONUP
        backend._on_event(event)

        event.type = 1027  # sdl2.SDL_MOUSEWHEEL
        event.wheel.x, event.wheel.y = 0, 1
        backend._on_event(event)

        event.type = 768  # SDL_KEYDOWN
        event.key.keysym.mod = 1073742049  # SLDK_LSHIFT
        event.key.keysym.sym = 1073741906  # SDLK_UP
        backend._on_event(event)
        event.type = 769  # SDL_KEYUP
        backend._on_event(event)
    elif 'glut' in backend_name.lower():
        backend.on_mouse_action(0, 0, 0, 0)
        backend.on_mouse_action(0, 1, 0, 0)
        backend.on_mouse_action(3, 0, 0, 0)
        backend.on_draw()
        backend.on_mouse_motion(1, 1)
        # Skip keypress tests b/c of glutGetModifiers warning
        #for key in (100, 'a'):
        #    backend.on_key_press(key, 0, 0)
        #    backend.on_key_release(key, 0, 0)
    else:
        raise ValueError


@requires_application()
def test_run():
    """Test app running"""
    a = default_app
    a.use()
    if a.backend_name.lower() == 'glut':
        raise SkipTest('cannot test running glut')  # knownfail
    for _ in range(2):
        with Canvas(size=(100, 100), show=True, title=' run') as c:
            @c.events.paint.connect
            def paint(event):
                print(event)  # test event __repr__
                c.app.quit()
            c.update()
            c.app.run()
        c.app.quit()  # make sure it doesn't break if a user quits twice


@requires_application()
def test_capability():
    """Test application capability enumeration"""
    non_default_vals = dict(title='foo', size=[100, 100], position=[0, 0],
                            show=True, decorate=False, resizable=False,
                            vsync=True)  # context is tested elsewhere
    good_kwargs = dict()
    bad_kwargs = dict()
    with Canvas() as c:
        for key, val in c._backend._vispy_capability.items():
            if key in non_default_vals:
                if val:
                    good_kwargs[key] = non_default_vals[key]
                else:
                    bad_kwargs[key] = non_default_vals[key]
    # ensure all settable values can be set
    with Canvas(**good_kwargs):
        # some of these are hard to test, and the ones that are easy are
        # tested elsewhere, so let's just make sure it runs here
        pass
    # ensure that *any* bad argument gets caught
    for key, val in bad_kwargs.items():
        assert_raises(RuntimeError, Canvas, **{key: val})


@requires_application()
def test_application():
    """Test application running"""
    app = default_app
    print(app)  # __repr__ without app
    app.create()
    wrong = 'glut' if app.backend_name.lower() != 'glut' else 'pyglet'
    assert_raises(RuntimeError, app.use, wrong)
    app.process_events()
    print(app)  # test __repr__

    # Canvas
    pos = [0, 0]
    size = (100, 100)
    # Use "with" statement so failures don't leave open window
    # (and test context manager behavior)
    title = 'default'
    with Canvas(title=title, size=size, app=app, show=True,
                position=pos) as canvas:
        assert_true(canvas.create_native() is None)  # should be done already
        assert_is(canvas.app, app)
        assert_true(canvas.native)
        assert_equal('swap_buffers', canvas.events.paint.callback_refs[-1])

        # FPS
        canvas.measure_fps(0.001)
        sleep(0.002)
        canvas.update()
        app.process_events()
        assert_true(canvas.fps > 0)

        # Other methods
        print(canvas)  # __repr__
        assert_equal(canvas.title, title)
        canvas.title = 'you'
        canvas.position = pos
        canvas.size = size
        canvas.connect(on_mouse_move)
        assert_raises(ValueError, canvas.connect, _on_mouse_move)
        if sys.platform != 'darwin':  # XXX knownfail, prob. needs warmup
            canvas.show(False)
            canvas.show()
        app.process_events()
        assert_raises(ValueError, canvas.connect, on_nonexist)

        # screenshots
        gl.glViewport(0, 0, *size)
        ss = _screenshot()
        assert_array_equal(ss.shape, size + (3,))
        assert_equal(len(canvas._backend._vispy_get_geometry()), 4)
        if (app.backend_name.lower() != 'glut' and  # XXX knownfail for Almar
                sys.platform != 'win32'):  # XXX knownfail for windows
            assert_array_equal(canvas.size, size)
        assert_equal(len(canvas.position), 2)  # XXX knawnfail, doesn't "take"

        # GLOO: should have an OpenGL context already, so these should work
        vert = VertexShader("void main (void) {gl_Position = pos;}")
        frag = FragmentShader("void main (void) {gl_FragColor = pos;}")
        program = Program(vert, frag)
        assert_raises(RuntimeError, program.activate)

        vert = VertexShader("uniform vec4 pos;"
                            "void main (void) {gl_Position = pos;}")
        frag = FragmentShader("uniform vec4 pos;"
                              "void main (void) {gl_FragColor = pos;}")
        program = Program(vert, frag)
        #uniform = program.uniforms[0]
        program['pos'] = [1, 2, 3, 4]
        program.activate()  # should print
        #uniform.upload(program)
        program.detach(vert)
        program.detach(frag)
        assert_raises(RuntimeError, program.detach, vert)
        assert_raises(RuntimeError, program.detach, frag)

        vert = VertexShader("attribute vec4 pos;"
                            "void main (void) {gl_Position = pos;}")
        frag = FragmentShader("void main (void) {}")
        program = Program(vert, frag)
        #attribute = program.attributes[0]
        program["pos"] = [1, 2, 3, 4]
        program.activate()
        #attribute.upload(program)
        # cannot get element count
        #assert_raises(RuntimeError, program.draw, 'POINTS')

        # use a real program
        vert = ("uniform mat4 u_model;"
                "attribute vec2 a_position; attribute vec4 a_color;"
                "varying vec4 v_color;"
                "void main (void) {v_color = a_color;"
                "gl_Position = u_model * vec4(a_position, 0.0, 1.0);"
                "v_color = a_color;}")
        frag = "void main() {gl_FragColor = vec4(0, 0, 0, 1);}"
        n, p = 250, 50
        T = np.random.uniform(0, 2 * np.pi, n)
        position = np.zeros((n, 2), dtype=np.float32)
        position[:, 0] = np.cos(T)
        position[:, 1] = np.sin(T)
        color = np.ones((n, 4), dtype=np.float32) * (1, 1, 1, 1)
        data = np.zeros(n * p, [('a_position', np.float32, 2),
                                ('a_color', np.float32, 4)])
        data['a_position'] = np.repeat(position, p, axis=0)
        data['a_color'] = np.repeat(color, p, axis=0)

        program = Program(vert, frag)
        program.bind(VertexBuffer(data))
        program['u_model'] = np.eye(4, dtype=np.float32)
        # different codepath if no call to activate()
        program.draw(gl.GL_POINTS)
        subset = IndexBuffer(np.arange(10, dtype=np.uint32))
        program.draw(gl.GL_POINTS, subset)

        # bad programs
        frag_bad = ("varying vec4 v_colors")  # no semicolon
        program = Program(vert, frag_bad)
        assert_raises(RuntimeError, program.activate)
        frag_bad = None  # no fragment code. no main is not always enough
        program = Program(vert, frag_bad)
        assert_raises(ValueError, program.activate)

        # Timer
        timer = Timer(interval=0.001, connect=on_mouse_move, iterations=2,
                      start=True, app=app)
        timer.start()
        timer.interval = 0.002
        assert_equal(timer.interval, 0.002)
        assert_true(timer.running)
        timer.stop()
        assert_true(not timer.running)
        assert_true(timer.native)
        timer.disconnect()

        # test that callbacks take reasonable inputs
        _test_callbacks(canvas)

        # cleanup
        canvas.swap_buffers()
        canvas.update()
        app.process_events()
        # put this in even though __exit__ will call it to make sure we don't
        # have problems calling it multiple times
        canvas.close()  # done by context


@requires_application()
def test_fs():
    """Test fullscreen support"""
    a = default_app
    a.use()
    assert_raises(TypeError, Canvas, fullscreen='foo')
    if a.backend_name.lower() in ('glfw', 'sdl2'):  # takes over screen
        raise SkipTest('glfw and sdl2 take over screen')
    with Canvas(fullscreen=True):
        pass
    with Canvas(fullscreen=0):
        pass


@requires_application()
def test_close_keys():
    """Test close keys"""
    c = Canvas(close_keys='ESCAPE')
    x = list()

    @c.events.close.connect
    def closer(event):
        x.append('done')
    c.events.key_press(key=keys.ESCAPE, text='', modifiers=[])
    # XXX known fail: this works on Qt, but not any other backend,
    # the flow of canvas.close() is inconsistent (and should close_keys)
    # call canvas.close(), or canvas.events.close()?
    #assert_equal(len(x), 1)  # ensure the close event was sent
    c.app.process_events()


def test_abstract():
    """Test app abstract template"""
    app = BaseApplicationBackend()
    for fun in (app._vispy_get_backend_name, app._vispy_process_events,
                app._vispy_run, app._vispy_quit):
        assert_raises(NotImplementedError, fun)


def test_mouse_key_events():
    """Test mouse and key events"""
    me = MouseEvent('mouse_press')
    for fun in (me.pos, me.button, me.buttons, me.modifiers, me.delta,
                me.press_event, me.last_event, me.is_dragging):
        fun
    me.drag_events()
    me._forget_last_event()
    me.trail()
    ke = KeyEvent('key_release')
    ke.key
    ke.text
    ke.modifiers

########NEW FILE########
__FILENAME__ = test_backends
""" Tests to quickly see if the backends look good.
This tests only to see if all the necessary methods are implemented,
whether all the right events are mentioned, and whether the keymap
contains all keys that should be supported.

This test basically checks whether nothing was forgotten, not that the
implementation is corect.

"""

from nose.tools import assert_raises
from inspect import getargspec

import vispy
from vispy import keys
from vispy.testing import requires_application
from vispy.app import default_app
from vispy.app.backends import _template


def _test_module_properties(_module=None):
    """Test application module"""
    if _module is None:
        default_app.use()
        _module = default_app.backend_module

    # Test that the keymap contains all keys supported by vispy.
    keymap = _module.KEYMAP
    vispy_keys = keymap.values()
    for keyname in dir(keys):
        if keyname.upper() != keyname:
            continue
        key = getattr(keys, keyname)
        assert key in vispy_keys

    # Test that all _vispy_x methods are there.
    exceptions = (
        '_vispy_get_native_canvas',
        '_vispy_get_native_timer',
        '_vispy_get_native_app',
        '_vispy_mouse_move',
        '_vispy_mouse_press',
        '_vispy_mouse_release',
        '_vispy_get_geometry',
        '_process_backend_kwargs')  # defined in base class

    Klass = _module.CanvasBackend
    KlassRef = vispy.app.base.BaseCanvasBackend
    base = KlassRef(None, None)
    for key in dir(KlassRef):
        if not key.startswith('__'):
            method = getattr(Klass, key)
            if key not in exceptions:
                print(key)
                args = [None] * (len(getargspec(method).args) - 1)
                assert_raises(NotImplementedError, getattr(base, key),
                              *args)
                if hasattr(method, '__module__'):
                    mod_str = method.__module__  # Py3k
                else:
                    mod_str = method.im_func.__module__
                assert mod_str == _module.__name__, \
                    "Method %s.%s not defined in %s" \
                    % (Klass, key, _module.__name__)

    Klass = _module.TimerBackend
    KlassRef = vispy.app.timer.TimerBackend
    for key in dir(KlassRef):
        if not key.startswith('__'):
            method = getattr(Klass, key)
            if key not in exceptions:
                if hasattr(method, '__module__'):
                    # Py3k
                    assert method.__module__ == _module.__name__
                else:
                    t = method.im_func.__module__ == _module.__name__
                    assert t

    Klass = _module.ApplicationBackend
    KlassRef = vispy.app.application.ApplicationBackend
    for key in dir(KlassRef):
        if not key.startswith('__'):
            method = getattr(Klass, key)
            if key not in exceptions:
                if hasattr(method, '__module__'):
                    # Py3k
                    assert method.__module__ == _module.__name__
                else:
                    t = method.im_func.__module__ == _module.__name__
                    assert t

    # Test that all events seem to be emitted.
    # Get text
    fname = _module.__file__.strip('c')
    text = open(fname, 'rb').read().decode('utf-8')

    canvas = vispy.app.Canvas(create_native=False)
    # Stylus and touch are ignored because they are not yet implemented.
    # Mouse events are emitted from the CanvasBackend base class.
    ignore = set(['stylus', 'touch', 'mouse_press',
                  'mouse_move', 'mouse_release'])
    eventNames = set(canvas.events._emitters.keys()) - ignore

    for name in eventNames:
        assert 'events.%s' % name in text, ('events.%s does not appear '
                                            'in %s' % (name, fname))


def test_template():
    """Test application module template"""
    _test_module_properties(_template)
    assert_raises(NotImplementedError, _template._set_config, dict())
    a = _template.ApplicationBackend()
    print(a._vispy_get_backend_name())
    for method in (a._vispy_process_events, a._vispy_run, a._vispy_quit,
                   a._vispy_get_native_app):
        assert_raises(NotImplementedError, method)

    c = _template.CanvasBackend(None)
    print(c._vispy_get_native_canvas())
    for method in (c.events_to_emit, c._vispy_set_current,
                   c._vispy_swap_buffers, c._vispy_update, c._vispy_close,
                   c._vispy_get_size, c._vispy_get_position):
        assert_raises(NotImplementedError, method)
    for method in (c._vispy_set_title, c._vispy_set_visible):
        assert_raises(NotImplementedError, method, 0)
    for method in (c._vispy_set_size, c._vispy_set_position):
        assert_raises(NotImplementedError, method, 0, 0)


@requires_application()
def test_actual():
    """Test actual application module"""
    _test_module_properties(None)

########NEW FILE########
__FILENAME__ = test_context
import os
from nose.tools import assert_equal, assert_raises

from vispy.testing import requires_application, SkipTest
from vispy.app import Canvas, default_app
from vispy.gloo import (get_gl_configuration, VertexShader, FragmentShader,
                        Program, check_error)


@requires_application()
def test_context_properties():
    """Test setting context properties"""
    a = default_app
    a.use()
    if a.backend_name.lower() == 'pyglet':
        return  # cannot set more than once on Pyglet
    # stereo, double buffer won't work on every sys
    contexts = [dict(samples=4), dict(stencil_size=8),
                dict(samples=4, stencil_size=8)]
    if a.backend_name.lower() != 'glfw':  # glfw *always* double-buffers
        contexts.append(dict(double_buffer=False, samples=4))
        contexts.append(dict(double_buffer=False))
    else:
        assert_raises(RuntimeError, Canvas, app=a,
                      context=dict(double_buffer=False))
    if a.backend_name.lower() == 'sdl2' and os.getenv('TRAVIS') == 'true':
        raise SkipTest('Travis SDL cannot set context')
    for context in contexts:
        n_items = len(context)
        with Canvas(context=context):
            if os.getenv('TRAVIS', 'false') == 'true':
                # Travis cannot handle obtaining these values
                props = context
            else:
                props = get_gl_configuration()
            assert_equal(len(context), n_items)
            for key, val in context.items():
                assert_equal(val, props[key], key)
    assert_raises(TypeError, Canvas, context='foo')
    assert_raises(KeyError, Canvas, context=dict(foo=True))
    assert_raises(TypeError, Canvas, context=dict(double_buffer='foo'))


@requires_application()
def test_context_sharing():
    """Test context sharing"""
    with Canvas() as c1:
        vert = VertexShader("uniform vec4 pos;"
                            "void main (void) {gl_Position = pos;}")
        frag = FragmentShader("uniform vec4 pos;"
                              "void main (void) {gl_FragColor = pos;}")
        program = Program(vert, frag)
        program['pos'] = [1, 2, 3, 4]
        program.activate()  # should print

        def check():
            program.activate()
            check_error()

        with Canvas() as c:
            # pyglet always shares
            if 'pyglet' not in c.app.backend_name.lower():
                assert_raises(RuntimeError, check)
        if c1.app.backend_name.lower() in ('glut',):
            assert_raises(RuntimeError, Canvas, context=c1.context)
        else:
            with Canvas(context=c1.context):
                check()

########NEW FILE########
__FILENAME__ = test_qt
# Import PyQt4, vispy will see this and use that as a backend
# Also import QtOpenGL, because vispy needs it.

# This is a strange test: vispy does not need designer or uic stuff to run!

from os import path as op

from vispy.app import Canvas, default_app
from vispy.testing import requires_application, SkipTest
from vispy.gloo import gl


@requires_application('qt', has=['uic'])
def test_qt_designer():
    """Embed Canvas via Qt Designer"""
    default_app.use()
    if 'pyqt4' not in default_app.backend_name.lower():
        raise SkipTest('Not using PyQt4 backend')  # wrong backend
    from PyQt4 import uic
    fname = op.join(op.dirname(__file__), 'qt-designer.ui')
    WindowTemplate, TemplateBaseClass = uic.loadUiType(fname)
    default_app.create()  # make sure we have an app, or the init will fail

    class MainWindow(TemplateBaseClass):

        def __init__(self):
            TemplateBaseClass.__init__(self)

            self.ui = WindowTemplate()
            self.ui.setupUi(self)
            self.show()

    win = MainWindow()
    try:
        win.show()
        canvas = Canvas(create_native=False)
        canvas.app.use()  # Make sure the app exists (because create_native=0)
        canvas._set_backend(win.ui.canvas)
        canvas.create_native()

        @canvas.events.paint.connect
        def on_paint(ev):
            gl.glClearColor(0.0, 0.0, 0.0, 0.0)
            gl.glClear(gl.GL_COLOR_BUFFER_BIT)
            canvas.swap_buffers()
    finally:
        win.close()

########NEW FILE########
__FILENAME__ = test_simultaneous
# -*- coding: utf-8 -*-

import numpy as np
from numpy.testing import assert_allclose
from nose.tools import assert_true
from time import sleep

from vispy.app import default_app, Canvas, Timer
from vispy.testing import requires_application, SkipTest
from vispy.util.ptime import time
from vispy.gloo import gl
from vispy.gloo.util import _screenshot

_win_size = (200, 50)


def _update_process_check(canvas, val, paint=True):
    """Update, process, and check result"""
    if paint:
        canvas.update()
        canvas.app.process_events()
        canvas.app.process_events()
        sleep(0.03)  # give it time to swap (Qt?)
    canvas._backend._vispy_set_current()
    print('           check %s' % val)
    # check screenshot to see if it's all one color
    ss = _screenshot()
    try:
        assert_allclose(ss.shape[:2], _win_size[::-1])
    except Exception:
        print('!!!!!!!!!! FAIL  bad size %s' % list(ss.shape[:2]))
        raise
    goal = val * np.ones(ss.shape)
    try:
        assert_allclose(ss, goal, atol=1)  # can be off by 1 due to rounding
    except Exception:
        print('!!!!!!!!!! FAIL  %s' % np.unique(ss))
        raise


@requires_application()
def test_multiple_canvases():
    """Testing multiple canvases"""
    n_check = 3
    default_app.use()
    if default_app.backend_name.lower() == 'glut':
        raise SkipTest('glut cannot use multiple canvases')
    with Canvas(app=default_app, size=_win_size, title='same_0') as c0:
        with Canvas(app=default_app, size=_win_size, title='same_1') as c1:
            ct = [0, 0]

            @c0.events.paint.connect
            def paint0(event):
                ct[0] += 1
                c0.update()

            @c1.events.paint.connect  # noqa, analysis:ignore
            def paint1(event):
                ct[1] += 1
                c1.update()

            c0.show()  # ensure visible
            c1.show()
            c0.update()  # force first paint
            c1.update()

            timeout = time() + 2.0
            while (ct[0] < n_check or ct[1] < n_check) and time() < timeout:
                default_app.process_events()
            print((ct, n_check))
            assert_true(n_check <= ct[0] <= n_check + 1)
            assert_true(n_check <= ct[1] <= n_check + 1)

            # check timer
            global timer_ran
            timer_ran = False

            def on_timer(_):
                global timer_ran
                timer_ran = True
            timeout = time() + 2.0
            Timer(0.1, app=default_app, connect=on_timer, iterations=1,
                  start=True)
            while not timer_ran and time() < timeout:
                default_app.process_events()
            assert_true(timer_ran)

    kwargs = dict(app=default_app, autoswap=False, size=_win_size,
                  show=True)
    with Canvas(title='0', **kwargs) as c0:
        with Canvas(title='1', **kwargs) as c1:
            bgcolors = [None] * 2

            @c0.events.paint.connect
            def paint00(event):
                print('  {0:7}: {1}'.format('0', bgcolors[0]))
                if bgcolors[0] is not None:
                    gl.glViewport(0, 0, *list(_win_size))
                    gl.glClearColor(*bgcolors[0])
                    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
                    gl.glFinish()

            @c1.events.paint.connect
            def paint11(event):
                print('  {0:7}: {1}'.format('1', bgcolors[1]))
                if bgcolors[1] is not None:
                    gl.glViewport(0, 0, *list(_win_size))
                    gl.glClearColor(*bgcolors[1])
                    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
                    gl.glFinish()

            for ci, canvas in enumerate((c0, c1)):
                print('paint %s' % canvas.title)
                bgcolors[ci] = [0.5, 0.5, 0.5, 1.0]
                _update_process_check(canvas, 127)

            for ci, canvas in enumerate((c0, c1)):
                print('test')
                _update_process_check(canvas, 127, paint=False)
                bgcolors[ci] = [1., 1., 1., 1.]
                _update_process_check(canvas, 255)
                bgcolors[ci] = [0.25, 0.25, 0.25, 0.25]
                _update_process_check(canvas, 64)

########NEW FILE########
__FILENAME__ = timer
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

from __future__ import division

from ._default_app import default_app
from ..util.event import Event, EmitterGroup
from ..util.ptime import time as precision_time
from .base import BaseTimerBackend as TimerBackend  # noqa


class Timer(object):

    """Timer used to schedule events in the future or on a repeating schedule

    Parameters
    ----------
    interval : float
        Time between events.
    connect : function | None
        The function to call.
    iterations : int
        Number of iterations. Can be -1 for infinite.
    start : bool
        Whether to start the timer.
    app : instance of vispy.app.Application
        The application to attach the timer to.
    """

    def __init__(
            self,
            interval=0.0,
            connect=None,
            iterations=-1,
            start=False,
            app=None):
        self.events = EmitterGroup(source=self,
                                   start=Event,
                                   stop=Event,
                                   timeout=Event)
        #self.connect = self.events.timeout.connect
        #self.disconnect = self.events.timeout.disconnect

        # Get app instance and make sure that it has an associated backend
        self._app = default_app if app is None else app
        self._app.use()

        # Instantiate the backed with the right class
        self._backend = self._app.backend_module.TimerBackend(self)

        self._interval = interval
        self._running = False
        self._last_emit_time = None
        self.iter_count = 0
        self.max_iterations = iterations
        if connect is not None:
            self.connect(connect)
        if start:
            self.start()

    @property
    def app(self):
        """ The vispy Application instance on which this Timer is based.
        """
        return self._app

    @property
    def interval(self):
        return self._interval

    @interval.setter
    def interval(self, val):
        self._interval = val
        if self.running:
            self.stop()
            self.start()

    @property
    def running(self):
        return self._running

    def start(self, interval=None, iterations=None):
        """Start the timer.

        A timeout event will be generated every *interval* seconds.
        If *interval* is None, then self.interval will be used.

        If *iterations* is specified, the timer will stop after
        emitting that number of events. If unspecified, then
        the previous value of self.iterations will be used. If the value is
        negative, then the timer will continue running until stop() is called.
        """
        self.iter_count = 0
        if interval is not None:
            self.interval = interval
        if iterations is not None:
            self.max_iterations = iterations
        self._backend._vispy_start(self.interval)
        self._running = True
        self._last_emit_time = None
        self.events.start(type='timer_start')

    def stop(self):
        """Stop the timer."""
        self._backend._vispy_stop()
        self._running = False
        self.events.stop(type='timer_stop')

    # use timer.app.run() and .quit() instead.
    # def run_event_loop(self):
        #"""Execute the event loop for this Timer's backend.
        #"""
        # return self._backend._vispy_run()

    # def quit_event_loop(self):
        #"""Exit the event loop for this Timer's backend.
        #"""
        # return self._backend._vispy_quit()

    @property
    def native(self):
        """ The native timer on which this Timer is based.
        """
        return self._backend._vispy_get_native_timer()

    def _timeout(self, *args):
        # called when the backend timer has triggered.
        if not self.running:
            return
        if self.max_iterations >= 0 and self.iter_count >= self.max_iterations:
            self.stop()
            return

        # compute dt since last event
        now = precision_time()
        if self._last_emit_time is None:
            dt = None
        else:
            dt = now - self._last_emit_time
        self._last_emit_time = now

        self.events.timeout(
            type='timer_timeout',
            iteration=self.iter_count,
            dt=dt)
        self.iter_count += 1

    def connect(self, callback):
        """ Alias for self.events.timeout.connect() """
        return self.events.timeout.connect(callback)

    def disconnect(self, callback=None):
        """ Alias for self.events.timeout.disconnect() """
        return self.events.timeout.disconnect(callback)

########NEW FILE########
__FILENAME__ = _config
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

from copy import deepcopy

_default_dict = dict(red_size=8, green_size=8, blue_size=8, alpha_size=8,
                     depth_size=16, stencil_size=0, double_buffer=True,
                     stereo=False, samples=0)


def get_default_config():
    """Get the default OpenGL context configuration

    Returns
    -------
    config : dict
        Dictionary of config values.
    """
    return deepcopy(_default_dict)

########NEW FILE########
__FILENAME__ = _default_app
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

from .application import Application

default_app = Application()


def use(backend_name=None):
    """Select a backend by name

    Parameters
    ----------
    name : str | None
        If None (default), a suitable backend will be chosen automatically.
        Trying to select a particular backend when one is already selected
        will raise an error. Available backends:
        'PySide', 'PyQt4', 'Glut', 'Glfw', 'Pyglet', 'qt'. 'qt' will use
        PySide or PyQt4, whichever works.

    Notes
    -----
    If a backend name is provided, and that backend could not be loaded,
    an error is raised.

    If no backend name is provided, this function will first check if
    the GUI toolkit corresponding to each backend is already imported,
    and try that backend first. If this is unsuccessful, it will try
    the 'default_backend' provided in the vispy config. If still not
    succesful, it will try each backend in a predetermined order.
    """
    return default_app.use(backend_name)


def create():
    """Create the native application.
    """
    return default_app.create()


def run():
    """Enter the native GUI event loop.
    """
    return default_app.run()


def quit():
    """Quit the native GUI event loop.
    """
    return default_app.quit()


def process_events():
    """Process all pending GUI events

    If the mainloop is not running, this should be done regularly to
    keep the visualization interactive and to keep the event system going.
    """
    return default_app.process_events()

########NEW FILE########
__FILENAME__ = glfw
# -*- coding: utf-8 -*-

# -----------------------------------------------------------------------------
#  GLFW - An OpenGL framework
#  API version: 3.0.1
#  WWW:         http://www.glfw.org/
#  ----------------------------------------------------------------------------
#  Copyright (c) 2002-2006 Marcus Geelnard
#  Copyright (c) 2006-2010 Camilla Berglund
#
#  Python bindings - Copyright (c) 2013 Nicolas P. Rougier
#
#  This software is provided 'as-is', without any express or implied
#  warranty. In no event will the authors be held liable for any damages
#  arising from the use of this software.
#
#  Permission is granted to anyone to use this software for any purpose,
#  including commercial applications, and to alter it and redistribute it
#  freely, subject to the following restrictions:
#
#  1. The origin of this software must not be misrepresented; you must not
#     claim that you wrote the original software. If you use this software
#     in a product, an acknowledgment in the product documentation would
#     be appreciated but is not required.
#
#  2. Altered source versions must be plainly marked as such, and must not
#     be misrepresented as being the original software.
#
#  3. This notice may not be removed or altered from any source
#     distribution.
#
# -----------------------------------------------------------------------------

# NOTE:
# This source has been modified from its original form by the vispy dev team

import os
import ctypes.util
from ctypes import (Structure, POINTER, CFUNCTYPE, byref, c_char_p, c_int,
                    c_uint, c_double, c_float, c_ushort)


_glfw_file = None

# First if there is an environment variable pointing to the library
if 'GLFW_LIBRARY' in os.environ:
    if os.path.exists(os.environ['GLFW_LIBRARY']):
        _glfw_file = os.path.realpath(os.environ['GLFW_LIBRARY'])

# Else, try to find it
if _glfw_file is None:
    order = ['glfw3', 'glfw']
    for check in order:
        _glfw_file = ctypes.util.find_library(check)
        if _glfw_file is not None:
            break

# Else, we failed and exit
if _glfw_file is None:
    raise OSError('GLFW library not found')

# Load it
_glfw = ctypes.CDLL(_glfw_file)


# Ensure it's new enough
def glfwGetVersion():
    major, minor, rev = c_int(0), c_int(0), c_int(0)
    _glfw.glfwGetVersion(byref(major), byref(minor), byref(rev))
    return major.value, minor.value, rev.value

version = glfwGetVersion()

if version[0] != 3:
    version = '.'.join([str(v) for v in version])
    raise OSError('Need GLFW v3, found %s' % version)


# --- Version -----------------------------------------------------------------
GLFW_VERSION_MAJOR      = version[0]
GLFW_VERSION_MINOR      = version[1]
GLFW_VERSION_REVISION   = version[2]
__version__ = GLFW_VERSION_MAJOR, GLFW_VERSION_MINOR, GLFW_VERSION_REVISION

# --- Input handling definitions ----------------------------------------------
GLFW_RELEASE            = 0
GLFW_PRESS              = 1
GLFW_REPEAT             = 2

# --- Keys --------------------------------------------------------------------

# --- The unknown key ---------------------------------------------------------
GLFW_KEY_UNKNOWN          = -1

# --- Printable keys ----------------------------------------------------------
GLFW_KEY_SPACE            = 32
GLFW_KEY_APOSTROPHE       = 39 # ''
GLFW_KEY_COMMA            = 44 # ,
GLFW_KEY_MINUS            = 45 # -
GLFW_KEY_PERIOD           = 46 # .
GLFW_KEY_SLASH            = 47 # /
GLFW_KEY_0                = 48
GLFW_KEY_1                = 49
GLFW_KEY_2                = 50
GLFW_KEY_3                = 51
GLFW_KEY_4                = 52
GLFW_KEY_5                = 53
GLFW_KEY_6                = 54
GLFW_KEY_7                = 55
GLFW_KEY_8                = 56
GLFW_KEY_9                = 57
GLFW_KEY_SEMICOLON        = 59 # ;
GLFW_KEY_EQUAL            = 61 # =
GLFW_KEY_A                = 65
GLFW_KEY_B                = 66
GLFW_KEY_C                = 67
GLFW_KEY_D                = 68
GLFW_KEY_E                = 69
GLFW_KEY_F                = 70
GLFW_KEY_G                = 71
GLFW_KEY_H                = 72
GLFW_KEY_I                = 73
GLFW_KEY_J                = 74
GLFW_KEY_K                = 75
GLFW_KEY_L                = 76
GLFW_KEY_M                = 77
GLFW_KEY_N                = 78
GLFW_KEY_O                = 79
GLFW_KEY_P                = 80
GLFW_KEY_Q                = 81
GLFW_KEY_R                = 82
GLFW_KEY_S                = 83
GLFW_KEY_T                = 84
GLFW_KEY_U                = 85
GLFW_KEY_V                = 86
GLFW_KEY_W                = 87
GLFW_KEY_X                = 88
GLFW_KEY_Y                = 89
GLFW_KEY_Z                = 90
GLFW_KEY_LEFT_BRACKET     = 91  # [
GLFW_KEY_BACKSLASH        = 92  # \
GLFW_KEY_RIGHT_BRACKET    = 93  # ]
GLFW_KEY_GRAVE_ACCENT     = 96  # `
GLFW_KEY_WORLD_1          = 161 # non-US #1
GLFW_KEY_WORLD_2          = 162 # non-US #2

# --- Function keys -----------------------------------------------------------
GLFW_KEY_ESCAPE           = 256
GLFW_KEY_ENTER            = 257
GLFW_KEY_TAB              = 258
GLFW_KEY_BACKSPACE        = 259
GLFW_KEY_INSERT           = 260
GLFW_KEY_DELETE           = 261
GLFW_KEY_RIGHT            = 262
GLFW_KEY_LEFT             = 263
GLFW_KEY_DOWN             = 264
GLFW_KEY_UP               = 265
GLFW_KEY_PAGE_UP          = 266
GLFW_KEY_PAGE_DOWN        = 267
GLFW_KEY_HOME             = 268
GLFW_KEY_END              = 269
GLFW_KEY_CAPS_LOCK        = 280
GLFW_KEY_SCROLL_LOCK      = 281
GLFW_KEY_NUM_LOCK         = 282
GLFW_KEY_PRINT_SCREEN     = 283
GLFW_KEY_PAUSE            = 284
GLFW_KEY_F1               = 290
GLFW_KEY_F2               = 291
GLFW_KEY_F3               = 292
GLFW_KEY_F4               = 293
GLFW_KEY_F5               = 294
GLFW_KEY_F6               = 295
GLFW_KEY_F7               = 296
GLFW_KEY_F8               = 297
GLFW_KEY_F9               = 298
GLFW_KEY_F10              = 299
GLFW_KEY_F11              = 300
GLFW_KEY_F12              = 301
GLFW_KEY_F13              = 302
GLFW_KEY_F14              = 303
GLFW_KEY_F15              = 304
GLFW_KEY_F16              = 305
GLFW_KEY_F17              = 306
GLFW_KEY_F18              = 307
GLFW_KEY_F19              = 308
GLFW_KEY_F20              = 309
GLFW_KEY_F21              = 310
GLFW_KEY_F22              = 311
GLFW_KEY_F23              = 312
GLFW_KEY_F24              = 313
GLFW_KEY_F25              = 314
GLFW_KEY_KP_0             = 320
GLFW_KEY_KP_1             = 321
GLFW_KEY_KP_2             = 322
GLFW_KEY_KP_3             = 323
GLFW_KEY_KP_4             = 324
GLFW_KEY_KP_5             = 325
GLFW_KEY_KP_6             = 326
GLFW_KEY_KP_7             = 327
GLFW_KEY_KP_8             = 328
GLFW_KEY_KP_9             = 329
GLFW_KEY_KP_DECIMAL       = 330
GLFW_KEY_KP_DIVIDE        = 331
GLFW_KEY_KP_MULTIPLY      = 332
GLFW_KEY_KP_SUBTRACT      = 333
GLFW_KEY_KP_ADD           = 334
GLFW_KEY_KP_ENTER         = 335
GLFW_KEY_KP_EQUAL         = 336
GLFW_KEY_LEFT_SHIFT       = 340
GLFW_KEY_LEFT_CONTROL     = 341
GLFW_KEY_LEFT_ALT         = 342
GLFW_KEY_LEFT_SUPER       = 343
GLFW_KEY_RIGHT_SHIFT      = 344
GLFW_KEY_RIGHT_CONTROL    = 345
GLFW_KEY_RIGHT_ALT        = 346
GLFW_KEY_RIGHT_SUPER      = 347
GLFW_KEY_MENU             = 348
GLFW_KEY_LAST             = GLFW_KEY_MENU


# --- Modifiers ---------------------------------------------------------------
GLFW_MOD_SHIFT            = 0x0001
GLFW_MOD_CONTROL          = 0x0002
GLFW_MOD_ALT              = 0x0004
GLFW_MOD_SUPER            = 0x0008

# --- Mouse -------------------------------------------------------------------
GLFW_MOUSE_BUTTON_1       = 0
GLFW_MOUSE_BUTTON_2       = 1
GLFW_MOUSE_BUTTON_3       = 2
GLFW_MOUSE_BUTTON_4       = 3
GLFW_MOUSE_BUTTON_5       = 4
GLFW_MOUSE_BUTTON_6       = 5
GLFW_MOUSE_BUTTON_7       = 6
GLFW_MOUSE_BUTTON_8       = 7
GLFW_MOUSE_BUTTON_LAST    = GLFW_MOUSE_BUTTON_8
GLFW_MOUSE_BUTTON_LEFT    = GLFW_MOUSE_BUTTON_1
GLFW_MOUSE_BUTTON_RIGHT   = GLFW_MOUSE_BUTTON_2
GLFW_MOUSE_BUTTON_MIDDLE  = GLFW_MOUSE_BUTTON_3


# --- Joystick ----------------------------------------------------------------
GLFW_JOYSTICK_1           = 0
GLFW_JOYSTICK_2           = 1
GLFW_JOYSTICK_3           = 2
GLFW_JOYSTICK_4           = 3
GLFW_JOYSTICK_5           = 4
GLFW_JOYSTICK_6           = 5
GLFW_JOYSTICK_7           = 6
GLFW_JOYSTICK_8           = 7
GLFW_JOYSTICK_9           = 8
GLFW_JOYSTICK_10          = 9
GLFW_JOYSTICK_11          = 10
GLFW_JOYSTICK_12          = 11
GLFW_JOYSTICK_13          = 12
GLFW_JOYSTICK_14          = 13
GLFW_JOYSTICK_15          = 14
GLFW_JOYSTICK_16          = 15
GLFW_JOYSTICK_LAST        = GLFW_JOYSTICK_16


# --- Error codes -------------------------------------------------------------
GLFW_NOT_INITIALIZED        = 0x00010001
GLFW_NO_CURRENT_CONTEXT     = 0x00010002
GLFW_INVALID_ENUM           = 0x00010003
GLFW_INVALID_VALUE          = 0x00010004
GLFW_OUT_OF_MEMORY          = 0x00010005
GLFW_API_UNAVAILABLE        = 0x00010006
GLFW_VERSION_UNAVAILABLE    = 0x00010007
GLFW_PLATFORM_ERROR         = 0x00010008
GLFW_FORMAT_UNAVAILABLE     = 0x00010009

# ---
GLFW_FOCUSED                = 0x00020001
GLFW_ICONIFIED              = 0x00020002
GLFW_RESIZABLE              = 0x00020003
GLFW_VISIBLE                = 0x00020004
GLFW_DECORATED              = 0x00020005

# ---
GLFW_RED_BITS               = 0x00021001
GLFW_GREEN_BITS             = 0x00021002
GLFW_BLUE_BITS              = 0x00021003
GLFW_ALPHA_BITS             = 0x00021004
GLFW_DEPTH_BITS             = 0x00021005
GLFW_STENCIL_BITS           = 0x00021006
GLFW_ACCUM_RED_BITS         = 0x00021007
GLFW_ACCUM_GREEN_BITS       = 0x00021008
GLFW_ACCUM_BLUE_BITS        = 0x00021009
GLFW_ACCUM_ALPHA_BITS       = 0x0002100A
GLFW_AUX_BUFFERS            = 0x0002100B
GLFW_STEREO                 = 0x0002100C
GLFW_SAMPLES                = 0x0002100D
GLFW_SRGB_CAPABLE           = 0x0002100E
GLFW_REFRESH_RATE           = 0x0002100F

# ---
GLFW_CLIENT_API             = 0x00022001
GLFW_CONTEXT_VERSION_MAJOR  = 0x00022002
GLFW_CONTEXT_VERSION_MINOR  = 0x00022003
GLFW_CONTEXT_REVISION       = 0x00022004
GLFW_CONTEXT_ROBUSTNESS     = 0x00022005
GLFW_OPENGL_FORWARD_COMPAT  = 0x00022006
GLFW_OPENGL_DEBUG_CONTEXT   = 0x00022007
GLFW_OPENGL_PROFILE         = 0x00022008

# ---
GLFW_OPENGL_API             = 0x00030001
GLFW_OPENGL_ES_API          = 0x00030002

# ---
GLFW_NO_ROBUSTNESS          =          0
GLFW_NO_RESET_NOTIFICATION  = 0x00031001
GLFW_LOSE_CONTEXT_ON_RESET  = 0x00031002

# ---
GLFW_OPENGL_ANY_PROFILE     =          0
GLFW_OPENGL_CORE_PROFILE    = 0x00032001
GLFW_OPENGL_COMPAT_PROFILE  = 0x00032002

# ---
GLFW_CURSOR                 = 0x00033001
GLFW_STICKY_KEYS            = 0x00033002
GLFW_STICKY_MOUSE_BUTTONS   = 0x00033003

# ---
GLFW_CURSOR_NORMAL          = 0x00034001
GLFW_CURSOR_HIDDEN          = 0x00034002
GLFW_CURSOR_DISABLED        = 0x00034003

# ---
GLFW_CONNECTED              = 0x00040001
GLFW_DISCONNECTED           = 0x00040002


# --- Structures --------------------------------------------------------------
class GLFWvidmode(Structure):
    _fields_ = [ ('width',       c_int),
                 ('height',      c_int),
                 ('redBits',     c_int),
                 ('greenBits',   c_int),
                 ('blueBits',    c_int),
                 ('refreshRate', c_int) ]

class GLFWgammaramp(Structure):
    _fields_ = [ ('red',     POINTER(c_ushort)),
                 ('green',   POINTER(c_ushort)),
                 ('blue',    POINTER(c_ushort)),
                 ('size',    c_int) ]

class GLFWwindow(Structure): pass
class GLFWmonitor(Structure): pass

# --- Callbacks ---------------------------------------------------------------
errorfun           = CFUNCTYPE(None, c_int, c_char_p)
windowposfun       = CFUNCTYPE(None, POINTER(GLFWwindow), c_int, c_int)
windowsizefun      = CFUNCTYPE(None, POINTER(GLFWwindow), c_int, c_int)
windowclosefun     = CFUNCTYPE(None, POINTER(GLFWwindow))
windowrefreshfun   = CFUNCTYPE(None, POINTER(GLFWwindow))
windowfocusfun     = CFUNCTYPE(None, POINTER(GLFWwindow), c_int)
windowiconifyfun   = CFUNCTYPE(None, POINTER(GLFWwindow), c_int)
framebuffersizefun = CFUNCTYPE(None, POINTER(GLFWwindow), c_int, c_int)
mousebuttonfun     = CFUNCTYPE(None, POINTER(GLFWwindow), c_int, c_int, c_int)
cursorposfun       = CFUNCTYPE(None, POINTER(GLFWwindow), c_double, c_double)
cursorenterfun     = CFUNCTYPE(None, POINTER(GLFWwindow), c_int)
scrollfun          = CFUNCTYPE(None, POINTER(GLFWwindow), c_double, c_double)
keyfun             = CFUNCTYPE(None, POINTER(GLFWwindow), c_int, c_int, c_int, c_int)
charfun            = CFUNCTYPE(None, POINTER(GLFWwindow), c_uint)
monitorfun         = CFUNCTYPE(None, POINTER(GLFWmonitor), c_int)

# --- Init --------------------------------------------------------------------
glfwInit                        = _glfw.glfwInit
glfwTerminate                   = _glfw.glfwTerminate
#glfwGetVersion                 = _glfw.glfwGetVersion

# --- Error -------------------------------------------------------------------
#glfwSetErrorCallback            = _glfw.glfwSetErrorCallback

# --- Monitor -----------------------------------------------------------------
# glfwGetMonitors                 = _glfw.glfwGetMonitors
# glfwGetMonitors.restype         = POINTER(GLFWmonitor)
glfwGetPrimaryMonitor           = _glfw.glfwGetPrimaryMonitor
# glfwGetMonitorPos               = _glfw.glfwGetMonitorPos
# glfwGetMonitorPhysicalSize      = _glfw.glfwGetMonitorPhysicalSize
glfwGetMonitorName              = _glfw.glfwGetMonitorName
glfwGetMonitorName.restype = c_char_p
# glfwSetMonitorCallback          = _glfw.glfwSetMonitorCallback
# glfwGetVideoModes               = _glfw.glfwGetVideoModes
# glfwGetVideoMode                = _glfw.glfwGetVideoMode

# --- Gama --------------------------------------------------------------------
glfwSetGamma                   = _glfw.glfwSetGamma
# glfwGetGammaRamp               = _glfw.glfwGetGammaRamp
# glfwSetGammaRamp               = _glfw.glfwSetGammaRamp

# --- Window ------------------------------------------------------------------
glfwDefaultWindowHints         = _glfw.glfwDefaultWindowHints
glfwWindowHint                 = _glfw.glfwWindowHint
# glfwCreateWindow              = _glfw.glfwCreateWindow
# glfwDestroyWindow              = _glfw.glfwDestroyWindow
glfwWindowShouldClose          = _glfw.glfwWindowShouldClose
glfwSetWindowShouldClose       = _glfw.glfwSetWindowShouldClose
glfwSetWindowTitle             = _glfw.glfwSetWindowTitle
# glfwGetWindowPos              = _glfw.glfwGetWindowPos
glfwSetWindowPos               = _glfw.glfwSetWindowPos
# glfwGetWindowSize             = _glfw.glfwGetWindowSize
glfwSetWindowSize              = _glfw.glfwSetWindowSize
# glfwGetFramebufferSize        = _glfw.glfwGetFramebufferSize
glfwIconifyWindow              = _glfw.glfwIconifyWindow
glfwRestoreWindow              = _glfw.glfwRestoreWindow
glfwShowWindow                 = _glfw.glfwShowWindow
glfwHideWindow                 = _glfw.glfwHideWindow
glfwGetWindowMonitor           = _glfw.glfwGetWindowMonitor
glfwGetWindowAttrib            = _glfw.glfwGetWindowAttrib
glfwSetWindowUserPointer       = _glfw.glfwSetWindowUserPointer
glfwGetWindowUserPointer       = _glfw.glfwGetWindowUserPointer
# glfwSetWindowPosCallback       = _glfw.glfwSetWindowPosCallback
# glfwSetWindowSizeCallback      = _glfw.glfwSetWindowSizeCallback
# glfwSetWindowCloseCallback     = _glfw.glfwSetWindowCloseCallback
# glfwSetWindowRefreshCallback   = _glfw.glfwSetWindowRefreshCallback
# glfwSetWindowFocusCallback     = _glfw.glfwSetWindowFocusCallback
# glfwSetWindowIconifyCallback   = _glfw.glfwSetWindowIconifyCallback
# glfwSetFramebufferSizeCallback = _glfw.glfwSetFramebufferSizeCallback
glfwPollEvents                 = _glfw.glfwPollEvents
glfwWaitEvents                 = _glfw.glfwWaitEvents

# --- Input -------------------------------------------------------------------
glfwGetInputMode               = _glfw.glfwGetInputMode
glfwSetInputMode               = _glfw.glfwSetInputMode
glfwGetKey                     = _glfw.glfwGetKey
glfwGetMouseButton             = _glfw.glfwGetMouseButton
# glfwGetCursorPos               = _glfw.glfwGetCursorPos
glfwSetCursorPos               = _glfw.glfwSetCursorPos
# glfwSetKeyCallback             = _glfw.glfwSetKeyCallback
# glfwSetCharCallback            = _glfw.glfwSetCharCallback
# glfwSetMouseButtonCallback     = _glfw.glfwSetMouseButtonCallback
# glfwSetCursorPosCallback       = _glfw.glfwSetCursorPosCallback
# glfwSetCursorEnterCallback     = _glfw.glfwSetCursorEnterCallback
# glfwSetScrollCallback          = _glfw.glfwSetScrollCallback
glfwJoystickPresent            = _glfw.glfwJoystickPresent
# glfwGetJoystickAxes            = _glfw.glfwGetJoystickAxes
# glfwGetJoystickButtons         = _glfw.glfwGetJoystickButtons
glfwGetJoystickName            = _glfw.glfwGetJoystickName
glfwGetJoystickName.restype = c_char_p

# --- Clipboard ---------------------------------------------------------------
glfwSetClipboardString         = _glfw.glfwSetClipboardString
glfwGetClipboardString         = _glfw.glfwGetClipboardString
glfwGetClipboardString.restype = c_char_p

# --- Timer -------------------------------------------------------------------
glfwGetTime                    = _glfw.glfwGetTime
glfwGetTime.restype = c_double
glfwSetTime                    = _glfw.glfwSetTime

# --- Context -----------------------------------------------------------------
glfwMakeContextCurrent         = _glfw.glfwMakeContextCurrent
glfwGetCurrentContext          = _glfw.glfwGetCurrentContext
glfwSwapBuffers                = _glfw.glfwSwapBuffers
glfwSwapInterval               = _glfw.glfwSwapInterval
glfwExtensionSupported         = _glfw.glfwExtensionSupported
glfwGetProcAddress             = _glfw.glfwGetProcAddress


# --- Pythonizer --------------------------------------------------------------

# This keeps track of current windows
__windows__ = []
__destroyed__ = []

# This is to prevent garbage collection on callbacks
__c_callbacks__ = {}
__py_callbacks__ = {}


def glfwCreateWindow(width=640, height=480, title="GLFW Window",
                     monitor=None, share=None):
    _glfw.glfwCreateWindow.restype = POINTER(GLFWwindow)
    window = _glfw.glfwCreateWindow(int(width), int(height),
                                    title.encode('ASCII'), monitor, share)
    assert window not in __windows__
    __windows__.append(window)
    __destroyed__.append(False)
    index = __windows__.index(window)
    __c_callbacks__[index] = {}
    __py_callbacks__[index] = { 'errorfun'           : None,
                                'monitorfun'         : None,
                                'windowposfun'       : None,
                                'windowsizefun'      : None,
                                'windowclosefun'     : None,
                                'windowrefreshfun'   : None,
                                'windowfocusfun'     : None,
                                'windowiconifyfun'   : None,
                                'framebuffersizefun' : None,
                                'keyfun'             : None,
                                'charfun'            : None,
                                'mousebuttonfun'     : None,
                                'cursorposfun'       : None,
                                'cursorenterfun'     : None,
                                'scrollfun'          : None }
    return window


def glfwDestroyWindow(window):
    index = __windows__.index(window)
    if not __destroyed__[index]:
        __destroyed__[index] = True
        # We do not delete window from the list (or it would impact numbering)
        __windows__[index] = None
        _glfw.glfwDestroyWindow(window)
        del __c_callbacks__[index]
        del __py_callbacks__[index]


def glfwGetWindowPos(window):
    xpos, ypos = c_int(0), c_int(0)
    _glfw.glfwGetWindowPos(window, byref(xpos), byref(ypos))
    return xpos.value, ypos.value


def glfwGetCursorPos(window):
    xpos, ypos = c_double(0), c_double(0)
    _glfw.glfwGetCursorPos(window, byref(xpos), byref(ypos))
    return int(xpos.value), int(ypos.value)


def glfwGetWindowSize(window):
    width, height = c_int(0), c_int(0)
    _glfw.glfwGetWindowSize(window, byref(width), byref(height))
    return width.value, height.value


def glfwGetFramebufferSize(window):
    width, height = c_int(0), c_int(0)
    _glfw.glfwGetFramebufferSize(window, byref(width), byref(height))
    return width.value, height.value


def glfwGetMonitors():
    count = c_int(0)
    _glfw.glfwGetMonitors.restype = POINTER(POINTER(GLFWmonitor))
    c_monitors = _glfw.glfwGetMonitors( byref(count) )
    return [c_monitors[i] for i in range(count.value)]


def glfwGetVideoModes(monitor):
    count = c_int(0)
    _glfw.glfwGetVideoModes.restype = POINTER(GLFWvidmode)
    c_modes = _glfw.glfwGetVideoModes( monitor, byref(count) )
    modes = []
    for i in range(count.value):
        modes.append( (c_modes[i].width,
                       c_modes[i].height,
                       c_modes[i].redBits,
                       c_modes[i].blueBits,
                       c_modes[i].greenBits,
                       c_modes[i].refreshRate ) )
    return modes


def glfwGetMonitorPos(monitor):
    xpos, ypos = c_int(0), c_int(0)
    _glfw.glfwGetMonitorPos(monitor, byref(xpos), byref(ypos))
    return xpos.value, ypos.value


def glfwGetMonitorPhysicalSize(monitor):
    width, height = c_int(0), c_int(0)
    _glfw.glfwGetMonitorPhysicalSize(monitor, byref(width), byref(height))
    return width.value, height.value


def glfwGetVideoMode(monitor):
    _glfw.glfwGetVideoMode.restype = POINTER(GLFWvidmode)
    c_modes = _glfw.glfwGetVideoModes(monitor)
    return (c_modes.width,
            c_modes.height,
            c_modes.redBits,
            c_modes.blueBits,
            c_modes.greenBits,
            c_modes.refreshRate )


def GetGammaRamp(monitor):
    _glfw.glfwGetGammaRamp.restype = POINTER(GLFWgammaramp)
    c_gamma = _glfw.glfwGetGammaRamp(monitor).contents
    gamma = {'red':[], 'green':[], 'blue':[]}
    if c_gamma:
        for i in range(c_gamma.size):
            gamma['red'].append(c_gamma.red[i])
            gamma['green'].append(c_gamma.green[i])
            gamma['blue'].append(c_gamma.blue[i])
    return gamma


def glfwGetJoystickAxes(joy):
    count = c_int(0)
    _glfw.glfwGetJoystickAxes.restype = POINTER(c_float)
    c_axes = _glfw.glfwGetJoystickAxes(joy, byref(count))
    axes = [c_axes[i].value for i in range(count)]
    return axes


def glfwGetJoystickButtons(joy):
    count = c_int(0)
    _glfw.glfwGetJoystickButtons.restype = POINTER(c_int)
    c_buttons = _glfw.glfwGetJoystickButtons(joy, byref(count))
    buttons = [c_buttons[i].value for i in range(count)]
    return buttons


# --- Callbacks ---------------------------------------------------------------

def __callback__(name):
    callback = 'glfwSet%sCallback' % name
    fun      = '%sfun' % name.lower()
    code = """
def %(callback)s(window, callback = None):
    index = __windows__.index(window)
    old_callback = __py_callbacks__[index]['%(fun)s']
    __py_callbacks__[index]['%(fun)s'] = callback
    if callback: callback = %(fun)s(callback)
    __c_callbacks__[index]['%(fun)s'] = callback
    _glfw.%(callback)s(window, callback)
    return old_callback""" % {'callback': callback, 'fun': fun}
    return code

exec(__callback__('Error'))
exec(__callback__('Monitor'))
exec(__callback__('WindowPos'))
exec(__callback__('WindowSize'))
exec(__callback__('WindowClose'))
exec(__callback__('WindowRefresh'))
exec(__callback__('WindowFocus'))
exec(__callback__('WindowIconify'))
exec(__callback__('FramebufferSize'))
exec(__callback__('Key'))
exec(__callback__('Char'))
exec(__callback__('MouseButton'))
exec(__callback__('CursorPos'))
exec(__callback__('Scroll'))

########NEW FILE########
__FILENAME__ = py24_ordereddict
# Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
# Passes Python2.7's test suite and incorporates all the latest updates.

# MIT-licensed from:
# http://code.activestate.com/recipes/576693/
# http://docs.python.org/2/library/collections.html#ordereddict-objects

try:
    from thread import get_ident as _get_ident
except ImportError:
    from dummy_thread import get_ident as _get_ident

try:
    from _abcoll import KeysView, ValuesView, ItemsView
except ImportError:
    pass


class OrderedDict(dict):

    'Dictionary that remembers insertion order'
    # An inherited dict maps keys to values.
    # The inherited dict provides __getitem__, __len__, __contains__, and get.
    # The remaining methods are order-aware.
    # Big-O running times for all methods are the same as for regular
    # dictionaries.

    # The internal self.__map dictionary maps keys to links in a doubly linked list.
    # The circular doubly linked list starts and ends with a sentinel element.
    # The sentinel element never gets deleted (this simplifies the algorithm).
    # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

    def __init__(self, *args, **kwds):
        '''Initialize an ordered dictionary.  Signature is the same as for
        regular dictionaries, but keyword arguments are not recommended
        because their insertion order is arbitrary.

        '''
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        try:
            self.__root
        except AttributeError:
            self.__root = root = []                     # sentinel node
            root[:] = [root, root, None]
            self.__map = {}
        self.__update(*args, **kwds)

    def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
        'od.__setitem__(i, y) <==> od[i]=y'
        # Setting a new item creates a new link which goes at the end of the linked
        # list, and the inherited dictionary is updated with the new key/value
        # pair.
        if key not in self:
            root = self.__root
            last = root[0]
            last[1] = root[0] = self.__map[key] = [last, root, key]
        dict_setitem(self, key, value)

    def __delitem__(self, key, dict_delitem=dict.__delitem__):
        'od.__delitem__(y) <==> del od[y]'
        # Deleting an existing item uses self.__map to find the link which is
        # then removed by updating the links in the predecessor and successor
        # nodes.
        dict_delitem(self, key)
        link_prev, link_next, key = self.__map.pop(key)
        link_prev[1] = link_next
        link_next[0] = link_prev

    def __iter__(self):
        'od.__iter__() <==> iter(od)'
        root = self.__root
        curr = root[1]
        while curr is not root:
            yield curr[2]
            curr = curr[1]

    def __reversed__(self):
        'od.__reversed__() <==> reversed(od)'
        root = self.__root
        curr = root[0]
        while curr is not root:
            yield curr[2]
            curr = curr[0]

    def clear(self):
        'od.clear() -> None.  Remove all items from od.'
        try:
            for node in self.__map.itervalues():
                del node[:]
            root = self.__root
            root[:] = [root, root, None]
            self.__map.clear()
        except AttributeError:
            pass
        dict.clear(self)

    def popitem(self, last=True):
        '''od.popitem() -> (k, v), return and remove a (key, value) pair.
        Pairs are returned in LIFO order if last is true or FIFO order if false.

        '''
        if not self:
            raise KeyError('dictionary is empty')
        root = self.__root
        if last:
            link = root[0]
            link_prev = link[0]
            link_prev[1] = root
            root[0] = link_prev
        else:
            link = root[1]
            link_next = link[1]
            root[1] = link_next
            link_next[0] = root
        key = link[2]
        del self.__map[key]
        value = dict.pop(self, key)
        return key, value

    # -- the following methods do not depend on the internal structure --

    def keys(self):
        'od.keys() -> list of keys in od'
        return list(self)

    def values(self):
        'od.values() -> list of values in od'
        return [self[key] for key in self]

    def items(self):
        'od.items() -> list of (key, value) pairs in od'
        return [(key, self[key]) for key in self]

    def iterkeys(self):
        'od.iterkeys() -> an iterator over the keys in od'
        return iter(self)

    def itervalues(self):
        'od.itervalues -> an iterator over the values in od'
        for k in self:
            yield self[k]

    def iteritems(self):
        'od.iteritems -> an iterator over the (key, value) items in od'
        for k in self:
            yield (k, self[k])

    def update(*args, **kwds):
        '''od.update(E, **F) -> None.  Update od from dict/iterable E and F.

        If E is a dict instance, does:           for k in E: od[k] = E[k]
        If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
        Or if E is an iterable of items, does:   for k, v in E: od[k] = v
        In either case, this is followed by:     for k, v in F.items(): od[k] = v

        '''
        if len(args) > 2:
            raise TypeError('update() takes at most 2 positional '
                            'arguments (%d given)' % (len(args),))
        elif not args:
            raise TypeError('update() takes at least 1 argument (0 given)')
        self = args[0]
        # Make progressively weaker assumptions about "other"
        other = ()
        if len(args) == 2:
            other = args[1]
        if isinstance(other, dict):
            for key in other:
                self[key] = other[key]
        elif hasattr(other, 'keys'):
            for key in other.keys():
                self[key] = other[key]
        else:
            for key, value in other:
                self[key] = value
        for key, value in kwds.items():
            self[key] = value

    # let subclasses override update without breaking __init__
    __update = update

    __marker = object()

    def pop(self, key, default=__marker):
        '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.
        If key is not found, d is returned if given, otherwise KeyError is raised.

        '''
        if key in self:
            result = self[key]
            del self[key]
            return result
        if default is self.__marker:
            raise KeyError(key)
        return default

    def setdefault(self, key, default=None):
        'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
        if key in self:
            return self[key]
        self[key] = default
        return default

    def __repr__(self, _repr_running={}):
        'od.__repr__() <==> repr(od)'
        call_key = id(self), _get_ident()
        if call_key in _repr_running:
            return '...'
        _repr_running[call_key] = 1
        try:
            if not self:
                return '%s()' % (self.__class__.__name__,)
            return '%s(%r)' % (self.__class__.__name__, self.items())
        finally:
            del _repr_running[call_key]

    def __reduce__(self):
        'Return state information for pickling'
        items = [[k, self[k]] for k in self]
        inst_dict = vars(self).copy()
        for k in vars(OrderedDict()):
            inst_dict.pop(k, None)
        if inst_dict:
            return (self.__class__, (items,), inst_dict)
        return self.__class__, (items,)

    def copy(self):
        'od.copy() -> a shallow copy of od'
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
        and values equal to v (which defaults to None).

        '''
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    def __eq__(self, other):
        '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
        while comparison to a regular mapping is order-insensitive.

        '''
        if isinstance(other, OrderedDict):
            return len(self) == len(other) and self.items() == other.items()
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self == other

    # -- the following methods are only used in Python 2.7 --

    def viewkeys(self):
        "od.viewkeys() -> a set-like object providing a view on od's keys"
        return KeysView(self)

    def viewvalues(self):
        "od.viewvalues() -> an object providing a view on od's values"
        return ValuesView(self)

    def viewitems(self):
        "od.viewitems() -> a set-like object providing a view on od's items"
        return ItemsView(self)

########NEW FILE########
__FILENAME__ = six
"""Utilities for writing code that runs on Python 2 and 3"""

# Copyright (c) 2010-2013 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.4.1"


# Useful for very coarse version differentiation.
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"):
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31) - 1)
    else:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
        class X(object):
            def __len__(self):
                return 1 << 31
        try:
            len(X())
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31) - 1)
        else:
            # 64-bit
            MAXSIZE = int((1 << 63) - 1)
        del X


def _add_doc(func, doc):
    """Add documentation to a function."""
    func.__doc__ = doc


def _import_module(name):
    """Import module, returning the module after the last dot."""
    __import__(name)
    return sys.modules[name]


class _LazyDescr(object):

    def __init__(self, name):
        self.name = name

    def __get__(self, obj, tp):
        result = self._resolve()
        setattr(obj, self.name, result)
        # This is a bit ugly, but it avoids running this again.
        delattr(tp, self.name)
        return result


class MovedModule(_LazyDescr):

    def __init__(self, name, old, new=None):
        super(MovedModule, self).__init__(name)
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self):
        return _import_module(self.mod)


class MovedAttribute(_LazyDescr):

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        super(MovedAttribute, self).__init__(name)
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self):
        module = _import_module(self.mod)
        return getattr(module, self.attr)



class _MovedItems(types.ModuleType):
    """Lazy loading of moved objects"""


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
    MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
    MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("reload_module", "__builtin__", "imp", "reload"),
    MovedAttribute("reduce", "__builtin__", "functools"),
    MovedAttribute("StringIO", "StringIO", "io"),
    MovedAttribute("UserString", "UserString", "collections"),
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
    MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),

    MovedModule("builtins", "__builtin__"),
    MovedModule("configparser", "ConfigParser"),
    MovedModule("copyreg", "copy_reg"),
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
    MovedModule("http_cookies", "Cookie", "http.cookies"),
    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
    MovedModule("html_parser", "HTMLParser", "html.parser"),
    MovedModule("http_client", "httplib", "http.client"),
    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
    MovedModule("cPickle", "cPickle", "pickle"),
    MovedModule("queue", "Queue"),
    MovedModule("reprlib", "repr"),
    MovedModule("socketserver", "SocketServer"),
    MovedModule("tkinter", "Tkinter"),
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"),
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"),
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"),
    MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
    MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
    MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
    MovedModule("winreg", "_winreg"),
]
for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr)
del attr

moves = sys.modules[__name__ + ".moves"] = _MovedItems(__name__ + ".moves")



class Module_six_moves_urllib_parse(types.ModuleType):
    """Lazy loading of moved objects in six.moves.urllib_parse"""


_urllib_parse_moved_attributes = [
    MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
    MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
    MovedAttribute("urljoin", "urlparse", "urllib.parse"),
    MovedAttribute("urlparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
    MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
    MovedAttribute("quote", "urllib", "urllib.parse"),
    MovedAttribute("quote_plus", "urllib", "urllib.parse"),
    MovedAttribute("unquote", "urllib", "urllib.parse"),
    MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
    MovedAttribute("urlencode", "urllib", "urllib.parse"),
]
for attr in _urllib_parse_moved_attributes:
    setattr(Module_six_moves_urllib_parse, attr.name, attr)
del attr

sys.modules[__name__ + ".moves.urllib_parse"] = Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse")
sys.modules[__name__ + ".moves.urllib.parse"] = Module_six_moves_urllib_parse(__name__ + ".moves.urllib.parse")


class Module_six_moves_urllib_error(types.ModuleType):
    """Lazy loading of moved objects in six.moves.urllib_error"""


_urllib_error_moved_attributes = [
    MovedAttribute("URLError", "urllib2", "urllib.error"),
    MovedAttribute("HTTPError", "urllib2", "urllib.error"),
    MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
]
for attr in _urllib_error_moved_attributes:
    setattr(Module_six_moves_urllib_error, attr.name, attr)
del attr

sys.modules[__name__ + ".moves.urllib_error"] = Module_six_moves_urllib_error(__name__ + ".moves.urllib_error")
sys.modules[__name__ + ".moves.urllib.error"] = Module_six_moves_urllib_error(__name__ + ".moves.urllib.error")


class Module_six_moves_urllib_request(types.ModuleType):
    """Lazy loading of moved objects in six.moves.urllib_request"""


_urllib_request_moved_attributes = [
    MovedAttribute("urlopen", "urllib2", "urllib.request"),
    MovedAttribute("install_opener", "urllib2", "urllib.request"),
    MovedAttribute("build_opener", "urllib2", "urllib.request"),
    MovedAttribute("pathname2url", "urllib", "urllib.request"),
    MovedAttribute("url2pathname", "urllib", "urllib.request"),
    MovedAttribute("getproxies", "urllib", "urllib.request"),
    MovedAttribute("Request", "urllib2", "urllib.request"),
    MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
    MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
    MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
    MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
    MovedAttribute("FileHandler", "urllib2", "urllib.request"),
    MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
    MovedAttribute("urlretrieve", "urllib", "urllib.request"),
    MovedAttribute("urlcleanup", "urllib", "urllib.request"),
    MovedAttribute("URLopener", "urllib", "urllib.request"),
    MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
]
for attr in _urllib_request_moved_attributes:
    setattr(Module_six_moves_urllib_request, attr.name, attr)
del attr

sys.modules[__name__ + ".moves.urllib_request"] = Module_six_moves_urllib_request(__name__ + ".moves.urllib_request")
sys.modules[__name__ + ".moves.urllib.request"] = Module_six_moves_urllib_request(__name__ + ".moves.urllib.request")


class Module_six_moves_urllib_response(types.ModuleType):
    """Lazy loading of moved objects in six.moves.urllib_response"""


_urllib_response_moved_attributes = [
    MovedAttribute("addbase", "urllib", "urllib.response"),
    MovedAttribute("addclosehook", "urllib", "urllib.response"),
    MovedAttribute("addinfo", "urllib", "urllib.response"),
    MovedAttribute("addinfourl", "urllib", "urllib.response"),
]
for attr in _urllib_response_moved_attributes:
    setattr(Module_six_moves_urllib_response, attr.name, attr)
del attr

sys.modules[__name__ + ".moves.urllib_response"] = Module_six_moves_urllib_response(__name__ + ".moves.urllib_response")
sys.modules[__name__ + ".moves.urllib.response"] = Module_six_moves_urllib_response(__name__ + ".moves.urllib.response")


class Module_six_moves_urllib_robotparser(types.ModuleType):
    """Lazy loading of moved objects in six.moves.urllib_robotparser"""


_urllib_robotparser_moved_attributes = [
    MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
]
for attr in _urllib_robotparser_moved_attributes:
    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
del attr

sys.modules[__name__ + ".moves.urllib_robotparser"] = Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib_robotparser")
sys.modules[__name__ + ".moves.urllib.robotparser"] = Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser")


class Module_six_moves_urllib(types.ModuleType):
    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
    parse = sys.modules[__name__ + ".moves.urllib_parse"]
    error = sys.modules[__name__ + ".moves.urllib_error"]
    request = sys.modules[__name__ + ".moves.urllib_request"]
    response = sys.modules[__name__ + ".moves.urllib_response"]
    robotparser = sys.modules[__name__ + ".moves.urllib_robotparser"]


sys.modules[__name__ + ".moves.urllib"] = Module_six_moves_urllib(__name__ + ".moves.urllib")


def add_move(move):
    """Add an item to six.moves."""
    setattr(_MovedItems, move.name, move)


def remove_move(name):
    """Remove item from six.moves."""
    try:
        delattr(_MovedItems, name)
    except AttributeError:
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_closure = "__closure__"
    _func_code = "__code__"
    _func_defaults = "__defaults__"
    _func_globals = "__globals__"

    _iterkeys = "keys"
    _itervalues = "values"
    _iteritems = "items"
    _iterlists = "lists"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_closure = "func_closure"
    _func_code = "func_code"
    _func_defaults = "func_defaults"
    _func_globals = "func_globals"

    _iterkeys = "iterkeys"
    _itervalues = "itervalues"
    _iteritems = "iteritems"
    _iterlists = "iterlists"


try:
    advance_iterator = next
except NameError:
    def advance_iterator(it):
        return it.next()
next = advance_iterator


try:
    callable = callable
except NameError:
    def callable(obj):
        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)


if PY3:
    def get_unbound_function(unbound):
        return unbound

    create_bound_method = types.MethodType

    Iterator = object
else:
    def get_unbound_function(unbound):
        return unbound.im_func

    def create_bound_method(func, obj):
        return types.MethodType(func, obj, obj.__class__)

    class Iterator(object):

        def next(self):
            return type(self).__next__(self)

    callable = callable
_add_doc(get_unbound_function,
         """Get the function out of a possibly unbound function""")


get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_closure = operator.attrgetter(_func_closure)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)
get_function_globals = operator.attrgetter(_func_globals)


def iterkeys(d, **kw):
    """Return an iterator over the keys of a dictionary."""
    return iter(getattr(d, _iterkeys)(**kw))

def itervalues(d, **kw):
    """Return an iterator over the values of a dictionary."""
    return iter(getattr(d, _itervalues)(**kw))

def iteritems(d, **kw):
    """Return an iterator over the (key, value) pairs of a dictionary."""
    return iter(getattr(d, _iteritems)(**kw))

def iterlists(d, **kw):
    """Return an iterator over the (key, [values]) pairs of a dictionary."""
    return iter(getattr(d, _iterlists)(**kw))


if PY3:
    def b(s):
        return s.encode("latin-1")
    def u(s):
        return s
    unichr = chr
    if sys.version_info[1] <= 1:
        def int2byte(i):
            return bytes((i,))
    else:
        # This is about 2x faster than the implementation above on 3.2+
        int2byte = operator.methodcaller("to_bytes", 1, "big")
    byte2int = operator.itemgetter(0)
    indexbytes = operator.getitem
    iterbytes = iter
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
else:
    def b(s):
        return s
    def u(s):
        return unicode(s, "unicode_escape")
    unichr = unichr
    int2byte = chr
    def byte2int(bs):
        return ord(bs[0])
    def indexbytes(buf, i):
        return ord(buf[i])
    def iterbytes(buf):
        return (ord(byte) for byte in buf)
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
_add_doc(b, """Byte literal""")
_add_doc(u, """Text literal""")


if PY3:
    import builtins
    exec_ = getattr(builtins, "exec")


    def reraise(tp, value, tb=None):
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb)
        raise value


    print_ = getattr(builtins, "print")
    del builtins

else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")


    exec_("""def reraise(tp, value, tb=None):
    raise tp, value, tb
""")


    def print_(*args, **kwargs):
        """The new-style print function."""
        fp = kwargs.pop("file", sys.stdout)
        if fp is None:
            return
        def write(data):
            if not isinstance(data, basestring):
                data = str(data)
            fp.write(data)
        want_unicode = False
        sep = kwargs.pop("sep", None)
        if sep is not None:
            if isinstance(sep, unicode):
                want_unicode = True
            elif not isinstance(sep, str):
                raise TypeError("sep must be None or a string")
        end = kwargs.pop("end", None)
        if end is not None:
            if isinstance(end, unicode):
                want_unicode = True
            elif not isinstance(end, str):
                raise TypeError("end must be None or a string")
        if kwargs:
            raise TypeError("invalid keyword arguments to print()")
        if not want_unicode:
            for arg in args:
                if isinstance(arg, unicode):
                    want_unicode = True
                    break
        if want_unicode:
            newline = unicode("\n")
            space = unicode(" ")
        else:
            newline = "\n"
            space = " "
        if sep is None:
            sep = space
        if end is None:
            end = newline
        for i, arg in enumerate(args):
            if i:
                write(sep)
            write(arg)
        write(end)

_add_doc(reraise, """Reraise an exception.""")


def with_metaclass(meta, *bases):
    """Create a base class with a metaclass."""
    return meta("NewBase", bases, {})

def add_metaclass(metaclass):
    """Class decorator for creating a class with a metaclass."""
    def wrapper(cls):
        orig_vars = cls.__dict__.copy()
        orig_vars.pop('__dict__', None)
        orig_vars.pop('__weakref__', None)
        for slots_var in orig_vars.get('__slots__', ()):
            orig_vars.pop(slots_var)
        return metaclass(cls.__name__, cls.__bases__, orig_vars)
    return wrapper
########NEW FILE########
__FILENAME__ = buffer
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------

import sys

import numpy as np

from . import gl
from . globject import GLObject
from ..util import logger


# ------------------------------------------------------------ Buffer class ---
class Buffer(GLObject):
    """ Generic GPU buffer.

    A generic buffer is an interface used to upload data to a GPU array buffer
    (gl.GL_ARRAY_BUFFER or gl.GL_ELEMENT_ARRAY_BUFFER). It keeps track of
    buffer size but does not have any CPU storage. You can consider it as
    write-only.

    The `set_data` is a deferred operation: you can call it even if an OpenGL
    context is not available. The `update` function is responsible to upload
    pending data to GPU memory and requires an active GL context.

    The Buffer class only deals with data in terms of bytes; it is not
    aware of data type or element size.

    Parameters
    ----------
    target : GLenum
        gl.GL_ARRAY_BUFFER or gl.GL_ELEMENT_ARRAY_BUFFER
    data : ndarray
        Buffer data
    nbytes : int
        Buffer byte size
    resizeable : bool
        Indicates whether buffer is resizeable
    """

    def __init__(self, data=None, target=gl.GL_ARRAY_BUFFER, nbytes=0,
                 resizeable=True):

        GLObject.__init__(self)
        self._need_resize = True
        self._resizeable = resizeable
        self._views = []
        self._valid = True

        # For ATI bug
        self._bufferSubDataOk = False

        # Store and check target
        if target not in (gl.GL_ARRAY_BUFFER, gl.GL_ELEMENT_ARRAY_BUFFER):
            raise ValueError("Invalid target for buffer object")
        self._target = target

        # Bytesize of buffer in GPU memory
        self._nbytes = nbytes

        # Buffer usage (GL_STATIC_DRAW, G_STREAM_DRAW or GL_DYNAMIC_DRAW)
        self._usage = gl.GL_DYNAMIC_DRAW

        # Set data
        self._pending_data = []
        if data is not None:
            self._nbytes = data.nbytes
            self.set_data(data, copy=False)

    @property
    def nbytes(self):
        """ Buffer byte size """

        return self._nbytes

    def set_data(self, data, offset=0, copy=False):
        """ Set data (deferred operation)

        Parameters
        ----------

        data : ndarray
            Data to be uploaded
        offset: int
            Offset in buffer where to start copying data (in bytes)
        copy: bool
            Since the operation is deferred, data may change before
            data is actually uploaded to GPU memory.
            Asking explicitly for a copy will prevent this behavior.
        """

        data = np.array(data, copy=copy)
        nbytes = data.nbytes

        if offset < 0:
            raise ValueError("Offset must be positive")
        elif offset == 0 and nbytes > self._nbytes:
            if not self._resizeable:
                raise ValueError("Data does not fit into buffer")
            else:
                self._nbytes = nbytes
                self._need_resize = True
                # Invalidate any view on this buffer
                for view in self._views:
                    view._valid = False
                self._views = []

        elif (offset + nbytes) > self._nbytes:
            raise ValueError("Data does not fit into buffer")

        # If the whole buffer is to be written, we clear any pending data
        # (because they will be overwritten anyway)
        if nbytes == self._nbytes and offset == 0:
            self._pending_data = []
        self._pending_data.append((data, nbytes, offset))
        self._need_update = True

    def _create(self):
        """ Create buffer on GPU """

        logger.debug("GPU: Creating buffer")
        self._handle = gl.glCreateBuffer()

    def _delete(self):
        """ Delete buffer from GPU """

        logger.debug("GPU: Deleting buffer")
        gl.glDeleteBuffer(self._handle)

    def _resize(self):
        """ """

        logger.debug("GPU: Resizing buffer(%d bytes)" % self._nbytes)
        gl.glBufferData(self._target, self._nbytes, self._usage)
        self._need_resize = False

    def _activate(self):
        """ Bind the buffer to some target """

        logger.debug("GPU: Activating buffer")
        gl.glBindBuffer(self._target, self._handle)

    def _deactivate(self):
        """ Unbind the current bound buffer """

        logger.debug("GPU: Deactivating buffer")
        gl.glBindBuffer(self._target, 0)

    def _update(self):
        """ Upload all pending data to GPU. """

        if self.base is not None:
            return

        if self._need_resize:
            self._resize()
            self._need_resize = False

        logger.debug("GPU: Updating buffer (%d pending operation(s))" %
                     len(self._pending_data))
        while self._pending_data:
            data, nbytes, offset = self._pending_data.pop(0)

            # Determine whether to check errors to try handling the ATI bug
            check_ati_bug = ((not self._bufferSubDataOk) and
                             (gl.current_backend is gl.desktop) and
                             sys.platform.startswith('win'))

            # flush any pending errors
            if check_ati_bug:
                gl.check_error('periodic check')

            try:
                gl.glBufferSubData(self._target, offset, data)
                if check_ati_bug:
                    gl.check_error('glBufferSubData')
                self._bufferSubDataOk = True  # glBufferSubData seems to work
            except Exception:
                # This might be due to a driver error (seen on ATI), issue #64.
                # We try to detect this, and if we can use glBufferData instead
                if offset == 0 and nbytes == self._nbytes:
                    gl.glBufferData(self._target, data, self._usage)
                    logger.debug("Using glBufferData instead of " +
                                 "glBufferSubData (known ATI bug).")
                else:
                    raise


# -------------------------------------------------------- DataBuffer class ---
class DataBuffer(Buffer):
    """ GPU data buffer that is aware of data type and elements size

    Parameters
    ----------

    target : GLENUM
        gl.GL_ARRAY_BUFFER or gl.GL_ELEMENT_ARRAY_BUFFER
    data : ndarray
        Buffer data (optional)
    dtype : dtype
        Buffer data type (optional)
    size : int
        Buffer element size
    base : DataBuffer
        Base buffer of this buffer
    offset : int
        Byte offset of this buffer relative to base buffer
    store : bool
        Specify whether this object stores a reference to the data,
        allowing the data to be updated regardless of striding. Note
        that modifying the data after passing it here might result in
        undesired behavior, unless a copy is given. Default True.
    resizeable : bool
        Indicates whether buffer is resizeable
    """

    def __init__(self, data=None, dtype=None, target=gl.GL_ARRAY_BUFFER,
                 size=0, base=None, offset=0, store=True, resizeable=True):

        Buffer.__init__(self, target=target, resizeable=resizeable)
        self._base = base
        self._offset = offset
        self._data = None
        self._store = store
        self._copy = False  # flag to indicate that a copy is made
        self._size = size

        # This buffer is a view on another
        if base is not None:
            self._dtype = base.dtype
            if dtype is not None:
                self._dtype = dtype
            self._stride = base.stride
            #self._size = size or base.size
            self._itemsize = self._dtype.itemsize
            self._nbytes = self._size * self._itemsize

        # Create buffer from data
        elif data is not None:
            if dtype is not None:
                data = np.array(data, dtype=dtype, copy=False)
            else:
                data = np.array(data, copy=False)
            # Handle storage
            if self._store:
                if not data.flags["C_CONTIGUOUS"]:
                    logger.warning("Copying discontiguous data as CPU storage")
                    self._copy = True
                    data = data.copy()
                self._data = data.ravel()  # Makes a copy if not contiguous
            # Store meta data (AFTER flattening, or stride would be wrong)
            self._dtype = data.dtype
            self._size = data.size
            self._stride = data.strides[-1]
            self._nbytes = data.nbytes
            self._itemsize = self._dtype.itemsize
            # Set data
            self.set_data(data, copy=False)

        # Create buffer from dtype and size
        elif dtype is not None:
            self._dtype = np.dtype(dtype)
            self._size = size
            self._stride = self._dtype.itemsize
            self._itemsize = self._dtype.itemsize
            self._nbytes = self._size * self._itemsize
            if self._store:
                self._data = np.empty(self._size, dtype=self._dtype)
            # else:
            #    self.set_data(data,copy=True)

        # We need a minimum amount of information
        else:
            raise ValueError("data/dtype/base cannot be all set to None")

    @property
    def handle(self):
        """ Name of this object on the GPU """

        if self._base:
            return self._base.handle
        else:
            return self._handle

    @property
    def target(self):
        """ OpenGL type of object. """

        if self._base:
            return self._base.target
        else:
            return self._target

    def activate(self):
        """ Activate the object on GPU """

        if self._base is not None:
            self._base.activate()
        else:
            GLObject.activate(self)

    def deactivate(self):
        """ Deactivate the object on GPU """

        if self._base is not None:
            self._base.deactivate()
        else:
            GLObject.deactivate(self)

    def set_data(self, data, offset=0, copy=False):
        """ Set data (deferred operation)

        Parameters
        ----------

        data : ndarray
            Data to be uploaded
        offset: int
            Offset in buffer to start copying data (in number of vertices)
        copy: bool
            Since the operation is deferred, data may change before
            data is actually uploaded to GPU memory.
            Asking explicitly for a copy will prevent this behavior.
        """
        if self.base is not None:
            raise ValueError("Cannot set data on a non-base buffer")
        else:
            offset = offset * self.itemsize
            Buffer.set_data(self, data=data, offset=offset, copy=copy)

    @property
    def dtype(self):
        """ Buffer dtype """

        return self._dtype

    @property
    def offset(self):
        """ Buffer offset (in bytes) relative to base """

        return self._offset

    @property
    def stride(self):
        """ Stride of data in memory """

        return self._stride

    @property
    def base(self):
        """Buffer base if this buffer is a view on another buffer. """

        return self._base

    @property
    def size(self):
        """ Number of elements in the buffer """

        return self._size

    @property
    def data(self):
        """ Buffer CPU storage """

        return self._data

    @property
    def itemsize(self):
        """ The total number of bytes required to store the array data """

        return self._itemsize

    def resize(self, size):
        """ Resize the buffer (in-place, deferred operation)

        Parameters
        ----------
        size : integer
            New buffer size

        Notes
        -----
        This clears any pending operations.
        """

        if not self._resizeable:
            raise RuntimeError("Buffer is not resizeable")

        if self._base is not None:
            raise RuntimeError("Buffer view is not resizeable")

        if size == self.size:
            return

        # Invalidate any view on this texture
        for view in self._views:
            view._valid = False
        self._views = []

        self._pending_data = []
        self._need_update = False
        self._need_resize = True
        self._size = size
        if self._data is not None and self._store:
            self._data = np.resize(self._data, self._size)
        else:
            self._data = None

    def __getitem__(self, key):
        """ Create a view on this buffer. """

        if self.base is not None:
            raise ValueError("Can only access data from a base buffer")

        if isinstance(key, str):
            dtype = self.dtype[key]
            offset = self.dtype.fields[key][1]
            target = self.target
            base = self
            V = self.__class__(target=target, dtype=dtype, base=base,
                               size=self.size, offset=offset)
            V._nbytes = self.size * dtype.itemsize
            V._itemsize = dtype.itemsize
            V._key = key
            self._views.append(V)
            return V

        if isinstance(key, int):
            if key < 0:
                key += self.size
            if key < 0 or key > self.size:
                raise IndexError("Buffer assignment index out of range")
            start, stop, step = key, key + 1, 1
        elif isinstance(key, slice):
            start, stop, step = key.indices(self.size)
            if stop < start:
                start, stop = stop, start
        elif key == Ellipsis:
            start, stop, step = 0, self.size, 1
        else:
            raise TypeError("Buffer indices must be integers or strings")

        if step != 1:
            raise ValueError("Cannot access non-contiguous data")

        if self.data is not None:
            data = self.data[key]
            V = self.__class__(target=self.target, base=self,
                               data=data, size=stop - start,
                               offset=start * self.itemsize, resizeable=False)
        else:
            V = self.__class__(target=self.target, base=self,
                               dtype=self.dtype, size=stop - start,
                               offset=start * self.itemsize, resizeable=False)
        V._key = key
        self._views.append(V)
        return V

    def __setitem__(self, key, data):
        """ Set data (deferred operation) """

        if self.base is not None and not self._valid:
            raise ValueError("This texture view has been invalited")

        # Setting a whole field of the buffer: only allowed if we have CPU
        # storage. Note this case (key is str) only happen with base buffer
        if isinstance(key, str):
            if self.base is not None:
                raise ValueError(
                    "Cannot set a specific field on a non-base buffer")
            if self._data is None:
                raise ValueError(
                    """Cannot set non contiguous """
                    """data on buffer without CPU storage""")

            # WARNING: do we check data size
            #          or do we let numpy raises an error ?
            self._data[key] = data
            self.set_data(self._data, offset=0, copy=False)
            return

        elif key == Ellipsis and self.base is not None:
            # WARNING: do we check data size
            #          or do we let numpy raises an error ?
            self.base[self._key] = data
            return
        # Setting one or several elements
        elif isinstance(key, int):
            if key < 0:
                key += self.size
            if key < 0 or key > self.size:
                raise IndexError("Buffer assignment index out of range")
            start, stop, step = key, key + 1, 1
        elif isinstance(key, slice):
            start, stop, step = key.indices(self.size)
            if stop < start:
                start, stop = stop, start
        elif key == Ellipsis:
            start, stop, step = 0, self.size, 1
        else:
            raise TypeError("Buffer indices must be integers or strings")

        # Buffer is a view on a base buffer
        if self.base is not None:
            base = self.base
            # Base buffer has CPU storage
            if base.data is not None:
                # WARNING: do we check data size
                #          or do we let numpy raises an error ?
                base.data[key] = data
                offset = start * base.itemsize
                data = base.data[start:stop]
                base.set_data(data=data, offset=offset, copy=False)
            # Base buffer has no CPU storage, we cannot do operation
            else:
                raise ValueError(
                    """Cannot set non contiguous data """
                    """on buffer without CPU storage""")

        # Buffer is a base buffer and we have CPU storage
        elif self.data is not None:
            # WARNING: do we check data size
            #          or do we let numpy raises an error ?
            self.data[key] = data
            offset = start * self.itemsize
            self.set_data(data=self.data[start:stop],
                          offset=offset, copy=False)

        # Buffer is a base buffer but we do not have CPU storage
        # If 'key' points to a contiguous chunk of buffer, it's ok
        elif step == 1:
            offset = start * self.itemsize

            # Make sure data is an array
            if not isinstance(data, np.ndarray):
                data = np.array(data, dtype=self.dtype, copy=False)

            # Make sure data is big enough
            if data.size != stop - start:
                data = np.resize(data, stop - start)

            self.set_data(data=data, offset=offset, copy=True)

        # All the above fails, we raise an error
        else:
            raise ValueError(
                "Cannot set non contiguous data on buffer without CPU storage")


# ------------------------------------------------------ VertexBuffer class ---
class VertexBuffer(DataBuffer):
    """ Buffer for vertex attribute data

    Parameters
    ----------

    data : ndarray
        Buffer data (optional)
    dtype : dtype
        Buffer data type (optional)
    size : int
        Buffer size (optional)
    store : bool
        Specify whether this object stores a reference to the data,
        allowing the data to be updated regardless of striding. Note
        that modifying the data after passing it here might result in
        undesired behavior, unless a copy is given. Default True.
    resizeable : bool
        Indicates whether buffer is resizeable
    """

    def __init__(self, data=None, dtype=None, size=0, store=True,
                 resizeable=True, *args, **kwargs):

        # We don't want these two parameters to be seen from outside
        # (because they are used internally only)
        offset = kwargs.get("offset", 0)
        base = kwargs.get("base", None)

        # Build a structured view of the data if:
        #  -> it is not already a structured array
        #  -> it is not a view of another buffer
        #  -> shape if 1-D or last dimension is 1,2,3 or 4
        if data is not None and base is None and data.dtype.isbuiltin:
            if len(data.shape) == 1:
                data = data.view(dtype=[('f0', data.dtype.base, 1)])
            elif data.shape[-1] in [1, 2, 3, 4]:
                c = data.shape[-1]
                if not data.flags['C_CONTIGUOUS']:
                    logger.warn("Copying discontiguous data for struct dtype")
                    data = data.copy()
                data = data.view(dtype=[('f0', data.dtype.base, c)])
            else:
                data = data.view(dtype=[('f0', data.dtype.base, 1)])

        elif dtype is not None:
            dtype = np.dtype(dtype)
            if dtype.isbuiltin:
                dtype = np.dtype([('f0', dtype, 1)])

        DataBuffer.__init__(self, data=data, dtype=dtype, size=size, base=base,
                            offset=offset, target=gl.GL_ARRAY_BUFFER,
                            store=store, resizeable=resizeable)

        # Check base type and count for each dtype fields (if buffer is a base)
        if base is None:
            for name in self.dtype.names:
                btype = self.dtype[name].base
                if len(self.dtype[name].shape):
                    count = 1
                    s = self.dtype[name].shape
                    for i in range(len(s)):
                        count *= s[i]
                    #count = reduce(mul, self.dtype[name].shape)
                else:
                    count = 1
                if btype not in [np.int8,  np.uint8,  np.float16,
                                 np.int16, np.uint16, np.float32]:
                    msg = "Data basetype not allowed for Buffer/%s" % name
                    raise TypeError(msg)
                elif count not in [1, 2, 3, 4]:
                    msg = "Data basecount not allowed for Buffer/%s" % name
                    raise TypeError(msg)


# ------------------------------------------------------- IndexBuffer class ---
class IndexBuffer(DataBuffer):
    """ Buffer for index data

    Parameters
    ----------

    data : ndarray
        Buffer data (optional)
    dtype : dtype
        Buffer data type (optional)
    size : int
        Buffer size (optional)
    store : bool
        Specify whether this object stores a reference to the data,
        allowing the data to be updated regardless of striding. Note
        that modifying the data after passing it here might result in
        undesired behavior, unless a copy is given. Default True.
    resizeable : bool
        Indicates whether buffer is resizeable
    """

    def __init__(self, data=None, dtype=np.uint32, size=0, store=True,
                 resizeable=True, *args, **kwargs):

        # We don't want these two parameters to be seen from outside
        # (because they are used internally only)
        offset = kwargs.get("offset", 0)
        base = kwargs.get("base", None)

        if dtype and not np.dtype(dtype).isbuiltin:
            raise TypeError("Element buffer dtype cannot be structured")

        if isinstance(data, np.ndarray):
            if not data.dtype.isbuiltin:
                raise TypeError("Element buffer dtype cannot be structured")
            else:
                dtype = data.dtype
        elif dtype not in [np.uint8, np.uint16, np.uint32]:
            raise TypeError("Data type not allowed for IndexBuffer")

        DataBuffer.__init__(self, data=data, dtype=dtype, size=size, base=base,
                            offset=offset, target=gl.GL_ELEMENT_ARRAY_BUFFER,
                            store=store, resizeable=resizeable)

########NEW FILE########
__FILENAME__ = framebuffer
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------

#import OpenGL.GL as gl
from . import gl
from .globject import GLObject
from .texture import Texture2D
from ..util import logger

# ------------------------------------------------------ RenderBuffer class ---


class RenderBuffer(GLObject):
    """ Base class for render buffer object
    
    Parameters
    ----------

    format : GLEnum
        The buffer format: gl.GL_RGB565, gl.GL_RGBA4, gl.GL_RGB5_A1, 
        gl.GL_DEPTH_COMPONENT16, or gl.GL_STENCIL_INDEX8
    shape : tuple of 2 ints
        Buffer shape (always two dimensional)
    resizeable : bool
        Indicates whether texture can be resized
    """

    def __init__(self, shape=None, format=None, resizeable=True):
        GLObject.__init__(self)
        self._shape = shape
        self._target = gl.GL_RENDERBUFFER
        self._format = format
        self._resizeable = resizeable
        self._need_resize = True
        self._need_update = False

    @property
    def shape(self):
        """ Buffer shape """

        return self._shape

    def resize(self, shape):
        """ Resize the buffer (deferred operation)

        Parameters
        ----------

        shape : tuple of 2 integers
            New buffer shape (always two dimensional)
        """

        if not self._resizeable:
            raise RuntimeError("Buffer is not resizeable")

        if len(shape) != len(self.shape):
            raise ValueError("New shape has wrong number of dimensions")

        if shape == self.shape:
            return

        self._need_resize = True
        self._shape = shape

    def _create(self):
        """ Create buffer on GPU """

        logger.debug("GPU: Create render buffer")
        self._handle = gl.glCreateRenderbuffer()

    def _delete(self):
        """ Delete buffer from GPU """

        logger.debug("GPU: Deleting render buffer")
        gl.glDeleteRenderbuffer(self._handle)

    def _activate(self):
        """ Activate buffer on GPU """

        logger.debug("GPU: Activate render buffer")
        gl.glBindRenderbuffer(gl.GL_RENDERBUFFER, self._handle)
        if self._need_resize:
            self._resize()
            self._need_resize = False

    def _deactivate(self):
        """ Deactivate buffer on GPU """

        logger.debug("GPU: Deactivate render buffer")
        gl.glBindRenderbuffer(gl.GL_RENDERBUFFER, 0)

    def _resize(self):
        """ Buffer resize on GPU """

        # WARNING: Shape should be checked against maximum size
        # maxsize = gl.glGetParameter(gl.GL_MAX_RENDERBUFFER_SIZE)
        logger.debug("GPU: Resize render buffer")
        gl.glRenderbufferStorage(self._target, self._format,
                                 self._shape[1], self._shape[0])


# ------------------------------------------------------- ColorBuffer class ---
class ColorBuffer(RenderBuffer):
    """ Color buffer object
    
    Parameters
    ----------

    format : GLEnum
        gl.GL_RGB565, gl.GL_RGBA4, gl.GL_RGB5_A1
    shape : tuple of 2 integers
        Buffer shape (always two dimensional)
    resizeable : bool
        Indicates whether buffer can be resized
    """

    def __init__(self, shape, format=gl.GL_RGBA, resizeable=True):
        # if format not in (gl.GL_RGB565, gl.GL_RGBA4, gl.GL_RGB5_A1):
        #     raise ValueError("Format not allowed for color buffer")
        RenderBuffer.__init__(self, shape, format, resizeable)


# ------------------------------------------------------- DepthBuffer class ---
class DepthBuffer(RenderBuffer):
    """ Depth buffer object
    
    Parameters
    ----------

    shape : tuple of 2 integers
        Buffer shape (always two dimensional)
    format : GLEnum
        gl.GL_DEPTH_COMPONENT16
    resizeable : bool
        Indicates whether buffer can be resized
    """

    def __init__(self, shape,
                 format=gl.GL_DEPTH_COMPONENT, resizeable=True):
        #if format not in (gl.GL_DEPTH_COMPONENT16,):
        #    raise ValueError("Format not allowed for depth buffer")
        RenderBuffer.__init__(self, shape, format, resizeable)


# ----------------------------------------------------- StencilBuffer class ---
class StencilBuffer(RenderBuffer):
    """ Stencil buffer object
    
    Parameters
    ----------

    shape : tuple of 2 integers
        Buffer shape (always two dimensional)
    format : GLEnum
        gl.GL_STENCIL_INDEX8
    resizeable : bool
        Indicates whether buffer can be resized
    """

    def __init__(self, shape,
                 format=gl.GL_STENCIL_INDEX8, resizeable=True):
        # if format not in (gl.GL_STENCIL_INDEX,):
        #     raise ValueError("Format not allowed for color buffer")
        RenderBuffer.__init__(self, shape, format, resizeable)


# ------------------------------------------------------- FrameBuffer class ---
class FrameBuffer(GLObject):
    """ Frame buffer object
    
    Parameters
    ----------
    
    color : ColorBuffer (optional)
        The color buffer to attach to this frame buffer
    depth : DepthBuffer (optional)
        The depth buffer to attach to this frame buffer
    stencil : StencilBuffer (optional)
        The stencil buffer to attach to this frame buffer
    resizable : bool
        Whether the buffers are resizable (default True)
    """

    def __init__(self, color=None, depth=None, stencil=None, resizeable=True):
        """
        """

        GLObject.__init__(self)

        self._shape = None
        self._color_buffer = color
        self._depth_buffer = depth
        self._stencil_buffer = stencil
        self._need_update = False
        self._need_attach = True
        self._resizeable = resizeable
        self._pending_attachments = []

        if color is not None:
            self.color_buffer = color
        if depth is not None:
            self.depth_buffer = depth
        if stencil is not None:
            self.stencil_buffer = stencil

    @property
    def color_buffer(self):
        """Color buffer attachment"""

        return self._color_buffer

    @color_buffer.setter
    def color_buffer(self, buffer):
        """Color buffer attachment"""

        target = gl.GL_COLOR_ATTACHMENT0
        self._color_buffer = buffer
        if isinstance(buffer, (ColorBuffer, Texture2D)) or buffer is None:
            self._pending_attachments.append((target, buffer))
        else:
            raise ValueError(
                "Buffer must be a ColorBuffer, Texture2D or None")

    @property
    def depth_buffer(self):
        """Depth buffer attachment"""

        return self._depth_buffer

    @depth_buffer.setter
    def depth_buffer(self, buffer):
        """Depth buffer attachment"""

        target = gl.GL_DEPTH_ATTACHMENT
        self._depth_buffer = buffer
        if isinstance(buffer, (DepthBuffer, Texture2D)) or buffer is None:
            self._pending_attachments.append((target, buffer))
        else:
            raise ValueError(
                "Buffer must be a DepthBuffer, Texture2D or None")

    @property
    def stencil_buffer(self):
        """Stencil buffer attachment"""

        return self._stencil_buffer

    @stencil_buffer.setter
    def stencil_buffer(self, buffer):
        """Stencil buffer attachment"""

        target = gl.GL_STENCIL_ATTACHMENT
        self._stencil_buffer = buffer
        if isinstance(buffer, StencilBuffer) or buffer is None:
            self._pending_attachments.append((target, buffer))
        else:
            raise ValueError(
                "Buffer must be a StencilBuffer, Texture2D or None")

    @property
    def shape(self):
        """ Buffer shape """

        return self._shape

    def resize(self, shape):
        """ Resize the buffer (deferred operation)

        Parameters
        ----------

        shape : tuple of 2 integers
            New buffer shape (always two dimensional)
        """

        if not self._resizeable:
            raise RuntimeError("FrameBuffer is not resizeable")

        if len(shape) != 2:
            raise ValueError("New shape has wrong number of dimensions")

        if self.color is not None:
            self.color.resize(shape)
        if self.depth is not None:
            self.depth.resize(shape)
        if self.stencil is not None:
            self.stencil.resize(shape)

    def _create(self):
        """ Create framebuffer on GPU """

        logger.debug("GPU: Create framebuffer")
        self._handle = gl.glCreateFramebuffer()

    def _delete(self):
        """ Delete buffer from GPU """

        logger.debug("GPU: Delete framebuffer")
        gl.glDeleteFramebuffer(self._handle)

    def _activate(self):
        """ Activate framebuffer on GPU """

        logger.debug("GPU: Activate render framebuffer")
        gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, self._handle)
        if self._need_attach:
            self._attach()
            self._need_attach = False

    def _deactivate(self):
        """ Deactivate framebuffer on GPU """

        logger.debug("GPU: Deactivate render framebuffer")
        gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, 0)

    def _attach(self):
        """ Attach render buffers to framebuffer """
        
        # todo: this can currently only attach to texture mipmap level 0
        
        logger.debug("GPU: Attach render buffers")
        while self._pending_attachments:
            attachment, buffer = self._pending_attachments.pop(0)
            if buffer is None:
                gl.glFramebufferRenderbuffer(gl.GL_FRAMEBUFFER, attachment,
                                             gl.GL_RENDERBUFFER, 0)
            elif isinstance(buffer, RenderBuffer):
                buffer.activate()
                gl.glFramebufferRenderbuffer(gl.GL_FRAMEBUFFER, attachment,
                                             gl.GL_RENDERBUFFER, buffer.handle)
                buffer.deactivate()
            elif isinstance(buffer, Texture2D):
                buffer.activate()
                # INFO: 0 is for mipmap level 0 (default) of the texture
                gl.glFramebufferTexture2D(gl.GL_FRAMEBUFFER, attachment,
                                          buffer.target, buffer.handle, 0)
                buffer.deactivate()
            else:
                raise ValueError("Invalid attachment")

        if 1:
            res = gl.glCheckFramebufferStatus(gl.GL_FRAMEBUFFER)
            if res == gl.GL_FRAMEBUFFER_COMPLETE:
                pass
            elif res == 0:
                raise RuntimeError('Target not equal to GL_FRAMEBUFFER')
            elif res == gl.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                raise RuntimeError(
                    'FrameBuffer attachments are incomplete.')
            elif res == gl.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                raise RuntimeError(
                    'No valid attachments in the FrameBuffer.')
            elif res == gl.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                raise RuntimeError(
                    'attachments do not have the same width and height.')
            elif res == gl.GL_FRAMEBUFFER_INCOMPLETE_FORMATS:
                raise RuntimeError('Internal format of attachment '
                                   'is not renderable.')
            elif res == gl.GL_FRAMEBUFFER_UNSUPPORTED:
                raise RuntimeError('Combination of internal formats used '
                                   'by attachments is not supported.')

########NEW FILE########
__FILENAME__ = angle
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

""" GL ES 2.0 API implemented via Angle (i.e translated to DirectX).
"""

import ctypes

from . import _copy_gl_functions
from ._constants import *  # noqa


## Ctypes stuff

# todo: were are we going to put our libs?
dirname = r'C:\Users\Almar\AppData\Local\Chromium\Application\34.0.1790.0'

# Load dependency (so that libGLESv2 can find it
fname = dirname + r'\d3dcompiler_46.dll'
_libdum = ctypes.windll.LoadLibrary(fname)

# Load GL ES 2.0 lib (Angle)
fname = dirname + r'\libGLESv2.dll'
_lib = ctypes.windll.LoadLibrary(fname)


## Compatibility


def glShaderSource_compat(handle, code):
    """ Easy for real ES 2.0.
    """
    glShaderSource(handle, [code])
    return []


## Inject


from . import _angle
_copy_gl_functions(_angle, globals())

########NEW FILE########
__FILENAME__ = desktop
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

""" GL ES 2.0 API implemented via desktop GL (i.e subset of normal OpenGL).
"""

import sys
import ctypes.util

from . import _copy_gl_functions
from ._constants import *  # noqa


## Ctypes stuff


# Load the OpenGL library. We more or less follow the same approach
# as PyOpenGL does internally

if sys.platform.startswith('win'):
    # Windows
    _lib = ctypes.windll.opengl32
    try:
        wglGetProcAddress = _lib.wglGetProcAddress
        wglGetProcAddress.restype = ctypes.CFUNCTYPE(
            ctypes.POINTER(ctypes.c_int))
        wglGetProcAddress.argtypes = [ctypes.c_char_p]
        _have_get_proc_address = True
    except AttributeError:
        _have_get_proc_address = False
else:
    # Unix-ish
    _have_get_proc_address = False
    # Get filename
    if sys.platform.startswith('darwin'):
        _fname = ctypes.util.find_library('OpenGL')
    else:
        _fname = ctypes.util.find_library('GL')
    if not _fname:
        raise RuntimeError('Could not load OpenGL library.')
    # Load lib
    _lib = ctypes.cdll.LoadLibrary(_fname)


def _have_context():
    return _lib.glGetError() != 1282  # GL_INVALID_OPERATION


def _get_gl_func(name, restype, argtypes):
    # Based on a function in Pyglet
    try:
        # Try using normal ctypes stuff
        func = getattr(_lib, name)
        func.restype = restype
        func.argtypes = argtypes
        return func
    except AttributeError:
        if sys.platform.startswith('win'):
            # Ask for a pointer to the function, this is the approach
            # for OpenGL extensions on Windows
            fargs = (restype,) + argtypes
            ftype = ctypes.WINFUNCTYPE(*fargs)
            if not _have_get_proc_address:
                raise RuntimeError('Function %s not available.' % name)
            if not _have_context():
                raise RuntimeError('Using %s with no OpenGL context.' % name)
            address = wglGetProcAddress(name.encode('utf-8'))
            if address:
                return ctypes.cast(address, ftype)
        # If not Windows or if we did not return function object on Windows:
        raise RuntimeError('Function %s not present in context.' % name)


## Compatibility


def glShaderSource_compat(handle, code):
    """ This version of glShaderSource applies small modifications
    to the given GLSL code in order to make it more compatible between
    desktop and ES2.0 implementations. Specifically:
      * It sets the #version pragma (if none is given already)
      * It returns a (possibly empty) set of enums that should be enabled
        (for automatically enabling point sprites)
    """

    # Make a string
    if isinstance(code, (list, tuple)):
        code = '\n'.join(code)

    # Determine whether this is a vertex or fragment shader
    code_ = '\n' + code
    is_vertex = '\nattribute' in code_
    is_fragment = not is_vertex

    # Determine whether to write the #version pragma
    write_version = True
    for line in code.splitlines():
        if line.startswith('#version'):
            write_version = False
            logger.warn('For compatibility accross different GL backends, ' +
                        'avoid using the #version pragma.')
    if write_version:
        code = '#version 120\n#line 0\n' + code

    # Do the call
    glShaderSource(handle, [code])

    # Determine whether to activate point sprites
    enums = set()
    if is_fragment and 'gl_PointCoord' in code:
        enums.add(Enum('GL_VERTEX_PROGRAM_POINT_SIZE', 34370))
        enums.add(Enum('GL_POINT_SPRITE', 34913))
    return enums
    return []


## Inject


from . import _desktop
_copy_gl_functions(_desktop, globals())

########NEW FILE########
__FILENAME__ = pyopengl
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

""" GL ES 2.0 API implemented via pyOpenGL library. Intended as a
fallback and for testing.
"""

from OpenGL import GL as _GL
import OpenGL.GL.framebufferobjects as _FBO

from ...util import logger

from . import _copy_gl_functions
from ._constants import *  # noqa


## Compatibility


def glShaderSource_compat(handle, code):
    """ This version of glShaderSource applies small modifications
    to the given GLSL code in order to make it more compatible between
    desktop and ES2.0 implementations. Specifically:
      * It sets the #version pragma (if none is given already)
      * It returns a (possibly empty) set of enums that should be enabled
        (for automatically enabling point sprites)
    """

    # Make a string
    if isinstance(code, (list, tuple)):
        code = '\n'.join(code)

    # Determine whether this is a vertex or fragment shader
    code_ = '\n' + code
    is_vertex = '\nattribute' in code_
    is_fragment = not is_vertex

    # Determine whether to write the #version pragma
    write_version = True
    for line in code.splitlines():
        if line.startswith('#version'):
            write_version = False
            logger.warn('For compatibility accross different GL backends, ' +
                        'avoid using the #version pragma.')
    if write_version:
        code = '#version 120\n#line 0\n' + code

    # Do the call
    glShaderSource(handle, [code])

    # Determine whether to activate point sprites
    enums = set()
    if is_fragment and 'gl_PointCoord' in code:
        enums.add(Enum('GL_VERTEX_PROGRAM_POINT_SIZE', 34370))
        enums.add(Enum('GL_POINT_SPRITE', 34913))
    return enums
    return []


def _patch():
    """ Monkey-patch pyopengl to fix a bug in glBufferSubData. """
    import sys
    from OpenGL import GL
    if sys.version_info > (3,):
        buffersubdatafunc = GL.glBufferSubData
        if hasattr(buffersubdatafunc, 'wrapperFunction'):
            buffersubdatafunc = buffersubdatafunc.wrapperFunction
        _m = sys.modules[buffersubdatafunc.__module__]
        _m.long = int
    
    # Fix missing enum
    try:
        from OpenGL.GL.VERSION import GL_2_0
        GL_2_0.GL_OBJECT_SHADER_SOURCE_LENGTH = GL_2_0.GL_SHADER_SOURCE_LENGTH
    except Exception:
        pass


# Patch OpenGL package
_patch()


## Inject

def _make_unavailable_func(funcname):
    def cb(*args, **kwds):
        raise RuntimeError('OpenGL API call "%s" is not available.' % funcname)
    return cb


def _get_function_from_pyopengl(funcname):
    """ Try getting the given function from PyOpenGL, return
    a dummy function (that shows a warning when called) if it
    could not be found.
    """
    func = None
    
    # Get function from GL
    try:
        func = getattr(_GL, funcname)
    except AttributeError:
        # Get function from FBO
        try:
            func = getattr(_FBO, funcname)
        except AttributeError:
            func = None
    
    # Try using "alias"
    if not bool(func):
        # Some functions are known by a slightly different name
        # e.g. glDepthRangef, glClearDepthf
        if funcname.endswith('f'):
            try:
                func = getattr(_GL, funcname[:-1])
            except AttributeError:
                pass

    # Set dummy function if we could not find it
    if func is None:
        func = _make_unavailable_func(funcname)
        logger.warn('warning: %s not available' % funcname)
    return func


def _inject():
    """ Copy functions from OpenGL.GL into _pyopengl namespace.
    """
    NS = _pyopengl.__dict__
    for glname, ourname in _pyopengl._functions_to_import:
        func = _get_function_from_pyopengl(glname)
        NS[ourname] = func


from . import _pyopengl

# Inject remaining functions from OpenGL.GL
# copies name to _pyopengl namespace
_inject()

# Inject all function definitions in _pyopengl
_copy_gl_functions(_pyopengl, globals())

########NEW FILE########
__FILENAME__ = test_basics
""" Test to verify some basic functionality of our OpenGL API. We cover
much more in the test_functionality. Together, these two tests should
touch *all* ES 2.0 API calls.

The only exception is glCompressedTexImage2D and glCompressedTexSubImage2D.
"""

import sys

from nose.tools import assert_equal, assert_true  # noqa
from vispy.app import Canvas
from numpy.testing import assert_almost_equal
from vispy.testing import (requires_application, requires_pyopengl, SkipTest,
                           glut_skip)
from vispy.ext.six import string_types

from vispy.gloo import gl


def teardown_module():
    gl.use()  # Reset to default


@requires_application()
def test_basics_desktop():
    """ Test desktop GL backend for basic functionality. """
    glut_skip()
    _test_basics('desktop')


@requires_application()
def test_functionality_proxy():
    """ Test GL proxy class for basic functionality. """
    # By using debug mode, we are using the proxy class
    glut_skip()
    _test_basics('desktop debug')


@requires_application()
@requires_pyopengl()
def test_basics_pypengl():
    """ Test pyopengl GL backend for basic functionality. """
    glut_skip()
    _test_basics('pyopengl')


@requires_application()
def test_functionality_angle():
    """ Test angle GL backend for basic functionality. """
    if True:
        raise SkipTest('Skip Angle functionality test for now.')
    if sys.platform.startswith('win'):
        raise SkipTest('Can only test angle functionality on Windows.')

    glut_skip()
    _test_basics('angle')


def _test_basics(backend):
    """ Create app and canvas so we have a context. Then run tests.
    """

    # use the backend
    gl.use(backend)

    with Canvas():
        _test_setting_parameters()
        _test_enabling_disabling()
        _test_setting_stuff()
        _test_object_creation_and_deletion()
        _test_fbo()
        gl.glFinish()


def _test_setting_parameters():
    # Set some parameters and get result
    clr = 1.0, 0.1, 0.2, 0.7
    gl.glClearColor(*clr)
    assert_almost_equal(gl.glGetParameter(gl.GL_COLOR_CLEAR_VALUE), clr)
    #
    gl.glCullFace(gl.GL_FRONT)
    assert_equal(gl.glGetParameter(gl.GL_CULL_FACE_MODE), gl.GL_FRONT)
    gl.glCullFace(gl.GL_BACK)
    assert_equal(gl.glGetParameter(gl.GL_CULL_FACE_MODE), gl.GL_BACK)
    #
    gl.glDepthFunc(gl.GL_NOTEQUAL)
    assert_equal(gl.glGetParameter(gl.GL_DEPTH_FUNC), gl.GL_NOTEQUAL)
    #
    val = 0.2, 0.3
    gl.glDepthRange(*val)
    assert_almost_equal(gl.glGetParameter(gl.GL_DEPTH_RANGE), val)
    
    gl.check_error()


def _test_enabling_disabling():
    # Enabling/disabling
    gl.glEnable(gl.GL_DEPTH_TEST)
    assert_equal(gl.glIsEnabled(gl.GL_DEPTH_TEST), True)
    assert_equal(gl.glGetParameter(gl.GL_DEPTH_TEST), 1)
    gl.glDisable(gl.GL_DEPTH_TEST)
    assert_equal(gl.glIsEnabled(gl.GL_DEPTH_TEST), False)
    assert_equal(gl.glGetParameter(gl.GL_DEPTH_TEST), 0)
    #
    gl.glEnable(gl.GL_BLEND)
    assert_equal(gl.glIsEnabled(gl.GL_BLEND), True)
    assert_equal(gl.glGetParameter(gl.GL_BLEND), 1)
    gl.glDisable(gl.GL_BLEND)
    assert_equal(gl.glIsEnabled(gl.GL_BLEND), False)
    assert_equal(gl.glGetParameter(gl.GL_BLEND), 0)
    
    gl.check_error()


def _test_setting_stuff():
    # Set stuff to touch functions
    
    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    #
    gl.glBlendColor(1.0, 1.0, 1.0, 1.0)
    gl.glBlendEquation(gl.GL_FUNC_ADD)
    gl.glBlendEquationSeparate(gl.GL_FUNC_ADD, gl.GL_FUNC_ADD)
    gl.glBlendFunc(gl.GL_ONE, gl.GL_ZERO)
    gl.glBlendFuncSeparate(gl.GL_ONE, gl.GL_ZERO, gl.GL_ONE, gl.GL_ZERO)
    #
    gl.glClearColor(0.0, 0.0, 0.0, 1.0)
    gl.glClearDepth(1)
    gl.glClearStencil(0)
    #
    gl.glColorMask(True, True, True, True)
    gl.glDepthMask(False)
    gl.glStencilMask(255)
    gl.glStencilMaskSeparate(gl.GL_FRONT, 128)
    #
    gl.glStencilFunc(gl.GL_ALWAYS, 0, 255)
    gl.glStencilFuncSeparate(gl.GL_FRONT, gl.GL_ALWAYS, 0, 255)
    gl.glStencilOp(gl.GL_KEEP, gl.GL_KEEP, gl.GL_KEEP)
    gl.glStencilOpSeparate(gl.GL_FRONT, gl.GL_KEEP, gl.GL_KEEP, gl.GL_KEEP)
    #
    gl.glFrontFace(gl.GL_CW)
    gl.glHint(gl.GL_GENERATE_MIPMAP_HINT, gl.GL_FASTEST)
    gl.glLineWidth(2.0)
    gl.glPolygonOffset(0.0, 0.0)
    gl.glSampleCoverage(1.0, False)
    
    # And getting stuff
    try:
        range, precision = gl.glGetShaderPrecisionFormat(gl.GL_FRAGMENT_SHADER, 
                                                         gl.GL_HIGH_FLOAT)
        gl.check_error()  # Sometimes the func is there but OpenGL yields error
    except Exception:  
        pass  # accept if the function is not there ...
        # We should catch RuntimeError and GL.error.NullFunctionError,
        # but PyOpenGL may not be available.
        # On Travis this function was not there on one machine according
        # to PyOpenGL, but our desktop backend worked fine ...
        
    #
    v = gl.glGetParameter(gl.GL_VERSION)
    assert_true(isinstance(v, string_types))
    assert_true(len(v) > 0)
    
    gl.check_error()


def _test_object_creation_and_deletion():

    # Stuff that is originally glGenX
    
    # Note that if we test glIsTexture(x), we cannot assume x to be a
    # nonexisting texture; we might have created a texture in another
    # test and failed to clean it up.
    
    # Create/delete texture
    #assert_equal(gl.glIsTexture(12), False)
    handle = gl.glCreateTexture()
    gl.glBindTexture(gl.GL_TEXTURE_2D, handle)
    assert_equal(gl.glIsTexture(handle), True)
    gl.glDeleteTexture(handle)
    assert_equal(gl.glIsTexture(handle), False)

    # Create/delete buffer
    #assert_equal(gl.glIsBuffer(12), False)
    handle = gl.glCreateBuffer()
    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, handle)
    assert_equal(gl.glIsBuffer(handle), True)
    gl.glDeleteBuffer(handle)
    assert_equal(gl.glIsBuffer(handle), False)

    # Create/delete framebuffer
    #assert_equal(gl.glIsFramebuffer(12), False)
    handle = gl.glCreateFramebuffer()
    gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, handle)
    assert_equal(gl.glIsFramebuffer(handle), True)
    gl.glDeleteFramebuffer(handle)
    assert_equal(gl.glIsFramebuffer(handle), False)

    # Create/delete renderbuffer
    #assert_equal(gl.glIsRenderbuffer(12), False)
    handle = gl.glCreateRenderbuffer()
    gl.glBindRenderbuffer(gl.GL_RENDERBUFFER, handle)
    assert_equal(gl.glIsRenderbuffer(handle), True)
    gl.glDeleteRenderbuffer(handle)
    assert_equal(gl.glIsRenderbuffer(handle), False)

    # Stuff that is originally called glCreate

    # Create/delete program
    #assert_equal(gl.glIsProgram(12), False)
    handle = gl.glCreateProgram()
    assert_equal(gl.glIsProgram(handle), True)
    gl.glDeleteProgram(handle)
    assert_equal(gl.glIsProgram(handle), False)

    # Create/delete shader
    #assert_equal(gl.glIsShader(12), False)
    handle = gl.glCreateShader(gl.GL_VERTEX_SHADER)
    assert_equal(gl.glIsShader(handle), True)
    gl.glDeleteShader(handle)
    assert_equal(gl.glIsShader(handle), False)
    
    gl.check_error()


def _test_fbo():
    
    w, h = 120, 130
    
    # Create frame buffer
    hframebuf = gl.glCreateFramebuffer()
    gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, hframebuf)
    
    #Create render buffer (for depth)
    hrenderbuf = gl.glCreateRenderbuffer()
    gl.glBindRenderbuffer(gl.GL_RENDERBUFFER, hrenderbuf)
    gl.glRenderbufferStorage(gl.GL_RENDERBUFFER, gl.GL_DEPTH_COMPONENT16, w, h)
    gl.glFramebufferRenderbuffer(gl.GL_FRAMEBUFFER, gl.GL_DEPTH_ATTACHMENT,
                                 gl.GL_RENDERBUFFER, hrenderbuf)
    
    # Create texture (for color)
    htex = gl.glCreateTexture()
    gl.glBindTexture(gl.GL_TEXTURE_2D, htex)
    gl.glTexImage2D(gl.GL_TEXTURE_2D, 0, gl.GL_RGB, gl.GL_RGB, 
                    gl.GL_UNSIGNED_BYTE, (h, w))
    gl.glFramebufferTexture2D(gl.GL_FRAMEBUFFER, gl.GL_COLOR_ATTACHMENT0,
                              gl.GL_TEXTURE_2D, htex, 0)
    
    # Check framebuffer status
    status = gl.glCheckFramebufferStatus(gl.GL_FRAMEBUFFER)
    assert_equal(status, gl.GL_FRAMEBUFFER_COMPLETE)
    
    # Tests renderbuffer params
    name = gl.glGetFramebufferAttachmentParameter(
        gl.GL_FRAMEBUFFER, gl.GL_DEPTH_ATTACHMENT, 
        gl.GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME)
    assert_equal(name, hrenderbuf)
    #
    width = gl.glGetRenderbufferParameter(gl.GL_RENDERBUFFER,
                                          gl.GL_RENDERBUFFER_WIDTH)
    assert_equal(width, w)
    
    # Touch copy tex functions
    gl.glCopyTexImage2D(gl.GL_TEXTURE_2D, 0, gl.GL_RGB, 0, 0, 30, 30,  0)
    gl.glCopyTexSubImage2D(gl.GL_TEXTURE_2D, 0,  20, 20,  0, 0, 10, 10)
    
    gl.check_error()
    
    # Clean up
    gl.glDeleteTexture(htex)
    gl.glDeleteRenderbuffer(hrenderbuf)
    gl.glDeleteFramebuffer(hframebuf)
    
    gl.check_error()

########NEW FILE########
__FILENAME__ = test_functionality
""" Test to verify the functionality of the OpenGL backends. This test
sets up a real visualization with shaders and all. This tests setting
source code, setting texture and buffer data, and we touch many other
functions of the API too. The end result is an image with four colored
quads. The result is tested for pixel color.

The visualization
-----------------

We create a visualization where the screen is divided in 4 quadrants,
and each quadrant is painted a different color (black, red, green,
blue). The painting is done for 50% using attribute data, and 50%
using a texture. The end result should be fully saturated colors.

Remember: the bottom left is (-1, -1) and the first quadrant. 

"""
import sys

import numpy as np

from nose.tools import assert_equal, assert_true
from vispy.app import Canvas
from numpy.testing import assert_almost_equal  # noqa
from vispy.testing import (requires_application, requires_pyopengl, SkipTest,
                           glut_skip)

from vispy.gloo import gl

# All these tests require a working backend.


## High level tests

def teardown_module():
    gl.use()  # Reset to default


@requires_application()
def test_functionality_desktop():
    """ Test desktop GL backend for full functionality. """
    glut_skip()
    _test_functonality('desktop')


@requires_application()
def test_functionality_proxy():
    """ Test GL proxy class for full functionality. """
    # By using debug mode, we are using the proxy class
    glut_skip()
    _test_functonality('desktop debug')


@requires_application()
@requires_pyopengl()
def test_functionality_pyopengl():
    """ Test pyopengl GL backend for full functionality. """
    glut_skip()
    _test_functonality('pyopengl')


@requires_application()
def test_functionality_angle():
    """ Test angle GL backend for full functionality. """
    if True:
        raise SkipTest('Skip Angle functionality test for now.')
    if sys.platform.startswith('win'):
        raise SkipTest('Can only test angle functionality on Windows.')
    glut_skip()
    _test_functonality('angle')


def _clear_screen():
    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    gl.glFinish()


def _test_functonality(backend):
    """ Create app and canvas so we have a context. Then run tests.
    """
    # use the backend
    gl.use(backend)
    
    with Canvas() as canvas:
        _clear_screen()
        
        # Prepare
        w, h = canvas.size
        gl.glViewport(0, 0, w, h)
        gl.glScissor(0, 0, w, h)  # touch
        gl.glClearColor(0.0, 0.0, 0.0, 1.0)
        
        # Setup visualization, ensure to do it in a paint event
        objects = _prepare_vis()
        _clear_screen()
        _draw1()
        _clear_screen()
        _draw2()
        _clear_screen()
        _draw3()

        # Clean up
        for delete_func, handle in objects:
            delete_func(handle)
        gl.glFinish()


## Create CPU data

# Create vertex and fragments shader. They are designed to that all
# OpenGL func can be tested, i.e. all types of uniforms are present.
# Most variables are nullified however, but we must make sure we do this
# in a way that the compiler won't optimize out :)
VERT = """
attribute float a_1;
attribute vec2 a_2;
attribute vec3 a_3;
attribute vec4 a_4;

uniform float u_f1;
uniform vec2 u_f2;
uniform vec3 u_f3;
uniform vec4 u_f4;

uniform int u_i1;
uniform ivec2 u_i2;
uniform ivec3 u_i3;
uniform ivec4 u_i4;

uniform mat2 u_m2;
uniform mat3 u_m3;
uniform mat4 u_m4;

varying vec2 v_2;  // tex coords
varying vec4 v_4;  // attr colors

void main()
{   
    float zero = float(u_i1);
    
    // Combine int with float uniforms (i.e. ints are "used")
    float u1 = u_f1 + float(u_i1);
    vec2 u2 = u_f2 + vec2(u_i2);
    vec3 u3 = u_f3 + vec3(u_i3);
    vec4 u4 = u_f4 + vec4(u_i4);
    
    // Set varyings (use every 2D and 4D variable, and u1)
    v_2 = a_1 * a_2 + zero*u_m2 * a_2 * u2 * u1;
    v_4 = u_m4 * a_4 * u4;
    
    // Set position (use 3D variables)
    gl_Position = vec4(u_m3* a_3* u3, 1.0);
}
"""

FRAG = """

uniform sampler2D s_1;
uniform int u_i1;
varying vec2 v_2;  // rex coords
varying vec4 v_4;  // attr colors

void main()
{   
    float zero = float(u_i1);
    gl_FragColor = (texture2D(s_1, v_2) + v_4);
}
"""

# Color texture
texquad = 5
im1 = np.zeros((texquad*2, texquad*2, 3), np.uint8)
im1[texquad:, :texquad, 0] = 128
im1[texquad:, texquad:, 1] = 128
im1[:texquad, texquad:, 2] = 128

# Grayscale texture (uploaded but not used)
im2 = im1[:, :, 0]  # A non-contiguous view
assert im2.flags['C_CONTIGUOUS'] is False

# Vertex Buffers

# Create coordinates for upper left quad
quad = np.array([[0, 0, 0], [-1, 0, 0], [-1, -1, 0], 
                 [0, 0, 0], [-1, -1, 0], [0, -1, 0]], np.float32)
N = quad.shape[0] * 4

# buf3 contains coordinates in device coordinates for four quadrants
buf3 = np.row_stack([quad + (0, 0, 0), quad + (0, 1, 0),
                     quad + (1, 1, 0), quad + (1, 0, 0)]).astype(np.float32)

# buf2 is texture coords. Note that this is a view on buf2
buf2 = ((buf3+1.0)*0.5)[:, :2]   # not C-contiguous
assert buf2.flags['C_CONTIGUOUS'] is False

# Array of colors
buf4 = np.zeros((N, 5), np.float32)
buf4[6:12, 0] = 0.5
buf4[12:18, 1] = 0.5
buf4[18:24, 2] = 0.5
buf4[:, 3] = 1.0  # alpha
buf4 = buf4[:, :4]  # make non-contiguous

# Element buffer
# elements = np.arange(N, dtype=np.uint8)  # C-contiguous
elements = np.arange(0, N, 0.5).astype(np.uint8)[::2]  # not C-contiguous
helements = None  # the OpenGL object ref


## The GL calls


def _prepare_vis():
    
    objects = []
    
    # --- program and shaders
    
    # Create program and shaders
    hprog = gl.glCreateProgram()
    hvert = gl.glCreateShader(gl.GL_VERTEX_SHADER)
    hfrag = gl.glCreateShader(gl.GL_FRAGMENT_SHADER)
    objects.append((gl.glDeleteProgram, hprog))
    objects.append((gl.glDeleteShader, hvert))
    objects.append((gl.glDeleteShader, hfrag))
    
    # Compile source code
    gl.glShaderSource_compat(hvert, VERT)
    gl.glShaderSource_compat(hfrag, FRAG)
    gl.glCompileShader(hvert)
    gl.glCompileShader(hfrag)
    
    # Check
    assert_equal(gl.glGetShaderInfoLog(hvert), '')
    assert_equal(gl.glGetShaderInfoLog(hfrag), '')
    assert_equal(gl.glGetShaderParameter(hvert, gl.GL_COMPILE_STATUS), 1)
    assert_equal(gl.glGetShaderParameter(hfrag, gl.GL_COMPILE_STATUS), 1)
    
    # Attach and link
    gl.glAttachShader(hprog, hvert)
    gl.glAttachShader(hprog, hfrag)
    # touch glDetachShader
    gl.glDetachShader(hprog, hvert)
    gl.glAttachShader(hprog, hvert)
    gl.glLinkProgram(hprog)
    
    # Test that indeed these shaders are attached
    attached_shaders = gl.glGetAttachedShaders(hprog)
    assert_equal(set(attached_shaders), set([hvert, hfrag]))
    
    # Check
    assert_equal(gl.glGetProgramInfoLog(hprog), '')
    assert_equal(gl.glGetProgramParameter(hprog, gl.GL_LINK_STATUS), 1)
    gl.glValidateProgram(hprog)
    assert_equal(gl.glGetProgramParameter(hprog, gl.GL_VALIDATE_STATUS), 1)
    
    # Use it!
    gl.glUseProgram(hprog)
    
    # Bind one attribute
    gl.glBindAttribLocation(hprog, 1, 'a_2')
    
    # Check if all is ok
    assert_equal(gl.glGetError(), 0)
    
    # Check source
    vert_source = gl.glGetShaderSource(hvert)
    assert_true('attribute vec2 a_2;' in vert_source)
    
    # --- get information on attributes and uniforms
    
    # Count attribbutes and uniforms
    natt = gl.glGetProgramParameter(hprog, gl.GL_ACTIVE_ATTRIBUTES)
    nuni = gl.glGetProgramParameter(hprog, gl.GL_ACTIVE_UNIFORMS)
    assert_equal(natt, 4)
    assert_equal(nuni, 4+4+3+1)
    
    # Get names
    names = {}
    for i in range(natt):
        name, count, type = gl.glGetActiveAttrib(hprog, i)
        names[name] = type
        assert_equal(count, 1)
    for i in range(nuni):
        name, count, type = gl.glGetActiveUniform(hprog, i)
        names[name] = type
        assert_equal(count, 1)
    
    # Check
    assert_equal(names['a_1'], gl.GL_FLOAT)
    assert_equal(names['a_2'], gl.GL_FLOAT_VEC2)
    assert_equal(names['a_3'], gl.GL_FLOAT_VEC3)
    assert_equal(names['a_4'], gl.GL_FLOAT_VEC4)
    assert_equal(names['s_1'], gl.GL_SAMPLER_2D)
    #
    for i, type in enumerate([gl.GL_FLOAT, gl.GL_FLOAT_VEC2, 
                              gl.GL_FLOAT_VEC3, gl.GL_FLOAT_VEC4]):
        assert_equal(names['u_f%i' % (i+1)], type)
    for i, type in enumerate([gl.GL_INT, gl.GL_INT_VEC2, 
                              gl.GL_INT_VEC3, gl.GL_INT_VEC4]):
        assert_equal(names['u_i%i' % (i+1)], type)
    for i, type in enumerate([gl.GL_FLOAT_MAT2, gl.GL_FLOAT_MAT3, 
                              gl.GL_FLOAT_MAT4]):
        assert_equal(names['u_m%i' % (i+2)], type)
    
    # Check if all is ok
    assert_equal(gl.glGetError(), 0)
    
    # --- texture
    
    # Create, bind, activate
    htex = gl.glCreateTexture()
    objects.append((gl.glDeleteTexture, htex))
    gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 1)
    gl.glBindTexture(gl.GL_TEXTURE_2D, htex)
    
    # Allocate data and upload
    # This data is luminance and not C-contiguous
    gl.glTexImage2D(gl.GL_TEXTURE_2D, 0, gl.GL_LUMINANCE, gl.GL_LUMINANCE, 
                    gl.GL_UNSIGNED_BYTE, im2)  # touch
    gl.glTexImage2D(gl.GL_TEXTURE_2D, 0, gl.GL_LUMINANCE, gl.GL_LUMINANCE, 
                    gl.GL_UNSIGNED_BYTE, im2.shape[:2])
    gl.glTexSubImage2D(gl.GL_TEXTURE_2D, 0, 0, 0, gl.GL_LUMINANCE,
                       gl.GL_UNSIGNED_BYTE, im2)
    
    # Set texture parameters (use f and i to touch both)
    T = gl.GL_TEXTURE_2D
    gl.glTexParameterf(T, gl.GL_TEXTURE_MIN_FILTER, gl.GL_LINEAR)
    gl.glTexParameteri(T, gl.GL_TEXTURE_MAG_FILTER, gl.GL_LINEAR)
    
    # Re-allocate data and upload 
    gl.glTexImage2D(gl.GL_TEXTURE_2D, 0, gl.GL_RGB, gl.GL_RGB, 
                    gl.GL_UNSIGNED_BYTE, im1.shape[:2])
    gl.glTexSubImage2D(gl.GL_TEXTURE_2D, 0, 0, 0, gl.GL_RGB,
                       gl.GL_UNSIGNED_BYTE, im1)
    
    # Attach!
    loc = gl.glGetUniformLocation(hprog, 's_1')
    unit = 0
    gl.glActiveTexture(gl.GL_TEXTURE0+unit)
    gl.glUniform1i(loc, unit) 
    
    # Mipmaps (just to touch this function)
    gl.glGenerateMipmap(gl.GL_TEXTURE_2D)
    
    # Check min filter (touch getTextParameter)
    minfilt = gl.glGetTexParameter(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER)
    assert_equal(minfilt, gl.GL_LINEAR)
    
    # Check if all is ok
    assert_equal(gl.glGetError(), 0)
    
    # --- buffer vec2 (contiguous VBO)
    
    # Create buffer
    hbuf2 = gl.glCreateBuffer()
    objects.append((gl.glDeleteBuffer, hbuf2))
    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, hbuf2)

    # Allocate and set data
    gl.glBufferData(gl.GL_ARRAY_BUFFER, buf2.nbytes, gl.GL_DYNAMIC_DRAW)
    gl.glBufferSubData(gl.GL_ARRAY_BUFFER, 0, buf2)
    
    # Attach!
    loc = gl.glGetAttribLocation(hprog, 'a_2')
    gl.glDisableVertexAttribArray(loc)  # touch
    gl.glEnableVertexAttribArray(loc)
    gl.glVertexAttribPointer(loc, 2, gl.GL_FLOAT, False, 2*4, 0)
    
    # Check (touch glGetBufferParameter, glGetVertexAttrib and
    # glGetVertexAttribOffset)
    size = gl.glGetBufferParameter(gl.GL_ARRAY_BUFFER, gl.GL_BUFFER_SIZE)
    assert_equal(size, buf2.nbytes)
    stride = gl.glGetVertexAttrib(loc, gl.GL_VERTEX_ATTRIB_ARRAY_STRIDE)
    assert_equal(stride, 2*4)
    offset = gl.glGetVertexAttribOffset(loc, gl.GL_VERTEX_ATTRIB_ARRAY_POINTER)
    assert_equal(offset, 0)
    
    # Check if all is ok
    assert_equal(gl.glGetError(), 0)
    
    # --- buffer vec3 (non-contiguous VBO)
    
    # Create buffer
    hbuf3 = gl.glCreateBuffer()
    objects.append((gl.glDeleteBuffer, hbuf3))
    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, hbuf3)

    # Allocate and set data
    gl.glBufferData(gl.GL_ARRAY_BUFFER, buf3.nbytes, gl.GL_DYNAMIC_DRAW)
    gl.glBufferSubData(gl.GL_ARRAY_BUFFER, 0, buf3)
    
    # Attach!
    loc = gl.glGetAttribLocation(hprog, 'a_3')
    gl.glEnableVertexAttribArray(loc)
    gl.glVertexAttribPointer(loc, 3, gl.GL_FLOAT, False, 3*4, 0)
    
    # Check if all is ok
    assert_equal(gl.glGetError(), 0)
    
    # --- buffer vec4 (client vertex data)
    
    # Select no FBO
    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
    
    # Attach!
    loc = gl.glGetAttribLocation(hprog, 'a_4')
    gl.glEnableVertexAttribArray(loc)
    gl.glVertexAttribPointer(loc, 4, gl.GL_FLOAT, False, 4*4, buf4)
    
    # Check if all is ok
    assert_equal(gl.glGetError(), 0)
    
    # --- element buffer
    
    # Create buffer
    global helements
    helements = gl.glCreateBuffer()
    objects.append((gl.glDeleteBuffer, helements))
    gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, helements)

    # Allocate and set data
    gl.glBufferData(gl.GL_ELEMENT_ARRAY_BUFFER, elements, gl.GL_DYNAMIC_DRAW)
    gl.glBufferSubData(gl.GL_ELEMENT_ARRAY_BUFFER, 0, elements)
    
    # Turn off
    gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, 0)
    
    # Check if all is ok
    assert_equal(gl.glGetError(), 0)
    
    # --- uniforms
    
    # Set integer uniforms to 0
    # We set them twice just to touch both i and iv functions
    for i, fun1, fun2 in [(1, gl.glUniform1i, gl.glUniform1iv),
                          (2, gl.glUniform2i, gl.glUniform2iv),
                          (3, gl.glUniform3i, gl.glUniform3iv),
                          (4, gl.glUniform4i, gl.glUniform4iv)]:
        name = 'u_i%i' % i
        value = [0] * i
        loc = gl.glGetUniformLocation(hprog, name)
        fun1(loc, *value)  # e.g. glUniform4i
        fun2(loc, 1, value)  # e.g. glUniform4iv

    # Set float uniforms to 1.0
    # We set them twice just to touch both i and iv functions
    for i, fun1, fun2 in [(1, gl.glUniform1f, gl.glUniform1fv),
                          (2, gl.glUniform2f, gl.glUniform2fv),
                          (3, gl.glUniform3f, gl.glUniform3fv),
                          (4, gl.glUniform4f, gl.glUniform4fv)]:
        name = 'u_f%i' % i
        value = [1.0] * i
        loc = gl.glGetUniformLocation(hprog, name)
        fun1(loc, *value)  # e.g. glUniform4f
        fun2(loc, 1, value)  # e.g. glUniform4fv
    
    # Set matrix uniforms
    m = np.eye(5, dtype='float32')
    loc = gl.glGetUniformLocation(hprog, 'u_m2')
    gl.glUniformMatrix2fv(loc, 1, False, m[:2, :2])
    #
    loc = gl.glGetUniformLocation(hprog, 'u_m3')
    m = np.eye(3, dtype='float32')
    gl.glUniformMatrix3fv(loc, 1, False, m[:3, :3])
    #
    loc = gl.glGetUniformLocation(hprog, 'u_m4')
    m = np.eye(4, dtype='float32')
    gl.glUniformMatrix4fv(loc, 1, False, m[:4, :4])
    
    # Check some uniforms
    loc = gl.glGetUniformLocation(hprog, 'u_i1')
    assert_equal(gl.glGetUniform(hprog, loc), 0)
    loc = gl.glGetUniformLocation(hprog, 'u_i2')
    assert_equal(gl.glGetUniform(hprog, loc), (0, 0))
    loc = gl.glGetUniformLocation(hprog, 'u_f2')
    assert_equal(gl.glGetUniform(hprog, loc), (1.0, 1.0))
    
    # Check if all is ok
    assert_equal(gl.glGetError(), 0)
    
    # --- attributes 
    
    # Constant values for attributes. We do not even use this ...
    loc = gl.glGetAttribLocation(hprog, 'a_1')
    gl.glVertexAttrib1f(loc, 1.0)
    loc = gl.glGetAttribLocation(hprog, 'a_2')
    gl.glVertexAttrib2f(loc, 1.0, 1.0)
    loc = gl.glGetAttribLocation(hprog, 'a_3')
    gl.glVertexAttrib3f(loc, 1.0, 1.0, 1.0)
    loc = gl.glGetAttribLocation(hprog, 'a_4')
    gl.glVertexAttrib4f(loc, 1.0, 1.0, 1.0, 1.0)
    
    # --- flush and finish
    
    # Not really necessary, but we want to touch the functions
    gl.glFlush()
    gl.glFinish()
    
    #print([i[1] for i in objects])
    return objects


def _draw1():
    # Draw using arrays
    gl.glDrawArrays(gl.GL_TRIANGLES, 0, N)
    gl.glFinish()
    _check_result()


def _draw2():
    # Draw using elements via buffer
    gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, helements)
    gl.glDrawElements(gl.GL_TRIANGLES, elements.size, gl.GL_UNSIGNED_BYTE, 0)
    gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, 0)
    gl.glFinish()
    _check_result()


def _draw3():
    # Draw using elements via numpy array
    gl.glDrawElements(gl.GL_TRIANGLES, 
                      elements.size, gl.GL_UNSIGNED_BYTE, elements)
    gl.glFinish()
    _check_result()


def _check_result(assert_result=True):
    """ Test the color of each quadrant by picking the center pixel 
    of each quadrant and comparing it with the reference color.
    """
    
    # Take screenshot
    x, y, w, h = gl.glGetParameter(gl.GL_VIEWPORT)
    data = gl.glReadPixels(x, y, w, h, gl.GL_RGB, gl.GL_UNSIGNED_BYTE)
    im = np.frombuffer(data, np.uint8)
    im.shape = h, w, 3
    
    # Get center pixel from each quadrant
    pix1 = tuple(im[int(1*h/4), int(1*w/4)])
    pix2 = tuple(im[int(3*h/4), int(1*w/4)])
    pix3 = tuple(im[int(3*h/4), int(3*w/4)])
    pix4 = tuple(im[int(1*h/4), int(3*w/4)])
    #print(pix1, pix2, pix3, pix4)
   
    if assert_result:
        # Test their value
        assert_equal(pix1, (0, 0, 0))
        assert_equal(pix2, (255, 0, 0))
        assert_equal(pix3, (0, 255, 0))
        assert_equal(pix4, (0, 0, 255))


if __name__ == '__main__':
    test_functionality_desktop()
    test_functionality_pyopengl()
    test_functionality_proxy()

########NEW FILE########
__FILENAME__ = test_names
""" Tests to verify that all ES 2.0 function names are defined in all
backends, and no more than that.
"""

from nose.tools import assert_equal
from vispy.testing import requires_pyopengl

from vispy.gloo import gl


class _DummyObject:
    """ To be able to import angle even in Linux, so that we can test the
    names defined inside.
    """
    def LoadLibrary(self, fname):
        return _DummyObject()

    def __getattr__(self, name):
        setattr(self, name, self.__class__())
        return getattr(self, name)


def _test_function_names(mod):
    fnames = set([name for name in dir(mod) if name.startswith('gl')])
    assert_equal(function_names.difference(fnames), set())
    assert_equal(fnames.difference(function_names), set())


def _test_contant_names(mod):
    cnames = set([name for name in dir(mod) if name.startswith('GL')])
    assert_equal(constant_names.difference(cnames), set())
    assert_equal(cnames.difference(constant_names), set())


def test_destop():
    """ Desktop backend should have all ES 2.0 names. No more, no less. """
    from vispy.gloo.gl import desktop
    _test_function_names(desktop)
    _test_contant_names(desktop)


def test_angle():
    """ Angle backend should have all ES 2.0 names. No more, no less. """
    # Import. Install a dummy lib so that at least we can import angle.
    try:
        from vispy.gloo.gl import angle  # noqa
    except Exception:
        import ctypes
        ctypes.windll = _DummyObject()
    from vispy.gloo.gl import angle  # noqa

    # Test
    _test_function_names(angle)
    _test_contant_names(angle)


@requires_pyopengl()
def test_pyopengl():
    """ Pyopengl backend should have all ES 2.0 names. No more, no less. """
    from vispy.gloo.gl import pyopengl
    _test_function_names(pyopengl)
    _test_contant_names(pyopengl)


def test_proxy():
    """ GLProxy class should have all ES 2.0 names. No more, no less. """
    _test_function_names(gl.proxy)
    _test_contant_names(gl._constants)


def test_main():
    """ Main gl namespace should have all ES 2.0 names. No more, no less. """
    _test_function_names(gl)
    _test_contant_names(gl)


def test_webgl():
    """ Webgl backend should have all ES 2.0 names. No more, no less. """
    from vispy.gloo.gl import webgl
    _test_function_names(webgl)
    _test_contant_names(webgl)


def _main():
    """ For testing this test suite :)
    """
    test_main()
    test_proxy()
    test_destop()
    test_angle()
    test_pyopengl()
    test_webgl()


# Note: I took these names below from _main and _constants, which is a
# possible cause for error.

function_names = """
glActiveTexture glAttachShader glBindAttribLocation glBindBuffer
glBindFramebuffer glBindRenderbuffer glBindTexture glBlendColor
glBlendEquation glBlendEquationSeparate glBlendFunc glBlendFuncSeparate
glBufferData glBufferSubData glCheckFramebufferStatus glClear
glClearColor glClearDepth glClearStencil glColorMask glCompileShader
glCompressedTexImage2D glCompressedTexSubImage2D glCopyTexImage2D
glCopyTexSubImage2D glCreateBuffer glCreateFramebuffer glCreateProgram
glCreateRenderbuffer glCreateShader glCreateTexture glCullFace
glDeleteBuffer glDeleteFramebuffer glDeleteProgram glDeleteRenderbuffer
glDeleteShader glDeleteTexture glDepthFunc glDepthMask glDepthRange
glDetachShader glDisable glDisableVertexAttribArray glDrawArrays
glDrawElements glEnable glEnableVertexAttribArray glFinish glFlush
glFramebufferRenderbuffer glFramebufferTexture2D glFrontFace
glGenerateMipmap glGetActiveAttrib glGetActiveUniform
glGetAttachedShaders glGetAttribLocation glGetBufferParameter glGetError
glGetFramebufferAttachmentParameter glGetParameter glGetProgramInfoLog
glGetProgramParameter glGetRenderbufferParameter glGetShaderInfoLog
glGetShaderParameter glGetShaderPrecisionFormat glGetShaderSource
glGetTexParameter glGetUniform glGetUniformLocation glGetVertexAttrib
glGetVertexAttribOffset glHint glIsBuffer glIsEnabled glIsFramebuffer
glIsProgram glIsRenderbuffer glIsShader glIsTexture glLineWidth
glLinkProgram glPixelStorei glPolygonOffset glReadPixels
glRenderbufferStorage glSampleCoverage glScissor glShaderSource
glShaderSource_compat glStencilFunc glStencilFuncSeparate glStencilMask
glStencilMaskSeparate glStencilOp glStencilOpSeparate glTexImage2D
glTexParameterf glTexParameteri glTexSubImage2D glUniform1f glUniform1fv
glUniform1i glUniform1iv glUniform2f glUniform2fv glUniform2i
glUniform2iv glUniform3f glUniform3fv glUniform3i glUniform3iv
glUniform4f glUniform4fv glUniform4i glUniform4iv glUniformMatrix2fv
glUniformMatrix3fv glUniformMatrix4fv glUseProgram glValidateProgram
glVertexAttrib1f glVertexAttrib2f glVertexAttrib3f glVertexAttrib4f
glVertexAttribPointer glViewport
""".replace('\n', ' ')

constant_names = """
GL_ACTIVE_ATTRIBUTES GL_ACTIVE_ATTRIBUTE_MAX_LENGTH GL_ACTIVE_TEXTURE
GL_ACTIVE_UNIFORMS GL_ACTIVE_UNIFORM_MAX_LENGTH
GL_ALIASED_LINE_WIDTH_RANGE GL_ALIASED_POINT_SIZE_RANGE GL_ALPHA
GL_ALPHA_BITS GL_ALWAYS GL_ARRAY_BUFFER GL_ARRAY_BUFFER_BINDING
GL_ATTACHED_SHADERS GL_BACK GL_BLEND GL_BLEND_COLOR GL_BLEND_DST_ALPHA
GL_BLEND_DST_RGB GL_BLEND_EQUATION GL_BLEND_EQUATION_ALPHA
GL_BLEND_EQUATION_RGB GL_BLEND_SRC_ALPHA GL_BLEND_SRC_RGB GL_BLUE_BITS
GL_BOOL GL_BOOL_VEC2 GL_BOOL_VEC3 GL_BOOL_VEC4 GL_BUFFER_SIZE
GL_BUFFER_USAGE GL_BYTE GL_CCW GL_CLAMP_TO_EDGE GL_COLOR_ATTACHMENT0
GL_COLOR_BUFFER_BIT GL_COLOR_CLEAR_VALUE GL_COLOR_WRITEMASK
GL_COMPILE_STATUS GL_COMPRESSED_TEXTURE_FORMATS GL_CONSTANT_ALPHA
GL_CONSTANT_COLOR GL_CULL_FACE GL_CULL_FACE_MODE GL_CURRENT_PROGRAM
GL_CURRENT_VERTEX_ATTRIB GL_CW GL_DECR GL_DECR_WRAP GL_DELETE_STATUS
GL_DEPTH_ATTACHMENT GL_DEPTH_BITS GL_DEPTH_BUFFER_BIT
GL_DEPTH_CLEAR_VALUE GL_DEPTH_COMPONENT GL_DEPTH_COMPONENT16
GL_DEPTH_FUNC GL_DEPTH_RANGE GL_DEPTH_TEST GL_DEPTH_WRITEMASK GL_DITHER
GL_DONT_CARE GL_DST_ALPHA GL_DST_COLOR GL_DYNAMIC_DRAW
GL_ELEMENT_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER_BINDING GL_EQUAL
GL_ES_VERSION_2_0 GL_EXTENSIONS GL_FALSE GL_FASTEST GL_FIXED GL_FLOAT
GL_FLOAT_MAT2 GL_FLOAT_MAT3 GL_FLOAT_MAT4 GL_FLOAT_VEC2 GL_FLOAT_VEC3
GL_FLOAT_VEC4 GL_FRAGMENT_SHADER GL_FRAMEBUFFER
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL GL_FRAMEBUFFER_BINDING
GL_FRAMEBUFFER_COMPLETE GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT GL_FRAMEBUFFER_UNSUPPORTED
GL_FRONT GL_FRONT_AND_BACK GL_FRONT_FACE GL_FUNC_ADD
GL_FUNC_REVERSE_SUBTRACT GL_FUNC_SUBTRACT GL_GENERATE_MIPMAP_HINT
GL_GEQUAL GL_GREATER GL_GREEN_BITS GL_HIGH_FLOAT GL_HIGH_INT
GL_IMPLEMENTATION_COLOR_READ_FORMAT GL_IMPLEMENTATION_COLOR_READ_TYPE
GL_INCR GL_INCR_WRAP GL_INFO_LOG_LENGTH GL_INT GL_INT_VEC2 GL_INT_VEC3
GL_INT_VEC4 GL_INVALID_ENUM GL_INVALID_FRAMEBUFFER_OPERATION
GL_INVALID_OPERATION GL_INVALID_VALUE GL_INVERT GL_KEEP GL_LEQUAL
GL_LESS GL_LINEAR GL_LINEAR_MIPMAP_LINEAR GL_LINEAR_MIPMAP_NEAREST
GL_LINES GL_LINE_LOOP GL_LINE_STRIP GL_LINE_WIDTH GL_LINK_STATUS
GL_LOW_FLOAT GL_LOW_INT GL_LUMINANCE GL_LUMINANCE_ALPHA
GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS GL_MAX_CUBE_MAP_TEXTURE_SIZE
GL_MAX_FRAGMENT_UNIFORM_VECTORS GL_MAX_RENDERBUFFER_SIZE
GL_MAX_TEXTURE_IMAGE_UNITS GL_MAX_TEXTURE_SIZE GL_MAX_VARYING_VECTORS
GL_MAX_VERTEX_ATTRIBS GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
GL_MAX_VERTEX_UNIFORM_VECTORS GL_MAX_VIEWPORT_DIMS GL_MEDIUM_FLOAT
GL_MEDIUM_INT GL_MIRRORED_REPEAT GL_NEAREST GL_NEAREST_MIPMAP_LINEAR
GL_NEAREST_MIPMAP_NEAREST GL_NEVER GL_NICEST GL_NONE GL_NOTEQUAL
GL_NO_ERROR GL_NUM_COMPRESSED_TEXTURE_FORMATS
GL_NUM_SHADER_BINARY_FORMATS GL_ONE GL_ONE_MINUS_CONSTANT_ALPHA
GL_ONE_MINUS_CONSTANT_COLOR GL_ONE_MINUS_DST_ALPHA
GL_ONE_MINUS_DST_COLOR GL_ONE_MINUS_SRC_ALPHA GL_ONE_MINUS_SRC_COLOR
GL_OUT_OF_MEMORY GL_PACK_ALIGNMENT GL_POINTS GL_POLYGON_OFFSET_FACTOR
GL_POLYGON_OFFSET_FILL GL_POLYGON_OFFSET_UNITS GL_RED_BITS
GL_RENDERBUFFER GL_RENDERBUFFER_ALPHA_SIZE GL_RENDERBUFFER_BINDING
GL_RENDERBUFFER_BLUE_SIZE GL_RENDERBUFFER_DEPTH_SIZE
GL_RENDERBUFFER_GREEN_SIZE GL_RENDERBUFFER_HEIGHT
GL_RENDERBUFFER_INTERNAL_FORMAT GL_RENDERBUFFER_RED_SIZE
GL_RENDERBUFFER_STENCIL_SIZE GL_RENDERBUFFER_WIDTH GL_RENDERER GL_REPEAT
GL_REPLACE GL_RGB GL_RGB565 GL_RGB5_A1 GL_RGBA GL_RGBA4 GL_SAMPLER_2D
GL_SAMPLER_CUBE GL_SAMPLES GL_SAMPLE_ALPHA_TO_COVERAGE GL_SAMPLE_BUFFERS
GL_SAMPLE_COVERAGE GL_SAMPLE_COVERAGE_INVERT GL_SAMPLE_COVERAGE_VALUE
GL_SCISSOR_BOX GL_SCISSOR_TEST GL_SHADER_BINARY_FORMATS
GL_SHADER_COMPILER GL_SHADER_SOURCE_LENGTH GL_SHADER_TYPE
GL_SHADING_LANGUAGE_VERSION GL_SHORT GL_SRC_ALPHA GL_SRC_ALPHA_SATURATE
GL_SRC_COLOR GL_STATIC_DRAW GL_STENCIL_ATTACHMENT GL_STENCIL_BACK_FAIL
GL_STENCIL_BACK_FUNC GL_STENCIL_BACK_PASS_DEPTH_FAIL
GL_STENCIL_BACK_PASS_DEPTH_PASS GL_STENCIL_BACK_REF
GL_STENCIL_BACK_VALUE_MASK GL_STENCIL_BACK_WRITEMASK GL_STENCIL_BITS
GL_STENCIL_BUFFER_BIT GL_STENCIL_CLEAR_VALUE GL_STENCIL_FAIL
GL_STENCIL_FUNC GL_STENCIL_INDEX8 GL_STENCIL_PASS_DEPTH_FAIL
GL_STENCIL_PASS_DEPTH_PASS GL_STENCIL_REF GL_STENCIL_TEST
GL_STENCIL_VALUE_MASK GL_STENCIL_WRITEMASK GL_STREAM_DRAW
GL_SUBPIXEL_BITS GL_TEXTURE GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE10
GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15
GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE2
GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24
GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29
GL_TEXTURE3 GL_TEXTURE30 GL_TEXTURE31 GL_TEXTURE4 GL_TEXTURE5
GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE_2D
GL_TEXTURE_BINDING_2D GL_TEXTURE_BINDING_CUBE_MAP GL_TEXTURE_CUBE_MAP
GL_TEXTURE_CUBE_MAP_NEGATIVE_X GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z GL_TEXTURE_CUBE_MAP_POSITIVE_X
GL_TEXTURE_CUBE_MAP_POSITIVE_Y GL_TEXTURE_CUBE_MAP_POSITIVE_Z
GL_TEXTURE_MAG_FILTER GL_TEXTURE_MIN_FILTER GL_TEXTURE_WRAP_S
GL_TEXTURE_WRAP_T GL_TRIANGLES GL_TRIANGLE_FAN GL_TRIANGLE_STRIP GL_TRUE
GL_UNPACK_ALIGNMENT GL_UNSIGNED_BYTE GL_UNSIGNED_INT GL_UNSIGNED_SHORT
GL_UNSIGNED_SHORT_4_4_4_4 GL_UNSIGNED_SHORT_5_5_5_1
GL_UNSIGNED_SHORT_5_6_5 GL_VALIDATE_STATUS GL_VENDOR GL_VERSION
GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING GL_VERTEX_ATTRIB_ARRAY_ENABLED
GL_VERTEX_ATTRIB_ARRAY_NORMALIZED GL_VERTEX_ATTRIB_ARRAY_POINTER
GL_VERTEX_ATTRIB_ARRAY_SIZE GL_VERTEX_ATTRIB_ARRAY_STRIDE
GL_VERTEX_ATTRIB_ARRAY_TYPE GL_VERTEX_SHADER GL_VIEWPORT GL_ZERO
""".replace('\n', ' ')

function_names = [n.strip() for n in function_names.split(' ')]
function_names = set([n for n in function_names if n])
constant_names = [n.strip() for n in constant_names.split(' ')]
constant_names = set([n for n in constant_names if n])

if __name__ == '__main__':
    _main()

########NEW FILE########
__FILENAME__ = test_use
""" Test the use function.
"""

from vispy.testing import assert_is, requires_pyopengl

from vispy.gloo import gl


def teardown_module():
    gl.use()  # Reset to default


@requires_pyopengl()
def test_use_desktop():
    """ Testing that gl.use injects all names in gl namespace """

    # Use desktop
    gl.use('desktop')
    #
    for name in dir(gl.desktop):
        if name.lower().startswith('gl'):
            val1 = getattr(gl, name)
            val2 = getattr(gl.desktop, name)
            assert_is(val1, val2)

    # Use pyopengl
    gl.use('pyopengl')
    #
    for name in dir(gl.desktop):
        if name.lower().startswith('gl'):
            val1 = getattr(gl, name)
            val2 = getattr(gl.pyopengl, name)
            assert_is(val1, val2)
    
    # Use webgl
    gl.use('webgl')
    #
    for name in dir(gl.desktop):
        if name.lower().startswith('gl'):
            val1 = getattr(gl, name)
            val2 = getattr(gl.webgl, name)
            assert_is(val1, val2)
    
    # Touch debug wrapper stuff
    gl.use('desktop debug')
    
    # Use desktop again
    gl.use('desktop')
    #
    for name in dir(gl.desktop):
        if name.lower().startswith('gl'):
            val1 = getattr(gl, name)
            val2 = getattr(gl.desktop, name)
            assert_is(val1, val2)


if __name__ == '__main__':
    test_use_desktop()

########NEW FILE########
__FILENAME__ = webgl
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

""" GL ES 2.0 API implemented via WebGL.
"""

from . import BaseGLProxy, _copy_gl_functions
from ._constants import *  # noqa


class WebGLProxy(BaseGLProxy):
    """ Dummy proxy class for WebGL. More or less psuedo code for now :)
    But this should get whomever is going to work on WebGL a good place to
    start.
    Note that in order to use WebGL, we also need a WebGL app, probably
    also via some sort of proxy class. 
    """
    
    def __call__(self, funcname, returns, *args):
        
        self.websocket.send(funcname, *args)
        if returns:
            return self.websocket.wait_for_result()


# Instantiate proxy and inject functions
_proxy = WebGLProxy()
_copy_gl_functions(_proxy, globals())

########NEW FILE########
__FILENAME__ = _angle
"""

THIS CODE IS AUTO-GENERATED. DO NOT EDIT.

GL ES 2.0 API based on the Angle library (i.e. DirectX)

"""

import ctypes
from .angle import _lib


_lib.glActiveTexture.argtypes = ctypes.c_uint,
# void = glActiveTexture(GLenum texture)
def glActiveTexture(texture):
    _lib.glActiveTexture(texture)


_lib.glAttachShader.argtypes = ctypes.c_uint, ctypes.c_uint,
# void = glAttachShader(GLuint program, GLuint shader)
def glAttachShader(program, shader):
    _lib.glAttachShader(program, shader)


_lib.glBindAttribLocation.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_char_p,
# void = glBindAttribLocation(GLuint program, GLuint index, GLchar* name)
def glBindAttribLocation(program, index, name):
    name = ctypes.c_char_p(name.encode('utf-8'))
    res = _lib.glBindAttribLocation(program, index, name)


_lib.glBindBuffer.argtypes = ctypes.c_uint, ctypes.c_uint,
# void = glBindBuffer(GLenum target, GLuint buffer)
def glBindBuffer(target, buffer):
    _lib.glBindBuffer(target, buffer)


_lib.glBindFramebuffer.argtypes = ctypes.c_uint, ctypes.c_uint,
# void = glBindFramebuffer(GLenum target, GLuint framebuffer)
def glBindFramebuffer(target, framebuffer):
    _lib.glBindFramebuffer(target, framebuffer)


_lib.glBindRenderbuffer.argtypes = ctypes.c_uint, ctypes.c_uint,
# void = glBindRenderbuffer(GLenum target, GLuint renderbuffer)
def glBindRenderbuffer(target, renderbuffer):
    _lib.glBindRenderbuffer(target, renderbuffer)


_lib.glBindTexture.argtypes = ctypes.c_uint, ctypes.c_uint,
# void = glBindTexture(GLenum target, GLuint texture)
def glBindTexture(target, texture):
    _lib.glBindTexture(target, texture)


_lib.glBlendColor.argtypes = ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,
# void = glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
def glBlendColor(red, green, blue, alpha):
    _lib.glBlendColor(red, green, blue, alpha)


_lib.glBlendEquation.argtypes = ctypes.c_uint,
# void = glBlendEquation(GLenum mode)
def glBlendEquation(mode):
    _lib.glBlendEquation(mode)


_lib.glBlendEquationSeparate.argtypes = ctypes.c_uint, ctypes.c_uint,
# void = glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
def glBlendEquationSeparate(modeRGB, modeAlpha):
    _lib.glBlendEquationSeparate(modeRGB, modeAlpha)


_lib.glBlendFunc.argtypes = ctypes.c_uint, ctypes.c_uint,
# void = glBlendFunc(GLenum sfactor, GLenum dfactor)
def glBlendFunc(sfactor, dfactor):
    _lib.glBlendFunc(sfactor, dfactor)


_lib.glBlendFuncSeparate.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,
# void = glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
def glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha):
    _lib.glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha)


_lib.glBufferData.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_void_p, ctypes.c_uint,
# void = glBufferData(GLenum target, GLsizeiptr size, GLvoid* data, GLenum usage)
def glBufferData(target, data, usage):
    """ Data can be numpy array or the size of data to allocate.
    """
    if isinstance(data, int):
        size = data
        data = ctypes.c_voidp(0)
    else:
        if not data.flags['C_CONTIGUOUS'] or not data.flags['ALIGNED']:
            data = data.copy('C')
        data_ = data
        size = data_.nbytes
        data = data_.ctypes.data
    res = _lib.glBufferData(target, size, data, usage)


_lib.glBufferSubData.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_void_p,
# void = glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid* data)
def glBufferSubData(target, offset, data):
    if not data.flags['C_CONTIGUOUS']:
        data = data.copy('C')
    data_ = data
    size = data_.nbytes
    data = data_.ctypes.data
    res = _lib.glBufferSubData(target, offset, size, data)


_lib.glCheckFramebufferStatus.argtypes = ctypes.c_uint,
_lib.glCheckFramebufferStatus.restype = ctypes.c_uint
# GLenum = glCheckFramebufferStatus(GLenum target)
def glCheckFramebufferStatus(target):
    return _lib.glCheckFramebufferStatus(target)


_lib.glClear.argtypes = ctypes.c_uint,
# void = glClear(GLbitfield mask)
def glClear(mask):
    _lib.glClear(mask)


_lib.glClearColor.argtypes = ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,
# void = glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
def glClearColor(red, green, blue, alpha):
    _lib.glClearColor(red, green, blue, alpha)


_lib.glClearDepthf.argtypes = ctypes.c_float,
# void = glClearDepthf(GLclampf depth)
def glClearDepth(depth):
    _lib.glClearDepthf(depth)


_lib.glClearStencil.argtypes = ctypes.c_int,
# void = glClearStencil(GLint s)
def glClearStencil(s):
    _lib.glClearStencil(s)


_lib.glColorMask.argtypes = ctypes.c_bool, ctypes.c_bool, ctypes.c_bool, ctypes.c_bool,
# void = glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
def glColorMask(red, green, blue, alpha):
    _lib.glColorMask(red, green, blue, alpha)


_lib.glCompileShader.argtypes = ctypes.c_uint,
# void = glCompileShader(GLuint shader)
def glCompileShader(shader):
    _lib.glCompileShader(shader)


_lib.glCompressedTexImage2D.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_void_p,
# void = glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLvoid* data)
def glCompressedTexImage2D(target, level, internalformat, width, height, border, data):
    # border = 0  # set in args
    if not data.flags['C_CONTIGUOUS']:
        data = data.copy('C')
    data_ = data
    size = data_.size
    data = data_.ctypes.data
    res = _lib.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data)


_lib.glCompressedTexSubImage2D.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_int, ctypes.c_void_p,
# void = glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLvoid* data)
def glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data):
    if not data.flags['C_CONTIGUOUS']:
        data = data.copy('C')
    data_ = data
    size = data_.size
    data = data_.ctypes.data
    res = _lib.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data)


_lib.glCopyTexImage2D.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,
# void = glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
def glCopyTexImage2D(target, level, internalformat, x, y, width, height, border):
    _lib.glCopyTexImage2D(target, level, internalformat, x, y, width, height, border)


_lib.glCopyTexSubImage2D.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,
# void = glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
def glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height):
    _lib.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height)


_lib.glCreateProgram.argtypes = ()
_lib.glCreateProgram.restype = ctypes.c_uint
# GLuint = glCreateProgram()
def glCreateProgram():
    return _lib.glCreateProgram()


_lib.glCreateShader.argtypes = ctypes.c_uint,
_lib.glCreateShader.restype = ctypes.c_uint
# GLuint = glCreateShader(GLenum type)
def glCreateShader(type):
    return _lib.glCreateShader(type)


_lib.glCullFace.argtypes = ctypes.c_uint,
# void = glCullFace(GLenum mode)
def glCullFace(mode):
    _lib.glCullFace(mode)


_lib.glDeleteBuffers.argtypes = ctypes.c_int, ctypes.POINTER(ctypes.c_uint),
# void = glDeleteBuffers(GLsizei n, GLuint* buffers)
def glDeleteBuffer(buffer):
    n = 1
    buffers = (ctypes.c_uint*n)(buffer)
    res = _lib.glDeleteBuffers(n, buffers)


_lib.glDeleteFramebuffers.argtypes = ctypes.c_int, ctypes.POINTER(ctypes.c_uint),
# void = glDeleteFramebuffers(GLsizei n, GLuint* framebuffers)
def glDeleteFramebuffer(framebuffer):
    n = 1
    framebuffers = (ctypes.c_uint*n)(framebuffer)
    res = _lib.glDeleteFramebuffers(n, framebuffers)


_lib.glDeleteProgram.argtypes = ctypes.c_uint,
# void = glDeleteProgram(GLuint program)
def glDeleteProgram(program):
    _lib.glDeleteProgram(program)


_lib.glDeleteRenderbuffers.argtypes = ctypes.c_int, ctypes.POINTER(ctypes.c_uint),
# void = glDeleteRenderbuffers(GLsizei n, GLuint* renderbuffers)
def glDeleteRenderbuffer(renderbuffer):
    n = 1
    renderbuffers = (ctypes.c_uint*n)(renderbuffer)
    res = _lib.glDeleteRenderbuffers(n, renderbuffers)


_lib.glDeleteShader.argtypes = ctypes.c_uint,
# void = glDeleteShader(GLuint shader)
def glDeleteShader(shader):
    _lib.glDeleteShader(shader)


_lib.glDeleteTextures.argtypes = ctypes.c_int, ctypes.POINTER(ctypes.c_uint),
# void = glDeleteTextures(GLsizei n, GLuint* textures)
def glDeleteTexture(texture):
    n = 1
    textures = (ctypes.c_uint*n)(texture)
    res = _lib.glDeleteTextures(n, textures)


_lib.glDepthFunc.argtypes = ctypes.c_uint,
# void = glDepthFunc(GLenum func)
def glDepthFunc(func):
    _lib.glDepthFunc(func)


_lib.glDepthMask.argtypes = ctypes.c_bool,
# void = glDepthMask(GLboolean flag)
def glDepthMask(flag):
    _lib.glDepthMask(flag)


_lib.glDepthRangef.argtypes = ctypes.c_float, ctypes.c_float,
# void = glDepthRangef(GLclampf zNear, GLclampf zFar)
def glDepthRange(zNear, zFar):
    _lib.glDepthRangef(zNear, zFar)


_lib.glDetachShader.argtypes = ctypes.c_uint, ctypes.c_uint,
# void = glDetachShader(GLuint program, GLuint shader)
def glDetachShader(program, shader):
    _lib.glDetachShader(program, shader)


_lib.glDisable.argtypes = ctypes.c_uint,
# void = glDisable(GLenum cap)
def glDisable(cap):
    _lib.glDisable(cap)


_lib.glDisableVertexAttribArray.argtypes = ctypes.c_uint,
# void = glDisableVertexAttribArray(GLuint index)
def glDisableVertexAttribArray(index):
    _lib.glDisableVertexAttribArray(index)


_lib.glDrawArrays.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_int,
# void = glDrawArrays(GLenum mode, GLint first, GLsizei count)
def glDrawArrays(mode, first, count):
    _lib.glDrawArrays(mode, first, count)


_lib.glDrawElements.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_void_p,
# void = glDrawElements(GLenum mode, GLsizei count, GLenum type, GLvoid* indices)
def glDrawElements(mode, count, type, offset):
    if offset is None:
        offset = ctypes.c_void_p(0)
    elif isinstance(offset, ctypes.c_void_p):
        pass
    elif isinstance(offset, (int, ctypes.c_int)):
        offset = ctypes.c_void_p(int(offset))
    else:
        if not offset.flags['C_CONTIGUOUS']:
            offset = offset.copy('C')
        offset_ = offset
        offset = offset.ctypes.data
    indices = offset
    res = _lib.glDrawElements(mode, count, type, indices)


_lib.glEnable.argtypes = ctypes.c_uint,
# void = glEnable(GLenum cap)
def glEnable(cap):
    _lib.glEnable(cap)


_lib.glEnableVertexAttribArray.argtypes = ctypes.c_uint,
# void = glEnableVertexAttribArray(GLuint index)
def glEnableVertexAttribArray(index):
    _lib.glEnableVertexAttribArray(index)


_lib.glFinish.argtypes = ()
# void = glFinish()
def glFinish():
    _lib.glFinish()


_lib.glFlush.argtypes = ()
# void = glFlush()
def glFlush():
    _lib.glFlush()


_lib.glFramebufferRenderbuffer.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,
# void = glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
def glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer):
    _lib.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer)


_lib.glFramebufferTexture2D.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_int,
# void = glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
def glFramebufferTexture2D(target, attachment, textarget, texture, level):
    _lib.glFramebufferTexture2D(target, attachment, textarget, texture, level)


_lib.glFrontFace.argtypes = ctypes.c_uint,
# void = glFrontFace(GLenum mode)
def glFrontFace(mode):
    _lib.glFrontFace(mode)


_lib.glGenBuffers.argtypes = ctypes.c_int, ctypes.POINTER(ctypes.c_uint),
# void = glGenBuffers(GLsizei n, GLuint* buffers)
def glCreateBuffer():
    n = 1
    buffers = (ctypes.c_uint*n)()
    res = _lib.glGenBuffers(n, buffers)
    return buffers[0]


_lib.glGenFramebuffers.argtypes = ctypes.c_int, ctypes.POINTER(ctypes.c_uint),
# void = glGenFramebuffers(GLsizei n, GLuint* framebuffers)
def glCreateFramebuffer():
    n = 1
    framebuffers = (ctypes.c_uint*n)()
    res = _lib.glGenFramebuffers(n, framebuffers)
    return framebuffers[0]


_lib.glGenRenderbuffers.argtypes = ctypes.c_int, ctypes.POINTER(ctypes.c_uint),
# void = glGenRenderbuffers(GLsizei n, GLuint* renderbuffers)
def glCreateRenderbuffer():
    n = 1
    renderbuffers = (ctypes.c_uint*n)()
    res = _lib.glGenRenderbuffers(n, renderbuffers)
    return renderbuffers[0]


_lib.glGenTextures.argtypes = ctypes.c_int, ctypes.POINTER(ctypes.c_uint),
# void = glGenTextures(GLsizei n, GLuint* textures)
def glCreateTexture():
    n = 1
    textures = (ctypes.c_uint*n)()
    res = _lib.glGenTextures(n, textures)
    return textures[0]


_lib.glGenerateMipmap.argtypes = ctypes.c_uint,
# void = glGenerateMipmap(GLenum target)
def glGenerateMipmap(target):
    _lib.glGenerateMipmap(target)


_lib.glGetActiveAttrib.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_uint), ctypes.c_char_p,
# void = glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
def glGetActiveAttrib(program, index):
    bufsize = 256
    length = (ctypes.c_int*1)()
    size = (ctypes.c_int*1)()
    type = (ctypes.c_uint*1)()
    name = ctypes.create_string_buffer(bufsize)
    res = _lib.glGetActiveAttrib(program, index, bufsize, length, size, type, name)
    name = name[:length[0]].decode('utf-8')
    return name, size[0], type[0]


_lib.glGetActiveUniform.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_uint), ctypes.c_char_p,
# void = glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
def glGetActiveUniform(program, index):
    bufsize = 256
    length = (ctypes.c_int*1)()
    size = (ctypes.c_int*1)()
    type = (ctypes.c_uint*1)()
    name = ctypes.create_string_buffer(bufsize)
    res = _lib.glGetActiveUniform(program, index, bufsize, length, size, type, name)
    name = name[:length[0]].decode('utf-8')
    return name, size[0], type[0]


_lib.glGetAttachedShaders.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_uint),
# void = glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders)
def glGetAttachedShaders(program):
    maxcount = 256
    count = (ctypes.c_int*1)()
    shaders = (ctypes.c_uint*maxcount)()
    res = _lib.glGetAttachedShaders(program, maxcount, count, shaders)
    return tuple(shaders[:count[0]])


_lib.glGetAttribLocation.argtypes = ctypes.c_uint, ctypes.c_char_p,
_lib.glGetAttribLocation.restype = ctypes.c_int
# GLint = glGetAttribLocation(GLuint program, GLchar* name)
def glGetAttribLocation(program, name):
    name = ctypes.c_char_p(name.encode('utf-8'))
    res = _lib.glGetAttribLocation(program, name)
    return res


_lib.glGetBooleanv.argtypes = ctypes.c_uint, ctypes.POINTER(ctypes.c_bool),
# void = glGetBooleanv(GLenum pname, GLboolean* params)
def _glGetBooleanv(pname):
    params = (ctypes.c_bool*1)()
    res = _lib.glGetBooleanv(pname, params)
    return params[0]


_lib.glGetBufferParameteriv.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),
# void = glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params)
def glGetBufferParameter(target, pname):
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    res = _lib.glGetBufferParameteriv(target, pname, params)
    return params[0]


_lib.glGetError.argtypes = ()
_lib.glGetError.restype = ctypes.c_uint
# GLenum = glGetError()
def glGetError():
    return _lib.glGetError()


_lib.glGetFloatv.argtypes = ctypes.c_uint, ctypes.POINTER(ctypes.c_float),
# void = glGetFloatv(GLenum pname, GLfloat* params)
def _glGetFloatv(pname):
    n = 16
    d = float('Inf')
    params = (ctypes.c_float*n)(*[d for i in range(n)])
    res = _lib.glGetFloatv(pname, params)
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)


_lib.glGetFramebufferAttachmentParameteriv.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),
# void = glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params)
def glGetFramebufferAttachmentParameter(target, attachment, pname):
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    res = _lib.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params)
    return params[0]


_lib.glGetIntegerv.argtypes = ctypes.c_uint, ctypes.POINTER(ctypes.c_int),
# void = glGetIntegerv(GLenum pname, GLint* params)
def _glGetIntegerv(pname):
    n = 16
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*n)(*[d for i in range(n)])
    res = _lib.glGetIntegerv(pname, params)
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)


_lib.glGetProgramInfoLog.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.c_char_p,
# void = glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog)
def glGetProgramInfoLog(program):
    bufsize = 1024
    length = (ctypes.c_int*1)()
    infolog = ctypes.create_string_buffer(bufsize)
    res = _lib.glGetProgramInfoLog(program, bufsize, length, infolog)
    return infolog[:length[0]].decode('utf-8')


_lib.glGetProgramiv.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),
# void = glGetProgramiv(GLuint program, GLenum pname, GLint* params)
def glGetProgramParameter(program, pname):
    params = (ctypes.c_int*1)()
    res = _lib.glGetProgramiv(program, pname, params)
    return params[0]


_lib.glGetRenderbufferParameteriv.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),
# void = glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params)
def glGetRenderbufferParameter(target, pname):
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    res = _lib.glGetRenderbufferParameteriv(target, pname, params)
    return params[0]


_lib.glGetShaderInfoLog.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.c_char_p,
# void = glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog)
def glGetShaderInfoLog(shader):
    bufsize = 1024
    length = (ctypes.c_int*1)()
    infolog = ctypes.create_string_buffer(bufsize)
    res = _lib.glGetShaderInfoLog(shader, bufsize, length, infolog)
    return infolog[:length[0]].decode('utf-8')


_lib.glGetShaderPrecisionFormat.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int),
# void = glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision)
def glGetShaderPrecisionFormat(shadertype, precisiontype):
    range = (ctypes.c_int*1)()
    precision = (ctypes.c_int*1)()
    res = _lib.glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision)
    return range[0], precision[0]


_lib.glGetShaderSource.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.c_char_p,
# void = glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source)
def glGetShaderSource(shader):
    bufsize = 1024*1024
    length = (ctypes.c_int*1)()
    source = (ctypes.c_char*bufsize)()
    res = _lib.glGetShaderSource(shader, bufsize, length, source)
    return source.value[:length[0]].decode('utf-8')


_lib.glGetShaderiv.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),
# void = glGetShaderiv(GLuint shader, GLenum pname, GLint* params)
def glGetShaderParameter(shader, pname):
    params = (ctypes.c_int*1)()
    res = _lib.glGetShaderiv(shader, pname, params)
    return params[0]


_lib.glGetString.argtypes = ctypes.c_uint,
_lib.glGetString.restype = ctypes.c_char_p
# GLubyte* = glGetString(GLenum name)
def glGetParameter(pname):
    if pname in [33902, 33901, 32773, 3106, 2931, 2928,
                 2849, 32824, 10752, 32938]:
        # GL_ALIASED_LINE_WIDTH_RANGE GL_ALIASED_POINT_SIZE_RANGE
        # GL_BLEND_COLOR GL_COLOR_CLEAR_VALUE GL_DEPTH_CLEAR_VALUE
        # GL_DEPTH_RANGE GL_LINE_WIDTH GL_POLYGON_OFFSET_FACTOR
        # GL_POLYGON_OFFSET_UNITS GL_SAMPLE_COVERAGE_VALUE
        return _glGetFloatv(pname)
    elif pname in [7936, 7937, 7938, 35724, 7939]:
        # GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION,
        # GL_EXTENSIONS are strings
        pass  # string handled below
    else:
        return _glGetIntegerv(pname)
    name = pname
    res = _lib.glGetString(name)
    return res.decode('utf-8') if res else ''


_lib.glGetTexParameterfv.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_float),
# void = glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params)
def glGetTexParameter(target, pname):
    d = float('Inf')
    params = (ctypes.c_float*1)(d)
    res = _lib.glGetTexParameterfv(target, pname, params)
    return params[0]


_lib.glGetUniformfv.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_float),
# void = glGetUniformfv(GLuint program, GLint location, GLfloat* params)
def glGetUniform(program, location):
    n = 16
    d = float('Inf')
    params = (ctypes.c_float*n)(*[d for i in range(n)])
    res = _lib.glGetUniformfv(program, location, params)
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)


_lib.glGetUniformLocation.argtypes = ctypes.c_uint, ctypes.c_char_p,
_lib.glGetUniformLocation.restype = ctypes.c_int
# GLint = glGetUniformLocation(GLuint program, GLchar* name)
def glGetUniformLocation(program, name):
    name = ctypes.c_char_p(name.encode('utf-8'))
    res = _lib.glGetUniformLocation(program, name)
    return res


_lib.glGetVertexAttribfv.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_float),
# void = glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params)
def glGetVertexAttrib(index, pname):
    n = 4
    d = float('Inf')
    params = (ctypes.c_float*n)(*[d for i in range(n)])
    res = _lib.glGetVertexAttribfv(index, pname, params)
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)


_lib.glGetVertexAttribPointerv.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_void_p),
# void = glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer)
def glGetVertexAttribOffset(index, pname):
    pointer = (ctypes.c_void_p*1)()
    res = _lib.glGetVertexAttribPointerv(index, pname, pointer)
    return pointer[0] or 0


_lib.glHint.argtypes = ctypes.c_uint, ctypes.c_uint,
# void = glHint(GLenum target, GLenum mode)
def glHint(target, mode):
    _lib.glHint(target, mode)


_lib.glIsBuffer.argtypes = ctypes.c_uint,
_lib.glIsBuffer.restype = ctypes.c_bool
# GLboolean = glIsBuffer(GLuint buffer)
def glIsBuffer(buffer):
    return _lib.glIsBuffer(buffer)


_lib.glIsEnabled.argtypes = ctypes.c_uint,
_lib.glIsEnabled.restype = ctypes.c_bool
# GLboolean = glIsEnabled(GLenum cap)
def glIsEnabled(cap):
    return _lib.glIsEnabled(cap)


_lib.glIsFramebuffer.argtypes = ctypes.c_uint,
_lib.glIsFramebuffer.restype = ctypes.c_bool
# GLboolean = glIsFramebuffer(GLuint framebuffer)
def glIsFramebuffer(framebuffer):
    return _lib.glIsFramebuffer(framebuffer)


_lib.glIsProgram.argtypes = ctypes.c_uint,
_lib.glIsProgram.restype = ctypes.c_bool
# GLboolean = glIsProgram(GLuint program)
def glIsProgram(program):
    return _lib.glIsProgram(program)


_lib.glIsRenderbuffer.argtypes = ctypes.c_uint,
_lib.glIsRenderbuffer.restype = ctypes.c_bool
# GLboolean = glIsRenderbuffer(GLuint renderbuffer)
def glIsRenderbuffer(renderbuffer):
    return _lib.glIsRenderbuffer(renderbuffer)


_lib.glIsShader.argtypes = ctypes.c_uint,
_lib.glIsShader.restype = ctypes.c_bool
# GLboolean = glIsShader(GLuint shader)
def glIsShader(shader):
    return _lib.glIsShader(shader)


_lib.glIsTexture.argtypes = ctypes.c_uint,
_lib.glIsTexture.restype = ctypes.c_bool
# GLboolean = glIsTexture(GLuint texture)
def glIsTexture(texture):
    return _lib.glIsTexture(texture)


_lib.glLineWidth.argtypes = ctypes.c_float,
# void = glLineWidth(GLfloat width)
def glLineWidth(width):
    _lib.glLineWidth(width)


_lib.glLinkProgram.argtypes = ctypes.c_uint,
# void = glLinkProgram(GLuint program)
def glLinkProgram(program):
    _lib.glLinkProgram(program)


_lib.glPixelStorei.argtypes = ctypes.c_uint, ctypes.c_int,
# void = glPixelStorei(GLenum pname, GLint param)
def glPixelStorei(pname, param):
    _lib.glPixelStorei(pname, param)


_lib.glPolygonOffset.argtypes = ctypes.c_float, ctypes.c_float,
# void = glPolygonOffset(GLfloat factor, GLfloat units)
def glPolygonOffset(factor, units):
    _lib.glPolygonOffset(factor, units)


_lib.glReadPixels.argtypes = ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_uint, ctypes.c_void_p,
# void = glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
def glReadPixels(x, y, width, height, format, type):
    # GL_ALPHA, GL_RGB, GL_RGBA
    t = {6406:1, 6407:3, 6408:4}[format]
    # we kind of only support type GL_UNSIGNED_BYTE
    size = int(width*height*t)
    pixels = ctypes.create_string_buffer(size)
    res = _lib.glReadPixels(x, y, width, height, format, type, pixels)
    return pixels[:]


_lib.glRenderbufferStorage.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.c_int,
# void = glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
def glRenderbufferStorage(target, internalformat, width, height):
    _lib.glRenderbufferStorage(target, internalformat, width, height)


_lib.glSampleCoverage.argtypes = ctypes.c_float, ctypes.c_bool,
# void = glSampleCoverage(GLclampf value, GLboolean invert)
def glSampleCoverage(value, invert):
    _lib.glSampleCoverage(value, invert)


_lib.glScissor.argtypes = ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,
# void = glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
def glScissor(x, y, width, height):
    _lib.glScissor(x, y, width, height)


_lib.glShaderSource.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_int),
# void = glShaderSource(GLuint shader, GLsizei count, GLchar** string, GLint* length)
def glShaderSource(shader, source):
    # Some implementation do not like getting a list of single chars
    if isinstance(source, (tuple, list)):
        strings = [s for s in source]
    else:
        strings = [source]
    count = len(strings)
    string = (ctypes.c_char_p*count)(*[s.encode('utf-8') for s in strings])
    length = (ctypes.c_int*count)(*[len(s) for s in strings])
    res = _lib.glShaderSource(shader, count, string, length)


_lib.glStencilFunc.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_uint,
# void = glStencilFunc(GLenum func, GLint ref, GLuint mask)
def glStencilFunc(func, ref, mask):
    _lib.glStencilFunc(func, ref, mask)


_lib.glStencilFuncSeparate.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.c_uint,
# void = glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
def glStencilFuncSeparate(face, func, ref, mask):
    _lib.glStencilFuncSeparate(face, func, ref, mask)


_lib.glStencilMask.argtypes = ctypes.c_uint,
# void = glStencilMask(GLuint mask)
def glStencilMask(mask):
    _lib.glStencilMask(mask)


_lib.glStencilMaskSeparate.argtypes = ctypes.c_uint, ctypes.c_uint,
# void = glStencilMaskSeparate(GLenum face, GLuint mask)
def glStencilMaskSeparate(face, mask):
    _lib.glStencilMaskSeparate(face, mask)


_lib.glStencilOp.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,
# void = glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
def glStencilOp(fail, zfail, zpass):
    _lib.glStencilOp(fail, zfail, zpass)


_lib.glStencilOpSeparate.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,
# void = glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
def glStencilOpSeparate(face, fail, zfail, zpass):
    _lib.glStencilOpSeparate(face, fail, zfail, zpass)


_lib.glTexImage2D.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_uint, ctypes.c_void_p,
# void = glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLvoid* pixels)
def glTexImage2D(target, level, internalformat, format, type, pixels):
    border = 0
    if isinstance(pixels, (tuple, list)):
        height, width = pixels
        pixels = ctypes.c_void_p(0)
        pixels = None
    else:
        if not pixels.flags['C_CONTIGUOUS']:
            pixels = pixels.copy('C')
        pixels_ = pixels
        pixels = pixels_.ctypes.data
        height, width = pixels_.shape[:2]
    res = _lib.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels)


_lib.glTexParameterf.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_float,
def glTexParameterf(target, pname, param):
    _lib.glTexParameterf(target, pname, param)
_lib.glTexParameteri.argtypes = ctypes.c_uint, ctypes.c_uint, ctypes.c_int,
def glTexParameteri(target, pname, param):
    _lib.glTexParameteri(target, pname, param)


_lib.glTexSubImage2D.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_uint, ctypes.c_void_p,
# void = glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
def glTexSubImage2D(target, level, xoffset, yoffset, format, type, pixels):
    if not pixels.flags['C_CONTIGUOUS']:
        pixels = pixels.copy('C')
    pixels_ = pixels
    pixels = pixels_.ctypes.data
    height, width = pixels_.shape[:2]
    res = _lib.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels)


_lib.glUniform1f.argtypes = ctypes.c_int, ctypes.c_float,
def glUniform1f(location, v1):
    _lib.glUniform1f(location, v1)
_lib.glUniform2f.argtypes = ctypes.c_int, ctypes.c_float, ctypes.c_float,
def glUniform2f(location, v1, v2):
    _lib.glUniform2f(location, v1, v2)
_lib.glUniform3f.argtypes = ctypes.c_int, ctypes.c_float, ctypes.c_float, ctypes.c_float,
def glUniform3f(location, v1, v2, v3):
    _lib.glUniform3f(location, v1, v2, v3)
_lib.glUniform4f.argtypes = ctypes.c_int, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,
def glUniform4f(location, v1, v2, v3, v4):
    _lib.glUniform4f(location, v1, v2, v3, v4)
_lib.glUniform1i.argtypes = ctypes.c_int, ctypes.c_int,
def glUniform1i(location, v1):
    _lib.glUniform1i(location, v1)
_lib.glUniform2i.argtypes = ctypes.c_int, ctypes.c_int, ctypes.c_int,
def glUniform2i(location, v1, v2):
    _lib.glUniform2i(location, v1, v2)
_lib.glUniform3i.argtypes = ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,
def glUniform3i(location, v1, v2, v3):
    _lib.glUniform3i(location, v1, v2, v3)
_lib.glUniform4i.argtypes = ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,
def glUniform4i(location, v1, v2, v3, v4):
    _lib.glUniform4i(location, v1, v2, v3, v4)
_lib.glUniform1fv.argtypes = ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),
def glUniform1fv(location, count, values):
    values = [float(val) for val in values]
    values = (ctypes.c_float*len(values))(*values)
    _lib.glUniform1fv(location, count, values)
_lib.glUniform2fv.argtypes = ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),
def glUniform2fv(location, count, values):
    values = [float(val) for val in values]
    values = (ctypes.c_float*len(values))(*values)
    _lib.glUniform2fv(location, count, values)
_lib.glUniform3fv.argtypes = ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),
def glUniform3fv(location, count, values):
    values = [float(val) for val in values]
    values = (ctypes.c_float*len(values))(*values)
    _lib.glUniform3fv(location, count, values)
_lib.glUniform4fv.argtypes = ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),
def glUniform4fv(location, count, values):
    values = [float(val) for val in values]
    values = (ctypes.c_float*len(values))(*values)
    _lib.glUniform4fv(location, count, values)
_lib.glUniform1iv.argtypes = ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),
def glUniform1iv(location, count, values):
    values = [int(val) for val in values]
    values = (ctypes.c_int*len(values))(*values)
    _lib.glUniform1iv(location, count, values)
_lib.glUniform2iv.argtypes = ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),
def glUniform2iv(location, count, values):
    values = [int(val) for val in values]
    values = (ctypes.c_int*len(values))(*values)
    _lib.glUniform2iv(location, count, values)
_lib.glUniform3iv.argtypes = ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),
def glUniform3iv(location, count, values):
    values = [int(val) for val in values]
    values = (ctypes.c_int*len(values))(*values)
    _lib.glUniform3iv(location, count, values)
_lib.glUniform4iv.argtypes = ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),
def glUniform4iv(location, count, values):
    values = [int(val) for val in values]
    values = (ctypes.c_int*len(values))(*values)
    _lib.glUniform4iv(location, count, values)


_lib.glUniformMatrix2fv.argtypes = ctypes.c_int, ctypes.c_int, ctypes.c_bool, ctypes.POINTER(ctypes.c_float),
def glUniformMatrix2fv(location, count, transpose, values):
    if not values.flags["C_CONTIGUOUS"]:
        values = values.copy()
    assert values.dtype.name == "float32"
    values_ = values
    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))
    _lib.glUniformMatrix2fv(location, count, transpose, values)
_lib.glUniformMatrix3fv.argtypes = ctypes.c_int, ctypes.c_int, ctypes.c_bool, ctypes.POINTER(ctypes.c_float),
def glUniformMatrix3fv(location, count, transpose, values):
    if not values.flags["C_CONTIGUOUS"]:
        values = values.copy()
    assert values.dtype.name == "float32"
    values_ = values
    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))
    _lib.glUniformMatrix3fv(location, count, transpose, values)
_lib.glUniformMatrix4fv.argtypes = ctypes.c_int, ctypes.c_int, ctypes.c_bool, ctypes.POINTER(ctypes.c_float),
def glUniformMatrix4fv(location, count, transpose, values):
    if not values.flags["C_CONTIGUOUS"]:
        values = values.copy()
    assert values.dtype.name == "float32"
    values_ = values
    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))
    _lib.glUniformMatrix4fv(location, count, transpose, values)


_lib.glUseProgram.argtypes = ctypes.c_uint,
# void = glUseProgram(GLuint program)
def glUseProgram(program):
    _lib.glUseProgram(program)


_lib.glValidateProgram.argtypes = ctypes.c_uint,
# void = glValidateProgram(GLuint program)
def glValidateProgram(program):
    _lib.glValidateProgram(program)


_lib.glVertexAttrib1f.argtypes = ctypes.c_uint, ctypes.c_float,
def glVertexAttrib1f(index, v1):
    _lib.glVertexAttrib1f(index, v1)
_lib.glVertexAttrib2f.argtypes = ctypes.c_uint, ctypes.c_float, ctypes.c_float,
def glVertexAttrib2f(index, v1, v2):
    _lib.glVertexAttrib2f(index, v1, v2)
_lib.glVertexAttrib3f.argtypes = ctypes.c_uint, ctypes.c_float, ctypes.c_float, ctypes.c_float,
def glVertexAttrib3f(index, v1, v2, v3):
    _lib.glVertexAttrib3f(index, v1, v2, v3)
_lib.glVertexAttrib4f.argtypes = ctypes.c_uint, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,
def glVertexAttrib4f(index, v1, v2, v3, v4):
    _lib.glVertexAttrib4f(index, v1, v2, v3, v4)


_lib.glVertexAttribPointer.argtypes = ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_bool, ctypes.c_int, ctypes.c_void_p,
# void = glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLvoid* ptr)
def glVertexAttribPointer(indx, size, type, normalized, stride, offset):
    if offset is None:
        offset = ctypes.c_void_p(0)
    elif isinstance(offset, ctypes.c_void_p):
        pass
    elif isinstance(offset, (int, ctypes.c_int)):
        offset = ctypes.c_void_p(int(offset))
    else:
        if not offset.flags['C_CONTIGUOUS']:
            offset = offset.copy('C')
        offset_ = offset
        offset = offset.ctypes.data
        # We need to ensure that the data exists at draw time :(
        # PyOpenGL does this too
        key = '_vert_attr_'+str(indx)
        setattr(glVertexAttribPointer, key, offset_)
    ptr = offset
    res = _lib.glVertexAttribPointer(indx, size, type, normalized, stride, ptr)


_lib.glViewport.argtypes = ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,
# void = glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
def glViewport(x, y, width, height):
    _lib.glViewport(x, y, width, height)



########NEW FILE########
__FILENAME__ = _constants
"""

THIS CODE IS AUTO-GENERATED. DO NOT EDIT.

Constants for OpenGL ES 2.0.

"""


class Enum(int):
    ''' Enum (integer) with a meaningfull repr. '''
    def __new__(cls, name, value):
        base = int.__new__(cls, value)
        base.name = name
        return base
    def __repr__(self):
        return self.name


GL_ACTIVE_ATTRIBUTES = Enum('GL_ACTIVE_ATTRIBUTES', 35721)
GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = Enum('GL_ACTIVE_ATTRIBUTE_MAX_LENGTH', 35722)
GL_ACTIVE_TEXTURE = Enum('GL_ACTIVE_TEXTURE', 34016)
GL_ACTIVE_UNIFORMS = Enum('GL_ACTIVE_UNIFORMS', 35718)
GL_ACTIVE_UNIFORM_MAX_LENGTH = Enum('GL_ACTIVE_UNIFORM_MAX_LENGTH', 35719)
GL_ALIASED_LINE_WIDTH_RANGE = Enum('GL_ALIASED_LINE_WIDTH_RANGE', 33902)
GL_ALIASED_POINT_SIZE_RANGE = Enum('GL_ALIASED_POINT_SIZE_RANGE', 33901)
GL_ALPHA = Enum('GL_ALPHA', 6406)
GL_ALPHA_BITS = Enum('GL_ALPHA_BITS', 3413)
GL_ALWAYS = Enum('GL_ALWAYS', 519)
GL_ARRAY_BUFFER = Enum('GL_ARRAY_BUFFER', 34962)
GL_ARRAY_BUFFER_BINDING = Enum('GL_ARRAY_BUFFER_BINDING', 34964)
GL_ATTACHED_SHADERS = Enum('GL_ATTACHED_SHADERS', 35717)
GL_BACK = Enum('GL_BACK', 1029)
GL_BLEND = Enum('GL_BLEND', 3042)
GL_BLEND_COLOR = Enum('GL_BLEND_COLOR', 32773)
GL_BLEND_DST_ALPHA = Enum('GL_BLEND_DST_ALPHA', 32970)
GL_BLEND_DST_RGB = Enum('GL_BLEND_DST_RGB', 32968)
GL_BLEND_EQUATION = Enum('GL_BLEND_EQUATION', 32777)
GL_BLEND_EQUATION_ALPHA = Enum('GL_BLEND_EQUATION_ALPHA', 34877)
GL_BLEND_EQUATION_RGB = Enum('GL_BLEND_EQUATION_RGB', 32777)
GL_BLEND_SRC_ALPHA = Enum('GL_BLEND_SRC_ALPHA', 32971)
GL_BLEND_SRC_RGB = Enum('GL_BLEND_SRC_RGB', 32969)
GL_BLUE_BITS = Enum('GL_BLUE_BITS', 3412)
GL_BOOL = Enum('GL_BOOL', 35670)
GL_BOOL_VEC2 = Enum('GL_BOOL_VEC2', 35671)
GL_BOOL_VEC3 = Enum('GL_BOOL_VEC3', 35672)
GL_BOOL_VEC4 = Enum('GL_BOOL_VEC4', 35673)
GL_BUFFER_SIZE = Enum('GL_BUFFER_SIZE', 34660)
GL_BUFFER_USAGE = Enum('GL_BUFFER_USAGE', 34661)
GL_BYTE = Enum('GL_BYTE', 5120)
GL_CCW = Enum('GL_CCW', 2305)
GL_CLAMP_TO_EDGE = Enum('GL_CLAMP_TO_EDGE', 33071)
GL_COLOR_ATTACHMENT0 = Enum('GL_COLOR_ATTACHMENT0', 36064)
GL_COLOR_BUFFER_BIT = Enum('GL_COLOR_BUFFER_BIT', 16384)
GL_COLOR_CLEAR_VALUE = Enum('GL_COLOR_CLEAR_VALUE', 3106)
GL_COLOR_WRITEMASK = Enum('GL_COLOR_WRITEMASK', 3107)
GL_COMPILE_STATUS = Enum('GL_COMPILE_STATUS', 35713)
GL_COMPRESSED_TEXTURE_FORMATS = Enum('GL_COMPRESSED_TEXTURE_FORMATS', 34467)
GL_CONSTANT_ALPHA = Enum('GL_CONSTANT_ALPHA', 32771)
GL_CONSTANT_COLOR = Enum('GL_CONSTANT_COLOR', 32769)
GL_CULL_FACE = Enum('GL_CULL_FACE', 2884)
GL_CULL_FACE_MODE = Enum('GL_CULL_FACE_MODE', 2885)
GL_CURRENT_PROGRAM = Enum('GL_CURRENT_PROGRAM', 35725)
GL_CURRENT_VERTEX_ATTRIB = Enum('GL_CURRENT_VERTEX_ATTRIB', 34342)
GL_CW = Enum('GL_CW', 2304)
GL_DECR = Enum('GL_DECR', 7683)
GL_DECR_WRAP = Enum('GL_DECR_WRAP', 34056)
GL_DELETE_STATUS = Enum('GL_DELETE_STATUS', 35712)
GL_DEPTH_ATTACHMENT = Enum('GL_DEPTH_ATTACHMENT', 36096)
GL_DEPTH_BITS = Enum('GL_DEPTH_BITS', 3414)
GL_DEPTH_BUFFER_BIT = Enum('GL_DEPTH_BUFFER_BIT', 256)
GL_DEPTH_CLEAR_VALUE = Enum('GL_DEPTH_CLEAR_VALUE', 2931)
GL_DEPTH_COMPONENT = Enum('GL_DEPTH_COMPONENT', 6402)
GL_DEPTH_COMPONENT16 = Enum('GL_DEPTH_COMPONENT16', 33189)
GL_DEPTH_FUNC = Enum('GL_DEPTH_FUNC', 2932)
GL_DEPTH_RANGE = Enum('GL_DEPTH_RANGE', 2928)
GL_DEPTH_TEST = Enum('GL_DEPTH_TEST', 2929)
GL_DEPTH_WRITEMASK = Enum('GL_DEPTH_WRITEMASK', 2930)
GL_DITHER = Enum('GL_DITHER', 3024)
GL_DONT_CARE = Enum('GL_DONT_CARE', 4352)
GL_DST_ALPHA = Enum('GL_DST_ALPHA', 772)
GL_DST_COLOR = Enum('GL_DST_COLOR', 774)
GL_DYNAMIC_DRAW = Enum('GL_DYNAMIC_DRAW', 35048)
GL_ELEMENT_ARRAY_BUFFER = Enum('GL_ELEMENT_ARRAY_BUFFER', 34963)
GL_ELEMENT_ARRAY_BUFFER_BINDING = Enum('GL_ELEMENT_ARRAY_BUFFER_BINDING', 34965)
GL_EQUAL = Enum('GL_EQUAL', 514)
GL_ES_VERSION_2_0 = Enum('GL_ES_VERSION_2_0', 1)
GL_EXTENSIONS = Enum('GL_EXTENSIONS', 7939)
GL_FALSE = Enum('GL_FALSE', 0)
GL_FASTEST = Enum('GL_FASTEST', 4353)
GL_FIXED = Enum('GL_FIXED', 5132)
GL_FLOAT = Enum('GL_FLOAT', 5126)
GL_FLOAT_MAT2 = Enum('GL_FLOAT_MAT2', 35674)
GL_FLOAT_MAT3 = Enum('GL_FLOAT_MAT3', 35675)
GL_FLOAT_MAT4 = Enum('GL_FLOAT_MAT4', 35676)
GL_FLOAT_VEC2 = Enum('GL_FLOAT_VEC2', 35664)
GL_FLOAT_VEC3 = Enum('GL_FLOAT_VEC3', 35665)
GL_FLOAT_VEC4 = Enum('GL_FLOAT_VEC4', 35666)
GL_FRAGMENT_SHADER = Enum('GL_FRAGMENT_SHADER', 35632)
GL_FRAMEBUFFER = Enum('GL_FRAMEBUFFER', 36160)
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = Enum('GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME', 36049)
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = Enum('GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE', 36048)
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = Enum('GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE', 36051)
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = Enum('GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL', 36050)
GL_FRAMEBUFFER_BINDING = Enum('GL_FRAMEBUFFER_BINDING', 36006)
GL_FRAMEBUFFER_COMPLETE = Enum('GL_FRAMEBUFFER_COMPLETE', 36053)
GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = Enum('GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT', 36054)
GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = Enum('GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS', 36057)
GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = Enum('GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT', 36055)
GL_FRAMEBUFFER_UNSUPPORTED = Enum('GL_FRAMEBUFFER_UNSUPPORTED', 36061)
GL_FRONT = Enum('GL_FRONT', 1028)
GL_FRONT_AND_BACK = Enum('GL_FRONT_AND_BACK', 1032)
GL_FRONT_FACE = Enum('GL_FRONT_FACE', 2886)
GL_FUNC_ADD = Enum('GL_FUNC_ADD', 32774)
GL_FUNC_REVERSE_SUBTRACT = Enum('GL_FUNC_REVERSE_SUBTRACT', 32779)
GL_FUNC_SUBTRACT = Enum('GL_FUNC_SUBTRACT', 32778)
GL_GENERATE_MIPMAP_HINT = Enum('GL_GENERATE_MIPMAP_HINT', 33170)
GL_GEQUAL = Enum('GL_GEQUAL', 518)
GL_GREATER = Enum('GL_GREATER', 516)
GL_GREEN_BITS = Enum('GL_GREEN_BITS', 3411)
GL_HIGH_FLOAT = Enum('GL_HIGH_FLOAT', 36338)
GL_HIGH_INT = Enum('GL_HIGH_INT', 36341)
GL_IMPLEMENTATION_COLOR_READ_FORMAT = Enum('GL_IMPLEMENTATION_COLOR_READ_FORMAT', 35739)
GL_IMPLEMENTATION_COLOR_READ_TYPE = Enum('GL_IMPLEMENTATION_COLOR_READ_TYPE', 35738)
GL_INCR = Enum('GL_INCR', 7682)
GL_INCR_WRAP = Enum('GL_INCR_WRAP', 34055)
GL_INFO_LOG_LENGTH = Enum('GL_INFO_LOG_LENGTH', 35716)
GL_INT = Enum('GL_INT', 5124)
GL_INT_VEC2 = Enum('GL_INT_VEC2', 35667)
GL_INT_VEC3 = Enum('GL_INT_VEC3', 35668)
GL_INT_VEC4 = Enum('GL_INT_VEC4', 35669)
GL_INVALID_ENUM = Enum('GL_INVALID_ENUM', 1280)
GL_INVALID_FRAMEBUFFER_OPERATION = Enum('GL_INVALID_FRAMEBUFFER_OPERATION', 1286)
GL_INVALID_OPERATION = Enum('GL_INVALID_OPERATION', 1282)
GL_INVALID_VALUE = Enum('GL_INVALID_VALUE', 1281)
GL_INVERT = Enum('GL_INVERT', 5386)
GL_KEEP = Enum('GL_KEEP', 7680)
GL_LEQUAL = Enum('GL_LEQUAL', 515)
GL_LESS = Enum('GL_LESS', 513)
GL_LINEAR = Enum('GL_LINEAR', 9729)
GL_LINEAR_MIPMAP_LINEAR = Enum('GL_LINEAR_MIPMAP_LINEAR', 9987)
GL_LINEAR_MIPMAP_NEAREST = Enum('GL_LINEAR_MIPMAP_NEAREST', 9985)
GL_LINES = Enum('GL_LINES', 1)
GL_LINE_LOOP = Enum('GL_LINE_LOOP', 2)
GL_LINE_STRIP = Enum('GL_LINE_STRIP', 3)
GL_LINE_WIDTH = Enum('GL_LINE_WIDTH', 2849)
GL_LINK_STATUS = Enum('GL_LINK_STATUS', 35714)
GL_LOW_FLOAT = Enum('GL_LOW_FLOAT', 36336)
GL_LOW_INT = Enum('GL_LOW_INT', 36339)
GL_LUMINANCE = Enum('GL_LUMINANCE', 6409)
GL_LUMINANCE_ALPHA = Enum('GL_LUMINANCE_ALPHA', 6410)
GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = Enum('GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS', 35661)
GL_MAX_CUBE_MAP_TEXTURE_SIZE = Enum('GL_MAX_CUBE_MAP_TEXTURE_SIZE', 34076)
GL_MAX_FRAGMENT_UNIFORM_VECTORS = Enum('GL_MAX_FRAGMENT_UNIFORM_VECTORS', 36349)
GL_MAX_RENDERBUFFER_SIZE = Enum('GL_MAX_RENDERBUFFER_SIZE', 34024)
GL_MAX_TEXTURE_IMAGE_UNITS = Enum('GL_MAX_TEXTURE_IMAGE_UNITS', 34930)
GL_MAX_TEXTURE_SIZE = Enum('GL_MAX_TEXTURE_SIZE', 3379)
GL_MAX_VARYING_VECTORS = Enum('GL_MAX_VARYING_VECTORS', 36348)
GL_MAX_VERTEX_ATTRIBS = Enum('GL_MAX_VERTEX_ATTRIBS', 34921)
GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = Enum('GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS', 35660)
GL_MAX_VERTEX_UNIFORM_VECTORS = Enum('GL_MAX_VERTEX_UNIFORM_VECTORS', 36347)
GL_MAX_VIEWPORT_DIMS = Enum('GL_MAX_VIEWPORT_DIMS', 3386)
GL_MEDIUM_FLOAT = Enum('GL_MEDIUM_FLOAT', 36337)
GL_MEDIUM_INT = Enum('GL_MEDIUM_INT', 36340)
GL_MIRRORED_REPEAT = Enum('GL_MIRRORED_REPEAT', 33648)
GL_NEAREST = Enum('GL_NEAREST', 9728)
GL_NEAREST_MIPMAP_LINEAR = Enum('GL_NEAREST_MIPMAP_LINEAR', 9986)
GL_NEAREST_MIPMAP_NEAREST = Enum('GL_NEAREST_MIPMAP_NEAREST', 9984)
GL_NEVER = Enum('GL_NEVER', 512)
GL_NICEST = Enum('GL_NICEST', 4354)
GL_NONE = Enum('GL_NONE', 0)
GL_NOTEQUAL = Enum('GL_NOTEQUAL', 517)
GL_NO_ERROR = Enum('GL_NO_ERROR', 0)
GL_NUM_COMPRESSED_TEXTURE_FORMATS = Enum('GL_NUM_COMPRESSED_TEXTURE_FORMATS', 34466)
GL_NUM_SHADER_BINARY_FORMATS = Enum('GL_NUM_SHADER_BINARY_FORMATS', 36345)
GL_ONE = Enum('GL_ONE', 1)
GL_ONE_MINUS_CONSTANT_ALPHA = Enum('GL_ONE_MINUS_CONSTANT_ALPHA', 32772)
GL_ONE_MINUS_CONSTANT_COLOR = Enum('GL_ONE_MINUS_CONSTANT_COLOR', 32770)
GL_ONE_MINUS_DST_ALPHA = Enum('GL_ONE_MINUS_DST_ALPHA', 773)
GL_ONE_MINUS_DST_COLOR = Enum('GL_ONE_MINUS_DST_COLOR', 775)
GL_ONE_MINUS_SRC_ALPHA = Enum('GL_ONE_MINUS_SRC_ALPHA', 771)
GL_ONE_MINUS_SRC_COLOR = Enum('GL_ONE_MINUS_SRC_COLOR', 769)
GL_OUT_OF_MEMORY = Enum('GL_OUT_OF_MEMORY', 1285)
GL_PACK_ALIGNMENT = Enum('GL_PACK_ALIGNMENT', 3333)
GL_POINTS = Enum('GL_POINTS', 0)
GL_POLYGON_OFFSET_FACTOR = Enum('GL_POLYGON_OFFSET_FACTOR', 32824)
GL_POLYGON_OFFSET_FILL = Enum('GL_POLYGON_OFFSET_FILL', 32823)
GL_POLYGON_OFFSET_UNITS = Enum('GL_POLYGON_OFFSET_UNITS', 10752)
GL_RED_BITS = Enum('GL_RED_BITS', 3410)
GL_RENDERBUFFER = Enum('GL_RENDERBUFFER', 36161)
GL_RENDERBUFFER_ALPHA_SIZE = Enum('GL_RENDERBUFFER_ALPHA_SIZE', 36179)
GL_RENDERBUFFER_BINDING = Enum('GL_RENDERBUFFER_BINDING', 36007)
GL_RENDERBUFFER_BLUE_SIZE = Enum('GL_RENDERBUFFER_BLUE_SIZE', 36178)
GL_RENDERBUFFER_DEPTH_SIZE = Enum('GL_RENDERBUFFER_DEPTH_SIZE', 36180)
GL_RENDERBUFFER_GREEN_SIZE = Enum('GL_RENDERBUFFER_GREEN_SIZE', 36177)
GL_RENDERBUFFER_HEIGHT = Enum('GL_RENDERBUFFER_HEIGHT', 36163)
GL_RENDERBUFFER_INTERNAL_FORMAT = Enum('GL_RENDERBUFFER_INTERNAL_FORMAT', 36164)
GL_RENDERBUFFER_RED_SIZE = Enum('GL_RENDERBUFFER_RED_SIZE', 36176)
GL_RENDERBUFFER_STENCIL_SIZE = Enum('GL_RENDERBUFFER_STENCIL_SIZE', 36181)
GL_RENDERBUFFER_WIDTH = Enum('GL_RENDERBUFFER_WIDTH', 36162)
GL_RENDERER = Enum('GL_RENDERER', 7937)
GL_REPEAT = Enum('GL_REPEAT', 10497)
GL_REPLACE = Enum('GL_REPLACE', 7681)
GL_RGB = Enum('GL_RGB', 6407)
GL_RGB565 = Enum('GL_RGB565', 36194)
GL_RGB5_A1 = Enum('GL_RGB5_A1', 32855)
GL_RGBA = Enum('GL_RGBA', 6408)
GL_RGBA4 = Enum('GL_RGBA4', 32854)
GL_SAMPLER_2D = Enum('GL_SAMPLER_2D', 35678)
GL_SAMPLER_CUBE = Enum('GL_SAMPLER_CUBE', 35680)
GL_SAMPLES = Enum('GL_SAMPLES', 32937)
GL_SAMPLE_ALPHA_TO_COVERAGE = Enum('GL_SAMPLE_ALPHA_TO_COVERAGE', 32926)
GL_SAMPLE_BUFFERS = Enum('GL_SAMPLE_BUFFERS', 32936)
GL_SAMPLE_COVERAGE = Enum('GL_SAMPLE_COVERAGE', 32928)
GL_SAMPLE_COVERAGE_INVERT = Enum('GL_SAMPLE_COVERAGE_INVERT', 32939)
GL_SAMPLE_COVERAGE_VALUE = Enum('GL_SAMPLE_COVERAGE_VALUE', 32938)
GL_SCISSOR_BOX = Enum('GL_SCISSOR_BOX', 3088)
GL_SCISSOR_TEST = Enum('GL_SCISSOR_TEST', 3089)
GL_SHADER_BINARY_FORMATS = Enum('GL_SHADER_BINARY_FORMATS', 36344)
GL_SHADER_COMPILER = Enum('GL_SHADER_COMPILER', 36346)
GL_SHADER_SOURCE_LENGTH = Enum('GL_SHADER_SOURCE_LENGTH', 35720)
GL_SHADER_TYPE = Enum('GL_SHADER_TYPE', 35663)
GL_SHADING_LANGUAGE_VERSION = Enum('GL_SHADING_LANGUAGE_VERSION', 35724)
GL_SHORT = Enum('GL_SHORT', 5122)
GL_SRC_ALPHA = Enum('GL_SRC_ALPHA', 770)
GL_SRC_ALPHA_SATURATE = Enum('GL_SRC_ALPHA_SATURATE', 776)
GL_SRC_COLOR = Enum('GL_SRC_COLOR', 768)
GL_STATIC_DRAW = Enum('GL_STATIC_DRAW', 35044)
GL_STENCIL_ATTACHMENT = Enum('GL_STENCIL_ATTACHMENT', 36128)
GL_STENCIL_BACK_FAIL = Enum('GL_STENCIL_BACK_FAIL', 34817)
GL_STENCIL_BACK_FUNC = Enum('GL_STENCIL_BACK_FUNC', 34816)
GL_STENCIL_BACK_PASS_DEPTH_FAIL = Enum('GL_STENCIL_BACK_PASS_DEPTH_FAIL', 34818)
GL_STENCIL_BACK_PASS_DEPTH_PASS = Enum('GL_STENCIL_BACK_PASS_DEPTH_PASS', 34819)
GL_STENCIL_BACK_REF = Enum('GL_STENCIL_BACK_REF', 36003)
GL_STENCIL_BACK_VALUE_MASK = Enum('GL_STENCIL_BACK_VALUE_MASK', 36004)
GL_STENCIL_BACK_WRITEMASK = Enum('GL_STENCIL_BACK_WRITEMASK', 36005)
GL_STENCIL_BITS = Enum('GL_STENCIL_BITS', 3415)
GL_STENCIL_BUFFER_BIT = Enum('GL_STENCIL_BUFFER_BIT', 1024)
GL_STENCIL_CLEAR_VALUE = Enum('GL_STENCIL_CLEAR_VALUE', 2961)
GL_STENCIL_FAIL = Enum('GL_STENCIL_FAIL', 2964)
GL_STENCIL_FUNC = Enum('GL_STENCIL_FUNC', 2962)
GL_STENCIL_INDEX8 = Enum('GL_STENCIL_INDEX8', 36168)
GL_STENCIL_PASS_DEPTH_FAIL = Enum('GL_STENCIL_PASS_DEPTH_FAIL', 2965)
GL_STENCIL_PASS_DEPTH_PASS = Enum('GL_STENCIL_PASS_DEPTH_PASS', 2966)
GL_STENCIL_REF = Enum('GL_STENCIL_REF', 2967)
GL_STENCIL_TEST = Enum('GL_STENCIL_TEST', 2960)
GL_STENCIL_VALUE_MASK = Enum('GL_STENCIL_VALUE_MASK', 2963)
GL_STENCIL_WRITEMASK = Enum('GL_STENCIL_WRITEMASK', 2968)
GL_STREAM_DRAW = Enum('GL_STREAM_DRAW', 35040)
GL_SUBPIXEL_BITS = Enum('GL_SUBPIXEL_BITS', 3408)
GL_TEXTURE = Enum('GL_TEXTURE', 5890)
GL_TEXTURE0 = Enum('GL_TEXTURE0', 33984)
GL_TEXTURE1 = Enum('GL_TEXTURE1', 33985)
GL_TEXTURE10 = Enum('GL_TEXTURE10', 33994)
GL_TEXTURE11 = Enum('GL_TEXTURE11', 33995)
GL_TEXTURE12 = Enum('GL_TEXTURE12', 33996)
GL_TEXTURE13 = Enum('GL_TEXTURE13', 33997)
GL_TEXTURE14 = Enum('GL_TEXTURE14', 33998)
GL_TEXTURE15 = Enum('GL_TEXTURE15', 33999)
GL_TEXTURE16 = Enum('GL_TEXTURE16', 34000)
GL_TEXTURE17 = Enum('GL_TEXTURE17', 34001)
GL_TEXTURE18 = Enum('GL_TEXTURE18', 34002)
GL_TEXTURE19 = Enum('GL_TEXTURE19', 34003)
GL_TEXTURE2 = Enum('GL_TEXTURE2', 33986)
GL_TEXTURE20 = Enum('GL_TEXTURE20', 34004)
GL_TEXTURE21 = Enum('GL_TEXTURE21', 34005)
GL_TEXTURE22 = Enum('GL_TEXTURE22', 34006)
GL_TEXTURE23 = Enum('GL_TEXTURE23', 34007)
GL_TEXTURE24 = Enum('GL_TEXTURE24', 34008)
GL_TEXTURE25 = Enum('GL_TEXTURE25', 34009)
GL_TEXTURE26 = Enum('GL_TEXTURE26', 34010)
GL_TEXTURE27 = Enum('GL_TEXTURE27', 34011)
GL_TEXTURE28 = Enum('GL_TEXTURE28', 34012)
GL_TEXTURE29 = Enum('GL_TEXTURE29', 34013)
GL_TEXTURE3 = Enum('GL_TEXTURE3', 33987)
GL_TEXTURE30 = Enum('GL_TEXTURE30', 34014)
GL_TEXTURE31 = Enum('GL_TEXTURE31', 34015)
GL_TEXTURE4 = Enum('GL_TEXTURE4', 33988)
GL_TEXTURE5 = Enum('GL_TEXTURE5', 33989)
GL_TEXTURE6 = Enum('GL_TEXTURE6', 33990)
GL_TEXTURE7 = Enum('GL_TEXTURE7', 33991)
GL_TEXTURE8 = Enum('GL_TEXTURE8', 33992)
GL_TEXTURE9 = Enum('GL_TEXTURE9', 33993)
GL_TEXTURE_2D = Enum('GL_TEXTURE_2D', 3553)
GL_TEXTURE_BINDING_2D = Enum('GL_TEXTURE_BINDING_2D', 32873)
GL_TEXTURE_BINDING_CUBE_MAP = Enum('GL_TEXTURE_BINDING_CUBE_MAP', 34068)
GL_TEXTURE_CUBE_MAP = Enum('GL_TEXTURE_CUBE_MAP', 34067)
GL_TEXTURE_CUBE_MAP_NEGATIVE_X = Enum('GL_TEXTURE_CUBE_MAP_NEGATIVE_X', 34070)
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = Enum('GL_TEXTURE_CUBE_MAP_NEGATIVE_Y', 34072)
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = Enum('GL_TEXTURE_CUBE_MAP_NEGATIVE_Z', 34074)
GL_TEXTURE_CUBE_MAP_POSITIVE_X = Enum('GL_TEXTURE_CUBE_MAP_POSITIVE_X', 34069)
GL_TEXTURE_CUBE_MAP_POSITIVE_Y = Enum('GL_TEXTURE_CUBE_MAP_POSITIVE_Y', 34071)
GL_TEXTURE_CUBE_MAP_POSITIVE_Z = Enum('GL_TEXTURE_CUBE_MAP_POSITIVE_Z', 34073)
GL_TEXTURE_MAG_FILTER = Enum('GL_TEXTURE_MAG_FILTER', 10240)
GL_TEXTURE_MIN_FILTER = Enum('GL_TEXTURE_MIN_FILTER', 10241)
GL_TEXTURE_WRAP_S = Enum('GL_TEXTURE_WRAP_S', 10242)
GL_TEXTURE_WRAP_T = Enum('GL_TEXTURE_WRAP_T', 10243)
GL_TRIANGLES = Enum('GL_TRIANGLES', 4)
GL_TRIANGLE_FAN = Enum('GL_TRIANGLE_FAN', 6)
GL_TRIANGLE_STRIP = Enum('GL_TRIANGLE_STRIP', 5)
GL_TRUE = Enum('GL_TRUE', 1)
GL_UNPACK_ALIGNMENT = Enum('GL_UNPACK_ALIGNMENT', 3317)
GL_UNSIGNED_BYTE = Enum('GL_UNSIGNED_BYTE', 5121)
GL_UNSIGNED_INT = Enum('GL_UNSIGNED_INT', 5125)
GL_UNSIGNED_SHORT = Enum('GL_UNSIGNED_SHORT', 5123)
GL_UNSIGNED_SHORT_4_4_4_4 = Enum('GL_UNSIGNED_SHORT_4_4_4_4', 32819)
GL_UNSIGNED_SHORT_5_5_5_1 = Enum('GL_UNSIGNED_SHORT_5_5_5_1', 32820)
GL_UNSIGNED_SHORT_5_6_5 = Enum('GL_UNSIGNED_SHORT_5_6_5', 33635)
GL_VALIDATE_STATUS = Enum('GL_VALIDATE_STATUS', 35715)
GL_VENDOR = Enum('GL_VENDOR', 7936)
GL_VERSION = Enum('GL_VERSION', 7938)
GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = Enum('GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING', 34975)
GL_VERTEX_ATTRIB_ARRAY_ENABLED = Enum('GL_VERTEX_ATTRIB_ARRAY_ENABLED', 34338)
GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = Enum('GL_VERTEX_ATTRIB_ARRAY_NORMALIZED', 34922)
GL_VERTEX_ATTRIB_ARRAY_POINTER = Enum('GL_VERTEX_ATTRIB_ARRAY_POINTER', 34373)
GL_VERTEX_ATTRIB_ARRAY_SIZE = Enum('GL_VERTEX_ATTRIB_ARRAY_SIZE', 34339)
GL_VERTEX_ATTRIB_ARRAY_STRIDE = Enum('GL_VERTEX_ATTRIB_ARRAY_STRIDE', 34340)
GL_VERTEX_ATTRIB_ARRAY_TYPE = Enum('GL_VERTEX_ATTRIB_ARRAY_TYPE', 34341)
GL_VERTEX_SHADER = Enum('GL_VERTEX_SHADER', 35633)
GL_VIEWPORT = Enum('GL_VIEWPORT', 2978)
GL_ZERO = Enum('GL_ZERO', 0)


ENUM_MAP = {}
for ob in list(globals().values()):
    if repr(ob).startswith('GL_'):
        ENUM_MAP[int(ob)] = ob
del ob

########NEW FILE########
__FILENAME__ = _desktop
"""

THIS CODE IS AUTO-GENERATED. DO NOT EDIT.

Subset of desktop GL API compatible with GL ES 2.0

"""

import ctypes
from .desktop import _lib, _get_gl_func


# void = glActiveTexture(GLenum texture)
def glActiveTexture(texture):
    try:
        nativefunc = glActiveTexture._native
    except AttributeError:
        nativefunc = glActiveTexture._native = _get_gl_func("glActiveTexture", None, (ctypes.c_uint,))
    nativefunc(texture)


# void = glAttachShader(GLuint program, GLuint shader)
def glAttachShader(program, shader):
    try:
        nativefunc = glAttachShader._native
    except AttributeError:
        nativefunc = glAttachShader._native = _get_gl_func("glAttachShader", None, (ctypes.c_uint, ctypes.c_uint,))
    nativefunc(program, shader)


# void = glBindAttribLocation(GLuint program, GLuint index, GLchar* name)
def glBindAttribLocation(program, index, name):
    name = ctypes.c_char_p(name.encode('utf-8'))
    try:
        nativefunc = glBindAttribLocation._native
    except AttributeError:
        nativefunc = glBindAttribLocation._native = _get_gl_func("glBindAttribLocation", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_char_p,))
    res = nativefunc(program, index, name)


# void = glBindBuffer(GLenum target, GLuint buffer)
def glBindBuffer(target, buffer):
    try:
        nativefunc = glBindBuffer._native
    except AttributeError:
        nativefunc = glBindBuffer._native = _get_gl_func("glBindBuffer", None, (ctypes.c_uint, ctypes.c_uint,))
    nativefunc(target, buffer)


# void = glBindFramebuffer(GLenum target, GLuint framebuffer)
def glBindFramebuffer(target, framebuffer):
    try:
        nativefunc = glBindFramebuffer._native
    except AttributeError:
        nativefunc = glBindFramebuffer._native = _get_gl_func("glBindFramebuffer", None, (ctypes.c_uint, ctypes.c_uint,))
    nativefunc(target, framebuffer)


# void = glBindRenderbuffer(GLenum target, GLuint renderbuffer)
def glBindRenderbuffer(target, renderbuffer):
    try:
        nativefunc = glBindRenderbuffer._native
    except AttributeError:
        nativefunc = glBindRenderbuffer._native = _get_gl_func("glBindRenderbuffer", None, (ctypes.c_uint, ctypes.c_uint,))
    nativefunc(target, renderbuffer)


# void = glBindTexture(GLenum target, GLuint texture)
def glBindTexture(target, texture):
    try:
        nativefunc = glBindTexture._native
    except AttributeError:
        nativefunc = glBindTexture._native = _get_gl_func("glBindTexture", None, (ctypes.c_uint, ctypes.c_uint,))
    nativefunc(target, texture)


# void = glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
def glBlendColor(red, green, blue, alpha):
    try:
        nativefunc = glBlendColor._native
    except AttributeError:
        nativefunc = glBlendColor._native = _get_gl_func("glBlendColor", None, (ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,))
    nativefunc(red, green, blue, alpha)


# void = glBlendEquation(GLenum mode)
def glBlendEquation(mode):
    try:
        nativefunc = glBlendEquation._native
    except AttributeError:
        nativefunc = glBlendEquation._native = _get_gl_func("glBlendEquation", None, (ctypes.c_uint,))
    nativefunc(mode)


# void = glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
def glBlendEquationSeparate(modeRGB, modeAlpha):
    try:
        nativefunc = glBlendEquationSeparate._native
    except AttributeError:
        nativefunc = glBlendEquationSeparate._native = _get_gl_func("glBlendEquationSeparate", None, (ctypes.c_uint, ctypes.c_uint,))
    nativefunc(modeRGB, modeAlpha)


# void = glBlendFunc(GLenum sfactor, GLenum dfactor)
def glBlendFunc(sfactor, dfactor):
    try:
        nativefunc = glBlendFunc._native
    except AttributeError:
        nativefunc = glBlendFunc._native = _get_gl_func("glBlendFunc", None, (ctypes.c_uint, ctypes.c_uint,))
    nativefunc(sfactor, dfactor)


# void = glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
def glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha):
    try:
        nativefunc = glBlendFuncSeparate._native
    except AttributeError:
        nativefunc = glBlendFuncSeparate._native = _get_gl_func("glBlendFuncSeparate", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,))
    nativefunc(srcRGB, dstRGB, srcAlpha, dstAlpha)


# void = glBufferData(GLenum target, GLsizeiptr size, GLvoid* data, GLenum usage)
def glBufferData(target, data, usage):
    """ Data can be numpy array or the size of data to allocate.
    """
    if isinstance(data, int):
        size = data
        data = ctypes.c_voidp(0)
    else:
        if not data.flags['C_CONTIGUOUS'] or not data.flags['ALIGNED']:
            data = data.copy('C')
        data_ = data
        size = data_.nbytes
        data = data_.ctypes.data
    try:
        nativefunc = glBufferData._native
    except AttributeError:
        nativefunc = glBufferData._native = _get_gl_func("glBufferData", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_void_p, ctypes.c_uint,))
    res = nativefunc(target, size, data, usage)


# void = glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid* data)
def glBufferSubData(target, offset, data):
    if not data.flags['C_CONTIGUOUS']:
        data = data.copy('C')
    data_ = data
    size = data_.nbytes
    data = data_.ctypes.data
    try:
        nativefunc = glBufferSubData._native
    except AttributeError:
        nativefunc = glBufferSubData._native = _get_gl_func("glBufferSubData", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_void_p,))
    res = nativefunc(target, offset, size, data)


# GLenum = glCheckFramebufferStatus(GLenum target)
def glCheckFramebufferStatus(target):
    try:
        nativefunc = glCheckFramebufferStatus._native
    except AttributeError:
        nativefunc = glCheckFramebufferStatus._native = _get_gl_func("glCheckFramebufferStatus", ctypes.c_uint, (ctypes.c_uint,))
    return nativefunc(target)


# void = glClear(GLbitfield mask)
def glClear(mask):
    try:
        nativefunc = glClear._native
    except AttributeError:
        nativefunc = glClear._native = _get_gl_func("glClear", None, (ctypes.c_uint,))
    nativefunc(mask)


# void = glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
def glClearColor(red, green, blue, alpha):
    try:
        nativefunc = glClearColor._native
    except AttributeError:
        nativefunc = glClearColor._native = _get_gl_func("glClearColor", None, (ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,))
    nativefunc(red, green, blue, alpha)


# void = glClearDepthf(GLclampf depth)
def glClearDepth(depth):
    try:
        nativefunc = glClearDepth._native
    except AttributeError:
        nativefunc = glClearDepth._native = _get_gl_func("glClearDepth", None, (ctypes.c_double,))
    nativefunc(depth)


# void = glClearStencil(GLint s)
def glClearStencil(s):
    try:
        nativefunc = glClearStencil._native
    except AttributeError:
        nativefunc = glClearStencil._native = _get_gl_func("glClearStencil", None, (ctypes.c_int,))
    nativefunc(s)


# void = glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
def glColorMask(red, green, blue, alpha):
    try:
        nativefunc = glColorMask._native
    except AttributeError:
        nativefunc = glColorMask._native = _get_gl_func("glColorMask", None, (ctypes.c_bool, ctypes.c_bool, ctypes.c_bool, ctypes.c_bool,))
    nativefunc(red, green, blue, alpha)


# void = glCompileShader(GLuint shader)
def glCompileShader(shader):
    try:
        nativefunc = glCompileShader._native
    except AttributeError:
        nativefunc = glCompileShader._native = _get_gl_func("glCompileShader", None, (ctypes.c_uint,))
    nativefunc(shader)


# void = glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLvoid* data)
def glCompressedTexImage2D(target, level, internalformat, width, height, border, data):
    # border = 0  # set in args
    if not data.flags['C_CONTIGUOUS']:
        data = data.copy('C')
    data_ = data
    size = data_.size
    data = data_.ctypes.data
    try:
        nativefunc = glCompressedTexImage2D._native
    except AttributeError:
        nativefunc = glCompressedTexImage2D._native = _get_gl_func("glCompressedTexImage2D", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_void_p,))
    res = nativefunc(target, level, internalformat, width, height, border, imageSize, data)


# void = glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLvoid* data)
def glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data):
    if not data.flags['C_CONTIGUOUS']:
        data = data.copy('C')
    data_ = data
    size = data_.size
    data = data_.ctypes.data
    try:
        nativefunc = glCompressedTexSubImage2D._native
    except AttributeError:
        nativefunc = glCompressedTexSubImage2D._native = _get_gl_func("glCompressedTexSubImage2D", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_int, ctypes.c_void_p,))
    res = nativefunc(target, level, xoffset, yoffset, width, height, format, imageSize, data)


# void = glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
def glCopyTexImage2D(target, level, internalformat, x, y, width, height, border):
    try:
        nativefunc = glCopyTexImage2D._native
    except AttributeError:
        nativefunc = glCopyTexImage2D._native = _get_gl_func("glCopyTexImage2D", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))
    nativefunc(target, level, internalformat, x, y, width, height, border)


# void = glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
def glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height):
    try:
        nativefunc = glCopyTexSubImage2D._native
    except AttributeError:
        nativefunc = glCopyTexSubImage2D._native = _get_gl_func("glCopyTexSubImage2D", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))
    nativefunc(target, level, xoffset, yoffset, x, y, width, height)


# GLuint = glCreateProgram()
def glCreateProgram():
    try:
        nativefunc = glCreateProgram._native
    except AttributeError:
        nativefunc = glCreateProgram._native = _get_gl_func("glCreateProgram", ctypes.c_uint, ())
    return nativefunc()


# GLuint = glCreateShader(GLenum type)
def glCreateShader(type):
    try:
        nativefunc = glCreateShader._native
    except AttributeError:
        nativefunc = glCreateShader._native = _get_gl_func("glCreateShader", ctypes.c_uint, (ctypes.c_uint,))
    return nativefunc(type)


# void = glCullFace(GLenum mode)
def glCullFace(mode):
    try:
        nativefunc = glCullFace._native
    except AttributeError:
        nativefunc = glCullFace._native = _get_gl_func("glCullFace", None, (ctypes.c_uint,))
    nativefunc(mode)


# void = glDeleteBuffers(GLsizei n, GLuint* buffers)
def glDeleteBuffer(buffer):
    n = 1
    buffers = (ctypes.c_uint*n)(buffer)
    try:
        nativefunc = glDeleteBuffer._native
    except AttributeError:
        nativefunc = glDeleteBuffer._native = _get_gl_func("glDeleteBuffers", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))
    res = nativefunc(n, buffers)


# void = glDeleteFramebuffers(GLsizei n, GLuint* framebuffers)
def glDeleteFramebuffer(framebuffer):
    n = 1
    framebuffers = (ctypes.c_uint*n)(framebuffer)
    try:
        nativefunc = glDeleteFramebuffer._native
    except AttributeError:
        nativefunc = glDeleteFramebuffer._native = _get_gl_func("glDeleteFramebuffers", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))
    res = nativefunc(n, framebuffers)


# void = glDeleteProgram(GLuint program)
def glDeleteProgram(program):
    try:
        nativefunc = glDeleteProgram._native
    except AttributeError:
        nativefunc = glDeleteProgram._native = _get_gl_func("glDeleteProgram", None, (ctypes.c_uint,))
    nativefunc(program)


# void = glDeleteRenderbuffers(GLsizei n, GLuint* renderbuffers)
def glDeleteRenderbuffer(renderbuffer):
    n = 1
    renderbuffers = (ctypes.c_uint*n)(renderbuffer)
    try:
        nativefunc = glDeleteRenderbuffer._native
    except AttributeError:
        nativefunc = glDeleteRenderbuffer._native = _get_gl_func("glDeleteRenderbuffers", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))
    res = nativefunc(n, renderbuffers)


# void = glDeleteShader(GLuint shader)
def glDeleteShader(shader):
    try:
        nativefunc = glDeleteShader._native
    except AttributeError:
        nativefunc = glDeleteShader._native = _get_gl_func("glDeleteShader", None, (ctypes.c_uint,))
    nativefunc(shader)


# void = glDeleteTextures(GLsizei n, GLuint* textures)
def glDeleteTexture(texture):
    n = 1
    textures = (ctypes.c_uint*n)(texture)
    try:
        nativefunc = glDeleteTexture._native
    except AttributeError:
        nativefunc = glDeleteTexture._native = _get_gl_func("glDeleteTextures", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))
    res = nativefunc(n, textures)


# void = glDepthFunc(GLenum func)
def glDepthFunc(func):
    try:
        nativefunc = glDepthFunc._native
    except AttributeError:
        nativefunc = glDepthFunc._native = _get_gl_func("glDepthFunc", None, (ctypes.c_uint,))
    nativefunc(func)


# void = glDepthMask(GLboolean flag)
def glDepthMask(flag):
    try:
        nativefunc = glDepthMask._native
    except AttributeError:
        nativefunc = glDepthMask._native = _get_gl_func("glDepthMask", None, (ctypes.c_bool,))
    nativefunc(flag)


# void = glDepthRangef(GLclampf zNear, GLclampf zFar)
def glDepthRange(zNear, zFar):
    try:
        nativefunc = glDepthRange._native
    except AttributeError:
        nativefunc = glDepthRange._native = _get_gl_func("glDepthRange", None, (ctypes.c_double, ctypes.c_double,))
    nativefunc(zNear, zFar)


# void = glDetachShader(GLuint program, GLuint shader)
def glDetachShader(program, shader):
    try:
        nativefunc = glDetachShader._native
    except AttributeError:
        nativefunc = glDetachShader._native = _get_gl_func("glDetachShader", None, (ctypes.c_uint, ctypes.c_uint,))
    nativefunc(program, shader)


# void = glDisable(GLenum cap)
def glDisable(cap):
    try:
        nativefunc = glDisable._native
    except AttributeError:
        nativefunc = glDisable._native = _get_gl_func("glDisable", None, (ctypes.c_uint,))
    nativefunc(cap)


# void = glDisableVertexAttribArray(GLuint index)
def glDisableVertexAttribArray(index):
    try:
        nativefunc = glDisableVertexAttribArray._native
    except AttributeError:
        nativefunc = glDisableVertexAttribArray._native = _get_gl_func("glDisableVertexAttribArray", None, (ctypes.c_uint,))
    nativefunc(index)


# void = glDrawArrays(GLenum mode, GLint first, GLsizei count)
def glDrawArrays(mode, first, count):
    try:
        nativefunc = glDrawArrays._native
    except AttributeError:
        nativefunc = glDrawArrays._native = _get_gl_func("glDrawArrays", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_int,))
    nativefunc(mode, first, count)


# void = glDrawElements(GLenum mode, GLsizei count, GLenum type, GLvoid* indices)
def glDrawElements(mode, count, type, offset):
    if offset is None:
        offset = ctypes.c_void_p(0)
    elif isinstance(offset, ctypes.c_void_p):
        pass
    elif isinstance(offset, (int, ctypes.c_int)):
        offset = ctypes.c_void_p(int(offset))
    else:
        if not offset.flags['C_CONTIGUOUS']:
            offset = offset.copy('C')
        offset_ = offset
        offset = offset.ctypes.data
    indices = offset
    try:
        nativefunc = glDrawElements._native
    except AttributeError:
        nativefunc = glDrawElements._native = _get_gl_func("glDrawElements", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_void_p,))
    res = nativefunc(mode, count, type, indices)


# void = glEnable(GLenum cap)
def glEnable(cap):
    try:
        nativefunc = glEnable._native
    except AttributeError:
        nativefunc = glEnable._native = _get_gl_func("glEnable", None, (ctypes.c_uint,))
    nativefunc(cap)


# void = glEnableVertexAttribArray(GLuint index)
def glEnableVertexAttribArray(index):
    try:
        nativefunc = glEnableVertexAttribArray._native
    except AttributeError:
        nativefunc = glEnableVertexAttribArray._native = _get_gl_func("glEnableVertexAttribArray", None, (ctypes.c_uint,))
    nativefunc(index)


# void = glFinish()
def glFinish():
    try:
        nativefunc = glFinish._native
    except AttributeError:
        nativefunc = glFinish._native = _get_gl_func("glFinish", None, ())
    nativefunc()


# void = glFlush()
def glFlush():
    try:
        nativefunc = glFlush._native
    except AttributeError:
        nativefunc = glFlush._native = _get_gl_func("glFlush", None, ())
    nativefunc()


# void = glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
def glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer):
    try:
        nativefunc = glFramebufferRenderbuffer._native
    except AttributeError:
        nativefunc = glFramebufferRenderbuffer._native = _get_gl_func("glFramebufferRenderbuffer", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,))
    nativefunc(target, attachment, renderbuffertarget, renderbuffer)


# void = glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
def glFramebufferTexture2D(target, attachment, textarget, texture, level):
    try:
        nativefunc = glFramebufferTexture2D._native
    except AttributeError:
        nativefunc = glFramebufferTexture2D._native = _get_gl_func("glFramebufferTexture2D", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_int,))
    nativefunc(target, attachment, textarget, texture, level)


# void = glFrontFace(GLenum mode)
def glFrontFace(mode):
    try:
        nativefunc = glFrontFace._native
    except AttributeError:
        nativefunc = glFrontFace._native = _get_gl_func("glFrontFace", None, (ctypes.c_uint,))
    nativefunc(mode)


# void = glGenBuffers(GLsizei n, GLuint* buffers)
def glCreateBuffer():
    n = 1
    buffers = (ctypes.c_uint*n)()
    try:
        nativefunc = glCreateBuffer._native
    except AttributeError:
        nativefunc = glCreateBuffer._native = _get_gl_func("glGenBuffers", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))
    res = nativefunc(n, buffers)
    return buffers[0]


# void = glGenFramebuffers(GLsizei n, GLuint* framebuffers)
def glCreateFramebuffer():
    n = 1
    framebuffers = (ctypes.c_uint*n)()
    try:
        nativefunc = glCreateFramebuffer._native
    except AttributeError:
        nativefunc = glCreateFramebuffer._native = _get_gl_func("glGenFramebuffers", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))
    res = nativefunc(n, framebuffers)
    return framebuffers[0]


# void = glGenRenderbuffers(GLsizei n, GLuint* renderbuffers)
def glCreateRenderbuffer():
    n = 1
    renderbuffers = (ctypes.c_uint*n)()
    try:
        nativefunc = glCreateRenderbuffer._native
    except AttributeError:
        nativefunc = glCreateRenderbuffer._native = _get_gl_func("glGenRenderbuffers", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))
    res = nativefunc(n, renderbuffers)
    return renderbuffers[0]


# void = glGenTextures(GLsizei n, GLuint* textures)
def glCreateTexture():
    n = 1
    textures = (ctypes.c_uint*n)()
    try:
        nativefunc = glCreateTexture._native
    except AttributeError:
        nativefunc = glCreateTexture._native = _get_gl_func("glGenTextures", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))
    res = nativefunc(n, textures)
    return textures[0]


# void = glGenerateMipmap(GLenum target)
def glGenerateMipmap(target):
    try:
        nativefunc = glGenerateMipmap._native
    except AttributeError:
        nativefunc = glGenerateMipmap._native = _get_gl_func("glGenerateMipmap", None, (ctypes.c_uint,))
    nativefunc(target)


# void = glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
def glGetActiveAttrib(program, index):
    bufsize = 256
    length = (ctypes.c_int*1)()
    size = (ctypes.c_int*1)()
    type = (ctypes.c_uint*1)()
    name = ctypes.create_string_buffer(bufsize)
    try:
        nativefunc = glGetActiveAttrib._native
    except AttributeError:
        nativefunc = glGetActiveAttrib._native = _get_gl_func("glGetActiveAttrib", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_uint), ctypes.c_char_p,))
    res = nativefunc(program, index, bufsize, length, size, type, name)
    name = name[:length[0]].decode('utf-8')
    return name, size[0], type[0]


# void = glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
def glGetActiveUniform(program, index):
    bufsize = 256
    length = (ctypes.c_int*1)()
    size = (ctypes.c_int*1)()
    type = (ctypes.c_uint*1)()
    name = ctypes.create_string_buffer(bufsize)
    try:
        nativefunc = glGetActiveUniform._native
    except AttributeError:
        nativefunc = glGetActiveUniform._native = _get_gl_func("glGetActiveUniform", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_uint), ctypes.c_char_p,))
    res = nativefunc(program, index, bufsize, length, size, type, name)
    name = name[:length[0]].decode('utf-8')
    return name, size[0], type[0]


# void = glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders)
def glGetAttachedShaders(program):
    maxcount = 256
    count = (ctypes.c_int*1)()
    shaders = (ctypes.c_uint*maxcount)()
    try:
        nativefunc = glGetAttachedShaders._native
    except AttributeError:
        nativefunc = glGetAttachedShaders._native = _get_gl_func("glGetAttachedShaders", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_uint),))
    res = nativefunc(program, maxcount, count, shaders)
    return tuple(shaders[:count[0]])


# GLint = glGetAttribLocation(GLuint program, GLchar* name)
def glGetAttribLocation(program, name):
    name = ctypes.c_char_p(name.encode('utf-8'))
    try:
        nativefunc = glGetAttribLocation._native
    except AttributeError:
        nativefunc = glGetAttribLocation._native = _get_gl_func("glGetAttribLocation", ctypes.c_int, (ctypes.c_uint, ctypes.c_char_p,))
    res = nativefunc(program, name)
    return res


# void = glGetBooleanv(GLenum pname, GLboolean* params)
def _glGetBooleanv(pname):
    params = (ctypes.c_bool*1)()
    try:
        nativefunc = _glGetBooleanv._native
    except AttributeError:
        nativefunc = _glGetBooleanv._native = _get_gl_func("glGetBooleanv", None, (ctypes.c_uint, ctypes.POINTER(ctypes.c_bool),))
    res = nativefunc(pname, params)
    return params[0]


# void = glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params)
def glGetBufferParameter(target, pname):
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    try:
        nativefunc = glGetBufferParameter._native
    except AttributeError:
        nativefunc = glGetBufferParameter._native = _get_gl_func("glGetBufferParameteriv", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))
    res = nativefunc(target, pname, params)
    return params[0]


# GLenum = glGetError()
def glGetError():
    try:
        nativefunc = glGetError._native
    except AttributeError:
        nativefunc = glGetError._native = _get_gl_func("glGetError", ctypes.c_uint, ())
    return nativefunc()


# void = glGetFloatv(GLenum pname, GLfloat* params)
def _glGetFloatv(pname):
    n = 16
    d = float('Inf')
    params = (ctypes.c_float*n)(*[d for i in range(n)])
    try:
        nativefunc = _glGetFloatv._native
    except AttributeError:
        nativefunc = _glGetFloatv._native = _get_gl_func("glGetFloatv", None, (ctypes.c_uint, ctypes.POINTER(ctypes.c_float),))
    res = nativefunc(pname, params)
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)


# void = glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params)
def glGetFramebufferAttachmentParameter(target, attachment, pname):
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    try:
        nativefunc = glGetFramebufferAttachmentParameter._native
    except AttributeError:
        nativefunc = glGetFramebufferAttachmentParameter._native = _get_gl_func("glGetFramebufferAttachmentParameteriv", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))
    res = nativefunc(target, attachment, pname, params)
    return params[0]


# void = glGetIntegerv(GLenum pname, GLint* params)
def _glGetIntegerv(pname):
    n = 16
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*n)(*[d for i in range(n)])
    try:
        nativefunc = _glGetIntegerv._native
    except AttributeError:
        nativefunc = _glGetIntegerv._native = _get_gl_func("glGetIntegerv", None, (ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))
    res = nativefunc(pname, params)
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)


# void = glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog)
def glGetProgramInfoLog(program):
    bufsize = 1024
    length = (ctypes.c_int*1)()
    infolog = ctypes.create_string_buffer(bufsize)
    try:
        nativefunc = glGetProgramInfoLog._native
    except AttributeError:
        nativefunc = glGetProgramInfoLog._native = _get_gl_func("glGetProgramInfoLog", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.c_char_p,))
    res = nativefunc(program, bufsize, length, infolog)
    return infolog[:length[0]].decode('utf-8')


# void = glGetProgramiv(GLuint program, GLenum pname, GLint* params)
def glGetProgramParameter(program, pname):
    params = (ctypes.c_int*1)()
    try:
        nativefunc = glGetProgramParameter._native
    except AttributeError:
        nativefunc = glGetProgramParameter._native = _get_gl_func("glGetProgramiv", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))
    res = nativefunc(program, pname, params)
    return params[0]


# void = glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params)
def glGetRenderbufferParameter(target, pname):
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    try:
        nativefunc = glGetRenderbufferParameter._native
    except AttributeError:
        nativefunc = glGetRenderbufferParameter._native = _get_gl_func("glGetRenderbufferParameteriv", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))
    res = nativefunc(target, pname, params)
    return params[0]


# void = glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog)
def glGetShaderInfoLog(shader):
    bufsize = 1024
    length = (ctypes.c_int*1)()
    infolog = ctypes.create_string_buffer(bufsize)
    try:
        nativefunc = glGetShaderInfoLog._native
    except AttributeError:
        nativefunc = glGetShaderInfoLog._native = _get_gl_func("glGetShaderInfoLog", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.c_char_p,))
    res = nativefunc(shader, bufsize, length, infolog)
    return infolog[:length[0]].decode('utf-8')


# void = glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision)
def glGetShaderPrecisionFormat(shadertype, precisiontype):
    range = (ctypes.c_int*1)()
    precision = (ctypes.c_int*1)()
    try:
        nativefunc = glGetShaderPrecisionFormat._native
    except AttributeError:
        nativefunc = glGetShaderPrecisionFormat._native = _get_gl_func("glGetShaderPrecisionFormat", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int),))
    res = nativefunc(shadertype, precisiontype, range, precision)
    return range[0], precision[0]


# void = glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source)
def glGetShaderSource(shader):
    bufsize = 1024*1024
    length = (ctypes.c_int*1)()
    source = (ctypes.c_char*bufsize)()
    try:
        nativefunc = glGetShaderSource._native
    except AttributeError:
        nativefunc = glGetShaderSource._native = _get_gl_func("glGetShaderSource", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.c_char_p,))
    res = nativefunc(shader, bufsize, length, source)
    return source.value[:length[0]].decode('utf-8')


# void = glGetShaderiv(GLuint shader, GLenum pname, GLint* params)
def glGetShaderParameter(shader, pname):
    params = (ctypes.c_int*1)()
    try:
        nativefunc = glGetShaderParameter._native
    except AttributeError:
        nativefunc = glGetShaderParameter._native = _get_gl_func("glGetShaderiv", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))
    res = nativefunc(shader, pname, params)
    return params[0]


# GLubyte* = glGetString(GLenum name)
def glGetParameter(pname):
    if pname in [33902, 33901, 32773, 3106, 2931, 2928,
                 2849, 32824, 10752, 32938]:
        # GL_ALIASED_LINE_WIDTH_RANGE GL_ALIASED_POINT_SIZE_RANGE
        # GL_BLEND_COLOR GL_COLOR_CLEAR_VALUE GL_DEPTH_CLEAR_VALUE
        # GL_DEPTH_RANGE GL_LINE_WIDTH GL_POLYGON_OFFSET_FACTOR
        # GL_POLYGON_OFFSET_UNITS GL_SAMPLE_COVERAGE_VALUE
        return _glGetFloatv(pname)
    elif pname in [7936, 7937, 7938, 35724, 7939]:
        # GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION,
        # GL_EXTENSIONS are strings
        pass  # string handled below
    else:
        return _glGetIntegerv(pname)
    name = pname
    try:
        nativefunc = glGetParameter._native
    except AttributeError:
        nativefunc = glGetParameter._native = _get_gl_func("glGetString", ctypes.c_char_p, (ctypes.c_uint,))
    res = nativefunc(name)
    return res.decode('utf-8') if res else ''


# void = glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params)
def glGetTexParameter(target, pname):
    d = float('Inf')
    params = (ctypes.c_float*1)(d)
    try:
        nativefunc = glGetTexParameter._native
    except AttributeError:
        nativefunc = glGetTexParameter._native = _get_gl_func("glGetTexParameterfv", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_float),))
    res = nativefunc(target, pname, params)
    return params[0]


# void = glGetUniformfv(GLuint program, GLint location, GLfloat* params)
def glGetUniform(program, location):
    n = 16
    d = float('Inf')
    params = (ctypes.c_float*n)(*[d for i in range(n)])
    try:
        nativefunc = glGetUniform._native
    except AttributeError:
        nativefunc = glGetUniform._native = _get_gl_func("glGetUniformfv", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_float),))
    res = nativefunc(program, location, params)
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)


# GLint = glGetUniformLocation(GLuint program, GLchar* name)
def glGetUniformLocation(program, name):
    name = ctypes.c_char_p(name.encode('utf-8'))
    try:
        nativefunc = glGetUniformLocation._native
    except AttributeError:
        nativefunc = glGetUniformLocation._native = _get_gl_func("glGetUniformLocation", ctypes.c_int, (ctypes.c_uint, ctypes.c_char_p,))
    res = nativefunc(program, name)
    return res


# void = glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params)
def glGetVertexAttrib(index, pname):
    n = 4
    d = float('Inf')
    params = (ctypes.c_float*n)(*[d for i in range(n)])
    try:
        nativefunc = glGetVertexAttrib._native
    except AttributeError:
        nativefunc = glGetVertexAttrib._native = _get_gl_func("glGetVertexAttribfv", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_float),))
    res = nativefunc(index, pname, params)
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)


# void = glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer)
def glGetVertexAttribOffset(index, pname):
    pointer = (ctypes.c_void_p*1)()
    try:
        nativefunc = glGetVertexAttribOffset._native
    except AttributeError:
        nativefunc = glGetVertexAttribOffset._native = _get_gl_func("glGetVertexAttribPointerv", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_void_p),))
    res = nativefunc(index, pname, pointer)
    return pointer[0] or 0


# void = glHint(GLenum target, GLenum mode)
def glHint(target, mode):
    try:
        nativefunc = glHint._native
    except AttributeError:
        nativefunc = glHint._native = _get_gl_func("glHint", None, (ctypes.c_uint, ctypes.c_uint,))
    nativefunc(target, mode)


# GLboolean = glIsBuffer(GLuint buffer)
def glIsBuffer(buffer):
    try:
        nativefunc = glIsBuffer._native
    except AttributeError:
        nativefunc = glIsBuffer._native = _get_gl_func("glIsBuffer", ctypes.c_bool, (ctypes.c_uint,))
    return nativefunc(buffer)


# GLboolean = glIsEnabled(GLenum cap)
def glIsEnabled(cap):
    try:
        nativefunc = glIsEnabled._native
    except AttributeError:
        nativefunc = glIsEnabled._native = _get_gl_func("glIsEnabled", ctypes.c_bool, (ctypes.c_uint,))
    return nativefunc(cap)


# GLboolean = glIsFramebuffer(GLuint framebuffer)
def glIsFramebuffer(framebuffer):
    try:
        nativefunc = glIsFramebuffer._native
    except AttributeError:
        nativefunc = glIsFramebuffer._native = _get_gl_func("glIsFramebuffer", ctypes.c_bool, (ctypes.c_uint,))
    return nativefunc(framebuffer)


# GLboolean = glIsProgram(GLuint program)
def glIsProgram(program):
    try:
        nativefunc = glIsProgram._native
    except AttributeError:
        nativefunc = glIsProgram._native = _get_gl_func("glIsProgram", ctypes.c_bool, (ctypes.c_uint,))
    return nativefunc(program)


# GLboolean = glIsRenderbuffer(GLuint renderbuffer)
def glIsRenderbuffer(renderbuffer):
    try:
        nativefunc = glIsRenderbuffer._native
    except AttributeError:
        nativefunc = glIsRenderbuffer._native = _get_gl_func("glIsRenderbuffer", ctypes.c_bool, (ctypes.c_uint,))
    return nativefunc(renderbuffer)


# GLboolean = glIsShader(GLuint shader)
def glIsShader(shader):
    try:
        nativefunc = glIsShader._native
    except AttributeError:
        nativefunc = glIsShader._native = _get_gl_func("glIsShader", ctypes.c_bool, (ctypes.c_uint,))
    return nativefunc(shader)


# GLboolean = glIsTexture(GLuint texture)
def glIsTexture(texture):
    try:
        nativefunc = glIsTexture._native
    except AttributeError:
        nativefunc = glIsTexture._native = _get_gl_func("glIsTexture", ctypes.c_bool, (ctypes.c_uint,))
    return nativefunc(texture)


# void = glLineWidth(GLfloat width)
def glLineWidth(width):
    try:
        nativefunc = glLineWidth._native
    except AttributeError:
        nativefunc = glLineWidth._native = _get_gl_func("glLineWidth", None, (ctypes.c_float,))
    nativefunc(width)


# void = glLinkProgram(GLuint program)
def glLinkProgram(program):
    try:
        nativefunc = glLinkProgram._native
    except AttributeError:
        nativefunc = glLinkProgram._native = _get_gl_func("glLinkProgram", None, (ctypes.c_uint,))
    nativefunc(program)


# void = glPixelStorei(GLenum pname, GLint param)
def glPixelStorei(pname, param):
    try:
        nativefunc = glPixelStorei._native
    except AttributeError:
        nativefunc = glPixelStorei._native = _get_gl_func("glPixelStorei", None, (ctypes.c_uint, ctypes.c_int,))
    nativefunc(pname, param)


# void = glPolygonOffset(GLfloat factor, GLfloat units)
def glPolygonOffset(factor, units):
    try:
        nativefunc = glPolygonOffset._native
    except AttributeError:
        nativefunc = glPolygonOffset._native = _get_gl_func("glPolygonOffset", None, (ctypes.c_float, ctypes.c_float,))
    nativefunc(factor, units)


# void = glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
def glReadPixels(x, y, width, height, format, type):
    # GL_ALPHA, GL_RGB, GL_RGBA
    t = {6406:1, 6407:3, 6408:4}[format]
    # we kind of only support type GL_UNSIGNED_BYTE
    size = int(width*height*t)
    pixels = ctypes.create_string_buffer(size)
    try:
        nativefunc = glReadPixels._native
    except AttributeError:
        nativefunc = glReadPixels._native = _get_gl_func("glReadPixels", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_uint, ctypes.c_void_p,))
    res = nativefunc(x, y, width, height, format, type, pixels)
    return pixels[:]


# void = glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
def glRenderbufferStorage(target, internalformat, width, height):
    try:
        nativefunc = glRenderbufferStorage._native
    except AttributeError:
        nativefunc = glRenderbufferStorage._native = _get_gl_func("glRenderbufferStorage", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.c_int,))
    nativefunc(target, internalformat, width, height)


# void = glSampleCoverage(GLclampf value, GLboolean invert)
def glSampleCoverage(value, invert):
    try:
        nativefunc = glSampleCoverage._native
    except AttributeError:
        nativefunc = glSampleCoverage._native = _get_gl_func("glSampleCoverage", None, (ctypes.c_float, ctypes.c_bool,))
    nativefunc(value, invert)


# void = glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
def glScissor(x, y, width, height):
    try:
        nativefunc = glScissor._native
    except AttributeError:
        nativefunc = glScissor._native = _get_gl_func("glScissor", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))
    nativefunc(x, y, width, height)


# void = glShaderSource(GLuint shader, GLsizei count, GLchar** string, GLint* length)
def glShaderSource(shader, source):
    # Some implementation do not like getting a list of single chars
    if isinstance(source, (tuple, list)):
        strings = [s for s in source]
    else:
        strings = [source]
    count = len(strings)
    string = (ctypes.c_char_p*count)(*[s.encode('utf-8') for s in strings])
    length = (ctypes.c_int*count)(*[len(s) for s in strings])
    try:
        nativefunc = glShaderSource._native
    except AttributeError:
        nativefunc = glShaderSource._native = _get_gl_func("glShaderSource", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_int),))
    res = nativefunc(shader, count, string, length)


# void = glStencilFunc(GLenum func, GLint ref, GLuint mask)
def glStencilFunc(func, ref, mask):
    try:
        nativefunc = glStencilFunc._native
    except AttributeError:
        nativefunc = glStencilFunc._native = _get_gl_func("glStencilFunc", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_uint,))
    nativefunc(func, ref, mask)


# void = glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
def glStencilFuncSeparate(face, func, ref, mask):
    try:
        nativefunc = glStencilFuncSeparate._native
    except AttributeError:
        nativefunc = glStencilFuncSeparate._native = _get_gl_func("glStencilFuncSeparate", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.c_uint,))
    nativefunc(face, func, ref, mask)


# void = glStencilMask(GLuint mask)
def glStencilMask(mask):
    try:
        nativefunc = glStencilMask._native
    except AttributeError:
        nativefunc = glStencilMask._native = _get_gl_func("glStencilMask", None, (ctypes.c_uint,))
    nativefunc(mask)


# void = glStencilMaskSeparate(GLenum face, GLuint mask)
def glStencilMaskSeparate(face, mask):
    try:
        nativefunc = glStencilMaskSeparate._native
    except AttributeError:
        nativefunc = glStencilMaskSeparate._native = _get_gl_func("glStencilMaskSeparate", None, (ctypes.c_uint, ctypes.c_uint,))
    nativefunc(face, mask)


# void = glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
def glStencilOp(fail, zfail, zpass):
    try:
        nativefunc = glStencilOp._native
    except AttributeError:
        nativefunc = glStencilOp._native = _get_gl_func("glStencilOp", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,))
    nativefunc(fail, zfail, zpass)


# void = glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
def glStencilOpSeparate(face, fail, zfail, zpass):
    try:
        nativefunc = glStencilOpSeparate._native
    except AttributeError:
        nativefunc = glStencilOpSeparate._native = _get_gl_func("glStencilOpSeparate", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,))
    nativefunc(face, fail, zfail, zpass)


# void = glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLvoid* pixels)
def glTexImage2D(target, level, internalformat, format, type, pixels):
    border = 0
    if isinstance(pixels, (tuple, list)):
        height, width = pixels
        pixels = ctypes.c_void_p(0)
        pixels = None
    else:
        if not pixels.flags['C_CONTIGUOUS']:
            pixels = pixels.copy('C')
        pixels_ = pixels
        pixels = pixels_.ctypes.data
        height, width = pixels_.shape[:2]
    try:
        nativefunc = glTexImage2D._native
    except AttributeError:
        nativefunc = glTexImage2D._native = _get_gl_func("glTexImage2D", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_uint, ctypes.c_void_p,))
    res = nativefunc(target, level, internalformat, width, height, border, format, type, pixels)


def glTexParameterf(target, pname, param):
    try:
        nativefunc = glTexParameterf._native
    except AttributeError:
        nativefunc = glTexParameterf._native = _get_gl_func("glTexParameterf", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_float,))
    nativefunc(target, pname, param)
def glTexParameteri(target, pname, param):
    try:
        nativefunc = glTexParameteri._native
    except AttributeError:
        nativefunc = glTexParameteri._native = _get_gl_func("glTexParameteri", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_int,))
    nativefunc(target, pname, param)


# void = glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
def glTexSubImage2D(target, level, xoffset, yoffset, format, type, pixels):
    if not pixels.flags['C_CONTIGUOUS']:
        pixels = pixels.copy('C')
    pixels_ = pixels
    pixels = pixels_.ctypes.data
    height, width = pixels_.shape[:2]
    try:
        nativefunc = glTexSubImage2D._native
    except AttributeError:
        nativefunc = glTexSubImage2D._native = _get_gl_func("glTexSubImage2D", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_uint, ctypes.c_void_p,))
    res = nativefunc(target, level, xoffset, yoffset, width, height, format, type, pixels)


def glUniform1f(location, v1):
    try:
        nativefunc = glUniform1f._native
    except AttributeError:
        nativefunc = glUniform1f._native = _get_gl_func("glUniform1f", None, (ctypes.c_int, ctypes.c_float,))
    nativefunc(location, v1)
def glUniform2f(location, v1, v2):
    try:
        nativefunc = glUniform2f._native
    except AttributeError:
        nativefunc = glUniform2f._native = _get_gl_func("glUniform2f", None, (ctypes.c_int, ctypes.c_float, ctypes.c_float,))
    nativefunc(location, v1, v2)
def glUniform3f(location, v1, v2, v3):
    try:
        nativefunc = glUniform3f._native
    except AttributeError:
        nativefunc = glUniform3f._native = _get_gl_func("glUniform3f", None, (ctypes.c_int, ctypes.c_float, ctypes.c_float, ctypes.c_float,))
    nativefunc(location, v1, v2, v3)
def glUniform4f(location, v1, v2, v3, v4):
    try:
        nativefunc = glUniform4f._native
    except AttributeError:
        nativefunc = glUniform4f._native = _get_gl_func("glUniform4f", None, (ctypes.c_int, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,))
    nativefunc(location, v1, v2, v3, v4)
def glUniform1i(location, v1):
    try:
        nativefunc = glUniform1i._native
    except AttributeError:
        nativefunc = glUniform1i._native = _get_gl_func("glUniform1i", None, (ctypes.c_int, ctypes.c_int,))
    nativefunc(location, v1)
def glUniform2i(location, v1, v2):
    try:
        nativefunc = glUniform2i._native
    except AttributeError:
        nativefunc = glUniform2i._native = _get_gl_func("glUniform2i", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int,))
    nativefunc(location, v1, v2)
def glUniform3i(location, v1, v2, v3):
    try:
        nativefunc = glUniform3i._native
    except AttributeError:
        nativefunc = glUniform3i._native = _get_gl_func("glUniform3i", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))
    nativefunc(location, v1, v2, v3)
def glUniform4i(location, v1, v2, v3, v4):
    try:
        nativefunc = glUniform4i._native
    except AttributeError:
        nativefunc = glUniform4i._native = _get_gl_func("glUniform4i", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))
    nativefunc(location, v1, v2, v3, v4)
def glUniform1fv(location, count, values):
    values = [float(val) for val in values]
    values = (ctypes.c_float*len(values))(*values)
    try:
        nativefunc = glUniform1fv._native
    except AttributeError:
        nativefunc = glUniform1fv._native = _get_gl_func("glUniform1fv", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),))
    nativefunc(location, count, values)
def glUniform2fv(location, count, values):
    values = [float(val) for val in values]
    values = (ctypes.c_float*len(values))(*values)
    try:
        nativefunc = glUniform2fv._native
    except AttributeError:
        nativefunc = glUniform2fv._native = _get_gl_func("glUniform2fv", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),))
    nativefunc(location, count, values)
def glUniform3fv(location, count, values):
    values = [float(val) for val in values]
    values = (ctypes.c_float*len(values))(*values)
    try:
        nativefunc = glUniform3fv._native
    except AttributeError:
        nativefunc = glUniform3fv._native = _get_gl_func("glUniform3fv", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),))
    nativefunc(location, count, values)
def glUniform4fv(location, count, values):
    values = [float(val) for val in values]
    values = (ctypes.c_float*len(values))(*values)
    try:
        nativefunc = glUniform4fv._native
    except AttributeError:
        nativefunc = glUniform4fv._native = _get_gl_func("glUniform4fv", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),))
    nativefunc(location, count, values)
def glUniform1iv(location, count, values):
    values = [int(val) for val in values]
    values = (ctypes.c_int*len(values))(*values)
    try:
        nativefunc = glUniform1iv._native
    except AttributeError:
        nativefunc = glUniform1iv._native = _get_gl_func("glUniform1iv", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),))
    nativefunc(location, count, values)
def glUniform2iv(location, count, values):
    values = [int(val) for val in values]
    values = (ctypes.c_int*len(values))(*values)
    try:
        nativefunc = glUniform2iv._native
    except AttributeError:
        nativefunc = glUniform2iv._native = _get_gl_func("glUniform2iv", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),))
    nativefunc(location, count, values)
def glUniform3iv(location, count, values):
    values = [int(val) for val in values]
    values = (ctypes.c_int*len(values))(*values)
    try:
        nativefunc = glUniform3iv._native
    except AttributeError:
        nativefunc = glUniform3iv._native = _get_gl_func("glUniform3iv", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),))
    nativefunc(location, count, values)
def glUniform4iv(location, count, values):
    values = [int(val) for val in values]
    values = (ctypes.c_int*len(values))(*values)
    try:
        nativefunc = glUniform4iv._native
    except AttributeError:
        nativefunc = glUniform4iv._native = _get_gl_func("glUniform4iv", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),))
    nativefunc(location, count, values)


def glUniformMatrix2fv(location, count, transpose, values):
    if not values.flags["C_CONTIGUOUS"]:
        values = values.copy()
    assert values.dtype.name == "float32"
    values_ = values
    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))
    try:
        nativefunc = glUniformMatrix2fv._native
    except AttributeError:
        nativefunc = glUniformMatrix2fv._native = _get_gl_func("glUniformMatrix2fv", None, (ctypes.c_int, ctypes.c_int, ctypes.c_bool, ctypes.POINTER(ctypes.c_float),))
    nativefunc(location, count, transpose, values)
def glUniformMatrix3fv(location, count, transpose, values):
    if not values.flags["C_CONTIGUOUS"]:
        values = values.copy()
    assert values.dtype.name == "float32"
    values_ = values
    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))
    try:
        nativefunc = glUniformMatrix3fv._native
    except AttributeError:
        nativefunc = glUniformMatrix3fv._native = _get_gl_func("glUniformMatrix3fv", None, (ctypes.c_int, ctypes.c_int, ctypes.c_bool, ctypes.POINTER(ctypes.c_float),))
    nativefunc(location, count, transpose, values)
def glUniformMatrix4fv(location, count, transpose, values):
    if not values.flags["C_CONTIGUOUS"]:
        values = values.copy()
    assert values.dtype.name == "float32"
    values_ = values
    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))
    try:
        nativefunc = glUniformMatrix4fv._native
    except AttributeError:
        nativefunc = glUniformMatrix4fv._native = _get_gl_func("glUniformMatrix4fv", None, (ctypes.c_int, ctypes.c_int, ctypes.c_bool, ctypes.POINTER(ctypes.c_float),))
    nativefunc(location, count, transpose, values)


# void = glUseProgram(GLuint program)
def glUseProgram(program):
    try:
        nativefunc = glUseProgram._native
    except AttributeError:
        nativefunc = glUseProgram._native = _get_gl_func("glUseProgram", None, (ctypes.c_uint,))
    nativefunc(program)


# void = glValidateProgram(GLuint program)
def glValidateProgram(program):
    try:
        nativefunc = glValidateProgram._native
    except AttributeError:
        nativefunc = glValidateProgram._native = _get_gl_func("glValidateProgram", None, (ctypes.c_uint,))
    nativefunc(program)


def glVertexAttrib1f(index, v1):
    try:
        nativefunc = glVertexAttrib1f._native
    except AttributeError:
        nativefunc = glVertexAttrib1f._native = _get_gl_func("glVertexAttrib1f", None, (ctypes.c_uint, ctypes.c_float,))
    nativefunc(index, v1)
def glVertexAttrib2f(index, v1, v2):
    try:
        nativefunc = glVertexAttrib2f._native
    except AttributeError:
        nativefunc = glVertexAttrib2f._native = _get_gl_func("glVertexAttrib2f", None, (ctypes.c_uint, ctypes.c_float, ctypes.c_float,))
    nativefunc(index, v1, v2)
def glVertexAttrib3f(index, v1, v2, v3):
    try:
        nativefunc = glVertexAttrib3f._native
    except AttributeError:
        nativefunc = glVertexAttrib3f._native = _get_gl_func("glVertexAttrib3f", None, (ctypes.c_uint, ctypes.c_float, ctypes.c_float, ctypes.c_float,))
    nativefunc(index, v1, v2, v3)
def glVertexAttrib4f(index, v1, v2, v3, v4):
    try:
        nativefunc = glVertexAttrib4f._native
    except AttributeError:
        nativefunc = glVertexAttrib4f._native = _get_gl_func("glVertexAttrib4f", None, (ctypes.c_uint, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,))
    nativefunc(index, v1, v2, v3, v4)


# void = glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLvoid* ptr)
def glVertexAttribPointer(indx, size, type, normalized, stride, offset):
    if offset is None:
        offset = ctypes.c_void_p(0)
    elif isinstance(offset, ctypes.c_void_p):
        pass
    elif isinstance(offset, (int, ctypes.c_int)):
        offset = ctypes.c_void_p(int(offset))
    else:
        if not offset.flags['C_CONTIGUOUS']:
            offset = offset.copy('C')
        offset_ = offset
        offset = offset.ctypes.data
        # We need to ensure that the data exists at draw time :(
        # PyOpenGL does this too
        key = '_vert_attr_'+str(indx)
        setattr(glVertexAttribPointer, key, offset_)
    ptr = offset
    try:
        nativefunc = glVertexAttribPointer._native
    except AttributeError:
        nativefunc = glVertexAttribPointer._native = _get_gl_func("glVertexAttribPointer", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_bool, ctypes.c_int, ctypes.c_void_p,))
    res = nativefunc(indx, size, type, normalized, stride, ptr)


# void = glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
def glViewport(x, y, width, height):
    try:
        nativefunc = glViewport._native
    except AttributeError:
        nativefunc = glViewport._native = _get_gl_func("glViewport", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))
    nativefunc(x, y, width, height)



########NEW FILE########
__FILENAME__ = _proxy
"""

THIS CODE IS AUTO-GENERATED. DO NOT EDIT.

Base proxy API for GL ES 2.0.

"""

class BaseGLProxy(object):
    """ Base proxy class for the GL ES 2.0 API. Subclasses should
    implement __call__ to process the API calls.
    """
   
    def __call__(self, funcname, returns, *args):
        raise NotImplementedError()
    
    
    def glShaderSource_compat(self, handle, code):
        return self("glShaderSource_compat", True, handle, code)


    def glActiveTexture(self, texture):
        self("glActiveTexture", False, texture)


    def glAttachShader(self, program, shader):
        self("glAttachShader", False, program, shader)


    def glBindAttribLocation(self, program, index, name):
        self("glBindAttribLocation", False, program, index, name)


    def glBindBuffer(self, target, buffer):
        self("glBindBuffer", False, target, buffer)


    def glBindFramebuffer(self, target, framebuffer):
        self("glBindFramebuffer", False, target, framebuffer)


    def glBindRenderbuffer(self, target, renderbuffer):
        self("glBindRenderbuffer", False, target, renderbuffer)


    def glBindTexture(self, target, texture):
        self("glBindTexture", False, target, texture)


    def glBlendColor(self, red, green, blue, alpha):
        self("glBlendColor", False, red, green, blue, alpha)


    def glBlendEquation(self, mode):
        self("glBlendEquation", False, mode)


    def glBlendEquationSeparate(self, modeRGB, modeAlpha):
        self("glBlendEquationSeparate", False, modeRGB, modeAlpha)


    def glBlendFunc(self, sfactor, dfactor):
        self("glBlendFunc", False, sfactor, dfactor)


    def glBlendFuncSeparate(self, srcRGB, dstRGB, srcAlpha, dstAlpha):
        self("glBlendFuncSeparate", False, srcRGB, dstRGB, srcAlpha, dstAlpha)


    def glBufferData(self, target, data, usage):
        self("glBufferData", False, target, data, usage)


    def glBufferSubData(self, target, offset, data):
        self("glBufferSubData", False, target, offset, data)


    def glCheckFramebufferStatus(self, target):
        return self("glCheckFramebufferStatus", True, target)


    def glClear(self, mask):
        self("glClear", False, mask)


    def glClearColor(self, red, green, blue, alpha):
        self("glClearColor", False, red, green, blue, alpha)


    def glClearDepth(self, depth):
        self("glClearDepth", False, depth)


    def glClearStencil(self, s):
        self("glClearStencil", False, s)


    def glColorMask(self, red, green, blue, alpha):
        self("glColorMask", False, red, green, blue, alpha)


    def glCompileShader(self, shader):
        self("glCompileShader", False, shader)


    def glCompressedTexImage2D(self, target, level, internalformat, width, height, border, data):
        self("glCompressedTexImage2D", False, target, level, internalformat, width, height, border, data)


    def glCompressedTexSubImage2D(self, target, level, xoffset, yoffset, width, height, format, data):
        self("glCompressedTexSubImage2D", False, target, level, xoffset, yoffset, width, height, format, data)


    def glCopyTexImage2D(self, target, level, internalformat, x, y, width, height, border):
        self("glCopyTexImage2D", False, target, level, internalformat, x, y, width, height, border)


    def glCopyTexSubImage2D(self, target, level, xoffset, yoffset, x, y, width, height):
        self("glCopyTexSubImage2D", False, target, level, xoffset, yoffset, x, y, width, height)


    def glCreateProgram(self, ):
        return self("glCreateProgram", True, )


    def glCreateShader(self, type):
        return self("glCreateShader", True, type)


    def glCullFace(self, mode):
        self("glCullFace", False, mode)


    def glDeleteBuffer(self, buffer):
        self("glDeleteBuffer", False, buffer)


    def glDeleteFramebuffer(self, framebuffer):
        self("glDeleteFramebuffer", False, framebuffer)


    def glDeleteProgram(self, program):
        self("glDeleteProgram", False, program)


    def glDeleteRenderbuffer(self, renderbuffer):
        self("glDeleteRenderbuffer", False, renderbuffer)


    def glDeleteShader(self, shader):
        self("glDeleteShader", False, shader)


    def glDeleteTexture(self, texture):
        self("glDeleteTexture", False, texture)


    def glDepthFunc(self, func):
        self("glDepthFunc", False, func)


    def glDepthMask(self, flag):
        self("glDepthMask", False, flag)


    def glDepthRange(self, zNear, zFar):
        self("glDepthRange", False, zNear, zFar)


    def glDetachShader(self, program, shader):
        self("glDetachShader", False, program, shader)


    def glDisable(self, cap):
        self("glDisable", False, cap)


    def glDisableVertexAttribArray(self, index):
        self("glDisableVertexAttribArray", False, index)


    def glDrawArrays(self, mode, first, count):
        self("glDrawArrays", False, mode, first, count)


    def glDrawElements(self, mode, count, type, offset):
        self("glDrawElements", False, mode, count, type, offset)


    def glEnable(self, cap):
        self("glEnable", False, cap)


    def glEnableVertexAttribArray(self, index):
        self("glEnableVertexAttribArray", False, index)


    def glFinish(self, ):
        self("glFinish", False, )


    def glFlush(self, ):
        self("glFlush", False, )


    def glFramebufferRenderbuffer(self, target, attachment, renderbuffertarget, renderbuffer):
        self("glFramebufferRenderbuffer", False, target, attachment, renderbuffertarget, renderbuffer)


    def glFramebufferTexture2D(self, target, attachment, textarget, texture, level):
        self("glFramebufferTexture2D", False, target, attachment, textarget, texture, level)


    def glFrontFace(self, mode):
        self("glFrontFace", False, mode)


    def glCreateBuffer(self, ):
        return self("glCreateBuffer", True, )


    def glCreateFramebuffer(self, ):
        return self("glCreateFramebuffer", True, )


    def glCreateRenderbuffer(self, ):
        return self("glCreateRenderbuffer", True, )


    def glCreateTexture(self, ):
        return self("glCreateTexture", True, )


    def glGenerateMipmap(self, target):
        self("glGenerateMipmap", False, target)


    def glGetActiveAttrib(self, program, index):
        return self("glGetActiveAttrib", True, program, index)


    def glGetActiveUniform(self, program, index):
        return self("glGetActiveUniform", True, program, index)


    def glGetAttachedShaders(self, program):
        return self("glGetAttachedShaders", True, program)


    def glGetAttribLocation(self, program, name):
        return self("glGetAttribLocation", True, program, name)


    def _glGetBooleanv(self, pname):
        self("_glGetBooleanv", False, pname)


    def glGetBufferParameter(self, target, pname):
        return self("glGetBufferParameter", True, target, pname)


    def glGetError(self, ):
        return self("glGetError", True, )


    def _glGetFloatv(self, pname):
        self("_glGetFloatv", False, pname)


    def glGetFramebufferAttachmentParameter(self, target, attachment, pname):
        return self("glGetFramebufferAttachmentParameter", True, target, attachment, pname)


    def _glGetIntegerv(self, pname):
        self("_glGetIntegerv", False, pname)


    def glGetProgramInfoLog(self, program):
        return self("glGetProgramInfoLog", True, program)


    def glGetProgramParameter(self, program, pname):
        return self("glGetProgramParameter", True, program, pname)


    def glGetRenderbufferParameter(self, target, pname):
        return self("glGetRenderbufferParameter", True, target, pname)


    def glGetShaderInfoLog(self, shader):
        return self("glGetShaderInfoLog", True, shader)


    def glGetShaderPrecisionFormat(self, shadertype, precisiontype):
        return self("glGetShaderPrecisionFormat", True, shadertype, precisiontype)


    def glGetShaderSource(self, shader):
        return self("glGetShaderSource", True, shader)


    def glGetShaderParameter(self, shader, pname):
        return self("glGetShaderParameter", True, shader, pname)


    def glGetParameter(self, pname):
        return self("glGetParameter", True, pname)


    def glGetTexParameter(self, target, pname):
        return self("glGetTexParameter", True, target, pname)


    def glGetUniform(self, program, location):
        return self("glGetUniform", True, program, location)


    def glGetUniformLocation(self, program, name):
        return self("glGetUniformLocation", True, program, name)


    def glGetVertexAttrib(self, index, pname):
        return self("glGetVertexAttrib", True, index, pname)


    def glGetVertexAttribOffset(self, index, pname):
        return self("glGetVertexAttribOffset", True, index, pname)


    def glHint(self, target, mode):
        self("glHint", False, target, mode)


    def glIsBuffer(self, buffer):
        return self("glIsBuffer", True, buffer)


    def glIsEnabled(self, cap):
        return self("glIsEnabled", True, cap)


    def glIsFramebuffer(self, framebuffer):
        return self("glIsFramebuffer", True, framebuffer)


    def glIsProgram(self, program):
        return self("glIsProgram", True, program)


    def glIsRenderbuffer(self, renderbuffer):
        return self("glIsRenderbuffer", True, renderbuffer)


    def glIsShader(self, shader):
        return self("glIsShader", True, shader)


    def glIsTexture(self, texture):
        return self("glIsTexture", True, texture)


    def glLineWidth(self, width):
        self("glLineWidth", False, width)


    def glLinkProgram(self, program):
        self("glLinkProgram", False, program)


    def glPixelStorei(self, pname, param):
        self("glPixelStorei", False, pname, param)


    def glPolygonOffset(self, factor, units):
        self("glPolygonOffset", False, factor, units)


    def glReadPixels(self, x, y, width, height, format, type):
        return self("glReadPixels", True, x, y, width, height, format, type)


    def glRenderbufferStorage(self, target, internalformat, width, height):
        self("glRenderbufferStorage", False, target, internalformat, width, height)


    def glSampleCoverage(self, value, invert):
        self("glSampleCoverage", False, value, invert)


    def glScissor(self, x, y, width, height):
        self("glScissor", False, x, y, width, height)


    def glShaderSource(self, shader, source):
        self("glShaderSource", False, shader, source)


    def glStencilFunc(self, func, ref, mask):
        self("glStencilFunc", False, func, ref, mask)


    def glStencilFuncSeparate(self, face, func, ref, mask):
        self("glStencilFuncSeparate", False, face, func, ref, mask)


    def glStencilMask(self, mask):
        self("glStencilMask", False, mask)


    def glStencilMaskSeparate(self, face, mask):
        self("glStencilMaskSeparate", False, face, mask)


    def glStencilOp(self, fail, zfail, zpass):
        self("glStencilOp", False, fail, zfail, zpass)


    def glStencilOpSeparate(self, face, fail, zfail, zpass):
        self("glStencilOpSeparate", False, face, fail, zfail, zpass)


    def glTexImage2D(self, target, level, internalformat, format, type, pixels):
        self("glTexImage2D", False, target, level, internalformat, format, type, pixels)


    def glTexParameterf(self, target, pname, param):
        self("glTexParameterf", False, target, pname, param)
    def glTexParameteri(self, target, pname, param):
        self("glTexParameteri", False, target, pname, param)


    def glTexSubImage2D(self, target, level, xoffset, yoffset, format, type, pixels):
        self("glTexSubImage2D", False, target, level, xoffset, yoffset, format, type, pixels)


    def glUniform1f(self, location, v1):
        self("glUniform1f", False, location, v1)
    def glUniform2f(self, location, v1, v2):
        self("glUniform2f", False, location, v1, v2)
    def glUniform3f(self, location, v1, v2, v3):
        self("glUniform3f", False, location, v1, v2, v3)
    def glUniform4f(self, location, v1, v2, v3, v4):
        self("glUniform4f", False, location, v1, v2, v3, v4)
    def glUniform1i(self, location, v1):
        self("glUniform1i", False, location, v1)
    def glUniform2i(self, location, v1, v2):
        self("glUniform2i", False, location, v1, v2)
    def glUniform3i(self, location, v1, v2, v3):
        self("glUniform3i", False, location, v1, v2, v3)
    def glUniform4i(self, location, v1, v2, v3, v4):
        self("glUniform4i", False, location, v1, v2, v3, v4)
    def glUniform1fv(self, location, count, values):
        self("glUniform1fv", False, location, count, values)
    def glUniform2fv(self, location, count, values):
        self("glUniform2fv", False, location, count, values)
    def glUniform3fv(self, location, count, values):
        self("glUniform3fv", False, location, count, values)
    def glUniform4fv(self, location, count, values):
        self("glUniform4fv", False, location, count, values)
    def glUniform1iv(self, location, count, values):
        self("glUniform1iv", False, location, count, values)
    def glUniform2iv(self, location, count, values):
        self("glUniform2iv", False, location, count, values)
    def glUniform3iv(self, location, count, values):
        self("glUniform3iv", False, location, count, values)
    def glUniform4iv(self, location, count, values):
        self("glUniform4iv", False, location, count, values)


    def glUniformMatrix2fv(self, location, count, transpose, values):
        self("glUniformMatrix2fv", False, location, count, transpose, values)
    def glUniformMatrix3fv(self, location, count, transpose, values):
        self("glUniformMatrix3fv", False, location, count, transpose, values)
    def glUniformMatrix4fv(self, location, count, transpose, values):
        self("glUniformMatrix4fv", False, location, count, transpose, values)


    def glUseProgram(self, program):
        self("glUseProgram", False, program)


    def glValidateProgram(self, program):
        self("glValidateProgram", False, program)


    def glVertexAttrib1f(self, index, v1):
        self("glVertexAttrib1f", False, index, v1)
    def glVertexAttrib2f(self, index, v1, v2):
        self("glVertexAttrib2f", False, index, v1, v2)
    def glVertexAttrib3f(self, index, v1, v2, v3):
        self("glVertexAttrib3f", False, index, v1, v2, v3)
    def glVertexAttrib4f(self, index, v1, v2, v3, v4):
        self("glVertexAttrib4f", False, index, v1, v2, v3, v4)


    def glVertexAttribPointer(self, indx, size, type, normalized, stride, offset):
        self("glVertexAttribPointer", False, indx, size, type, normalized, stride, offset)


    def glViewport(self, x, y, width, height):
        self("glViewport", False, x, y, width, height)



########NEW FILE########
__FILENAME__ = _pyopengl
"""

THIS CODE IS AUTO-GENERATED. DO NOT EDIT.

Proxy API for GL ES 2.0 subset, via the PyOpenGL library.

"""

import ctypes
from OpenGL import GL
import OpenGL.GL.framebufferobjects as FBO





def glBindAttribLocation(program, index, name):
    name = name.encode('utf-8')
    return GL.glBindAttribLocation(program, index, name)


def glBufferData(target, data, usage):
    """ Data can be numpy array or the size of data to allocate.
    """
    if isinstance(data, int):
        size = data
        data = None
    else:
        size = data.nbytes
    GL.glBufferData(target, size, data, usage)


def glBufferSubData(target, offset, data):
    size = data.nbytes
    GL.glBufferSubData(target, offset, size, data)


def glCompressedTexImage2D(target, level, internalformat, width, height, border, data):
    # border = 0  # set in args
    size = data.size
    GL.glCompressedTexImage2D(target, level, internalformat, width, height, border, size, data)


def glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data):
    size = data.size
    GL.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, size, data)


def glDeleteBuffer(buffer):
    GL.glDeleteBuffers(1, [buffer])


def glDeleteFramebuffer(framebuffer):
    FBO.glDeleteFramebuffers(1, [framebuffer])


def glDeleteRenderbuffer(renderbuffer):
    FBO.glDeleteRenderbuffers(1, [renderbuffer])


def glDeleteTexture(texture):
    GL.glDeleteTextures([texture])


def glDrawElements(mode, count, type, offset):
    if offset is None:
        offset = ctypes.c_void_p(0)
    elif isinstance(offset, (int, ctypes.c_int)):
        offset = ctypes.c_void_p(int(offset))
    return GL.glDrawElements(mode, count, type, offset)


def glCreateBuffer():
    return GL.glGenBuffers(1)


def glCreateFramebuffer():
    return FBO.glGenFramebuffers(1)


def glCreateRenderbuffer():
    return FBO.glGenRenderbuffers(1)


def glCreateTexture():
    return GL.glGenTextures(1)


def glGetActiveAttrib(program, index):
    bufsize = 256
    length = (ctypes.c_int*1)()
    size = (ctypes.c_int*1)()
    type = (ctypes.c_uint*1)()
    name = ctypes.create_string_buffer(bufsize)
    # pyopengl has a bug, this is a patch
    GL.glGetActiveAttrib(program, index, bufsize, length, size, type, name)
    name = name[:length[0]].decode('utf-8')
    return name, size[0], type[0]


def glGetActiveUniform(program, index):
    name, size, type = GL.glGetActiveUniform(program, index)
    return name.decode('utf-8'), size, type


def glGetAttribLocation(program, name):
    name = name.encode('utf-8')
    return GL.glGetAttribLocation(program, name)


def glGetFramebufferAttachmentParameter(target, attachment, pname):
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    FBO.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params)
    return params[0]


def glGetProgramInfoLog(program):
    res = GL.glGetProgramInfoLog(program)
    return res.decode('utf-8')


def glGetRenderbufferParameter(target, pname):
    d = -2**31  # smallest 32bit integer
    params = (ctypes.c_int*1)(d)
    FBO.glGetRenderbufferParameteriv(target, pname, params)
    return params[0]


def glGetShaderInfoLog(shader):
    res = GL.glGetShaderInfoLog(shader)
    return res.decode('utf-8')


def glGetShaderSource(shader):
    res = GL.glGetShaderSource(shader)
    return res.decode('utf-8')


def glGetParameter(pname):
    if pname in [33902, 33901, 32773, 3106, 2931, 2928,
                 2849, 32824, 10752, 32938]:
        # GL_ALIASED_LINE_WIDTH_RANGE GL_ALIASED_POINT_SIZE_RANGE
        # GL_BLEND_COLOR GL_COLOR_CLEAR_VALUE GL_DEPTH_CLEAR_VALUE
        # GL_DEPTH_RANGE GL_LINE_WIDTH GL_POLYGON_OFFSET_FACTOR
        # GL_POLYGON_OFFSET_UNITS GL_SAMPLE_COVERAGE_VALUE
        return _glGetFloatv(pname)
    elif pname in [7936, 7937, 7938, 35724, 7939]:
        # GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION,
        # GL_EXTENSIONS are strings
        pass  # string handled below
    else:
        return _glGetIntegerv(pname)
    name = pname
    res = GL.glGetString(pname)
    return res.decode('utf-8')


def glGetUniform(program, location):
    n = 16
    d = float('Inf')
    params = (ctypes.c_float*n)(*[d for i in range(n)])
    GL.glGetUniformfv(program, location, params)
    params = [p for p in params if p!=d]
    if len(params) == 1:
        return params[0]
    else:
        return tuple(params)


def glGetUniformLocation(program, name):
    name = name.encode('utf-8')
    return GL.glGetUniformLocation(program, name)


def glGetVertexAttrib(index, pname):
    try:  # maybe they will fix it
        return GL.glGetVertexAttribfv(index, pname)
    except TypeError:
        n = 4
        d = float('Inf')
        params = (ctypes.c_float*n)(*[d for i in range(n)])
        GL.glGetVertexAttribfv(index, pname, params)
        params = [p for p in params if p!=d]
        if len(params) == 1:
            return params[0]
        else:
            return tuple(params)


def glGetVertexAttribOffset(index, pname):
    try:  # maybe the fixed it
        return GL.glGetVertexAttribPointerv(index, pname)
    except TypeError:
        pointer = (ctypes.c_void_p*1)()
        GL.glGetVertexAttribPointerv(index, pname, pointer)
        return pointer[0] or 0


def glShaderSource(shader, source):
    # Some implementation do not like getting a list of single chars
    if isinstance(source, (tuple, list)):
        strings = [s for s in source]
    else:
        strings = [source]
    GL.glShaderSource(shader, strings)


def glTexImage2D(target, level, internalformat, format, type, pixels):
    border = 0
    if isinstance(pixels, (tuple, list)):
        height, width = pixels
        pixels = None
    else:
        height, width = pixels.shape[:2]
    GL.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels)


def glTexSubImage2D(target, level, xoffset, yoffset, format, type, pixels):
    height, width = pixels.shape[:2]
    GL.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels)


def glVertexAttribPointer(indx, size, type, normalized, stride, offset):
    if offset is None:
        offset = ctypes.c_void_p(0)
    elif isinstance(offset, (int, ctypes.c_int)):
        offset = ctypes.c_void_p(int(offset))
    return GL.glVertexAttribPointer(indx, size, type, normalized, stride, offset)


# List of functions that we should import from OpenGL.GL
_functions_to_import = [
    ("glActiveTexture", "glActiveTexture"),
    ("glAttachShader", "glAttachShader"),
    ("glBindBuffer", "glBindBuffer"),
    ("glBindFramebuffer", "glBindFramebuffer"),
    ("glBindRenderbuffer", "glBindRenderbuffer"),
    ("glBindTexture", "glBindTexture"),
    ("glBlendColor", "glBlendColor"),
    ("glBlendEquation", "glBlendEquation"),
    ("glBlendEquationSeparate", "glBlendEquationSeparate"),
    ("glBlendFunc", "glBlendFunc"),
    ("glBlendFuncSeparate", "glBlendFuncSeparate"),
    ("glCheckFramebufferStatus", "glCheckFramebufferStatus"),
    ("glClear", "glClear"),
    ("glClearColor", "glClearColor"),
    ("glClearDepthf", "glClearDepth"),
    ("glClearStencil", "glClearStencil"),
    ("glColorMask", "glColorMask"),
    ("glCompileShader", "glCompileShader"),
    ("glCopyTexImage2D", "glCopyTexImage2D"),
    ("glCopyTexSubImage2D", "glCopyTexSubImage2D"),
    ("glCreateProgram", "glCreateProgram"),
    ("glCreateShader", "glCreateShader"),
    ("glCullFace", "glCullFace"),
    ("glDeleteProgram", "glDeleteProgram"),
    ("glDeleteShader", "glDeleteShader"),
    ("glDepthFunc", "glDepthFunc"),
    ("glDepthMask", "glDepthMask"),
    ("glDepthRangef", "glDepthRange"),
    ("glDetachShader", "glDetachShader"),
    ("glDisable", "glDisable"),
    ("glDisableVertexAttribArray", "glDisableVertexAttribArray"),
    ("glDrawArrays", "glDrawArrays"),
    ("glEnable", "glEnable"),
    ("glEnableVertexAttribArray", "glEnableVertexAttribArray"),
    ("glFinish", "glFinish"),
    ("glFlush", "glFlush"),
    ("glFramebufferRenderbuffer", "glFramebufferRenderbuffer"),
    ("glFramebufferTexture2D", "glFramebufferTexture2D"),
    ("glFrontFace", "glFrontFace"),
    ("glGenerateMipmap", "glGenerateMipmap"),
    ("glGetAttachedShaders", "glGetAttachedShaders"),
    ("glGetBooleanv", "_glGetBooleanv"),
    ("glGetBufferParameteriv", "glGetBufferParameter"),
    ("glGetError", "glGetError"),
    ("glGetFloatv", "_glGetFloatv"),
    ("glGetIntegerv", "_glGetIntegerv"),
    ("glGetProgramiv", "glGetProgramParameter"),
    ("glGetShaderPrecisionFormat", "glGetShaderPrecisionFormat"),
    ("glGetShaderiv", "glGetShaderParameter"),
    ("glGetTexParameterfv", "glGetTexParameter"),
    ("glHint", "glHint"),
    ("glIsBuffer", "glIsBuffer"),
    ("glIsEnabled", "glIsEnabled"),
    ("glIsFramebuffer", "glIsFramebuffer"),
    ("glIsProgram", "glIsProgram"),
    ("glIsRenderbuffer", "glIsRenderbuffer"),
    ("glIsShader", "glIsShader"),
    ("glIsTexture", "glIsTexture"),
    ("glLineWidth", "glLineWidth"),
    ("glLinkProgram", "glLinkProgram"),
    ("glPixelStorei", "glPixelStorei"),
    ("glPolygonOffset", "glPolygonOffset"),
    ("glReadPixels", "glReadPixels"),
    ("glRenderbufferStorage", "glRenderbufferStorage"),
    ("glSampleCoverage", "glSampleCoverage"),
    ("glScissor", "glScissor"),
    ("glStencilFunc", "glStencilFunc"),
    ("glStencilFuncSeparate", "glStencilFuncSeparate"),
    ("glStencilMask", "glStencilMask"),
    ("glStencilMaskSeparate", "glStencilMaskSeparate"),
    ("glStencilOp", "glStencilOp"),
    ("glStencilOpSeparate", "glStencilOpSeparate"),
    ("glTexParameterf", "glTexParameterf"),
    ("glTexParameteri", "glTexParameteri"),
    ("glUniform1f", "glUniform1f"),
    ("glUniform2f", "glUniform2f"),
    ("glUniform3f", "glUniform3f"),
    ("glUniform4f", "glUniform4f"),
    ("glUniform1i", "glUniform1i"),
    ("glUniform2i", "glUniform2i"),
    ("glUniform3i", "glUniform3i"),
    ("glUniform4i", "glUniform4i"),
    ("glUniform1fv", "glUniform1fv"),
    ("glUniform2fv", "glUniform2fv"),
    ("glUniform3fv", "glUniform3fv"),
    ("glUniform4fv", "glUniform4fv"),
    ("glUniform1iv", "glUniform1iv"),
    ("glUniform2iv", "glUniform2iv"),
    ("glUniform3iv", "glUniform3iv"),
    ("glUniform4iv", "glUniform4iv"),
    ("glUniformMatrix2fv", "glUniformMatrix2fv"),
    ("glUniformMatrix3fv", "glUniformMatrix3fv"),
    ("glUniformMatrix4fv", "glUniformMatrix4fv"),
    ("glUseProgram", "glUseProgram"),
    ("glValidateProgram", "glValidateProgram"),
    ("glVertexAttrib1f", "glVertexAttrib1f"),
    ("glVertexAttrib2f", "glVertexAttrib2f"),
    ("glVertexAttrib3f", "glVertexAttrib3f"),
    ("glVertexAttrib4f", "glVertexAttrib4f"),
    ("glViewport", "glViewport"),
    ]

########NEW FILE########
__FILENAME__ = globject
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------


class GLObject(object):
    """ Generic GL object that may live both on CPU and GPU 
    """

    # Internal id counter to keep track of GPU objects
    _idcount = 0

    def __init__(self):
        """ Initialize the object in the default state """

        self._handle = -1
        self._target = None
        self._need_create = True
        self._need_update = True
        self._need_delete = False

        GLObject._idcount += 1
        self._id = GLObject._idcount
    
    def __del__(self):
        # You never know when this is goint to happen. The window might
        # already be closed and no OpenGL context might be available.
        # Worse, there might be multiple contexts and calling delete()
        # at the wrong moment might remove other gl objects, leading to
        # very strange and hard to debug behavior.
        # 
        # So we don't do anything. If each GLObject was aware of the
        # context in which it resides, we could do auto-cleanup though...
        # todo: it's not very Pythonic to have to delete an object.
        pass

    def delete(self):
        """ Delete the object from GPU memory """

        if self._need_delete:
            self._delete()
        self._handle = -1
        self._need_create = True
        self._need_update = True
        self._need_delete = False

    def activate(self):
        """ Activate the object on GPU """

        if self._need_create:
            self._create()
            self._need_create = False
        self._activate()
        if self._need_update:
            self._update()
            self._need_update = False
            self._activate()
    
    def deactivate(self):
        """ Deactivate the object on GPU """

        self._deactivate()

    @property
    def handle(self):
        """ Name of this object on the GPU """

        return self._handle

    @property
    def target(self):
        """ OpenGL type of object. """

        return self._target

    def _create(self):
        """ Dummy create method """
        raise NotImplementedError()

    def _delete(self):
        """ Dummy delete method """
        raise NotImplementedError()

    def _activate(self):
        """ Dummy activate method """
        raise NotImplementedError()

    def _deactivate(self):
        """ Dummy deactivate method """
        raise NotImplementedError()

    def _update(self):
        """ Dummy update method """
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = initialize
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

from . import gl

GL_VERTEX_PROGRAM_POINT_SIZE = 34370
GL_POINT_SPRITE = 34913


def gl_initialize():
    """Initialize GL values

    This method helps standardize GL across desktop and mobile, e.g.
    by enabling ``GL_VERTEX_PROGRAM_POINT_SIZE`` and ``GL_POINT_SPRITE``.
    """
    gl.glEnable(GL_VERTEX_PROGRAM_POINT_SIZE)
    gl.glEnable(GL_POINT_SPRITE)

########NEW FILE########
__FILENAME__ = program
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
import re
import numpy as np

from . import gl
from . globject import GLObject
from . buffer import VertexBuffer, IndexBuffer
from . shader import VertexShader, FragmentShader
from . variable import Uniform, Attribute
from ..util import logger
from ..ext.six import string_types


# ----------------------------------------------------------- Program class ---
class Program(GLObject):
    """ Shader program object
    
    A Program is an object to which shaders can be attached and linked to
    create the final program.
    
    Parameters
    ----------

    vert : str, VertexShader, or list
        The vertex shader to be used by this program
    frag : str, FragmentShader, or list
        The fragment shader to be used by this program
    count : int (optional)
        Number of vertices this program will use. This can be given to
        initialize a VertexBuffer during Program initialization.

    Notes
    -----
    If several shaders are specified, only one can contain the main
    function. OpenGL ES 2.0 does not support a list of shaders.
    """

    # ---------------------------------
    def __init__(self, vert=None, frag=None, count=0):
        GLObject.__init__(self)

        self._count = count
        self._buffer = None

        # Get all vertex shaders
        self._verts = []
        if isinstance(vert, (str, VertexShader)):
            verts = [vert]
        elif isinstance(vert, (type(None), tuple, list)):
            verts = vert or []
        else:
            raise ValueError('Vert must be str, VertexShader or list')
        # Apply
        for shader in verts:
            if isinstance(shader, str):
                self._verts.append(VertexShader(shader))
            elif isinstance(shader, VertexShader):
                if shader not in self._verts:
                    self._verts.append(shader)
            else:
                T = type(shader)
                raise ValueError('Cannot make a VertexShader of %r.' % T)

        # Get all fragment shaders
        self._frags = []
        if isinstance(frag, (str, FragmentShader)):
            frags = [frag]
        elif isinstance(frag, (type(None), tuple, list)):
            frags = frag or []
        else:
            raise ValueError('Frag must be str, FragmentShader or list')
        # Apply
        for shader in frags:
            if isinstance(shader, str):
                self._frags.append(FragmentShader(shader))
            elif isinstance(shader, FragmentShader):
                if shader not in self._frags:
                    self._frags.append(shader)
            else:
                T = type(shader)
                raise ValueError('Cannot make a FragmentShader of %r.' % T)

        # Build uniforms and attributes
        self._build_uniforms()
        self._build_attributes()

        # Build associated structured vertex buffer if count is given
        if self._count > 0:
            dtype = []
            for attribute in self._attributes.values():
                dtype.append(attribute.dtype)
            self._buffer = VertexBuffer(np.zeros(self._count, dtype=dtype))
            self.bind(self._buffer)

    def attach(self, shaders):
        """ Attach one or several vertex/fragment shaders to the program
        
        Note that GL ES 2.0 only supports one vertex and one fragment 
        shader.
        
        Parameters
        ----------
        
        shaders : list of shade objects
            The shaders to attach.
        """

        if isinstance(shaders, (VertexShader, FragmentShader)):
            shaders = [shaders]
        for shader in shaders:
            if isinstance(shader, VertexShader):
                self._verts.append(shader)
            else:
                self._frags.append(shader)

        # Ensure uniqueness of shaders
        self._verts = list(set(self._verts))
        self._frags = list(set(self._frags))

        self._need_create = True
        self._need_update = True

        # Build uniforms and attributes
        self._build_uniforms()
        self._build_attributes()

    def detach(self, shaders):
        """Detach one or several vertex/fragment shaders from the program.
    
        Parameters
        ----------
        shaders : list of shade objects
            The shaders to detach.
        
        Notes
        -----
        We don't need to defer attach/detach shaders since shader deletion
        takes care of that.
        """

        if isinstance(shaders, (VertexShader, FragmentShader)):
            shaders = [shaders]
        for shader in shaders:
            if isinstance(shader, VertexShader):
                if shader in self._verts:
                    self._verts.remove(shader)
                else:
                    raise RuntimeError("Shader is not attached to the program")
            if isinstance(shader, FragmentShader):
                if shader in self._frags:
                    self._frags.remove(shader)
                else:
                    raise RuntimeError("Shader is not attached to the program")
        self._need_update = True

        # Build uniforms and attributes
        self._build_uniforms()
        self._build_attributes()

    def _create(self):
        """ create the program object on the GPU """
        
        # Create and check if program has been created:
        self._handle = gl.glCreateProgram()
        if not self._handle:
            raise RuntimeError("Cannot create program object")
    
    def _update(self):
        """ Build (link) the program and checks everything's ok """

        # Check if we have something to link
        if not self._verts:
            raise ValueError("No vertex shader has been given")
        if not self._frags:
            raise ValueError("No fragment shader has been given")

        # Detach any attached shaders
        attached = gl.glGetAttachedShaders(self._handle)
        for handle in attached:
            gl.glDetachShader(self._handle, handle)

        # Attach vertex and fragment shaders
        for shader in self._verts:
            shader.activate()
            gl.glAttachShader(self._handle, shader.handle)
        for shader in self._frags:
            shader.activate()
            gl.glAttachShader(self._handle, shader.handle)

        logger.debug("GPU: Creating program")

        # Link the program
        gl.glLinkProgram(self._handle)
        if not gl.glGetProgramParameter(self._handle, gl.GL_LINK_STATUS):
            print(gl.glGetProgramInfoLog(self._handle))
            raise RuntimeError('Program linking error')
        
        # Validate
        gl.glValidateProgram(self._handle)
        if not gl.glGetProgramParameter(self._handle, gl.GL_VALIDATE_STATUS):
            print(gl.glGetProgramInfoLog(self._handle))
            raise RuntimeError('Program validation error')
        
        # Activate uniforms
        active_uniforms = [name for (name, gtype) in self.active_uniforms]
        for uniform in self._uniforms.values():
            if uniform.name in active_uniforms:
                uniform.active = True
            else:
                uniform.active = False
        
        # Activate attributes
        active_attributes = [name for (name, gtype) in self.active_attributes]
        for attribute in self._attributes.values():
            if attribute.name in active_attributes:
                attribute.active = True
            else:
                attribute.active = False

    def _delete(self):
        logger.debug("GPU: Deleting program")
        gl.glDeleteProgram(self._handle)

    def _build_uniforms(self):
        """ Build the uniform objects """

        self._uniforms = {}
        count = 0
        for (name, gtype) in self.all_uniforms:
            uniform = Uniform(self, name, gtype)
            # if gtype in (gl.GL_SAMPLER_1D, gl.GL_SAMPLER_2D):
            if gtype in (gl.GL_SAMPLER_2D,):
                uniform._unit = count
                count += 1
            self._uniforms[name] = uniform
        self._need_update = True

    def _build_attributes(self):
        """ Build the attribute objects """

        self._attributes = {}

        dtype = []
        for (name, gtype) in self.all_attributes:
            attribute = Attribute(self, name, gtype)
            self._attributes[name] = attribute
            dtype.append(attribute.dtype)

    def bind(self, data):
        """ Bind a VertexBuffer that has structured data
        
        Parameters
        ----------
        data : VertexBuffer
            The vertex buffer to bind. The field names of the array
            are mapped to attribute names in GLSL.
        """
        # Check
        if not isinstance(data, VertexBuffer):
            raise ValueError('Program.bind() requires a VertexBuffer.')
        # Apply
        for name in data.dtype.names:
            if name in self._attributes.keys():
                self._attributes[name].set_data(data[name])
            else:
                logger.warn("%s has not been bound" % name)

    def __setitem__(self, name, data):
        if name in self._uniforms.keys():
            self._uniforms[name].set_data(data)
        elif name in self._attributes.keys():
            self._attributes[name].set_data(data)
        else:
            raise ValueError("Unknown uniform or attribute")

    def __getitem__(self, name):
        if name in self._uniforms.keys():
            return self._uniforms[name].data
        elif name in self._attributes.keys():
            return self._attributes[name].data
        else:
            raise IndexError("Unknown uniform or attribute")

    def _activate(self):
        """Activate the program as part of current rendering state."""

        if self._need_update:
            # We cannot use the program if its not yet linked etc.
            # _activate will get called after _update again
            return
        
        logger.debug("GPU: Activating program")
        gl.glUseProgram(self.handle)

        for uniform in self._uniforms.values():
            if uniform.active:
                uniform.activate()

        for attribute in self._attributes.values():
            if attribute.active:
                attribute.activate()

    def _deactivate(self):
        """Deactivate the program."""

        logger.debug("GPU: Deactivating program")
        gl.glUseProgram(0)

        for uniform in self._uniforms.values():
            if uniform.active:
                uniform.deactivate()
        for attribute in self._attributes.values():
            if attribute.active:
                attribute.deactivate()

    @property
    def all_uniforms(self):
        """ Program uniforms obtained from shaders code """

        uniforms = []
        for shader in self._verts:
            uniforms.extend(shader.uniforms)
        for shader in self._frags:
            uniforms.extend(shader.uniforms)
        uniforms = list(set(uniforms))
        return uniforms

    @property
    def active_uniforms(self):
        """ Program active uniforms obtained from GPU """

        count = gl.glGetProgramParameter(self.handle, gl.GL_ACTIVE_UNIFORMS)
        # This match a name of the form "name[size]" (= array)
        regex = re.compile("""(?P<name>\w+)\s*(\[(?P<size>\d+)\])\s*""")
        uniforms = []
        for i in range(count):
            name, size, gtype = gl.glGetActiveUniform(self.handle, i)
            # This checks if the uniform is an array
            # Name will be something like xxx[0] instead of xxx
            m = regex.match(name)
            # When uniform is an array, size corresponds to the highest used
            # index
            if m:
                name = m.group('name')
                if size >= 1:
                    for i in range(size):
                        name = '%s[%d]' % (m.group('name'), i)
                        uniforms.append((name, gtype))
            else:
                uniforms.append((name, gtype))

        return uniforms

    @property
    def inactive_uniforms(self):
        """ Program inactive uniforms obtained from GPU """

        active_uniforms = self.active_uniforms
        inactive_uniforms = self.all_uniforms
        for uniform in active_uniforms:
            if uniform in inactive_uniforms:
                inactive_uniforms.remove(uniform)
        return inactive_uniforms

    @property
    def all_attributes(self):
        """ Program attributes obtained from shaders code """

        attributes = []
        for shader in self._verts:
            attributes.extend(shader.attributes)
        # No attribute in fragment shaders
        attributes = list(set(attributes))
        return attributes

    @property
    def active_attributes(self):
        """ Program active attributes obtained from GPU """

        count = gl.glGetProgramParameter(self.handle, gl.GL_ACTIVE_ATTRIBUTES)
        attributes = []

        # This match a name of the form "name[size]" (= array)
        regex = re.compile("""(?P<name>\w+)\s*(\[(?P<size>\d+)\])""")

        for i in range(count):
            name, size, gtype = gl.glGetActiveAttrib(self.handle, i)

            # This checks if the attribute is an array
            # Name will be something like xxx[0] instead of xxx
            m = regex.match(name)
            # When attribute is an array, size corresponds to the highest used
            # index
            if m:
                name = m.group('name')
                if size >= 1:
                    for i in range(size):
                        name = '%s[%d]' % (m.group('name'), i)
                        attributes.append((name, gtype))
            else:
                attributes.append((name, gtype))
        return attributes

    @property
    def inactive_attributes(self):
        """ Program inactive attributes obtained from GPU """

        active_attributes = self.active_attributes
        inactive_attributes = self.all_attributes
        for attribute in active_attributes:
            if attribute in inactive_attributes:
                inactive_attributes.remove(attribute)
        return inactive_attributes

    @property
    def shaders(self):
        """ List of shaders currently attached to this program """

        shaders = []
        shaders.extend(self._verts)
        shaders.extend(self._frags)
        return shaders

    # first=0, count=None):
    def draw(self, mode=gl.GL_TRIANGLES, indices=None, check_error=True):
        """ Draw the attribute arrays in the specified mode.

        Parameters
        ----------
        mode : str | GL_ENUM
            GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP,
            GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN
        first : int
            The starting vertex index in the vertex array. Default 0.
        count : int
            The number of vertices to draw. Default all.
        """
        _known_modes = ('points', 'lines', 'line_strip', 'line_loop',
                        'triangles', 'triangle_strip', 'triangle_fan')
        if isinstance(mode, string_types):
            if mode not in _known_modes:
                raise ValueError('mode must be one of %s, not "%s"'
                                 % (_known_modes, mode))
            mode = getattr(gl, 'GL_%s' % mode.upper())
        self.activate()

        # WARNING: The "list" of values from a dict is not a list (py3k)
        attributes = list(self._attributes.values())

        # Get buffer size first attribute
        # We need more tests here
        #  - do we have at least 1 attribute ?
        #  - does all attributes report same count ?
        # count = (count or attributes[0].size) - first

        if isinstance(indices, IndexBuffer):
            indices.activate()
            gltypes = {np.dtype(np.uint8): gl.GL_UNSIGNED_BYTE,
                       np.dtype(np.uint16): gl.GL_UNSIGNED_SHORT,
                       np.dtype(np.uint32): gl.GL_UNSIGNED_INT}
            gl.glDrawElements(mode, indices.size, gltypes[indices.dtype], None)
            indices.deactivate()
        else:
            #count = (count or attributes[0].size) - first
            first = 0
            count = attributes[0].size
            gl.glDrawArrays(mode, first, count)

        gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
        self.deactivate()

        # Check ok
        if check_error:
            gl.check_error()

########NEW FILE########
__FILENAME__ = shader
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
import re
import os.path

from . import gl
from ..util import logger
from .globject import GLObject


# ------------------------------------------------------------ Shader class ---
class Shader(GLObject):
    """ Abstract shader class
    
    Parameters
    ----------

    code: str
        code can be a filename or the actual code
    """

    _gtypes = {
        'float':       gl.GL_FLOAT,
        'vec2':        gl.GL_FLOAT_VEC2,
        'vec3':        gl.GL_FLOAT_VEC3,
        'vec4':        gl.GL_FLOAT_VEC4,
        'int':         gl.GL_INT,
        'ivec2':       gl.GL_INT_VEC2,
        'ivec3':       gl.GL_INT_VEC3,
        'ivec4':       gl.GL_INT_VEC4,
        'bool':        gl.GL_BOOL,
        'bvec2':       gl.GL_BOOL_VEC2,
        'bvec3':       gl.GL_BOOL_VEC3,
        'bvec4':       gl.GL_BOOL_VEC4,
        'mat2':        gl.GL_FLOAT_MAT2,
        'mat3':        gl.GL_FLOAT_MAT3,
        'mat4':        gl.GL_FLOAT_MAT4,
        #        'sampler1D':   gl.GL_SAMPLER_1D,
        'sampler2D':   gl.GL_SAMPLER_2D,
        #        'sampler13':   gl.GL_SAMPLER_3D,
    }

    def __init__(self, target, code=None):
        GLObject.__init__(self)
        if target not in [gl.GL_VERTEX_SHADER, gl.GL_FRAGMENT_SHADER]:
            raise ValueError("Shader target must be vertex or fragment")

        self._target = target
        self._code = None
        self._source = None
        if code is not None:
            self.code = code

    @property
    def code(self):
        """ Shader source code """
        return self._code

    @code.setter
    def code(self, code):
        """ Shader source code """
        if os.path.isfile(code):
            with open(code, 'rt') as file:
                self._code = file.read()
                self._source = os.path.basename(code)
        else:
            self._code = code
            self._source = '<string>'
        self._need_update = True

    @property
    def source(self):
        """ Shader source (string or filename) """
        return self._source
    
    def _activate(self):
        pass  # shaders do not need any kind of (de)activation
    
    def _deactivate(self):
        pass  # shaders do not need any kind of (de)activation
    
    def _create(self):
        """ Create the shader object on the GPU """

        # Check if we have something to compile
        if not self._code:
            raise RuntimeError("No code has been given")

        # Create and check that shader object has been created
        self._handle = gl.glCreateShader(self._target)
        if self._handle <= 0:
            raise RuntimeError("Cannot create shader object")

    def _update(self):
        """ Compile the source and checks everything's ok """
        # Set shader source
        gl.glShaderSource(self._handle, self._code)

        logger.debug("GPU: Creating shader")

        # Actual compilation
        gl.glCompileShader(self._handle)
        status = gl.glGetShaderParameter(self._handle, gl.GL_COMPILE_STATUS)
        if not status:
            errors = gl.glGetShaderInfoLog(self._handle)
            errormsg = self._get_error(errors, 4)
            raise RuntimeError("Shader compilation error in %r:\n%s" % 
                               (self, errormsg))

    def _delete(self):
        """ Delete shader from GPU memory (if it was present). """

        gl.glDeleteShader(self._handle)

    def _parse_error(self, error):
        """
        Parses a single GLSL error and extracts the line number and error
        description.

        Parameters
        ----------
        error : str
            An error string as returned byt the compilation process
        """
        error = str(error)
        
        # Nvidia
        # 0(7): error C1008: undefined variable "MV"
        m = re.match(r'(\d+)\((\d+)\)\s*:\s(.*)', error)
        if m:
            return int(m.group(2)), m.group(3)

        # ATI / Intel
        # ERROR: 0:131: '{' : syntax error parse error
        m = re.match(r'ERROR:\s(\d+):(\d+):\s(.*)', error)
        if m:
            return int(m.group(2)), m.group(3)

        # Nouveau
        # 0:28(16): error: syntax error, unexpected ')', expecting '('
        m = re.match(r'(\d+):(\d+)\((\d+)\):\s(.*)', error)
        if m:
            return int(m.group(2)), m.group(4)

        # Other ...
        return None, error

    def _get_error(self, errors, indentation=0):
        """Get error and show the faulty line + some context

        Parameters
        ----------
        error : str
            An error string as returned by the compilation process
        indentation : int
            Number of spaces to indent the found error.
        """
        # Init
        results = []
        lines = None
        if self._code:
            lines = [line.strip() for line in self._code.split('\n')]

        for error in errors.split('\n'):
            # Strip; skip empy lines
            error = error.strip()
            if not error:
                continue
            # Separate line number from description (if we can)
            linenr, error = self._parse_error(error)
            if None in (linenr, lines):
                results.append('%s' % error)
            else:
                results.append('on line %i: %s' % (linenr, error))
                if linenr > 0 and linenr < len(lines):
                    results.append('  %s' % lines[linenr - 1])

        # Add indentation and return
        results = [' ' * indentation + r for r in results]
        return '\n'.join(results)

    @property
    def uniforms(self):
        """ Shader uniforms obtained from source code """

        uniforms = []
        regex = re.compile("""\s*uniform\s+(?P<type>\w+)\s+"""
                           """(?P<name>\w+)\s*(\[(?P<size>\d+)\])?\s*;""")
        for m in re.finditer(regex, self._code):
            size = -1
            gtype = Shader._gtypes[m.group('type')]
            if m.group('size'):
                size = int(m.group('size'))
            if size >= 1:
                for i in range(size):
                    name = '%s[%d]' % (m.group('name'), i)
                    uniforms.append((name, gtype))
            else:
                uniforms.append((m.group('name'), gtype))
        return uniforms

    @property
    def attributes(self):
        """ Shader attributes obtained from source code """

        attributes = []
        regex = re.compile("""\s*attribute\s+(?P<type>\w+)\s+"""
                           """(?P<name>\w+)\s*(\[(?P<size>\d+)\])?\s*;""")
        for m in re.finditer(regex, self._code):
            size = -1
            gtype = Shader._gtypes[m.group('type')]
            if m.group('size'):
                size = int(m.group('size'))
            if size >= 1:
                for i in range(size):
                    name = '%s[%d]' % (m.group('name'), i)
                    attributes.append((name, gtype))
            else:
                attributes.append((m.group('name'), gtype))
        return attributes


# ------------------------------------------------------ VertexShader class ---
class VertexShader(Shader):
    """ Vertex shader object
    
    Parameters
    ----------

    code: str
        code can be a filename or the actual code
    """

    def __init__(self, code=None):
        Shader.__init__(self, gl.GL_VERTEX_SHADER, code)

    def __repr__(self):
        return "Vertex Shader %d (%s)" % (self._id, self._source)


# ---------------------------------------------------- FragmentShader class ---
class FragmentShader(Shader):
    """ Fragment shader object
    
    Parameters
    ----------

    code: str
        code can be a filename or the actual code
    """

    def __init__(self, code=None):
        Shader.__init__(self, gl.GL_FRAGMENT_SHADER, code)

    def __repr__(self):
        return "Fragment Shader %d (%s)" % (self._id, self._source)

########NEW FILE########
__FILENAME__ = test_buffer
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Nicolas P. Rougier. All rights reserved.
# Distributed under the terms of the new BSD License.
# -----------------------------------------------------------------------------
import unittest
import numpy as np

from vispy.gloo import gl
from vispy.gloo.buffer import Buffer, DataBuffer, VertexBuffer, IndexBuffer


# -----------------------------------------------------------------------------
class BufferTest(unittest.TestCase):

    # Default init
    # ------------
    def test_init_default(self):
        B = Buffer()
        assert B._target == gl.GL_ARRAY_BUFFER
        assert B._handle == -1
        assert B._need_create is True
        assert B._need_update is True
        assert B._need_resize is True
        assert B._need_delete is False
        assert B._nbytes == 0
        assert B._usage == gl.GL_DYNAMIC_DRAW
        assert B._resizeable is True

    # Unknown target
    # --------------
    def test_init_wrong_target(self):
        # with self.assertRaises(ValueError):
        #    B = Buffer(target=-1)
        self.assertRaises(ValueError, Buffer, target=-1)

    # No data
    # -------
    def test_init_no_data(self):
        B = Buffer()
        assert len(B._pending_data) == 0

    # Data
    # ----
    def test_init_with_data(self):
        data = np.zeros(100)
        B = Buffer(data=data)
        assert len(B._pending_data) == 1

    # Check setting the whole buffer clear pending operations
    # -------------------------------------------------------
    def test_set_whole_data(self):
        data = np.zeros(100)
        B = Buffer(data=data)
        B.set_data(data=data)
        assert len(B._pending_data) == 1

    # Check stored data is data
    # -------------------------
    def test_data_storage(self):
        data = np.zeros(100)
        B = Buffer(data=data)
        B.set_data(data=data[:50], offset=0, copy=False)
        assert B._pending_data[-1][0].base is data

    # Check stored data is a copy
    # ----------------------------
    def test_data_copy(self):
        data = np.zeros(100)
        B = Buffer(data=data)
        B.set_data(data=data[:50], offset=0, copy=True)
        assert B._pending_data[-1][0].base is not data

    # Check setting oversized data
    # ----------------------------
    def test_oversized_data(self):
        data = np.zeros(10)
        B = Buffer(data=data, resizeable=False)
        # with self.assertRaises(ValueError):
        #    B.set_data(np.ones(20))
        self.assertRaises(ValueError, B.set_data, np.ones(20))

    # Check negative offset
    # ---------------------
    def test_negative_offset(self):
        data = np.zeros(10)
        B = Buffer(data=data, resizeable=False)
        # with self.assertRaises(ValueError):
        #    B.set_data(np.ones(1), offset=-1)
        self.assertRaises(ValueError, B.set_data, np.ones(1), offset=-1)

    # Check offlimit offset
    # ---------------------
    def test_offlimit_offset(self):
        data = np.zeros(10)
        B = Buffer(data=data, resizeable=False)
        # with self.assertRaises(ValueError):
        #    B.set_data(np.ones(1), offset=10 * data.dtype.itemsize)
        self.assertRaises(ValueError, B.set_data,
                          np.ones(1), offset=10 * data.dtype.itemsize)

    # Buffer size
    # -----------
    def test_buffer_size(self):
        data = np.zeros(10)
        B = Buffer(data=data)
        assert B.nbytes == data.nbytes

    # Resize
    # ------
    def test_buffer_resize(self):
        data = np.zeros(10)
        B = Buffer(data=data)
        data = np.zeros(20)
        B._need_resize = False
        B.set_data(data)
        assert B.nbytes == data.nbytes
        assert B._need_resize is True

    # Forbidden resize
    # ----------------
    def test_buffer_forbidden_resize(self):
        data = np.zeros(10)
        B = Buffer(data=data, resizeable=False)
        data = np.zeros(20)
        # with self.assertRaises(ValueError):
        #    B.set_data(data)
        self.assertRaises(ValueError, B.set_data, data)


# -----------------------------------------------------------------------------
class DataBufferTest(unittest.TestCase):

    # Default init
    # ------------
    def test_default_init(self):
        # Check default storage and copy flags
        data = np.ones(100)
        B = DataBuffer(data)
        assert B._store is True
        assert B._copy is False
        assert B.nbytes == data.nbytes
        assert B.offset == 0
        assert B.size == 100
        assert B.itemsize == data.itemsize
        assert B.stride == data.itemsize
        assert B.dtype == data.dtype
        assert B._resizeable is True

    # Default init with structured data
    # ---------------------------------
    def test_structured_init(self):
        # Check structured type
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data = np.zeros(10, dtype=dtype)
        B = DataBuffer(data)
        assert B.nbytes == data.nbytes
        assert B.offset == 0
        assert B.size == 10
        assert B.itemsize == data.itemsize
        assert B.stride == data.itemsize
        assert B.dtype == data.dtype

    # CPU storage
    # ------------
    def test_storage(self):
        data = np.ones(100)
        B = DataBuffer(data, store=True)
        assert B.data.base is data

    # Use CPU storage but make a local copy for storage
    # -------------------------------------------------
    def test_storage_copy(self):
        data = np.ones(100, np.float32)
        B = DataBuffer(data.copy(), store=True)  # we got rid of copy arg
        assert B.data is not None
        assert B.data is not data
        assert B.stride == 4

    # No CPU storage
    # --------------
    def test_no_storage_copy(self):
        data = np.ones(100, np.float32)
        B = DataBuffer(data, store=False)
        assert B.data is None
        assert B.stride == 4

    # Empty init (not allowed)
    # ------------------------
    def test_empty_init(self):
        # with self.assertRaises(ValueError):
        #    B = DataBuffer()
        self.assertRaises(ValueError, DataBuffer)

    # Wrong storage
    # -------------
    def test_non_contiguous_storage(self):
        # Ask to have CPU storage and to use data as storage
        # Not possible since data[::2] is not contiguous
        data = np.ones(100, np.float32)
        data_given = data[::2]
        
        B = DataBuffer(data_given, store=True)
        assert B._data is not data_given
        assert B.stride == 4
        
        B = DataBuffer(data_given, store=False)
        assert B._data is not data_given
        assert B.stride == 4*2

    # Get buffer field
    # ----------------
    def test_getitem_field(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data = np.zeros(10, dtype=dtype)
        B = DataBuffer(data)

        Z = B["position"]
        assert Z.nbytes == 10 * 3 * np.dtype(np.float32).itemsize
        assert Z.offset == 0
        assert Z.size == 10
        assert Z.itemsize == 3 * np.dtype(np.float32).itemsize
        assert Z.stride == (3 + 2 + 4) * np.dtype(np.float32).itemsize
        assert Z.dtype == (np.float32, 3)

        Z = B["texcoord"]
        assert Z.nbytes == 10 * 2 * np.dtype(np.float32).itemsize
        assert Z.offset == 3 * np.dtype(np.float32).itemsize
        assert Z.size == 10
        assert Z.itemsize == 2 * np.dtype(np.float32).itemsize
        assert Z.stride == (3 + 2 + 4) * np.dtype(np.float32).itemsize
        assert Z.dtype == (np.float32, 2)

        Z = B["color"]
        assert Z.nbytes == 10 * 4 * np.dtype(np.float32).itemsize
        assert Z.offset == (2 + 3) * np.dtype(np.float32).itemsize
        assert Z.size == 10
        assert Z.itemsize == 4 * np.dtype(np.float32).itemsize
        assert Z.stride == (3 + 2 + 4) * np.dtype(np.float32).itemsize
        assert Z.dtype == (np.float32, 4)

    # Get item via index
    # ------------------
    def test_getitem_index(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data = np.zeros(10, dtype=dtype)
        B = DataBuffer(data)
        Z = B[0]
        assert Z.nbytes == 1 * (3 + 2 + 4) * np.dtype(np.float32).itemsize
        assert Z.offset == 0
        assert Z.size == 1
        assert Z.itemsize == (3 + 2 + 4) * np.dtype(np.float32).itemsize
        assert Z.stride == (3 + 2 + 4) * np.dtype(np.float32).itemsize
        assert Z.dtype == B.dtype

    # View get invalidated when base is resized
    # -----------------------------------------
    def test_invalid_view_after_resize(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data = np.zeros(10, dtype=dtype)
        B = DataBuffer(data)
        Z = B[5:]
        B.resize(5)
        assert Z._valid is False

    # View get invalidated after setting oversized data
    # -------------------------------------------------
    def test_invalid_view_after_set_data(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data = np.zeros(10, dtype=dtype)
        B = DataBuffer(data)
        Z = B[5:]
        B.set_data(np.zeros(15, dtype=dtype))
        assert Z._valid is False

    # Set data on base buffer : ok
    # ----------------------------
    def test_set_data_base(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data = np.zeros(10, dtype=dtype)
        B = DataBuffer(data, store=True)
        B.set_data(data)
        assert len(B._pending_data) == 1

    # Set data on view buffer : error
    # -------------------------------
    def test_set_data_base_view(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data = np.zeros(10, dtype=dtype)
        B = DataBuffer(data, store=True)
        # set_data on field is not allowed because set_data
        # can result in a buffer resize

        # with self.assertRaises(ValueError):
        #    B['position'].set_data(data)
        Z = B['position']
        self.assertRaises(ValueError, Z.set_data, data)

    # Check set_data using offset in data buffer
    # ------------------------------------------
    def test_set_data_offset(self):
        data = np.zeros(100, np.float32)
        subdata = data[:10]
        
        B = DataBuffer(data)
        B.set_data(subdata, offset=10)
        offset = B._pending_data[-1][2]
        assert offset == 10*4

    # Setitem + broadcast
    # ------------------------------------------------------
    def test_setitem_broadcast(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data = np.zeros(10, dtype=dtype)
        B = DataBuffer(data, store=True)
        B['position'] = 1, 2, 3
        assert np.allclose(data['position'].ravel(), np.resize([1, 2, 3], 30))

    # Setitem ellipsis
    # ------------------------------------------------------
    def test_setitem_ellipsis(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data1 = np.zeros(10, dtype=dtype)
        data2 = np.ones(10, dtype=dtype)
        B = DataBuffer(data1, store=True)
        B[...] = data2
        assert np.allclose(data1['position'], data2['position'])
        assert np.allclose(data1['texcoord'], data2['texcoord'])
        assert np.allclose(data1['color'], data2['color'])

    # Set every 2 item
    # ------------------------------------------------------
    def test_setitem_strided(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data1 = np.zeros(10, dtype=dtype)
        data2 = np.ones(10, dtype=dtype)
        B = DataBuffer(data1, store=True)
        B[::2] = data2[::2]
        assert np.allclose(data1['position'][::2], data2['position'][::2])
        assert np.allclose(data1['texcoord'][::2], data2['texcoord'][::2])
        assert np.allclose(data1['color'][::2], data2['color'][::2])

    # Set half the array
    # ------------------------------------------------------
    def test_setitem_half(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data1 = np.zeros(10, dtype=dtype)
        data2 = np.ones(10, dtype=dtype)
        B = DataBuffer(data1, store=True)
        B[:5] = data2[:5]
        assert np.allclose(data1['position'][:5], data2['position'][:5])
        assert np.allclose(data1['texcoord'][:5], data2['texcoord'][:5])
        assert np.allclose(data1['color'][:5], data2['color'][:5])
        assert len(B._pending_data) == 2

    # Set field without storage: error
    # --------------------------------
    def test_setitem_field_no_storage(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data = np.zeros(10, dtype=dtype)
        B = DataBuffer(data, store=False)
        # with self.assertRaises(ValueError):
        #    B['position'] = 1, 2, 3
        self.assertRaises(ValueError,  B.__setitem__, 'position', (1, 2, 3))

    # Set every 2 item without storage:  error
    # ----------------------------------------
    def test_every_two_item_no_storage(self):
        dtype = np.dtype([('position', np.float32, 3),
                          ('texcoord', np.float32, 2),
                          ('color',    np.float32, 4)])
        data = np.zeros(10, dtype=dtype)
        B = DataBuffer(data, store=False)
        # with self.assertRaises(ValueError):
        #    B[::2] = data[::2]
        s = slice(None, None, 2)
        self.assertRaises(ValueError, B.__setitem__, s, data[::2])

    # Resize
    # ------
    def test_resize(self):
        data = np.zeros(10)
        B = DataBuffer(data=data)
        data = np.zeros(20)
        B.set_data(data)
        assert B.nbytes == data.nbytes
        assert B._need_resize is True

    # Resize not allowed using ellipsis
    # --------------------------------
    def test_no_resize_ellipsis(self):
        data = np.zeros(10)
        B = DataBuffer(data=data)
        data = np.zeros(30)
        # with self.assertRaises(ValueError):
        #    B[...] = data
        self.assertRaises(ValueError, B.__setitem__, Ellipsis, data)

    # Resize when no resizeable
    # -------------------------
    def test_resize_no_resizeable(self):
        data = np.zeros(10)
        B = DataBuffer(data=data, resizeable=False)
        data = np.zeros(20)
        # with self.assertRaises(ValueError):
        #    B.set_data(data)
        self.assertRaises(ValueError, B.set_data, data)


# -----------------------------------------------------------------------------
class VertexBufferTest(unittest.TestCase):

    # VertexBuffer allowed base types
    # -------------------------------
    def test_init_allowed_dtype(self):
        for dtype in (np.uint8, np.int8, np.uint16, np.int16, np.float32):
            V = VertexBuffer(dtype=dtype)
            names = V.dtype.names
            assert V.dtype[names[0]].base == dtype
            assert V.dtype[names[0]].shape == ()

    # VertexBuffer not allowed base types
    # -----------------------------------
    def test_init_not_allowed_dtype(self):
        for dtype in (np.uint32, np.int32, np.float64):
            # with self.assertRaises(TypeError):
            #    V = VertexBuffer(dtype=dtype)
            self.assertRaises(TypeError, VertexBuffer, dtype=dtype)

# -----------------------------------------------------------------------------


class IndexBufferTest(unittest.TestCase):

    # IndexBuffer allowed base types
    # ------------------------------
    def test_init_allowed_dtype(self):
        for dtype in (np.uint8, np.uint16, np.uint32):
            V = IndexBuffer(dtype=dtype)
            assert V.dtype == dtype

    # IndexBuffer not allowed base types
    # -----------------------------------
    def test_init_not_allowed_dtype(self):
        for dtype in (np.int8, np.int16, np.int32,
                      np.float16, np.float32, np.float64):
            # with self.assertRaises(TypeError):
            #    V = IndexBuffer(dtype=dtype)
            self.assertRaises(TypeError, IndexBuffer, dtype=dtype)

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_globject
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Nicolas P. Rougier. All rights reserved.
# Distributed under the terms of the new BSD License.
# -----------------------------------------------------------------------------
import unittest
from vispy.gloo.globject import GLObject


# -----------------------------------------------------------------------------
class GLObjectTest(unittest.TestCase):

    # Default init
    # ------------
    def test_init_default(self):
        O = GLObject()

        assert O._handle == -1
        assert O._target is None
        assert O._need_create is True
        assert O._need_update is True
        assert O._need_delete is False
        assert O._id > 0
        assert O._id == GLObject._idcount
if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_program
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Nicolas P. Rougier. All rights reserved.
# Distributed under the terms of the new BSD License.
# -----------------------------------------------------------------------------
import unittest

from vispy.gloo import gl
from vispy.gloo.program import Program
from vispy.gloo.shader import VertexShader, FragmentShader


class ProgramTest(unittest.TestCase):

    def test_init(self):
        program = Program()
        assert program._handle == -1
        assert program.shaders == []

    def test_delete_no_context(self):
        program = Program()
        program.delete()

    def test_init_from_string(self):
        program = Program("A", "B")
        assert len(program.shaders) == 2
        assert program.shaders[0].code == "A"
        assert program.shaders[1].code == "B"

    def test_init_from_shader(self):
        program = Program(VertexShader("A"), FragmentShader("B"))
        assert len(program.shaders) == 2
        assert program.shaders[0].code == "A"
        assert program.shaders[1].code == "B"

    def test_unique_shader(self):
        vert = VertexShader("A")
        frag = FragmentShader("B")
        program = Program([vert, vert], [frag, frag, frag])
        assert len(program.shaders) == 2

    def test_uniform(self):
        vert = VertexShader("uniform float A;")
        frag = FragmentShader("uniform float A; uniform vec4 B;")
        program = Program(vert, frag)
        assert ("A", gl.GL_FLOAT) in program.all_uniforms
        assert ("B", gl.GL_FLOAT_VEC4) in program.all_uniforms
        assert len(program.all_uniforms) == 2

    def test_attributes(self):
        vert = VertexShader("attribute float A;")
        frag = FragmentShader("")
        program = Program(vert, frag)
        assert program.all_attributes == [("A", gl.GL_FLOAT)]

    def test_attach(self):
        vert = VertexShader("A")
        frag = FragmentShader("B")
        program = Program(vert)
        program.attach(frag)
        assert len(program.shaders) == 2
        assert program.shaders[0].code == "A"
        assert program.shaders[1].code == "B"

    def test_detach(self):
        vert = VertexShader("A")
        frag = FragmentShader("B")
        program = Program(vert, frag)
        program.detach(frag)
        assert len(program.shaders) == 1
        assert program.shaders[0].code == "A"

    def test_failed_build(self):
        vert = VertexShader("A")
        frag = FragmentShader("B")

        program = Program(vert=vert)
        program._need_create = False  # fool program that it already exists
        self.assertRaises(ValueError, program.activate)

        program = Program(frag=frag)
        program._need_create = False  # fool program that it already exists
        self.assertRaises(ValueError, program.activate)

    def test_setitem(self):
        vert = VertexShader("")
        frag = FragmentShader("")

        program = Program(vert, frag)
        #with self.assertRaises(ValueError):
        #    program["A"] = 1
        self.assertRaises(ValueError, program.__setitem__, "A", 1)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_shader
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Nicolas P. Rougier. All rights reserved.
# Distributed under the terms of the new BSD License.
# -----------------------------------------------------------------------------
import unittest

from vispy.gloo import gl
from vispy.gloo.shader import VertexShader, FragmentShader


# -----------------------------------------------------------------------------
class VertexShaderTest(unittest.TestCase):

    def test_init(self):
        shader = VertexShader()
        assert shader._target == gl.GL_VERTEX_SHADER


# -----------------------------------------------------------------------------
class FragmentShaderTest(unittest.TestCase):

    def test_init(self):
        shader = FragmentShader()
        assert shader._target == gl.GL_FRAGMENT_SHADER


# -----------------------------------------------------------------------------
class ShaderTest(unittest.TestCase):

    def test_init(self):
        shader = VertexShader()
        assert shader._handle == -1
        assert shader.code is None
        assert shader.source is None

    def test_sourcecode(self):
        code = "/* Code */"
        shader = VertexShader(code)
        assert shader.code == code
        assert shader.source == "<string>"

    def test_empty_build(self):
        shader = VertexShader()
        #with self.assertRaises(RuntimeError):
        #    shader.activate()
        self.assertRaises(RuntimeError, shader.activate)

    def test_delete_no_context(self):
        shader = VertexShader()
        shader.delete()

    def test_uniform_float(self):
        shader = VertexShader("uniform float color;")
        assert shader.uniforms == [("color", gl.GL_FLOAT)]

    def test_uniform_vec4(self):
        shader = VertexShader("uniform vec4 color;")
        assert shader.uniforms == [("color", gl.GL_FLOAT_VEC4)]

    def test_uniform_array(self):
        shader = VertexShader("uniform float color[2];")
        assert shader.uniforms == [("color[0]", gl.GL_FLOAT),
                                   ("color[1]", gl.GL_FLOAT)]

    def test_attribute_float(self):
        shader = VertexShader("attribute float color;")
        assert shader.attributes == [("color", gl.GL_FLOAT)]

    def test_attribute_vec4(self):
        shader = VertexShader("attribute vec4 color;")
        assert shader.attributes == [("color", gl.GL_FLOAT_VEC4)]


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_texture
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Nicolas P. Rougier. All rights reserved.
# Distributed under the terms of the new BSD License.
# -----------------------------------------------------------------------------
import unittest
import numpy as np

from vispy.gloo.texture import Texture, Texture1D, Texture2D
from vispy.gloo import gl


# ----------------------------------------------------------------- Texture ---
class TextureTest(unittest.TestCase):

    # No data, no dtype : forbidden
    # ---------------------------------
    def test_init_none(self):
        # with self.assertRaises(ValueError):
        #    T = Texture()
        self.assertRaises(ValueError, Texture)

    # Data only
    # ---------------------------------
    def test_init_data(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data)
        assert T._shape == (10, 10)
        assert T._dtype == np.uint8
        assert T._offset == (0, 0)
        assert T._store is True
        assert T._copy is False
        assert T._need_resize is True
        assert T._need_update is True
        assert T._data is data
        assert len(T._pending_data) == 1

    # Non contiguous data
    # ---------------------------------
    def test_init_non_contiguous_data(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data[::2, ::2])
        assert T._shape == (5, 5)
        assert T._dtype == np.uint8
        assert T._offset == (0, 0)
        assert T._store is True
        assert T._copy is True
        assert T._need_resize is True
        assert T._need_update is True
        assert T._data is not data
        assert len(T._pending_data) == 1

    # Dtype and shape
    # ---------------------------------
    def test_init_dtype_shape(self):
        T = Texture(shape=(10, 10), dtype=np.uint8)
        assert T._shape == (10, 10)
        assert T._dtype == np.uint8
        assert T._offset == (0, 0)
        assert T._store is True
        assert T._copy is False
        assert T._need_resize is True
        assert T._need_update is False
        assert T._data is not None
        assert T._data.shape == (10, 10)
        assert T._data.dtype == np.uint8
        assert len(T._pending_data) == 0

    # Dtype only
    # ---------------------------------
    def test_init_dtype(self):
        T = Texture(dtype=np.uint8)
        assert T._shape == ()
        assert T._dtype == np.uint8
        assert T._offset == ()
        assert T._store is True
        assert T._copy is False
        assert T._need_resize is False
        assert T._need_update is False
        assert T._data is not None
        assert len(T._pending_data) == 0

    # Data and dtype: dtype prevails
    # ---------------------------------
    def test_init_data_dtype(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data, dtype=np.uint16)
        assert T._shape == (10, 10)
        assert T._dtype == np.uint16
        assert T._offset == (0, 0)
        assert T._store is True
        assert T._copy is False
        assert T._need_resize is True
        assert T._need_update is True
        assert T._data is not data
        assert len(T._pending_data) == 1

    # Data, store but no copy
    # ---------------------------------
    def test_init_data_store(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data, store=True)
        assert T._data is data

    # Data, store and copy
    # ---------------------------------
    def test_init_data_store_copy(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data.copy(), store=True)
        assert T._data is not data
        assert T._data is not None

    # Get a view of the whole texture
    # ---------------------------------
    def test_getitem_ellipsis(self):

        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data)
        Z = T[...]
        assert Z._base is T
        assert Z._data.base is T._data
        assert Z._shape == (10, 10)
        assert Z._resizeable is False
        assert len(Z._pending_data) == 0

    # Get a view using ellipsis at start
    # ---------------------------------
    def test_getitem_ellipsis_start(self):

        data = np.zeros((10, 10, 10), dtype=np.uint8)
        T = Texture(data=data)
        Z = T[..., 0]
        assert Z._base is T
        assert Z._data.base is T._data
        assert Z._shape == (10, 10, 1)
        assert Z._resizeable is False
        assert len(Z._pending_data) == 0

    # Get a view using ellipsis at end
    # ---------------------------------
    def test_getitem_ellipsis_end(self):

        data = np.zeros((10, 10, 10), dtype=np.uint8)
        T = Texture(data=data)
        Z = T[0, ...]
        assert Z._base is T
        assert Z._data.base is T._data
        assert Z._shape == (1, 10, 10)
        assert Z._resizeable is False
        assert len(Z._pending_data) == 0

    # Get a single item
    # ---------------------------------
    def test_getitem_single(self):

        data = np.zeros((10, 10, 10), dtype=np.uint8)
        T = Texture(data=data)
        Z = T[0, 0, 0]
        assert Z._base is T
        assert Z._data.base is T._data
        assert Z._shape == (1, 1, 1)
        assert Z._resizeable is False
        assert len(Z._pending_data) == 0

    # Get a partial view
    # ---------------------------------
    def test_getitem_partial(self):

        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data)
        Z = T[2:5, 2:5]
        assert Z._base is T
        assert Z._data.base is T._data
        assert Z._shape == (3, 3)
        assert Z._offset == (2, 2)
        assert Z._resizeable is False
        assert len(Z._pending_data) == 0

    # Get non contiguous view : forbidden
    # ---------------------------------
    def test_getitem_non_contiguous(self):

        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data)
        # with self.assertRaises(ValueError):
        #    Z = T[::2, ::2]
        #    print(Z)
        s = slice(None, None, 2)
        self.assertRaises(ValueError, T.__getitem__, (s, s))

    # Set data with store
    # ---------------------------------
    def test_setitem_all(self):

        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data)
        T[...] = np.ones((10, 10))
        assert len(T._pending_data) == 1
        assert np.allclose(data, np.ones((10, 10)))

    # Set data without store
    # ---------------------------------
    def test_setitem_all_no_store(self):

        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data, store=False)
        T[...] = np.ones((10, 10), np.uint8)
        assert len(T._pending_data) == 1
        assert np.allclose(data, np.zeros((10, 10)))

    # Set a single data
    # ---------------------------------
    def test_setitem_single(self):

        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data)
        T[0, 0] = 1
        assert len(T._pending_data) == 2
        assert data[0, 0] == 1, 1

    # Set some data
    # ---------------------------------
    def test_setitem_partial(self):

        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data)
        T[5:, 5:] = 1
        assert len(T._pending_data) == 2
        assert np.allclose(data[5:, 5:], np.ones((5, 5)))

    # Set non contiguous data
    # ---------------------------------
    def test_setitem_wrong(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data)
        # with self.assertRaises(ValueError):
        #    T[::2, ::2] = 1
        s = slice(None, None, 2)
        self.assertRaises(ValueError, T.__setitem__, (s, s), 1)

    # Set via get (pending data on base)
    # ---------------------------------
    def test_getitem_setitem(self):

        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture(data=data)
        Z = T[5:, 5:]
        Z[...] = 1
        assert len(Z._pending_data) == 0
        assert len(T._pending_data) == 2
        assert np.allclose(data[5:, 5:], np.ones((5, 5)))


# --------------------------------------------------------------- Texture1D ---
class Texture1DTest(unittest.TestCase):
    
    # Shape extension
    # ---------------------------------
    def test_init(self):
        data = np.zeros(10, dtype=np.uint8)
        T = Texture1D(data=data)
        assert T._shape == (10, 1)

    # Width
    # ---------------------------------
    def test_width(self):
        data = np.zeros(10, dtype=np.uint8)
        T = Texture1D(data=data)
        assert T.width == 10

    # Set misshaped data
    # ---------------------------------
    def test_set_misshaped_data_1D(self):
        data = np.zeros(10, dtype=np.uint8)
        T = Texture1D(data=data)
        # with self.assertRaises(ValueError):
        #    T.set_data(np.ones((10, 10)))
        self.assertRaises(ValueError, T.set_data, np.ones((10, 10)))


# --------------------------------------------------------------- Texture2D ---
class Texture2DTest(unittest.TestCase):
    # Note: put many tests related to (re)sizing here, because Texture
    # is not really aware of shape.
    
    # Shape extension
    # ---------------------------------
    def test_init(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture2D(data=data)
        assert T._shape == (10, 10, 1)

    # Width & height
    # ---------------------------------
    def test_width_height(self):
        data = np.zeros((10, 20), dtype=np.uint8)
        T = Texture2D(data=data)
        assert T.width == 20
        assert T.height == 10
    
    # Resize
    # ---------------------------------
    def test_resize(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture2D(data=data)
        T.resize((5, 5))
        assert T.shape == (5, 5, 1)
        assert T._data.shape == (5, 5, 1)
        assert T._need_resize is True
        assert T._need_update is False
        assert len(T._pending_data) == 0

    # Resize with bad shape
    # ---------------------------------
    def test_resize_bad_shape(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture2D(data=data)
        # with self.assertRaises(ValueError):
        #    T.resize((5, 5, 5))
        self.assertRaises(ValueError, T.resize, (5, 5, 5))

    # Resize view (forbidden)
    # ---------------------------------
    def test_resize_view(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture2D(data=data)
        # with self.assertRaises(RuntimeError):
        #    T[...].resize((5, 5))
        Z = T[...]
        self.assertRaises(RuntimeError, Z.resize, (5, 5))

    # Resize not resizeable
    # ---------------------------------
    def test_resize_unresizeable(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture2D(data=data, resizeable=False)
        # with self.assertRaises(RuntimeError):
        #    T.resize((5, 5))
        self.assertRaises(RuntimeError, T.resize, (5, 5))
    
    # Set oversized data (-> resize)
    # ---------------------------------
    def test_set_oversized_data(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture2D(data=data)
        T.set_data(np.ones((20, 20), np.uint8))
        assert T.shape == (20, 20, 1)
        assert T._data.shape == (20, 20, 1)
        assert len(T._pending_data) == 1
    
    # Set undersized data
    # ---------------------------------
    def test_set_undersized_data(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture2D(data=data)
        T.set_data(np.ones((5, 5), np.uint8))
        assert T.shape == (5, 5, 1)
        assert len(T._pending_data) == 1

    # Set misplaced data
    # ---------------------------------
    def test_set_misplaced_data(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture2D(data=data)
        # with self.assertRaises(ValueError):
        #    T.set_data(np.ones((5, 5)), offset=(8, 8))
        self.assertRaises(ValueError, T.set_data,
                          np.ones((5, 5)), offset=(8, 8))

    # Set misshaped data
    # ---------------------------------
    def test_set_misshaped_data_2D(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture2D(data=data)
        # with self.assertRaises(ValueError):
        #    T.set_data(np.ones((10, 10)))
        self.assertRaises(ValueError, T.set_data, np.ones((10,)))

    # Set whole data (clear pending data)
    # ---------------------------------
    def test_set_whole_data(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture2D(data=data)
        T.set_data(np.ones((10, 10), np.uint8))
        assert T.shape == (10, 10, 1)
        assert len(T._pending_data) == 1
    
    # Test view get invalidated when base is resized
    # ----------------------------------------------
    def test_invalid_views(self):
        data = np.zeros((10, 10), dtype=np.uint8)
        T = Texture2D(data=data)
        Z = T[5:, 5:]
        T.resize((5, 5))
        assert Z._valid is False
    
    # Test set data with different shape
    # ---------------------------------
    def test_reset_data_shape(self):
        shape1 = 10, 10
        shape3 = 10, 10, 3
        
        # Init data (explicit shape)
        data = np.zeros((10, 10, 1), dtype=np.uint8)
        T = Texture2D(data=data)
        assert T.shape == (10, 10, 1)
        assert T._format == gl.GL_LUMINANCE
        
        # Set data to rgb
        T.set_data(np.zeros(shape3, np.uint8))
        assert T.shape == (10, 10, 3)
        assert T._format == gl.GL_RGB
        
        # Set data to grayscale
        T.set_data(np.zeros(shape1, np.uint8))
        assert T.shape == (10, 10, 1)
        assert T._format == gl.GL_LUMINANCE
        
        # Set size to rgb
        T.resize(shape3)
        assert T.shape == (10, 10, 3)
        assert T._format == gl.GL_RGB
        
        # Set size to grayscale
        T.resize(shape1)
        assert T.shape == (10, 10, 1)
        assert T._format == gl.GL_LUMINANCE
    
    # Test set data with different shape
    # ---------------------------------
    def test_reset_data_type(self):
        shape = 10, 10
        T = Texture2D(data=np.zeros(shape, dtype=np.uint8))
        assert T.dtype == np.uint8
        assert T._gtype == gl.GL_UNSIGNED_BYTE
        
        newdata = np.zeros(shape, dtype=np.float32)
        self.assertRaises(ValueError, T.set_data, newdata)
        
        newdata = np.zeros(shape, dtype=np.int32)
        self.assertRaises(ValueError, T.set_data, newdata)


# -----------------------------------------------------------------------------
if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_variable
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Nicolas P. Rougier. All rights reserved.
# Distributed under the terms of the new BSD License.
# -----------------------------------------------------------------------------
import unittest
import numpy as np

from vispy.gloo import gl
from vispy.gloo.variable import Uniform, Variable, Attribute


# -----------------------------------------------------------------------------
class VariableTest(unittest.TestCase):

    def test_init(self):
        variable = Variable(None, "A", gl.GL_FLOAT)
        assert variable._handle == -1
        assert variable.name == "A"
        assert variable.data is None
        assert variable.gtype == gl.GL_FLOAT
        assert variable.active is True

    def test_init_wrong_type(self):
        # with self.assertRaises(TypeError):
        #    v = Variable(None, "A", gl.GL_INT_VEC2)
        self.assertRaises(TypeError, Variable, None, "A", gl.GL_INT_VEC2)

        # with self.assertRaises(TypeError):
        #    v = Variable(None, "A", gl.GL_INT_VEC3)
        self.assertRaises(TypeError, Variable, None, "A", gl.GL_INT_VEC3)

        # with self.assertRaises(TypeError):
        #    v = Variable(None, "A", gl.GL_INT_VEC4)
        self.assertRaises(TypeError, Variable, None, "A", gl.GL_INT_VEC4)

        # with self.assertRaises(TypeError):
        #    v = Variable(None, "A", gl.GL_BOOL_VEC2)
        self.assertRaises(TypeError, Variable, None, "A", gl.GL_BOOL_VEC2)

        # with self.assertRaises(TypeError):
        #    v = Variable(None, "A", gl.GL_BOOL_VEC3)
        self.assertRaises(TypeError, Variable, None, "A", gl.GL_BOOL_VEC3)

        # with self.assertRaises(TypeError):
        #    v = Variable(None, "A", gl.GL_BOOL_VEC4)
        self.assertRaises(TypeError, Variable, None, "A", gl.GL_BOOL_VEC4)


# -----------------------------------------------------------------------------
class UniformTest(unittest.TestCase):

    def test_init(self):
        uniform = Uniform(None, "A", gl.GL_FLOAT)
        assert uniform._unit == -1

    def test_float(self):
        uniform = Uniform(None, "A", gl.GL_FLOAT)
        assert uniform.data.dtype == np.float32
        assert uniform.data.size == 1

    def test_vec2(self):
        uniform = Uniform(None, "A", gl.GL_FLOAT_VEC2)
        assert uniform.data.dtype == np.float32
        assert uniform.data.size == 2

    def test_vec3(self):
        uniform = Uniform(None, "A", gl.GL_FLOAT_VEC2)
        assert uniform.data.dtype == np.float32
        assert uniform.data.size == 2

    def test_vec4(self):
        uniform = Uniform(None, "A", gl.GL_FLOAT_VEC2)
        assert uniform.data.dtype == np.float32
        assert uniform.data.size == 2

    def test_int(self):
        uniform = Uniform(None, "A", gl.GL_INT)
        assert uniform.data.dtype == np.int32
        assert uniform.data.size == 1

    def test_mat2(self):
        uniform = Uniform(None, "A", gl.GL_FLOAT_MAT2)
        assert uniform.data.dtype == np.float32
        assert uniform.data.size == 4

    def test_mat3(self):
        uniform = Uniform(None, "A", gl.GL_FLOAT_MAT3)
        assert uniform.data.dtype == np.float32
        assert uniform.data.size == 9

    def test_mat4(self):
        uniform = Uniform(None, "A", gl.GL_FLOAT_MAT4)
        assert uniform.data.dtype == np.float32
        assert uniform.data.size == 16

    def test_set(self):
        uniform = Uniform(None, "A", gl.GL_FLOAT_VEC4)

        uniform.set_data(1)
        assert (uniform.data == 1).all()

        uniform.set_data([1, 2, 3, 4])
        assert (uniform.data == [1, 2, 3, 4]).all()

    def test_set_exception(self):
        uniform = Uniform(None, "A", gl.GL_FLOAT_VEC4)

        # with self.assertRaises(ValueError):
        #    uniform.set_data([1, 2])
        self.assertRaises(ValueError, uniform.set_data, [1, 2])

        # with self.assertRaises(ValueError):
        #    uniform.set_data([1, 2, 3, 4, 5])
        self.assertRaises(ValueError, uniform.set_data, [1, 2, 3, 4, 5])


# -----------------------------------------------------------------------------
class AttributeTest(unittest.TestCase):

    def test_init(self):
        attribute = Attribute(None, "A", gl.GL_FLOAT)
        assert attribute.size == 0

    def test_set_generic(self):
        attribute = Attribute(None, "A", gl.GL_FLOAT_VEC4)

        attribute.set_data(1)
        assert type(attribute.data) is np.ndarray

#    @unittest.expectedFailure
#    def test_set_generic_2(self):
#        attribute = Attribute(None, "A", gl.GL_FLOAT_VEC4)
#        attribute.set_data([1, 2, 3, 4])
#        assert type(attribute.data) is np.ndarray


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_wrappers
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Nicolas P. Rougier. All rights reserved.
# Distributed under the terms of the new BSD License.
# -----------------------------------------------------------------------------
import numpy as np
from numpy.testing import assert_array_equal
from nose.tools import assert_true, assert_equal, assert_raises

from vispy import gloo
from vispy.gloo import gl
from vispy.app import Canvas
from vispy.testing import requires_application


@requires_application()
def test_wrappers():
    """Test gloo wrappers"""
    with Canvas():
        gl.use('desktop debug')
        # check presets
        assert_raises(ValueError, gloo.set_state, preset='foo')
        for state in gloo.get_state_presets().keys():
            gloo.set_state(state)
        assert_raises(ValueError, gloo.set_blend_color, (0., 0.))  # bad color
        assert_raises(TypeError, gloo.set_hint, 1, 2)  # need strs
        assert_raises(TypeError, gloo.get_parameter, 1)  # need str
        # this doesn't exist in ES 2.0 namespace
        assert_raises(ValueError, gloo.set_hint, 'fog_hint', 'nicest')
        # test bad enum
        assert_raises(RuntimeError, gloo.set_line_width, -1)

        # check read_pixels
        assert_true(isinstance(gloo.read_pixels(), np.ndarray))
        assert_true(isinstance(gloo.read_pixels((0, 0, 1, 1)), np.ndarray))
        assert_raises(ValueError, gloo.read_pixels, (0, 0, 1))  # bad port

        # now let's (indirectly) check our set_* functions
        viewport = (0, 0, 1, 1)
        blend_color = (0., 0., 0.)
        _funs = dict(viewport=viewport,  # checked
                     hint=('generate_mipmap_hint', 'nicest'),
                     depth_range=(1., 2.),
                     front_face='cw',  # checked
                     cull_face='front',
                     line_width=1.,
                     polygon_offset=(1., 1.),
                     blend_func=('zero', 'one'),
                     blend_color=blend_color,
                     blend_equation='func_add',
                     scissor=(0, 0, 1, 1),
                     stencil_func=('never', 1, 2, 'back'),
                     stencil_mask=4,
                     stencil_op=('zero', 'zero', 'zero', 'back'),
                     depth_func='greater',
                     depth_mask=True,
                     color_mask=(True, True, True, True),
                     sample_coverage=(0.5, True))
        gloo.set_state(**_funs)
        gloo.clear((1., 1., 1., 1.), 0.5, 1)
        gloo.flush()
        gloo.finish()
        # check some results
        assert_array_equal(gloo.get_parameter('viewport'), viewport)
        assert_equal(gloo.get_parameter('front_face'), gl.GL_CW)
        assert_equal(gloo.get_parameter('blend_color'), blend_color + (1,))

########NEW FILE########
__FILENAME__ = texture
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
import numpy as np

from . import gl
from .globject import GLObject
from ..util import logger


# ----------------------------------------------------------- Texture class ---
class Texture(GLObject):
    """
    A Texture is used to represent a topological set of scalar values.
    
    Parameters
    ----------

    target : GLEnum
        gl.GL_TEXTURE2D
        gl.GL_TEXTURE_CUBE_MAP
    data : ndarray
        Texture data (optional)
    shape : tuple of integers
        Texture shape (optional)
    dtype : dtype
        Texture data type (optional)
    base : Texture
        Base texture of this texture
    offset : tuple of integers
        Offset of this texture relative to base texture
    store : bool
        Specify whether this object stores a reference to the data,
        allowing the data to be updated regardless of striding. Note
        that modifying the data after passing it here might result in
        undesired behavior, unless a copy is given. Default True.
    resizeable : bool
        Indicates whether texture can be resized
    """

    _formats = {
        1: gl.GL_LUMINANCE,  # or ALPHA,
        2: gl.GL_LUMINANCE_ALPHA,
        3: gl.GL_RGB,
        4: gl.GL_RGBA
    }

    _types = {
        np.dtype(np.int8): gl.GL_BYTE,
        np.dtype(np.uint8): gl.GL_UNSIGNED_BYTE,
        np.dtype(np.int16): gl.GL_SHORT,
        np.dtype(np.uint16): gl.GL_UNSIGNED_SHORT,
        np.dtype(np.int32): gl.GL_INT,
        np.dtype(np.uint32): gl.GL_UNSIGNED_INT,
        # np.dtype(np.float16) : gl.GL_HALF_FLOAT,
        np.dtype(np.float32): gl.GL_FLOAT,
        # np.dtype(np.float64) : gl.GL_DOUBLE
    }

    def __init__(self, data=None, shape=None, dtype=None, base=None, 
                 target=None, offset=None, store=True, resizeable=True):
        GLObject.__init__(self)
        self._data = None
        self._base = base
        self._store = store
        self._copy = False  # flag to indicate that a copy is made
        self._target = target
        self._offset = offset
        self._pending_data = []
        self._resizeable = resizeable
        self._need_resize = False
        self._need_update = False
        self._valid = True
        self._views = []

        self._interpolation = gl.GL_NEAREST, gl.GL_NEAREST
        self._wrapping = gl.GL_CLAMP_TO_EDGE
        self._need_parameterization = True

        # Do we have data to build texture upon ?
        if data is not None:
            self._need_resize = True
            # Handle dtype
            if dtype is not None:
                data = np.array(data, dtype=dtype, copy=False)
            else:
                data = np.array(data, copy=False)
            self._dtype = data.dtype
            # Handle shape
            data = self._normalize_shape(data)
            if shape is not None:
                raise ValueError('Texture needs data or shape, nor both.')
            self._shape = data.shape
            # Handle storage
            if self._store:
                if not data.flags["C_CONTIGUOUS"]:
                    logger.warning("Copying discontiguous data as CPU storage")
                    self._copy = True
                    data = data.copy()
                self._data = data
            # Set data
            self.set_data(data, copy=False)
        elif dtype is not None:
            if shape is not None:
                self._need_resize = True
            shape = shape or ()
            self._shape = self._normalize_shape(shape)
            self._dtype = dtype
            if self._store:
                self._data = np.empty(self._shape, dtype=self._dtype)
        else:
            raise ValueError("Either data or dtype must be given")

        if offset is None:
            self._offset = (0,) * len(self._shape)
        else:
            self._offset = offset
        
        # Check dtype
        if hasattr(self._dtype, 'fields') and self._dtype.fields:
            raise ValueError("Texture dtype cannot be structured")

        self._gtype = Texture._types.get(np.dtype(self.dtype), None)
        if self._gtype is None:
            raise ValueError("Type not allowed for texture")

    def _normalize_shape(self, data_or_shape):
        return data_or_shape
    
    @property
    def shape(self):
        """ Texture shape """

        return self._shape

    @property
    def offset(self):
        """ Texture offset """

        return self._offset

    @property
    def dtype(self):
        """ Texture data type """

        return self._dtype

    @property
    def base(self):
        """ Texture base if this texture is a view on another texture """

        return self._base

    @property
    def data(self):
        """ Texture CPU storage """

        return self._data

    @property
    def wrapping(self):
        """ Texture wrapping mode """

        if self.base is not None:
            return self.base.wrapping
        return self._wrapping

    @wrapping.setter
    def wrapping(self, value):
        """ Texture wrapping mode """

        if self.base is not None:
            raise ValueError("Cannot set wrapping on texture view")

        assert value in (gl.GL_REPEAT, gl.GL_CLAMP_TO_EDGE,
                         gl.GL_MIRRORED_REPEAT)
        self._wrapping = value
        self._need_parameterization = True

    @property
    def interpolation(self):
        """ Texture interpolation for minification and magnification. """

        if self.base is not None:
            return self.base.interpolation

        return self._interpolation

    @interpolation.setter
    def interpolation(self, value):
        """ Texture interpolation for minication and magnification. """

        if self.base is not None:
            raise ValueError("Cannot set interpolation on texture view")

        assert value in (gl.GL_NEAREST, gl.GL_LINEAR)
        self._interpolation = value
        self._need_parameterization = True

    def resize(self, shape):
        """ Resize the texture (deferred operation)

        Parameters
        ----------

        shape : tuple of integers
            New texture shape

        Notes
        -----
        This clears any pending operations.
        """
        
        shape = self._normalize_shape(shape)
        
        if not self._resizeable:
            raise RuntimeError("Texture is not resizeable")

        if self._base is not None:
            raise RuntimeError("Texture view is not resizeable")

        if len(shape) != len(self.shape):
            raise ValueError("New shape has wrong number of dimensions")

        if shape == self.shape:
            return
        
        # Reset format if size of last dimension differs
        if shape[-1] != self.shape[-1]:
            format = Texture._formats.get(shape[-1], None)
            if format is None:
                raise ValueError("Cannot determine texture format from shape")
            self._format = format
        
        # Invalidate any view on this texture
        for view in self._views:
            view._valid = False
        self._views = []

        self._pending_data = []
        self._need_update = False
        self._need_resize = True
        self._shape = shape
        if self._data is not None and self._store:
            self._data = np.resize(self._data, self._shape)
        else:
            self._data = None

    def set_data(self, data, offset=None, copy=False):
        """
        Set data (deferred operation)

        Parameters
        ----------

        data : ndarray
            Data to be uploaded
        offset: int or tuple of ints
            Offset in texture where to start copying data
        copy: bool
            Since the operation is deferred, data may change before
            data is actually uploaded to GPU memory.
            Asking explicitly for a copy will prevent this behavior.

        Notes
        -----
        This operation implicitely resizes the texture to the shape of the data
        if given offset is None.
        """

        if self.base is not None and not self._valid:
            raise ValueError("This texture view has been invalidated")

        if self.base is not None:
            self.base.set_data(data, offset=self.offset, copy=copy)
            return
        
        # Force using the same data type. We could probably allow it,
        # but with the views and data storage, this is rather complex.
        if data.dtype != self.dtype:
            raise ValueError('Cannot set texture data with another dtype.')
        
        # Copy if needed, check/normalize shape
        data = np.array(data, copy=copy)
        data = self._normalize_shape(data)
        
        # Check data has the right shape
        # if len(data.shape) != len(self.shape):
        #  raise ValueError("Data has wrong shape")

        # Check if resize needed
        if offset is None:
            if data.shape != self.shape:
                self.resize(data.shape)

        if offset is None or offset == (0,) * len(self.shape):
            if data.shape == self.shape:
                self._pending_data = []

            # Convert offset to something usable
            offset = (0,) * len(self.shape)

        # Check if data fits
        for i in range(len(data.shape)):
            if offset[i] + data.shape[i] > self.shape[i]:
                raise ValueError("Data is too large")
        
        if self._store:
            pass  
            # todo: @nico should we not update self._data?
            # but we need to keep the offset into account.
        
        self._pending_data.append((data, offset))
        self._need_update = True

    def __getitem__(self, key):
        """ x.__getitem__(y) <==> x[y] """

        if self.base is not None:
            raise ValueError("Can only access data from a base texture")

        # Make sure key is a tuple
        if isinstance(key, (int, slice)) or key == Ellipsis:
            key = (key,)

        # Default is to access the whole texture
        shape = self.shape
        slices = [slice(0, shape[i]) for i in range(len(shape))]

        # Check last key/Ellipsis to decide on the order
        keys = key[::+1]
        dims = range(0, len(key))
        if key[0] == Ellipsis:
            keys = key[::-1]
            dims = range(len(self.shape) - 1,
                         len(self.shape) - 1 - len(keys), -1)

        # Find exact range for each key
        for k, dim in zip(keys, dims):
            size = self.shape[dim]
            if isinstance(k, int):
                if k < 0:
                    k += size
                if k < 0 or k > size:
                    raise IndexError("Texture assignment index out of range")
                start, stop = k, k + 1
                slices[dim] = slice(start, stop, 1)
            elif isinstance(k, slice):
                start, stop, step = k.indices(size)
                if step != 1:
                    raise ValueError("Cannot access non-contiguous data")
                if stop < start:
                    start, stop = stop, start
                slices[dim] = slice(start, stop, step)
            elif k == Ellipsis:
                pass
            else:
                raise TypeError("Texture indices must be integers")

        offset = tuple([s.start for s in slices])
        shape = tuple([s.stop - s.start for s in slices])
        data = None
        if self.data is not None:
            data = self.data[slices]

        T = self.__class__(dtype=self.dtype, shape=shape,
                           base=self, offset=offset, resizeable=False)
        T._data = data
        self._views.append(T)
        return T

    def __setitem__(self, key, data):
        """ x.__getitem__(y) <==> x[y] """

        if self.base is not None and not self._valid:
            raise ValueError("This texture view has been invalited")

        # Make sure key is a tuple
        if isinstance(key, (int, slice)) or key == Ellipsis:
            key = (key,)

        # Default is to access the whole texture
        shape = self.shape
        slices = [slice(0, shape[i]) for i in range(len(shape))]

        # Check last key/Ellipsis to decide on the order
        keys = key[::+1]
        dims = range(0, len(key))
        if key[0] == Ellipsis:
            keys = key[::-1]
            dims = range(len(self.shape) - 1,
                         len(self.shape) - 1 - len(keys), -1)

        # Find exact range for each key
        for k, dim in zip(keys, dims):
            size = self.shape[dim]
            if isinstance(k, int):
                if k < 0:
                    k += size
                if k < 0 or k > size:
                    raise IndexError("Texture assignment index out of range")
                start, stop = k, k + 1
                slices[dim] = slice(start, stop, 1)
            elif isinstance(k, slice):
                start, stop, step = k.indices(size)
                if step != 1:
                    raise ValueError("Cannot access non-contiguous data")
                if stop < start:
                    start, stop = stop, start
                slices[dim] = slice(start, stop, step)
            elif k == Ellipsis:
                pass
            else:
                raise TypeError("Texture indices must be integers")

        offset = tuple([s.start for s in slices])
        shape = tuple([s.stop - s.start for s in slices])
        size = 1
        for i in range(len(shape)):
            size *= shape[i]
        #size = reduce(mul, shape)

        # We have CPU storage
        if self.data is not None:
            self.data[key] = data
            data = self.data[key]
        else:
            # Make sure data is an array
            if not isinstance(data, np.ndarray):
                data = np.array(data, dtype=self.dtype, copy=False)
            # Make sure data is big enough
            if data.size != size:
                data = np.resize(data, size).reshape(shape)

        # Set data (deferred)
        if self.base is None:
            self.set_data(data=data, offset=offset, copy=False)
        else:
            offset = self.offset + offset
            self.base.set_data(data=data, offset=offset, copy=False)

    def _parameterize(self):
        """ Paramaterize texture """

        if self._need_parameterization:
            self._need_parameterization = False
            if isinstance(self._interpolation, tuple):
                min_filter = self._interpolation[0]
                mag_filter = self._interpolation[1]
            else:
                min_filter = self._interpolation
                mag_filter = self._interpolation
            gl.glTexParameterf(
                self._target, gl.GL_TEXTURE_MIN_FILTER, min_filter)
            gl.glTexParameterf(
                self._target, gl.GL_TEXTURE_MAG_FILTER, mag_filter)

            if isinstance(self._wrapping, tuple):
                wrap_s = self._wrapping[0]
                wrap_t = self._wrapping[1]
            else:
                wrap_s = self._wrapping
                wrap_t = self._wrapping
            gl.glTexParameterf(self._target, gl.GL_TEXTURE_WRAP_S, wrap_s)
            gl.glTexParameterf(self._target, gl.GL_TEXTURE_WRAP_T, wrap_t)

    def _create(self):
        """ Create texture on GPU """

        logger.debug("GPU: Creating texture")
        self._handle = gl.glCreateTexture()

    def _delete(self):
        """ Delete texture from GPU """

        logger.debug("GPU: Deleting texture")
        gl.glDeleteTexture(self._handle)

    def _activate(self):
        """ Activate texture on GPU """

        logger.debug("GPU: Activate texture")
        gl.glBindTexture(self.target, self._handle)
        if self._need_parameterization:
            self._parameterize()
        if self._need_resize:
            self._resize()
            self._need_resize = False

    def _deactivate(self):
        """ Deactivate texture on GPU """

        logger.debug("GPU: Deactivate texture")
        gl.glBindTexture(self._target, 0)
    
    # Taken from pygly
    def _get_alignment(self, width):
        """Determines a textures byte alignment.

        If the width isn't a power of 2
        we need to adjust the byte alignment of the image.
        The image height is unimportant

        www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads
        """

        # we know the alignment is appropriate
        # if we can divide the width by the
        # alignment cleanly
        # valid alignments are 1,2,4 and 8
        # put 4 first, since it's the default
        alignments = [4, 8, 2, 1]
        for alignment in alignments:
            if width % alignment == 0:
                return alignment


# --------------------------------------------------------- Texture1D class ---
class Texture1D(Texture):
    """ One dimensional texture
    
    Parameters
    ----------

    data : ndarray
        Texture data (optional)
    shape : tuple of integers
        Texture shape (optional)
    dtype : dtype
        Texture data type (optional)
    store : bool
        Specify whether this object stores a reference to the data,
        allowing the data to be updated regardless of striding. Note
        that modifying the data after passing it here might result in
        undesired behavior, unless a copy is given. Default True.
    format : ENUM
        The format of the texture: GL_LUMINANCE, ALPHA, GL_LUMINANCE_ALPHA, 
        or GL_RGB, GL_RGBA. If not given the format is chosen automatically 
        based on the number of channels. When the data has one channel,
        GL_LUMINANCE is assumed.
    
    Notes
    -----
    Under water this is really a 2D texture (1D textures are not
    supported in GL ES 2.0).
    
    """

    def __init__(self, data=None, shape=None, dtype=None, store=True, 
                 format=None, **kwargs):
        
        # We don't want these parameters to be seen from outside (because they
        # are only used internally)
        offset = kwargs.get("offset", None)
        base = kwargs.get("base", None)
        resizeable = kwargs.get("resizeable", True)
        
        Texture.__init__(self, data=data, shape=shape, dtype=dtype,
                         base=base, resizeable=resizeable, store=store,
                         target=gl.GL_TEXTURE_2D, offset=offset)

        # Get and check format
        if format is None:
            self._format = Texture._formats.get(self.shape[-1], None)
        else:
            self._format = format
        if self._format is None:
            raise ValueError("Cannot convert data to texture")

    def _normalize_shape(self, data_or_shape):
        # Get data and shape from input
        if isinstance(data_or_shape, np.ndarray):
            data = data_or_shape
            shape = data.shape
        else:
            assert isinstance(data_or_shape, tuple)
            data = None
            shape = data_or_shape
        # Check and correct
        if shape:
            if len(shape) < 1:
                raise ValueError("Too few dimensions for texture")
            elif len(shape) > 2:
                raise ValueError("Too many dimensions for texture")
            elif len(shape) == 1:
                shape = shape[0], 1
            elif len(shape) == 2:
                if shape[-1] > 4:
                    raise ValueError("Too many channels for texture")
        # Return
        if data is not None:
            return data.reshape(*shape)
        else:
            return shape
    
    @property
    def width(self):
        """ Texture width """

        return self._shape[0]

    def _resize(self):
        """ Texture resize on GPU """

        logger.debug("GPU: Resizing texture(%s)" % (self.width))
        # gl.glTexImage1D(self.target, 0, self._format, self._format, 
        #                 self._gtype, (self._width,))
        shape = self.height, self.width
        gl.glTexImage2D(self.target, 0, self._format, self._format, 
                        self._gtype, shape)

    def _update(self):
        """ Texture update on GPU """

        # We let base texture to handle all operations
        if self.base is not None:
            return

        logger.debug("GPU: Updating texture (%d pending operation(s))" %
                     len(self._pending_data))

        while self._pending_data:
            data, offset = self._pending_data.pop(0)
            if offset is None:
                x = 0
            else:
                x = offset[0]
            # gl.glTexSubImage1D(self.target, 0, x, self._format, 
            #                    self._gtype, data)
            gl.glTexSubImage2D(self.target, 0, x, self._format, 
                               self._gtype, data)


# --------------------------------------------------------- Texture2D class ---
class Texture2D(Texture):
    """ Two dimensional texture
    
    Parameters
    ----------

    data : ndarray
        Texture data (optional)
    shape : tuple of integers
        Texture shape (optional)
    dtype : dtype
        Texture data type (optional)
    store : bool
        Specify whether this object stores a reference to the data,
        allowing the data to be updated regardless of striding. Note
        that modifying the data after passing it here might result in
        undesired behavior, unless a copy is given. Default True.
    format : ENUM
        The format of the texture: GL_LUMINANCE, ALPHA, GL_LUMINANCE_ALPHA, 
        or GL_RGB, GL_RGBA. If not given the format is chosen automatically 
        based on the number of channels. When the data has one channel,
        GL_LUMINANCE is assumed.
    """

    def __init__(self, data=None, shape=None, dtype=None, store=True, 
                 format=None, **kwargs):

        # We don't want these parameters to be seen from outside (because they
        # are only used internally)
        offset = kwargs.get("offset", None)
        base = kwargs.get("base", None)
        resizeable = kwargs.get("resizeable", True)

        Texture.__init__(self, data=data, shape=shape, dtype=dtype, base=base,
                         resizeable=resizeable, store=store,
                         target=gl.GL_TEXTURE_2D, offset=offset)

        # Get and check format
        if format is None:
            self._format = Texture._formats.get(self.shape[-1], None)
        else:
            self._format = format
        if self._format is None:
            raise ValueError("Cannot convert data to texture")
    
    def _normalize_shape(self, data_or_shape):
        # Get data and shape from input
        if isinstance(data_or_shape, np.ndarray):
            data = data_or_shape
            shape = data.shape
        else:
            assert isinstance(data_or_shape, tuple)
            data = None
            shape = data_or_shape
        # Check and correct
        if shape:
            if len(shape) < 2:
                raise ValueError("Too few dimensions for texture")
            elif len(shape) > 3:
                raise ValueError("Too many dimensions for texture")
            elif len(shape) == 2:
                shape = shape[0], shape[1], 1
            elif len(shape) == 3:
                if shape[-1] > 4:
                    raise ValueError("Too many channels for texture")
        # Return
        if data is not None:
            return data.reshape(*shape)
        else:
            return shape

    @property
    def height(self):
        """ Texture height """

        return self._shape[0]

    @property
    def width(self):
        """ Texture width """

        return self._shape[1]

    def _resize(self):
        """ Texture resize on GPU """

        logger.debug("GPU: Resizing texture(%sx%s)" %
                     (self.width, self.height))
        shape = self.height, self.width
        gl.glTexImage2D(self.target, 0, self._format, self._format, 
                        self._gtype, shape)

    def _update(self):
        """ Texture update on GPU """

        # We let base texture to handle all operations
        if self.base is not None:
            return

        if self._need_resize:
            self._resize()
            self._need_resize = False
        logger.debug("GPU: Updating texture (%d pending operation(s))" %
                     len(self._pending_data))

        while self._pending_data:
            data, offset = self._pending_data.pop(0)
            x, y = 0, 0
            if offset is not None:
                y, x = offset[0], offset[1]
            # Set alignment (width is nbytes_per_pixel * npixels_per_line)
            alignment = self._get_alignment(data.shape[-2]*data.shape[-1])
            if alignment != 4:
                gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, alignment)
            #width, height = data.shape[1], data.shape[0]
            gl.glTexSubImage2D(self.target, 0, x, y, self._format, 
                               self._gtype, data)
            if alignment != 4:
                gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 4)

'''
# ---------------------------------------------------- TextureCubeMap class ---
class TextureCubeMap(Texture):
    """ A TextureCubeMap represents a set of 6 2D Textures
    
    Parameters
    ----------

    data : ndarray
        Texture data (optional)
    shape : tuple of integers
        Texture shape (optional)
    dtype : dtype
        Texture data type (optional)
    store : bool
        Specify whether this object stores a reference to the data,
        allowing the data to be updated regardless of striding. Note
        that modifying the data after passing it here might result in
        undesired behavior, unless a copy is given. Default True.
    format : ENUM
        The format of the texture: GL_LUMINANCE, ALPHA, GL_LUMINANCE_ALPHA, 
        or GL_RGB, GL_RGBA. If not given the format is chosen automatically 
        based on the number of channels. When the data has one channel,
        GL_LUMINANCE is assumed.
    """

    def __init__(self, data=None, shape=None, dtype=None, store=True,
                 format=None, **kwargs):
        
        # We don't want these parameters to be seen from outside (because they
        # are only used internally)
        offset = kwargs.get("offset", None)
        base = kwargs.get("base", None)
        resizeable = kwargs.get("resizeable", True)
        
        Texture.__init__(self, data=data, shape=shape, dtype=dtype, base=base,
                         store=store, target=gl.GL_TEXTURE_CUBE_MAP,
                         offset=offset, resizeable=resizeable)

        # Get and check format
        if format is None:
            self._format = Texture._formats.get(self.shape[-1], None)
        else:
            self._format = format
        if self._format is None:
            raise ValueError("Cannot convert data to texture")

        # Create sub-textures
        self._textures = []
        target = gl.GL_TEXTURE_CUBE_MAP_POSITIVE_X
        for i in range(6):
            if data is not None:
                T = Texture2D(data=data[i], base=base,
                              resizeable=False, store=store,
                              target=target + i, offset=offset)
            else:
                T = Texture2D(dtype=dtype, shape=shape[1:], base=base,
                              resizeable=False, store=store,
                              target=target + i, offset=offset)
            self._textures.append(T)
    
    def _normalize_shape(self, data_or_shape):
        # Get data and shape from input
        if isinstance(data_or_shape, np.ndarray):
            data = data_or_shape
            shape = data.shape
        else:
            assert isinstance(data_or_shape, tuple)
            data = None
            shape = data_or_shape
        # Check and correct
        if shape:
            if len(shape) < 3:
                raise ValueError("Too few dimensions for texture")
            elif len(shape) > 4:
                raise ValueError("Too many dimensions for texture")
            elif len(shape) == 3:
                if shape[0] != 6:
                    raise ValueError("First dim must be 6 for texture cube")
                shape = shape[0], shape[1], shape[2], 1
            elif len(shape) == 4:
                if shape[0] != 6:
                    raise ValueError("First dim must be 6 for texture cube")
                if shape[-1] > 4:
                    raise ValueError("Too many channels for texture")
        # Return
        if data is not None:
            return data.reshape(*shape)
        else:
            return shape
        
    def activate(self):
        """ Activate the object on GPU """

        Texture.activate(self)
        for texture in self._textures:
            texture.activate()

    def _create(self):
        """ Create texture on GPU """

        logger.debug("GPU: Creating texture")

    def _delete(self):
        """ Delete texture from GPU """

        logger.debug("GPU: Deleting texture")

    def _parameterize(self):
        """ Paramaterize texture """

        logger.debug("GPU: Parameterizing texture")

    def _activate(self):
        """ Activate texture on GPU """

        logger.debug("GPU: Activate texture")

    def _deactivate(self):
        """ Deactivate texture on GPU """

        logger.debug("GPU: Deactivate texture")

    def _resize(self):
        """ Texture resize on GPU """

        logger.debug("GPU: Resizing texture(%sx%s)" %
                     (self.width, self.height))

    def _update(self):
        """ Texture upload on GPU """

        logger.debug("GPU: Updating texture (%d pending operation(s))" %
                     len(self._pending_data))


# if __name__ == '__main__':
#    data = np.zeros((6,128,128), dtype=np.uint32)
#    T = TextureCubeMap(data=data)
#    T.activate()
'''

########NEW FILE########
__FILENAME__ = util
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------

from .wrappers import read_pixels


def _screenshot(viewport=None):
    """ Take a screenshot using glReadPixels. Not sure where to put this
    yet, so a private function for now. Used in make.py.
    """
    # gl.glReadBuffer(gl.GL_BACK)  Not avaliable in ES 2.0
    return read_pixels(viewport)


KEYWORDS = set(['active', 'asm', 'cast', 'class', 'common', 'default',
                'double', 'dvec2', 'dvec3', 'dvec4', 'enum', 'extern',
                'external', 'filter', 'fixed', 'flat', 'fvec2', 'fvec3',
                'fvec4', 'goto', 'half', 'hvec2', 'hvec3', 'hvec4', 'iimage1D',
                'iimage1DArray', 'iimage2D', 'iimage2DArray', 'iimage3D',
                'iimageBuffer', 'iimageCube', 'image1D', 'image1DArray',
                'image1DArrayShadow', 'image1DShadow', 'image2D',
                'image2DArray', 'image2DArrayShadow', 'image2DShadow',
                'image3D', 'imageBuffer', 'imageCube', 'inline', 'input',
                'interface', 'long', 'namespace', 'noinline', 'output',
                'packed', 'partition', 'public', 'row_major', 'sampler1D',
                'sampler1DShadow', 'sampler2DRect', 'sampler2DRectShadow',
                'sampler2DShadow', 'sampler3D', 'sampler3DRect', 'short',
                'sizeof', 'static', 'superp', 'switch', 'template', 'this',
                'typedef', 'uimage1D', 'uimage1DArray', 'uimage2D',
                'uimage2DArray', 'uimage3D', 'uimageBuffer', 'uimageCube',
                'union', 'unsigned', 'using', 'volatile'])


def check_variable(name):
    """
    Return None if *name* is expected to be a valid variable name in any GLSL
    version. Otherwise, return a string describing the problem.
    """
    # Limit imposed by glGetActive* in pyopengl
    if len(name) > 31:
        return ("Variable names >31 characters may not function on some "
                "systems.")
    
    return check_identifier(name)


def check_identifier(name):
    if '__' in name:
        return "Identifiers may not contain double-underscores."
    
    if name[:3] == 'gl_' or name[:3] == 'GL_':
        return "Identifiers may not begin with gl_ or GL_."
    
    if name in KEYWORDS:
        return "Identifier is a reserved keyword."

########NEW FILE########
__FILENAME__ = variable
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
import numpy as np

from . import gl
from .globject import GLObject
from .buffer import VertexBuffer
from .texture import Texture2D
from .framebuffer import RenderBuffer
from ..util import logger
from .util import check_variable


# ------------------------------------------------------------- gl_typeinfo ---
gl_typeinfo = {
    gl.GL_FLOAT: (1, gl.GL_FLOAT,        np.float32),
    gl.GL_FLOAT_VEC2: (2, gl.GL_FLOAT,        np.float32),
    gl.GL_FLOAT_VEC3: (3, gl.GL_FLOAT,        np.float32),
    gl.GL_FLOAT_VEC4: (4, gl.GL_FLOAT,        np.float32),
    gl.GL_INT: (1, gl.GL_INT,          np.int32),
    gl.GL_INT_VEC2: (2, gl.GL_INT,          np.int32),
    gl.GL_INT_VEC3: (3, gl.GL_INT,          np.int32),
    gl.GL_INT_VEC4: (4, gl.GL_INT,          np.int32),
    gl.GL_BOOL: (1, gl.GL_BOOL,         np.bool),
    gl.GL_BOOL_VEC2: (2, gl.GL_BOOL,         np.bool),
    gl.GL_BOOL_VEC3: (3, gl.GL_BOOL,         np.bool),
    gl.GL_BOOL_VEC4: (4, gl.GL_BOOL,         np.bool),
    gl.GL_FLOAT_MAT2: (4, gl.GL_FLOAT,        np.float32),
    gl.GL_FLOAT_MAT3: (9, gl.GL_FLOAT,        np.float32),
    gl.GL_FLOAT_MAT4: (16, gl.GL_FLOAT,        np.float32),
    #    gl.GL_SAMPLER_1D   : ( 1, gl.GL_UNSIGNED_INT, np.uint32),
    gl.GL_SAMPLER_2D: (1, gl.GL_UNSIGNED_INT, np.uint32)
}


# ---------------------------------------------------------- Variable class ---
class Variable(GLObject):
    """ A variable is an interface between a program and some data 
    
    For internal use
    
    Parameters
    ----------
    
    program : Program
        The Program instance to which the data applies
    name : str
        The variable name
    gtype : ENUM
        The type of the variable: GL_FLOAT, GL_FLOAT_VEC2, GL_FLOAT_VEC3,
        GL_FLOAT_VEC4, GL_INT, GL_BOOL, GL_FLOAT_MAT2, GL_FLOAT_MAT3,
        GL_FLOAT_MAT4, or gl.GL_SAMPLER_2D
    
    """

    def __init__(self, program, name, gtype):
        """ Initialize the data into default state """

        # Make sure variable type is allowed (for ES 2.0 shader)
        if gtype not in [gl.GL_FLOAT,
                         gl.GL_FLOAT_VEC2,
                         gl.GL_FLOAT_VEC3,
                         gl.GL_FLOAT_VEC4,
                         gl.GL_INT,
                         gl.GL_BOOL,
                         gl.GL_FLOAT_MAT2,
                         gl.GL_FLOAT_MAT3,
                         gl.GL_FLOAT_MAT4,
                         #                         gl.GL_SAMPLER_1D,
                         gl.GL_SAMPLER_2D]:
            raise TypeError("Unknown variable type")

        GLObject.__init__(self)

        # Program this variable belongs to
        self._program = program

        # Name of this variable in the program
        self._name = name
        check = check_variable(name) 
        if check:
            logger.warn('Invalid variable name "%s". (%s)' 
                        % (name, check))

        # Build dtype
        size, _, base = gl_typeinfo[gtype]
        self._dtype = (name, base, size)

        # GL type
        self._gtype = gtype

        # CPU data
        self._data = None

        # Whether this variable is active
        self._active = True

    @property
    def name(self):
        """ Variable name """

        return self._name

    @property
    def program(self):
        """ Program this variable belongs to """

        return self._program

    @property
    def gtype(self):
        """ Type of the underlying variable (as a GL constant) """

        return self._gtype

    @property
    def dtype(self):
        """ Equivalent dtype of the variable """

        return self._dtype

    @property
    def active(self):
        """ Whether this variable is active in the program """
        return self._active

    @active.setter
    def active(self, active):
        """ Whether this variable is active in the program """
        self._active = bool(active)

    @property
    def data(self):
        """ CPU data """

        return self._data


# ----------------------------------------------------------- Uniform class ---
class Uniform(Variable):
    """ A Uniform represents a program uniform variable. 
    
    See Variable.
    """

    # todo: store function names instead of GL proxy function (faster)
    _ufunctions = {
        gl.GL_FLOAT:        gl.proxy.glUniform1fv,
        gl.GL_FLOAT_VEC2:   gl.proxy.glUniform2fv,
        gl.GL_FLOAT_VEC3:   gl.proxy.glUniform3fv,
        gl.GL_FLOAT_VEC4:   gl.proxy.glUniform4fv,
        gl.GL_INT:          gl.proxy.glUniform1iv,
        gl.GL_BOOL:         gl.proxy.glUniform1iv,
        gl.GL_FLOAT_MAT2:   gl.proxy.glUniformMatrix2fv,
        gl.GL_FLOAT_MAT3:   gl.proxy.glUniformMatrix3fv,
        gl.GL_FLOAT_MAT4:   gl.proxy.glUniformMatrix4fv,
        #        gl.GL_SAMPLER_1D:   gl.proxy.glUniform1i,
        gl.GL_SAMPLER_2D:   gl.proxy.glUniform1i,
    }

    def __init__(self, program, name, gtype):
        """ Initialize the input into default state """

        Variable.__init__(self, program, name, gtype)
        size, _, dtype = gl_typeinfo[self._gtype]
        self._data = np.zeros(size, dtype)
        self._ufunction = Uniform._ufunctions[self._gtype]
        self._unit = -1

    def set_data(self, data):
        """ Set data (no upload) """

        # Textures need special handling
        # if self._gtype == gl.GL_SAMPLER_1D:
        #     if isinstance(self._data, Texture1D):
        #         self._data.set_data(data)

        # Automatic texture creation if required
        #     elif not isinstance(data,Texture1D):
        #         data = np.array(data,copy=False)
        #         if data.dtype in [np.float16, np.float32, np.float64]:
        #             self._data = Texture1D(data=data.astype(np.float32))
        #         else:
        #             self._data = Texture1D(data=data.astype(np.uint8))
        #     else:
        #         self._data = data
        if self._gtype == gl.GL_SAMPLER_2D:
            if isinstance(data, Texture2D):
                self._data = data
            elif isinstance(self._data, Texture2D):
                self._data.set_data(data)
            elif isinstance(data, RenderBuffer):
                self._data = data
            else:
                # Automatic texture creation if required
                data = np.array(data, copy=False)
                if data.dtype in [np.float16, np.float32, np.float64]:
                    self._data = Texture2D(data=data.astype(np.float32))
                else:
                    self._data = Texture2D(data=data.astype(np.uint8))
        else:
            self._data[...] = np.array(data, copy=False).ravel()

        self._need_update = True

    def _activate(self):
        # if self._gtype in (gl.GL_SAMPLER_1D, gl.GL_SAMPLER_2D):
        if self._gtype in (gl.GL_SAMPLER_2D,):
            logger.debug("GPU: Active texture is %d" % self._unit)
            gl.glActiveTexture(gl.GL_TEXTURE0 + self._unit)
            if self.data is not None:
                self.data.activate()

    def _deactivate(self):
        if self._gtype in (gl.GL_SAMPLER_2D,):
            #gl.glActiveTexture(gl.GL_TEXTURE0 + self._unit)
            if self.data is not None:
                self.data.deactivate()

    def _update(self):

        # Check active status (mandatory)
        if not self._active:
            raise RuntimeError("Uniform variable is not active")
        if self._data is None:
            raise RuntimeError("Uniform variable data is not set")
        
        # WARNING : Uniform are supposed to keep their value between program
        #           activation/deactivation (from the GL documentation). It has
        #           been tested on some machines but if it is not the case on
        #           every machine, we can expect nasty bugs from this early
        #           return

        # Matrices (need a transpose argument)
        if self._gtype in (gl.GL_FLOAT_MAT2,
                           gl.GL_FLOAT_MAT3, gl.GL_FLOAT_MAT4):
            # OpenGL ES 2.0 does not support transpose
            transpose = False
            self._ufunction(self._handle, 1, transpose, self._data)

        # Textures (need to get texture count)
        # elif self._gtype in (gl.GL_SAMPLER_1D, gl.GL_SAMPLER_2D):
        elif self._gtype in (gl.GL_SAMPLER_2D,):
            # texture = self.data
            # log("GPU: Active texture is %d" % self._unit)
            # gl.glActiveTexture(gl.GL_TEXTURE0 + self._unit)
            # gl.glBindTexture(texture.target, texture.handle)
            gl.glUniform1i(self._handle, self._unit)

        # Regular uniform
        else:
            self._ufunction(self._handle, 1, self._data)

    def _create(self):
        """ Create uniform on GPU (get handle) """

        self._handle = gl.glGetUniformLocation(
            self._program.handle, self._name)


# --------------------------------------------------------- Attribute class ---
class Attribute(Variable):
    """ An Attribute represents a program attribute variable 
    
    See Variable.
    """

    _afunctions = {
        gl.GL_FLOAT:      gl.proxy.glVertexAttrib1f,
        gl.GL_FLOAT_VEC2: gl.proxy.glVertexAttrib2f,
        gl.GL_FLOAT_VEC3: gl.proxy.glVertexAttrib3f,
        gl.GL_FLOAT_VEC4: gl.proxy.glVertexAttrib4f
    }

    def __init__(self, program, name, gtype):
        """ Initialize the input into default state """

        Variable.__init__(self, program, name, gtype)

        # Number of elements this attribute links to (in the attached buffer)
        self._size = 0

        # Whether this attribure is generic
        self._generic = False

    def set_data(self, data):
        """ Set data (deferred operation) """
        
        isnumeric = isinstance(data, (float, int))
        
        if isinstance(data, VertexBuffer):
            # New vertex buffer
            self._data = data
        elif isinstance(self._data, VertexBuffer):
            # We already have a vertex buffer
            self._data[...] = data
        elif (isnumeric or (isinstance(data, (tuple, list)) and
                            len(data) in (1, 2, 3, 4) and
                            isinstance(data[0], (float, int)))):
            # Data is a tuple with size <= 4, we assume this designates
            # a generate vertex attribute.
            # Let numpy convert the data for us
            _, _, dtype = gl_typeinfo[self._gtype]
            self._data = np.array(data).astype(dtype)
            self._generic = True
            self._need_update = True
            self._afunction = Attribute._afunctions[self._gtype]
            return
        else:
            # For array-like, we need to build a proper VertexBuffer
            # to be able to upload it later to GPU memory.
            name, base, count = self.dtype
            data = np.array(data, dtype=base, copy=False)
            data = data.ravel().view([self.dtype])
            # WARNING : transform data with the right type
            # data = np.array(data,copy=False)
            self._data = VertexBuffer(data)
        
        self._generic = False

    def _activate(self):
        if isinstance(self.data, VertexBuffer):
            self.data.activate()
    
    def _deactivate(self):
        if isinstance(self.data, VertexBuffer):
            self.data.deactivate()
    
    def _update(self):
        """ Actual upload of data to GPU memory  """

        logger.debug("GPU: Updating %s" % self.name)
        
        # Check active status (mandatory)
        if not self._active:
            raise RuntimeError("Attribute variable is not active")
        if self._data is None:
            raise RuntimeError("Attribute variable data is not set")
        
        # Generic vertex attribute (all vertices receive the same value)
        if self._generic:
            if self._handle >= 0:
                gl.glDisableVertexAttribArray(self._handle)
                self._afunction(self._handle, *self._data)

        # Direct upload
        # elif isinstance(self._data, ClientVertexBuffer):
            # Tell OpenGL to use the array and not the glVertexAttrib* value
            # gl.glEnableVertexAttribArray(self._loc)
            # Disable any VBO
            # gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
            # Early exit (pointer to CPU-data is still known by Program)
            # if not self._dirty:
            #    return
            # Get numpy array from its container
            #data = self._data.data

            # Check attribute format against data format
            #size, gtype, _ = gl_typeinfo[self._gtype]
            # if self._gtype != self._data._gtype:
            #    raise ValueError("Data not compatible with attribute type")
            #offset = 0
            #stride = self._data.stride
            # Apply (first disable any previous VertexBuffer)
            #gl.glVertexAttribPointer(self._loc, size, gtype,False,stride,data)

        # Regular vertex buffer
        elif self._handle >= 0:
            #if self._need_update:
            #    self.data._update()
            #    self._need_update = False

            # Get relevant information from gl_typeinfo
            size, gtype, dtype = gl_typeinfo[self._gtype]
            stride = self.data.stride

            # Make offset a pointer, or it will be interpreted as a small array
            # Not needed with our new GL API
            offset = self.data.offset  # ctypes.c_void_p(self.data.offset)

            gl.glEnableVertexAttribArray(self.handle)
            #gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.data.handle)
            gl.glVertexAttribPointer(
                self.handle, size, gtype, gl.GL_FALSE, stride, offset)

    def _create(self):
        """ Create attribute on GPU (get handle) """

        self._handle = gl.glGetAttribLocation(self._program.handle, self.name)

    @property
    def size(self):
        """ Size of the underlying vertex buffer """

        if self._data is None:
            return 0
        return self._data.size

########NEW FILE########
__FILENAME__ = wrappers
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------

import numpy as np
from copy import deepcopy

from . import gl
from ..ext.six import string_types


__all__ = ('set_viewport', 'set_depth_range', 'set_front_face',
           'set_cull_face', 'set_line_width', 'set_polygon_offset',
           'clear', 'set_clear_color', 'set_clear_depth', 'set_clear_stencil',
           'set_blend_func', 'set_blend_color', 'set_blend_equation',
           'set_scissor', 'set_stencil_func', 'set_stencil_mask',
           'set_stencil_op', 'set_depth_func', 'set_depth_mask',
           'set_color_mask', 'set_sample_coverage',
           'get_state_presets', 'set_state', 'finish', 'flush',
           'get_parameter', 'read_pixels', 'set_hint',
           'get_gl_configuration', 'check_error')
_setters = [s[4:] for s in __all__
            if s.startswith('set_') and s != 'set_state']


# Helpers that are needed for efficient wrapping

def _check_valid(key, val, valid):
    """Helper to check valid options"""
    if val not in valid:
        raise ValueError('%s must be one of %s, not "%s"'
                         % (key, valid, val))


def _gl_attr(x):
    """Helper to return gl.GL_x enum"""
    y = 'GL_' + x.upper()
    z = getattr(gl, y, None)
    if z is None:
        raise ValueError('gl has no attribute corresponding to name %s (%s)'
                         % (x, y))
    return z


def _gl_bool(x):
    """Helper to convert to GL boolean"""
    return gl.GL_TRUE if x else gl.GL_FALSE


def _to_args(x):
    """Convert to args representation"""
    if not isinstance(x, (list, tuple, np.ndarray)):
        x = [x]
    return x


def _check_color(color):
    """Check and validate color"""
    # XXX this should eventually go in vispy.colors
    color = np.array(color, float)
    if color.ndim != 1 or color.size not in (3, 4):
        raise ValueError('color must be a 3- or 4-element array-like')
    if len(color) == 3:
        color = np.concatenate((color, [1.]))
    return color


###############################################################################
# PRIMITIVE/VERTEX

#
# Viewport, DepthRangef, CullFace, FrontFace, LineWidth, PolygonOffset
#

def set_viewport(x, y, w, h):
    """Set the OpenGL viewport

    This is a wrapper for gl.glViewport.

    Parameters
    ----------
    x : int
        X coordinate.
    y : int
        Y coordinate.
    w : int
        Viewport width.
    h : int
        Viewport height.
    """
    gl.glViewport(int(x), int(y), int(w), int(h))


def set_depth_range(near=0., far=1.):
    """Set depth values

    Parameters
    ----------
    near : float
        Near clipping plane.
    far : float
        Far clipping plane.
    """
    gl.glDepthRange(float(near), float(far))


def set_front_face(mode='ccw'):
    """Set which faces are front-facing

    Parameters
    ----------
    mode : str
        Can be 'cw' for clockwise or 'ccw' for counter-clockwise.
    """
    gl.glFrontFace(_gl_attr(mode))


def set_cull_face(mode='back'):
    """Set front, back, or both faces to be culled

    Parameters
    ----------
    mode : str
        Culling mode. Can be "front", "back", or "front_and_back".
    """
    gl.glCullFace(_gl_attr(mode))


def set_line_width(width=1.):
    """Set line width

    Parameters
    ----------
    width : float
        The line width.
    """
    gl.glLineWidth(float(width))


def set_polygon_offset(factor=0., units=0.):
    """Set the scale and units used to calculate depth values

    Parameters
    ----------
    factor : float
        Scale factor used to create a variable depth offset for each polygon.
    units : float
        Multiplied by an implementation-specific value to create a constant
        depth offset.
    """
    gl.glPolygonOffset(float(factor), float(units))


###############################################################################
# FRAGMENT/SCREEN

#
# glClear, glClearColor, glClearDepthf, glClearStencil
#

def clear(color=True, depth=True, stencil=True):
    """Clear the screen buffers

    This is a wrapper for gl.glClear.

    Parameters
    ----------
    color : bool | tuple
        Clear the color buffer bit. If tuple, ``set_clear_color`` will
        be used to set the color clear value.
    depth : bool | float
        Clear the depth buffer bit. If float, ``set_clear_depth`` will
        be used to set the depth clear value.
    stencil : bool | int
        Clear the stencil buffer bit. If int, ``set_clear_stencil`` will
        be used to set the stencil clear index.
    """
    bits = 0
    if color:
        if not isinstance(color, bool):
            set_clear_color(color)
        bits |= gl.GL_COLOR_BUFFER_BIT
    if depth:
        if not isinstance(depth, bool):
            set_clear_depth(depth)
        bits |= gl.GL_DEPTH_BUFFER_BIT
    if stencil:
        if not isinstance(stencil, bool):
            set_clear_stencil(stencil)
        bits |= gl.GL_STENCIL_BUFFER_BIT
    gl.glClear(bits)


def set_clear_color(color=(0., 0., 0., 1.)):
    """Set the screen clear color

    This is a wrapper for gl.glClearColor.

    Parameters
    ----------
    color : 4-element tuple
        Color to use. Defaults to black.
    """
    gl.glClearColor(*_check_color(color))


def set_clear_depth(depth=1.0):
    """Set the clear value for the depth buffer

    This is a wrapper for gl.glClearDepth.

    Parameters
    ----------
    depth : float
        The depth to use.
    """
    gl.glClearDepth(float(depth))


def set_clear_stencil(index=0):
    """Set the clear value for the stencil buffer

    This is a wrapper for gl.glClearStencil.

    Parameters
    ----------
    index : int
        The index to use when the stencil buffer is cleared.
    """
    gl.glClearStencil(int(index))


# glBlendFunc(Separate), glBlendColor, glBlendEquation(Separate)

def set_blend_func(srgb='one', drgb='zero',
                   salpha=None, dalpha=None):
    """Specify pixel arithmetic for RGB and alpha

    Parameters
    ----------
    srgb : str
        Source RGB factor.
    drgb : str
        Destination RGB factor.
    salpha : str | None
        Source alpha factor. If None, ``srgb`` is used.
    dalpha : str
        Destination alpha factor. If None, ``drgb`` is used.
    """
    salpha = srgb if salpha is None else salpha
    dalpha = drgb if dalpha is None else dalpha
    gl.glBlendFuncSeparate(_gl_attr(srgb), _gl_attr(drgb),
                           _gl_attr(salpha), _gl_attr(dalpha))


def set_blend_color(color):
    """Set the blend color

    Parameters
    ----------
    color : array-like
        3- or 4-element array-like specifying float RGB(A) values.
    """
    gl.glBlendColor(*_check_color(color))


def set_blend_equation(mode_rgb, mode_alpha=None):
    """Specify the equation for RGB and alpha blending

    Parameters
    ----------
    mode_rgb : str
        Mode for RGB.
    mode_alpha : str | None
        Mode for Alpha. If None, ``mode_rgb`` is used.

    Notes
    -----
    See ``set_blend_equation`` for valid modes.
    """
    mode_alpha = mode_rgb if mode_alpha is None else mode_alpha
    gl.glBlendEquationSeparate(_gl_attr(mode_rgb),
                               _gl_attr(mode_alpha))


# glScissor, glStencilFunc(Separate), glStencilMask(Separate),
# glStencilOp(Separate),

def set_scissor(x, y, w, h):
    """Define the scissor box

    Parameters
    ----------
    x : int
        Left corner of the box.
    y : int
        Lower corner of the box.
    w : int
        The width of the box.
    h : int
        The height of the box.
    """
    gl.glScissor(int(x), int(y), int(w), int(h))


def set_stencil_func(func='always', ref=0, mask=8, face='front_and_back'):
    """Set front or back function and reference value

    Parameters
    ----------
    func : str
        See set_stencil_func.
    ref : int
        Reference value for the stencil test.
    mask : int
        Mask that is ANDed with ref and stored stencil value.
    face : str
        Can be 'front', 'back', or 'front_and_back'.
    """
    gl.glStencilFuncSeparate(_gl_attr(face), _gl_attr(func),
                             int(ref), int(mask))


def set_stencil_mask(mask=8, face='front_and_back'):
    """Control the front or back writing of individual bits in the stencil

    Parameters
    ----------
    mask : int
        Mask that is ANDed with ref and stored stencil value.
    face : str
        Can be 'front', 'back', or 'front_and_back'.
    """
    gl.glStencilMaskSeparate(_gl_attr(face), int(mask))


def set_stencil_op(sfail='keep', dpfail='keep', dppass='keep',
                   face='front_and_back'):
    """Set front or back stencil test actions

    Parameters
    ----------
    sfail : str
        Action to take when the stencil fails. Must be one of
        'keep', 'zero', 'replace', 'incr', 'incr_wrap',
        'decr', 'decr_wrap', or 'invert'.
    dpfail : str
        Action to take when the stencil passes.
    dppass : str
        Action to take when both the stencil and depth tests pass,
        or when the stencil test passes and either there is no depth
        buffer or depth testing is not enabled.
    face : str
        Can be 'front', 'back', or 'front_and_back'.
    """
    gl.glStencilOpSeparate(_gl_attr(face), _gl_attr(sfail),
                           _gl_attr(dpfail), _gl_attr(dppass))


# glDepthFunc, glDepthMask, glColorMask, glSampleCoverage

def set_depth_func(func='less'):
    """Specify the value used for depth buffer comparisons

    Parameters
    ----------
    func : str
        The depth comparison function. Must be one of 'never', 'less', 'equal',
        'lequal', 'greater', 'gequal', 'notequal', or 'always'.
    """
    gl.glDepthFunc(_gl_attr(func))


def set_depth_mask(flag):
    """Toggle writing into the depth buffer

    Parameters
    ----------
    flag : bool
        Whether depth writing should be enabled.
    """
    gl.glDepthMask(_gl_bool(flag))


def set_color_mask(red, green, blue, alpha):
    """Toggle writing of frame buffer color components

    Parameters
    ----------
    red : bool
        Red toggle.
    green : bool
        Green toggle.
    blue : bool
        Blue toggle.
    alpha : bool
        Alpha toggle.
    """
    gl.glColorMask(_gl_bool(red), _gl_bool(green), _gl_bool(blue),
                   _gl_bool(alpha))


def set_sample_coverage(value=1.0, invert=False):
    """Specify multisample coverage parameters

    Parameters
    ----------
    value : float
        Sample coverage value (will be clamped between 0. and 1.).
    invert : bool
        Specify if the coverage masks should be inverted.
    """
    gl.glSampleCoverage(float(value), _gl_bool(invert))


###############################################################################
# STATE

#
# glEnable/Disable
#

# NOTE: If these are updated to have things beyond glEnable/glBlendFunc
# calls, set_preset_state will need to be updated to deal with it.
_gl_presets = dict(
    opaque=dict(depth_test=True, cull_face=False, blend=False),
    translucent=dict(depth_test=True, cull_face=False, blend=True,
                     blend_func=('src_alpha', 'one_minus_src_alpha')),
    additive=dict(depth_test=False, cull_face=False, blend=True,
                  blend_func=('src_alpha', 'one'),)
)


def get_state_presets():
    """The available GL state presets

    Returns
    -------
    presets : dict
        The dictionary of presets usable with ``set_options``.
    """
    return deepcopy(_gl_presets)


_known_state_names = ('depth_test', 'blend', 'blend_func')


def set_state(preset=None, **kwargs):
    """Set OpenGL rendering state, optionally using a preset

    Parameters
    ----------
    preset : str | None
        Can be one of ('opaque', 'translucent', 'additive') to use
        use reasonable defaults for these typical use cases.
    **kwargs : keyword arguments
        Other supplied keyword arguments will override any preset defaults.
        Options to be enabled or disabled should be supplied as booleans
        (e.g., ``'depth_test=True'``, ``cull_face=False``), non-boolean
        entries will be passed as arguments to ``set_*`` functions (e.g.,
        ``blend_func=('src_alpha', 'one')`` will call ``set_blend_func``).

    Notes
    -----
    This serves three purposes:

      1. Set GL state using reasonable presets.
      2. Wrapping glEnable/glDisable functionality.
      3. Convienence wrapping of other ``gloo.set_*`` functions.

    For example, one could do the following:

        >>> from vispy import gloo
        >>> gloo.set_state('translucent', depth_test=False, clear_color=(1, 1, 1, 1))  # noqa, doctest:+SKIP

    This would take the preset defaults for 'translucent', turn depth testing
    off (which would normally be on for that preset), and additionally
    set the glClearColor parameter to be white.

    Another example to showcase glEnable/glDisable wrapping:

        >>> gloo.set_state(blend=True, depth_test=True, polygon_offset_fill=False)  # noqa, doctest:+SKIP

    This would be equivalent to calling 

        >>> from vispy.gloo import gl
        >>> gl.glDisable(gl.GL_BLEND)
        >>> gl.glEnable(gl.GL_DEPTH_TEST)
        >>> gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)

    Or here's another example:

        >>> gloo.set_state(clear_color=(0, 0, 0, 1), blend=True, blend_func=('src_alpha', 'one'))  # noqa, doctest:+SKIP

    Thus arbitrary GL state components can be set directly using ``set_state``.
    Note that individual functions are exposed e.g., as ``set_clear_color``,
    with some more informative docstrings about those particular functions.
    """
    kwargs = deepcopy(kwargs)
    # Load preset, if supplied
    if preset is not None:
        _check_valid('preset', preset, tuple(list(_gl_presets.keys())))
        for key, val in _gl_presets[preset].items():
            # only overwrite user's input with preset if user's input is None
            if key not in kwargs:
                kwargs[key] = val

    # cull_face is an exception because GL_CULL_FACE and glCullFace both exist
    if 'cull_face' in kwargs:
        cull_face = kwargs.pop('cull_face')
        if isinstance(cull_face, bool):
            func = gl.glEnable if val else gl.glDisable
            func(_gl_attr('cull_face'))
        else:
            set_cull_face(*_to_args(cull_face))

    # Now deal with other non-glEnable/glDisable args
    for s in _setters:
        if s in kwargs:
            args = _to_args(kwargs.pop(s))
            # these actually need tuples
            if s in ('blend_color', 'clear_color'):
                args = [args]
            globals()['set_' + s](*args)

    # check values and translate
    for key, val in kwargs.items():
        func = gl.glEnable if val else gl.glDisable
        func(_gl_attr(key))


#
# glFinish, glFlush, glGetParameter, glReadPixels, glHint
#

def finish():
    """Wait for GL commands to to finish

    This is a wrapper for glFinish().
    """
    gl.glFinish()


def flush():
    """Flush GL commands

    This is a wrapper for glFlush().
    """
    gl.glFlush()


def get_parameter(name):
    """Get OpenGL parameter value

    Parameters
    ----------
    name : str
        The name of the parameter to get.
    """
    if not isinstance(name, string_types):
        raise TypeError('name bust be a string')
    return gl.glGetParameter(_gl_attr(name))


def read_pixels(viewport=None):
    """Read pixels from the front buffer

    Parameters
    ----------
    viewport : array-like | None
        4-element list of x, y, w, h parameters. If None (default),
        the current GL viewport will be queried and used.

    Returns
    -------
    pixels : array
        2D array of pixels in np.uint8 format.
    """
    if viewport is None:
        viewport = get_parameter('viewport')
    else:
        viewport = np.array(viewport, int)
        if viewport.ndim != 1 or viewport.size != 4:
            raise ValueError('viewport must be 1D 4-element array-like')
    x, y, w, h = viewport
    gl.glPixelStorei(gl.GL_PACK_ALIGNMENT, 1)  # PACK, not UNPACK
    im = gl.glReadPixels(x, y, w, h, gl.GL_RGB, gl.GL_UNSIGNED_BYTE)
    gl.glPixelStorei(gl.GL_PACK_ALIGNMENT, 4)
    # reshape, flip, and return
    if not isinstance(im, np.ndarray):
        im = np.frombuffer(im, np.uint8)
    im.shape = h, w, 3
    return im


def set_hint(target, mode):
    """Set OpenGL drawing hint

    Parameters
    ----------
    target : str
        The target (e.g., 'fog_hint', 'line_smooth_hint', 'point_smooth_hint').
    mode : str
        The mode to set (e.g., 'fastest', 'nicest', 'dont_care').
    """
    if not all(isinstance(tm, string_types) for tm in (target, mode)):
        raise TypeError('target and mode must both be strings')
    gl.glHint(_gl_attr(target), _gl_attr(mode))


###############################################################################
# Current OpenGL configuration

def get_gl_configuration():
    """Read the current gl configuration

    This function uses constants that are not in the OpenGL ES 2.1
    namespace, so only use this on desktop systems.

    Returns
    -------
    config : dict
        The currently active OpenGL configuration.
    """
    # XXX eventually maybe we can ask `gl` whether or not we can access these
    gl.check_error('pre-config check')
    config = dict()
    gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, 0)
    fb_param = gl.glGetFramebufferAttachmentParameter
    # copied since they aren't in ES:
    GL_FRONT_LEFT = 1024
    GL_DEPTH = 6145
    GL_STENCIL = 6146
    GL_SRGB = 35904
    GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296
    GL_STEREO = 3123
    GL_DOUBLEBUFFER = 3122
    sizes = dict(red=(GL_FRONT_LEFT, 33298),
                 green=(GL_FRONT_LEFT, 33299),
                 blue=(GL_FRONT_LEFT, 33300),
                 alpha=(GL_FRONT_LEFT, 33301),
                 depth=(GL_DEPTH, 33302),
                 stencil=(GL_STENCIL, 33303))
    for key, val in sizes.items():
        config[key + '_size'] = fb_param(gl.GL_FRAMEBUFFER, val[0], val[1])
    val = fb_param(gl.GL_FRAMEBUFFER, GL_FRONT_LEFT,
                   GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING)
    if val not in (gl.GL_LINEAR, GL_SRGB):
        raise RuntimeError('unknown value for SRGB: %s' % val)
    config['srgb'] = True if val == GL_SRGB else False  # GL_LINEAR
    config['stereo'] = True if gl.glGetParameter(GL_STEREO) else False
    config['double_buffer'] = (True if gl.glGetParameter(GL_DOUBLEBUFFER)
                               else False)
    config['samples'] = gl.glGetParameter(gl.GL_SAMPLES)
    gl.check_error('post-config check')
    return config


def check_error():
    """Check for OpenGL errors

    For efficiency, errors are only checked periodically. This forces
    a check for OpenGL errors.
    """
    gl.check_error('gloo check')

########NEW FILE########
__FILENAME__ = test_testing
from nose.tools import assert_raises
from vispy.testing import assert_in, assert_not_in, assert_is


def test_testing():
    """Test testing ports"""
    assert_raises(AssertionError, assert_in, 'foo', 'bar')
    assert_in('foo', 'foobar')
    assert_raises(AssertionError, assert_not_in, 'foo', 'foobar')
    assert_not_in('foo', 'bar')
    assert_raises(AssertionError, assert_is, None, 0)
    assert_is(None, None)

########NEW FILE########
__FILENAME__ = _runners
"""Test running functions"""

from __future__ import print_function

import sys
import os
from os import path as op
from subprocess import Popen
from copy import deepcopy
from functools import partial

from ..util.ptime import time
from ._testing import SkipTest, has_backend


def _get_root_dir():
    root_dir = os.getcwd()
    if (op.isfile(op.join(root_dir, 'setup.py')) and
            op.isdir(op.join(root_dir, 'vispy'))):
        dev = True
    else:
        root_dir = op.abspath(op.join(op.dirname(__file__), '..', '..'))
        dev = True if op.isfile(op.join(root_dir, 'setup.py')) else False
    return root_dir, dev


def _nose(mode, verbosity, coverage):
    """Run nosetests using a particular mode"""
    cwd = os.getcwd()  # this must be done before nose import
    try:
        import nose  # noqa, analysis:ignore
    except ImportError:
        print('Skipping nosetests, nose not installed')
        raise SkipTest()
    extra = ('-' * 70)
    if mode == 'nobackend':
        print(extra + '\nRunning tests with no backend')
        attrs = '-a !vispy_app_test '
    else:
        has, why_not = has_backend(mode, out=['why_not'])
        if has:
            print('%s\nRunning tests with %s backend' % (extra, mode))
            attrs = '-a vispy_app_test '
        else:
            msg = ('Skipping tests for backend %s, not found (%s)'
                   % (mode, why_not))
            print(extra + '\n' + msg + '\n' + extra + '\n')  # last \n nicer
            raise SkipTest(msg)
    sys.stdout.flush()
    if coverage:
        covs = '--with-coverage --cover-package=vispy --cover-branches '
    else:
        covs = ''
    args = ' ' + ('--verbosity=%s ' % verbosity) + covs + attrs
    # make a call to "python" so that it inherits whatever the system
    # thinks is "python" (e.g., virtualenvs)
    cmd = ['python', '-c',
           'import nose; nose.main(argv="%s".split(" "))' % args]
    env = deepcopy(os.environ)
    env.update(dict(_VISPY_TESTING_TYPE=mode))
    p = Popen(cmd, cwd=cwd, env=env)
    stdout, stderr = p.communicate()
    if(p.returncode):
        raise RuntimeError('Nose failure (%s):\n%s' % (p.returncode, stderr))


def _flake():
    """Test flake8"""
    orig_dir = os.getcwd()
    root_dir, dev = _get_root_dir()
    os.chdir(root_dir)
    if dev:
        sys.argv[1:] = ['vispy', 'examples', 'make']
    else:
        sys.argv[1:] = ['vispy']
    sys.argv.append('--ignore=E226,E241,E265,W291,W293')
    sys.argv.append('--exclude=six.py,py24_ordereddict.py,glfw.py,'
                    '_proxy.py,_angle.py,_desktop.py,_pyopengl.py,'
                    '_constants.py')
    try:
        from flake8.main import main
    except ImportError:
        print('Skipping flake8 test, flake8 not installed')
    else:
        print('Running flake8... ')  # if end='', first error gets ugly
        sys.stdout.flush()
        try:
            main()
        except SystemExit as ex:
            if ex.code in (None, 0):
                pass  # do not exit yet, we want to print a success msg
            else:
                raise RuntimeError('flake8 failed')
    finally:
        os.chdir(orig_dir)


def _check_line_endings():
    """Check all files in the repository for CR characters"""
    if sys.platform == 'win32':
        print('Skipping line endings check on Windows')
        sys.stdout.flush()
        return
    print('Running line endings check... ')
    sys.stdout.flush()
    report = []
    root_dir, dev = _get_root_dir()
    if not dev:
        root_dir = op.join(root_dir, 'vispy')
    for dirpath, dirnames, filenames in os.walk(root_dir):
        for fname in filenames:
            if op.splitext(fname)[1] in ('.pyc', '.pyo', '.so', '.dll'):
                continue
            # Get filename
            filename = op.join(dirpath, fname)
            relfilename = op.relpath(filename, root_dir)
            # Open and check
            try:
                text = open(filename, 'rb').read().decode('utf-8')
            except UnicodeDecodeError:
                continue  # Probably a binary file
            crcount = text.count('\r')
            if crcount:
                lfcount = text.count('\n')
                report.append('In %s found %i/%i CR/LF' %
                              (relfilename, crcount, lfcount))

    # Process result
    if len(report) > 0:
        raise RuntimeError('Found %s files with incorrect endings:\n%s'
                           % (len(report), '\n'.join(report)))


def _tester(label='full', coverage=False, verbosity=1):
    """Test vispy software. See vispy.test()
    """
    from vispy.app.backends import BACKEND_NAMES as backend_names
    label = label.lower()
    verbosity = int(verbosity)
    cov = bool(coverage)
    if cov and op.isfile('.coverage'):
        os.remove('.coverage')
    known_types = ['full', 'nose', 'lineendings', 'extra', 'flake',
                   'nobackend'] + backend_names
    if label not in known_types:
        raise ValueError('label must be one of %s, or a backend name %s'
                         % (known_types, backend_names))
    work_dir = _get_root_dir()[0]
    orig_dir = os.getcwd()
    # figure out what we actually need to run
    runs = []
    if label in ('full', 'nose'):
        for backend in backend_names:
            runs.append([partial(_nose, backend, verbosity, cov), backend])
    elif label in backend_names:
        runs.append([partial(_nose, label, verbosity, cov), label])
    if label in ('full', 'nose', 'nobackend'):
        runs.append([partial(_nose, 'nobackend', verbosity, cov), 'nobackend'])
    if label in ('full', 'extra', 'lineendings'):
        runs.append([_check_line_endings, 'lineendings'])
    if label in ('full', 'extra', 'flake'):
        runs.append([_flake, 'flake'])
    t0 = time()
    fail = []
    skip = []
    for run in runs:
        try:
            os.chdir(work_dir)
            run[0]()
        except RuntimeError as exp:
            print('Failed: %s' % str(exp))
            fail += [run[1]]
        except SkipTest:
            skip += [run[1]]
        except Exception as exp:
            # this should only happen if we've screwed up the test setup
            fail += [run[1]]
            print('Failed strangely: %s\n' % str(exp))
        else:
            print('Passed\n')
        finally:
            sys.stdout.flush()
            os.chdir(orig_dir)
    dt = time() - t0
    stat = '%s failed, %s skipped' % (fail if fail else 0, skip if skip else 0)
    extra = 'failed' if fail else 'succeeded'
    print('Testing %s (%s) in %0.3f seconds' % (extra, stat, dt))
    sys.stdout.flush()
    if len(fail) > 0:
        raise RuntimeError('FAILURE')

########NEW FILE########
__FILENAME__ = _testing
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------

from __future__ import print_function

import numpy as np
import os


###############################################################################
# Adapted from Python's unittest2 (which is wrapped by nose)
# http://docs.python.org/2/license.html

try:
    from unittest.case import SkipTest
except ImportError:
    try:
        from unittest2.case import SkipTest
    except ImportError:
        class SkipTest(Exception):
            pass


def _safe_rep(obj, short=False):
    """Helper for assert_* ports"""
    try:
        result = repr(obj)
    except Exception:
        result = object.__repr__(obj)
    if not short or len(result) < 80:
        return result
    return result[:80] + ' [truncated]...'


def _safe_str(obj):
    """Helper for assert_* ports"""
    try:
        return str(obj)
    except Exception:
        return object.__str__(obj)


def _format_msg(msg, std_msg):
    """Helper for assert_* ports"""
    if msg is None:
        msg = std_msg
    else:
        try:
            msg = '%s : %s' % (std_msg, msg)
        except UnicodeDecodeError:
            msg = '%s : %s' % (_safe_str(std_msg), _safe_str(msg))
    return msg


def assert_in(member, container, msg=None):
    """Backport for old nose.tools"""
    if member in container:
        return
    std_msg = '%s not found in %s' % (_safe_rep(member), _safe_rep(container))
    msg = _format_msg(msg, std_msg)
    raise AssertionError(msg)


def assert_not_in(member, container, msg=None):
    """Backport for old nose.tools"""
    if member not in container:
        return
    std_msg = '%s found in %s' % (_safe_rep(member), _safe_rep(container))
    msg = _format_msg(msg, std_msg)
    raise AssertionError(msg)


def assert_is(expr1, expr2, msg=None):
    """Backport for old nose.tools"""
    if expr1 is not expr2:
        std_msg = '%s is not %s' % (_safe_rep(expr1), _safe_rep(expr2))
        raise AssertionError(_format_msg(msg, std_msg))


###############################################################################
# GL stuff

def _has_pyopengl():
    try:
        from OpenGL import GL  # noqa, analysis:ignore
    except Exception:
        return False
    else:
        return True


def requires_pyopengl():
    return np.testing.dec.skipif(not _has_pyopengl(), 'Requires PyOpenGL')


###############################################################################
# App stuff

def has_backend(backend, has=(), capable=(), out=()):
    using = os.getenv('_VISPY_TESTING_BACKEND', None)
    if using is not None and using != backend:
        # e.g., we are on  a 'pyglet' run but the test requires PyQt4
        ret = (False,) if len(out) > 0 else False
        for o in out:
            ret += (None,)
        return ret
    # let's follow the standard code path
    mod = __import__('app.backends._%s' % backend, globals(), level=2)
    mod = getattr(mod.backends, '_%s' % backend)
    good = mod.testable
    for h in has:
        good = (good and getattr(mod, 'has_%s' % h))
    for cap in capable:
        good = (good and mod.capability[cap])
    ret = (good,) if len(out) > 0 else good
    for o in out:
        ret += (getattr(mod, o),)
    return ret


def requires_application(backend=None, has=(), capable=()):
    """Decorator for tests that require an application"""
    from ..app.backends import BACKEND_NAMES
    if backend is None:
        good = False
        for backend in BACKEND_NAMES:
            if has_backend(backend, has=has, capable=capable):
                good = True
                break
        msg = 'Requires application backend'
    else:
        good, why = has_backend(backend, has=has, capable=capable,
                                out=['why_not'])
        msg = 'Requires %s: %s' % (backend, why)

    # Actually construct the decorator
    def skip_decorator(f):
        import nose
        f.vispy_app_test = True  # set attribute for easy run or not

        def skipper(*args, **kwargs):
            if not good:
                raise SkipTest("Skipping test: %s: %s" % (f.__name__, msg))
            else:
                return f(*args, **kwargs)
        return nose.tools.make_decorator(f)(skipper)
    return skip_decorator


def glut_skip():
    """Helper to skip a test if GLUT is the current backend"""
    # this is basically a knownfail tool for glut
    from ..app import default_app
    default_app.use()
    if default_app.backend_name.lower() == 'glut':
        raise SkipTest('GLUT unstable')
    return  # otherwise it's fine

########NEW FILE########
__FILENAME__ = color
"""
Functions for handling color values
 - conversion between colorspaces (0.0-1.0 vs 0-255; RGB/RGBA/HSV; etc.)
 - define shorthand for specifying colors (single letters, short names, etc)
"""

########NEW FILE########
__FILENAME__ = cube
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2014, Vispy Development Team. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
# Author: Nicolas P .Rougier
# Date:   04/03/2014
# -----------------------------------------------------------------------------
import numpy as np


def cube():
    """ Generate vertices & indices for a filled and outlined cube """

    vtype = [('position', np.float32, 3),
             ('texcoord', np.float32, 2),
             ('normal', np.float32, 3),
             ('color',    np.float32, 4)]
    itype = np.uint32

    # Vertices positions
    p = np.array([[1, 1, 1], [-1, 1, 1], [-1, -1, 1], [1, -1, 1],
                  [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, -1]])

    # Face Normals
    n = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0],
                  [-1, 0, 1], [0, -1, 0], [0, 0, -1]])

    # Vertice colors
    c = np.array([[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 1, 0, 1],
                  [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 0, 1]])

    # Texture coords
    t = np.array([[0, 0], [0, 1], [1, 1], [1, 0]])

    faces_p = [0, 1, 2, 3,
               0, 3, 4, 5,
               0, 5, 6, 1,
               1, 6, 7, 2,
               7, 4, 3, 2,
               4, 7, 6, 5]
    faces_c = [0, 1, 2, 3,
               0, 3, 4, 5,
               0, 5, 6, 1,
               1, 6, 7, 2,
               7, 4, 3, 2,
               4, 7, 6, 5]
    faces_n = [0, 0, 0, 0,
               1, 1, 1, 1,
               2, 2, 2, 2,
               3, 3, 3, 3,
               4, 4, 4, 4,
               5, 5, 5, 5]
    faces_t = [0, 1, 2, 3,
               0, 1, 2, 3,
               0, 1, 2, 3,
               3, 2, 1, 0,
               0, 1, 2, 3,
               0, 1, 2, 3]

    vertices = np.zeros(24, vtype)
    vertices['position'] = p[faces_p]
    vertices['normal'] = n[faces_n]
    vertices['color'] = c[faces_c]
    vertices['texcoord'] = t[faces_t]

    filled = np.resize(
        np.array([0, 1, 2, 0, 2, 3], dtype=itype), 6 * (2 * 3))
    filled += np.repeat(4 * np.arange(6, dtype=itype), 6)

    outline = np.resize(
        np.array([0, 1, 1, 2, 2, 3, 3, 0], dtype=itype), 6 * (2 * 4))
    outline += np.repeat(4 * np.arange(6, dtype=itype), 8)

    return vertices, filled, outline

########NEW FILE########
__FILENAME__ = io
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

""" Reading and writing of data like images and meshes.
"""

import os
import bz2
import numpy as np

from .wavefront import WavefrontReader, WavefrontWriter

THISDIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(os.path.dirname(THISDIR), '..', 'data')


# So we can demo image data without needing an image reading library
def crate():
    """ Return an image of a crate (256x256 RGB).
    """
    with open(os.path.join(DATA_DIR, 'crate.bz2'), 'rb') as f:
        bb = f.read()
    a = np.frombuffer(bz2.decompress(bb), np.uint8)
    a.shape = 256, 256, 3
    return a


# def _write_image_blob(im, fname):
#     bb = bz2.compress(im.tostring())
#     with open(os.path.join(DATA_DIR, fname), 'wb') as f:
#         f.write(bb)


def read_mesh(fname, format=None):
    """Read mesh data from file.

    Parameters
    ----------
    fname : str
        File name to read.
    format : str | None
        Format of file to read in. Currently only ``"obj"`` is supported.
        If None, format will be inferred from the filename.

    Returns
    -------
    vertices : array
        Vertices.
    faces : array | None
        Triangle face definitions.
    normals : array
        Normals for the mesh.
    texcoords : array | None
        Texture coordinates.

    Notes
    -----
    Mesh files that ship with vispy always work, such as 'triceratops.obj'.
    """
    # Check file
    if not os.path.isfile(fname):
        # Maybe we have it?
        fname_ = os.path.join(DATA_DIR, fname)
        if os.path.isfile(fname_):
            fname = fname_
        else:
            raise ValueError('File does not exist: %s' % fname)

    # Check format
    if format is None:
        format = os.path.splitext(fname)[1]
    format = format.strip('. ').upper()

    if format == 'OBJ':
        return WavefrontReader.read(fname)
    elif not format:
        raise ValueError('read_mesh needs could not determine format.')
    else:
        raise ValueError('read_mesh does not understand format %s.' % format)


def write_mesh(fname, vertices, faces, normals, texcoords, name='',
               format='obj', overwrite=False):
    """ Write mesh data to file.
    """
    # Check file
    if os.path.isfile(fname):
        if not overwrite:
            raise IOError('file "%s" exists, use overwrite=True' % fname)
        else:
            os.remove(fname)

    # Check format
    if format not in ['obj']:
        raise ValueError('Only "obj" format writing currently supported')
    return WavefrontWriter.write(fname, vertices, faces, normals, texcoords,
                                 name)


def imread(filename, format=None):
    """ Function to read image data. Requires imageio or PIL.
    """
    imageio, PIL = _check_img_lib()
    if imageio is not None:
        return imageio.imread(filename, format)
    elif PIL is not None:
        im = PIL.Image.open(filename)
        if im.mode == 'P':
            im = im.convert()
        # Make numpy array
        a = np.asarray(im)
        if len(a.shape) == 0:
            raise MemoryError("Too little memory to convert PIL image to "
                              "array")
        return a
    else:
        raise RuntimeError("imread requires the imageio or PIL package.")


def imsave(filename, im, format=None):
    """ Function to save image data. Requires imageio or PIL.
    """
    # Import imageio or PIL
    imageio, PIL = _check_img_lib()
    if imageio is not None:
        return imageio.imsave(filename, im, format)
    elif PIL is not None:
        pim = PIL.Image.fromarray(im)
        pim.save(filename, format)
    else:
        raise RuntimeError("imsave requires the imageio or PIL package.")


def _check_img_lib():
    """Utility to search for imageio or PIL"""
    # Import imageio or PIL
    imageio = PIL = None
    try:
        import imageio
    except ImportError:
        try:
            import PIL.Image
        except ImportError:
            pass
    return imageio, PIL

########NEW FILE########
__FILENAME__ = wavefront
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

# This module was taken from visvis
"""
This module produces functionality to read and write wavefront (.OBJ) files.

http://en.wikipedia.org/wiki/Wavefront_.obj_file

The wavefront format is quite powerful and allows a wide variety of surfaces
to be described.

This implementation does only supports mesh stuff, so no nurbs etc. Further,
material properties are ignored, although this might be implemented later,

The classes are written with compatibility of Python3 in mind.

"""

import numpy as np
import time

from .._geom import _calculate_normals
from .._logging import logger


class WavefrontReader(object):

    def __init__(self, f):
        self._f = f

        # Original vertices, normals and texture coords.
        # These are not necessarily of the same length.
        self._v = []
        self._vn = []
        self._vt = []

        # Final vertices, normals and texture coords.
        # All three lists are of the same length, as opengl wants it.
        self._vertices = []
        self._normals = []
        self._texcords = []

        # The faces, indices to vertex/normal/texcords arrays.
        self._faces = []

        # Dictionary to keep track of processed face data, so we can
        # convert the original v/vn/vn to the final vertices/normals/texcords.
        self._facemap = {}

    @classmethod
    def read(cls, fname, check='ignored'):
        """ read(fname)

        This classmethod is the entry point for reading OBJ files.

        Parameters
        ----------
        fname : string
            The name of the file to read.

        """
        # Open file
        with open(fname, 'rb') as f:
            try:
                reader = WavefrontReader(f)
                while True:
                    reader.readLine()
            except EOFError:
                pass

        # Done
        t0 = time.time()
        mesh = reader.finish()
        logger.debug('reading mesh took ' + str(time.time() - t0) + ' seconds')
        return mesh

    def readLine(self):
        """ The method that reads a line and processes it.
        """

        # Read line
        line = self._f.readline().decode('ascii', 'ignore')
        if not line:
            raise EOFError()
        line = line.strip()

        if line.startswith('v '):
            #self._vertices.append( *self.readTuple(line) )
            self._v.append(self.readTuple(line))
        elif line.startswith('vt '):
            self._vt.append(self.readTuple(line, 3))
        elif line.startswith('vn '):
            self._vn.append(self.readTuple(line))
        elif line.startswith('f '):
            self._faces.append(self.readFace(line))
        elif line.startswith('#'):
            pass  # Comment
        elif line.startswith('mtllib '):
            logger.warning('Notice reading .OBJ: material properties are '
                           'ignored.')
        elif any(line.startswith(x) for x in ('g ', 's ', 'o ', 'usemtl ')):
            pass  # Ignore groups and smoothing groups, obj names, material
        elif not line.strip():
            pass
        else:
            logger.warning('Notice reading .OBJ: ignoring %s command.'
                           % line.strip())

    def readTuple(self, line, n=3):
        """ Reads a tuple of numbers. e.g. vertices, normals or teture coords.
        """
        numbers = [num for num in line.split(' ') if num]
        return [float(num) for num in numbers[1:n + 1]]

    def readFace(self, line):
        """ Each face consists of three or more sets of indices. Each set
        consists of 1, 2 or 3 indices to vertices/normals/texcords.
        """

        # Get parts (skip first)
        indexSets = [num for num in line.split(' ') if num][1:]

        final_face = []
        for indexSet in indexSets:

            # Did we see this exact index earlier? If so, it's easy
            final_index = self._facemap.get(indexSet)
            if final_index is not None:
                final_face.append(final_index)
                continue

            # If not, we need to sync the vertices/normals/texcords ...

            # Get and store final index
            final_index = len(self._vertices)
            final_face.append(final_index)
            self._facemap[indexSet] = final_index

            # What indices were given?
            indices = [i for i in indexSet.split('/')]

            # Store new set of vertex/normal/texcords.
            # If there is a single face that does not specify the texcord
            # index, the texcords are ignored. Likewise for the normals.
            if True:
                vertex_index = self._absint(indices[0], len(self._v))
                self._vertices.append(self._v[vertex_index])
            if self._texcords is not None:
                if len(indices) > 1 and indices[1]:
                    texcord_index = self._absint(indices[1], len(self._vt))
                    self._texcords.append(self._vt[texcord_index])
                else:
                    if self._texcords:
                        logger.warning('Ignoring texture coordinates because '
                                       'it is not specified for all faces.')
                    self._texcords = None
            if self._normals is not None:
                if len(indices) > 2 and indices[2]:
                    normal_index = self._absint(indices[2], len(self._vn))
                    self._normals.append(self._vn[normal_index])
                else:
                    if self._normals:
                        logger.warning('Ignoring normals because it is not '
                                       'specified for all faces.')
                    self._normals = None

        # Check face
        if self._faces and len(self._faces[0]) != len(final_face):
            raise RuntimeError(
                'Vispy requires that all faces are either triangles or quads.')

        # Done
        return final_face

    def _absint(self, i, ref):
        i = int(i)
        if i > 0:
            return i - 1
        else:
            return ref + i

    def _calculate_normals(self):
        vertices, faces = self._vertices, self._faces
        if faces is None:
            # ensure it's always 2D so we can use our methods
            faces = np.arange(0, vertices.size, dtype=np.uint32)[:, np.newaxis]
        normals = _calculate_normals(vertices, faces)
        return normals

    def finish(self):
        """ Converts gathere lists to numpy arrays and creates
        BaseMesh instance.
        """
        self._vertices = np.array(self._vertices, 'float32')
        if self._faces:
            self._faces = np.array(self._faces, 'uint32')
        else:
            # Use vertices only
            self._vertices = np.array(self._v, 'float32')
            self._faces = None
        if self._normals:
            self._normals = np.array(self._normals, 'float32')
        else:
            self._normals = self._calculate_normals()
        if self._texcords:
            self._texcords = np.array(self._texcords, 'float32')
        else:
            self._texcords = None

        return self._vertices, self._faces, self._normals, self._texcords


class WavefrontWriter(object):

    def __init__(self, f):
        self._f = f

    @classmethod
    def write(cls, fname, vertices, faces, normals, texcoords, name=''):
        """ This classmethod is the entry point for writing mesh data to OBJ.

        Parameters
        ----------
        fname : string
            The filename to write to.
        vertices : numpy array
            The vertex data
        faces : numpy array
            The face data
        texcoords : numpy array
            The texture coordinate per vertex
        name : string
            The name of the object (e.g. 'teapot')

        """

        # Open file
        f = open(fname, 'wb')
        try:
            writer = WavefrontWriter(f)
            writer.writeMesh(vertices, faces, normals, texcoords, name)
        except EOFError:
            pass
        finally:
            f.close()

    def writeLine(self, text):
        """ Simple writeLine function to write a line of code to the file.
        The encoding is done here, and a newline character is added.
        """
        text += '\n'
        self._f.write(text.encode('ascii'))

    def writeTuple(self, val, what):
        """ Writes a tuple of numbers (on one line).
        """
        # Limit to three values. so RGBA data drops the alpha channel
        # Format can handle up to 3 texcords
        val = val[:3]
        # Make string
        val = ' '.join([str(v) for v in val])
        # Write line
        self.writeLine('%s %s' % (what, val))

    def writeFace(self, val, what='f'):
        """ Write the face info to the net line.
        """
        # OBJ counts from 1
        val = [v + 1 for v in val]
        # Make string
        if self._hasValues and self._hasNormals:
            val = ' '.join(['%i/%i/%i' % (v, v, v) for v in val])
        elif self._hasNormals:
            val = ' '.join(['%i//%i' % (v, v) for v in val])
        elif self._hasValues:
            val = ' '.join(['%i/%i' % (v, v) for v in val])
        else:
            val = ' '.join(['%i' % v for v in val])
        # Write line
        self.writeLine('%s %s' % (what, val))

    def writeMesh(self, vertices, faces, normals, values, name=''):
        """ Write the given mesh instance.
        """

        # Store properties
        self._hasNormals = normals is not None
        self._hasValues = values is not None
        self._hasFaces = faces is not None

        # Get faces and number of vertices
        if faces is None:
            faces = np.arange(len(vertices))

        # Reshape faces
        Nfaces = faces.size / 3
        faces = faces.reshape((Nfaces, 3))

        # Number of vertices
        N = vertices.shape[0]

        # Get string with stats
        stats = []
        stats.append('%i vertices' % N)
        if self._hasValues:
            stats.append('%i texcords' % N)
        else:
            stats.append('no texcords')
        if self._hasNormals:
            stats.append('%i normals' % N)
        else:
            stats.append('no normals')
        stats.append('%i faces' % faces.shape[0])

        # Write header
        self.writeLine('# Wavefront OBJ file')
        self.writeLine('# Created by vispy.')
        self.writeLine('#')
        if name:
            self.writeLine('# object %s' % name)
        else:
            self.writeLine('# unnamed object')
        self.writeLine('# %s' % ', '.join(stats))
        self.writeLine('')

        # Write data
        if True:
            for i in range(N):
                self.writeTuple(vertices[i], 'v')
        if self._hasNormals:
            for i in range(N):
                self.writeTuple(normals[i], 'vn')
        if self._hasValues:
            for i in range(N):
                self.writeTuple(values[i], 'vt')
        if True:
            for i in range(faces.shape[0]):
                self.writeFace(faces[i])

########NEW FILE########
__FILENAME__ = event
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""
The event module implements the classes that make up the event system.
The Event class and its subclasses are used to represent "stuff that happens".
The EventEmitter class provides an interface to connect to events and
to emit events. The EmitterGroup groups EventEmitter objects.

For more information see http://github.com/vispy/vispy/wiki/API_Events

"""

from __future__ import division

import sys
import inspect
import weakref

from .ordereddict import OrderedDict
from ._logging import logger
from ..ext.six import string_types


class Event(object):

    """Class describing events that occur and can be reacted to with callbacks.
    Each event instance contains information about a single event that has
    occurred such as a key press, mouse motion, timer activation, etc.

    Subclasses: :class:`KeyEvent`, :class:`MouseEvent`, :class:`TouchEvent`,
    :class:`StylusEvent`

    The creation of events and passing of events to the appropriate callback
    functions is the responsibility of :class:`EventEmitter` instances.

    Note that each event object has an attribute for each of the input
    arguments listed below.

    Parameters
    ----------
    type : str
       String indicating the event type (e.g. mouse_press, key_release)
    native : object (optional)
       The native GUI event object
    **kwds : keyword arguments
        All extra keyword arguments become attributes of the event object.
    """

    def __init__(self, type, native=None, **kwds):
        # stack of all sources this event has been emitted through
        self._sources = []
        self._handled = False
        self._blocked = False
        # Store args
        self._type = type
        self._native = native
        for k, v in kwds.items():
            setattr(self, k, v)

    @property
    def source(self):
        """The object that the event applies to (i.e. the source of the event).
        """
        return self._sources[-1] if self._sources else None

    @property
    def sources(self):
        """ List of objects that the event applies to (i.e. are or have
        been a source of the event). Can contain multiple objects in case
        the event traverses a hierarchy of objects.
        """
        return self._sources

    def _push_source(self, source):
        self._sources.append(source)

    def _pop_source(self):
        return self._sources.pop()

    @property
    def type(self):
        # No docstring; documeted in class docstring
        return self._type

    @property
    def native(self):
        # No docstring; documeted in class docstring
        return self._native

    @property
    def handled(self):
        """This boolean property indicates whether the event has already been
        acted on by an event handler. Since many handlers may have access to
        the same events, it is recommended that each check whether the event
        has already been handled as well as set handled=True if it decides to
        act on the event.
        """
        return self._handled

    @handled.setter
    def handled(self, val):
        self._handled = bool(val)

    @property
    def blocked(self):
        """This boolean property indicates whether the event will be delivered
        to event callbacks. If it is set to True, then no further callbacks
        will receive the event. When possible, it is recommended to use
        Event.handled rather than Event.blocked.
        """
        return self._blocked

    @blocked.setter
    def blocked(self, val):
        self._blocked = bool(val)

    def __repr__(self):
        # Try to generate a nice string representation of the event that
        # includes the interesting properties.
        # need to keep track of depth because it is
        # very difficult to avoid excessive recursion.
        global _event_repr_depth
        _event_repr_depth += 1
        try:
            if _event_repr_depth > 2:
                return "<...>"
            attrs = []
            for name in dir(self):
                if name.startswith('_'):
                    continue
                # select only properties
                if not hasattr(type(self), name) or \
                        not isinstance(getattr(type(self), name), property):
                    continue
                attr = getattr(self, name)

                attrs.append("%s=%s" % (name, attr))
            return "<%s %s>" % (self.__class__.__name__, " ".join(attrs))
        finally:
            _event_repr_depth -= 1

_event_repr_depth = 0


class EventEmitter(object):

    """Encapsulates a list of event callbacks.

    Each instance of EventEmitter represents the source of a stream of similar
    events, such as mouse click events or timer activation events. For
    example, the following diagram shows the propagation of a mouse click
    event to the list of callbacks that are registered to listen for that
    event::

       User clicks    |Canvas creates
       mouse on       |MouseEvent:                |'mouse_press' EventEmitter:         |callbacks in sequence: # noqa
       Canvas         |                           |                                    |  # noqa
                   -->|event = MouseEvent(...) -->|Canvas.events.mouse_press(event) -->|callback1(event)  # noqa
                      |                           |                                 -->|callback2(event)  # noqa
                      |                           |                                 -->|callback3(event)  # noqa

    Callback functions may be added or removed from an EventEmitter using
    :func:`connect() <vispy.event.EventEmitter.connect>` or
    :func:`disconnect() <vispy.event.EventEmitter.disconnect>`.

    Calling an instance of EventEmitter will cause each of its callbacks
    to be invoked in sequence. All callbacks are invoked with a single
    argument which will be an instance of :class:`Event <vispy.event.Event>`.

    EventEmitters are generally created by an EmitterGroup instance.

    Parameters
    ----------
    source : object
        The object that the generated events apply to. All emitted Events will
        have their .source property set to this value.
    type : str or None
        String indicating the event type (e.g. mouse_press, key_release)
    event_class : subclass of Event
        The class of events that this emitter will generate.
    """

    def __init__(self, source=None, type=None, event_class=Event):
        self._callbacks = []
        self._callback_refs = []
        self.blocked = 0
        self._emitting = False  # used to detect emitter loops
        self.source = source
        self.default_args = {}
        if type is not None:
            self.default_args['type'] = type

        assert inspect.isclass(event_class)
        self.event_class = event_class

        self._ignore_callback_errors = True
        self._print_callback_errors = True

    @property
    def ignore_callback_errors(self):
        """Whether exceptions during callbacks will be caught by the emitter

        This allows it to continue invoking other callbacks if an error
        occurs.
        """
        return self._ignore_callback_errors

    @ignore_callback_errors.setter
    def ignore_callback_errors(self, val):
        self._ignore_callback_errors = val

    @property
    def print_callback_errors(self):
        """Print a message and stack trace if a callback raises an exception

        This assumes ignore_callback_errors=True. These will be raised as
        warnings, so ensure that the vispy logging level is set to at
        least "warning".
        """
        return self._print_callback_errors

    @print_callback_errors.setter
    def print_callback_errors(self, val):
        self._print_callback_errors = val

    @property
    def callback_refs(self):
        """The set of callback references"""
        return tuple(self._callback_refs)

    @property
    def callbacks(self):
        """The set of callbacks"""
        return tuple(self._callbacks)

    @property
    def source(self):
        """The object that events generated by this emitter apply to"""
        return None if self._source is None else self._source(
        )  # get object behind weakref

    @source.setter
    def source(self, s):
        if s is None:
            self._source = None
        else:
            self._source = weakref.ref(s)

    def connect(self, callback, ref=False, position='first',
                before=None, after=None):
        """Connect this emitter to a new callback.

        Parameters
        ----------
        callback : function | tuple
            *callback* may be either a callable object or a tuple
            (object, attr_name) where object.attr_name will point to a
            callable object.
        ref : bool | str
            Reference used to identify the callback in ``before``/``after``.
            If True, the callback ref will automatically determined (see
            Notes). If False, the callback cannot be referred to by a string.
            If str, the given string will be used. Note that if ``ref``
            is not unique in ``callback_refs``, an error will be thrown.
        position : str
            If ``'first'``, the first eligible position is used (that
            meets the before and after criteria), ``'last'`` will use
            the last position.
        before : str | callback | list of str or callback | None
            List of callbacks that the current callback should precede.
            Can be None if no before-criteria should be used.
        after : str | callback | list of str or callback | None
            List of callbacks that the current callback should follow.
            Can be None if no after-criteria should be used.

        Notes
        -----
        If ``ref=True``, the callback reference will be determined from:

            1. If ``callback`` is ``tuple``, the secend element in the tuple.
            2. The ``__name__`` attribute.
            3. The ``__class__.__name__`` attribute.

        The current list of callback refs can be obtained using
        ``event.callback_refs``. Callbacks can be referred to by either
        their string reference (if given), or by the actual callback that
        was attached (e.g., ``(canvas, 'swap_buffers')``).

        If the specified callback is already connected, then the request is
        ignored.

        If before is None and after is None (default), the new callback will
        be added to the beginning of the callback list. Thus the
        callback that is connected _last_ will be the _first_ to receive
        events from the emitter.
        """
        callbacks = self.callbacks
        callback_refs = self.callback_refs
        if callback in callbacks:
            return
        # deal with the ref
        if isinstance(ref, bool):
            if ref:
                if isinstance(callback, tuple):
                    ref = callback[1]
                elif hasattr(callback, '__name__'):  # function
                    ref = callback.__name__
                else:  # Method, or other
                    ref = callback.__class__.__name__
            else:
                ref = None
        elif not isinstance(ref, string_types):
            raise TypeError('ref must be a bool or string')
        if ref is not None and ref in self._callback_refs:
            raise ValueError('ref "%s" is not unique' % ref)

        # positions
        if position not in ('first', 'last'):
            raise ValueError('position must be "first" or "last", not %s'
                             % position)

        # bounds
        bounds = list()  # upper & lower bnds (inclusive) of possible cb locs
        for ri, criteria in enumerate((before, after)):
            if criteria is None or criteria == []:
                bounds.append(len(callback_refs) if ri == 0 else 0)
            else:
                if not isinstance(criteria, list):
                    criteria = [criteria]
                for c in criteria:
                    count = sum([(c == cn or c == cc) for cn, cc
                                 in zip(callback_refs, callbacks)])
                    if count != 1:
                        raise ValueError('criteria "%s" is in the current '
                                         'callback list %s times:\n%s\n%s'
                                         % (criteria, count,
                                            callback_refs, callbacks))
                matches = [ci for ci, (cn, cc) in enumerate(zip(callback_refs,
                                                                callbacks))
                           if (cc in criteria or cn in criteria)]
                bounds.append(matches[0] if ri == 0 else (matches[-1] + 1))
        if bounds[0] < bounds[1]:  # i.e., "place before" < "place after"
            raise RuntimeError('cannot place callback before "%s" '
                               'and after "%s" for callbacks: %s'
                               % (before, after, callback_refs))
        idx = bounds[1] if position == 'first' else bounds[0]  # 'last'

        # actually add the callback
        self._callbacks.insert(idx, callback)
        self._callback_refs.insert(idx, ref)
        return callback  # allows connect to be used as a decorator

    def disconnect(self, callback=None):
        """Disconnect a callback from this emitter.

        If no callback is specified, then *all* callbacks are removed.
        If the callback was not already connected, then the call does nothing.
        """
        if callback is None:
            self._callbacks = []
            self._callback_refs = []
        else:
            if callback in self._callbacks:
                idx = self._callbacks.index(callback)
                self._callbacks.pop(idx)
                self._callback_refs.pop(idx)

    def __call__(self, *args, **kwds):
        """ __call__(**kwds)
        Invoke all callbacks for this emitter.

        Emit a new event object, created with the given keyword
        arguments, which must match with the input arguments of the
        corresponding event class. Note that the 'type' argument is
        filled in by the emitter.

        Alternatively, the emitter can also be called with an Event
        instance as the only argument. In this case, the specified
        Event will be used rather than generating a new one. This allows
        customized Event instances to be emitted and also allows EventEmitters
        to be chained by connecting one directly to another.

        Note that the same Event instance is sent to all callbacks.
        This allows some level of communication between the callbacks
        (notably, via Event.handled) but also requires that callbacks
        be careful not to inadvertently modify the Event.
        """
        if self._emitting:
            raise RuntimeError('EventEmitter loop detected!')

        # create / massage event as needed
        event = self._prepare_event(*args, **kwds)

        # Add our source to the event; remove it after all callbacks have been
        # invoked.
        event._push_source(self.source)
        self._emitting = True
        try:
            if self.blocked > 0:
                return event

            for cb in self._callbacks:
                if isinstance(cb, tuple):
                    cb = getattr(cb[0], cb[1], None)
                    if cb is None:
                        continue

                try:
                    cb(event)
                except Exception:
                    # get traceback and store (so we can do postmortem
                    # debugging)
                    type, value, tb = sys.exc_info()
                    tb = tb.tb_next  # Skip *this* frame
                    sys.last_type = type
                    sys.last_value = value
                    sys.last_traceback = tb
                    # Handle
                    if self.ignore_callback_errors:
                        if self.print_callback_errors:
                            sys.excepthook(type, value, tb)
                            logger.warning("Error invoking callback for "
                                           "event: %s" % str(event))
                    else:
                        raise

                if event.blocked:
                    break
        finally:
            self._emitting = False
            if event._pop_source() != self.source:
                raise RuntimeError("Event source-stack mismatch.")

        return event

    def _prepare_event(self, *args, **kwds):
        # When emitting, this method is called to create or otherwise alter
        # an event before it is sent to callbacks. Subclasses may extend
        # this method to make custom modifications to the event.
        if len(args) == 1 and not kwds and isinstance(args[0], Event):
            event = args[0]
            # Ensure that the given event matches what we want to emit
            assert isinstance(event, self.event_class)
        elif not args:
            args = self.default_args.copy()
            args.update(kwds)
            event = self.event_class(**args)
        else:
            raise ValueError("Event emitters can be called with an Event "
                             "instance or with keyword arguments only.")
        return event

    def block(self):
        """Block this emitter. Any attempts to emit an event while blocked
        will be silently ignored.

        Calls to block are cumulative; the emitter must be unblocked the same
        number of times as it is blocked.
        """
        self.blocked += 1

    def unblock(self):
        """ Unblock this emitter. See :func:`event.EventEmitter.block`.
        """
        self.blocked = max(0, self.blocked - 1)

    def blocker(self):
        """Return an EventBlocker to be used in 'with' statements

           Notes
           -----
           For example, one could do::

               with emitter.blocker():
                   pass  # ..do stuff; no events will be emitted..
        """
        return EventBlocker(self)


class EmitterGroup(EventEmitter):

    """EmitterGroup instances manage a set of related
    :class:`EventEmitters <vispy.event.EventEmitter>`.
    Its primary purpose is to provide organization for objects
    that make use of multiple emitters and to reduce the boilerplate code
    needed to initialize those emitters with default connections.

    EmitterGroup instances are usually stored as an 'events' attribute on
    objects that use multiple emitters. For example::

         EmitterGroup  EventEmitter
                 |       |
        Canvas.events.mouse_press
        Canvas.events.resized
        Canvas.events.key_press

    EmitterGroup is also a subclass of
    :class:`EventEmitters <vispy.event.EventEmitter>`,
    allowing it to emit its own
    events. Any callback that connects directly to the EmitterGroup will
    receive *all* of the events generated by the group's emitters.

    Parameters
    ----------
    source : object
        The object that the generated events apply to.
    auto_connect : bool
        If *auto_connect* is True (default), then one connection will
        be made for each emitter that looks like
        :func:`emitter.connect((source, 'on_' + event_name))
        <vispy.event.EventEmitter.connect>`.
        This provides a simple mechanism for automatically connecting a large
        group of emitters to default callbacks.
    emitters : keyword arguments
        See the :func:`add <vispy.event.EmitterGroup.add>` method.
    """

    def __init__(self, source=None, auto_connect=True, **emitters):
        EventEmitter.__init__(self, source)

        self.auto_connect = auto_connect
        self.auto_connect_format = "on_%s"
        self._emitters = OrderedDict()
        # whether the sub-emitters have been connected to the group:
        self._emitters_connected = False
        self.add(**emitters)

    def __getitem__(self, name):
        """
        Return the emitter assigned to the specified name.
        Note that emitters may also be retrieved as an attribute of the
        EmitterGroup.
        """
        return self._emitters[name]

    def __setitem__(self, name, emitter):
        """
        Alias for EmitterGroup.add(name=emitter)
        """
        self.add(**{name: emitter})

    def add(self, auto_connect=None, **kwds):
        """ Add one or more EventEmitter instances to this emitter group.
        Each keyword argument may be specified as either an EventEmitter
        instance or an Event subclass, in which case an EventEmitter will be
        generated automatically::

            # This statement:
            group.add(mouse_press=MouseEvent,
                      mouse_release=MouseEvent)

            # ..is equivalent to this statement:
            group.add(mouse_press=EventEmitter(group.source, 'mouse_press',
                                               MouseEvent),
                      mouse_release=EventEmitter(group.source, 'mouse_press',
                                                 MouseEvent))
        """
        if auto_connect is None:
            auto_connect = self.auto_connect

        # check all names before adding anything
        for name in kwds:
            if name in self._emitters:
                raise ValueError(
                    "EmitterGroup already has an emitter named '%s'" %
                    name)
            elif hasattr(self, name):
                raise ValueError("The name '%s' cannot be used as an emitter; "
                                 "it is already an attribute of EmitterGroup"
                                 % name)

        # add each emitter specified in the keyword arguments
        for name, emitter in kwds.items():
            if emitter is None:
                emitter = Event

            if inspect.isclass(emitter) and issubclass(emitter, Event):
                emitter = EventEmitter(
                    source=self.source,
                    type=name,
                    event_class=emitter)
            elif not isinstance(emitter, EventEmitter):
                raise Exception('Emitter must be specified as either an '
                                'EventEmitter instance or Event subclass')

            # give this emitter the same source as the group.
            emitter.source = self.source

            setattr(self, name, emitter)
            self._emitters[name] = emitter

            if auto_connect and self.source is not None:
                emitter.connect((self.source, self.auto_connect_format % name))

            # If emitters are connected to the group already, then this one
            # should be connected as well.
            if self._emitters_connected:
                emitter.connect(self)

    @property
    def emitters(self):
        """ List of current emitters in this group.
        """
        return self._emitters

    def __iter__(self):
        """
        Iterates over the names of emitters in this group.
        """
        for k in self._emitters:
            yield k

    def block_all(self):
        """ Block all emitters in this group.
        """
        self.block()
        for em in self._emitters.values():
            em.block()

    def unblock_all(self):
        """ Unblock all emitters in this group.
        """
        self.unblock()
        for em in self._emitters.values():
            em.unblock()

    def connect(self, callback, ref=False, position='first',
                before=None, after=None):
        """ Connect the callback to the event group. The callback will receive
        events from *all* of the emitters in the group.

        See :func:`EventEmitter.connect() <vispy.event.EventEmitter.connect>`
        for arguments.
        """
        self._connect_emitters(True)
        return EventEmitter.connect(self, callback, ref, position,
                                    before, after)

    def disconnect(self, callback=None):
        """ Disconnect the callback from this group. See
        :func:`connect() <vispy.event.EmitterGroup.connect>` and
        :func:`EventEmitter.connect() <vispy.event.EventEmitter.connect>` for
        more information.
        """
        ret = EventEmitter.disconnect(self, callback)
        if len(self._callbacks) == 0:
            self._connect_emitters(False)
        return ret

    def _connect_emitters(self, connect):
        # Connect/disconnect all sub-emitters from the group. This allows the
        # group to emit an event whenever _any_ of the sub-emitters emit,
        # while simultaneously eliminating the overhead if nobody is listening.
        if connect:
            for emitter in self:
                self[emitter].connect(self)
        else:
            for emitter in self:
                self[emitter].disconnect(self)

        self._emitters_connected = connect


class EventBlocker(object):

    """ Represents a block for an EventEmitter to be used in a context
    manager (i.e. 'with' statement).
    """

    def __init__(self, target):
        self.target = target

    def __enter__(self):
        self.target.block()

    def __exit__(self, *args):
        self.target.unblock()

########NEW FILE########
__FILENAME__ = keys
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

""" Define constants for keys.

Each key constant is defined as a Key object, which allows comparison with
strings (e.g. 'A', 'Escape', 'Shift'). This enables handling of key events
without using the key constants explicitly (e.g. ``if ev.key == 'Left':``).

In addition, key objects that represent characters can be matched to
the integer ordinal (e.g. 32 for space, 65 for A). This behavior is mainly
intended as a compatibility measure.

"""

from ..ext.six import string_types


class Key(object):
    """ Represent the identity of a certain key.

    This represents one or more names that the key in question is known by.

    A Key object can be compared to one of its string names (case
    insensitive), to the integer ordinal of the key (only for keys that
    represent characters), and to another Key instance.
    """

    def __init__(self, *names):
        self._names = names
        self._names_upper = tuple([v.upper() for v in names])

    @property
    def name(self):
        """ The primary name of the key.
        """
        return self._names[0]

    def __repr__(self):
        return "<Key %s>" % ', '.join([repr(v) for v in self._names])

    def __eq__(self, other):
        if isinstance(other, string_types):
            return other.upper() in self._names_upper
        elif isinstance(other, Key):
            return self._names[0] == other
        elif isinstance(other, int):
            return other in [ord(v) for v in self._names_upper if len(v) == 1]
        elif other is None:
            return False
        else:
            raise ValueError('Key can only be compared to str, int and Key.')


SHIFT = Key('Shift')
CONTROL = Key('Control')
ALT = Key('Alt')
META = Key('Meta')  # That Mac thingy

UP = Key('Up')
DOWN = Key('Down')
LEFT = Key('Left')
RIGHT = Key('Right')
PAGEUP = Key('PageUp')
PAGEDOWN = Key('PageDown')

INSERT = Key('Insert')
DELETE = Key('Delete')
HOME = Key('Home')
END = Key('End')

ESCAPE = Key('Escape')
BACKSPACE = Key('Backspace')

F1 = Key('F1')
F2 = Key('F2')
F3 = Key('F3')
F4 = Key('F4')
F5 = Key('F5')
F6 = Key('F6')
F7 = Key('F7')
F8 = Key('F8')
F9 = Key('F9')
F10 = Key('F10')
F11 = Key('F11')
F12 = Key('F12')

SPACE = Key('Space', ' ')
ENTER = Key('Enter', 'Return', '\n')
TAB = Key('Tab', '\t')

########NEW FILE########
__FILENAME__ = ordereddict
# -*- coding: utf-8 -*-
from sys import version_info

if version_info[0] > 2 or version_info[1] >= 7:
    from collections import OrderedDict
else:
    from ..ext.py24_ordereddict import OrderedDict  # noqa

########NEW FILE########
__FILENAME__ = ptime
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""
ptime.py -  Precision time function made os-independent
(should have been taken care of by python)
"""

from __future__ import division

import sys
import time as systime
START_TIME = None
time = None


def winTime():
    """Return the current time in seconds with high precision

    (Windows version, use Manager.time() to stay platform independent.)
    """
    return systime.clock() + START_TIME
    # return systime.time()


def unixTime():
    """Return the current time in seconds with high precision

    (Unix version, use Manager.time() to stay platform independent.)
    """
    return systime.time()

if sys.platform.startswith('win'):
    cstart = systime.clock()  # Required to start the clock in windows
    START_TIME = systime.time() - cstart

    time = winTime
else:
    time = unixTime

########NEW FILE########
__FILENAME__ = test_config
from nose.tools import assert_raises, assert_equal
from os import path as op
import os

from vispy.util import (config, sys_info, _TempDir, get_data_file,
                        set_data_dir, save_config)

from vispy.testing import assert_in, requires_application
temp_dir = _TempDir()


@requires_application()
def test_sys_info():
    """Test printing of system information"""
    fname = op.join(temp_dir, 'info.txt')
    sys_info(fname)
    assert_raises(IOError, sys_info, fname)  # no overwrite
    with open(fname, 'r') as fid:
        out = ''.join(fid.readlines())
    # Note: 'GL version' only for non-GLUT
    keys = ['Python', 'Backend', 'pyglet', 'Platform:']
    for key in keys:
        assert_in(key, out)


def test_config():
    """Test vispy config methods and file downloading"""
    assert_raises(TypeError, config.update, data_path=dict())
    assert_raises(KeyError, config.update, foo='bar')  # bad key
    data_dir = op.join(temp_dir, 'data')
    assert_raises(IOError, set_data_dir, data_dir)  # didn't say to create
    orig_val = os.environ.get('_VISPY_CONFIG_TESTING', None)
    os.environ['_VISPY_CONFIG_TESTING'] = 'true'
    try:
        assert_raises(IOError, set_data_dir, data_dir)  # doesn't exist yet
        set_data_dir(data_dir, create=True, save=True)
        assert_equal(config['data_path'], data_dir)
        config['data_path'] = data_dir
        print(config)  # __repr__
        get_data_file('CONTRIBUTING.txt')
        fid = open(op.join(data_dir, 'test-faked.txt'), 'w')
        fid.close()
        get_data_file('test-faked.txt')  # this one shouldn't download
        assert_raises(RuntimeError, get_data_file, 'foo-nonexist.txt')
        save_config()
    finally:
        if orig_val is not None:
            os.environ['_VISPY_CONFIG_TESTING'] = orig_val
        else:
            del os.environ['_VISPY_CONFIG_TESTING']

########NEW FILE########
__FILENAME__ = test_cube
import numpy as np
from numpy.testing import assert_array_equal

from vispy.util.cube import cube


def test_cube():
    """Test cube function"""
    vertices, filled, outline = cube()
    assert_array_equal(np.arange(len(vertices)), np.unique(filled))
    assert_array_equal(np.arange(len(vertices)), np.unique(outline))

########NEW FILE########
__FILENAME__ = test_dataio
import numpy as np
from os import path as op
from nose.tools import assert_equal, assert_raises
from numpy.testing import assert_allclose, assert_array_equal

from vispy.util.dataio import (write_mesh, read_mesh, _check_img_lib, crate,
                               imsave, imread)
from vispy.util._geom import _fast_cross_3d
from vispy.util import _TempDir

temp_dir = _TempDir()

has_img_lib = not all(c is None for c in _check_img_lib())
requires_img_lib = np.testing.dec.skipif(not has_img_lib, 'imageio or PIL '
                                         'required')


def test_wavefront():
    """Test wavefront reader"""
    fname_mesh = 'triceratops.obj'

    fname_out = op.join(temp_dir, 'temp.obj')
    mesh1 = read_mesh(fname_mesh)
    assert_raises(ValueError, read_mesh, 'foo')
    assert_raises(ValueError, read_mesh, op.abspath(__file__))
    assert_raises(ValueError, write_mesh, fname_out, mesh1[0], mesh1[1],
                  mesh1[2], mesh1[3], format='foo')
    write_mesh(fname_out, mesh1[0], mesh1[1], mesh1[2], mesh1[3])
    assert_raises(IOError, write_mesh, fname_out, mesh1[0], mesh1[1],
                  mesh1[2], mesh1[3])
    write_mesh(fname_out, mesh1[0], mesh1[1], mesh1[2], mesh1[3],
               overwrite=True)
    mesh2 = read_mesh(fname_out)
    assert_equal(len(mesh1), len(mesh2))
    for m1, m2 in zip(mesh1, mesh2):
        if m1 is None:
            assert_equal(m2, None)
        else:
            assert_allclose(m1, m2)
    # test our efficient normal calculation routine
    assert_allclose(mesh1[2], _slow_calculate_normals(mesh1[0], mesh1[1]),
                    rtol=1e-10, atol=1e-10)


@requires_img_lib
def test_read_write_image():
    """Test reading and writing of images"""
    fname = op.join(temp_dir, 'out.png')
    im1 = crate()
    imsave(fname, im1, format='png')
    im2 = imread(fname)
    assert_allclose(im1, im2)


def _slow_calculate_normals(rr, tris):
    """Efficiently compute vertex normals for triangulated surface"""
    # first, compute triangle normals
    rr = rr.astype(np.float64)
    r1 = rr[tris[:, 0], :]
    r2 = rr[tris[:, 1], :]
    r3 = rr[tris[:, 2], :]
    tri_nn = np.cross((r2 - r1), (r3 - r1))

    #   Triangle normals and areas
    size = np.sqrt(np.sum(tri_nn * tri_nn, axis=1))
    zidx = np.where(size == 0)[0]
    size[zidx] = 1.0  # prevent ugly divide-by-zero
    tri_nn /= size[:, np.newaxis]

    # accumulate the normals
    nn = np.zeros((len(rr), 3))
    for p, verts in enumerate(tris):
        nn[verts] += tri_nn[p, :]
    size = np.sqrt(np.sum(nn * nn, axis=1))
    size[size == 0] = 1.0  # prevent ugly divide-by-zero
    nn /= size[:, np.newaxis]
    return nn


def test_huge_cross():
    """Test cross product with lots of elements
    """
    x = np.random.rand(100000, 3)
    y = np.random.rand(1, 3)
    z = np.cross(x, y)
    zz = _fast_cross_3d(x, y)
    assert_array_equal(z, zz)

########NEW FILE########
__FILENAME__ = test_dict
from os import path as op
from nose.tools import assert_true, assert_raises, assert_equal
import pickle

from vispy.util.ordereddict import OrderedDict
from vispy.ext.six.moves import zip
from vispy.util import _TempDir

temp_dir = _TempDir()


def test_ordered_dict():
    """Test ordered dictionary"""
    d1 = OrderedDict()
    d2 = OrderedDict()
    for d in [d1, d2]:
        d['a'] = 1
        d['b'] = 2
        d['c'] = 3
    assert_equal(d1, d2)
    assert_true(all(dd1 == dd2
                    for dd1, dd2 in zip(reversed(d1), reversed(d2))))
    assert_raises(TypeError, OrderedDict, 1, 2)
    del d1['c']
    assert_true(d1 != d2)
    d2.popitem()
    assert_equal(d1, d2)

    # pickling (__reduce__)
    fname = op.join(temp_dir, 'pickle')
    with open(fname, 'wb') as fid:
        pickle.dump(d1, fid)
    with open(fname, 'rb') as fid:
        d1p = pickle.load(fid)
    assert_equal(d1, d1p)

########NEW FILE########
__FILENAME__ = test_emitter_group
import unittest
import copy

from vispy.util.event import Event, EventEmitter, EmitterGroup


class BasicEvent(Event):
    pass


class TypedEvent(Event):

    def __init__(self, **kwds):
        kwds['type'] = 'typed_event'
        Event.__init__(self, **kwds)


class TestGroups(unittest.TestCase):

    def test_group_construction(self):
        """EmitterGroup basic construction"""
        grp = EmitterGroup(em1=Event,
                           em2=BasicEvent,
                           em3=TypedEvent)

        grp.em1.connect(self.record_event)
        grp.em2.connect(self.record_event)
        grp.em3.connect(self.record_event)
        self.result = None
        ev = grp.em1()
        self.assert_result(event=ev, type='em1', event_class=Event)
        ev = grp.em2()
        self.assert_result(event=ev, type='em2', event_class=BasicEvent)
        ev = grp.em3()
        self.assert_result(
            event=ev,
            type='typed_event',
            event_class=TypedEvent)

    def test_group_add_emitter(self):
        """EmitterGroup.add"""
        grp = EmitterGroup(em1=Event)
        grp.em1.connect(self.record_event)
        self.result = None
        ev = grp.em1()
        self.assert_result(event=ev, type='em1')

        grp.add(em2=BasicEvent)
        grp.em2.connect(self.record_event)
        ev = grp.em2()
        self.assert_result(event=ev, type='em2', event_class=BasicEvent)

        grp.add(em3=TypedEvent)
        grp.em3.connect(self.record_event)
        ev = grp.em3(test_key=2)
        self.assert_result(
            event=ev,
            type='typed_event',
            event_class=TypedEvent,
            test_key=2)

        try:
            grp.add(em3=Event)
            assert False, "Double-added emitter"
        except ValueError:
            pass

        try:
            grp.add(add=Event)
            assert False, "Added event with invalid name"
        except ValueError:
            pass

    def test_group_block(self):
        """EmitterGroup.block_all"""
        grp = EmitterGroup(em1=Event, em2=Event)

        def cb(ev):
            self.result = 1
        grp.em1.connect(self.record_event)
        grp.em2.connect(self.record_event)
        grp.connect(cb)

        self.result = None
        grp.block_all()
        try:
            grp.em1()
            grp.em2()
            grp(type='test_event')
        finally:
            grp.unblock_all()
        assert self.result is None

    def test_group_disconnect(self):
        """EmitterGroup.disconnect"""
        grp = EmitterGroup(em1=Event)

        assert len(grp.em1.callbacks) == 0, grp.em1.callbacks
        grp.connect(self.record_event)
        assert len(grp.em1.callbacks) == 1
        grp.add(em2=Event)
        assert len(grp.em2.callbacks) == 1
        grp.disconnect()
        assert len(grp.em1.callbacks) == 0
        assert len(grp.em2.callbacks) == 0

    def test_group_autoconnect(self):
        """EmitterGroup auto-connect"""
        class Source:

            def on_em1(self, ev):
                self.result = 1

            def em2_event(self, ev):
                self.result = 2

            def em3_event(self, ev):
                self.result = 3
        src = Source()
        grp = EmitterGroup(source=src, em1=Event, auto_connect=False)
        src.result = None
        grp.em1()
        assert src.result is None

        grp = EmitterGroup(source=src, em1=Event, auto_connect=True)
        src.result = None
        grp.em1()
        assert src.result == 1

        grp.auto_connect_format = "%s_event"
        grp.add(em2=Event)
        src.result = None
        grp.em2()
        assert src.result == 2

        grp.add(em3=Event, auto_connect=False)
        src.result = None
        grp.em3()
        assert src.result is None

    def test_add_custom_emitter(self):
        class Emitter(EventEmitter):

            def _prepare_event(self, *args, **kwds):
                ev = super(Emitter, self)._prepare_event(*args, **kwds)
                ev.test_key = 1
                return ev

        class Source:
            pass
        src = Source()

        grp = EmitterGroup(source=src, em1=Emitter(type='test_event1'))
        grp.em1.connect(self.record_event)
        self.result = None
        ev = grp.em1()
        self.assert_result(
            event=ev,
            test_key=1,
            type='test_event1',
            source=src)

        grp.add(em2=Emitter(type='test_event2'))
        grp.em2.connect(self.record_event)
        self.result = None
        ev = grp.em2()
        self.assert_result(
            event=ev,
            test_key=1,
            type='test_event2',
            source=src)

    def test_group_connect(self):
        grp = EmitterGroup(source=self, em1=Event)
        grp.connect(self.record_event)
        self.result = None
        ev = grp.em1(test_key=1)
        self.assert_result(
            event=ev,
            source=self,
            sources=[
                self,
                self],
            test_key=1)

    def record_event(self, ev, key=None):
        # get a copy of all event attributes because these may change
        # as the event is passed around; we want to know exactly what the event
        # looked like when it reached this callback.
        names = [name for name in dir(ev) if name[0] != '_']
        attrs = {}
        for name in names:
            val = getattr(ev, name)
            if name == 'source':
                attrs[name] = val
            elif name == 'sources':
                attrs[name] = val[:]
            else:
                try:
                    attrs[name] = copy.deepcopy(val)
                except Exception:
                    try:
                        attrs[name] = copy.copy(val)
                    except Exception:
                        attrs[name] = val
        if key is None:
            self.result = ev, attrs
        else:
            if not hasattr(self, 'result') or self.result is None:
                self.result = {}
            self.result[key] = ev, attrs

    def assert_result(self, key=None, **kwds):
        assert (hasattr(self, 'result') and self.result is not None), \
            "No event recorded"

        if key is None:
            event, event_attrs = self.result
        else:
            event, event_attrs = self.result[key]

        assert isinstance(event, Event), "Emitted object is not Event instance"

        for name, val in kwds.items():
            if name == 'event':
                assert event is val, "Event objects do not match"

            elif name == 'event_class':
                assert isinstance(event, val), \
                    "Emitted object is not instance of %s" % val.__name__

            else:
                attr = event_attrs[name]
                assert (attr == val), "Event.%s != %s  (%s)" % (
                    name, str(val), str(attr))

########NEW FILE########
__FILENAME__ = test_event_emitter
from nose.tools import assert_raises, assert_equal
import unittest
import copy
import functools

from vispy.util.event import Event, EventEmitter


class BasicEvent(Event):
    pass


class TypedEvent(Event):

    def __init__(self, **kwds):
        kwds['type'] = 'typed_event'
        Event.__init__(self, **kwds)


class TestEmitters(unittest.TestCase):

    def test_emitter(self):
        """Emitter constructed with no arguments"""
        em = EventEmitter()

        # type must be specified when emitting since Event requires type
        # argument and the emitter was constructed without it.
        try:
            em()
            assert False, "Emitting event with no type should have failed."
        except TypeError:
            pass

        # See that emitted event has all of the properties we expect
        ev = self.try_emitter(em, type='test_event')
        self.assert_result(
            event=ev,
            event_class=Event,
            source=None,
            type='test_event',
            sources=[None])

    def test_emitter_source(self):
        """Emitter constructed with source argument"""
        em = EventEmitter(source=self)
        ev = self.try_emitter(em, type='test_event')
        self.assert_result(
            event=ev,
            event_class=Event,
            source=self,
            type='test_event',
            sources=[self])

        # overriding source should fail:
        try:
            ev = em(type='test_event', source=None)
            assert False, "Should not be able to specify source when emitting"
        except AttributeError:
            pass

    def test_emitter_type(self):
        """Emitter constructed with type argument"""
        em = EventEmitter(type='asdf')
        ev = self.try_emitter(em)
        self.assert_result(
            event=ev,
            event_class=Event,
            source=None,
            type='asdf',
            sources=[None])

        # overriding type is ok:
        ev = self.try_emitter(em, type='qwer')
        self.assert_result(
            event=ev,
            event_class=Event,
            source=None,
            type='qwer',
            sources=[None])

    def test_emitter_type_event_class(self):
        """Emitter constructed with event_class argument"""
        em = EventEmitter(event_class=BasicEvent)
        ev = self.try_emitter(em, type='test_event')
        self.assert_result(
            event=ev,
            event_class=BasicEvent,
            source=None,
            type='test_event',
            sources=[None])

        # specifying non-event class should fail (eventually):
        class X:

            def __init__(self, *args, **kwds):
                self.blocked = False

            def _push_source(self, s):
                pass

            def _pop_source(self):
                pass

        try:
            em = EventEmitter(event_class=X)
            ev = self.try_emitter(em, type='test_event')
            self.assert_result()  # checks event type
            assert False, \
                "Should not be able to construct emitter with non-Event class"
        except Exception:
            pass

    def test_event_kwargs(self):
        """Extra Event kwargs"""
        em = EventEmitter(type='test_event')
        em.default_args['key1'] = 'test1'
        em.connect(self.record_event)
        self.result = None
        em(key2='test2')
        self.assert_result(key1='test1', key2='test2')

    def test_prebuilt_event(self):
        """Emit pre-built event"""
        em = EventEmitter(type='test_event')
        em.default_args['key1'] = 'test1'
        em.connect(self.record_event)

        self.result = None
        ev = Event(type='my_type')
        em(ev)
        self.assert_result(event=ev, type='my_type')
        assert not hasattr(self.result[0], 'key1')

    def test_emitter_subclass(self):
        """EventEmitter subclassing"""
        class MyEmitter(EventEmitter):

            def _prepare_event(self, *args, **kwds):
                ev = super(MyEmitter, self)._prepare_event(*args, **kwds)
                ev.test_tag = 1
                return ev
        em = MyEmitter(type='test_event')
        em.connect(self.record_event)
        self.result = None
        em()
        self.assert_result(test_tag=1)

    def test_typed_event(self):
        """Emit Event class with pre-specified type"""
        em = EventEmitter(event_class=TypedEvent)
        ev = self.try_emitter(em)  # no need to specify type here
        self.assert_result(
            event=ev,
            event_class=TypedEvent,
            source=None,
            type='typed_event',
            sources=[None])

    def test_disconnect(self):
        """Emitter disconnection"""
        em = EventEmitter(type='test_event')

        def cb1(ev):
            self.result = 1

        def cb2(ev):
            self.result = 2

        em.connect((self, 'record_event'))
        em.connect(cb1)
        em.connect(cb2)
        self.result = None
        em.disconnect(cb2)
        em.disconnect(cb2)  # should pass silently
        ev = em()
        self.assert_result(event=ev)

        self.result = None
        em.disconnect((self, 'record_event'))
        ev = em()
        assert self.result == 1

        self.result = None
        em.connect(cb1)
        em.connect(cb2)
        em.connect((self, 'record_event'))
        em.disconnect()
        em()
        assert self.result is None

    def test_reconnect(self):
        """Ignore callback reconnect"""
        em = EventEmitter(type='test_event')

        def cb(ev):
            self.result += 1

        em.connect(cb)
        em.connect(cb)  # second connection should do nothing.
        self.result = 0
        em()
        assert self.result == 1

    def test_decorator_connection(self):
        """Connection by decorator"""
        em = EventEmitter(type='test_event')

        @em.connect
        def cb(ev):
            self.result = 1

        self.result = None
        em()
        assert self.result == 1

    def test_chained_emitters(self):
        """Chained emitters"""
        em1 = EventEmitter(source=None, type='test_event1')
        em2 = EventEmitter(source=self, type='test_event2')
        em1.connect(em2)
        em1.connect(self.record_event)
        self.result = None
        ev = em1()
        self.assert_result(
            event=ev,
            event_class=Event,
            source=None,
            type='test_event1',
            sources=[None])

        # sources look different from second emitter, but type is the same.
        em1.disconnect(self.record_event)
        em2.connect(self.record_event)
        self.result = None
        ev = em1()
        self.assert_result(
            event=ev,
            event_class=Event,
            source=self,
            type='test_event1',
            sources=[
                None,
                self])

    def test_emitter_error_handling(self):
        """Emitter error handling"""
        em = EventEmitter(type='test_event')
        em.print_callback_errors = False

        def cb(ev):
            raise Exception('test')

        # first callback fails; second callback still runs.
        em.connect(self.record_event)
        em.connect(cb)
        self.result = None
        ev = em()
        self.assert_result(event=ev)

        # this time we should get an exception
        self.result = None
        em.ignore_callback_errors = False
        try:
            em()
            assert False, "Emission should have raised exception"
        except Exception as err:
            if str(err) != 'test':
                raise

    def test_emission_order(self):
        """Event emission order"""
        em = EventEmitter(type='test_event')

        def cb1(ev):
            self.result = 1

        def cb2(ev):
            self.result = 2

        em.connect(cb1)
        em.connect(cb2)
        self.result = None
        em()
        assert self.result == 1, "Events emitted in wrong order"

        em.disconnect()
        em.connect(cb2)
        em.connect(cb1)
        self.result = None
        em()
        assert self.result == 2, "Events emitted in wrong order"

    def test_multiple_callbacks(self):
        """Multiple emitter callbacks"""
        em = EventEmitter(type='test_event')
        em.connect(functools.partial(self.record_event, key=1))
        em.connect(functools.partial(self.record_event, key=2))
        em.connect(functools.partial(self.record_event, key=3))
        ev = em()
        self.assert_result(key=1, event=ev, sources=[None])
        self.assert_result(key=2, event=ev, sources=[None])
        self.assert_result(key=3, event=ev, sources=[None])

    def test_symbolic_callback(self):
        """Symbolic callbacks"""
        em = EventEmitter(type='test_event')
        em.connect((self, 'record_event'))
        ev = em()
        self.assert_result(event=ev)

        # now check overriding the connected method
        def cb(ev):
            self.result = 1

        self.result = None
        orig_method = self.record_event
        try:
            self.record_event = cb
            em()
            assert self.result == 1
        finally:
            self.record_event = orig_method

    def test_source_stack_integrity(self):
        """Emitter checks source stack"""
        em = EventEmitter(type='test_event')

        def cb(ev):
            ev._sources.append('x')
        em.connect(cb)

        try:
            em()
        except RuntimeError as err:
            if str(err) != 'Event source-stack mismatch.':
                raise

        em.disconnect()

        def cb(ev):
            ev._sources = []
        em.connect(cb)

        try:
            em()
        except IndexError:
            pass

    def test_emitter_loop(self):
        """Catch emitter loops"""
        em1 = EventEmitter(type='test_event1')
        em2 = EventEmitter(type='test_event2')
        em1.ignore_callback_errors = False
        em2.ignore_callback_errors = False

        # cross-connect emitters; when we emit, an exception should be raised
        # indicating an event loop.
        em1.connect(em2)
        em2.connect(em1)
        try:
            em1()
        except RuntimeError as err:
            if str(err) != 'EventEmitter loop detected!':
                raise err

    def test_emitter_block(self):
        """EventEmitter.blocker"""
        em = EventEmitter(type='test_event')
        em.connect(self.record_event)
        self.result = None

        with em.blocker():
            em()
        assert self.result is None

        ev = em()
        self.assert_result(event=ev)

    def test_event_handling(self):
        """Event.handled"""
        em = EventEmitter(type='test_event')

        def cb1(ev):
            ev.handled = True

        def cb2(ev):
            assert ev.handled
            self.result = 1
        em.connect(cb2)
        em.connect(cb1)
        self.result = None
        em()
        assert self.result == 1

    def test_event_block(self):
        """Event.blocked"""
        em = EventEmitter(type='test_event')

        def cb1(ev):
            ev.handled = True
            self.result = 1

        def cb2(ev):
            ev.blocked = True
            self.result = 2

        em.connect(self.record_event)
        em.connect(cb1)
        self.result = None
        em()
        self.assert_result()

        em.connect(cb2)
        self.result = None
        em()
        assert self.result == 2

    def try_emitter(self, em, **kwds):
        em.connect(self.record_event)
        self.result = None
        return em(**kwds)

    def record_event(self, ev, key=None):
        # get a copy of all event attributes because these may change
        # as the event is passed around; we want to know exactly what the event
        # looked like when it reached this callback.
        names = [name for name in dir(ev) if name[0] != '_']
        attrs = {}
        for name in names:
            val = getattr(ev, name)
            if name == 'source':
                attrs[name] = val
            elif name == 'sources':
                attrs[name] = val[:]
            else:
                try:
                    attrs[name] = copy.deepcopy(val)
                except Exception:
                    try:
                        attrs[name] = copy.copy(val)
                    except Exception:
                        attrs[name] = val
        if key is None:
            self.result = ev, attrs
        else:
            if not hasattr(self, 'result') or self.result is None:
                self.result = {}
            self.result[key] = ev, attrs

    def assert_result(self, key=None, **kwds):
        assert (hasattr(self, 'result') and self.result is not None), \
            "No event recorded"

        if key is None:
            event, event_attrs = self.result
        else:
            event, event_attrs = self.result[key]

        assert isinstance(event, Event), "Emitted object is not Event instance"

        for name, val in kwds.items():
            if name == 'event':
                assert event is val, "Event objects do not match"

            elif name == 'event_class':
                assert isinstance(event, val), \
                    "Emitted object is not instance of %s" % val.__name__

            else:
                attr = event_attrs[name]
                assert (attr == val), "Event.%s != %s  (%s)" % (
                    name, str(val), str(attr))


def test_event_connect_order():
    """Test event connection order"""
    def a():
        return

    def b():
        return

    def c():
        return

    def d():
        return

    def e():
        return

    def f():
        return

    em = EventEmitter(type='test_event')
    assert_raises(ValueError, em.connect, c, before=['c', 'foo'])
    assert_raises(ValueError, em.connect, c, position='foo')
    assert_raises(TypeError, em.connect, c, ref=dict())
    em.connect(c, ref=True)
    assert_equal((c,), tuple(em.callbacks))
    em.connect(c)
    assert_equal((c,), tuple(em.callbacks))
    em.connect(d, ref=True, position='last')
    assert_equal((c, d), tuple(em.callbacks))
    em.connect(b, ref=True)  # position='first'
    assert_equal((b, c, d), tuple(em.callbacks))
    assert_raises(RuntimeError, em.connect, a, before='c', after='d')  # can't
    em.connect(a, ref=True, before=['c', 'd'])  # first possible pos == 0
    assert_equal((a, b, c, d), tuple(em.callbacks))
    em.connect(f, ref=True, after=['c', 'd'])
    assert_equal((a, b, c, d, f), tuple(em.callbacks))
    em.connect(e, ref=True, after='d', before='f')
    assert_equal(('a', 'b', 'c', 'd', 'e', 'f'), tuple(em.callback_refs))
    em.disconnect(e)
    em.connect(e, ref=True, after='a', before='f', position='last')
    assert_equal(('a', 'b', 'c', 'd', 'e', 'f'), tuple(em.callback_refs))
    em.disconnect(e)
    em.connect(e, ref='e', after='d', before='f', position='last')
    assert_equal(('a', 'b', 'c', 'd', 'e', 'f'), tuple(em.callback_refs))
    em.disconnect(e)
    em.connect(e, after='d', before='f', position='first')  # no name
    assert_equal(('a', 'b', 'c', 'd', None, 'f'), tuple(em.callback_refs))
    em.disconnect(e)
    assert_raises(ValueError, em.connect, e, ref='d')  # duplicate name
    em.connect(e, ref=True, after=[], before='f', position='last')
    assert_equal(('a', 'b', 'c', 'd', 'e', 'f'), tuple(em.callback_refs))
    assert_equal((a, b, c, d, e, f), tuple(em.callbacks))

    old_e = e

    def e():
        return

    assert_raises(ValueError, em.connect, e, ref=True)  # duplicate name
    em.connect(e)
    assert_equal((None, 'a', 'b', 'c', 'd', 'e', 'f'),
                 tuple(em.callback_refs))
    assert_equal((e, a, b, c, d, old_e, f), tuple(em.callbacks))

########NEW FILE########
__FILENAME__ = test_import
"""
Test that importing vispy subpackages do not pull
in any more vispy submodules than strictly necessary.
"""

import sys
import os
import subprocess

from nose.tools import assert_equal
from vispy.testing import assert_in, assert_not_in, requires_pyopengl

import vispy


# minimum that will be imported when importing vispy
_min_modules = ['vispy', 'vispy.util', 'vispy.ext']


def check_output(*popenargs, **kwargs):
    """ Minimal py 2.6 compatible version of subprocess.check_output()

    Py2.6 does not have check_output.
    Taken from https://gist.github.com/edufelipe/1027906
    """
    process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
    output, unused_err = process.communicate()
    retcode = process.poll()
    if retcode:
        cmd = kwargs.get("args")
        if cmd is None:
            cmd = popenargs[0]
        error = subprocess.CalledProcessError(retcode, cmd)
        error.output = output
        raise error
    return output


def loaded_vispy_modules(import_module, depth=None, all_modules=False):
    """ Import the given module in subprocess and return loaded modules

    Import a certain module in a clean subprocess and return the
    vispy modules that are subsequently loaded. The given depth
    indicates the module level (i.e. depth=1 will only yield 'vispy.app'
    but not 'vispy.app.backends').
    """

    vispy_dir = os.path.dirname(os.path.dirname(vispy.__file__))

    # Get the loaded modules in a clean interpreter
    code = "import sys, %s; print(', '.join(sys.modules))" % import_module
    res = check_output([sys.executable, '-c', code], cwd=vispy_dir)
    res = res.decode('utf-8')
    loaded_modules = [name.strip() for name in res.split(',')]
    
    if all_modules:
        return loaded_modules
    
    # Get only vispy modules at the given depth
    vispy_modules = set()
    for m in loaded_modules:
        if m.startswith('vispy') and '__future__' not in m:
            if depth:
                parts = m.split('.')
                m = '.'.join(parts[:depth])
            vispy_modules.add(m)
    
    return vispy_modules


def test_import_nothing():
    """ Not importing vispy should not import any vispy modules. """
    modnames = loaded_vispy_modules('os', 2)
    assert_equal(modnames, set())


def test_import_vispy():
    """ Importing vispy should only pull in other vispy.util submodule. """
    modnames = loaded_vispy_modules('vispy', 2)
    assert_equal(modnames, set(_min_modules))


def test_import_vispy_util():
    """ Importing vispy.util should not pull in other vispy submodules. """
    modnames = loaded_vispy_modules('vispy.util', 2)
    assert_equal(modnames, set(_min_modules))


def test_import_vispy_app1():
    """ Importing vispy.app should not pull in other vispy submodules. """
    modnames = loaded_vispy_modules('vispy.app', 2)
    assert_equal(modnames, set(_min_modules + ['vispy.app']))


def test_import_vispy_app2():
    """ Importing vispy.app should not pull in any backend toolkit. """
    allmodnames = loaded_vispy_modules('vispy.app', 2, True)
    assert_not_in('PySide', allmodnames)
    assert_not_in('PyQt4', allmodnames)
    assert_not_in('pyglet', allmodnames)
    assert_not_in('OpenGL.GLUT', allmodnames)


def test_import_vispy_gloo():
    """ Importing vispy.gloo should not pull in other vispy submodules. """
    modnames = loaded_vispy_modules('vispy.gloo', 2)
    assert_equal(modnames, set(_min_modules + ['vispy.gloo']))


def test_import_vispy_no_pyopengl():
    """ Importing vispy.gloo.gl.desktop should not import PyOpenGL. """
    allmodnames = loaded_vispy_modules('vispy.gloo.gl.desktop', 2, True)
    assert_not_in('OpenGL', allmodnames)


@requires_pyopengl()
def test_import_vispy_pyopengl():
    """ Importing vispy.gloo.gl.pyopengl should import PyOpenGL. """
    allmodnames = loaded_vispy_modules('vispy.gloo.gl.pyopengl', 2, True)
    assert_in('OpenGL', allmodnames)

########NEW FILE########
__FILENAME__ = test_key
from nose.tools import assert_raises, assert_true, assert_equal

from vispy.util.keys import Key, ENTER


def test_key():
    """Test basic key functionality"""
    def bad():
        return (ENTER == dict())
    assert_raises(ValueError, bad)
    assert_true(not (ENTER == None))  # noqa
    assert_equal('Return', ENTER)
    print(ENTER.name)
    print(ENTER)  # __repr__
    assert_equal(Key('1'), 49)  # ASCII code

########NEW FILE########
__FILENAME__ = test_logging
from nose.tools import assert_equal
import logging

from vispy.util import logger, use_log_level
from vispy.testing import assert_in, assert_not_in


def test_logging():
    """Test logging context manager"""
    ll = logger.level
    with use_log_level('warning'):
        assert_equal(logger.level, logging.WARN)
    assert_equal(logger.level, ll)
    with use_log_level('debug'):
        assert_equal(logger.level, logging.DEBUG)
    assert_equal(logger.level, ll)


def test_debug_logging():
    """Test advanced debugging logging"""
    with use_log_level('debug', 'Selected', True) as l:
        logger.debug('Selected foo')
    assert_equal(len(l), 1)
    assert_in('unknown', l[0])  # can't really parse this location

    with use_log_level('debug', record=True) as l:
        logger.debug('foo')
    assert_equal(len(l), 1)
    assert_in('unknown', l[0])

    with use_log_level('debug', 'foo', True) as l:
        logger.debug('bar')
    assert_equal(len(l), 0)

    with use_log_level('info', record=True) as l:
        logger.debug('foo')
        logger.info('bar')
    assert_equal(len(l), 1)
    assert_not_in('unknown', l[0])

########NEW FILE########
__FILENAME__ = test_transforms
import numpy as np
from nose.tools import assert_equal
from numpy.testing import assert_allclose

from vispy.util.transforms import (translate, scale, xrotate, yrotate,
                                   zrotate, rotate, ortho, frustum,
                                   perspective)


def test_transforms():
    """Test basic transforms"""
    xfm = np.random.randn(4, 4).astype(np.float32)

    for rot in [xrotate, yrotate, zrotate]:
        new_xfm = rot(rot(xfm, 90), -90)
        assert_allclose(xfm, new_xfm)

    new_xfm = rotate(rotate(xfm, 90, 1, 0, 0), 90, -1, 0, 0)
    assert_allclose(xfm, new_xfm)

    new_xfm = translate(translate(xfm, 1, -1), 1, -1, 1)
    assert_allclose(xfm, new_xfm)

    new_xfm = scale(scale(xfm, 1, 2, 3), 1, 1. / 2., 1. / 3.)
    assert_allclose(xfm, new_xfm)

    # These could be more complex...
    xfm = ortho(-1, 1, -1, 1, -1, 1)
    assert_equal(xfm.shape, (4, 4))

    xfm = frustum(-1, 1, -1, 1, -1, 1)
    assert_equal(xfm.shape, (4, 4))

    xfm = perspective(1, 1, -1, 1)
    assert_equal(xfm.shape, (4, 4))

########NEW FILE########
__FILENAME__ = test_vispy
""" Tests to ensure that base vispy namespace functions correctly,
including configuration options.
"""

########NEW FILE########
__FILENAME__ = transforms
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Very simple transformation library that is needed for some examples.

Notes
-----

Functions that take a matrix as input generally operate on that matrix in
place.
"""

# Note: we use functions (e.g. sin) from math module because they're faster

import math
import numpy as np


def translate(M, x, y=None, z=None):
    """Translate by an offset (x, y, z) .

    Parameters
    ----------
    M : array
        Original transformation (4x4).
    x : float
        X coordinate of a translation vector.
    y : float | None
        Y coordinate of translation vector. If None, `x` will be used.
    z : float | None
        Z coordinate of translation vector. If None, `x` will be used.

    Returns
    -------
    M : array
        Updated transformation (4x4). Note that this function operates
        in-place.
    """
    y = x if y is None else y
    z = x if z is None else z
    T = np.array([[1.0, 0.0, 0.0, x],
                  [0.0, 1.0, 0.0, y],
                  [0.0, 0.0, 1.0, z],
                  [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype).T
    M[...] = np.dot(M, T)
    return M


def scale(M, x, y=None, z=None):
    """Non-uniform scaling along the x, y, and z axes

    Parameters
    ----------
    M : array
        Original transformation (4x4).
    x : float
        X coordinate of the translation vector.
    y : float | None
        Y coordinate of the translation vector. If None, `x` will be used.
    z : float | None
        Z coordinate of the translation vector. If None, `x` will be used.

    Returns
    -------
    M : array
        Updated transformation (4x4). Note that this function operates
        in-place.
    """
    y = x if y is None else y
    z = x if z is None else z
    S = np.array([[x, 0.0, 0.0, 0.0],
                  [0.0, y, 0.0, 0.0],
                  [0.0, 0.0, z, 0.0],
                  [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype).T
    M[...] = np.dot(M, S)
    return M


def xrotate(M, theta):
    """Rotate about the X axis

    Parameters
    ----------
    M : array
        Original transformation (4x4).
    theta : float
        Specifies the angle of rotation, in degrees.

    Returns
    -------
    M : array
        Updated transformation (4x4). Note that this function operates
        in-place.
    """
    t = math.pi * theta / 180.
    cosT = math.cos(t)
    sinT = math.sin(t)
    R = np.array([[1.0, 0.0, 0.0, 0.0],
                  [0.0, cosT, -sinT, 0.0],
                  [0.0, sinT, cosT, 0.0],
                  [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype)
    M[...] = np.dot(M, R)
    return M


def yrotate(M, theta):
    """Rotate about the Y axis

    Parameters
    ----------
    M : array
        Original transformation (4x4).
    theta : float
        Specifies the angle of rotation, in degrees.

    Returns
    -------
    M : array
        Updated transformation (4x4). Note that this function operates
        in-place.
    """
    t = math.pi * theta / 180
    cosT = math.cos(t)
    sinT = math.sin(t)
    R = np.array(
        [[cosT, 0.0, sinT, 0.0],
         [0.0, 1.0, 0.0, 0.0],
         [-sinT, 0.0, cosT, 0.0],
         [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype)
    M[...] = np.dot(M, R)
    return M


def zrotate(M, theta):
    """Rotate about the Z axis

    Parameters
    ----------
    M : array
        Original transformation (4x4).
    theta : float
        Specifies the angle of rotation, in degrees.

    Returns
    -------
    M : array
        Updated transformation (4x4). Note that this function operates
        in-place.
    """
    t = math.pi * theta / 180
    cosT = math.cos(t)
    sinT = math.sin(t)
    R = np.array(
        [[cosT, -sinT, 0.0, 0.0],
         [sinT, cosT, 0.0, 0.0],
         [0.0, 0.0, 1.0, 0.0],
         [0.0, 0.0, 0.0, 1.0]], dtype=M.dtype)
    M[...] = np.dot(M, R)
    return M


def rotate(M, angle, x, y, z, point=None):
    """Rotation about a vector

    Parameters
    ----------
    M : array
        Original transformation (4x4).
    angle : float
        Specifies the angle of rotation, in degrees.
    x : float
        X coordinate of the angle of rotation vector.
    y : float | None
        Y coordinate of the angle of rotation vector.
    z : float | None
        Z coordinate of the angle of rotation vector.

    Returns
    -------
    M : array
        Updated transformation (4x4). Note that this function operates
        in-place.
    """
    angle = math.pi * angle / 180
    c, s = math.cos(angle), math.sin(angle)
    n = math.sqrt(x * x + y * y + z * z)
    x /= n
    y /= n
    z /= n
    cx, cy, cz = (1 - c) * x, (1 - c) * y, (1 - c) * z
    R = np.array([[cx * x + c, cy * x - z * s, cz * x + y * s, 0],
                  [cx * y + z * s, cy * y + c, cz * y - x * s, 0],
                  [cx * z - y * s, cy * z + x * s, cz * z + c, 0],
                  [0, 0, 0, 1]], dtype=M.dtype).T
    M[...] = np.dot(M, R)
    return M


def ortho(left, right, bottom, top, znear, zfar):
    """Create orthographic projection matrix

    Parameters
    ----------
    left : float
        Left coordinate of the field of view.
    right : float
        Right coordinate of the field of view.
    bottom : float
        Bottom coordinate of the field of view.
    top : float
        Top coordinate of the field of view.
    znear : float
        Near coordinate of the field of view.
    zfar : float
        Far coordinate of the field of view.

    Returns
    -------
    M : array
        Orthographic projection matrix (4x4).
    """
    assert(right != left)
    assert(bottom != top)
    assert(znear != zfar)

    M = np.zeros((4, 4), dtype=np.float32)
    M[0, 0] = +2.0 / (right - left)
    M[3, 0] = -(right + left) / float(right - left)
    M[1, 1] = +2.0 / (top - bottom)
    M[3, 1] = -(top + bottom) / float(top - bottom)
    M[2, 2] = -2.0 / (zfar - znear)
    M[3, 2] = -(zfar + znear) / float(zfar - znear)
    M[3, 3] = 1.0
    return M


def frustum(left, right, bottom, top, znear, zfar):
    """Create view frustum

    Parameters
    ----------
    left : float
        Left coordinate of the field of view.
    right : float
        Right coordinate of the field of view.
    bottom : float
        Bottom coordinate of the field of view.
    top : float
        Top coordinate of the field of view.
    znear : float
        Near coordinate of the field of view.
    zfar : float
        Far coordinate of the field of view.

    Returns
    -------
    M : array
        View frustum matrix (4x4).
    """
    assert(right != left)
    assert(bottom != top)
    assert(znear != zfar)

    M = np.zeros((4, 4), dtype=np.float32)
    M[0, 0] = +2.0 * znear / (right - left)
    M[2, 0] = (right + left) / (right - left)
    M[1, 1] = +2.0 * znear / (top - bottom)
    M[3, 1] = (top + bottom) / (top - bottom)
    M[2, 2] = -(zfar + znear) / (zfar - znear)
    M[3, 2] = -2.0 * znear * zfar / (zfar - znear)
    M[2, 3] = -1.0
    return M


def perspective(fovy, aspect, znear, zfar):
    """Create perspective projection matrix

    Parameters
    ----------
    fovy : float
        The field of view along the y axis.
    aspect : float
        Aspect ratio of the view.
    znear : float
        Near coordinate of the field of view.
    zfar : float
        Far coordinate of the field of view.

    Returns
    -------
    M : array
        Perspective projection matrix (4x4).
    """
    assert(znear != zfar)
    h = math.tan(fovy / 360.0 * math.pi) * znear
    w = h * aspect
    return frustum(-w, w, -h, h, znear, zfar)

########NEW FILE########
__FILENAME__ = _config
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""Vispy configuration functions
"""

import os
from os import path as op
import json
import sys
import platform
import getopt
import traceback
import tempfile
import atexit
from shutil import rmtree

from .event import EmitterGroup, EventEmitter, Event
from ..ext.six import string_types
from ._logging import logger, set_log_level, use_log_level


class _TempDir(str):
    """Class for creating and auto-destroying temp dir

    This is designed to be used with testing modules.

    We cannot simply use __del__() method for cleanup here because the rmtree
    function may be cleaned up before this object, so we use the atexit module
    instead.
    """
    def __new__(self):
        new = str.__new__(self, tempfile.mkdtemp())
        return new

    def __init__(self):
        self._path = self.__str__()
        atexit.register(self.cleanup)

    def cleanup(self):
        rmtree(self._path, ignore_errors=True)


###############################################################################
# CONFIG

# Adapted from pyzolib/paths.py:
# https://bitbucket.org/pyzo/pyzolib/src/tip/paths.py
def _get_vispy_app_dir():
    """Helper to get the default directory for storing vispy data"""
    # Define default user directory
    user_dir = os.path.expanduser('~')

    # Get system app data dir
    path = None
    if sys.platform.startswith('win'):
        path1, path2 = os.getenv('LOCALAPPDATA'), os.getenv('APPDATA')
        path = path1 or path2
    elif sys.platform.startswith('darwin'):
        path = os.path.join(user_dir, 'Library', 'Application Support')
    # On Linux and as fallback
    if not (path and os.path.isdir(path)):
        path = user_dir

    # Maybe we should store things local to the executable (in case of a
    # portable distro or a frozen application that wants to be portable)
    prefix = sys.prefix
    if getattr(sys, 'frozen', None):  # See application_dir() function
        prefix = os.path.abspath(os.path.dirname(sys.path[0]))
    for reldir in ('settings', '../settings'):
        localpath = os.path.abspath(os.path.join(prefix, reldir))
        if os.path.isdir(localpath):
            try:
                open(os.path.join(localpath, 'test.write'), 'wb').close()
                os.remove(os.path.join(localpath, 'test.write'))
            except IOError:
                pass  # We cannot write in this directory
            else:
                path = localpath
                break

    # Get path specific for this app
    appname = '.vispy' if path == user_dir else 'vispy'
    path = os.path.join(path, appname)
    return path


class ConfigEvent(Event):

    """ Event indicating a configuration change.

    This class has a 'changes' attribute which is a dict of all name:value
    pairs that have changed in the configuration.
    """

    def __init__(self, changes):
        Event.__init__(self, type='config_change')
        self.changes = changes


class Config(object):

    """ Container for global settings used application-wide in vispy.

    Events:
    -------
    Config.events.changed - Emits ConfigEvent whenever the configuration
    changes.
    """

    def __init__(self, **kwargs):
        self.events = EmitterGroup(source=self)
        self.events['changed'] = EventEmitter(
            event_class=ConfigEvent,
            source=self)
        self._config = {}
        self.update(**kwargs)
        self._known_keys = get_config_keys()

    def __getitem__(self, item):
        return self._config[item]

    def __setitem__(self, item, val):
        self._check_key_val(item, val)
        self._config[item] = val
        # inform any listeners that a configuration option has changed
        self.events.changed(changes={item: val})

    def _check_key_val(self, key, val):
        # check values against acceptable ones
        known_keys = get_config_keys()
        if key not in known_keys:
            raise KeyError('key "%s" not in known keys: "%s"'
                           % (key, known_keys))
        if not isinstance(val, (string_types, bool)):
            raise TypeError('Value for key "%s" must be str or bool, not %s'
                            % (key, type(val)))

    def update(self, **kwargs):
        for key, val in kwargs.items():
            self._check_key_val(key, val)
        self._config.update(kwargs)
        self.events.changed(changes=kwargs)

    def __repr__(self):
        return repr(self._config)


def get_config_keys():
    """The config keys known by vispy

    Returns
    -------
    keys : tuple
        List of known config keys.
    """
    return ('data_path', 'default_backend', 'gl_debug', 'logging_level',
            'qt_lib')


def _get_config_fname():
    """Helper for the vispy config file"""
    directory = _get_vispy_app_dir()
    if directory is None:
        return None
    fname = op.join(directory, 'vispy.json')
    if os.environ.get('_VISPY_CONFIG_TESTING', None) is not None:
        fname = op.join(_TempDir(), 'vispy.json')
    return fname


def _load_config():
    """Helper to load prefs from ~/.vispy/vispy.json"""
    fname = _get_config_fname()
    if fname is None or not op.isfile(fname):
        return dict()
    with open(fname, 'r') as fid:
        config = json.load(fid)
    return config


def save_config(**kwargs):
    """Save configuration keys to vispy config file

    Parameters
    ----------
    **kwargs : keyword arguments
        Key/value pairs to save to the config file.
    """
    if kwargs == {}:
        kwargs = config._config
    current_config = _load_config()
    current_config.update(**kwargs)
    # write to disk
    fname = _get_config_fname()
    if fname is None:
        raise RuntimeError('config filename could not be determined')
    if not op.isdir(op.dirname(fname)):
        os.mkdir(op.dirname(fname))
    with open(fname, 'w') as fid:
        json.dump(current_config, fid, sort_keys=True, indent=0)


_data_path = _get_vispy_app_dir()
if _data_path is not None:
    _data_path = op.join(_data_path, 'data')
config = Config(default_backend='qt', qt_lib='any',
                gl_debug=False, logging_level='info',
                data_path=_data_path)
try:
    config.update(**_load_config())
except Exception as err:
    raise Exception('Error while reading vispy config file "%s":\n  %s' %
                    (_get_config_fname(), err.message))
set_log_level(config['logging_level'])


def set_data_dir(directory=None, create=False, save=False):
    """Set vispy data download directory"""
    if directory is None:
        directory = _data_path
        if _data_path is None:
            raise IOError('default path cannot be determined, please '
                          'set it manually (directory != None)')
    if not op.isdir(directory):
        if not create:
            raise IOError('directory "%s" does not exist, perhaps try '
                          'create=True to create it?' % directory)
        os.mkdir(directory)
    config.update(data_path=directory)
    if save:
        save_config(data_path=directory)


###############################################################################
# System information and parsing

def _parse_command_line_arguments():
    """ Transform vispy specific command line args to vispy config.
    Put into a function so that any variables dont leak in the vispy namespace.
    """
    # Get command line args for vispy
    argnames = ['vispy-backend', 'vispy-gl-debug']
    try:
        opts, args = getopt.getopt(sys.argv[1:], '', argnames)
    except getopt.GetoptError:
        opts = []
    # Use them to set the config values
    for o, a in opts:
        if o.startswith('--vispy'):
            if o == '--vispy-backend':
                config['default_backend'] = a
                logger.info('backend', a)
            elif o == '--vispy-gl-debug':
                config['gl_debug'] = True
            else:
                logger.warning("Unsupported vispy flag: %s" % o)


def sys_info(fname=None, overwrite=False):
    """Get relevant system and debugging information

    Parameters
    ----------
    fname : str | None
        Filename to dump info to. Use None to simply print.
    overwrite : bool
        If True, overwrite file (if it exists).

    Returns
    -------
    out : str
        The system information as a string.
    """
    if fname is not None and op.isfile(fname) and not overwrite:
        raise IOError('file exists, use overwrite=True to overwrite')

    out = ''
    try:
        # Nest all imports here to avoid any circular imports
        from ..app import default_app, Canvas
        from ..app.backends import BACKEND_NAMES
        from ..gloo import gl
        from ..testing import has_backend
        # get default app
        with use_log_level('warning'):
            default_app.use()  # suppress unnecessary messages
        out += 'Platform: %s\n' % platform.platform()
        out += 'Python:   %s\n' % str(sys.version).replace('\n', ' ')
        out += 'Backend:  %s\n' % default_app.backend_name
        for backend in BACKEND_NAMES:
            which = has_backend(backend, out=['which'])[1]
            out += '{0:<9} {1}\n'.format(backend + ':', which)
        out += '\n'
        # We need an OpenGL context to get GL info
        if 'glut' in default_app.backend_name.lower():
            # glut causes problems
            out += 'OpenGL information omitted for glut backend\n'
        else:
            canvas = Canvas('Test', (10, 10), show=False, app=default_app)
            canvas._backend._vispy_set_current()
            out += 'GL version:  %s\n' % gl.glGetParameter(gl.GL_VERSION)
            x_ = gl.GL_MAX_TEXTURE_SIZE
            out += 'MAX_TEXTURE_SIZE: %d\n' % gl.glGetParameter(x_)
            out += 'Extensions: %s\n' % gl.glGetParameter(gl.GL_EXTENSIONS)
            canvas.close()
    except Exception:  # don't stop printing info
        out += '\nInfo-gathering error:\n%s' % traceback.format_exc()
        pass
    if fname is not None:
        with open(fname, 'w') as fid:
            fid.write(out)
    return out

########NEW FILE########
__FILENAME__ = _data
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""Data downloading and reading functions
"""

from math import log
import os
from os import path as op
import sys
import shutil

from ..ext.six.moves import urllib
from ._config import config


###############################################################################
# Vispy data directory

def get_data_file(fname, directory=None, force_download=False):
    """Get a standard vispy demo data file

    Parameters
    ----------
    fname : str
        The filename on the remote ``demo-data`` repository to download,
        e.g. ``'molecular_viewer/micelle.npy'``. These correspond to paths
        on ``https://github.com/vispy/demo-data/``.
    directory : str | None
        Directory to use to save the file. By default, the vispy
        configuration directory is used.
    force_download : bool
        If True, the file will be downloaded even if a local copy exists
        (and this copy will be overwritten).

    Returns
    -------
    fname : str
        The path to the file on the local system.
    """
    _url_root = 'https://github.com/vispy/demo-data/raw/master/'
    url = _url_root + fname
    if directory is None:
        directory = config['data_path']
        if directory is None:
            raise ValueError('config["data_path"] is not defined, '
                             'so directory must be supplied')

    fname = op.join(directory, op.normcase(fname))  # convert to native
    if op.isfile(fname) and not force_download:  # we're done
        return fname
    if not op.isdir(op.dirname(fname)):
        os.makedirs(op.abspath(op.dirname(fname)))
    # let's go get the file
    _fetch_file(url, fname)
    return fname


###############################################################################
# File downloading (most adapted from mne-python)

class ProgressBar(object):
    """Class for generating a command-line progressbar

    Parameters
    ----------
    max_value : int
        Maximum value of process (e.g. number of samples to process, bytes to
        download, etc.).
    initial_value : int
        Initial value of process, useful when resuming process from a specific
        value, defaults to 0.
    mesg : str
        Message to include at end of progress bar.
    max_chars : int
        Number of characters to use for progress bar (be sure to save some room
        for the message and % complete as well).
    progress_character : char
        Character in the progress bar that indicates the portion completed.
    spinner : bool
        Show a spinner.  Useful for long-running processes that may not
        increment the progress bar very often.  This provides the user with
        feedback that the progress has not stalled.
    """
    spinner_symbols = ['|', '/', '-', '\\']
    template = '\r[{0}{1}] {2:.05f} {3} {4}   '

    def __init__(self, max_value, initial_value=0, mesg='', max_chars=40,
                 progress_character='.', spinner=False):
        self.cur_value = initial_value
        self.max_value = float(max_value)
        self.mesg = mesg
        self.max_chars = max_chars
        self.progress_character = progress_character
        self.spinner = spinner
        self.spinner_index = 0
        self.n_spinner = len(self.spinner_symbols)

    def update(self, cur_value, mesg=None):
        """Update progressbar with current value of process

        Parameters
        ----------
        cur_value : number
            Current value of process.  Should be <= max_value (but this is not
            enforced).  The percent of the progressbar will be computed as
            (cur_value / max_value) * 100
        mesg : str
            Message to display to the right of the progressbar.  If None, the
            last message provided will be used.  To clear the current message,
            pass a null string, ''.
        """
        # Ensure floating-point division so we can get fractions of a percent
        # for the progressbar.
        self.cur_value = cur_value
        progress = float(self.cur_value) / self.max_value
        num_chars = int(progress * self.max_chars)
        num_left = self.max_chars - num_chars

        # Update the message
        if mesg is not None:
            self.mesg = mesg

        # The \r tells the cursor to return to the beginning of the line rather
        # than starting a new line.  This allows us to have a progressbar-style
        # display in the console window.
        bar = self.template.format(self.progress_character * num_chars,
                                   ' ' * num_left,
                                   progress * 100,
                                   self.spinner_symbols[self.spinner_index],
                                   self.mesg)
        sys.stdout.write(bar)
        # Increament the spinner
        if self.spinner:
            self.spinner_index = (self.spinner_index + 1) % self.n_spinner

        # Force a flush because sometimes when using bash scripts and pipes,
        # the output is not printed until after the program exits.
        sys.stdout.flush()

    def update_with_increment_value(self, increment_value, mesg=None):
        """Update progressbar with the value of the increment instead of the
        current value of process as in update()

        Parameters
        ----------
        increment_value : int
            Value of the increment of process.  The percent of the progressbar
            will be computed as
            (self.cur_value + increment_value / max_value) * 100
        mesg : str
            Message to display to the right of the progressbar.  If None, the
            last message provided will be used.  To clear the current message,
            pass a null string, ''.
        """
        self.cur_value += increment_value
        self.update(self.cur_value, mesg)


def _chunk_read(response, local_file, chunk_size=65536, initial_size=0):
    """Download a file chunk by chunk and show advancement

    Can also be used when resuming downloads over http.

    Parameters
    ----------
    response: urllib.response.addinfourl
        Response to the download request in order to get file size.
    local_file: file
        Hard disk file where data should be written.
    chunk_size: integer, optional
        Size of downloaded chunks. Default: 8192
    initial_size: int, optional
        If resuming, indicate the initial size of the file.
    """
    # Adapted from NISL:
    # https://github.com/nisl/tutorial/blob/master/nisl/datasets.py

    bytes_so_far = initial_size
    # Returns only amount left to download when resuming, not the size of the
    # entire file
    total_size = int(response.headers['Content-Length'].strip())
    total_size += initial_size

    progress = ProgressBar(total_size, initial_value=bytes_so_far,
                           max_chars=40, spinner=True, mesg='downloading')
    while True:
        chunk = response.read(chunk_size)
        bytes_so_far += len(chunk)
        if not chunk:
            sys.stderr.write('\n')
            break
        _chunk_write(chunk, local_file, progress)


def _chunk_write(chunk, local_file, progress):
    """Write a chunk to file and update the progress bar"""
    local_file.write(chunk)
    progress.update_with_increment_value(len(chunk))


def _fetch_file(url, file_name, print_destination=True):
    """Load requested file, downloading it if needed or requested

    Parameters
    ----------
    url: string
        The url of file to be downloaded.
    file_name: string
        Name, along with the path, of where downloaded file will be saved.
    print_destination: bool, optional
        If true, destination of where file was saved will be printed after
        download finishes.
    resume: bool, optional
        If true, try to resume partially downloaded files.
    """
    # Adapted from NISL:
    # https://github.com/nisl/tutorial/blob/master/nisl/datasets.py

    temp_file_name = file_name + ".part"
    local_file = None
    initial_size = 0
    try:
        # Checking file size and displaying it alongside the download url
        u = urllib.request.urlopen(url)
        file_size = int(u.headers['Content-Length'].strip())
        print('Downloading data from %s (%s)' % (url, sizeof_fmt(file_size)))
        # Downloading data (can be extended to resume if need be)
        local_file = open(temp_file_name, "wb")
        data = urllib.request.urlopen(url)
        _chunk_read(data, local_file, initial_size=initial_size)
        # temp file must be closed prior to the move
        if not local_file.closed:
            local_file.close()
        shutil.move(temp_file_name, file_name)
        if print_destination is True:
            sys.stdout.write('File saved as %s.\n' % file_name)
    except Exception as e:
        raise RuntimeError('Error while fetching file %s.\n'
                           'Dataset fetching aborted (%s)' % (url, e))
    finally:
        if local_file is not None:
            if not local_file.closed:
                local_file.close()


def sizeof_fmt(num):
    """Turn number of bytes into human-readable str"""
    units = ['bytes', 'kB', 'MB', 'GB', 'TB', 'PB']
    decimals = [0, 0, 1, 2, 2, 2]
    """Human friendly file size"""
    if num > 1:
        exponent = min(int(log(num, 1024)), len(units) - 1)
        quotient = float(num) / 1024 ** exponent
        unit = units[exponent]
        num_decimals = decimals[exponent]
        format_string = '{0:.%sf} {1}' % (num_decimals)
        return format_string.format(quotient, unit)
    return '0 bytes' if num == 0 else '1 byte'

########NEW FILE########
__FILENAME__ = _geom
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""Miscellaneous functions
"""

import numpy as np


###############################################################################
# These fast normal calculation routines are adapted from mne-python

def _fast_cross_3d(x, y):
    """Compute cross product between list of 3D vectors

    Much faster than np.cross() when the number of cross products
    becomes large (>500). This is because np.cross() methods become
    less memory efficient at this stage.

    Parameters
    ----------
    x : array
        Input array 1.
    y : array
        Input array 2.

    Returns
    -------
    z : array
        Cross product of x and y.

    Notes
    -----
    x and y must both be 2D row vectors. One must have length 1, or both
    lengths must match.
    """
    assert x.ndim == 2
    assert y.ndim == 2
    assert x.shape[1] == 3
    assert y.shape[1] == 3
    assert (x.shape[0] == 1 or y.shape[0] == 1) or x.shape[0] == y.shape[0]
    if max([x.shape[0], y.shape[0]]) >= 500:
        return np.c_[x[:, 1] * y[:, 2] - x[:, 2] * y[:, 1],
                     x[:, 2] * y[:, 0] - x[:, 0] * y[:, 2],
                     x[:, 0] * y[:, 1] - x[:, 1] * y[:, 0]]
    else:
        return np.cross(x, y)


def _calculate_normals(rr, tris):
    """Efficiently compute vertex normals for triangulated surface"""
    # ensure highest precision for our summation/vectorization "trick"
    rr = rr.astype(np.float64)
    # first, compute triangle normals
    r1 = rr[tris[:, 0], :]
    r2 = rr[tris[:, 1], :]
    r3 = rr[tris[:, 2], :]
    tri_nn = _fast_cross_3d((r2 - r1), (r3 - r1))

    #   Triangle normals and areas
    size = np.sqrt(np.sum(tri_nn * tri_nn, axis=1))
    size[size == 0] = 1.0  # prevent ugly divide-by-zero
    tri_nn /= size[:, np.newaxis]

    npts = len(rr)

    # the following code replaces this, but is faster (vectorized):
    #
    # for p, verts in enumerate(tris):
    #     nn[verts, :] += tri_nn[p, :]
    #
    nn = np.zeros((npts, 3))
    for verts in tris.T:  # note this only loops 3x (number of verts per tri)
        for idx in range(3):  # x, y, z
            nn[:, idx] += np.bincount(verts, tri_nn[:, idx], minlength=npts)
    size = np.sqrt(np.sum(nn * nn, axis=1))
    size[size == 0] = 1.0  # prevent ugly divide-by-zero
    nn /= size[:, np.newaxis]
    return nn

########NEW FILE########
__FILENAME__ = _logging
# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

import logging
import sys
import inspect
import re

from ..ext.six import string_types


###############################################################################
# LOGGING (some adapted from mne-python)

def _get_vispy_caller():
    """Helper to get vispy calling function from the stack"""
    records = inspect.stack()
    # first few records are vispy-based logging calls
    for record in records[5:]:
        module = record[0].f_globals['__name__']
        if module.startswith('vispy'):
            line = str(record[0].f_lineno)
            func = record[3]
            caller = "{0}:{1}({2}): ".format(module, func, line)
            return caller
    return 'unknown'


# class _WrapStdOut(object):
#     """Class to work around how doctest captures stdout"""
#     def __getattr__(self, name):
#         # Even more ridiculous than this class, this must be sys.stdout (not
#         # just stdout) in order for this to work (tested on OSX and Linux)
#         return getattr(sys.stdout, name)


class _VispyFormatter(logging.Formatter):
    """Formatter that optionally prepends caller"""
    def __init__(self):
        logging.Formatter.__init__(self, '%(levelname)s: %(message)s')
        self._vispy_prepend_caller = False

    def _vispy_set_prepend(self, prepend):
        self._vispy_prepend_caller = prepend

    def format(self, record):
        out = logging.Formatter.format(self, record)
        if self._vispy_prepend_caller:
            out = _get_vispy_caller() + out
        return out


class _VispyStreamHandler(logging.StreamHandler):
    """Stream handler allowing matching and recording

    This handler has two useful optional additions:

        1. Recording emitted messages.
        2. Performing regexp substring matching.

    Prepending of traceback information is done in _VispyFormatter.
    """
    def __init__(self):
        #logging.StreamHandler.__init__(self, _WrapStdOut())
        logging.StreamHandler.__init__(self, sys.stdout)
        self._vispy_formatter = _lf
        self.setFormatter(self._vispy_formatter)
        self._vispy_match = None
        self._vispy_emit_list = list()
        self._vispy_set_emit_record(False)
        self._vispy_set_match(None)

    def _vispy_emit_match_andor_record(self, record):
        """Log message emitter that optionally matches and/or records"""
        test = record.getMessage()
        match = self._vispy_match
        if match is None or len(re.findall(match, test)) > 0:
            if self._vispy_emit_record:
                fmt_rec = self._vispy_formatter.format(record)
                self._vispy_emit_list.append(fmt_rec)
            return logging.StreamHandler.emit(self, record)

    def _vispy_emit(self, record):
        """Log message emitter that wraps directly to the standard method"""
        return logging.StreamHandler.emit(self, record)

    def _vispy_set_match(self, match):
        old_match = self._vispy_match
        self._vispy_match = match
        # Triage here to avoid a bunch of if's later (more efficient)
        if match is not None or self._vispy_emit_record:
            self.emit = self._vispy_emit_match_andor_record
        else:
            self.emit = self._vispy_emit
        return old_match

    def _vispy_set_emit_record(self, record):
        self._vispy_emit_record = record
        match = self._vispy_match
        # Triage here to avoid a bunch of if's later (more efficient)
        if match is not None or self._vispy_emit_record:
            self.emit = self._vispy_emit_match_andor_record
        else:
            self.emit = self._vispy_emit

    def _vispy_reset_list(self):
        self._vispy_emit_list = list()


logger = logging.getLogger('vispy')
_lf = _VispyFormatter()
_lh = _VispyStreamHandler()  # needs _lf to exist
logger.addHandler(_lh)

logging_types = dict(debug=logging.DEBUG, info=logging.INFO,
                     warning=logging.WARNING, error=logging.ERROR,
                     critical=logging.CRITICAL)


def set_log_level(verbose, match=None, return_old=False):
    """Convenience function for setting the logging level

    Parameters
    ----------
    verbose : bool, str, int, or None
        The verbosity of messages to print. If a str, it can be either DEBUG,
        INFO, WARNING, ERROR, or CRITICAL. Note that these are for
        convenience and are equivalent to passing in logging.DEBUG, etc.
        For bool, True is the same as 'INFO', False is the same as 'WARNING'.
    match : str | None
        String to match. Only those messages that both contain a substring
        that regexp matches ``'match'`` (and the ``verbose`` level) will be
        displayed.
    return_old_level : bool
        If True, return the old verbosity level and old match.

    Notes
    -----
    If ``verbose=='debug'``, then the ``vispy`` method emitting the log
    message will be prepended to each log message, which is useful for
    debugging. If ``verbose=='debug'`` or ``match is not None``, then a
    small performance overhead is added. Thus it is suggested to only use
    these options when performance is not crucial.

    See also
    --------
    vispy.util.use_log_level
    """
    # This method is responsible for setting properties of the handler and
    # formatter such that proper messages (possibly with the vispy caller
    # prepended) are displayed. Storing log messages is only available
    # via the context handler (use_log_level), so that configuration is
    # done by the context handler itself.
    if isinstance(verbose, bool):
        verbose = 'info' if verbose else 'warning'
    if isinstance(verbose, string_types):
        verbose = verbose.lower()
        if verbose not in logging_types:
            raise ValueError('verbose must be of a valid type')
        verbose = logging_types[verbose]
    else:
        raise TypeError('verbose must be a bool or string')
    logger = logging.getLogger('vispy')
    old_verbose = logger.level
    old_match = _lh._vispy_set_match(match)
    logger.setLevel(verbose)
    if verbose <= logging.DEBUG:
        _lf._vispy_set_prepend(True)
    else:
        _lf._vispy_set_prepend(False)
    out = None
    if return_old:
        out = (old_verbose, old_match)
    return out


class use_log_level(object):
    """Context manager that temporarily sets logging level

    Parameters
    ----------
    level : str
        See ``set_log_level`` for options.
    record : bool
        If True, the context manager will keep a record of the logging
        messages generated by vispy. Otherwise, an empty list will
        be returned.

    Returns
    -------
    records : list
        As a context manager, an empty list or the list of logging messages
        will be returned (depending on the input ``record``).
    """
    # This method mostly wraps to set_log_level, but also takes
    # care of enabling/disabling message recording in the formatter.
    def __init__(self, level, match=None, record=False):
        self._new_level = level
        self._new_match = match
        self._record = record
        if match is not None and not isinstance(match, string_types):
            raise TypeError('match must be None or str')

    def __enter__(self):
        # set the log level
        old_level, old_match = set_log_level(self._new_level,
                                             self._new_match, return_old=True)
        for key, value in logging_types.items():
            if value == old_level:
                old_level = key
        self._old_level = old_level
        self._old_match = old_match
        # set handler to record, if appropriate
        _lh._vispy_reset_list()
        if self._record:
            _lh._vispy_set_emit_record(True)
            return _lh._vispy_emit_list
        else:
            return list()

    def __exit__(self, type, value, traceback):
        # reset log level
        set_log_level(self._old_level, self._old_match)
        # reset handler
        if self._record:
            _lh._vispy_set_emit_record(False)

########NEW FILE########
__FILENAME__ = vispy.proxy
# -*- coding: utf-8 -*-
# Copyright (c) 2013, Almar Klein
# (new) BSD License.

"""
This module provides an easy way to enable importing a package event
if it's not on sys.path. The main use case is to import a package 
from its developmment repository without having to install it.

This module is sort of like a symlink for Python modules.

To install: 
  1) Copy this file to a directory that is on the PYTHONPATH
  2) Rename the file to "yourpackage.py".

If the real package is in "yourpackage/yourpackage" relative to this file, 
you're done. Otherwise modify PARENT_DIR_OF_MODULE.

""" 

import os
import sys

# Determine directory and package name
THIS_DIR = os.path.abspath(os.path.dirname(__file__))
MODULE_NAME = __name__

# Override if necessary
PARENT_DIR_OF_MODULE = os.path.join(THIS_DIR, MODULE_NAME)


# Insert in sys.path, so we can import the *real* package
if not PARENT_DIR_OF_MODULE in sys.path:
    sys.path.insert(0, PARENT_DIR_OF_MODULE)

# Remove *this* module from sys.modules, so we can import that name again
# (keep reference to avoid premature cleanup)
_old = sys.modules.pop(MODULE_NAME, None)

# Import the *real* package. This will put the new package in
# sys.modules. Note that the new package is injected in the namespace
# from which "import package" is called; we do not need to import *.
try:
  __import__(MODULE_NAME, level=0)
except Exception as err:
  sys.modules[MODULE_NAME] = _old  # Prevent KeyError
  raise


# Clean up after ourselves
if PARENT_DIR_OF_MODULE in sys.path:
    sys.path.remove(PARENT_DIR_OF_MODULE)

########NEW FILE########
