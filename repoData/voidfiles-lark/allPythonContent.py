__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# lark documentation build configuration file, created by
# sphinx-quickstart on Tue Dec 17 22:21:12 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('../'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'lark'
copyright = u'2013, Alex Kessinger'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'larkdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'lark.tex', u'lark Documentation',
   u'Alex Kessinger', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'lark', u'lark Documentation',
     [u'Alex Kessinger'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'lark', u'lark Documentation',
   u'Alex Kessinger', 'lark', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = flask_app
from flask import Flask
from lark.ext.flask.redis_api import redis_api_blueprint
from lark.ext.flask.flask_redis import Redis

app = Flask(__name__)
# Add a simpple redis connection to the global object
Redis(app)

app.config['DEFAULT_LARK_SCOPES'] = set(['admin'])

# Mount the redis blueprint
app.register_blueprint(redis_api_blueprint, url_prefix='/api/0')


if __name__ == '__main__':
    app.run()

########NEW FILE########
__FILENAME__ = api
import functools

from colander import Invalid
from redis.exceptions import DataError
from flask import Blueprint, make_response, g, request
from flask_oauthlib.provider import OAuth2Provider

from lark.ext.flask.flask_redis import Redis
from lark.ext.utils import json_dumps

from .models import User, Token, Client, Grant
from .schemas import ClientSchema
from .oauth2 import bind_models
from .database import db

oauth = OAuth2Provider()
redis = Redis()


class NotFound(Exception):
    pass


class NotAuthorized(Exception):
    pass


def current_user():
    return g.user


# Lazily register oauth, redis
def init_blueprint(state):
    oauth.init_app(state.app)
    redis.init_app(state.app)
    db.init_app(state.app)
    bind_models(oauth, user=User, token=Token,
                client=Client, grant=Grant, current_user=current_user)

lark_admin_api = Blueprint('lark_admin_api', __name__)
lark_admin_api.record(init_blueprint)


def api_func(func, oauth_obj, schema=None, *args, **kwargs):
    status_code = 200
    try:
        try:
            request_json = request.get_json()
        except:
            request_json = None

        if schema:
            schema_inst = schema()
            data = schema_inst.serialize(request_json)
        else:
            data = request_json

        if data:
            args = list(args) if args else []
            args.insert(0, data)

        data = func(oauth_obj, *args, **kwargs)

        resp_envelope = {
            'meta': {
                'status': 'ok',
                'status_code': status_code,
            },
            'data': data,
        }
    except NotFound, e:
        status_code = 404
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': status_code,
                'error_message': unicode(e)
            }
        }
    except NotAuthorized, e:
        status_code = 400
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': status_code,
                'error_message': unicode(e)
            }
        }
    except DataError, e:
        status_code = 400
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': status_code,
                'error_message': unicode(e)
            }
        }
    except Invalid, e:
        status_code = 400
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': status_code,
                'error_message': unicode(e)
            }
        }
    except Exception, e:
        raise
        status_code = 500
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': 500,
                'error_message': 'unhandled error'
            }
        }

    resp_json = json_dumps.encode(resp_envelope)
    return make_response(resp_json, status_code, {
        'Content-Type': 'application/json',
    })


def json_handler(schema=None):
    def outer_wraper(f):
        @functools.wraps(f)
        def wrapper(schema=None, *args, **kwargs):
            print f
            print schema
            return api_func(f, schema, *args, **kwargs)
        return wrapper
    return outer_wraper

# @app.route('/oauth/authorize', methods=['GET', 'POST'])
# @oauth.authorize_handler
# def authorize(*args, **kwargs):
#     # NOTICE: for real project, you need to require login
#     if request.method == 'GET':
#         # render a page for user to confirm the authorization
#         return render_template('confirm.html')

#     confirm = request.form.get('confirm', 'no')
#     return confirm == 'yes'


@lark_admin_api.route('/oauth/token')
@oauth.token_handler
def access_token():
    return {}


@lark_admin_api.route('/clients', methods=['POST'])
@oauth.require_oauth('admin')
@json_handler(schema=ClientSchema)
def create_client(oauth_obj, client):
    client = Client.create_from_user(oauth_obj.user, client)
    return client.for_api()


@lark_admin_api.route('/clients', methods=['GET'])
@oauth.require_oauth('admin')
@json_handler()
def get_clients(oauth_obj):
    clients = oauth_obj.user.clients
    clients = [client.for_api() for client in clients]
    return clients


def get_client_with_authorize(user, client_id):
    client = Client.query.filter_by(client_id=client_id).first()
    if not client:
        raise NotFound('Client for %s does not exsist' % client_id)

    if not client.authorized(user):
        raise NotAuthorized('You are not authorized to get this resource')

    return client


@lark_admin_api.route('/clients/<client_id>', methods=['GET'])
@oauth.require_oauth('admin')
@json_handler()
def get_client(oauth_obj, client_id):
    print oauth_obj.user
    client = get_client_with_authorize(oauth_obj.user, client_id)

    return client.for_api()


@lark_admin_api.route('/clients/<client_id>', methods=['POST'])
@oauth.require_oauth('admin')
@json_handler(schema=ClientSchema)
def update_client(oauth_obj, client_data, client_id):
    client = get_client_with_authorize(oauth_obj.user, client_id)
    client = client.update(client_data)

    return client.for_api()


@lark_admin_api.route('/clients/<client_id>/tokens', methods=['GET'])
@oauth.require_oauth('admin')
@json_handler()
def get_tokens(oauth_obj, client_id):
    client = get_client_with_authorize(oauth_obj.user, client_id)
    tokens = Token.get_by_index('user_pk', oauth_obj.user.pk)
    # Ensure user owns client
    # Find a list of this users tokens for this client


@lark_admin_api.route('/clients/<client_id>/tokens', methods=['POST'])
@oauth.require_oauth('admin')
@json_handler(schema=ClientSchema)
def create_token(oauth_obj, client_data, client_id):
    # Ensure user owns client
    class RequestValidator(object):
        def save_bearer_token(self, token, request):
            return Token.set_for_oauth2(token, request)

    validator = RequestValidator()

    bearer_token_generator = BearerToken(request_validator=validator, expires_in=3600)

    class RequestMock(object):
        scopes = ['admin']
        state = '123'
        extra_credentials = None

        def __init__(self, user, client):
            self.user = user
            self.client = client

    request = RequestMock(user=user, client=oauth_client)

    token = bearer_token_generator.create_token(request, refresh_token=True)

    return token['access_token']

########NEW FILE########
__FILENAME__ = database
from flask.ext.sqlalchemy import SQLAlchemy

db = SQLAlchemy()

########NEW FILE########
__FILENAME__ = models
from datetime import datetime, timedelta
import json

from flask.ext.bcrypt import Bcrypt
from lark.ext.utils import generate_random_string
from sqlalchemy.types import TypeDecorator, TEXT

from .database import db


class JSONEncodedDict(TypeDecorator):
    """Represents an immutable structure as a json-encoded string.

    Usage::

        JSONEncodedDict(255)

    """

    impl = TEXT

    def process_bind_param(self, value, dialect):
        if value is not None:
            value = json.dumps(value)

        return value

    def process_result_value(self, value, dialect):
        if value is not None:
            value = json.loads(value)
        return value


bcrypt = Bcrypt()


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(20), nullable=False)
    password_hash = db.Column(db.String(40), nullable=False)
    external_access_token = db.Column(db.String(255), nullable=True)
    remote_user_id = db.Column(db.Integer)
    extra_info = db.Column(JSONEncodedDict)

    @classmethod
    def create_user(cls, **kwargs):
        password = kwargs.pop('password', None)
        if password:
            kwargs['password_hash'] = bcrypt.generate_password_hash(password)

        user = cls(**kwargs)
        db.session.add(user)
        db.session.commit()

        return user

    def for_api(self):
        return {
            'id': self.id,
            'username': self.username,
        }

    def check_password(self, password):
        hashed_password = bcrypt.generate_password_hash(password)
        return hashed_password == self.password

    @classmethod
    def get_for_oauth2(cls, username, password, client, request):
        user = cls.query.filter_by(username=username).first()
        if not user:
            return None

        if not bcrypt.check_password_hash(user.password_hash, password):
            return None

        return user


class Client(db.Model):
    # human readable name, not required
    name = db.Column(db.String(40))

    # human readable description, not required
    description = db.Column(db.String(400))

    # creator of the client, not required
    user_id = db.Column(db.ForeignKey('user.id'))
    # required if you need to support client credential
    user = db.relationship('User', backref="clients")

    client_id = db.Column(db.String(40), primary_key=True)
    client_secret = db.Column(db.String(55), unique=True, index=True,
                              nullable=False)

    # public or confidential
    is_confidential = db.Column(db.Boolean, default=True)

    _redirect_uris = db.Column(db.Text, default='http://localhost:8000')
    _alowed_grant_types = db.Column(db.Text)
    _alowed_response_types = db.Column(db.Text)
    _default_scopes = db.Column(db.Text)
    extra_info = db.Column(JSONEncodedDict)

    @property
    def client_type(self):
        if self.is_confidential:
            return 'confidential'
        return 'public'

    @property
    def redirect_uris(self):
        if self._redirect_uris:
            return self._redirect_uris.split()
        return []

    @property
    def alowed_grant_types(self):
        if self._alowed_grant_types:
            return self._alowed_grant_types.split()
        return []

    @property
    def alowed_response_types(self):
        if self._alowed_response_types:
            return self._alowed_response_types.split()
        return []

    @property
    def default_redirect_uri(self):
        return self.redirect_uris[0]

    @property
    def default_scopes(self):
        if self._default_scopes:
            return self._default_scopes.split()
        return []

    def update(self, data):
        self.name = data.get('name')
        self.description = data.get('description')
        self._redirect_uris = ' '.join(data.get('redirect_uris'))

        db.session.add(self)
        db.session.commit()
        return self

    def for_api(self):
        return {
            'name': self.name,
            'description': self.description,
            'client_id': self.client_id,
            'client_secret': self.client_secret,
            'redirect_uris': self.redirect_uris,
            'user': self.user.for_api()
        }

    def authorized(self, user):
        return self.user.id == user.id

    @classmethod
    def get_for_oauth2(cls, client_id):
        return cls.query.filter_by(client_id=client_id).first()

    @classmethod
    def create_from_user(cls, user, data):
        while True:
            client_id = generate_random_string(32)
            client = cls.query.filter_by(client_id=client_id).first()
            if not client:
                break

        data['client_id'] = client_id
        data['client_secret'] = generate_random_string(32)
        data['user_id'] = user.id
        data['is_confidential'] = True
        data['_default_scopes'] = ''
        data['_redirect_uris'] = ' '.join(data.pop('redirect_uris', []))
        client = cls(**data)
        db.session.add(client)
        db.session.commit()

        return client


class Grant(db.Model):
    id = db.Column(db.Integer, primary_key=True)

    user_id = db.Column(
        db.Integer, db.ForeignKey('user.id', ondelete='CASCADE')
    )
    user = db.relationship('User')

    client_id = db.Column(
        db.String(40), db.ForeignKey('client.client_id'),
        nullable=False,
    )
    client = db.relationship('Client')

    code = db.Column(db.String(255), index=True, nullable=False)

    redirect_uri = db.Column(db.String(255))
    expires = db.Column(db.DateTime)

    _scopes = db.Column(db.Text)
    extra_info = db.Column(JSONEncodedDict)

    def delete(self):
        db.session.delete(self)
        db.session.commit()
        return self

    @property
    def scopes(self):
        if self._scopes:
            return self._scopes.split()
        return []

    @classmethod
    def get_for_oauth2(cls, client_id, code):

        if isinstance(code, dict):
            code = code.get('code')

        return cls.query.filter_by(client_id=client_id, code=code).first()

    @classmethod
    def set_for_oauth2(cls, current_user, client_id, code, request):
        # decide the expires time yourself
        expires = datetime.utcnow() + timedelta(seconds=100)
        grant = Grant(
            client_id=client_id,
            code=code['code'],
            redirect_uri=request.redirect_uri,
            _scopes=' '.join(request.scopes),
            user=current_user(),
            expires=expires
        )
        db.session.add(grant)
        db.session.commit()
        return grant


class Token(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    client_id = db.Column(
        db.String(40), db.ForeignKey('client.client_id'),
        nullable=False,
    )
    client = db.relationship('Client')

    user_id = db.Column(
        db.Integer, db.ForeignKey('user.id')
    )
    user = db.relationship('User')

    # currently only bearer is supported
    token_type = db.Column(db.String(40))

    access_token = db.Column(db.String(255), unique=True)
    refresh_token = db.Column(db.String(255), unique=True)
    expires = db.Column(db.DateTime)
    _scopes = db.Column(db.Text)
    extra_info = db.Column(JSONEncodedDict)

    @property
    def scopes(self):
        if self._scopes:
            return self._scopes.split()
        return []

    @classmethod
    def get_for_oauth2(cls, access_token=None, refresh_token=None):
        if access_token:
            return cls.query.filter_by(access_token=access_token).first()
        elif refresh_token:
            return cls.query.filter_by(refresh_token=refresh_token).first()

    @classmethod
    def set_for_oauth2(cls, token, request, *args, **kwargs):
        toks = Token.query.filter_by(client_id=request.client.client_id,
                                     user_id=request.user.id)

        # make sure that every client has only one token connected to a user
        for t in toks:
            db.session.delete(t)

        expires_in = token.pop('expires_in')
        expires = datetime.utcnow() + timedelta(seconds=expires_in)
        scopes = token['scope']
        if scopes and not isinstance(scopes, basestring):
            scopes = ' '.join(scopes)

        tok = Token(
            access_token=token['access_token'],
            refresh_token=token['refresh_token'],
            token_type=token['token_type'],
            _scopes=scopes,
            expires=expires,
            client_id=request.client.client_id,
            user_id=request.user.id,
        )
        db.session.add(tok)
        db.session.commit()
        return tok

########NEW FILE########
__FILENAME__ = oauth2
from __future__ import absolute_import
from functools import partial
import logging


__all__ = ('bind_models',)


log = logging.getLogger(__name__)


def bind_models(provider, user=None, client=None,
                token=None, grant=None, current_user=None):

    if user:
        provider.usergetter(user.get_for_oauth2)

    if client:
        provider.clientgetter(client.get_for_oauth2)

    if token:
        provider.tokengetter(token.get_for_oauth2)
        provider.tokensetter(token.set_for_oauth2)

    if grant:
        if not current_user:
            raise ValueError(('`current_user` is required'
                              'for Grant Binding'))
        provider.grantgetter(grant.get_for_oauth2)
        provider.grantsetter(partial(grant.set_for_oauth2, current_user))

########NEW FILE########
__FILENAME__ = schemas
import colander


class ClientSchema(colander.MappingSchema):
    name = colander.SchemaNode(colander.String())
    description = colander.SchemaNode(colander.String())
    default_scope = colander.SchemaNode(colander.String(), missing='')
    redirect_uris = colander.SchemaNode(colander.Sequence(colander.String),
                                        missing=['http://localhost:8000'])

########NEW FILE########
__FILENAME__ = client
from flask import Flask, redirect, url_for, session, request, jsonify, abort
from flask_oauthlib.client import OAuth


def create_client(app):
    oauth = OAuth(app)

    remote = oauth.remote_app(
        'dev',
        consumer_key='dev',
        consumer_secret='dev',
        request_token_params={'scope': 'email'},
        base_url='http://127.0.0.1:5000/api/',
        request_token_url=None,
        access_token_method='GET',
        access_token_url='http://127.0.0.1:5000/oauth/token',
        authorize_url='http://127.0.0.1:5000/oauth/authorize'
    )

    @app.route('/')
    def index():
        if 'dev_token' in session:
            ret = remote.get('email')
            return jsonify(ret.data)
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        return remote.authorize(callback=url_for('authorized', _external=True))

    @app.route('/logout')
    def logout():
        session.pop('dev_token', None)
        return redirect(url_for('index'))

    @app.route('/authorized')
    @remote.authorized_handler
    def authorized(resp):
        if resp is None:
            return 'Access denied: error=%s' % (
                request.args['error']
            )
        if isinstance(resp, dict) and 'access_token' in resp:
            session['dev_token'] = (resp['access_token'], '')
            return jsonify(resp)
        return str(resp)

    @app.route('/client')
    def client_method():
        ret = remote.get("client")
        if ret.status not in (200, 201):
            return abort(ret.status)
        return ret.raw_data

    @app.route('/address')
    def address():
        ret = remote.get('address/hangzhou')
        if ret.status not in (200, 201):
            return abort(ret.status)
        return ret.raw_data

    @app.route('/method/<name>')
    def method(name):
        func = getattr(remote, name)
        ret = func('method')
        return ret.raw_data

    @remote.tokengetter
    def get_oauth_token():
        return session.get('dev_token')

    return remote


if __name__ == '__main__':
    import os
    os.environ['DEBUG'] = 'true'
    # DEBUG=1 python oauth2_client.py
    app = Flask(__name__)
    app.debug = True
    app.secret_key = 'development'
    create_client(app)
    app.run(host='localhost', port=8000)

########NEW FILE########
__FILENAME__ = schemas
import collander


def ClientSchema(collander.MappingSchema):
    name = colander.SchemaNode(colander.String())
    description = colander.SchemaNode(colander.String())
    default_scope = colander.SchemaNode(colander.Strin(), missing='')
    redirect_uris = colander.SchemaNode(colander.Sequence(colander.String),
                                        missing=['http://localhost:8000'])

########NEW FILE########
__FILENAME__ = server
from datetime import datetime, timedelta
from flask import g, render_template, request, jsonify

from flask_oauthlib.provider import OAuth2Provider
import redis

from lark.auth.models import User, Client, Grant, Token
from lark.auth.oauth2 import bind_models


def current_user():
    return g.user


r_con = redis.Redis.from_url('redis://localhost:6379/11')


def redis_provider(app):
    oauth = OAuth2Provider(app)

    bind_models(oauth, r_con, user=User, token=Token,
                client=Client, grant=Grant, current_user=current_user)

    return oauth


def prepare_app(app):
    user = User(r_con, username='admin', password='admin')
    user.save()

    user2 = User(r_con, username='admin2', password='admin2')
    user2.save()

    client1 = Client(r_con, name='dev', client_id='dev', client_secret='dev',
                     default_scope=['address', 'email'],
                     user=user, redirect_uris=('http://localhost:8000/authorized',
                                               'http://localhost/authorized'))

    client1.save()

    client2 = Client(r_con, name='confidential', client_id='confidential',
                     default_scope=['address', 'email'],
                     client_secret='confidential', client_type='confidential',
                     user=user2, redirect_uris=('http://localhost:8000/authorized',
                                                'http://localhost/authorized'))

    client2.save()

    return app


def create_server(app, oauth):
    app = prepare_app(app)

    @app.before_request
    def load_current_user():
        user = User.by_pk(r_con, 1)
        g.user = user

    @app.route('/home')
    def home():
        return render_template('home.html')

    @app.route('/oauth/authorize', methods=['GET', 'POST'])
    @oauth.authorize_handler
    def authorize(*args, **kwargs):
        # NOTICE: for real project, you need to require login
        if request.method == 'GET':
            # render a page for user to confirm the authorization
            return render_template('confirm.html')

        confirm = request.form.get('confirm', 'no')
        return confirm == 'yes'

    @app.route('/oauth/token')
    @oauth.token_handler
    def access_token():
        return {}

    @app.route('/api/email')
    @oauth.require_oauth('email')
    def email_api(oauth):
        return jsonify(email='me@oauth.net', username=oauth.user.username)

    @app.route('/api/client')
    @oauth.require_oauth()
    def client_api(oauth):
        return jsonify(client=oauth.client.name)

    @app.route('/api/address/<city>')
    @oauth.require_oauth('address')
    def address_api(oauth, city):
        return jsonify(address=city, username=oauth.user.username)

    @app.route('/api/method', methods=['GET', 'POST', 'PUT', 'DELETE'])
    @oauth.require_oauth()
    def method_api(oauth):
        return jsonify(method=request.method)

    return app


if __name__ == '__main__':
    from flask import Flask
    app = Flask(__name__)
    app.debug = True
    app.secret_key = 'development'
    app.config.update({
        'SQLALCHEMY_DATABASE_URI': 'sqlite:///test.sqlite'
    })
    app = create_server(app)
    app.run()

########NEW FILE########
__FILENAME__ = test_admin_api
from __future__ import with_statement
import json
import os
import tempfile
import unittest
import base64

from werkzeug.datastructures import Headers

from flask import Flask
from oauthlib.oauth2.rfc6749.tokens import BearerToken

from lark.auth.api import lark_admin_api
from lark.auth.models import User, Client, Token
from lark.auth.database import db


class ApiTest(unittest.TestCase):

    def setUp(self):
        app = Flask(__name__)
        self.db_fd, self.path = tempfile.mkstemp()
        app.config['DEBUG'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = "sqlite:///%s" % (self.path)
        app.register_blueprint(lark_admin_api, url_prefix='/admin')
        self.app = app
        self.client = app.test_client()
        self.request_ctx = self.app.test_request_context()
        self.request_ctx.push()
        db.create_all()
        self.client = app.test_client()

        user = User.create_user(username='test', password='test')
        self.user = user
        user2 = User.create_user(username='test2', password='test2')
        self.user2 = user2
        client = Client.create_from_user(user, {
            'name': 'Test Test',
            'description': 'test is testy',
            'redirect_uris': ['http://localhost:8000'],
        })
        self.oauth_client = client

    def tearDown(self):
        self.request_ctx.pop()
        os.close(self.db_fd)
        os.unlink(self.path)

    ### SERVER INFORMATION ###
    def test_get_access_token(self):
        url = ('/admin/oauth/token?grant_type=password&state=foo'
               '&scope=admin&username=test&password=test')

        auth_code = '%s:%s' % (self.oauth_client.client_id, self.oauth_client.client_secret)
        auth_code = base64.b64encode(auth_code)

        rv = self.client.get(url, headers={
            'Authorization': 'Basic %s' % auth_code,
        }, data={'confirm': 'yes'})

        resp_json = json.loads(rv.data)
        assert 'access_token' in resp_json
        assert 'state' in resp_json

        data = {
            'name': 'awesome sauce',
            'description': 'awesome sauce is awesome',
            'redirect_uris': ['http://localhost:4000'],
        }

        rv = self.client.post('/admin/clients', headers={
            'Authorization': 'Bearer %s' % (resp_json['access_token'], ),
            'Content-Type': 'application/json',
        }, data=json.dumps(data))

        json_data = json.loads(rv.data)

        assert json_data['data']['user']['id'] == 1

    def create_access_token(self, user, oauth_client):
        class RequestValidator(object):
            def save_bearer_token(self, token, request):
                print token
                return Token.set_for_oauth2(token, request)

        validator = RequestValidator()

        bearer_token_generator = BearerToken(request_validator=validator, expires_in=3600)

        class RequestMock(object):
            scopes = ['admin']
            state = '123'
            extra_credentials = None

            def __init__(self, user, client):
                self.user = user
                self.client = client

        request = RequestMock(user=user, client=oauth_client)

        token = bearer_token_generator.create_token(request, refresh_token=True)

        return token['access_token']

    def test_client_creation(self):

        access_token = self.create_access_token(self.user, self.oauth_client)

        data = {
            'name': 'awesome sauce',
            'description': 'awesome sauce is awesome',
            'redirect_uris': ['http://localhost:4000'],
        }

        headers = Headers({
            'Authorization': 'Bearer %s' % (access_token, ),
            'Content-Type': 'application/json',
        })

        rv = self.client.post(path='/admin/clients', headers=headers, data=json.dumps(data))

        json_data = json.loads(rv.data)

        assert json_data['data']['user']['id'] == 1
        assert json_data['data']['name'] == data['name']
        assert json_data['data']['description'] == data['description']
        assert json_data['data']['redirect_uris'] == data['redirect_uris']

        rv = self.client.get(path='/admin/clients', headers=headers)
        json_data = json.loads(rv.data)
        assert len(json_data['data']) == 2

        client_id = json_data['data'][0]['client_id']
        path = '/admin/clients/%s' % (client_id)
        rv = self.client.get(path=path, headers=headers)
        json_data = json.loads(rv.data)
        assert json_data['data']['client_id'] == client_id

        client_data = json_data['data']
        client_data['name'] = 'awesome sauce 2'
        path = '/admin/clients/%s' % (client_id)
        rv = self.client.post(path=path, headers=headers, data=json.dumps(client_data))
        json_data = json.loads(rv.data)
        assert json_data['data']['client_id'] == client_id
        assert json_data['data']['name'] == 'awesome sauce 2'

########NEW FILE########
__FILENAME__ = test_models
from datetime import datetime, timedelta
import os
import tempfile
import unittest

from flask import Flask

from lark.auth.models import User, Client, Grant, Token
from lark.auth.api import lark_admin_api
from lark.auth.database import db


class ModelTests(unittest.TestCase):
    def setUp(self):
        app = Flask(__name__)
        self.db_fd, self.path = tempfile.mkstemp()
        app.config['DEBUG'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = "sqlite:///%s" % (self.path)
        app.register_blueprint(lark_admin_api, url_prefix='/admin')
        self.app = app
        self.request_ctx = self.app.test_request_context()
        self.request_ctx.push()
        db.create_all()

    def tearDown(self):
        self.request_ctx.pop()
        os.close(self.db_fd)
        os.unlink(self.path)

    def create_user(self, username='voidfiles', password='awesome', external_access_token='abc', remote_user_id=3):
        user_data = {
            'username': username,
            'password': password,
            'external_access_token': external_access_token,
            'remote_user_id': remote_user_id,
        }

        user = User.create_user(**user_data)
        db.session.add(user)
        db.session.commit()

        return user

    def test_user(self):
        user = self.create_user()

        assert User.get_for_oauth2('voidfiles', 'awesome', {}, {}).id == user.id

    def create_client(self, user, name='TextApp', description='An awesome test app', client_id='123', client_secret='abc',
                      is_confidential=True, default_scope=['email', 'user'],
                      redirect_uris=['http://example.com', 'http://example.com/2']):

        client_data = {
            'user': user,
            'name': name,
            'description': description,
            'client_id': client_id,
            'client_secret': client_secret,
            '_default_scopes': ' '.join(default_scope),
            '_redirect_uris': ' '.join(redirect_uris),
        }

        client = Client(**client_data)
        db.session.add(client)
        db.session.commit()

        return client

    def test_client(self):
        user = self.create_user()

        client = self.create_client(user)

        assert client.user.id == user.id
        assert client.redirect_uris == ['http://example.com', 'http://example.com/2']
        assert client.default_scopes == ['email', 'user']
        assert client.default_redirect_uri == 'http://example.com'
        assert Client.get_for_oauth2('123').client_id == client.client_id

    def test_grant(self):
        user = self.create_user()
        client = self.create_client(user)
        print user
        print client
        data = {
            'user_id': user.id,
            'user': user,
            'client': client,
            'client_id': client.client_id,
            'code': '101112',
            'redirect_uri': 'http://example.com',
            '_scopes': 'email user',
            'expires': datetime.utcnow() + timedelta(seconds=10),
        }

        grant = Grant(**data)
        db.session.add(grant)
        db.session.commit()
        grant = Grant.get_for_oauth2(client.client_id, '101112')
        assert grant.user.id == user.id
        assert grant.client_id == client.client_id
        assert grant.scopes == ['email', 'user']
        assert Grant.get_for_oauth2(client.client_id, '101112').id == grant.id

        class Request(object):
            scopes = ['email', 'user']
            redirect_uri = 'http://example.com'

            def __init__(self, user):
                self.user = user

        request = Request(user=user)
        current_user = lambda: request.user
        grant = Grant.set_for_oauth2(current_user, 'abcdef', {'code': '123'}, request)

        assert grant.scopes == ['email', 'user']
        assert grant.client_id == 'abcdef'
        assert grant.code == '123'

    def test_token(self):
        user = self.create_user()
        client = self.create_client(user)

        token_data = {
            'user': user,
            'client': client,
            'token_type': 'bearer',
            'access_token': '123',
            'refresh_token': 'abc',
            'expires': datetime.utcnow() + timedelta(seconds=3600),
            '_scopes': 'email user',
        }

        token = Token(**token_data)
        db.session.add(token)
        db.session.commit()

        token = Token.get_for_oauth2(access_token='123')

        assert token.user.id == user.id
        assert token.client.client_id == client.client_id
        assert token.scopes == ['email', 'user']

        class Request(object):
            scopes = ['email', 'user']

            def __init__(self, user, client):
                self.user = user
                self.client = client

        request = Request(user=user, client=client)

        token_data = {
            'expires_in': 3600,
            'access_token': 'abc',
            'refresh_token': '123',
            'token_type': 'Bearer',
            'scope': ['email', 'user'],
        }

        token = Token.set_for_oauth2(token_data, request)
        assert token.user.id == user.id
        assert token.client.client_id == client.client_id
        assert token.scopes == ['email', 'user']

        token = Token.get_for_oauth2(access_token='abc')
        assert token.user.id == user.id
        assert token.client.client_id == client.client_id
        assert token.scopes == ['email', 'user']

        token = Token.get_for_oauth2(refresh_token='123')
        assert token.user.id == user.id
        assert token.client.client_id == client.client_id
        assert token.scopes == ['email', 'user']


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_oauth2
import base64
import json
import os
import sys

from mock import MagicMock
import redis
from unittest import TestCase


from flask import Flask
from flask_oauthlib.client import prepare_request
from .server import create_server, redis_provider
from .client import create_client

try:
    from urlparse import urlparse
except ImportError:
    from urllib.parse import urlparse

if sys.version_info[0] == 3:
    python_version = 3
    string_type = str
else:
    python_version = 2
    string_type = unicode

r_con = redis.Redis.from_url('redis://localhost:6379/11')

os.environ['DEBUG'] = 'true'

def u(text):
    if not isinstance(text, string_type):
        text = text.decode('utf-8')
    return text


def b(text):
    if isinstance(text, string_type):
        text = text.encode('utf-8')
    return text


def clean_url(location):
    location = u(location)
    ret = urlparse(location)
    return '%s?%s' % (ret.path, ret.query)


class OAuthSuite(TestCase):

    def setUp(self):
        app = self.create_app()

        self.setup_app(app)

        self.app = app
        self.client = app.test_client()
        return app

    def tearDown(self):
        r_con.flushall()

    def create_oauth_provider(app):
        raise NotImplementedError('Each test class must'
                                  'implement this method.')

    def create_app(self):
        app = Flask(__name__)
        app.config.update({
            'OAUTH1_PROVIDER_ENFORCE_SSL': False,
        })
        app.debug = True
        app.testing = True
        app.secret_key = 'development'
        return app

    def setup_app(self, app):
        oauth = self.create_oauth_provider(app)
        create_server(app, oauth)
        client = create_client(app)
        client.http_request = MagicMock(
            side_effect=self.patch_request(app)
        )
        return app

    def patch_request(self, app):
        test_client = app.test_client()

        def make_request(uri, headers=None, data=None, method=None):
            uri, headers, data, method = prepare_request(
                uri, headers, data, method
            )

            # test client is a `werkzeug.test.Client`
            parsed = urlparse(uri)
            uri = '%s?%s' % (parsed.path, parsed.query)
            resp = test_client.open(
                uri, headers=headers, data=data, method=method
            )
            # for compatible
            resp.code = resp.status_code
            return resp, resp.data

        return make_request

authorize_url = (
    '/oauth/authorize?response_type=code&client_id=dev'
    '&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fauthorized&scope=email'
)


def _base64(text):
    return u(base64.b64encode(b(text)))


auth_code = _base64('confidential:confidential')


class TestWebAuth(OAuthSuite):

    def create_oauth_provider(self, app):
        return redis_provider(app)

    def test_login(self):
        rv = self.client.get('/login')
        assert 'response_type=code' in rv.location

    def test_oauth_authorize_invalid_url(self):
        rv = self.client.get('/oauth/authorize')
        assert 'invalid_client_id' in rv.location

    def test_oauth_authorize_valid_url(self):
        rv = self.client.get(authorize_url)
        assert b'</form>' in rv.data

        rv = self.client.post(authorize_url, data=dict(
            confirm='no'
        ))
        assert 'access_denied' in rv.location

        rv = self.client.post(authorize_url, data=dict(
            confirm='yes'
        ))
        # success
        assert 'code=' in rv.location
        assert 'state' not in rv.location

        # test state
        rv = self.client.post(authorize_url + '&state=foo', data=dict(
            confirm='yes'
        ))
        assert 'code=' in rv.location
        assert 'state' in rv.location

    def test_get_access_token(self):
        rv = self.client.post(authorize_url, data={'confirm': 'yes'})
        rv = self.client.get(clean_url(rv.location))
        assert b'access_token' in rv.data

    def test_full_flow(self):
        rv = self.client.post(authorize_url, data={'confirm': 'yes'})
        rv = self.client.get(clean_url(rv.location))
        assert b'access_token' in rv.data

        rv = self.client.get('/')
        assert b'username' in rv.data

        rv = self.client.get('/address')
        assert rv.status_code == 403

        rv = self.client.get('/method/post')
        assert b'POST' in rv.data

        rv = self.client.get('/method/put')
        assert b'PUT' in rv.data

        rv = self.client.get('/method/delete')
        assert b'DELETE' in rv.data

    def test_get_client(self):
        rv = self.client.post(authorize_url, data={'confirm': 'yes'})
        rv = self.client.get(clean_url(rv.location))
        rv = self.client.get("/client")
        assert b'dev' in rv.data

    def test_invalid_client_id(self):
        authorize_url = (
            '/oauth/authorize?response_type=code&client_id=confidential'
            '&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fauthorized'
            '&scope=email'
        )
        rv = self.client.post(authorize_url, data={'confirm': 'yes'})
        rv = self.client.get(clean_url(rv.location))
        assert b'Invalid' in rv.data

    def test_invalid_response_type(self):
        authorize_url = (
            '/oauth/authorize?response_type=invalid&client_id=dev'
            '&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fauthorized'
            '&scope=email'
        )
        rv = self.client.post(authorize_url, data={'confirm': 'yes'})
        rv = self.client.get(clean_url(rv.location))
        assert b'error' in rv.data


class TestPasswordAuth(OAuthSuite):

    def create_oauth_provider(self, app):
        return redis_provider(app)

    def test_get_access_token(self):
        url = ('/oauth/token?grant_type=password&state=foo'
               '&scope=email+address&username=admin&password=admin')
        rv = self.client.get(url, headers={
            'Authorization': 'Basic %s' % auth_code,
        }, data={'confirm': 'yes'})
        assert b'access_token' in rv.data
        assert b'state' in rv.data

    def test_invalid_user_credentials(self):
        url = ('/oauth/token?grant_type=password&state=foo'
               '&scope=email+address&username=fake&password=admin')
        rv = self.client.get(url, headers={
            'Authorization': 'Basic %s' % auth_code,
        }, data={'confirm': 'yes'})

        assert b'Invalid credentials given' in rv.data


class TestRefreshToken(OAuthSuite):

    def create_oauth_provider(self, app):
        return redis_provider(app)

    def test_refresh_token_in_password_grant(self):
        url = ('/oauth/token?grant_type=password'
               '&scope=email+address&username=admin&password=admin')
        rv = self.client.get(url, headers={
            'Authorization': 'Basic %s' % auth_code,
        })
        assert b'access_token' in rv.data
        data = json.loads(u(rv.data))

        args = (data.get('scope').replace(' ', '+'),
                data.get('refresh_token'))
        url = ('/oauth/token?grant_type=refresh_token'
               '&scope=%s&refresh_token=%s&username=admin')
        url = url % args
        rv = self.client.get(url, headers={
            'Authorization': 'Basic %s' % auth_code,
        })
        assert b'access_token' in rv.data


class TestCredentialAuth(OAuthSuite):

    def create_oauth_provider(self, app):
        return redis_provider(app)

    def test_get_access_token(self):
        url = ('/oauth/token?grant_type=client_credentials'
               '&scope=email+address&username=admin&password=admin')
        rv = self.client.get(url, headers={
            'Authorization': 'Basic %s' % auth_code,
        }, data={'confirm': 'yes'})
        assert b'access_token' in rv.data

    def test_invalid_auth_header(self):
        url = ('/oauth/token?grant_type=client_credentials'
               '&scope=email+address&username=admin&password=admin')
        rv = self.client.get(url, headers={
            'Authorization': 'Basic foobar'
        }, data={'confirm': 'yes'})
        assert b'invalid_client' in rv.data

    def test_no_client(self):
        auth_code = _base64('none:confidential')
        url = ('/oauth/token?grant_type=client_credentials'
               '&scope=email+address&username=admin&password=admin')
        rv = self.client.get(url, headers={
            'Authorization': 'Basic %s' % auth_code,
        }, data={'confirm': 'yes'})
        assert b'invalid_client' in rv.data

    def test_wrong_secret_client(self):
        auth_code = _base64('confidential:wrong')
        url = ('/oauth/token?grant_type=client_credentials'
               '&scope=email+address&username=admin&password=admin')
        rv = self.client.get(url, headers={
            'Authorization': 'Basic %s' % auth_code,
        }, data={'confirm': 'yes'})
        assert b'invalid_client' in rv.data


class TestTokenGenerator(OAuthSuite):

    def create_oauth_provider(self, app):

        def generator(request, refresh_token=False):
            return 'foobar'

        app.config['OAUTH2_PROVIDER_TOKEN_GENERATOR'] = generator
        return redis_provider(app)

    def test_get_access_token(self):
        rv = self.client.post(authorize_url, data={'confirm': 'yes'})
        rv = self.client.get(clean_url(rv.location))
        data = json.loads(u(rv.data))
        assert data['access_token'] == 'foobar'
        assert data['refresh_token'] == 'foobar'

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
import re

urlpatterns = []


def build_api_func(routes, methods=['GET'], redispy_method=None):
    if isinstance(routes, basestring):
        routes = [routes]

    if not redispy_method:
        redispy_method = routes[0][1:].split('/')[0].lower()

    for route in routes:
        args = re.findall(r'(<\w+>)', route)
        for arg in args:
            name = '(?P<%s>[^/]+)' % (arg[1:-1])
            route = route.replace(arg, name, 1)
        # print route
        urlpatterns.append(url(r'(?i)^%s$' % (route[1:]), 'lark.ext.django.views.query_redis', {'redispy_method': redispy_method, 'methods': methods}))


build_api_func('/BGREWRITEAOF/')

build_api_func('/BGSAVE/')

build_api_func('/CLIENT/LIST/', redispy_method='client_list')

build_api_func('/CLIENT/KILL/', methods=['POST'], redispy_method='client_kill')

build_api_func('/CLIENT/GETNAME/', redispy_method='client_getname')

build_api_func('/CLIENT/SETNAME/', methods=['POST'], redispy_method='client_setname')

build_api_func(['/CONFIG/GET/<pattern>', '/CONFIG/GET/'], redispy_method='config_get')

build_api_func('/CONFIG/SET/<name>/', methods=['POST'], redispy_method='config_set')

build_api_func('/CONFIG/RESETSTAT/', methods=['POST'], redispy_method='config_resetstat')

build_api_func('/DBSIZE/')

build_api_func('/DEBUG/OBJECT/<key>', redispy_method='debug_object')

build_api_func('/ECHO/', methods=['POST'])

build_api_func('/FLUSHALL/', methods=['DELETE'])

build_api_func('/FLUSHDB/', methods=['DELETE'])

build_api_func(['/INFO/<section>', '/INFO/'])

build_api_func('/LASTSAVE/')

build_api_func('/OBJECT/<infotype>/<key>/')

build_api_func('/PING/')

build_api_func('/SAVE/')

build_api_func('/DUMP/<name>/')

build_api_func('/RESTORE/<name>/', methods=['POST'])

# Strings
build_api_func('/GET/<key>/')

build_api_func('/SET/<key>/', methods=['POST'])

build_api_func('/APPEND/<key>/', methods=['POST'])

build_api_func('/SETBIT/<name>/', methods=['POST'])

build_api_func(['/BITCOUNT/<key>/<start>/<end>/', '/BITCOUNT/<key>/'])

build_api_func('/BITOP/', methods=['POST'])

build_api_func(['/DECR/<name>/', '/DECRBY/<name>/'], methods=['POST'], redispy_method='decr')

build_api_func(['/DEL/<name>/', '/DEL/'], methods=['DELETE'], redispy_method='delete')

build_api_func('/EXISTS/<key>/')

build_api_func('/EXPIRE/<name>/', methods=['POST'])

build_api_func('/EXPIREAT/<name>/', methods=['POST'])

build_api_func('/TTL/<name>/')

build_api_func('/PEXPIRE/<name>/', methods=['POST'])

build_api_func('/PEXPIREAT/<name>/', methods=['POST'])

build_api_func('/PTTL/<name>/')

build_api_func('/PSETEX/<name>/', methods=['POST'])

build_api_func('/PERSIST/<name>/', methods=['POST'])

build_api_func('/GETBIT/<name>/<offset>/')

build_api_func('/GETRANGE/<key>/<start>/<end>/')

build_api_func('/GETSET/<name>/', methods=['POST'])

build_api_func(['/INCR/<name>/', '/INCRBY/<name>/'], methods=['POST'], redispy_method='incr')

build_api_func('/INCRBYFLOAT/<name>/', methods=['POST'])

build_api_func(['/KEYS/<pattern>/', '/KEYS/'], redispy_method='keys')

build_api_func('/MGET/')

build_api_func('/MSET/', methods=['POST'])

build_api_func('/MSETNX/', methods=['POST'])

build_api_func('/RANDOMKEY/')

build_api_func('/RENAME/', methods=['POST'])

build_api_func('/RENAMENX/', methods=['POST'])

build_api_func('/SETEX/<name>/', methods=['POST'])

build_api_func('/SETNX/<name>/', methods=['POST'])

build_api_func('/SETRANGE/<name>/', methods=['POST'])

build_api_func('/STRLEN/<name>/')

build_api_func(['/SUBSTR/<name>/<start>/<end>/', '/SUBSTR/<name>/<start>/'])

build_api_func('/TYPE/<name>/')

build_api_func('/BLPOP/', methods=['POST'])

build_api_func('/BRPOP/', methods=['POST'])

build_api_func('/BRPOPLPUSH/', methods=['POST'])

build_api_func('/LINDEX/<name>/<index>/')

build_api_func('/LINSERT/<name>/', methods=['POST'])

build_api_func('/LLEN/<name>/')

build_api_func('/LPOP/<name>/', methods=['POST'])

build_api_func('/LPUSH/<name>/', methods=['POST'])

build_api_func('/LPUSHX/<name>/', methods=['POST'])

build_api_func('/LRANGE/<name>/<start>/<end>/', )

build_api_func(['/LREM/<name>/<value>/<num>/', '/LREM/<name>/<value>/'], methods=['DELETE'])

build_api_func('/LSET/<name>/', methods=['POST'])

build_api_func('/LTRIM/<name>/<start>/<end>/', methods=['DELETE'])

build_api_func('/RPOP/<name>/', methods=['POST'])

build_api_func('/RPOPLPUSH/', methods=['POST'])

build_api_func('/RPUSH/<name>/', methods=['POST'])

build_api_func('/RPUSHX/<name>/', methods=['POST'])

build_api_func('/SORT/<name>/')

build_api_func('/SCAN/')

build_api_func('/SSCAN/<name>/')

build_api_func('/HSCAN/<name>/')

build_api_func('/ZSCAN/<name>/')

build_api_func('/SADD/<name>/', methods=['POST'])

build_api_func('/SMEMBERS/<name>/')

build_api_func('/SCARD/<name>/')

build_api_func('/SDIFF/')

build_api_func('/SDIFFSTORE/', methods=['POST'])

build_api_func('/SINTER/')

build_api_func('/SINTERSTORE/', methods=['POST'])

build_api_func('/SISMEMBER/<name>/<value>/')

build_api_func('/SMOVE/', methods=['POST'])

build_api_func('/SPOP/<name>/', methods=['POST'])

build_api_func(['/SRANDMEMBER/<name>/<number>/', '/SRANDMEMBER/<name>/'])

build_api_func('/SREM/<name>/', methods=['DELETE'])

build_api_func('/SUNION/')

build_api_func('/SUNIONSTORE/', methods=['POST'])

build_api_func('/ZADD/<name>/', methods=['POST'])

build_api_func('/ZCARD/<name>/')

build_api_func('/ZCOUNT/<name>/<min>/<max>/')

build_api_func('/ZINCRBY/<name>/', methods=['POST'])

build_api_func('/ZINTERSTORE/', methods=['POST'])

build_api_func('/ZRANGE/<name>/<start>/<end>/')

build_api_func('/ZRANGEBYSCORE/<name>/<min>/<max>/')

build_api_func('/ZREVRANGEBYSCORE/<name>/<min>/<max>/')

build_api_func('/ZRANK/<name>/<value>/')

build_api_func('/ZREVRANK/<name>/<value>/')

build_api_func('/ZREM/<name>/', methods=['DELETE'])

build_api_func('/ZREMRANGEBYRANK/<name>/<min>/<max>/', methods=['DELETE'])

build_api_func('/ZREMRANGEBYSCORE/<name>/<min>/<max>/', methods=['DELETE'])

build_api_func('/ZREVRANGE/<name>/<start>/<end>/')

build_api_func('/ZSCORE/<name>/<value>/')

build_api_func('/ZUNIONSTORE/', methods=['POST'])

build_api_func('/HGET/<name>/<key>/')

build_api_func('/HGETALL/<name>/')

build_api_func('/HEXISTS/<name>/<key>/')

build_api_func('/HDEL/<name>/', methods=['DELETE'])

build_api_func('/HINCRBY/<name>/<key>/', methods=['POST'])

build_api_func('/HINCRBYFLOAT/<name>/<key>/', methods=['POST'])

build_api_func('/HKEYS/<name>/')

build_api_func('/HLEN/<name>/')

build_api_func('/HSET/<name>/<key>/', methods=['POST'])

build_api_func('/HSETNX/<name>/', methods=['POST'])

build_api_func('/HMSET/<name>/', methods=['POST'])

build_api_func('/HMGET/<name>/')

build_api_func('/HVALS/<name>/')

urlpatterns = patterns('', *urlpatterns)

########NEW FILE########
__FILENAME__ = views
from django.conf import settings
from django.http import HttpResponse
import json
from redis.exceptions import DataError

from colander import Invalid
from lark.redis.client import RedisApiClient
from lark.ext.utils import json_dumps, RedisApiException


redis_connection = getattr(settings, 'REDIS_CONNECTION_METHOD', None)
if not redis_connection:
    raise Exception("Lark requires a way to connect to redis please set REDIS_CONNECTION_METHOD in your settings.py")

r = redis_connection()


class InvalidMethod(Exception):
    pass


def query_redis(request, *args, **kwargs):
    status_code = 200
    try:
        methods = kwargs.pop('methods', ['GET'])
        redis_method = kwargs.pop('redispy_method')
        if request.method not in methods:
            raise InvalidMethod()

        request_json = None
        if request.method == 'POST':
            try:
                request_json = json.loads(request.body.decode(encoding='UTF-8'))
            except:
                pass

        scopes = None
        default_scopes = getattr(settings, 'DEFAULT_LARK_SCOPES', set())

        scope_getter = getattr(settings, 'LARK_SCOPE_GETTER', None)
        if scope_getter:
            scopes = scope_getter(request, redis_method, request_json, request.GET, args, kwargs)

        if scopes is None:
            scopes = default_scopes

        data = RedisApiClient.from_request(redis_method, r, request_json, request.GET, args, kwargs, scopes)
        resp_envelope = {
            'meta': {
                'status': 'ok',
                'status_code': status_code,
            },
            'data': data,
        }
    except DataError, e:
        status_code = 400
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': status_code,
                'error_message': unicode(e)
            }
        }
    except Invalid, e:
        status_code = 400
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': status_code,
                'error_message': unicode(e)
            }
        }
    except RedisApiException, e:
        status_code = e.status_code
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': e.status_code,
                'error_message': unicode(e)
            }
        }

    except InvalidMethod, e:
        status_code = 405
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': 405,
                'error_message': '%s Invalid method should be one of %s' % (request.method, methods)
            }
        }

    except Exception, e:
        raise
        status_code = 500
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': 500,
                'error_message': 'unhandled error'
            }
        }

    resp_json = json_dumps.encode(resp_envelope)
    return HttpResponse(resp_json, content_type='application/json', status=status_code)

########NEW FILE########
__FILENAME__ = flask_redis
import redis
from flask import g


class Redis(object):

    def __init__(self, app=None):

        if app is not None:
            self.init_app(app)
        else:
            self.app = None

    def init_app(self, app):
        """
        Used to initialize redis with app object
        """

        app.config.setdefault('REDIS_URLS', {
            'main': 'redis://localhost:6379/0',
            'admin': 'redis://localhost:6379/1',
        })

        app.before_request(self.before_request)

        self.app = app

    _redis_connection = {}

    def connect(self, connection_type='main'):
        r_con = self._redis_connection.get(connection_type)
        if r_con:
            return r_con

        self._redis_connection[connection_type] = redis.Redis.from_url(self.app.config['REDIS_URLS'][connection_type])
        return self._redis_connection[connection_type]

    def before_request(self):
        g.r = self.connect()
        g.get_redis_connection = self.connect

########NEW FILE########
__FILENAME__ = redis_api
import functools
from redis.exceptions import DataError
from flask import Blueprint, make_response, g, request, current_app
from colander import Invalid
from lark.redis.client import RedisApiClient
from lark.ext.utils import json_dumps, RedisApiException

redis_api_blueprint = Blueprint('redis_api', __name__)


def query_redis(redispy_method, *args, **kwargs):
    status_code = 200
    try:
        try:
            request_json = request.get_json()
        except:
            request_json = None

        scopes = None
        default_scopes = current_app.config.get('DEFAULT_LARK_SCOPES', set())
        scope_getter = current_app.config.get('LARK_SCOPE_GETTER')
        if scope_getter:
            scopes = scope_getter(redispy_method, request_json, request.args, args, kwargs)

        if scopes is None:
            scopes = default_scopes

        data = RedisApiClient.from_request(redispy_method, g.r, request_json, request.args, args, kwargs, scopes)
        resp_envelope = {
            'meta': {
                'status': 'ok',
                'status_code': status_code,
            },
            'data': data,
        }
    except DataError, e:
        status_code = 400
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': status_code,
                'error_message': unicode(e)
            }
        }
    except Invalid, e:
        status_code = 400
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': status_code,
                'error_message': unicode(e)
            }
        }
    except RedisApiException, e:
        status_code = e.status_code
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': e.status_code,
                'error_message': unicode(e)
            }
        }

    except Exception, e:
        raise
        status_code = 500
        resp_envelope = {
            'meta': {
                'status': 'error',
                'status_code': 500,
                'error_message': 'unhandled error'
            }
        }

    resp_json = json_dumps.encode(resp_envelope)
    return make_response(resp_json, status_code, {
        'Content-Type': 'application/json',
    })


def build_api_func(routes, methods=['GET'], redispy_method=None):
    if isinstance(routes, basestring):
        routes = [routes]

    if not redispy_method:
        redispy_method = routes[0][1:].split('/')[0].lower()

    view_func = functools.partial(query_redis, redispy_method)

    for route in routes:
        redis_api_blueprint.add_url_rule(route, methods=methods, view_func=view_func, endpoint=redispy_method)
        redis_api_blueprint.add_url_rule(route.lower(), methods=methods, view_func=view_func, endpoint=redispy_method)


build_api_func('/BGREWRITEAOF/')

build_api_func('/BGSAVE/')

build_api_func('/CLIENT/LIST/', redispy_method='client_list')

build_api_func('/CLIENT/KILL/', methods=['POST'], redispy_method='client_kill')

build_api_func('/CLIENT/GETNAME/', redispy_method='client_getname')

build_api_func('/CLIENT/SETNAME/', methods=['POST'], redispy_method='client_setname')

build_api_func(['/CONFIG/GET/<pattern>', '/CONFIG/GET/'], redispy_method='config_get')

build_api_func('/CONFIG/SET/<name>/', methods=['POST'], redispy_method='config_set')

build_api_func('/CONFIG/RESETSTAT/', methods=['POST'], redispy_method='config_resetstat')

build_api_func('/DBSIZE/')

build_api_func('/DEBUG/OBJECT/<key>', redispy_method='debug_object')

build_api_func('/ECHO/', methods=['POST'])

build_api_func('/FLUSHALL/', methods=['DELETE'])

build_api_func('/FLUSHDB/', methods=['DELETE'])

build_api_func(['/INFO/<section>', '/INFO/'])

build_api_func('/LASTSAVE/')

build_api_func('/OBJECT/<infotype>/<key>/')

build_api_func('/PING/')

build_api_func('/SAVE/')

build_api_func('/DUMP/<name>/')

build_api_func('/RESTORE/<name>/', methods=['POST'])

# Strings
build_api_func('/GET/<key>/')

build_api_func('/SET/<key>/', methods=['POST'])

build_api_func('/APPEND/<key>/', methods=['POST'])

build_api_func('/SETBIT/<name>/', methods=['POST'])

build_api_func(['/BITCOUNT/<key>/<start>/<end>/', '/BITCOUNT/<key>/'])

build_api_func('/BITOP/', methods=['POST'])

build_api_func(['/DECR/<name>/', '/DECRBY/<name>/'], methods=['POST'], redispy_method='decr')

build_api_func(['/DEL/<name>/', '/DEL/'], methods=['DELETE'], redispy_method='delete')

build_api_func('/EXISTS/<key>/')

build_api_func('/EXPIRE/<name>/', methods=['POST'])

build_api_func('/EXPIREAT/<name>/', methods=['POST'])

build_api_func('/TTL/<name>/')

build_api_func('/PEXPIRE/<name>/', methods=['POST'])

build_api_func('/PEXPIREAT/<name>/', methods=['POST'])

build_api_func('/PTTL/<name>/')

build_api_func('/PSETEX/<name>/', methods=['POST'])

build_api_func('/PERSIST/<name>/', methods=['POST'])

build_api_func('/GETBIT/<name>/<offset>/')

build_api_func('/GETRANGE/<key>/<start>/<end>/')

build_api_func('/GETSET/<name>/', methods=['POST'])

build_api_func(['/INCR/<name>/', '/INCRBY/<name>/'], methods=['POST'], redispy_method='incr')

build_api_func('/INCRBYFLOAT/<name>/', methods=['POST'])

build_api_func(['/KEYS/<pattern>/', '/KEYS/'], redispy_method='keys')

build_api_func('/MGET/')

build_api_func('/MSET/', methods=['POST'])

build_api_func('/MSETNX/', methods=['POST'])

build_api_func('/RANDOMKEY/')

build_api_func('/RENAME/', methods=['POST'])

build_api_func('/RENAMENX/', methods=['POST'])

build_api_func('/SETEX/<name>/', methods=['POST'])

build_api_func('/SETNX/<name>/', methods=['POST'])

build_api_func('/SETRANGE/<name>/', methods=['POST'])

build_api_func('/STRLEN/<name>/')

build_api_func(['/SUBSTR/<name>/<start>/<end>/', '/SUBSTR/<name>/<start>/'])

build_api_func('/TYPE/<name>/')

build_api_func('/BLPOP/', methods=['POST'])

build_api_func('/BRPOP/', methods=['POST'])

build_api_func('/BRPOPLPUSH/', methods=['POST'])

build_api_func('/LINDEX/<name>/<index>/')

build_api_func('/LINSERT/<name>/', methods=['POST'])

build_api_func('/LLEN/<name>/')

build_api_func('/LPOP/<name>/', methods=['POST'])

build_api_func('/LPUSH/<name>/', methods=['POST'])

build_api_func('/LPUSHX/<name>/', methods=['POST'])

build_api_func('/LRANGE/<name>/<start>/<end>/', )

build_api_func(['/LREM/<name>/<value>/<num>/', '/LREM/<name>/<value>/'], methods=['DELETE'])

build_api_func('/LSET/<name>/', methods=['POST'])

build_api_func('/LTRIM/<name>/<start>/<end>/', methods=['DELETE'])

build_api_func('/RPOP/<name>/', methods=['POST'])

build_api_func('/RPOPLPUSH/', methods=['POST'])

build_api_func('/RPUSH/<name>/', methods=['POST'])

build_api_func('/RPUSHX/<name>/', methods=['POST'])

build_api_func('/SORT/<name>/')

build_api_func('/SCAN/')

build_api_func('/SSCAN/<name>/')

build_api_func('/HSCAN/<name>/')

build_api_func('/ZSCAN/<name>/')

build_api_func('/SADD/<name>/', methods=['POST'])

build_api_func('/SMEMBERS/<name>/')

build_api_func('/SCARD/<name>/')

build_api_func('/SDIFF/')

build_api_func('/SDIFFSTORE/', methods=['POST'])

build_api_func('/SINTER/')

build_api_func('/SINTERSTORE/', methods=['POST'])

build_api_func('/SISMEMBER/<name>/<value>/')

build_api_func('/SMOVE/', methods=['POST'])

build_api_func('/SPOP/<name>/', methods=['POST'])

build_api_func(['/SRANDMEMBER/<name>/<number>/', '/SRANDMEMBER/<name>/'])

build_api_func('/SREM/<name>/', methods=['DELETE'])

build_api_func('/SUNION/')

build_api_func('/SUNIONSTORE/', methods=['POST'])

build_api_func('/ZADD/<name>/', methods=['POST'])

build_api_func('/ZCARD/<name>/')

build_api_func('/ZCOUNT/<name>/<min>/<max>/')

build_api_func('/ZINCRBY/<name>/', methods=['POST'])

build_api_func('/ZINTERSTORE/', methods=['POST'])

build_api_func('/ZRANGE/<name>/<start>/<end>/')

build_api_func('/ZRANGEBYSCORE/<name>/<min>/<max>/')

build_api_func('/ZREVRANGEBYSCORE/<name>/<min>/<max>/')

build_api_func('/ZRANK/<name>/<value>/')

build_api_func('/ZREVRANK/<name>/<value>/')

build_api_func('/ZREM/<name>/', methods=['DELETE'])

build_api_func('/ZREMRANGEBYRANK/<name>/<min>/<max>/', methods=['DELETE'])

build_api_func('/ZREMRANGEBYSCORE/<name>/<min>/<max>/', methods=['DELETE'])

build_api_func('/ZREVRANGE/<name>/<start>/<end>/')

build_api_func('/ZSCORE/<name>/<value>/')

build_api_func('/ZUNIONSTORE/', methods=['POST'])

build_api_func('/HGET/<name>/<key>/')

build_api_func('/HGETALL/<name>/')

build_api_func('/HEXISTS/<name>/<key>/')

build_api_func('/HDEL/<name>/', methods=['DELETE'])

build_api_func('/HINCRBY/<name>/<key>/', methods=['POST'])

build_api_func('/HINCRBYFLOAT/<name>/<key>/', methods=['POST'])

build_api_func('/HKEYS/<name>/')

build_api_func('/HLEN/<name>/')

build_api_func('/HSET/<name>/<key>/', methods=['POST'])

build_api_func('/HSETNX/<name>/', methods=['POST'])

build_api_func('/HMSET/<name>/', methods=['POST'])

build_api_func('/HMGET/<name>/')

build_api_func('/HVALS/<name>/')

########NEW FILE########
__FILENAME__ = utils
import datetime
import json
import random
import string


class RedisApiException(Exception):

    def __init__(self, message, status_code, *args, **kwargs):
        super(RedisApiException, self).__init__(message)
        self.status_code = status_code


class DateTimeJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime.datetime):
            return obj.isoformat()

        if isinstance(obj, set):
            return list(obj)

        if obj and hasattr(obj, 'to_json'):
            obj = obj.to_json()

        return super(DateTimeJSONEncoder, self).default(obj)

json_dumps = DateTimeJSONEncoder()


def generate_random_string(length=13, chars=string.ascii_letters + string.digits, ):
    return ''.join(random.choice(chars) for i in range(length))

########NEW FILE########
__FILENAME__ = client
from collections import namedtuple
import schemas


DEFAULT_INBOUND_SCHEMA = schemas.NoSchema
DEFAULT_OUTBOUND_SCHEMA = schemas.OutboundResultSchema


class RedisApiClientException(Exception):
    pass


class RedisApiClientAuthException(RedisApiClientException):
    pass


class RedisApiClient(object):

    @classmethod
    def from_request(cls, redis_method, r, request_json, get_query_dict, url_args, url_kwargs, request_scopes=set([])):
        redis_api_client = cls()

        # Check that method exisits
        try:
            redis_method_def = getattr(redis_api_client, redis_method)
        except AttributeError:
            raise RedisApiClientException('%s is not a redis method' % redis_method)

        # Check scopes
        has_scopes = request_scopes & redis_method_def.scopes
        if len(has_scopes) == 0:
            raise RedisApiClientAuthException('Request has %s scopes and is required to have at least one of %s scopes' % (request_scopes, redis_method_def.scopes))

        # Parse request for redis args
        redis_args, redis_kwargs = redis_api_client.get_signature_from_request(redis_method_def, request_json, get_query_dict, url_args, url_kwargs)

        # Execute redis method
        data = getattr(r, redis_method)(*redis_args, **redis_kwargs)

        # Transform redis data into outbounc data format
        response_data = redis_api_client.format_redis_response_for_http(redis_method_def, data)

        return response_data

    def get_signature_from_request(self, redis_method_def, request_json, get_query_dict, url_args, url_kwargs):
        # print 'args %s', % list(url_args)
        # print 'kwargs %s', % url_kwargs
        # print 'request.args %s', % get_query_dict
        # print 'request_json %s', % request_json

        InboundSchema = redis_method_def.inbound

        args, kwargs = InboundSchema.from_request(url_args, url_kwargs, get_query_dict, request_json)
        return (args, kwargs)

    def format_redis_response_for_http(self, redis_method_def, data):
        data = redis_method_def.outbound.serialize(data)

        return data


_RedisMethodDef = namedtuple('RedisMethodDef', 'method inbound outbound cmd_type write read')


class RedisMethodDef(_RedisMethodDef):

    @classmethod
    def from_kwargs(cls, method, inbound, outbound, cmd_type, write, read):
        if write == read:
            raise Exception("Command %s has to be write or read" % (cmd_type))

        return cls(inbound, outbound)

    @property
    def scopes(self):
        scopes = set(['admin'])
        if self.cmd_type != 'admin':
            scopes.add('%s:*' % self.cmd_type)

        if self.read:
            scopes.add('read:*')
            scopes.add('read:%s' % (self.method))

        if self.write:
            scopes.add('write:*')
            scopes.add('write:%s' % (self.method))

        return scopes


def bind_api_method(method, inbound=DEFAULT_INBOUND_SCHEMA, outbound=DEFAULT_OUTBOUND_SCHEMA, cmd_type='admin', write=False, read=False):
    redis_method_def = RedisMethodDef(method, inbound, outbound, cmd_type, write, read)

    def run(self, *args, **kwargs):
        return redis_method_def

    ctx = {
        'cmd': method,
        'scopes': ', '.join(map(lambda x: '**%s**' % x, list(redis_method_def.scopes))),
    }
    doc = """
    redis docs for `%(cmd)s <http://redis.io/commands/%(cmd)s>`_

    Requires one of these scopes: %(scopes)s

    """ % ctx

    run.__doc__ = doc
    run = property(run)
    setattr(RedisApiClient, method, run)


# Admin commands
bind_api_method('bgrewriteaof', write=True)
bind_api_method('client_list', read=True)
bind_api_method('bgsave', write=True)
bind_api_method('client_getname', read=True)
bind_api_method('client_setname', write=True, inbound=schemas.NameSchema)
bind_api_method('client_kill', write=True, inbound=schemas.AddressSchema)
bind_api_method('config_get', inbound=schemas.PatternSchema)
bind_api_method('config_set', inbound=schemas.NameValueSchema)
bind_api_method('config_resetstat', write=True)
bind_api_method('dbsize', read=True)
bind_api_method('flushall', write=True)
bind_api_method('flushdb', write=True)
bind_api_method('lastsave', read=True)
bind_api_method('save', write=True)
bind_api_method('debug_object', read=True, inbound=schemas.KeySchema)
bind_api_method('object', read=True, inbound=schemas.InfotypeKeyScheam)
bind_api_method('info', read=True, inbound=schemas.SectionSchema)
bind_api_method('ping', cmd_type='basic', read=True)
bind_api_method('echo', cmd_type='basic', read=True, inbound=schemas.ValueSchema)
bind_api_method('dump', read=True, inbound=schemas.NameSchema, outbound=schemas.OutBoundBinaryValueSchema)
bind_api_method('restore', write=True, inbound=schemas.NameTtlBinValueSchema)

# Keys
bind_api_method('randomkey', cmd_type='key', read=True)
bind_api_method('get', cmd_type='key', read=True, inbound=schemas.KeySchema, outbound=schemas.OutboundValueSchema)
bind_api_method('set', cmd_type='key', write=True, inbound=schemas.SetSchema)
bind_api_method('append', cmd_type='key', write=True, inbound=schemas.KeyValueSchema)
bind_api_method('setbit', cmd_type='key', write=True, inbound=schemas.NameOffsetBoolValueSchema)
bind_api_method('bitcount', cmd_type='key', read=True, inbound=schemas.KeyRangeOptionalSchema)
bind_api_method('bitop', cmd_type='key', write=True, inbound=schemas.OperationDestKeysSchema)
bind_api_method('decr', cmd_type='key', write=True, inbound=schemas.NameAmountSchema)
bind_api_method('delete', cmd_type='key', write=True, inbound=schemas.NamesSchema)
bind_api_method('exists', cmd_type='key', read=True, inbound=schemas.KeySchema)
bind_api_method('expire', cmd_type='key', write=True, inbound=schemas.NameTimeSchema)
bind_api_method('expireat', cmd_type='key', write=True, inbound=schemas.NameWhenSchema)
bind_api_method('ttl', cmd_type='key', read=True, inbound=schemas.NameSchema)
bind_api_method('pexpire', cmd_type='key', write=True, inbound=schemas.NameTimeSchema)
bind_api_method('pexpireat', cmd_type='key', write=True, inbound=schemas.NameWhenSchema)
bind_api_method('pttl', cmd_type='key', read=True, inbound=schemas.NameSchema)
bind_api_method('psetex', cmd_type='key', write=True, inbound=schemas.NameTimeMsValueSchema)
bind_api_method('persist', cmd_type='key', write=True, inbound=schemas.NameSchema)
bind_api_method('getbit', cmd_type='key', read=True, inbound=schemas.NameOffsetSchema)
bind_api_method('getrange', cmd_type='key', read=True, inbound=schemas.KeyRangeSchema)
bind_api_method('getset', cmd_type='key', read=True, inbound=schemas.NameValueSchema)
bind_api_method('incr', cmd_type='key', write=True, inbound=schemas.NameAmountSchema, outbound=schemas.OutboundResultSchema)
bind_api_method('incrbyfloat', cmd_type='key', inbound=schemas.NameFloatAmountSchema, outbound=schemas.OutboundResultSchema)
bind_api_method('keys', cmd_type='key', read=True, inbound=schemas.PatternSchema)
bind_api_method('mget', cmd_type='key', read=True, inbound=schemas.KeyListSchema)
bind_api_method('mset', cmd_type='key', write=True, inbound=schemas.NameValueListSchema, outbound=schemas.OutboundValueSchema)
bind_api_method('msetnx', cmd_type='key', write=True, inbound=schemas.NameValueListSchema, outbound=schemas.OutboundValueSchema)
bind_api_method('rename', cmd_type='key', write=True, inbound=schemas.SrcDstSchema)
bind_api_method('renamenx', cmd_type='key', write=True, inbound=schemas.SrcDstSchema)
bind_api_method('setex', cmd_type='key', write=True, inbound=schemas.NameValueTimeSchema, outbound=schemas.OutboundValueSchema)
bind_api_method('setnx', cmd_type='key', write=True, inbound=schemas.NameValueSchema, outbound=schemas.OutboundValueSchema)
bind_api_method('setrange', cmd_type='key', inbound=schemas.NameOffsetStrValueSchema)
bind_api_method('strlen', cmd_type='key', read=True, inbound=schemas.NameSchema)
bind_api_method('substr', cmd_type='key', read=True, inbound=schemas.NameRangeEndOptionalSchema, outbound=schemas.OutboundValueSchema)
bind_api_method('type', cmd_type='key', read=True, inbound=schemas.NameSchema)

# Lists
bind_api_method('blpop', cmd_type='list', write=True, inbound=schemas.KeysTimeoutSchema)
bind_api_method('brpop', cmd_type='list', write=True, inbound=schemas.KeysTimeoutSchema)
bind_api_method('brpoplpush', cmd_type='list', write=True, inbound=schemas.SrcDstTimeoutSchema)
bind_api_method('lindex', cmd_type='list', read=True, inbound=schemas.NameIndexSchema)
bind_api_method('linsert', cmd_type='list', write=True, inbound=schemas.NameWhereRefValueValueSchema)
bind_api_method('llen', cmd_type='list', read=True, inbound=schemas.NameSchema)
bind_api_method('lpop', cmd_type='list', write=True, inbound=schemas.NameSchema)
bind_api_method('lpush', cmd_type='list', write=True, inbound=schemas.NameValuesSchema)
bind_api_method('lpushx', cmd_type='list', write=True, inbound=schemas.NameValueSchema)
bind_api_method('lrange', cmd_type='list', read=True, inbound=schemas.NameRangeSchema)
bind_api_method('lrem', cmd_type='list', write=True, inbound=schemas.NameNumValueSchema)
bind_api_method('lset', cmd_type='list', write=True, inbound=schemas.NameIndexValueSchema)
bind_api_method('ltrim', cmd_type='list', write=True, inbound=schemas.NameRangeSchema)
bind_api_method('rpop', cmd_type='list', write=True, inbound=schemas.NameSchema)
bind_api_method('rpoplpush', cmd_type='list', write=True, inbound=schemas.SrcDstSchema)
bind_api_method('rpush', cmd_type='list', write=True, inbound=schemas.NameValuesSchema)
bind_api_method('rpushx', cmd_type='list', write=True, inbound=schemas.NameValueSchema)

# Sorting
bind_api_method('sort', cmd_type='sort', write=True, inbound=schemas.SortSchema)

# Scaning
bind_api_method('scan', cmd_type='scan', read=True, inbound=schemas.ScanSchema)
bind_api_method('sscan', cmd_type='scan', read=True, inbound=schemas.NameScanSchema)
bind_api_method('hscan', cmd_type='scan', read=True, inbound=schemas.NameScanSchema)
bind_api_method('zscan', cmd_type='scan', read=True, inbound=schemas.NameScanSchema)

# Sets
bind_api_method('sadd', cmd_type='sets', write=True, inbound=schemas.NameValuesSchema)
bind_api_method('smembers', cmd_type='sets', read=True, inbound=schemas.NameSchema)
bind_api_method('scard', cmd_type='sets', read=True, inbound=schemas.NameSchema)
bind_api_method('sdiff', cmd_type='sets', read=True, inbound=schemas.KeysSchema)
bind_api_method('sdiffstore', cmd_type='sets', write=True, inbound=schemas.DestKeysSchema)
bind_api_method('sinter', cmd_type='sets', read=True, inbound=schemas.KeysSchema)
bind_api_method('sinterstore', cmd_type='sets', write=True, inbound=schemas.DestKeysSchema)
bind_api_method('sismember', cmd_type='sets', read=True, inbound=schemas.NameValueSchema)
bind_api_method('smove', cmd_type='sets', write=True, inbound=schemas.SrcDstValueSchema)
bind_api_method('spop', cmd_type='sets', write=True, inbound=schemas.NameSchema)
bind_api_method('srandmember', cmd_type='sets', read=True, inbound=schemas.NameNumberSchema)
bind_api_method('srem', cmd_type='sets', write=True, inbound=schemas.RemNameValueListSchema)
bind_api_method('sunion', cmd_type='sets', read=True, inbound=schemas.KeysSchema)
bind_api_method('sunionstore', cmd_type='sets', write=True, inbound=schemas.DestKeysSchema)

# Sorted Sets
bind_api_method('zadd', cmd_type='sorted_sets', write=True, inbound=schemas.NameScoreListSchema)
bind_api_method('zcard', cmd_type='sorted_sets', read=True, inbound=schemas.NameSchema)
bind_api_method('zcount', cmd_type='sorted_sets', read=True, inbound=schemas.NameMinMaxSchema)
bind_api_method('zincrby', cmd_type='sorted_sets', write=True, inbound=schemas.NameValueAmount)
bind_api_method('zinterstore', cmd_type='sorted_sets', write=True, inbound=schemas.DestKeysAggregateSchema)
bind_api_method('zrange', cmd_type='sorted_sets', read=True, inbound=schemas.ZrangeSchema)
bind_api_method('zrangebyscore', cmd_type='sorted_sets', read=True, inbound=schemas.ZrangeByScoresSchema)
bind_api_method('zrevrangebyscore', cmd_type='sorted_sets', read=True, inbound=schemas.ZrangeByScoresSchema)
bind_api_method('zrank', cmd_type='sorted_sets', read=True, inbound=schemas.NameValueSchema)
bind_api_method('zrevrank', cmd_type='sorted_sets', read=True, inbound=schemas.NameValueSchema)
bind_api_method('zrem', cmd_type='sorted_sets', write=True, inbound=schemas.RemNameValueListSchema)
bind_api_method('zremrangebyrank', cmd_type='sorted_sets', inbound=schemas.NameMinMaxSchema)
bind_api_method('zremrangebyscore', cmd_type='sorted_sets', inbound=schemas.NameMinMaxSchema)
bind_api_method('zrevrange', cmd_type='sorted_sets', read=True, inbound=schemas.ZrevRangeSchema)
bind_api_method('zscore', cmd_type='sorted_sets', read=True, inbound=schemas.NameValueSchema)
bind_api_method('zunionstore', cmd_type='sorted_sets', inbound=schemas.DestKeysAggregateSchema)

# Hashes
bind_api_method('hget', cmd_type='hashes', read=True, inbound=schemas.NameKeySchema)
bind_api_method('hgetall', cmd_type='hashes', read=True, inbound=schemas.NameSchema)
bind_api_method('hexists', cmd_type='hashes', read=True, inbound=schemas.NameKeySchema)
bind_api_method('hdel', cmd_type='hashes', write=True, inbound=schemas.NameKeysSchema)
bind_api_method('hincrby', cmd_type='hashes', write=True, inbound=schemas.NameKeyAmountSchema)
bind_api_method('hincrbyfloat', cmd_type='hashes', write=True, inbound=schemas.NameKeyFloatAmountSchema)
bind_api_method('hkeys', cmd_type='hashes', read=True, inbound=schemas.NameSchema)
bind_api_method('hlen', cmd_type='hashes', read=True, inbound=schemas.NameSchema)
bind_api_method('hset', cmd_type='hashes', write=True, inbound=schemas.NameKeyValueSchema)
bind_api_method('hsetnx', cmd_type='hashes', write=True, inbound=schemas.NameKeyValueSchema)
bind_api_method('hmset', cmd_type='hashes', write=True, inbound=schemas.NameMapingSchema)
bind_api_method('hmget', cmd_type='hashes', read=True, inbound=schemas.NameKeyListSchema)
bind_api_method('hvals', cmd_type='hashes', read=True, inbound=schemas.NameSchema)

########NEW FILE########
__FILENAME__ = schemas
import collections
import colander
import json


def valid_key(key):
    if key:
        return key
    return False


class SchemaAdapterMixin(object):

    def from_request(self, args=None, kwargs=None, query_dict=None, request_json=None, key_prefix=None):
        list_args = []
        redis_args = []
        redis_kwargs = []
        names = []
        for node in self.children:
            names.append(node.name)
            if isinstance(node.typ, colander.Sequence):
                list_args.append(node.name)

            if node.required:
                redis_args.append(node.name)
            else:
                redis_kwargs.append(node.name)

        cstruct = dict(zip(names, args))
        for arg in redis_args:
            if query_dict.get(arg):
                cstruct[arg] = query_dict.get(arg)

        for arg in redis_kwargs:
            if query_dict.get(arg):
                cstruct[arg] = query_dict.get(arg)

        if kwargs:
            cstruct.update(kwargs)

        if request_json:
            cstruct.update(request_json)

        for name in list_args:
            if query_dict.getlist(name):
                cstruct[name] = query_dict.getlist(name)

        # print "Going to deserialize: %s" % (cstruct)
        schema_instance = self.clone()
        schema_instance.redis_prefix = key_prefix
        data = schema_instance.deserialize(cstruct)
        # print "deserialized data: %s redis_args: %s redis_kwargs: %s" % (data, redis_args, redis_kwargs)
        args, kwargs = schema_instance.signature_from_cstruct(data, redis_args, redis_kwargs)

        return (args, kwargs)

    def signature_from_cstruct(self, cstruct, redis_args, redis_kwargs):
        args = [cstruct[arg] for arg in redis_args]
        kwargs = dict((arg, cstruct.get(arg)) for arg in redis_kwargs)
        return (args, kwargs)


class StringBool(colander.Bool):
    def __init__(self, default=False):
        self.default = default

    def deserialize(self, node, cstruct):
        if not cstruct:
            return self.default

        cstruct = unicode(cstruct)
        cstruct = cstruct.lower()

        if cstruct == 'true' or cstruct == '1':
            return True

        if cstruct == 'false' or cstruct == '0':
            return False

        return self.default


# Our strings can be a blank value
# They can be integers
# Whatever we get returned from redis is what we want to transmit
class LarkString(colander.String):

    def deserialize(self, node, cstruct):
        if cstruct == '':
            return cstruct

        if isinstance(cstruct, basestring):
            return cstruct

        if isinstance(cstruct, int) or isinstance(cstruct, float):
            return unicode(cstruct)

        return super(LarkString, self).deserialize(node, cstruct)

    def serialize(self, node, appstruct):
        return appstruct


# This is a type that is a reference in to a key, or name in redis.
# So, this would
class RedisReferenceType(LarkString):
    pass


# This is a type that is a reference in to a key, or name in redis.
# So, this would
class BinaryValueType(LarkString):
    def deserialize(self, node, cstruct):
        cstruct = super(BinaryValueType, self).deserialize(node, cstruct)
        return cstruct.decode('base64')

    def serialize(self, node, appstruct):
        return appstruct.encode('base64')


# For some keys in redis I want to be able to prefix them transparently from the user
# That way many users can share the same redis DB
class PrefixedRedisReferenceType(RedisReferenceType):
    def deserialize(self, node, cstruct):
        cstruct = super(PrefixedRedisReferenceType, self).deserialize(node, cstruct)
        if not cstruct:
            return cstruct

        prefix = getattr(node, 'redis_prefix', None)

        if prefix:
            cstruct = u'%s:%s' % (prefix, cstruct)

        return cstruct

    def serialize(self, node, appstruct):
        appstruct = super(PrefixedRedisReferenceType, self).serialize(node, appstruct)
        prefix = getattr(node, 'redis_prefix', None)
        if prefix and appstruct.startswith(prefix):
            appstruct = appstruct.replace(prefix + ':', '', 1)

        return appstruct


# Turn any incoming value into JSON
# Turn any outgoing value into python
class RedisValueType(LarkString):
    def deserialize(self, node, cstruct):
        if cstruct is not None:
            if isinstance(cstruct, basestring):
                return cstruct

            if isinstance(cstruct, dict) or isinstance(cstruct, collections.Iterable):
                cstruct = json.dumps(cstruct)

            return cstruct

        return super(RedisValueType, self).deserialize(node, cstruct)

    def serialize(self, node, appstruct):
        if not appstruct:
            return appstruct

        if appstruct == '':
            return appstruct

        if not isinstance(appstruct, basestring):
            return appstruct

        if appstruct[0] != '{':
            return appstruct

        return json.loads(appstruct)


# Noop type just returns the app struct it's handed
class NoopType(colander.SchemaType):
    def serialize(self, node, appstruct):
        return appstruct

    def deserialize(self, node, cstruct):
        return cstruct


# Outbound types for things from redis to the user
class OutboundType(colander.Mapping):
    def __init__(self, *args, **kwargs):
        super(OutboundType, self).__init__(unknown='preserve')


class OutboundMappingSchema(colander.MappingSchema):
    schema_type = OutboundType


class OutboundSequenceSchema(colander.SequenceSchema):
    value = colander.SchemaNode(RedisValueType())


OutboundValueSchema = colander.SchemaNode(RedisValueType())
OutboundResultSchema = colander.SchemaNode(NoopType())
OutBoundBinaryValueSchema = colander.SchemaNode(BinaryValueType())


class OutboundKeyValueListSchema(colander.TupleSchema):
    name = colander.SchemaNode(RedisReferenceType())
    value = colander.SchemaNode(RedisValueType())


# Schema
class OutboundValueListSchema(colander.SequenceSchema):
    value = OutboundValueSchema


# Scheam
class OutboundSortSchema(colander.Schema):
    schema_type = NoopType

    def serialize(self, node, appstruct):
        if len(appstruct) == 0:
            return appstruct

        if isinstance(appstruct[0], collections.Iterable):
            return OutboundKeyValueListSchema().serialize(appstruct)
        else:
            return OutboundValueListSchema().serialize(appstruct)


# Type
class LarkMappingSchema(colander.Mapping):
    def serialize(self, node, appstruct):
        if appstruct is colander.null:
            return colander.null

        def callback(subnode, subappstruct):
            subnode.redis_prefix = node.redis_prefix
            return subnode.serialize(subappstruct)

        return self._impl(node, appstruct, callback)

    def deserialize(self, node, cstruct, accept_scalar=None):
        if cstruct is colander.null:
            return colander.null

        def callback(subnode, subcstruct):
            subnode.redis_prefix = node.redis_prefix
            return subnode.deserialize(subcstruct)

        return self._impl(node, cstruct, callback)


# Type
class LarkSequenceSchema(colander.Sequence):
    def serialize(self, node, appstruct, accept_scalar=None):
        if appstruct is colander.null:
            return colander.null

        def callback(subnode, subappstruct):
            subnode.redis_prefix = node.redis_prefix
            return subnode.serialize(subappstruct)

        return self._impl(node, appstruct, callback, accept_scalar)

    def deserialize(self, node, cstruct, accept_scalar=None):
        if cstruct is colander.null:
            return colander.null

        def callback(subnode, subcstruct):
            subnode.redis_prefix = node.redis_prefix
            return subnode.deserialize(subcstruct)

        return self._impl(node, cstruct, callback, accept_scalar)


class LarkSchemaNode(SchemaAdapterMixin, colander.SchemaNode):
    pass

lark_string = LarkString()
ref_type = RedisReferenceType()
name_ref_type = PrefixedRedisReferenceType()
value_type = RedisValueType()
int_type = colander.Integer()
float_type = colander.Float()
bool_type = colander.Boolean()
datetime_type = colander.DateTime()
string_bool = StringBool()
bin_type = BinaryValueType()


def node(schema, *args, **kwargs):
    schema.add(colander.SchemaNode(*args, **kwargs))


NameValueTupleSchema = colander.SchemaNode(colander.Tuple())
NameValueTupleSchema.add(colander.SchemaNode(name_ref_type, name='name'))
NameValueTupleSchema.add(colander.SchemaNode(value_type, name='value'))


class NameValueListSchemaNode(LarkSchemaNode):

    def from_request(self, args=None, kwargs=None, query_dict=None, request_json=None, redis_prefix=None):
        cstruct = {
            'value': request_json
        }
        # print "Going to deserialize: %s" % (cstruct)
        self.redis_prefix = redis_prefix
        data = self.deserialize(cstruct)
        args, kwargs = self.signature_from_cstruct(data)

        return (args, kwargs)

    def signature_from_cstruct(self, cstruct):
        values = cstruct['value']
        return ([], dict(values))


NameValueListSchema = NameValueListSchemaNode(LarkMappingSchema())
NameValueListSchema.add(LarkSchemaNode(colander.Sequence(), NameValueTupleSchema, name='value'))


NameScoreTupleSchema = colander.SchemaNode(colander.Tuple())
NameScoreTupleSchema.add(colander.SchemaNode(lark_string, name='name'))
NameScoreTupleSchema.add(colander.SchemaNode(lark_string, name='score'))


class NameScoreListSchemaNode(LarkSchemaNode):

    def signature_from_cstruct(self, cstruct, redis_args, redis_kwargs):
        name = cstruct['name']
        scores = cstruct['scores']
        return ([name], dict(scores))


NameScoreListSchema = NameScoreListSchemaNode(LarkMappingSchema())
NameScoreListSchema.add(LarkSchemaNode(name_ref_type, name='name'))
NameScoreListSchema.add(LarkSchemaNode(colander.Sequence(), NameValueTupleSchema, name='scores'))


NoSchema = LarkSchemaNode(LarkMappingSchema())


AddressSchema = LarkSchemaNode(LarkMappingSchema())
node(AddressSchema, lark_string, name='address')


InfotypeKeyScheam = LarkSchemaNode(LarkMappingSchema())
node(InfotypeKeyScheam, lark_string, name='infotype')
node(InfotypeKeyScheam, name_ref_type, name='key')


NameSchema = LarkSchemaNode(LarkMappingSchema())
node(NameSchema, name_ref_type, name='name')


class NamesSchemaNode(LarkSchemaNode):
    def signature_from_cstruct(self, cstruct, redis_args, redis_kwargs):
        return (cstruct['name'], {})


NamesSchema = NamesSchemaNode(LarkMappingSchema())
NamesSchema.add(LarkSchemaNode(colander.Sequence(accept_scalar=True), LarkSchemaNode(name_ref_type), name='name'))


PatternSchema = LarkSchemaNode(LarkMappingSchema())
node(PatternSchema, name_ref_type, name='pattern', missing='*')

KeySchema = LarkSchemaNode(LarkMappingSchema())
node(KeySchema, name_ref_type, name='key')


class KeySchemaNode(LarkSchemaNode):

    def signature_from_cstruct(self, cstruct, redis_args, redis_kwargs):
        return (cstruct['key'], {})


KeysSchema = KeySchemaNode(LarkMappingSchema())
KeysSchema.add(LarkSchemaNode(colander.Sequence(), LarkSchemaNode(name_ref_type), name='key'))

KeyListSchema = LarkSchemaNode(LarkMappingSchema())
KeyListSchema.add(LarkSchemaNode(colander.Sequence(), LarkSchemaNode(name_ref_type), name='key'))

KeysTimeoutSchema = LarkSchemaNode(LarkMappingSchema())
KeysTimeoutSchema.add(LarkSchemaNode(colander.Sequence(), LarkSchemaNode(name_ref_type), name='keys'))
node(KeysTimeoutSchema, int_type, name='timeout')

ValueSchema = LarkSchemaNode(LarkMappingSchema())
node(ValueSchema, value_type, name='value')


NameAmountSchema = LarkSchemaNode(LarkMappingSchema())
node(NameAmountSchema, name_ref_type, name='name')
node(NameAmountSchema, name_ref_type, name='amount', missing=1)

NameFloatAmountSchema = LarkSchemaNode(LarkMappingSchema())
node(NameFloatAmountSchema, name_ref_type, name='name')
node(NameFloatAmountSchema, float_type, name='amount', missing=1.0)


SectionSchema = LarkSchemaNode(LarkMappingSchema())
node(SectionSchema, lark_string, name='section', missing=None)


NameTimeSchema = LarkSchemaNode(LarkMappingSchema())
node(NameTimeSchema, name_ref_type, name='name')
node(NameTimeSchema, int_type, missing=None, name='time')


NameValueTimeSchema = LarkSchemaNode(LarkMappingSchema())
node(NameValueTimeSchema, name_ref_type, name='name')
node(NameValueTimeSchema, value_type, name='value')
node(NameValueTimeSchema, int_type, name='time')


NameTimeMsValueSchema = LarkSchemaNode(LarkMappingSchema())
node(NameTimeMsValueSchema, name_ref_type, name='name')
node(NameTimeMsValueSchema, int_type, name='time_ms')
node(NameTimeMsValueSchema, value_type, name='value')


NameOffsetSchema = LarkSchemaNode(LarkMappingSchema())
node(NameOffsetSchema, name_ref_type, name='name')
node(NameOffsetSchema, int_type, name='offset')


NameOffsetBoolValueSchema = LarkSchemaNode(LarkMappingSchema())
node(NameOffsetBoolValueSchema, name_ref_type, name='name')
node(NameOffsetBoolValueSchema, int_type, name='offset')
node(NameOffsetBoolValueSchema, bool_type, name='value')


NameOffsetStrValueSchema = LarkSchemaNode(LarkMappingSchema())
node(NameOffsetStrValueSchema, name_ref_type, name='name')
node(NameOffsetStrValueSchema, int_type, name='offset')
node(NameOffsetStrValueSchema, lark_string, name='value')


NameValueSchema = LarkSchemaNode(LarkMappingSchema())
node(NameValueSchema, name_ref_type, name='name')
node(NameValueSchema, value_type, name='value')


class NameValuesSchemaNode(LarkSchemaNode):

    def signature_from_cstruct(self, cstruct, redis_args, redis_kwargs):
        name = cstruct['name']
        values = cstruct['values']
        return ([name] + values, {})


NameValuesSchema = NameValuesSchemaNode(LarkMappingSchema())
node(NameValuesSchema, name_ref_type, name='name')
NameValuesSchema.add(LarkSchemaNode(colander.Sequence(), LarkSchemaNode(value_type), name='values'))


class RemNameValueListSchemaNode(LarkSchemaNode):

    def signature_from_cstruct(self, cstruct, redis_args, redis_kwargs):
        name = cstruct['name']
        values = cstruct['value']
        return ([name] + values, {})


RemNameValueListSchema = RemNameValueListSchemaNode(LarkMappingSchema())
node(RemNameValueListSchema, name_ref_type, name='name')
RemNameValueListSchema.add(LarkSchemaNode(colander.Sequence(), LarkSchemaNode(value_type), name='value'))


NameWhenSchema = LarkSchemaNode(LarkMappingSchema())
node(NameWhenSchema, name_ref_type, name='name')
node(NameWhenSchema, datetime_type, name='when')


KeyValueSchema = LarkSchemaNode(LarkMappingSchema())
node(KeyValueSchema, name_ref_type, name='key')
node(KeyValueSchema, value_type, name='value')


SetSchema = LarkSchemaNode(LarkMappingSchema())
node(SetSchema, name_ref_type, name='key')
node(SetSchema, value_type, name='value')
node(SetSchema, int_type, name='ex', missing=None)
node(SetSchema, int_type, name='px', missing=None)
node(SetSchema, bool_type, name='nx', missing=False)
node(SetSchema, bool_type, name='xx', missing=False)


KeyRangeSchema = LarkSchemaNode(LarkMappingSchema())
node(KeyRangeSchema, name_ref_type, name='key')
node(KeyRangeSchema, int_type, name='start')
node(KeyRangeSchema, int_type, name='end')


KeyRangeOptionalSchema = LarkSchemaNode(LarkMappingSchema())
node(KeyRangeOptionalSchema, name_ref_type, name='key')
node(KeyRangeOptionalSchema, int_type, name='start', missing=None)
node(KeyRangeOptionalSchema, int_type, name='end', missing=None)


NameRangeSchema = LarkSchemaNode(LarkMappingSchema())
node(NameRangeSchema, name_ref_type, name='name')
node(NameRangeSchema, int_type, name='start')
node(NameRangeSchema, int_type, name='end')


NameRangeEndOptionalSchema = LarkSchemaNode(LarkMappingSchema())
node(NameRangeEndOptionalSchema, name_ref_type, name='name')
node(NameRangeEndOptionalSchema, int_type, name='start')
node(NameRangeEndOptionalSchema, int_type, name='end', missing=-1)


SrcDstSchema = LarkSchemaNode(LarkMappingSchema())
node(SrcDstSchema, name_ref_type, name='src')
node(SrcDstSchema, name_ref_type, name='dst')


SrcDstValueSchema = LarkSchemaNode(LarkMappingSchema())
node(SrcDstValueSchema, name_ref_type, name='src')
node(SrcDstValueSchema, name_ref_type, name='dst')
node(SrcDstValueSchema, value_type, name='value')


SrcDstTimeoutSchema = LarkSchemaNode(LarkMappingSchema())
node(SrcDstTimeoutSchema, name_ref_type, name='src')
node(SrcDstTimeoutSchema, name_ref_type, name='dst')
node(SrcDstTimeoutSchema, int_type, name='timeout', missing=0)


NameIndexSchema = LarkSchemaNode(LarkMappingSchema())
node(NameIndexSchema, name_ref_type, name='name')
node(NameIndexSchema, int_type, name='index')


NameNumValueSchema = LarkSchemaNode(LarkMappingSchema())
node(NameNumValueSchema, name_ref_type, name='name')
node(NameNumValueSchema, int_type, name='num', missing=0)
node(NameNumValueSchema, value_type, name='value')


NameIndexValueSchema = LarkSchemaNode(LarkMappingSchema())
node(NameIndexValueSchema, name_ref_type, name='name')
node(NameIndexValueSchema, int_type, name='index')
node(NameIndexValueSchema, value_type, name='value')


NameWhereRefValueValueSchema = LarkSchemaNode(LarkMappingSchema())
node(NameWhereRefValueValueSchema, name_ref_type, name='name')
node(NameWhereRefValueValueSchema, lark_string, name='where')
node(NameWhereRefValueValueSchema, value_type, name='refvalue')
node(NameWhereRefValueValueSchema, value_type, name='value')


SortSchema = LarkSchemaNode(LarkMappingSchema())
node(SortSchema, name_ref_type, name='name')
node(SortSchema, lark_string, name='start', missing=None)
node(SortSchema, int_type, name='num', missing=None)
node(SortSchema, name_ref_type, name='by', missing=None)
SortSchema.add(LarkSchemaNode(colander.Sequence(), LarkSchemaNode(name_ref_type), name='get', accept_scalar=True, missing=None))
node(SortSchema, string_bool, name='desc', missing=False)
node(SortSchema, string_bool, name='alpha', missing=False)
node(SortSchema, name_ref_type, name='store', missing=None)
node(SortSchema, string_bool, name='groups', missing=False)


CursorMatchCountSchema = LarkSchemaNode(LarkMappingSchema())
node(CursorMatchCountSchema, int_type, name='cursor')
node(CursorMatchCountSchema, name_ref_type, name='match')
node(CursorMatchCountSchema, int_type, name='count')


NameCursorMatchCountSchema = LarkSchemaNode(LarkMappingSchema())
node(NameCursorMatchCountSchema, name_ref_type, name='name')
node(NameCursorMatchCountSchema, int_type, name='cursor')
node(NameCursorMatchCountSchema, lark_string, name='match')
node(NameCursorMatchCountSchema, int_type, name='count')


BitOpSchema = LarkSchemaNode(LarkMappingSchema())
node(BitOpSchema, lark_string, name='operation')
node(BitOpSchema, name_ref_type, name='destkey')
BitOpSchema.add(LarkSchemaNode(colander.Sequence(), LarkSchemaNode(name_ref_type), name='key'))


NameTtlValueSchema = LarkSchemaNode(LarkMappingSchema())
node(NameTtlValueSchema, name_ref_type, name='name')
node(NameTtlValueSchema, int_type, name='ttl')
node(NameTtlValueSchema, value_type, name='key')


NameNumberSchema = LarkSchemaNode(LarkMappingSchema())
node(NameNumberSchema, name_ref_type, name='name')
node(NameNumberSchema, lark_string, name='number', missing=None)


NameMinMaxSchema = LarkSchemaNode(LarkMappingSchema())
node(NameMinMaxSchema, name_ref_type, name='name')
node(NameMinMaxSchema, lark_string, name='min')
node(NameMinMaxSchema, lark_string, name='max')


NameValueAmount = LarkSchemaNode(LarkMappingSchema())
node(NameValueAmount, name_ref_type, name='name')
node(NameValueAmount, value_type, name='value')
node(NameValueAmount, int_type, name='amount', missing=1)


NameKeySchema = LarkSchemaNode(LarkMappingSchema())
node(NameKeySchema, name_ref_type, name='name')
node(NameKeySchema, lark_string, name='key')


class NameKeysSchemaNode(LarkSchemaNode):

    def signature_from_cstruct(self, cstruct, redis_args, redis_kwargs):
        name = cstruct['name']
        keys = cstruct['key']
        return ([name] + keys, {})


NameKeysSchema = NameKeysSchemaNode(LarkMappingSchema())
node(NameKeysSchema, name_ref_type, name='name')
NameKeysSchema.add(LarkSchemaNode(colander.Sequence(), LarkSchemaNode(lark_string), name='key'))


class DestKeysSchemaNode(LarkSchemaNode):

    def signature_from_cstruct(self, cstruct, redis_args, redis_kwargs):
        dest = cstruct['dest']
        keys = cstruct['keys']
        return ([dest, keys], {})


DestKeysSchema = DestKeysSchemaNode(LarkMappingSchema())
node(DestKeysSchema, name_ref_type, name='dest')
DestKeysSchema.add(LarkSchemaNode(colander.Sequence(), LarkSchemaNode(lark_string), name='keys'))


class OperationDestKeysSchemaNode(LarkSchemaNode):

    def signature_from_cstruct(self, cstruct, redis_args, redis_kwargs):
        operation = cstruct['operation']
        dest = cstruct['dest']
        keys = cstruct['keys']
        return ([operation, dest] + keys, {})


OperationDestKeysSchema = OperationDestKeysSchemaNode(LarkMappingSchema())
node(OperationDestKeysSchema, name_ref_type, name='operation')
node(OperationDestKeysSchema, name_ref_type, name='dest')
OperationDestKeysSchema.add(LarkSchemaNode(colander.Sequence(), LarkSchemaNode(lark_string), name='keys'))


NameWeightTupleSchema = colander.SchemaNode(colander.Tuple())
NameWeightTupleSchema.add(colander.SchemaNode(lark_string, name='name'))
NameWeightTupleSchema.add(colander.SchemaNode(int_type, name='weight', missing=None))


class DestKeysAggregateSchemaNode(LarkSchemaNode):

    def from_request(self, args=None, kwargs=None, query_dict=None, request_json=None, redis_prefix=None):
        keys = request_json.get('keys')
        format = 'dict'
        if keys and isinstance(keys, dict):
            request_json['keys'] = keys.items()
        if keys and isinstance(keys, list):
            format = 'list'
            request_json['keys'] = [[x, None] for x in keys]

        cstruct = request_json

        self.redis_prefix = redis_prefix
        data = self.deserialize(cstruct)
        args, kwargs = self.signature_from_cstruct(data, format)

        return (args, kwargs)

    def signature_from_cstruct(self, cstruct, format):
        name = cstruct.get('dest')
        keys = cstruct.get('keys')
        if keys and format == 'dict':
            keys = dict(keys)

        if keys and format == 'list':
            keys = [x[0] for x in keys]

        aggregate = cstruct.get('aggregate')

        return ([name, keys], {'aggregate': aggregate})


DestKeysAggregateSchema = DestKeysAggregateSchemaNode(LarkMappingSchema())
node(DestKeysAggregateSchema, name_ref_type, name='dest')
DestKeysAggregateSchema.add(LarkSchemaNode(colander.Sequence(), NameWeightTupleSchema, name='keys'))
node(DestKeysAggregateSchema, lark_string, name='aggregate', missing=None)


KeyValueTupleSchema = colander.SchemaNode(colander.Tuple())
KeyValueTupleSchema.add(colander.SchemaNode(lark_string, name='key'))
KeyValueTupleSchema.add(colander.SchemaNode(value_type, name='value'))


class NameMappingSchemaNode(LarkSchemaNode):

    def from_request(self, args=None, kwargs=None, query_dict=None, request_json=None, redis_prefix=None):
        request_json = request_json if request_json else {}

        mapping = request_json.get('mapping')
        if mapping and isinstance(mapping, dict):
            request_json['mapping'] = mapping.items()

        cstruct = dict(zip(['name'], args))
        if kwargs:
            cstruct.update(kwargs)

        cstruct.update(request_json)

        self.redis_prefix = redis_prefix
        data = self.deserialize(cstruct)
        args, kwargs = self.signature_from_cstruct(data, format)

        return (args, kwargs)

    def signature_from_cstruct(self, cstruct, format):
        name = cstruct.get('name')
        mapping = cstruct.get('mapping')
        if mapping:
            mapping = dict(mapping)

        return ([name, mapping], {})


NameMapingSchema = NameMappingSchemaNode(LarkMappingSchema())
node(NameMapingSchema, name_ref_type, name='name')
NameMapingSchema.add(LarkSchemaNode(colander.Sequence(), NameWeightTupleSchema, name='mapping'))


class NameKeyListSchemaNode(LarkSchemaNode):
    def signature_from_cstruct(self, cstruct, redis_keys, redis_args):
        name = cstruct.get('name')
        keys = cstruct.get('key')

        return ([name, keys], {})

NameKeyListSchema = NameKeyListSchemaNode(LarkMappingSchema())
node(NameKeyListSchema, name_ref_type, name='name')
NameKeyListSchema.add(LarkSchemaNode(colander.Sequence(), LarkSchemaNode(lark_string), name='key'))

ScanSchema = LarkSchemaNode(LarkMappingSchema())
node(ScanSchema, name_ref_type, name='match', missing=None)
node(ScanSchema, int_type, name='cursor', missing=0)
node(ScanSchema, int_type, name='count', missing=None)


NameScanSchema = LarkSchemaNode(LarkMappingSchema())
node(NameScanSchema, name_ref_type, name='name')
node(NameScanSchema, name_ref_type, name='match', missing=None)
node(NameScanSchema, int_type, name='cursor', missing=0)
node(NameScanSchema, int_type, name='count', missing=None)


NameKeyValueSchema = LarkSchemaNode(LarkMappingSchema())
node(NameKeyValueSchema, name_ref_type, name='name')
node(NameKeyValueSchema, lark_string, name='key')
node(NameKeyValueSchema, value_type, name='value')


NameKeyAmountSchema = LarkSchemaNode(LarkMappingSchema())
node(NameKeyAmountSchema, name_ref_type, name='name')
node(NameKeyAmountSchema, lark_string, name='key')
node(NameKeyAmountSchema, int_type, name='amount', missing=1)


NameKeyFloatAmountSchema = LarkSchemaNode(LarkMappingSchema())
node(NameKeyFloatAmountSchema, name_ref_type, name='name')
node(NameKeyFloatAmountSchema, lark_string, name='key')
node(NameKeyFloatAmountSchema, float_type, name='amount', missing=1.0)


valid_cast_funcs = {
    'int': int,
    'str': str,
    'float': float,
}


class ZrangeByScoresSchemaNode(LarkSchemaNode):
    def signature_from_cstruct(self, cstruct, redis_keys, redis_args):
        name = cstruct.get('name')
        min = cstruct.get('min')
        max = cstruct.get('max')
        start = cstruct.get('start')
        num = cstruct.get('num')
        withscores = cstruct.get('withscores')
        score_cast_func = valid_cast_funcs.get(cstruct.get('score_cast_func'))
        # print 'Sendcing up score_cast_func: %s %s' % (score_cast_func, type(score_cast_func))
        return ([name, min, max], {
            'start': start,
            'num': num,
            'withscores': withscores,
            'score_cast_func': score_cast_func,
        })


ZrangeByScoresSchema = ZrangeByScoresSchemaNode(LarkMappingSchema())
node(ZrangeByScoresSchema, name_ref_type, name='name')
node(ZrangeByScoresSchema, int_type, name='min')
node(ZrangeByScoresSchema, int_type, name='max')
node(ZrangeByScoresSchema, int_type, name='start', missing=None)
node(ZrangeByScoresSchema, int_type, name='num', missing=None)
node(ZrangeByScoresSchema, string_bool, name='withscores', missing=False)
node(ZrangeByScoresSchema, lark_string, name='score_cast_func', missing='float')


class ZrevRangeSchemaNode(LarkSchemaNode):
    def signature_from_cstruct(self, cstruct, redis_keys, redis_args):
        name = cstruct.get('name')
        start = cstruct.get('start')
        end = cstruct.get('end')
        withscores = cstruct.get('withscores')
        score_cast_func = valid_cast_funcs.get(cstruct.get('score_cast_func'))
        return ([name, start, end], {
            'withscores': withscores,
            'score_cast_func': score_cast_func,
        })


ZrevRangeSchema = ZrevRangeSchemaNode(LarkMappingSchema())
node(ZrevRangeSchema, name_ref_type, name='name')
node(ZrevRangeSchema, int_type, name='start')
node(ZrevRangeSchema, int_type, name='end')
node(ZrevRangeSchema, string_bool, name='withscores', missing=False)
node(ZrevRangeSchema, lark_string, name='score_cast_func', missing='float')


class ZrangeSchemaNode(LarkSchemaNode):
    def signature_from_cstruct(self, cstruct, redis_keys, redis_args):
        name = cstruct.get('name')
        start = cstruct.get('start')
        end = cstruct.get('end')
        desc = cstruct.get('desc')
        withscores = cstruct.get('withscores')
        score_cast_func = valid_cast_funcs.get(cstruct.get('score_cast_func'))
        return ([name, start, end], {
            'desc': desc,
            'withscores': withscores,
            'score_cast_func': score_cast_func,
        })


ZrangeSchema = ZrangeSchemaNode(LarkMappingSchema())
node(ZrangeSchema, name_ref_type, name='name')
node(ZrangeSchema, int_type, name='start')
node(ZrangeSchema, int_type, name='end')
node(ZrangeSchema, string_bool, name='desc', missing=False)
node(ZrangeSchema, string_bool, name='withscores', missing=False)
node(ZrangeSchema, lark_string, name='score_cast_func', missing='float')


NameTtlBinValueSchema = LarkSchemaNode(LarkMappingSchema())
node(NameTtlBinValueSchema, name_ref_type, name='name')
node(NameTtlBinValueSchema, int_type, name='ttl')
node(NameTtlBinValueSchema, bin_type, name='value')

########NEW FILE########
__FILENAME__ = test_client
from __future__ import with_statement
import binascii
import datetime
import json
import pprint
import os
import time
import unittest
from urllib import urlencode

from flask import Flask
from iso8601 import parse_date
import redis
from redis._compat import b

from lark.ext.flask.redis_api import redis_api_blueprint
from lark.ext.flask.flask_redis import Redis

app = Flask(__name__)
app.config['REDIS_URLS'] = {
    'main': 'redis://localhost:6379/10',
    'admin': 'redis://localhost:6379/11',
}
app.config['DEBUG'] = True
app.config['DEFAULT_LARK_SCOPES'] = set(['admin'])
Redis(app)
app.register_blueprint(redis_api_blueprint, url_prefix='/api/0')


class RedisCommands(object):

    ### SERVER INFORMATION ###
    def test_client_list(self):
        meta, data = self.api_request('/CLIENT/LIST/')
        assert isinstance(data[0], dict)
        assert 'addr' in data[0]

    def test_config_get(self):
        meta, data = self.api_request('/CONFIG/GET/')
        assert 'maxmemory' in data
        assert data['maxmemory'].isdigit()

    def test_config_resetstat(self):
        self.api_request('/PING/')
        meta, info = self.api_request('/INFO/')
        assert int(info['total_commands_processed']) > 1
        meta, data = self.api_request('/CONFIG/RESETSTAT/', method='POST')
        meta, info = self.api_request('/INFO/')
        assert int(info['total_commands_processed']) == 1

    def test_config_set(self):
        meta, data = self.api_request('/CONFIG/GET/')
        maxclients = data['maxclients']
        try:
            meta, data = self.api_request('/CONFIG/SET/maxclients/', method='POST',
                                          data={'value': '9999'})
            meta, data = self.api_request('/CONFIG/GET/')
            assert data['maxclients'] == '9999'
        finally:
            meta, data = self.api_request('/CONFIG/SET/maxclients/', method='POST',
                                          data={'value': maxclients})

    def test_dbsize(self):
        self.api_request('/SET/a/', method='POST', data={'value': 'foo'})
        self.api_request('/SET/b/', method='POST', data={'value': 'bar'})
        meta, data = self.api_request('/DBSIZE/')
        assert data == 2

    # def test_debug_object(self):
    #     self.api_request('/SET/', method='POST', data={'key': 'a', 'value': 'foo'})
    #     debug_info = r.debug_object('a')
    #     assert len(debug_info) > 0
    #     assert 'refcount' in debug_info
    #     assert debug_info['refcount'] == 1

    def test_echo(self):
        _, data = self.api_request('/ECHO/', method='POST', data={'value': 'foo bar'})
        assert data == 'foo bar'

    def test_info(self):
        self.api_request('/SET/a/', method='POST', data={'value': 'foo'})
        self.api_request('/SET/b/', method='POST', data={'value': 'bar'})
        _, info = self.api_request('/INFO/')
        assert isinstance(info, dict)
        assert info['db10']['keys'] == 2

    def test_lastsave(self):
        _, data = self.api_request('/LASTSAVE/')
        lastsave = parse_date(data)
        assert isinstance(lastsave, datetime.datetime)

    def test_object(self):
        self.arp('/SET/a/', {'value': 'foo'})
        data = self.arg('/OBJECT/refcount/a/')
        assert isinstance(data, int)
        data = self.arg('/OBJECT/idletime/a/')
        assert isinstance(data, int)
        data = self.arg('/OBJECT/encoding/a/')
        assert data == 'raw'

    def test_ping(self):
        self.api_request('/PING/')

    ### BASIC KEY COMMANDS ###
    def test_append(self):
        data = self.arp('/APPEND/a/', {'value': 'a1'})
        assert data == 2
        data = self.arg('/GET/a/')
        assert data == 'a1'
        data = self.arp('/APPEND/a/', {'value': 'a2'})
        assert data == 4
        data = self.arg('/GET/a/')
        assert data == 'a1a2'

    def test_bitcount(self):
        self.arp('/SETBIT/a/', data={'offset': 5, 'value': True})
        assert self.arg('/BITCOUNT/a/') == 1
        self.arp('/SETBIT/a/', data={'offset': 6, 'value': True})
        assert self.arg('/BITCOUNT/a/') == 2
        self.arp('/SETBIT/a/', data={'offset': 5, 'value': False})
        assert self.arg('/BITCOUNT/a/') == 1
        self.arp('/SETBIT/a/', data={'offset': 9, 'value': True})
        self.arp('/SETBIT/a/', data={'offset': 17, 'value': True})
        self.arp('/SETBIT/a/', data={'offset': 25, 'value': True})
        self.arp('/SETBIT/a/', data={'offset': 33, 'value': True})
        assert self.arg('/BITCOUNT/a/') == 5
        assert self.arg('/BITCOUNT/a/0/-1/') == 5
        assert self.arg('/BITCOUNT/a/2/3/') == 2
        assert self.arg('/BITCOUNT/a/2/-1/') == 3
        assert self.arg('/BITCOUNT/a/-2/-1/') == 2
        assert self.arg('/BITCOUNT/a/1/1/') == 1

    def test_bitop_not_empty_string(self):
        self.arp('/SET/a/', {'value': ''})
        self.arp('/BITOP/', {'operation': 'not', 'dest': 'r', 'keys': ['a']})
        assert self.arg('/GET/r/') is None

    # def test_bitop_not(self):
    #     test_str = b(u'\xAA\x00\xFF\x55')
    #     correct = ~0xAA00FF55 & 0xFFFFFFFF
    #     self.arp('/SET/a/', {'value': test_str})
    #     self.arp('/BITOP/', {'operation': 'not', 'dest': 'r', 'keys': ['a']})
    #     assert int(binascii.hexlify(self.arg('/GET/r/')), 16) == correct

    # def test_bitop_not_in_place(self):
    #     test_str = b(u'\xAA\x00\xFF\x55')
    #     correct = ~0xAA00FF55 & 0xFFFFFFFF
    #     self.arp('/SET/', {'key': 'a', 'value': test_str})
    #     self.arp('/BITOP/', {'operation': 'not', 'dest': 'a', 'keys': ['a']})
    #     assert int(binascii.hexlify(self.arg('/GET/r/')), 16) == correct

    # def test_bitop_single_string(self):
    #     test_str = b(u'\x01\x02\xFF')
    #     self.arp('/SET/', {'key': 'a', 'value': test_str})
    #     self.arp('/BITOP/', {'operation': 'and', 'dest': 'res1', 'keys': ['a']})
    #     self.arp('/BITOP/', {'operation': 'or', 'dest': 'res2', 'keys': ['a']})
    #     self.arp('/BITOP/', {'operation': 'xor', 'dest': 'res3', 'keys': ['a']})
    #     assert self.arg('/GET/res1/') == test_str
    #     assert self.arg('/GET/res2/') == test_str
    #     assert self.arg('/GET/res3/') == test_str

    # def test_bitop_string_operands(self):
    #     self.arp('/SET/', {'key': 'a', 'value': b('\x01\x02\xFF\xFF')})
    #     self.arp('/SET/', {'key': 'b', 'value': b('\x01\x02\xFF')})
    #     self.arp('/BITOP/', {'operation': 'and', 'dest': 'res1', 'keys': ['a', 'b']})
    #     self.arp('/BITOP/', {'operation': 'or', 'dest': 'res2', 'keys': ['a', 'b']})
    #     self.arp('/BITOP/', {'operation': 'xor', 'dest': 'res3', 'keys': ['a', 'b']})
    #     assert int(binascii.hexlify(self.arg('/GET/res1/')), 16) == 0x0102FF00
    #     assert int(binascii.hexlify(self.arg('/GET/res2/')), 16) == 0x0102FFFF
    #     assert int(binascii.hexlify(self.arg('/GET/res3/')), 16) == 0x000000FF

    def test_decr(self):
        self.arp('/DECR/a/')
        data = self.arg('/GET/a/')
        assert data == '-1'
        data = self.arp('/DECR/a/')
        assert data == -2
        data = self.arg('/GET/a/')
        assert data == '-2'
        data = self.arp('/DECRBY/a/', data={'amount': '5'})
        assert data == -7
        data = self.arg('/GET/a/')
        assert data == b('-7')

    def test_delete(self):
        data = self.ard('/DEL/a/')
        assert data == 0
        self.arp('/SET/a/', {'value': 'foo'})
        data = self.ard('/DEL/a/')
        assert data == 1

    def test_delete_with_multiple_keys(self):
        self.arp('/SET/a/', {'value': 'foo'})
        self.arp('/SET/b/', {'value': 'bar'})
        self.ard('/DEL/', params=[('name', 'a'), ('name', 'b')])
        assert self.arg('/GET/a/') is None
        assert self.arg('/GET/b/') is None

    def test_dump_and_restore(self):
        self.arp('/SET/a/', {'value': 'foo'})
        dumped = self.arg('/DUMP/a/')
        self.ard('/DEL/a/')
        self.arp('/RESTORE/a/', {'ttl': 0, 'value': dumped})
        assert self.arg('/GET/a/') == b('foo')

    def test_exists(self):
        data = self.arg('/EXISTS/a/')
        assert not data
        data = self.arp('/SET/a/', {'value': 'foo'})
        assert data

    def test_expire(self):
        data = self.arp('/EXPIRE/a/', {'time': 10})
        assert not data
        self.arp('/SET/a/', {'value': 'foo'})
        data = self.arp('/EXPIRE/a/', {'time': 10})
        assert data
        data = self.arg('/TTL/a/')
        assert 0 < data <= 10
        data = self.arp('/PERSIST/a/')
        assert data
        data = self.arg('/TTL/a/')
        assert not data

    def test_expireat_datetime(self):
        expire_at = datetime.datetime.now() + datetime.timedelta(minutes=1)
        self.arp('/SET/a/', {'value': 'foo'})
        self.arp('/EXPIREAT/a/', {'when': expire_at.isoformat()})
        data = self.arg('/TTL/a/')
        assert 0 < data <= 60

    def test_expireat_no_key(self):
        expire_at = datetime.datetime.now() + datetime.timedelta(minutes=1)
        data = self.arp('/EXPIREAT/a/', {'when': expire_at.isoformat()})
        assert not data

    def test_get_and_set(self):
        # get and set can't be tested independently of each other
        _, data = self.api_request('/GET/a/')
        assert data is None
        byte_string = b('value')
        integer = 5
        self.arp('/SET/byte_string/', {'value': byte_string})
        self.arp('/SET/integer/', {'value': '5'})
        _, data = self.api_request('/GET/byte_string/')
        assert data == byte_string
        _, data = self.api_request('/GET/integer/')
        assert data == b(str(integer))

    def test_get_set_bit(self):
        # no value
        _, data = self.api_request('/GETBIT/a/5/')
        assert not data
        # set bit 5
        self.api_request('/SETBIT/a/', method='POST', data={'offset': 5, 'value': True})
        _, data = self.api_request('/GETBIT/a/5/')
        # unset bit 4
        _, data = self.api_request('/SETBIT/a/', method='POST', data={'offset': 4, 'value': False})
        assert not data
        _, data = self.api_request('/GETBIT/a/4/')
        assert not data
        # set bit 4
        _, data = self.api_request('/SETBIT/a/', method='POST', data={'offset': 4, 'value': True})
        assert not data
        _, data = self.api_request('/GETBIT/a/4/')
        assert data
        # set bit 5 again
        _, data = self.api_request('/SETBIT/a/', method='POST', data={'offset': 5, 'value': True})
        assert data
        _, data = self.api_request('/GETBIT/a/5/')
        assert data

    def test_getrange(self):
        self.api_request('/SET/a/', method='POST', data={'value': 'foo'})
        data = self.arg('/GETRANGE/a/0/0/')
        assert data == b('f')
        data = self.arg('/GETRANGE/a/0/2/')
        assert data == b('foo')
        data = self.arg('/GETRANGE/a/3/4/')
        assert data == b('')

    def test_getset(self):
        _, data = self.api_request('/GETSET/a/', method='POST', data={'value': 'foo'})
        assert data is None
        _, data = self.api_request('/GETSET/a/', method='POST', data={'value': 'bar'})
        assert data == b('foo')

    def test_incr(self):
        self.arp('/INCR/a/')
        data = self.arg('/GET/a/')
        assert data == '1'
        data = self.arp('/INCR/a/')
        assert data == 2
        data = self.arg('/GET/a/')
        assert data == '2'
        data = self.arp('/INCRBY/a/', {'amount': '5'})
        assert data == 7
        data = self.arg('/GET/a/')
        assert data == b('7')

    def test_incrby(self):
        data = self.arp('/INCRBY/a/')
        assert data == 1
        data = self.arp('/INCRBY/a/', {'amount': 4})
        assert data == 5
        data = self.arg('/GET/a/')
        assert data == b('5')

    def test_incrbyfloat(self):
        assert self.arp('/INCRBYFLOAT/a/') == 1.0
        assert self.arg('/GET/a/') == b('1')
        assert self.arp('/INCRBYFLOAT/a/', {'amount': 1.1}) == 2.1
        assert float(self.arg('/GET/a/')) == float(2.1)

    def test_keys(self):
        _, data = self.api_request('/KEYS/')
        assert data == []
        keys_with_underscores = set([b('test_a'), b('test_b')])
        keys = keys_with_underscores.union(set([b('testc')]))
        for key in keys:
            self.api_request('/SET/%s/' % key, method='POST', data={'value': '1'})
        _, data = self.api_request('/KEYS/test_*/')
        assert set(data) == keys_with_underscores
        _, data = self.api_request('/KEYS/test*/')
        assert set(data) == keys

    def test_mget(self):
        _, data = self.api_request('/MGET/', params=[('key', 'a'), ('key', 'b')])
        assert data == [None, None]
        self.api_request('/SET/a/', method='POST', data={'value': '1'})
        self.api_request('/SET/b/', method='POST', data={'value': '2'})
        self.api_request('/SET/c/', method='POST', data={'value': '3'})
        _, data = self.api_request('/MGET/', params=[('key', 'a'), ('key', 'other'), ('key', 'b'), ('key', 'c')])
        assert data == [b('1'), None, b('2'), b('3')]

    def test_mset(self):
        d = [('a', '1'), ('b', '2'), ('c', '3')]
        _, data = self.api_request('/MSET/', method='POST', data=d)
        assert data
        for k, v in d:
            _, data = self.api_request('/GET/%s/' % k)
            assert data == v

    def test_msetnx(self):
        d = [('a', '1'), ('b', '2'), ('c', '3')]
        _, data = self.api_request('/MSETNX/', method='POST', data=d)
        assert data
        d2 = [('a', 'x'), ('d', '4')]
        data = self.arp('/MSETNX/', d2)
        assert not data
        for k, v in d:
            data = self.arg('/GET/%s/' % k)
            assert data == v
        data = self.arg('/GET/d/')
        assert data is None

    def test_pexpire(self):
        assert not self.arp('/PEXPIRE/a/', {'time': 60000})
        self.arp('/SET/a/', {'value': 'foo'})
        assert self.arp('/PEXPIRE/a/', {'time': 60000})
        assert 0 < self.arg('/PTTL/a/') <= 60000
        assert self.arp('/PERSIST/a/')
        assert self.arg('/PTTL/a/') is None

    def test_pexpireat_no_key(self):
        expire_at = datetime.datetime.now() + datetime.timedelta(minutes=1)
        assert not self.arp('/PEXPIREAT/a/', {'when': expire_at.isoformat()})

    def test_psetex(self):
        assert self.arp('/PSETEX/a/', {'time_ms': 1000, 'value': 'value'})
        assert self.arg('/GET/a/') == b('value')
        assert 0 < self.arg('/PTTL/a/') <= 1000

    def test_randomkey(self):
        _, data = self.api_request('/RANDOMKEY/')
        assert data is None
        for key in ('a', 'b', 'c'):
            self.api_request('/SET/%s/' % key, method='POST', data={'value': '1'})
        _, data = self.api_request('/RANDOMKEY/')
        assert data in (b('a'), b('b'), b('c'))

    def test_rename(self):
        self.api_request('/SET/a/', method='POST', data={'value': '1'})
        _, data = self.api_request('/RENAME/', method='POST', data={'src': 'a', 'dst': 'b'})
        assert data
        _, data = self.api_request('/GET/a/')
        assert data is None
        _, data = self.api_request('/GET/b/')
        assert data == b('1')

    def test_renamenx(self):
        self.arp('/SET/a/', {'value': '1'})
        self.arp('/SET/b/', {'value': '2'})
        _, data = self.api_request('/RENAMENX/', method='POST', data={'src': 'a', 'dst': 'b'})
        assert not data
        _, data = self.api_request('/GET/a/')
        assert data == b('1')
        _, data = self.api_request('/GET/b/')
        assert data == b('2')

    def test_set_nx(self):
        assert self.arp('/SET/a/', {'value': '1', 'nx': True})
        assert not self.arp('/SET/a/', {'value': '2', 'nx': True})
        assert self.arg('/GET/a/') == b('1')

    def test_set_xx(self):
        assert not self.arp('/SET/a/', {'value': '1', 'xx': True})
        assert self.arg('/GET/a/') is None
        self.arp('/SET/a/', {'value': 'bar'})
        assert self.arp('/SET/a/', {'value': '2', 'xx': True})
        assert self.arg('/GET/a/') == b('2')

    def test_set_px(self):
        assert self.arp('/SET/a/', {'value': '1', 'px': 10000})
        assert self.arg('/GET/a/') == b('1')
        assert 0 < self.arg('/PTTL/a/') <= 10000
        assert 0 < self.arg('/TTL/a/') <= 10

    def test_set_ex(self):
        assert self.arp('/SET/a/', {'value': '1', 'ex': 10})
        assert 0 < self.arg('/TTL/a/') <= 10

    def test_set_multipleoptions(self):
        self.arp('/SET/a/', {'value': '1'})
        assert self.arp('/SET/a/', {'value': '1', 'xx': True, 'px': 10000})
        assert 0 < self.arg('/TTL/a/') <= 10

    def test_setex(self):
        _, data = self.api_request('/SETEX/a/', method='POST', data={'value': '1', 'time': 60})
        assert data
        _, data = self.api_request('/GET/a/')
        assert data == b('1')
        _, data = self.api_request('/TTL/a/')
        assert 0 < data <= 60

    def test_setnx(self):
        _, data = self.api_request('/SETNX/a/', method='POST', data={'value': '1'})
        assert data
        _, data = self.api_request('/GET/a/')
        assert data == b('1')
        _, data = self.api_request('/SETNX/a/', method='POST', data={'value': '2'})
        assert not data
        _, data = self.api_request('/GET/a/')
        assert data == '1'

    def test_setrange(self):
        _, data = self.api_request('/SETRANGE/a/', method='POST', data={'offset': 5, 'value': 'foo'})
        assert data == 8
        _, data = self.api_request('/GET/a/')
        assert data == b('\0\0\0\0\0foo')
        _, data = self.api_request('/SET/a/', method='POST', data={'value': 'abcdefghijh'})
        _, data = self.api_request('/SETRANGE/a/', method='POST', data={'offset': 6, 'value': '12345'})
        assert data
        _, data = self.api_request('/GET/a/')
        assert data == b('abcdef12345')

    def test_strlen(self):
        # String length is going to be weird because of the automatic JSON encoding
        self.api_request('/SET/a/', method='POST', data={'value': 'foo'})
        _, data = self.api_request('/STRLEN/a/')
        assert data == 3

    def test_substr(self):
        self.arp('/SET/a/', {'value': '0123456789'})
        _, data = self.api_request('/SUBSTR/a/0/')
        assert data == b('0123456789')
        _, data = self.api_request('/SUBSTR/a/2/')
        assert data == b('23456789')
        _, data = self.api_request('/SUBSTR/a/3/5/')
        assert data == b('345')
        _, data = self.api_request('/SUBSTR/a/3/-2/')
        assert data == b('345678')

    def test_type(self):
        assert self.arg('/TYPE/a/') == b('none')
        self.arp('/SET/a/', {'value': '1'})
        assert self.arg('/TYPE/a/') == b('string')
        self.ard('/DEL/a/')
        self.arp('/LPUSH/a/', {'values': ['1']})
        assert self.arg('/TYPE/a/') == b('list')
        self.ard('/DEL/a/')
        self.arp('/SADD/a/', data={'values': ['1']})
        assert self.arg('/TYPE/a/') == b('set')
        self.ard('/DEL/a/')
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})
        assert self.arg('/TYPE/a/') == b('zset')

    #### LIST COMMANDS ####
    #@unittest.skip('Include later')
    def test_blpop(self):
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['1', '2']})
        self.api_request('/RPUSH/b/', method='POST', data={'values': ['3', '4']})
        _, data = self.api_request('/BLPOP/', method='POST', data={'keys': ['b', 'a'], 'timeout': 1})
        assert data == [b('b'), b('3')]
        _, data = self.api_request('/BLPOP/', method='POST', data={'keys': ['b', 'a'], 'timeout': 1})
        assert data == [b('b'), b('4')]
        _, data = self.api_request('/BLPOP/', method='POST', data={'keys': ['b', 'a'], 'timeout': 1})
        assert data == [b('a'), b('1')]
        _, data = self.api_request('/BLPOP/', method='POST', data={'keys': ['b', 'a'], 'timeout': 1})
        assert data == [b('a'), b('2')]
        _, data = self.api_request('/BLPOP/', method='POST', data={'keys': ['b', 'a'], 'timeout': 1})
        assert data is None
        self.api_request('/RPUSH/c/', method='POST', data={'values': ['1']})
        _, data = self.api_request('/BLPOP/', method='POST', data={'keys': ['c'], 'timeout': 1})
        assert data == [b('c'), b('1')]

    #@unittest.skip('Include later')
    def test_brpop(self):
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['1', '2']})
        self.api_request('/RPUSH/b/', method='POST', data={'values': ['3', '4']})
        _, data = self.api_request('/BRPOP/', method='POST', data={'keys': ['b', 'a'], 'timeout': 1})
        assert data == [b('b'), b('4')]
        _, data = self.api_request('/BRPOP/', method='POST', data={'keys': ['b', 'a'], 'timeout': 1})
        assert data == [b('b'), b('3')]
        _, data = self.api_request('/BRPOP/', method='POST', data={'keys': ['b', 'a'], 'timeout': 1})
        assert data == [b('a'), b('2')]
        _, data = self.api_request('/BRPOP/', method='POST', data={'keys': ['b', 'a'], 'timeout': 1})
        assert data == [b('a'), b('1')]
        _, data = self.api_request('/BRPOP/', method='POST', data={'keys': ['b', 'a'], 'timeout': 1})
        assert data is None
        self.api_request('/RPUSH/c/', method='POST', data={'values': ['1']})
        _, data = self.api_request('/BRPOP/', method='POST', data={'keys': ['c'], 'timeout': 1})
        assert data == [b('c'), b('1')]

    #@unittest.skip('Include later')
    def test_brpoplpush(self):
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['1', '2']})
        self.api_request('/RPUSH/b/', method='POST', data={'values': ['3', '4']})
        _, data = self.api_request('/BRPOPLPUSH/', method='POST', data={'src': 'a', 'dst': 'b'})
        assert data == b('2')
        _, data = self.api_request('/BRPOPLPUSH/', method='POST', data={'src': 'a', 'dst': 'b'})
        assert data == b('1')
        _, data = self.api_request('/BRPOPLPUSH/', method='POST', data={'src': 'a', 'dst': 'b', 'timeout': 1})
        assert data is None
        _, data = self.api_request('/LRANGE/a/0/-1/')
        assert data == []
        _, data = self.api_request('/LRANGE/b/0/-1/')
        assert data == [b('1'), b('2'), b('3'), b('4')]

    def test_brpoplpush_empty_string(self):
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['']})
        _, data = self.api_request('/BRPOPLPUSH/', method='POST', data={'src': 'a', 'dst': 'b'})
        assert data == b('')

    def test_lindex(self):
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['1', '2', '3']})
        _, data = self.api_request('/LINDEX/a/0/')
        assert data == b('1')
        _, data = self.api_request('/LINDEX/a/1/')
        assert data == b('2')
        _, data = self.api_request('/LINDEX/a/2/')
        assert data == b('3')

    def test_linsert(self):
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['1', '2', '3']})
        _, data = self.api_request('/LINSERT/a/', method='POST', data={'where': 'after', 'refvalue': '2', 'value': '2.5'})
        assert data == 4
        _, data = self.api_request('/LRANGE/a/0/-1/')
        assert data == [b('1'), b('2'), b('2.5'), b('3')]
        _, data = self.api_request('/LINSERT/a/', method='POST', data={'where': 'before', 'refvalue': '2', 'value': '1.5'})
        assert data == 5
        _, data = self.api_request('/LRANGE/a/0/-1/')
        assert data == [b('1'), b('1.5'), b('2'), b('2.5'), b('3')]

    def test_llen(self):
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['1', '2', '3']})
        _, data = self.api_request('/LLEN/a/')
        assert data == 3

    def test_lpop(self):
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['1', '2', '3']})
        _, data = self.api_request('/LPOP/a/', method='POST')
        assert data == b('1')
        _, data = self.api_request('/LPOP/a/', method='POST')
        assert data == b('2')
        _, data = self.api_request('/LPOP/a/', method='POST')
        assert data == b('3')
        _, data = self.api_request('/LPOP/a/', method='POST')
        assert data is None

    def test_lpush(self):
        _, data = self.api_request('/LPUSH/a/', method='POST', data={'values': ['1']})
        assert data == 1
        _, data = self.api_request('/LPUSH/a/', method='POST', data={'values': ['2']})
        assert data == 2
        _, data = self.api_request('/LPUSH/a/', method='POST', data={'values': ['3', '4']})
        assert data == 4
        _, data = self.api_request('/LRANGE/a/0/-1/')
        assert data == [b('4'), b('3'), b('2'), b('1')]

    def test_lpushx(self):
        _, data = self.api_request('/LPUSHX/a/', method='POST', data={'value': '1'})
        assert data == 0
        _, data = self.api_request('/LRANGE/a/0/-1/')
        assert data == []
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['1', '2', '3']})
        _, data = self.api_request('/LPUSHX/a/', method='POST', data={'value': '4'})
        assert data == 4
        _, data = self.api_request('/LRANGE/a/0/-1/')
        assert data == [b('4'), b('1'), b('2'), b('3')]

    def test_lrange(self):
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['1', '2', '3', '4', '5']})
        _, data = self.api_request('/LRANGE/a/0/2/')
        assert data == [b('1'), b('2'), b('3')]
        _, data = self.api_request('/LRANGE/a/2/10/')
        assert data == [b('3'), b('4'), b('5')]
        _, data = self.api_request('/LRANGE/a/0/-1/')
        assert data == [b('1'), b('2'), b('3'), b('4'), b('5')]

    def test_lrem(self):
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['1', '1', '1', '1']})
        _, data = self.api_request('/LREM/a/1/1/', method='DELETE')
        assert data == 1
        _, data = self.api_request('/LRANGE/a/0/-1/')
        assert data == [b('1'), b('1'), b('1')]
        _, data = self.api_request('/LREM/a/1/', method='DELETE')
        assert data == 3
        _, data = self.api_request('/LRANGE/a/0/-1/')
        assert data == []

    def test_lset(self):
        self.api_request('/RPUSH/a/', method='POST', data={'values': ['1', '2', '3']})
        assert self.arg('/LRANGE/a/0/-1/') == [b('1'), b('2'), b('3')]
        assert self.arp('/LSET/a/', data={'index': 1, 'value': '4'})
        assert self.arg('/LRANGE/a/0/2/') == [b('1'), b('4'), b('3')]

    def test_ltrim(self):
        self.arp('/RPUSH/a/', data={'values': ['1', '2', '3']})
        assert self.ard('/LTRIM/a/0/1/')
        assert self.arg('/LRANGE/a/0/-1/') == [b('1'), b('2')]

    def test_rpop(self):
        self.arp('/RPUSH/a/', data={'values': ['1', '2', '3']})
        assert self.arp('/RPOP/a/') == b('3')
        assert self.arp('/RPOP/a/') == b('2')
        assert self.arp('/RPOP/a/') == b('1')
        assert self.arp('/RPOP/a/') is None

    def test_rpoplpush(self):
        self.arp('/RPUSH/a/', data={'values': ['a1', 'a2', 'a3']})
        self.arp('/RPUSH/b/', data={'values': ['b1', 'b2', 'b3']})
        assert self.arp('/RPOPLPUSH/', data={'src': 'a', 'dst': 'b'}) == b('a3')
        assert self.arg('/LRANGE/a/0/-1/') == [b('a1'), b('a2')]
        assert self.arg('/LRANGE/b/0/-1/') == [b('a3'), b('b1'), b('b2'), b('b3')]

    def test_rpush(self):
        assert self.arp('/RPUSH/a/', data={'values': ['1']}) == 1
        assert self.arp('/RPUSH/a/', data={'values': ['2']}) == 2
        assert self.arp('/RPUSH/a/', data={'values': ['3', '4']}) == 4
        assert self.arg('/LRANGE/a/0/-1/') == [b('1'), b('2'), b('3'), b('4')]

    def test_rpushx(self):
        assert self.arp('/RPUSHX/a/', data={'value': 'b'}) == 0
        assert self.arg('/LRANGE/a/0/-1/') == []
        self.arp('/RPUSH/a/', data={'values': ['1', '2', '3']})
        assert self.arp('/RPUSHX/a/', data={'value': '4'}) == 4
        assert self.arg('/LRANGE/a/0/-1/') == [b('1'), b('2'), b('3'), b('4')]

    ### SCAN COMMANDS ###
    def test_scan(self):
        self.arp('/SET/a/', {'value': '1'})
        self.arp('/SET/b/', {'value': '2'})
        self.arp('/SET/c/', {'value': '3'})
        cursor, keys = self.arg('/SCAN/')
        assert cursor == b('0')
        assert set(keys) == set([b('a'), b('b'), b('c')])
        _, keys = self.arg('/SCAN/', params=[('match', 'a')])
        assert set(keys) == set([b('a')])

    def test_sscan(self):
        self.arp('/SADD/a/', data={'values': [1, 2, 3]})
        cursor, members = self.arg('/SSCAN/a/')
        assert cursor == b('0')
        assert set(members) == set([b('1'), b('2'), b('3')])
        _, members = self.arg('/SSCAN/a/', params=[('match', '1')])
        assert set(members) == set([b('1')])

    def test_hscan(self):
        self.arp('/HMSET/a/', {'mapping': {'a': 1, 'b': 2, 'c': 3}})
        cursor, dic = self.arg('/HSCAN/a/')
        assert cursor == b('0')
        assert dic == {b('a'): b('1'), b('b'): b('2'), b('c'): b('3')}
        _, dic = self.arg('/HSCAN/a/', params=[('match', 'a')])
        assert dic == {b('a'): b('1')}

    def test_zscan(self):
        self.arp('/ZADD/a/', {'scores': [('a', 1), ('b', 2), ('c', 3)]})
        cursor, pairs = self.arg('/ZSCAN/a/')
        assert cursor == b('0')
        assert pairs == [[b('a'), 1], [b('b'), 2], [b('c'), 3]]
        _, pairs = self.arg('/ZSCAN/a/', params=[('match', 'a')])
        assert pairs == [[b('a'), 1]]

    ### SET COMMANDS ###
    def test_sadd(self):
        members = [b('1'), b('2'), b('3')]
        self.arp('/SADD/a/', data={'values': members})
        assert set(self.arg('/SMEMBERS/a/')) == set(members)

    def test_scard(self):
        self.arp('/SADD/a/', data={'values': [b('1'), b('2'), b('3')]})
        assert self.arg('/SCARD/a/') == 3

    def test_sdiff(self):
        self.arp('/SADD/a/', data={'values': ['1', '2', '3']})
        params = [('key', 'a'), ('key', 'b')]
        assert set(self.arg('/SDIFF/', params=params)) == set([b('1'), b('2'), b('3')])
        self.arp('/SADD/b/', data={'values': ['2', '3']})
        assert set(self.arg('/SDIFF/', params=params)) == set([b('1')])

    def test_sdiffstore(self):
        members = ['1', '2', '3']
        self.arp('/SADD/a/', {'values': members})
        assert self.arp('/SDIFFSTORE/', {'dest': 'c', 'keys': ['a', 'b']}) == 3
        assert set(self.arg('/SMEMBERS/c/')) == set(members)
        self.arp('/SADD/b/', {'values': ['2', '3']})
        assert self.arp('/SDIFFSTORE/', {'dest': 'c', 'keys': ['a', 'b']}) == 1
        assert set(self.arg('/SMEMBERS/c/')) == set([b('1')])

    def test_sinter(self):
        self.arp('/SADD/a/', data={'values': ['1', '2', '3']})
        params = [('key', 'a'), ('key', 'b')]
        assert set(self.arg('/SINTER/', params=params)) == set([])
        self.arp('/SADD/b/', data={'values': ['2', '3']})
        assert set(self.arg('/SINTER/', params=params)) == set([b('2'), b('3')])

    def test_sinterstore(self):
        members = ['1', '2', '3']
        self.arp('/SADD/a/', {'values': members})
        assert self.arp('/SINTERSTORE/', {'dest': 'c', 'keys': ['a', 'b']}) == 0
        assert set(self.arg('/SMEMBERS/c/')) == set()
        self.arp('/SADD/b/', {'values': ['2', '3']})
        assert self.arp('/SINTERSTORE/', {'dest': 'c', 'keys': ['a', 'b']}) == 2
        assert set(self.arg('/SMEMBERS/c/')) == set([b('2'), b('3')])

    def test_sismember(self):
        self.arp('/SADD/a/', {'values': ['1', '2', '3']})
        assert self.arg('/SISMEMBER/a/1/')
        assert self.arg('/SISMEMBER/a/2/')
        assert self.arg('/SISMEMBER/a/3/')
        assert not self.arg('/SISMEMBER/a/4/')

    def test_smembers(self):
        self.arp('/SADD/a/', {'values': ['1', '2', '3']})
        assert set(self.arg('/SMEMBERS/a/')) == set([b('1'), b('2'), b('3')])

    def test_smove(self):
        self.arp('/SADD/a/', {'values': ['a1', 'a2']})
        self.arp('/SADD/b/', {'values': ['b1', 'b2']})
        assert self.arp('/SMOVE/', {'src': 'a', 'dst': 'b', 'value': 'a1'})
        assert set(self.arg('/SMEMBERS/a/')) == set([b('a2')])
        assert set(self.arg('/SMEMBERS/b/')) == set([b('b1'), b('b2'), b('a1')])

    def test_spop(self):
        s = [b('1'), b('2'), b('3')]
        self.arp('/SADD/a/', {'values': s})
        value = self.arp('/SPOP/a/')
        assert value in s
        assert set(self.arg('/SMEMBERS/a/')) == set(s) - set([value])

    def test_srandmember(self):
        s = [b('1'), b('2'), b('3')]
        self.arp('/SADD/a/', {'values': s})
        assert self.arg('/SRANDMEMBER/a/') in s

    def test_srandmember_multi_value(self):
        s = [b('1'), b('2'), b('3')]
        self.arp('/SADD/a/', {'values': s})
        randoms = self.arg('/SRANDMEMBER/a/2/')
        assert len(randoms) == 2
        assert set(randoms).intersection(s) == set(randoms)

    def test_srem(self):
        s = ['1', '2', '3', '4']
        self.arp('/SADD/a/', {'values': s})
        assert self.ard('/SREM/a/', params=[('value', '5')]) == 0
        assert self.ard('/SREM/a/', params=[('value', '2'), ('value', '4')]) == 2
        assert set(self.arg('/SMEMBERS/a/')) == set([b('1'), b('3')])

    def test_sunion(self):
        self.arp('/SADD/a/', {'values': ['1', '2']})
        self.arp('/SADD/b/', {'values': ['2', '3']})
        assert set(self.arg('/SUNION/', params=[('key', 'a'), ('key', 'b')])) == set([b('1'), b('2'), b('3')])

    def test_sunionstore(self):
        self.arp('/SADD/a/', {'values': ['1', '2']})
        self.arp('/SADD/b/', {'values': ['2', '3']})
        assert self.arp('/SUNIONSTORE/', {'dest': 'c', 'keys': ['a', 'b']}) == 3
        assert set(self.arg('/SMEMBERS/c/')) == set([b('1'), b('2'), b('3')])

    ### SORTED SET COMMANDS ###
    def test_zadd(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})
        assert self.arg('/ZRANGE/a/0/-1/') == [b('a1'), b('a2'), b('a3')]

    def test_zcard(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})
        assert self.arg('/ZCARD/a/') == 3

    def test_zcount(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})
        assert self.arg('/ZCOUNT/a/-inf/+inf/') == 3
        assert self.arg('/ZCOUNT/a/1/2/') == 2
        assert self.arg('/ZCOUNT/a/10/20/') == 0

    def test_zincrby(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})

        assert self.arp('/ZINCRBY/a/', {'value': 'a2'}) == 3.0
        assert self.arp('/ZINCRBY/a/', {'value': 'a3', 'amount': 5}) == 8.0
        assert self.arg('/ZSCORE/a/a2/') == 3.0
        assert self.arg('/ZSCORE/a/a3/') == 8.0

    def test_zinterstore_sum(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 1), ('a3', 1)]})
        self.arp('/ZADD/b/', {'scores': [('a1', 2), ('a2', 2), ('a3', 2)]})
        self.arp('/ZADD/c/', {'scores': [('a1', 6), ('a3', 5), ('a4', 4)]})
        assert self.arp('/ZINTERSTORE/', {'dest': 'd', 'keys': ['a', 'b', 'c']}) == 2
        assert self.arg('/ZRANGE/d/0/-1/', params=[('withscores', 1)]) == [[b('a3'), 8], [b('a1'), 9]]

    def test_zinterstore_max(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 1), ('a3', 1)]})
        self.arp('/ZADD/b/', {'scores': [('a1', 2), ('a2', 2), ('a3', 2)]})
        self.arp('/ZADD/c/', {'scores': [('a1', 6), ('a3', 5), ('a4', 4)]})
        assert self.arp('/ZINTERSTORE/', {'dest': 'd', 'keys': ['a', 'b', 'c'], 'aggregate': 'MAX'}) == 2
        assert self.arg('/ZRANGE/d/0/-1/', params=[('withscores', 1)]) == [[b('a3'), 5], [b('a1'), 6]]

    def test_zinterstore_min(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})
        self.arp('/ZADD/b/', {'scores': [('a1', 2), ('a2', 3), ('a3', 5)]})
        self.arp('/ZADD/c/', {'scores': [('a1', 6), ('a3', 5), ('a4', 4)]})
        assert self.arp('/ZINTERSTORE/', {'dest': 'd', 'keys': ['a', 'b', 'c'], 'aggregate': 'MIN'}) == 2
        assert self.arg('/ZRANGE/d/0/-1/', params=[('withscores', 1)]) == [[b('a1'), 1], [b('a3'), 3]]

    def test_zinterstore_with_weight(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 1), ('a3', 1)]})
        self.arp('/ZADD/b/', {'scores': [('a1', 2), ('a2', 2), ('a3', 2)]})
        self.arp('/ZADD/c/', {'scores': [('a1', 6), ('a3', 5), ('a4', 4)]})
        assert self.arp('/ZINTERSTORE/', {'dest': 'd', 'keys': {'a': 1, 'b': 2, 'c': 3}}) == 2
        assert self.arg('/ZRANGE/d/0/-1/', params=[('withscores', 1)]) == [[b('a3'), 20], [b('a1'), 23]]

    def test_zrange(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})
        assert self.arg('/ZRANGE/a/0/1/') == [b('a1'), b('a2')]
        assert self.arg('/ZRANGE/a/1/2/') == [b('a2'), b('a3')]

        # withscores
        assert self.arg('/ZRANGE/a/0/1/', params=[('withscores', 1)]) == [[b('a1'), 1.0], [b('a2'), 2.0]]
        assert self.arg('/ZRANGE/a/1/2/', params=[('withscores', 1)]) == [[b('a2'), 2.0], [b('a3'), 3.0]]

        # custom score function
        assert self.arg('/ZRANGE/a/0/1/', params=[('withscores', 1), ('score_cast_func', 'int')]) == \
            [[b('a1'), 1], [b('a2'), 2]]

    def test_zrangebyscore(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3), ('a4', 4), ('a5', 5)]})
        assert self.arg('/ZRANGEBYSCORE/a/2/4/') == [b('a2'), b('a3'), b('a4')]

        # slicing with start/num
        assert self.arg('/ZRANGEBYSCORE/a/2/4/', params=[('start', 1), ('num', 2)]) == [b('a3'), b('a4')]

        # withscores
        assert self.arg('/ZRANGEBYSCORE/a/2/4/', params=[('withscores', 1)]) == \
            [[b('a2'), 2.0], [b('a3'), 3.0], [b('a4'), 4.0]]

        # custom score function
        assert self.arg('/ZRANGEBYSCORE/a/2/4/', params=[('withscores', 1), ('score_cast_func', 'int')]) == \
            [[b('a2'), 2], [b('a3'), 3], [b('a4'), 4]]

    def test_zrank(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3), ('a4', 4), ('a5', 5)]})
        assert self.arg('/ZRANK/a/a1/') == 0
        assert self.arg('/ZRANK/a/a2/') == 1
        assert self.arg('/ZRANK/a/a6/') is None

    def test_zrem(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})
        assert self.ard('/ZREM/a/', params=[('value', 'a2')]) == 1
        assert self.arg('/ZRANGE/a/0/-1/') == [b('a1'), b('a3')]
        assert self.ard('/ZREM/a/', params=[('value', 'b')]) == 0
        assert self.arg('/ZRANGE/a/0/-1/') == [b('a1'), b('a3')]

    def test_zrem_multiple_keys(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})
        assert self.ard('/ZREM/a/', params=[('value', 'a1'), ('value', 'a2')]) == 2
        assert self.arg('/ZRANGE/a/0/5/') == [b('a3')]

    def test_zremrangebyrank(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3), ('a4', 4), ('a5', 5)]})
        assert self.ard('/ZREMRANGEBYRANK/a/1/3/') == 3
        assert self.arg('/ZRANGE/a/0/5/') == [b('a1'), b('a5')]

    def test_zremrangebyscore(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3), ('a4', 4), ('a5', 5)]})
        assert self.ard('/ZREMRANGEBYSCORE/a/2/4/') == 3
        assert self.arg('/ZRANGE/a/0/-1/') == [b('a1'), b('a5')]
        assert self.ard('/ZREMRANGEBYSCORE/a/2/4/') == 0
        assert self.arg('/ZRANGE/a/0/-1/') == [b('a1'), b('a5')]

    def test_zrevrange(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})
        assert self.arg('/ZREVRANGE/a/0/1/') == [b('a3'), b('a2')]
        assert self.arg('/ZREVRANGE/a/1/2/') == [b('a2'), b('a1')]

        # withscores
        assert self.arg('/ZREVRANGE/a/0/1/', params=[('withscores', 1)]) == \
            [[b('a3'), 3.0], [b('a2'), 2.0]]
        assert self.arg('/ZREVRANGE/a/1/2/', params=[('withscores', 1)]) == \
            [[b('a2'), 2.0], [b('a1'), 1.0]]

        # custom score function
        assert self.arg('/ZREVRANGE/a/0/1/', params=[('withscores', 1), ('score_cast_func', 'int')]) == \
            [[b('a3'), 3], [b('a2'), 2]]

    def test_zrevrangebyscore(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3), ('a4', 4), ('a5', 5)]})
        assert self.arg('/ZREVRANGEBYSCORE/a/4/2/') == [b('a4'), b('a3'), b('a2')]

        # slicing with start/num
        assert self.arg('/ZREVRANGEBYSCORE/a/4/2/', params=[('start', 1), ('num', 2)]) == \
            [b('a3'), b('a2')]

        # withscores
        assert self.arg('/ZREVRANGEBYSCORE/a/4/2/', params=[('withscores', 1)]) == \
            [[b('a4'), 4.0], [b('a3'), 3.0], [b('a2'), 2.0]]

        # custom score function
        assert self.arg('/ZREVRANGEBYSCORE/a/4/2/', params=[('withscores', 1), ('score_cast_func', 'int')]) == \
            [[b('a4'), 4], [b('a3'), 3], [b('a2'), 2]]

    def test_zrevrank(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3), ('a4', 4), ('a5', 5)]})
        assert self.arg('/ZREVRANK/a/a1/') == 4
        assert self.arg('/ZREVRANK/a/a2/') == 3
        assert self.arg('/ZREVRANK/a/a6/') is None

    def test_zscore(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})
        assert self.arg('/ZSCORE/a/a1/') == 1.0
        assert self.arg('/ZSCORE/a/a2/') == 2.0
        assert self.arg('/ZSCORE/a/a4/') is None

    def test_zunionstore_sum(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 1), ('a3', 1)]})
        self.arp('/ZADD/b/', {'scores': [('a1', 2), ('a2', 2), ('a3', 2)]})
        self.arp('/ZADD/c/', {'scores': [('a1', 6), ('a3', 5), ('a4', 4)]})
        assert self.arp('/ZUNIONSTORE/', {'dest': 'd', 'keys': ['a', 'b', 'c']}) == 4
        assert self.arg('/ZRANGE/d/0/-1/', params=[('withscores', 1)]) == \
            [[b('a2'), 3], [b('a4'), 4], [b('a3'), 8], [b('a1'), 9]]

    def test_zunionstore_max(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 1), ('a3', 1)]})
        self.arp('/ZADD/b/', {'scores': [('a1', 2), ('a2', 2), ('a3', 2)]})
        self.arp('/ZADD/c/', {'scores': [('a1', 6), ('a3', 5), ('a4', 4)]})
        assert self.arp('/ZUNIONSTORE/', {'dest': 'd', 'keys': ['a', 'b', 'c'], 'aggregate': 'MAX'}) == 4
        assert self.arg('/ZRANGE/d/0/-1/', params=[('withscores', 1)]) == \
            [[b('a2'), 2], [b('a4'), 4], [b('a3'), 5], [b('a1'), 6]]

    def test_zunionstore_min(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 2), ('a3', 3)]})
        self.arp('/ZADD/b/', {'scores': [('a1', 2), ('a2', 2), ('a3', 4)]})
        self.arp('/ZADD/c/', {'scores': [('a1', 6), ('a3', 5), ('a4', 4)]})
        assert self.arp('/ZUNIONSTORE/', {'dest': 'd', 'keys': ['a', 'b', 'c'], 'aggregate': 'MIN'}) == 4
        assert self.arg('/ZRANGE/d/0/-1/', params=[('withscores', 1)]) == \
            [[b('a1'), 1], [b('a2'), 2], [b('a3'), 3], [b('a4'), 4]]

    def test_zunionstore_with_weight(self):
        self.arp('/ZADD/a/', {'scores': [('a1', 1), ('a2', 1), ('a3', 1)]})
        self.arp('/ZADD/b/', {'scores': [('a1', 2), ('a2', 2), ('a3', 2)]})
        self.arp('/ZADD/c/', {'scores': [('a1', 6), ('a3', 5), ('a4', 4)]})
        assert self.arp('/ZUNIONSTORE/', {'dest': 'd', 'keys': {'a': 1, 'b': 2, 'c': 3}}) == 4
        assert self.arg('/ZRANGE/d/0/-1/', params=[('withscores', 1)]) == \
            [[b('a2'), 5], [b('a4'), 12], [b('a3'), 20], [b('a1'), 23]]

    ### HASH COMMANDS ###
    def test_hget_and_hset(self):
        self.arp('/HMSET/a/', {'mapping': {'1': 1, '2': 2, '3': 3}})
        assert self.arg('/HGET/a/1/') == b('1')
        assert self.arg('/HGET/a/2/') == b('2')
        assert self.arg('/HGET/a/3/') == b('3')

        # field was updated redis returns 0
        assert self.arp('/HSET/a/2/', {'value': '5'}) == 0
        assert self.arg('/HGET/a/2/') == b('5')

        # field is new redis returns 1
        assert self.arp('/HSET/a/4/', {'value': '4'}) == 1
        assert self.arg('/HGET/a/4/') == b('4')

        # key inside of hash that doesn't exist returns null value
        assert self.arg('/HGET/a/b/') is None

    def test_hdel(self):
        self.arp('/HMSET/a/', {'mapping': {'1': 1, '2': 2, '3': 3}})
        assert self.ard('/HDEL/a/', params=[('key', 2)]) == 1
        assert self.arg('/HGET/a/2/') is None
        assert self.ard('/HDEL/a/', params=[('key', 1), ('key', 3)]) == 2
        assert self.arg('/HLEN/a/') == 0

    def test_hexists(self):
        self.arp('/HMSET/a/', {'mapping': {'1': 1, '2': 2, '3': 3}})
        assert self.arg('/HEXISTS/a/1/')
        assert not self.arg('/HEXISTS/a/4/')

    def test_hgetall(self):
        h = {b('a1'): b('1'), b('a2'): b('2'), b('a3'): b('3')}
        self.arp('/HMSET/a/', {'mapping': h})
        assert self.arg('/HGETALL/a/') == h

    def test_hincrby(self):
        assert self.arp('/HINCRBY/a/1/') == 1
        assert self.arp('/HINCRBY/a/1/', {'amount': 2}) == 3
        assert self.arp('/HINCRBY/a/1/', {'amount': -2}) == 1

    def test_hincrbyfloat(self):
        assert self.arp('/HINCRBYFLOAT/a/1/') == 1.0
        assert self.arp('/HINCRBYFLOAT/a/1/',) == 2.0
        assert self.arp('/HINCRBYFLOAT/a/1/', {'amount': 1.2}) == 3.2

    def test_hkeys(self):
        h = {b('a1'): b('1'), b('a2'): b('2'), b('a3'): b('3')}
        self.arp('/HMSET/a/', {'mapping': h})
        local_keys = h.keys()
        remote_keys = self.arg('/HKEYS/a/')
        assert (sorted(local_keys) == sorted(remote_keys))

    def test_hlen(self):
        self.arp('/HMSET/a/', {'mapping': {'1': 1, '2': 2, '3': 3}})
        assert self.arg('/HLEN/a/') == 3

    def test_hmget(self):
        self.arp('/HMSET/a/', {'mapping': {'a': 1, 'b': 2, 'c': 3}})
        assert self.arg('/HMGET/a/', params=[('key', 'a'), ('key', 'b'), ('key', 'c')]) == [b('1'), b('2'), b('3')]

    def test_hmset(self):
        h = {b('a'): b('1'), b('b'): b('2'), b('c'): b('3')}
        self.arp('/HMSET/a/', {'mapping': h})
        assert self.arg('/HGETALL/a/') == h

    def test_hsetnx(self):
        # Initially set the hash field
        assert self.arp('/HSETNX/a/', {'key': '1', 'value': '1'})
        assert self.arg('/HGET/a/1/') == '1'
        assert not self.arp('/HSETNX/a/', {'key': '1', 'value': '2'})
        assert self.arg('/HGET/a/1/') == '1'

    def test_hvals(self):
        h = {b('a1'): b('1'), b('a2'): b('2'), b('a3'): b('3')}
        self.arp('/HMSET/a/', {'mapping': h})
        local_vals = h.values()
        remote_vals = self.arg('/HVALS/a/')
        assert sorted(local_vals) == sorted(remote_vals)

    ### SORT ###
    def test_sort_basic(self):
        self.arp('/RPUSH/a/', {'values': ['3', '2', '1', '4']})
        assert self.arg('/SORT/a/') == [b('1'), b('2'), b('3'), b('4')]

    def test_sort_limited(self):
        self.arp('/RPUSH/a/', {'values': ['3', '2', '1', '4']})
        assert self.arg('/SORT/a/', params=[('start', 1), ('num', 2)]) == [b('2'), b('3')]

    def test_sort_by(self):
        self.arp('/SET/score:1/', {'value': '8'})
        self.arp('/SET/score:2/', {'value': '3'})
        self.arp('/SET/score:3/', {'value': '5'})
        self.arp('/RPUSH/a/', {'values': ['3', '2', '1']})
        assert self.arg('/SORT/a/', params=[('by', 'score:*')]) == [b('2'), b('3'), b('1')]

    def test_sort_get(self):
        self.arp('/SET/user:1/', {'value': 'u1'})
        self.arp('/SET/user:2/', {'value': 'u2'})
        self.arp('/SET/user:3/', {'value': 'u3'})
        self.arp('/RPUSH/a/', {'values': ['2', '3', '1']})
        assert self.arg('/SORT/a/', params=[('get', 'user:*')]) == [b('u1'), b('u2'), b('u3')]

    def test_sort_get_multi(self):
        self.arp('/SET/user:1/', {'value': 'u1'})
        self.arp('/SET/user:2/', {'value': 'u2'})
        self.arp('/SET/user:3/', {'value': 'u3'})
        self.arp('/RPUSH/a/', {'values': ['2', '3', '1']})
        assert self.arg('/SORT/a/', params=[('get', 'user:*'), ('get', '#')]) == \
            [b('u1'), b('1'), b('u2'), b('2'), b('u3'), b('3')]

    def test_sort_get_groups_two(self):
        self.arp('/SET/user:1/', {'value': 'u1'})
        self.arp('/SET/user:2/', {'value': 'u2'})
        self.arp('/SET/user:3/', {'value': 'u3'})
        self.arp('/RPUSH/a/', {'values': ['2', '3', '1']})
        assert self.arg('/SORT/a/', params=[('get', 'user:*'), ('get', '#'), ('groups', 1)]) == \
            [[b('u1'), b('1')], [b('u2'), b('2')], [b('u3'), b('3')]]

    def test_sort_groups_string_get(self):
        self.arp('/SET/user:1/', {'value': 'u1'})
        self.arp('/SET/user:2/', {'value': 'u2'})
        self.arp('/SET/user:3/', {'value': 'u3'})
        self.arp('/RPUSH/a/', {'values': ['2', '3', '1']})
        self.arg('/SORT/a/', params=[('get', 'user:*'), ('groups', 1)], assert_status_code=400,
                 error_string='when using "groups" the "get" argument must be specified and contain at least two keys')

    def test_sort_desc(self):
        self.arp('/RPUSH/a/', {'values': ['2', '3', '1']})
        assert self.arg('/SORT/a/', params=[('desc', 1)]) == [b('3'), b('2'), b('1')]

    def test_sort_alpha(self):
        self.arp('/RPUSH/a/', {'values': ['e', 'c', 'b', 'd', 'a']})
        assert self.arg('/SORT/a/', params=[('alpha', 1)]) == \
            [b('a'), b('b'), b('c'), b('d'), b('e')]

    def test_sort_store(self):
        self.arp('/RPUSH/a/', {'values': ['2', '3', '1']})
        assert self.arg('/SORT/a/', params=[('store', 'sorted_values')]) == 3
        assert self.arg('/LRANGE/sorted_values/0/-1/') == [b('1'), b('2'), b('3')]

# class TestStrictCommands(object):

#     def test_strict_zadd(self, sr):
#         sr.zadd('a', 1.0, 'a1', 2.0, 'a2', a3=3.0)
#         assert sr.zrange('a', 0, -1, withscores=True) == \
#             [(b('a1'), 1.0), (b('a2'), 2.0), (b('a3'), 3.0)]

#     def test_strict_lrem(self, sr):
#         sr.rpush('a', 'a1', 'a2', 'a3', 'a1')
#         sr.lrem('a', 0, 'a1')
#         assert sr.lrange('a', 0, -1) == [b('a2'), b('a3')]

#     def test_strict_setex(self, sr):
#         assert sr.setex('a', 60, '1')
#         assert sr['a'] == b('1')
#         assert 0 < sr.ttl('a') <= 60

#     def test_strict_ttl(self, sr):
#         assert not sr.expire('a', 10)
#         sr['a'] = '1'
#         assert sr.expire('a', 10)
#         assert 0 < sr.ttl('a') <= 10
#         assert sr.persist('a')
#         assert sr.ttl('a') == -1

#     @skip_if_server_version_lt('2.6.0')
#     def test_strict_pttl(self, sr):
#         assert not sr.pexpire('a', 10000)
#         sr['a'] = '1'
#         assert sr.pexpire('a', 10000)
#         assert 0 < sr.pttl('a') <= 10000
#         assert sr.persist('a')
#         assert sr.pttl('a') == -1


# class TestBinarySave(object):
#     def test_binary_get_set(self):
#         assert r.set(' foo bar ', '123')
#         assert r.get(' foo bar ') == b('123')

#         assert r.set(' foo\r\nbar\r\n ', '456')
#         assert r.get(' foo\r\nbar\r\n ') == b('456')

#         assert r.set(' \r\n\t\x07\x13 ', '789')
#         assert r.get(' \r\n\t\x07\x13 ') == b('789')

#         assert sorted(r.keys('*')) == \
#             [b(' \r\n\t\x07\x13 '), b(' foo\r\nbar\r\n '), b(' foo bar ')]

#         assert r.delete(' foo bar ')
#         assert r.delete(' foo\r\nbar\r\n ')
#         assert r.delete(' \r\n\t\x07\x13 ')

#     def test_binary_lists(self):
#         mapping = {
#             b('foo bar'): [b('1'), b('2'), b('3')],
#             b('foo\r\nbar\r\n'): [b('4'), b('5'), b('6')],
#             b('foo\tbar\x07'): [b('7'), b('8'), b('9')],
#         }
#         # fill in lists
#         for key, value in iteritems(mapping):
#             r.rpush(key, *value)

#         # check that KEYS returns all the keys as they are
#         assert sorted(r.keys('*')) == sorted(list(iterkeys(mapping)))

#         # check that it is possible to get list content by key name
#         for key, value in iteritems(mapping):
#             assert r.lrange(key, 0, -1) == value

#     def test_22_info(self):
#         """
#         Older Redis versions contained 'allocation_stats' in INFO that
#         was the cause of a number of bugs when parsing.
#         """
#         info = "allocation_stats:6=1,7=1,8=7141,9=180,10=92,11=116,12=5330," \
#                "13=123,14=3091,15=11048,16=225842,17=1784,18=814,19=12020," \
#                "20=2530,21=645,22=15113,23=8695,24=142860,25=318,26=3303," \
#                "27=20561,28=54042,29=37390,30=1884,31=18071,32=31367,33=160," \
#                "34=169,35=201,36=10155,37=1045,38=15078,39=22985,40=12523," \
#                "41=15588,42=265,43=1287,44=142,45=382,46=945,47=426,48=171," \
#                "49=56,50=516,51=43,52=41,53=46,54=54,55=75,56=647,57=332," \
#                "58=32,59=39,60=48,61=35,62=62,63=32,64=221,65=26,66=30," \
#                "67=36,68=41,69=44,70=26,71=144,72=169,73=24,74=37,75=25," \
#                "76=42,77=21,78=126,79=374,80=27,81=40,82=43,83=47,84=46," \
#                "85=114,86=34,87=37,88=7240,89=34,90=38,91=18,92=99,93=20," \
#                "94=18,95=17,96=15,97=22,98=18,99=69,100=17,101=22,102=15," \
#                "103=29,104=39,105=30,106=70,107=22,108=21,109=26,110=52," \
#                "111=45,112=33,113=67,114=41,115=44,116=48,117=53,118=54," \
#                "119=51,120=75,121=44,122=57,123=44,124=66,125=56,126=52," \
#                "127=81,128=108,129=70,130=50,131=51,132=53,133=45,134=62," \
#                "135=12,136=13,137=7,138=15,139=21,140=11,141=20,142=6,143=7," \
#                "144=11,145=6,146=16,147=19,148=1112,149=1,151=83,154=1," \
#                "155=1,156=1,157=1,160=1,161=1,162=2,166=1,169=1,170=1,171=2," \
#                "172=1,174=1,176=2,177=9,178=34,179=73,180=30,181=1,185=3," \
#                "187=1,188=1,189=1,192=1,196=1,198=1,200=1,201=1,204=1,205=1," \
#                "207=1,208=1,209=1,214=2,215=31,216=78,217=28,218=5,219=2," \
#                "220=1,222=1,225=1,227=1,234=1,242=1,250=1,252=1,253=1," \
#                ">=256=203"
#         parsed = parse_info(info)
#         assert 'allocation_stats' in parsed
#         assert '6' in parsed['allocation_stats']
#         assert '>=256' in parsed['allocation_stats']

#     def test_large_responses(self):
#         "The PythonParser has some special cases for return values > 1MB"
#         # load up 5MB of data into a key
#         data = ''.join([ascii_letters] * (5000000 // len(ascii_letters)))
#         r['a'] = data
#         assert r['a'] == b(data)

#     def test_floating_point_encoding(self):
#         """
#         High precision floating point values sent to the server should keep
#         precision.
#         """
#         timestamp = 1349673917.939762
#         r.zadd('a', 'a1', timestamp)
#         assert r.zscore('a', 'a1') == timestamp


class TestFlaskRedisCommands(RedisCommands, unittest.TestCase):
    def setUp(self):
        self.app_ref = app
        self.app = app.test_client()

    def tearDown(self):
        self.api_request('/FLUSHDB/', method='DELETE')

    def api_request(self, path, method='GET', params=None, data=None, headers=None, assert_status_code=200, error_string=None, content_type='application/json'):
        data = json.dumps(data) if data else None

        query_string = None
        if params:
            query_string = urlencode(params)

        resp = self.app.open('/api/0%s' % path, method=method, query_string=query_string, data=data,
                             headers=headers, content_type='application/json')

        if assert_status_code:
            self.assertEquals(assert_status_code, resp.status_code)

        resp = json.loads(resp.data)
        if error_string:
            self.assertEquals(resp['meta']['error_message'], error_string)

        return (resp.get('meta'), resp.get('data'))

    def arp(self, path, data=None):
        _, data = self.api_request(path, method='POST', data=data)
        return data

    def ard(self, path, params=None):
        _, data = self.api_request(path, method='DELETE', params=params)
        return data

    def arg(self, path, params=None, assert_status_code=200, error_string=None):
        _, data = self.api_request(path, params=params, assert_status_code=assert_status_code, error_string=error_string, content_type=None)
        return data

    def test_scope_getter(self):
        DEFAULT_LARK_SCOPES = self.app_ref.config['DEFAULT_LARK_SCOPES']
        self.app_ref.config['DEFAULT_LARK_SCOPES'] = None

        def scope_getter(*args, **kwargs):
            return set(['admin'])

        self.app_ref.config['LARK_SCOPE_GETTER'] = scope_getter

        meta, data = self.api_request('/CLIENT/LIST/')
        assert isinstance(data[0], dict)
        assert 'addr' in data[0]

        self.app_ref.config['DEFAULT_LARK_SCOPES'] = DEFAULT_LARK_SCOPES
        self.app_ref.config['LARK_SCOPE_GETTER'] = None


try:
    import django
except ImportError, e:
    raise Exception('To run the tests you must have Django installed')


from django.conf import settings

DIRNAME = os.path.dirname(__file__)

settings.configure(DEBUG=True,
                   ROOT_URLCONF='lark.ext.django.urls',
                   DATABASE_ENGINE='sqlite3',
                   DATABASE_NAME=os.path.join(DIRNAME, 'database.db'),
                   INSTALLED_APPS=('django.contrib.auth', 'lark.ext.django'),
                   REDIS_CONNECTION_METHOD= lambda: redis.Redis.from_url('redis://localhost:6379/10'),
                   DEFAULT_LARK_SCOPES=set(['admin'])
                   )

from django.test.utils import setup_test_environment
setup_test_environment()


from django.test.client import Client
client = Client()


class TestDjangoRedisCommands(RedisCommands, unittest.TestCase):
    def setUp(self):
        self.client = client

    def tearDown(self):
        self.api_request('/FLUSHDB/', method='DELETE')

    def api_request(self, path, method='GET', params=None, data=None, assert_status_code=200, error_string=None, content_type='application/json'):
        data = json.dumps(data) if data else None

        query_string = None
        if params:
            query_string = urlencode(params)

        path = '%s' % path

        if query_string:
            path = path + '?' + query_string
        kwargs = {}
        if data:
            kwargs['data'] = data

        if method == 'POST':
            requester = self.client.post
        elif method == 'PATCH':
            requester = self.client.patch
        elif method == 'PUT':
            requester = self.client.put
        elif method == 'GET':
            requester = self.client.get
        elif method == 'DELETE':
            requester = self.client.delete

        resp = requester(path, content_type=content_type, **kwargs)

        if assert_status_code:
            self.assertEquals(assert_status_code, resp.status_code)

        resp = json.loads(resp.content)
        if error_string:
            self.assertEquals(resp['meta']['error_message'], error_string)

        return (resp.get('meta'), resp.get('data'))

    def arp(self, path, data=None):
        _, data = self.api_request(path, method='POST', data=data)
        return data

    def ard(self, path, params=None):
        _, data = self.api_request(path, method='DELETE', params=params)
        return data

    def arg(self, path, params=None, assert_status_code=200, error_string=None):
        _, data = self.api_request(path, params=params, assert_status_code=assert_status_code, error_string=error_string, content_type=None)
        return data

    def test_scope_getter(self):
        DEFAULT_LARK_SCOPES = settings.DEFAULT_LARK_SCOPES
        settings.DEFAULT_LARK_SCOPES = None

        def scope_getter(*args, **kwargs):
            return set(['admin'])

        settings.DEFAULT_LARK_SCOPES = None
        settings.LARK_SCOPE_GETTER = scope_getter

        meta, data = self.api_request('/CLIENT/LIST/')
        assert isinstance(data[0], dict)
        assert 'addr' in data[0]

        settings.DEFAULT_LARK_SCOPES = DEFAULT_LARK_SCOPES
        settings.LARK_SCOPE_GETTER = None

########NEW FILE########
__FILENAME__ = test_schemas
from colander import Invalid
from lark.redis import schemas
import unittest


"""Unit tests"""
class SchemaTests(unittest.TestCase):

    def run_schema(self, schema, cstruct):
        # schema = schema_cls()
        schema.redis_prefix = 'awesome'
        return schema.deserialize(cstruct)

    def test_key_schema(self):
        cstruct = {'key': 'awesome'}
        self.run_schema(schemas.KeySchema, cstruct)
        cstruct = {}
        with self.assertRaises(Invalid):
            data = self.run_schema(schemas.KeySchema, cstruct)

    def test_value_schema(self):
        cstruct = {'value': 'awesome'}
        self.run_schema(schemas.ValueSchema, cstruct)

    def test_key_value_schema(self):
        cstruct = {'key': 'awesome', 'value': 'awesome'}
        self.run_schema(schemas.KeyValueSchema, cstruct)

        data = {'key': 'a', 'value': 'value'}
        schemas.KeyValueSchema.redis_prefix = 'awesome'
        to_redis = schemas.KeyValueSchema.deserialize(data)
        self.assertEqual(to_redis['key'], 'awesome:a')

    def test_set_schema(self):
        cstruct = {'key': 'awesome', 'value': 'awesome'}
        self.run_schema(schemas.SetSchema, cstruct)

        cstruct['px'] = 1000
        self.run_schema(schemas.SetSchema, cstruct)

        cstruct['nx'] = True
        self.run_schema(schemas.SetSchema, cstruct)

        cstruct['nx'] = 1
        self.run_schema(schemas.SetSchema, cstruct)

    def test_bit_op_schema(self):
        cstruct = {'operation': 'awesome', 'destkey': 'cool', 'key': ['blah']}
        self.run_schema(schemas.BitOpSchema, cstruct)

        cstruct = {'operation': 'awesome', 'destkey': 'cool', 'key': 'blah'}
        with self.assertRaises(Invalid):
            self.run_schema(schemas.BitOpSchema, cstruct)

    def test_redis_reference_type(self):
        node = DummySchemaNode(None)
        node.redis_prefix = 'awesome'
        typ = schemas.PrefixedRedisReferenceType()
        result = typ.deserialize(node, 'test')
        self.assertEqual(result, 'awesome:test')
        result = typ.serialize(node, 'awesome:test')
        self.assertEqual(result, 'test')

    def test_lark_string_type(self):
        node = DummySchemaNode(None)
        typ = schemas.LarkString()
        # Normal strings
        result = typ.deserialize(node, 'test')
        self.assertEqual(result, 'test')
        # Empty strings
        result = typ.deserialize(node, '')
        self.assertEqual(result, '')

        # Even strings that look like numers
        result = typ.deserialize(node, '1')
        self.assertEqual(result, '1')

        # Integers can be strings too
        result = typ.deserialize(node, 1.0)
        self.assertEqual(result, '1.0') 

        # Integers can be strings too
        result = typ.deserialize(node, 1)
        self.assertEqual(result, '1')  


    def test_redis_value_type(self):
        node = DummySchemaNode(None)
        typ = schemas.RedisValueType()
        # Normal strings
        result = typ.deserialize(node, 'test')
        self.assertEqual(result, 'test')
        result = typ.serialize(node, result)
        self.assertEqual(result, 'test')

        # Empty strings
        result = typ.deserialize(node, '')
        self.assertEqual(result, '')
        result = typ.serialize(node, result)
        self.assertEqual(result, '')

        # Even strings that look like numers
        result = typ.deserialize(node, '1')
        self.assertEqual(result, '1')
        result = typ.serialize(node, result)
        self.assertEqual(result, '1')

        # Integers can be strings too
        result = typ.deserialize(node, 1)
        self.assertEqual(result, 1) 
        result = typ.serialize(node, result)
        self.assertEqual(result, 1)

        # Floats can be strings too
        result = typ.deserialize(node, 1.0)
        self.assertEqual(result, 1.0) 
        result = typ.serialize(node, result)
        self.assertEqual(result, 1.0)

        h = {'a': 'b'}
        result = typ.deserialize(node, h)
        self.assertEqual(result, '{"a": "b"}')
        result = typ.serialize(node, result)
        self.assertEqual(result, h)


class DummySchemaNode(object):
    def __init__(self, typ, name='', exc=None, default=None):
        self.typ = typ
        self.name = name
        self.exc = exc
        self.required = default is None
        self.default = default
        self.children = []

    def deserialize(self, val):
        from colander import Invalid
        if self.exc:
            raise Invalid(self, self.exc)
        return val

    def serialize(self, val):
        from colander import Invalid
        if self.exc:
            raise Invalid(self, self.exc)
        return val

    def __getitem__(self, name):
        for child in self.children:
            if child.name == name:
                return child

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
