__FILENAME__ = ckstyle-admin
from ckstyle.command.index import ckstyle

if __name__ == '__main__':
    ckstyle()

########NEW FILE########
__FILENAME__ = compress-admin
from ckstyle.command.index import compress

if __name__ == '__main__':
    compress()

########NEW FILE########
__FILENAME__ = fixstyle-admin
from ckstyle.command.index import fixstyle

if __name__ == '__main__':
    fixstyle()

########NEW FILE########
__FILENAME__ = Analyser
#/usr/bin/python
#encoding=utf-8

from .BinaryRule import *

basic = {
	'ie6' : IE6,
	'ie7' : IE7,
	'ie8' : IE8,
	'ie9' : IE9PLUS,
	'ie10': IE9PLUS,
	'chrome' : CHROME,
	'firefox' : FIREFOX,
	'opera' : OPERA,
	'safari' : SAFARI,
	'std' : STD | NONEIE
}

mapping = {
	'ie' : ALLIE,
	'ie9plus' : IE9PLUS,
	'std' : STD | NONEIE
}

mapping.update(basic)

allBrowsers = ','.join([x for x in mapping.keys() if x != 'webkit' and x != 'ie9plus'])

def analyse(text):
	if not text or text == '' or text=='none' or text == 'false':
		return None
	if text == 'all':
		text = allBrowsers
	text = text.lower()
	splited = text.split(',')
	browsers = {}

	for browser in splited:
		if mapping.has_key(browser):
			# 不管如何选择，STD的总是要显示的
			browsers[browser] = mapping[browser] | STD
	return browsers

def whatIs(code):
	result = []
	for name, value in basic.items():
		if value & code:
			result.append(name)

	return ','.join(result)

if __name__ == '__main__':
	print(analyse('ie6,std'))
	print(whatIs(FIREFOX))
########NEW FILE########
__FILENAME__ = BinaryRule
#/usr/bin/python
#encoding=utf-8

'''
  0b111111111
    |||||||||
    |||||||||
    |||||||||--ie6 ---------|
    ||||||||--ie7  ---------|
    |||||||--ie8   ---------| ALLIE
    ||||||--ie9+   ---------|
    |||||
    |||||--opera
    ||||--safari   ---------|
    |||--firefox            | WEBKIT
    ||-- chrome    ---------|
    |-- STD
'''

ORIGIN = 0b000000000

STD    = 0b100000000
CHROME = 0b010000000
FIREFOX= 0b001000000
SAFARI = 0b000100000
OPERA  = 0b000010000

WEBKIT = CHROME | SAFARI 

NONEIE = CHROME | SAFARI | OPERA | FIREFOX

IE9PLUS= 0b000001000
IE8    = 0b000000100
IE7    = 0b000000010
IE6    = 0b000000001
ALLIE  = IE9PLUS | IE8 | IE7 | IE6

NOIE6  = IE9PLUS | IE8 | IE7 | NONEIE
NOIE67 = IE9PLUS | IE8 | NONEIE
NOIE678= IE9PLUS | NONEIE
NONE   = 0b000000000
ALL    = 0b111111111
########NEW FILE########
__FILENAME__ = Detector
#/usr/bin/python
#encoding=utf-8
from .BinaryRule import *
from .Hacks import doRuleDetect, doRuleSetDetect, doExtraDetect

class Browser():

    @staticmethod
    def handleRule(rule):
        rule.browser = doRuleDetect(rule.fixedName, rule.fixedValue)

    @staticmethod
    def handleRuleSet(ruleSet):
        ruleSet.browser = doRuleSetDetect(ruleSet.selector)
    
    @staticmethod
    def handleNestedStatement(statement):
    	statement.browser = doExtraDetect(statement.selector)
########NEW FILE########
__FILENAME__ = Hacks
#/usr/bin/python
#encoding=utf-8
from BinaryRule import *
import re

# http://www.swordair.com/tools/css-hack-table/
# big table

# some hacks
RULE_HACKS = [
    [re.compile(r'^_'),                     1,  IE6],
    [re.compile(r'^\+'),                    1,  IE6 | IE7],
    [re.compile(r'^\*'),                    1,  IE6 | IE7],
    [re.compile(r'.*\\9'),                  2,  ALLIE],
    [re.compile(r'.*\\0/'),                 2,  IE8],
    [re.compile(r'.*\\0'),                  2,  IE8 | IE9PLUS],
    [re.compile(r'zoom|behavior|filter'),   1,  ALLIE],
    [re.compile(r'.*(m|M)icrosoft'),        2,  ALLIE],
    [re.compile(r'^expression'),            2,  ALLIE],
    [re.compile(r'^\-webkit\-'),            1,  WEBKIT],
    [re.compile(r'^\-webkit\-'),            2,  WEBKIT],
    [re.compile(r'^\-moz\-'),               1,  FIREFOX],
    [re.compile(r'^\-moz\-'),               2,  FIREFOX],
    [re.compile(r'^\-ms\-'),                1,  IE9PLUS],
    [re.compile(r'^\-ms\-'),                2,  IE9PLUS],
    [re.compile(r'^\-khtml\-'),             1,  ALLIE],
    [re.compile(r'^\-khtml\-'),             2,  ALLIE],
    [re.compile(r'^\-o\-'),                 1,  OPERA],
    [re.compile(r'^\-o\-'),                 2,  OPERA],

    # auto generated by script AUTO-GENERATOR-1 .
    [re.compile(r'^alignment\-adjust'), 1, NONE],
    [re.compile(r'^alignment\-baseline'), 1, NONE],
    [re.compile(r'^animation'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^animation\-name'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^animation\-duration'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^animation\-timing\-function'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^animation\-delay'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^animation\-iteration\-count'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^animation\-direction'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^animation\-play\-state'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^appearance'), 1, FIREFOX | CHROME | SAFARI],
    [re.compile(r'^backface\-visibility'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI],
    [re.compile(r'^background\-clip'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^background\-origin'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^background\-size'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^baseline\-shift'), 1, NONE],
    [re.compile(r'^bookmark\-label'), 1, NONE],
    [re.compile(r'^bookmark\-level'), 1, NONE],
    [re.compile(r'^bookmark\-target'), 1, NONE],
    [re.compile(r'^border\-bottom\-left\-radius'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^border\-bottom\-right\-radius'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^border\-image'), 1, FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^border\-image\-outset'), 1, NONE],
    [re.compile(r'^border\-image\-repeat'), 1, NONE],
    [re.compile(r'^border\-image\-slice'), 1, NONE],
    [re.compile(r'^border\-image\-source'), 1, NONE],
    [re.compile(r'^border\-image\-width'), 1, NONE],
    [re.compile(r'^border\-radius'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^border\-top\-left\-radius'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^border\-top\-right\-radius'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^box\-decoration\-break'), 1, NONE],
    [re.compile(r'^box\-align'), 1, FIREFOX | CHROME | SAFARI],
    [re.compile(r'^box\-direction'), 1, FIREFOX | CHROME | SAFARI],
    [re.compile(r'^box\-flex'), 1, FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^box\-flex\-group'), 1, NONE],
    [re.compile(r'^box\-lines'), 1, NONE],
    [re.compile(r'^box\-ordinal\-group'), 1, FIREFOX | CHROME | SAFARI],
    [re.compile(r'^box\-orient'), 1, FIREFOX | CHROME | SAFARI],
    [re.compile(r'^box\-pack'), 1, FIREFOX | CHROME | SAFARI],
    [re.compile(r'^box\-shadow'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^box\-sizing'), 1, IE8 | IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^color\-profile'), 1, NONE],
    [re.compile(r'^column\-fill'), 1, NONE],
    [re.compile(r'^column\-gap'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^column\-rule'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^column\-rule\-color'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^column\-rule\-style'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^column\-rule\-width'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^column\-span'), 1, IE9PLUS | CHROME | SAFARI | OPERA],
    [re.compile(r'^column\-width'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^columns'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^column\-count'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^crop'), 1, NONE],
    [re.compile(r'^dominant\-baseline'), 1, NONE],
    [re.compile(r'^drop\-initial\-after\-adjust'), 1, NONE],
    [re.compile(r'^drop\-initial\-after\-align'), 1, NONE],
    [re.compile(r'^drop\-initial\-before\-adjust'), 1, NONE],
    [re.compile(r'^drop\-initial\-before\-align'), 1, NONE],
    [re.compile(r'^drop\-initial\-size'), 1, NONE],
    [re.compile(r'^drop\-initial\-value'), 1, NONE],
    [re.compile(r'^fit'), 1, NONE],
    [re.compile(r'^fit\-position'), 1, NONE],
    [re.compile(r'^float\-offset'), 1, NONE],
    [re.compile(r'^font\-size\-adjust'), 1, FIREFOX],
    [re.compile(r'^font\-stretch'), 1, NONE],
    [re.compile(r'^grid\-columns'), 1, NONE],
    [re.compile(r'^grid\-rows'), 1, NONE],
    [re.compile(r'^hanging\-punctuation'), 1, NONE],
    [re.compile(r'^hyphenate\-after'), 1, NONE],
    [re.compile(r'^hyphenate\-before'), 1, NONE],
    [re.compile(r'^hyphenate\-characters'), 1, NONE],
    [re.compile(r'^hyphenate\-lines'), 1, NONE],
    [re.compile(r'^hyphenate\-resource'), 1, NONE],
    [re.compile(r'^hyphens'), 1, NONE],
    [re.compile(r'^icon'), 1, NONE],
    [re.compile(r'^image\-orientation'), 1, NONE],
    [re.compile(r'^image\-resolution'), 1, NONE],
    [re.compile(r'^inline\-box\-align'), 1, NONE],
    [re.compile(r'^line\-stacking'), 1, NONE],
    [re.compile(r'^line\-stacking\-ruby'), 1, NONE],
    [re.compile(r'^line\-stacking\-shift'), 1, NONE],
    [re.compile(r'^line\-stacking\-strategy'), 1, NONE],
    [re.compile(r'^mark'), 1, NONE],
    [re.compile(r'^mark\-after'), 1, NONE],
    [re.compile(r'^mark\-before'), 1, NONE],
    [re.compile(r'^marks'), 1, NONE],
    [re.compile(r'^marquee\-direction'), 1, CHROME | SAFARI],
    [re.compile(r'^marquee\-play\-count'), 1, CHROME | SAFARI],
    [re.compile(r'^marquee\-speed'), 1, CHROME | SAFARI],
    [re.compile(r'^marquee\-style'), 1, CHROME | SAFARI],
    [re.compile(r'^move\-to'), 1, NONE],
    [re.compile(r'^nav\-down'), 1, OPERA],
    [re.compile(r'^nav\-index'), 1, OPERA],
    [re.compile(r'^nav\-left'), 1, OPERA],
    [re.compile(r'^nav\-right'), 1, OPERA],
    [re.compile(r'^nav\-up'), 1, OPERA],
    [re.compile(r'^opacity'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^outline\-offset'), 1, FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^overflow\-style'), 1, NONE],
    [re.compile(r'^overflow\-x'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^overflow\-y'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^page'), 1, NONE],
    [re.compile(r'^page\-policy'), 1, NONE],
    [re.compile(r'^perspective'), 1, CHROME | SAFARI],
    [re.compile(r'^perspective\-origin'), 1, CHROME | SAFARI],
    [re.compile(r'^punctuation\-trim'), 1, NONE],
    [re.compile(r'^rendering\-intent'), 1, NONE],
    [re.compile(r'^resize'), 1, FIREFOX | CHROME | SAFARI],
    [re.compile(r'^rest'), 1, NONE],
    [re.compile(r'^rest\-after'), 1, NONE],
    [re.compile(r'^rest\-before'), 1, NONE],
    [re.compile(r'^rotation'), 1, NONE],
    [re.compile(r'^rotation\-point'), 1, NONE],
    [re.compile(r'^ruby\-align'), 1, IE9PLUS],
    [re.compile(r'^ruby\-overhang'), 1, IE9PLUS],
    [re.compile(r'^ruby\-position'), 1, IE9PLUS],
    [re.compile(r'^ruby\-span'), 1, NONE],
    [re.compile(r'^size'), 1, NONE],
    [re.compile(r'^string\-set'), 1, NONE],
    [re.compile(r'^target'), 1, NONE],
    [re.compile(r'^target\-name'), 1, NONE],
    [re.compile(r'^target\-new'), 1, NONE],
    [re.compile(r'^target\-position'), 1, NONE],
    [re.compile(r'^text\-align\-last'), 1, NONE],
    [re.compile(r'^text\-emphasis'), 1, NONE],
    [re.compile(r'^text\-height'), 1, NONE],
    [re.compile(r'^text\-justify'), 1, ALLIE],
    [re.compile(r'^text\-outline'), 1, NONE],
    [re.compile(r'^text\-overflow'), 1, ALLIE | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^text\-shadow'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^text\-wrap'), 1, NONE],
    [re.compile(r'^transform'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^transform\-origin'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^transform\-style'), 1, CHROME | SAFARI],
    [re.compile(r'^transition'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^transition\-property'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^transition\-duration'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^transition\-timing\-function'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^transition\-delay'), 1, IE9PLUS | FIREFOX | CHROME | SAFARI | OPERA],
    [re.compile(r'^word\-break'), 1, ALLIE | FIREFOX | CHROME | SAFARI],
    [re.compile(r'^word\-wrap'), 1, ALLIE | FIREFOX | CHROME | SAFARI | OPERA]
]

# some hacks
RULESET_HACKS = [
    [re.compile(r'\*html'),                 1, IE6],
    [re.compile(r'\*\+html'),               1, IE7],
    [re.compile(r'\*:first\-child\+html'),  1, IE7],
    [re.compile(r'html>body'),              1, IE7 | IE8 | IE9PLUS],
    [re.compile(r'html>/\*\*/body'),        1, IE8 | IE9PLUS],
    [re.compile(r'.*\-webkit\-'),           1, WEBKIT],
    [re.compile(r'.*\-moz\-'),              1, FIREFOX],
    [re.compile(r'.*\-ms\-'),               1, IE9PLUS],
    [re.compile(r'.*\-o\-'),                1, OPERA],

    #auto generated by script AUTO-GENERATOR-2 .
    [re.compile(r'.+:first\-line'), 1, NOIE6],
    [re.compile(r'.+:first\-letter'), 1, NOIE6],
    [re.compile(r'\.[^\s]+\.[^\s]+'), 2, NOIE6],
    [re.compile(r'.+>.+'), 1, NOIE6],
    [re.compile(r'.+:first\-child'), 1, NOIE6],
    [re.compile(r'.+:focus'), 1, NOIE67],
    [re.compile(r'.+\+.+'), 1, NOIE6],
    [re.compile(r'.+\[.+\]'), 1, NOIE6],
    [re.compile(r'.+\[.+=.+\]'), 1, NOIE6],
    [re.compile(r'.+\[.+~=.+\]'), 1, NOIE6],
    [re.compile(r'.+:before'), 1, NOIE67],
    [re.compile(r'.+:after'), 1, NOIE67],
    [re.compile(r'.+~.+'), 1, NOIE6],
    [re.compile(r'.+\[.+\^=.+\]'), 1, NOIE6],
    [re.compile(r'.+\[.+\$=.+\]'), 1, NOIE6],
    [re.compile(r'.+\[.+\*=.+\]'), 1, NOIE6],
    [re.compile(r'.+\[.+\|=.+\]'), 1, NOIE6],
    [re.compile(r'.+:root'), 1, NOIE678],
    [re.compile(r'.+:nth\-of\-type'), 1, NOIE678],
    [re.compile(r'.+:nth\-last\-of\-type'), 1, NOIE678],
    [re.compile(r'.+:first\-of\-type'), 1, NOIE678],
    [re.compile(r'.+:last\-of\-type'), 1, NOIE678],
    [re.compile(r'.+:only\-of\-type'), 1, NOIE678],
    [re.compile(r'.+:only\-child'), 1, NOIE678],
    [re.compile(r'.+:last\-child'), 1, NOIE678],
    [re.compile(r'.+:nth\-child'), 1, NOIE678],
    [re.compile(r'.+:nth\-last\-child'), 1, NOIE678],
    [re.compile(r'.+:empty'), 1, NOIE678],
    [re.compile(r'.+:target'), 1, NOIE678],
    [re.compile(r'.+:checked'), 1, NOIE678],
    [re.compile(r'.+::selection'), 1, NOIE678],
    [re.compile(r'.+:enabled'), 1, NOIE678],
    [re.compile(r'.+:disabled'), 1, NOIE678],
    [re.compile(r'.+:not\(.+\)'), 1, NOIE678]
]

# .test[fd*=df], .test:not(xxx) {
#      width:100px;
# }
# use .test:not(xxx) as important hack
RULESET_HACKS.sort(lambda a, b: a[2] - b[2])

# some hacks
EXTRA_HACKS = [
    [re.compile(r'@\-webkit\-keyframes'),   WEBKIT],
    [re.compile(r'@\-moz\-keyframes'),      FIREFOX],
    [re.compile(r'@\-ms\-keyframes'),       IE9PLUS],
    [re.compile(r'@\-o\-keyframes'),        OPERA],
    [re.compile(r'@keyframes'),             NONEIE | IE9PLUS],
    [re.compile(r'@font\-face'),           IE9PLUS | NONEIE],
    [re.compile(r'@\-moz\-document'),       FIREFOX],
    [re.compile(r'@mediascreenand\(\-webkit\-min\-device\-pixel\-ratio:0\)'),  WEBKIT],
    [re.compile(r'@mediascreenand\(max\-device\-width:480px\)'),               WEBKIT],
    [re.compile(r'@mediaalland\(\-webkit\-min\-device\-pixel\-ratio:10000\),notalland\(\-webkit\-min\-device\-pixel\-ratio:0\)'),  OPERA]
]

def doRuleDetect(name, value):
    name = name.strip().replace(' ', '')
    value = value.strip().replace(' ', '')

    for hack in RULE_HACKS:
        pattern = hack[0]
        match = pattern.match(name if hack[1] == 1 else value)
        if match:
            #print name, value, bin(hack[2])
            return hack[2]
    return STD

def doRuleSetDetect(selector):
    originSelector = selector.strip();
    selector = originSelector.replace(' ', '')
    for hack in RULESET_HACKS:
        pattern = hack[0]
        match = pattern.match(selector if hack[1] == 1 else originSelector)
        if match:
            return hack[2]
    return STD

def doExtraDetect(selector):
    selector = selector.strip().replace(' ', '')
    for hack in EXTRA_HACKS:
        pattern = hack[0]
        match = pattern.match(selector)
        if match:
            return hack[1]
    return STD

if __name__ == '__main__':
    print(bin(doRuleSetDetect('.test [a=1] .test2')))
    #print(bin(doExtraDetect('@media screen and (-webkit-min-device-pixel-ratio:0)')))
    #print(bin(doExtraDetect('@media all and (-webkit-min-device-pixel-ratio:10000), not all and (-webkit-min-device-pixel-ratio:0)')))

#SCRIPT AUTO-GENERATOR-1
#execute on http://www.w3schools.com/cssref/css3_browsersupport.asp
#
#var trs = document.querySelectorAll('table.reference tr');
#var contents = [], l = trs.length, tr, tds, ie, ff, ch, sa, op;
#
#for(var i = 0; i < l; i++) {
#     tr = trs[i];
#     tds = tr.querySelectorAll('td');
#     if (tds.length == 0) {
#        continue
#     }
#     prop = tds[0].innerHTML;
#     if (prop.indexOf('<') != -1) {
#        prop = tds[0].firstChild.innerHTML
#     }
#     if (tds[1].className == 'bsNoIE') {
#        ie = 0;
#     } else if (tds[1].className == 'bsIE') {
#        ie = tds[1].innerHTML || 9
#     } else if (tds[1].className == 'bsPreIE') {
#        ie = tds[1].innerHTML || 9
#     }
#     //if (prop == 'text-emphasis') console.log(prop, ie);
#     
#     if (tds[2].className == 'bsNoFirefox') {
#        ff = 0;
#     } else if (tds[2].className == 'bsFirefox') {
#        ff = tds[2].innerHTML || 1
#     } else if (tds[2].className == 'bsPreFirefox') {
#        ff = 1
#     } else {
#        
#     }
#     
#     if (tds[3].className == 'bsNoChrome') {
#        ch = 0;
#     } else if (tds[3].className == 'bsChrome') {
#        ch = tds[3].innerHTML || 1
#     } else if (tds[3].className == 'bsPreChrome') {
#        ch = 1
#     } else {
#     }
#     
#     if (tds[4].className == 'bsNoSafari') {
#        sa = 0;
#     } else if (tds[4].className == 'bsSafari') {
#        sa = tds[4].innerHTML || 1
#     } else if (tds[4].className == 'bsPreSafari') {
#        sa = 1
#     } else {
#     }
#     
#     if (tds[5].className == 'bsNoOpera') {
#        op = 0;
#     } else if (tds[5].className == 'bsOpera') {
#        op = tds[5].innerHTML || 1
#     } else if (tds[5].className == 'bsPreOpera') {
#        op = 1
#     } else {
#     }
#     final = []
#     if (ie) {
#         if (ie <=6) {
#             final.push('ALLIE')
#         } else if (ie == 7) {
#             final.push('IE7 | IE8 | IE9PLUS')
#         } else if (ie == 8) {
#            final.push('IE8 | IE9PLUS')
#         } else if (!!ie){
#            final.push('IE9PLUS')
#         }
#    }
#     if (!!ff) {
#        final.push('FIREFOX')
#     }
#     if (!!ch) {
#        final.push('CHROME')
#    }
#    if (!!sa) {
#        final.push('SAFARI')
#    }
#    if (!!op) {
#        final.push('OPERA');
#    }
#    result = final.join(' | ');
#    if (!result) {
#        result = 'NONE'
#    }    
#    contents.push('[re.compile(r\'^' + prop.replace(/\-/g, '\\-') + '\'), 1, ' + result + '],');
#}
#console.log(contents.join('\n'));

#SCRIPT AUTO-GENERATOR-2
#execute on http://kimblim.dk/css-tests/selectors/
#
#var table = document.querySelectorAll('.testOverview tr')
#collector = []
#for (var i =0, l = table.length; i < l; i++) {
#    tr = table[i];
#    th =  tr.getElementsByTagName('th')[0]    
#    selector = th.firstChild.innerHTML
#    if (!selector) continue
#    selector = selector.replace('E', 'div')
#    selector = selector.replace('F', 'span')
#    selector = selector.replace('&gt;', '>')
#    originSelector = selector
#    
#    //console.log(selector)
#    tds = tr.getElementsByTagName('td');
#    if (tds[2].firstChild.innerHTML == 'No') {
#        res = 'NOIE678'
#    } else if (tds[1].firstChild.innerHTML == 'No') {
#        res = 'NOIE67'
#    } else if (tds[0].firstChild.innerHTML == 'No') {
#        res = 'NOIE6'
#    } else {
#        continue
#    }
#    selector = selector.replace(/\-/g, '\\-')
#    selector = selector.replace(/\*/g, '\\*')
#    selector = selector.replace(/\|/g, '\\|')
#    selector = selector.replace(/\$/g, '\\$')
#    selector = selector.replace(/\^/g, '\\^')
#    selector = selector.replace(/\s/g, '')
#    selector = selector.replace(/\+/g, '\\+')
#    selector = selector.replace(/\[/g, '\\[')
#    selector = selector.replace(/\]/g, '\\]')
#    selector = selector.replace(/\./g, '\\.')
#    selector = selector.replace(/\(s\)/g, '\\(.+\\)')
#    selector = selector.replace('"name"', '.+')
#    selector = selector.replace(/classname/g, '.+')
#    selector = selector.replace(/div|span|attr/g, '.+')
#    //console.log(selector, res)
#    collector.push('    [re.compile(r\'' + selector+ '\', ' + (originSelector == '.classname.classname' ? 2: 1) + '), ' + res + '],')
#}
#console.log(collector.join('\n'))

########NEW FILE########
__FILENAME__ = ConsoleClass
DEBUG = False
PREFIX = '[CKstyle %s] '

class console():

    @staticmethod
    def show(msg, t=""):
        if t != "":
            print(PREFIX % t + msg)
        else:
            print(msg)

    @staticmethod
    def showError(msg):
        console.show(msg, "ERROR")

    @staticmethod
    def showOk(msg):
        console.show(msg, "OK")

    @staticmethod
    def log(msg):
        if DEBUG:
            consle.show(msg, "LOG")

    @staticmethod
    def warn(msg):
        if DEBUG:
            console.show(msg, "WARN")

    @staticmethod
    def error(msg):
        if DEBUG:
            console.show(msg, "ERROR")

########NEW FILE########
__FILENAME__ = args
class CommandArgs():
    def __init__(self):
        self.operation = None
        self.errorLevel = 2
        self.recursive = False
        self.printFlag = False
        self.extension = '.ckstyle.txt'
        self.include = 'all'
        self.exclude = 'none'
        self.standard = ''
        self.exportJson = False
        self.ignoreRuleSets = ['@unit-test-expecteds']
        self.fixedExtension = '.fixed.css'
        self.fixToSingleLine = False
        self.compressConfig = CompressArgs()
        self.safeMode = False
        self.noBak = False

        # current browser
        self._curBrowser = None

        # plugin config for developers, add plugin section in ckstyle.ini
        # 
        # [plugin]
        # pluginA = 1
        self.pluginConfig = {}

    def __str__(self):
        return 'errorLevel: %s\n recursive: %s\n printFlag: %s\n extension: %s\n include: %s\n exclude: %s' % (self.errorLevel, self.recursive, self.printFlag, self.extension, self.include, self.exclude)

class CompressArgs():
    def __init__(self):
        self.extension = '.min.css'
        self.combineFile = True
        self.browsers = None
        self.noBak = False

    def __str__(self):
        return 'extension: %s, combineFile: %s, browsers: %s' % (self.recursive, self.extension, self.combineAttr, self.combineRuleSet, self.combineFile, self.browsers)

########NEW FILE########
__FILENAME__ = CommandFileParser
import os
try:
    import configparser as ConfigParser
except ImportError:
    import ConfigParser as ConfigParser
from ckstyle.cmdconsole.ConsoleClass import console
from . import args
from ckstyle.browsers.Analyser import analyse

def exists(filePath):
    return os.path.exists(filePath)

def getInt(config, group, attr, default):
    if config.has_option(group, attr):
        try:
            result = config.getint(group, attr)
            return result
        except Exception:
            console.log('%s of %s in config file should be int' % (attr, group))
    return default

def getBoolean(config, group, attr, default):
    if config.has_option(group, attr):
        try:
            result = config.getboolean(group, attr)
            return result
        except Exception:
            console.log('%s of %s in config file should be boolean' % (attr, group))
    return default

def get(config, group, attr, default, lowerFlag = False):
    if config.has_option(group, attr):
        try:
            result = config.get(group, attr)
            if lowerFlag:
                result = result.lower()
            return result
        except Exception:
            console.log('%s of %s in config file should be valid string' % (attr, group))
    return default

class PluginConfigDict():
    def __init__(self, values):
        self._config = dict(values)

    def has_key(self, key):
        return self._config.has_key(key.lower())

    def get(self, key):
        key = key.lower()
        if self.has_key(key):
            return self._config.get(key.lower())
        else:
            return None

    def __str__(self):
        return str(self._config)

class CommandFileParser():
    def __init__(self, filePath, debug = False):
        self.args = args.CommandArgs()
        if exists(filePath):
            self.load(filePath)
    
    def load(self, filePath):
        config = ConfigParser.ConfigParser()
        f = open(filePath, 'rb')
        config.readfp(f)
        self.handleOptions(config)

    def handleOptions(self, config):
        self.handleCkStyleOptions(config)
        self.handleCompressOptions(config)
        self.handleExtraOptions(config)
        self.handlePluginOption(config)

    # for plugins to config
    def handlePluginOption(self, config):
        if config.has_section('plugin'):
            self.args.pluginConfig = PluginConfigDict(config.items('plugin'))

    def handleExtraOptions(self, config):
        # handle other options, global-files for example
        pass

    def handleCompressOptions(self, config):
        args = self.args.compressConfig
        args.extension      = get       (config, 'compress', 'extension',       args.extension)
        args.combineFile    = getBoolean(config, 'compress', 'combine-file',    args.combineFile)
        args.browsers       = analyse(get(config,'compress', 'browsers',        args.browsers))
        args.noBak          = getBoolean(config, 'compress', 'no-bak',          args.noBak)

    def handleCkStyleOptions(self, config):
        args = self.args
        args.errorLevel = getInt    (config, 'ckstyle', 'error-level', args.errorLevel)
        args.include    = get       (config, 'ckstyle', 'include',     args.include, True)
        args.exclude    = get       (config, 'ckstyle', 'exclude',     args.exclude, True)
        args.recursive  = getBoolean(config, 'ckstyle', 'recursive',   args.recursive)
        args.printFlag  = getBoolean(config, 'ckstyle', 'print-flag',  args.printFlag)
        args.extension  = get       (config, 'ckstyle', 'extension',   args.extension)
        args.standard   = get       (config, 'ckstyle', 'standard',    args.standard)
        args.safeMode   = getBoolean(config, 'ckstyle', 'safe-mode',   args.safeMode)
        args.noBak      = getBoolean(config, 'ckstyle', 'no-bak',      args.noBak)

        args.fixedExtension   = get       (config, 'ckstyle', 'fixed-extension',    args.fixedExtension)
        args.fixToSingleLine  = getBoolean(config, 'ckstyle', 'fix-to-single-line', args.fixToSingleLine)
        self.handleIgnoreRuleSets(config)

    def handleIgnoreRuleSets(self, config):
        if config.has_option('ckstyle', 'ignore-rule-sets'):
            ruleSetStr = config.get('ckstyle', 'ignore-rule-sets').strip()
            if ruleSetStr.find(','):
                self.args.ignoreRuleSets = [x.strip() for x in ruleSetStr.split(',')]
            elif ruleSetStr.find(' '):
                self.args.ignoreRuleSets = [x.strip() for x in ruleSetStr.split(' ')]
            else:
                self.args.ignoreRuleSets = [ruleSetStr]

########NEW FILE########
__FILENAME__ = ConsoleCommandParser
#/usr/bin/python
#encoding=utf-8

import sys
import os
import getopt
import string
from ckstyle.doCssCheck import checkFile, checkDir
from ckstyle.doCssFix import fixFile, fixDir
from ckstyle.doCssCompress import compressFile, compressDir
from ckstyle.cmdconsole.ConsoleClass import console
from ckstyle.command.usage import fixUsage, ckstyleUsage, compressUsage
from ckstyle.browsers.Analyser import analyse
from .args import CommandArgs
from . import CommandFileParser

def usage_compress():
    console.show(compressUsage)

def usage_fix():
    console.show(fixUsage)

def usage_ckstyle():
    console.show(ckstyleUsage)

def getDefaultConfigPath():
    homedir = os.getenv('USERPROFILE') or os.getenv('HOME')
    if homedir is None:
        return None
    else:
        return os.path.realpath(os.path.join(homedir, 'ckstyle.ini'))

def getConfigFilePath():
    configFile = 'ckstyle.ini'

    if not os.path.exists(configFile):
        configFile = getDefaultConfigPath()

    return configFile

def getDefaultConfig(configFile):
    if configFile is not None:
        parser = CommandFileParser.CommandFileParser(configFile)
        config = parser.args
    else:
         config = CommandArgs()

    return config

def getErrorLevel(value):
    if value.strip() == '':
        return None
    try:
        realValue = string.atoi(value)
        errorLevel = realValue
        if errorLevel > 2:
            errorLevel = 2
        elif errorLevel < 0:
            errorLevel = 0
        return errorLevel
    except ValueError:
        console.error('--errorLevel option should be number\n')
        return None

def getExtension(value):
    if value.strip() == '':
        return None
    value = value.strip()
    if value == 'none':
        return value
    if not value.startswith('.'):
        value = '.' + value
    return value

def getValue(value):
    if value.strip() == '':
        return None
    return value.strip()

def getConfigFile(value):
    value = value.strip()
    if value == '':
        console.error('no config file, ckstyle.ini path should be after -c.\n')
        return None
    if os.path.exists(value) and value.endswith('.ini'):
        return value
    else:
        console.error('%s does not exist, or is not a ".ini" file' % value)
    return None

def parseCkStyleCmdArgs(defaultConfigFile, opts, args, debug = False, called = False):
    recur = False
    printFlag = False
    configFile = None
    errorLevel = None
    extension = None
    include = None
    exclude = None
    exportJson = None
    for op, value in opts:
        if op == "-r":
            recur = True
        elif op == '-p':
            printFlag = True
        elif op == '-c' or op == '-config':
            configFile = getConfigFile(value)
        elif op == "--help" or op == '-h':
            if not called:
                usage_ckstyle()
                sys.exit()
        elif op == '--json':
            exportJson = True
        elif op == '--extension':
            extension = getExtension(value)
        elif op == '--errorLevel':
            errorLevel = getErrorLevel(value)
        elif op == '--include':
            include = getValue(value)
        elif op == '--exclude':
            exclude = getValue(value)

    if configFile is None :
        configFile = defaultConfigFile

    config = getDefaultConfig(configFile)

    if recur: config.recursive = True
    if printFlag: config.printFlag = True
    if errorLevel: config.errorLevel = errorLevel
    if extension: config.extension = extension
    if include: config.include = include
    if exclude: config.exclude = exclude
    if exportJson: config.exportJson = exportJson

    return config

def parseFixStyleCmdArgs(defaultConfigFile, opts, args, debug = False):
    extension = None
    singleLine = None
    safeMode = None
    noBak = None
    for op, value in opts:
        if op == "--help" or op == '-h':
            usage_fix()
            sys.exit()
        elif op == '--fixedExtension':
            extension = getExtension(value)
        elif op == '--singleLine':
            singleLine = True
        elif op == '--safeMode':
            safeMode = True
        elif op == '--noBak':
            noBak = True

    config = parseCkStyleCmdArgs(defaultConfigFile, opts, args, debug, True)

    if extension is not None: config.fixedExtension = extension
    if singleLine is not None: config.fixToSingleLine = singleLine
    if safeMode is not None: config.safeMode = safeMode
    if noBak is not None: config.noBak = noBak
    return config

def parseCompressCmdArgs(defaultConfigFile, opts, args, debug = False):
    #["help", "browsers=", "compressExtension=", "combineFile="]

    browsers = None
    extension = None
    combineFile = None
    safeMode = None
    noBak = None
    for op, value in opts:
        if op == "--help" or op == '-h':
            usage_compress()
            sys.exit()
        elif op == '--compressExtension':
            extension = getExtension(value)
        elif op == '--browsers':
            browsers = analyse(getValue(value).replace('"', ''))
        elif op == '--combineFile':
            combineFile = getValue(value).lower() == 'true'
        elif op == '--safeMode':
            safeMode = True
        elif op == '--noBak':
            noBak = True
    config = parseCkStyleCmdArgs(defaultConfigFile, opts, args, debug, True)
    args = config.compressConfig
    if safeMode is not None: config.safeMode = safeMode
    if browsers is not None: args.browsers = browsers
    if extension is not None: args.extension = extension
    if combineFile is not None: args.combineFile = combineFile
    if noBak is not None: args.noBak = noBak
    
    return config

def _handle(roughArgs, options, dirHandler, fileHandler, argsParser, operation):
    try:
        opts, args = getopt.getopt(roughArgs[2:], "hrpc:", options)
    except getopt.GetoptError as e:
        console.error('[option] %s ' % e.msg)
        return
    
    configFile = getConfigFilePath()

    if len(args) == 0 and len(opts) == 0:
        config = getDefaultConfig(configFile)
        dirHandler(os.getcwd(), config = config)
        return

    config = argsParser(configFile, opts, args)

    config.operation = operation
    
    filePath = None
    if len(args) == 0:
        filePath = os.getcwd()
    else:
        filePath = args[0]
        if not os.path.exists(filePath):
            console.error('%s not exist' % filePath)
            return

    if filePath.endswith('.css'):
        fileHandler(filePath, config = config)
    elif os.path.isdir(filePath):
        dirHandler(filePath, config = config)
    else:
        console.error('%s aborted! because "%s" is neither css file, nor dir' % (operation, filePath))

def handleCkStyleCmdArgs(args):
    options = ["help", "config=", "errorLevel=", "extension=", "include=", "exclude=", "json"]
    dirHandler = checkDir
    fileHandler = checkFile
    argsParser = parseCkStyleCmdArgs
    operation = 'ckstyle'
    _handle(args, options, dirHandler, fileHandler, argsParser, operation)

def handleCompressCmdArgs(args):
    options = ["help", "config=", "errorLevel=", "extension=", "include=", "exclude=", "browsers=", "compressExtension=", "combineFile=", "safeMode", "noBak"]
    dirHandler = compressDir
    fileHandler = compressFile
    argsParser = parseCompressCmdArgs
    operation = 'compress'
    _handle(args, options, dirHandler, fileHandler, argsParser, operation)

def handleFixStyleCmdArgs(args):
    options = ["help", "config=", "errorLevel=", "extension=", "include=", "exclude=", "fixedExtension=", "singleLine", "safeMode", "noBak"]
    dirHandler = fixDir
    fileHandler = fixFile
    argsParser = parseFixStyleCmdArgs
    operation = 'fixstyle'
    _handle(args, options, dirHandler, fileHandler, argsParser, operation)

########NEW FILE########
__FILENAME__ = helper
#/usr/bin/python
#encoding=utf-8
import urllib
import os
import shutil
from ckstyle.cmdconsole.ConsoleClass import console

def realpath(a, b):
	return os.path.realpath(os.path.join(a, b))
	
debug = False
noVersion = True # do not support version currently

pluginUrl = 'https://raw.github.com/wangjeaf/ckstyle-pm/master/plugins/%s/%sindex.py'
cmdPluginUrl = 'https://raw.github.com/wangjeaf/ckstyle-pm/master/commands/%s/%sindex.py'
pluginRootDir = realpath(__file__, '../../userplugins/plugins')
cmdPluginRootDir = realpath(__file__, '../../userplugins/commands')

pluginWant = 'PluginClass'
cmdPluginWant = 'doCommand'

def getWhatIWant(pluginType):
	return pluginWant if pluginType == 'plugins' else cmdPluginWant

def fetchPlugin(name, version = ''):
	fetch(name, version, pluginUrl, pluginRootDir, 'plugins')

def fetchCmdPlugin(name, version = ''):
	return fetch(name, version, cmdPluginUrl, cmdPluginRootDir, 'commands')

def removePlugin(name, version = ''):
	remove(name, version, pluginRootDir)

def removeCmdPlugin(name, version = ''):
	remove(name, version, cmdPluginRootDir)

def remove(name, version, root):
	if noVersion:
		version = ''
	pluginDir = realpath(root, './' + name)
	if not os.path.exists(pluginDir):
		return
	if version is not None and version != '':
		versionDir = realpath(pluginDir, './v' + replacedVer)
		if not os.path.exists(versionDir):
			return
		else:
			shutil.rmtree(versionDir)
	shutil.rmtree(pluginDir)
	console.showOk('%s is removed from %s' % (name, root))
	console.showOk('Uninstall successfully!')

def findPlugin(name):
	return find(name, pluginRootDir)

def findCmdPlugin(name):
	return find(name, cmdPluginRootDir)

def find(name, root):
	pluginDir = realpath(root, './' + name)
	if not os.path.exists(pluginDir):
		return False
	filePath = realpath(pluginDir, './index.py')
	if not os.path.exists(pluginDir):
		return False
	return True

def fetch(name, version, url, root, pluginType):	
	if noVersion:
		version = ''
	
	pluginDir = realpath(root, './' + name)
	replacedVer =  '' if version == '' else version.replace('.', '_')
	if not os.path.exists(pluginDir):
		os.mkdir(pluginDir)
		open(realpath(pluginDir, './__init__.py'), 'w').write('')

	versionDir = pluginDir

	if version is not None and version != '':
		versionDir = realpath(pluginDir, './v' + replacedVer)
		if not os.path.exists(versionDir):
			os.mkdir(versionDir)
			open(realpath(versionDir, './__init__.py'), 'w').write('')
	

		
	filePath = realpath(versionDir, './index.py')

	if debug or not os.path.exists(filePath):
		realUrl = url % (name, '' if version == '' else ('' + version + '/'))
		console.showOk('Downloading %s%s from %s' % (name, version, realUrl))
		request = urllib.urlopen(realUrl)
		if request.getcode() != 200:
			console.showError('Can not download file, status code : ' + str(request.getcode()))
			return
		try:
			f = open(filePath, 'w')
			f.write(request.read())
			console.showOk('%s%s Downloaded in %s' % (name, version, filePath))
			if pluginType == 'commands':
				console.showOk('Download successfully!')
				console.showOk('Please type "ckstyle %s" to execute.' % name)
			#urllib.urlretrieve(realUrl, realUrl)
		except IOError as e:
			console.error(str(e))

	versionPath = '' if replacedVer == '' else '.v' + replacedVer

	whatIWant = getWhatIWant(pluginType)

	moduleName = "ckstyle.userplugins.%s.%s%s.index" % (pluginType, name, versionPath)
	try:
		plugin = __import__(moduleName, fromlist=["ckstyle.userplugins.%s.%s%s" % (pluginType, name, versionPath)])
	except ImportError as e:
		console.showError(('Can not import plugin %s : ' % name) + str(e))
		return

	filePath = realpath(versionDir, './index.pyc')
	if os.path.exists(filePath):
		os.remove(filePath)

	if pluginType == 'commands':
		if hasattr(plugin, 'doCommand'):
			return getattr(plugin, 'doCommand')
		else:
			console.showError('%s do not contain %s' % (moduleName, whatIWant))

	return None

if __name__ == '__main__':
	print fetchPlugin('demo')
	#print fetchPlugin('demo', '1.0')
	#print fetchCmdPlugin('democmd')
	#print fetchCmdPlugin('democmd', '1.0')
	#print removePlugin('demo')
	#print removePlugin('demo', '1.0')
	#print removeCmdPlugin('demo')
	#print removeCmdPlugin('democmd', '1.0')
########NEW FILE########
__FILENAME__ = index
#/usr/bin/python
#encoding=utf-8
from .ConsoleCommandParser import handleCkStyleCmdArgs, handleFixStyleCmdArgs, handleCompressCmdArgs
from .PluginManager import install, uninstall, installcmd, uninstallcmd, handleExtraCommand
import sys
from .usage import newUsage

def ckstyle():
    args = sys.argv
    if len(args) < 2:
        newUsage()
        return

    commands = {
        'check' : handleCkStyleCmdArgs,
        'fix': handleFixStyleCmdArgs,
        'compress': handleCompressCmdArgs,
        
        'install': install,
        'add': install,
        'get': install,

        'uninstall': uninstall,
        'remove': uninstall,
        'rm': uninstall,

        'installcmd': installcmd,
        'addcmd': installcmd,
        'getcmd': installcmd,

        'rmcmd': uninstallcmd,
        'removecmd': uninstallcmd,
        'uninstallcmd': uninstallcmd
    }

    subcommand = args[1]
    if commands.has_key(subcommand):
        commands.get(subcommand)(args)
    else:
        handleExtraCommand(subcommand, args)

    #handleCkStyleCmdArgs()

#def fixstyle():
#    handleFixStyleCmdArgs()

#def compress():
#    handleCompressCmdArgs()

#def main():
#    ckstyle()

if __name__ == '__main__':
    ckstyle()

########NEW FILE########
__FILENAME__ = PluginManager
#/usr/bin/python
#encoding=utf-8

import sys
from ckstyle.cmdconsole.ConsoleClass import console
from .helper import fetchPlugin, fetchCmdPlugin, removePlugin, removeCmdPlugin, findCmdPlugin
from .usage import newUsage

def getNameAndVersion(args):
	argLen = len(args)
	if argLen < 3 or argLen > 4:
		console.error('wrong arg length, use "ckstyle -h" to see help.')
		return None, None
	pluginName = args[2]
	version = ''
	if argLen == 4:
		version = args[3]

	return pluginName, version

def install(args):
	pluginName, version = getNameAndVersion(args)
	if pluginName is None:
		return
	fetchPlugin(pluginName, version)

def uninstall(args):
	pluginName, version = getNameAndVersion(args)
	if pluginName is None:
		return
	removePlugin(pluginName, version)

def installcmd(args):
	pluginName, version = getNameAndVersion(args)
	if pluginName is None:
		return
	fetchCmdPlugin(pluginName, version)

def uninstallcmd(args):
	pluginName, version = getNameAndVersion(args)
	if pluginName is None:
		return
	removeCmdPlugin(pluginName, version)

def handleExtraCommand(command, args):
	if command.startswith('-') or command.startswith('.'):
		newUsage()
		return
	if not findCmdPlugin(command):
		console.show('[CKstyle ERROR] CKstyle can not find the subcommand: "%s".' % command)
		console.show('[CKstyle ERROR] Maybe you can type "ckstyle installcmd %s" to install this command from ckstyle-pm.' % command)
		return
	cmd = fetchCmdPlugin(command)
	if cmd is None:
		return
	cmd()

########NEW FILE########
__FILENAME__ = usage
#/usr/bin/python
#encoding=utf-8

from .helper import cmdPluginRootDir, fetchCmdPlugin
import os

usage = '[Usage]'
example = '[Example]'
options = '[Options]'


newUsageBase = '''
  [Commands]
  
   - ckstyle check    --options xxxx.css
   - ckstyle fix      --options xxxx.css
   - ckstyle compress --options xxxx.css

   - ckstyle install/add/get      [pluginName]
   - ckstyle uninstall/remove/rm  [pluginName]

   - ckstyle installcmd/addcmd/getcmd      [commandName]
   - ckstyle uninstallcmd/removecmd/rmcmd  [commandName]
'''

def newUsage():
    extraUsage = ''
    for f in os.listdir(cmdPluginRootDir):
        if f.startswith('__') or f.endswith('.py') or f.endswith('.pyc'):
            continue
        realPath = os.path.realpath(os.path.join(cmdPluginRootDir, f))
        if os.path.isdir(realPath) and fetchCmdPlugin(f) is not None:
            if extraUsage == '':
                  extraUsage = '  [Installed Cmds]\n\n'
            extraUsage = extraUsage + '   - ckstyle ' + f
    if extraUsage != '':
        extraUsage = '\n' + extraUsage
    print newUsageBase + extraUsage + '\n'

compressUsage = '''
[compress]
%s
    Compress shares almost the same options with ckstyle, but has more.

    compress -h / compress --help
    compress file.css
    compress -r dir
    compress -r -p dir

    compress --browsers=true dirpath
    compress --compressExtension=.min1.css dirpath

    compress -r --combineFile=all.min.css dirpath (coming soon)
    compress a.css b.css c.css to all.min.css (coming soon)

%s
    compress -r -p -c xxx.ini --compressExtension=.min2.css --include=all --exclude=none --browsers=true dirpath

%s
    -h / --help     show help
    -r              compress files in directory recursively
    -p              print compressed file content to console(delete result files at the same time)
    -c / --config   specify the config file name(use ckstyle.ini or ~/ckstyle.ini as default)
    --include       specify rules(can be configed in .ini file)
    --exclude       specify exclude rules(can be configed in .ini file)
    --compressExtension     specify compressed file extension(use ".min.css" as default)
    --browsers      compress css for different browsers, generate .ie6.css/.ie7.css/std.css/all.css ...
    --combineFile   combine all compressed css content into a file (todo)
    ''' % (usage, example, options)

ckstyleUsage = '''
[ckstyle]
%s
    ckstyle -h / ckstyle --help
    ckstyle
    ckstyle file.css
    ckstyle dir 
    ckstyle -r dir
    ckstyle -p -r dir
    ckstyle -c xxx.ini 
    ckstyle -c xxx.ini -r -p

%s
    ckstyle -r -p -c xxx.ini --extension=.test.txt --include=all --exclude=none --errorLevel=2 dirpath

%s
    -h / --help     show help
    -r              check files in directory recursively
    -p              print check result to console(delete result files at the same time)
    -c / --config   specify the config file name(use ckstyle.ini or ~/ckstyle.ini as default)
    --include       specify rules(can be configed in .ini file)
    --exclude       specify exclude rules(can be configed in .ini file)
    --extension     specify check result file extension(use ".ckstyle.txt" as default)
    --errorLevel    specify error level(0-error, 1-warning, 2-log)
    ''' % (usage, example, options)

fixUsage = '''
[fixstyle]
%s
    Fixstyle shares almost the same options with ckstyle, but has more.

    fixstyle -h / fixstyle --help
    fixstyle file.css
    fixstyle -r dir
    fixstyle -r -p dir

    fixstyle --fixedExtension=.fixed2.css dirpath
    fixstyle --singleLine dirpath

%s
    fixstyle -r -p -c xxx.ini --fixedExtension=.test.txt --include=all --exclude=none dirpath

%s
    -h / --help     show help
    -r              fix files in directory recursively
    -p              print fixed file content to console(delete result files at the same time)
    -c / --config   specify the config file name(use ckstyle.ini or ~/ckstyle.ini as default)
    --include       specify rules(can be configed in .ini file)
    --exclude       specify exclude rules(can be configed in .ini file)
    --fixedExtension     specify fixed file extension(use ".fixed.css" as default)
    --singleLine    fix all rule sets to single line mode
    ''' % (usage, example, options)

########NEW FILE########
__FILENAME__ = CssCheckerWrapper
#/usr/bin/python
#encoding=utf-8

import os
import imp
from .plugins.Base import *
from ckstyle.cmdconsole.ConsoleClass import console
from ckstyle.browsers.BinaryRule import ALL

class CssChecker():
    '''CSS检查类，需要CSS解析器作为辅助'''
    def __init__(self, parser, config = None):
        self.parser = parser
        self.config = config

        # 错误记录，log是2级，warn是1级，error是0级
        self.logMsgs = []
        self.warningMsgs = []
        self.errorMsgs = []

        # 额外的错误记录，比如工具内部的一些错误等
        self.extraMsgs = []

        # 注册的不同类型的检查器（都来自plugins目录）
        self.ruleSetCheckers = []
        self.ruleCheckers = []
        self.styleSheetCheckers = []

        self.extraCheckers = []

        # 如果有解析过程的错误，则先把那些错误记录下来
        self.handleParseErrors()

    def resetStyleSheet(self):
        self.parser.styleSheet.rebase()

    def getStyleSheet(self):
        '''获取styleSheet引用'''
        return self.parser.styleSheet

    def handleParseErrors(self):
        for msg in self.parser.getParseErrors():
            self.remember(msg[0], msg[1])

    def hasError(self):
        '''判断是否有error'''
        return len(self.logMsgs) != 0 or len(self.warningMsgs) != 0 or len(self.errorMsgs) != 0

    def errors(self):
        '''把错误信息导出'''
        return self.logMsgs, self.warningMsgs, self.errorMsgs

    def loadPlugins(self, pluginDir, debug = True):
        '''如果是debug模式，则从细小的plugin文件中载入插件，否则，从大文件中载入插件'''
        if debug:
            self.loadFromSubFiles(pluginDir)
            self.loadFromUserPlugins()
        else:
            self.loadFromBigFile(pluginDir)

    def loadFromBigFile(self, pluginDir):
        '''从AllRules.py动态载入检查类'''
        plugin = __import__("ckstyle.plugins.AllRules", fromlist = ['AllRules'])
        props = dir(plugin)
        for prop in props:
            if not prop.startswith('FED'):
                continue
            pluginClass = getattr(plugin, prop)
            self.registerPluginClass(pluginClass)

    def loadFromUserPlugins(self):
        '''允许用户通过ckstyle install添加plugin，执行的时候载入之'''
        include = self.config.include
        exclude = self.config.exclude
        safeMode = self.config.safeMode
        safeModeExcludes = 'combine-same-rulesets'

        def import_module(name):
            mod = __import__(name)
            components = name.split('.')
            for comp in components[1:]:
                mod = getattr(mod, comp)
            return mod
    
        root = os.path.realpath(os.path.join(__file__, '../userplugins/plugins'))
        modulePath = self.getModulePath(root)
        pluginClassName = 'PluginClass'
        for filename in os.listdir(root):
            if filename.startswith('.') or filename.startswith('_'):
                continue
            if not os.path.isdir(os.path.realpath(os.path.join(root, filename))):
                continue
            plugin = None
            try:
                plugin = import_module(modulePath + filename + '.index')
            except Exception as e:
                console.showError('Orz... can not load %s' % modulePath + filename + '.index')
                continue
            pluginClass = None
            if hasattr(plugin, pluginClassName):
                pluginClass = getattr(plugin, pluginClassName)
            else:
                console.showError('class %s should exist in %s.py' % (pluginClassName, filename + '/index'))
                continue
            self.registerPluginClass(pluginClass)

    def loadFromSubFiles(self, pluginDir):
        '''从plugins目录动态载入检查类'''
        modulePath = self.getModulePath(pluginDir)
        for filename in os.listdir(pluginDir):
            if not filename.endswith('.py') or filename.startswith('_'):
                continue
            if filename == 'Base.py' or filename == 'helper.py':
                continue
            pluginName = os.path.splitext(filename)[0]

            # 获取plugins的引用
            plugin = __import__(modulePath + pluginName, fromlist = [pluginName])
            pluginClass = None
            if hasattr(plugin, pluginName):
                pluginClass = getattr(plugin, pluginName)
            else:
                console.error('[TOOL] class %s should exist in %s.py' % (pluginName, pluginName))
                continue
            self.registerPluginClass(pluginClass)

    def registerPluginClass(self, pluginClass):
        include = self.config.include
        exclude = self.config.exclude
        safeMode = self.config.safeMode
        safeModeExcludes = 'combine-same-rulesets'

        # 构造plugin的类
        instance = pluginClass()

        # 如果是private，则说明不论是否选择都需要的规则
        if not hasattr(instance, 'private') or getattr(instance, 'private') is not True:
            if include != 'all' and include.find(instance.id) == -1:
                return
            elif exclude != 'none' and exclude.find(instance.id) != -1:
                return
            elif safeMode and safeModeExcludes.find(instance.id) != -1:
                return
        self.registerChecker(instance)

    def getModulePath(self, pluginDir):
        transDir = pluginDir.replace('\\', '/')
        splited = transDir.split('/ckstyle/')[1]
        modulePath = 'ckstyle.' + splited.replace('/', '.') + '.'
        return modulePath

    def registerChecker(self, checker):
        '''根据检查器类型的不同，分别注册到不同的检查器列表中'''
        if isinstance(checker, RuleChecker):
            self.registerRuleChecker(checker)
        elif isinstance(checker, RuleSetChecker):
            self.registerRuleSetChecker(checker)
        elif isinstance(checker, StyleSheetChecker):
            self.registerStyleSheetChecker(checker)
        else:
            self.registerExtraChecker(checker)

    def registerStyleSheetChecker(self, checker):
        self.styleSheetCheckers.append(checker)

    def registerRuleSetChecker(self, checker):
        self.ruleSetCheckers.append(checker)

    def registerRuleChecker(self, checker):
        self.ruleCheckers.append(checker)

    def registerExtraChecker(self, checker):
        self.extraCheckers.append(checker)

    def remember(self, errorLevel, errorMsg):
        '''记录代码中的问题'''
        if errorLevel == ERROR_LEVEL.LOG:
            if self.config.errorLevel > 1:
                self.logMsgs.append(errorMsg)
        elif errorLevel == ERROR_LEVEL.WARNING:
            if self.config.errorLevel > 0:
                self.warningMsgs.append(errorMsg)
        elif errorLevel == ERROR_LEVEL.ERROR:
            self.errorMsgs.append(errorMsg)
        else:
            console.error('[TOOL] wrong ErrorLevel for ' + errorMsg)

    def logStyleSheetMessage(self, checker, styleSheet, errors = None):
        '''记录StyleSheet的问题'''
        errorLevel = checker.getLevel()
        if errors is None:
            errors = [checker.getMsg()]
        for errorMsg in errors:
            obj = {}
            if errorMsg is None or errorMsg == '':
                console.error('[TOOL] no errorMsg in your plugin, please check it')

            #if errorMsg.find('${file}') == -1:
            #    errorMsg = errorMsg + ' (from "' + styleSheet.getFile() + '")'
            #else:
            #    errorMsg = errorMsg.replace('${file}', styleSheet.getFile())

            obj["errorMsg"] = errorMsg
            obj["file"] = styleSheet.getFile()
            obj["level"] = 'stylesheet'
            self.remember(errorLevel, obj);

    def logRuleMessage(self, checker, rule, errors = None):
        '''记录一条key/value的问题'''
        errorLevel = checker.getLevel()
        if errors is None:
            errors = [checker.getMsg()]
        for errorMsg in errors:
            obj = {}
            if errorMsg is None or errorMsg == '':
                console.error('[TOOL] no errorMsg in your plugin, please check it')
            #if errorMsg.find('${selector}') == -1:
            #    errorMsg = errorMsg + ' (from "' + rule.selector + '")'
            #else:
            #    errorMsg = errorMsg.replace('${selector}', rule.selector)
            #errorMsg = errorMsg.replace('${name}', rule.roughName.strip())
            #errorMsg = errorMsg.replace('${value}', rule.value.strip())
            obj["errorMsg"] = errorMsg
            obj["selector"] = rule.selector
            obj["name"] = rule.roughName.strip()
            obj["value"] = rule.value.strip()
            obj["level"] = 'rule'
            self.remember(errorLevel, obj);

    def logRuleSetMessage(self, checker, ruleSet, errors = None):
        '''记录一个"规则集"中的问题'''
        errorLevel = checker.getLevel()
        if errors is None:
            errors = [checker.getMsg()]
        for errorMsg in errors:
            obj = {}
            #if errorMsg.find('${selector}') == -1:
            #    errorMsg = errorMsg + ' (from "' + ruleSet.selector + '")'
            #else:
            #    errorMsg = errorMsg.replace('${selector}', ruleSet.selector)
            obj["errorMsg"] = errorMsg
            obj["selector"] = ruleSet.selector
            obj["level"] = 'ruleset'
            self.remember(errorLevel, obj);

    def doCompress(self, browser = ALL):
        self.config._curBrowser = browser
        self.doFix()
        return self.getStyleSheet().compress(browser).strip()

    def doFix(self, browser = ALL):
        #self.resetStyleSheet()
        # 忽略的规则集（目前只忽略单元测试的selector）
        ignoreRuleSets = self.config.ignoreRuleSets

        def findInArray(array, value):
            return value in array or value.strip() in array

        # fix规则集
        def fixRuleSet(ruleSet):
            for checker in self.ruleSetCheckers:
                if not hasattr(checker, 'fix'):
                    continue
                if ruleSet.fixedSelector == '':
                    ruleSet.fixedSelector = ruleSet.selector
                    ruleSet.fixedComment = ruleSet.comment
                checker.fix(ruleSet, self.config)

        # fix规则
        def fixRules(ruleSet):
            for checker in self.ruleCheckers:
                for rule in ruleSet.getRules():
                    if not hasattr(checker, 'fix'):
                        continue

                    # 确保fixedName/fixedValue一定有值
                    # fix中一定要针对fixedName/fixedValue来判断，确保其他plugin的fix不会被覆盖
                    if rule.fixedValue == '':
                        rule.fixedValue = rule.value
                        rule.fixedName = rule.strippedName

                    #print checker.id, checker, rule.fixedValue
                    checker.fix(rule, self.config)

        def fixExtraRules(ruleSet):
            for checker in self.extraCheckers:
                if not hasattr(checker, 'fix'):
                    continue
                if ruleSet.fixedSelector == '':
                    ruleSet.fixedSelector = ruleSet.selector
                    ruleSet.fixedStatement = ruleSet.statement

                checker.fix(ruleSet, self.config)

        styleSheet = self.parser.styleSheet

        for ruleSet in styleSheet.getRuleSets():
            if ruleSet.extra:
                fixExtraRules(ruleSet)
                continue
            # 判断此规则是否忽略
            if findInArray(ignoreRuleSets, ruleSet.selector):
                continue
            # 先fix rule
            fixRules(ruleSet)
            # 再fix ruleSet
            fixRuleSet(ruleSet)

        # 最后fix styleSheet
        for checker in self.styleSheetCheckers:
            if hasattr(checker, 'fix'):
                checker.fix(styleSheet, self.config)
        return self.getStyleSheet().fixed(self.config)

    def doCheck(self):
        # 忽略的规则集（目前只忽略单元测试的selector）
        ignoreRuleSets = self.config.ignoreRuleSets

        def findInArray(array, value):
            return value in array or value.strip() in array

        def isBoolean(value):
            return type(value) == type(True)

        def isList(value):
            return isinstance(value, list)

        # 检查规则集
        def checkRuleSet(ruleSet):
            for checker in self.ruleSetCheckers:
                if not hasattr(checker, 'check'):
                    continue
                result = checker.check(ruleSet, self.config)
                if isBoolean(result):
                    if not result:
                        self.logRuleSetMessage(checker, ruleSet)
                elif isList(result) and len(result) != 0:
                    self.logRuleSetMessage(checker, ruleSet, result)
                else:
                    console.error('check should be boolean/list, %s is not.' % checker.id)

        # 检查规则
        def checkRule(ruleSet):
            for checker in self.ruleCheckers:
                for rule in ruleSet.getRules():
                    if not hasattr(checker, 'check'):
                        continue
                    result = checker.check(rule, self.config)
                    if isBoolean(result):
                        if not result:
                            self.logRuleMessage(checker, rule)
                    elif isList(result) and len(result) != 0:
                        self.logRuleMessage(checker, rule, result)
                    else:
                        console.error('check should be boolean/list, %s is not.' % checker.id)

        # 检查规则
        def checkExtraRule(ruleSet):
            for checker in self.extraCheckers:
                if not hasattr(checker, 'check'):
                    continue
                result = checker.check(ruleSet, self.config)
                if isBoolean(result):
                    if not result:
                        self.logRuleSetMessage(checker, ruleSet)
                elif isList(result) and len(result) != 0:
                    self.logRuleSetMessage(checker, ruleSet, result)
                else:
                    console.error('check should be boolean/list, %s is not.' % checker.id)

        # 检查样式表
        styleSheet = self.parser.styleSheet
        for checker in self.styleSheetCheckers:
            if not hasattr(checker, 'check'):
                continue
            result = checker.check(styleSheet, self.config)
            if isBoolean(result):
                if not result:
                    self.logStyleSheetMessage(checker, styleSheet)
            elif isList(result) and len(result) != 0:
                self.logStyleSheetMessage(checker, styleSheet, result)
            else:
                console.error('check should be boolean/list, %s is not.' % checker.id)

        for ruleSet in styleSheet.getRuleSets():
            if ruleSet.extra:
                checkExtraRule(ruleSet)
                continue
            # 判断此规则是否忽略
            if findInArray(ignoreRuleSets, ruleSet.selector):
                continue
            checkRuleSet(ruleSet)
            checkRule(ruleSet)

########NEW FILE########
__FILENAME__ = CssFileParser
from .helper import findCharFrom, handleSpecialStatement, isCommentStart, isCommentEnd, isSpecialStart, isNestedStatement
from ckstyle.entity.StyleSheet import StyleSheet

class CssParser():
    def __init__(self, roughCss = None, fileName = ''):
        self.roughCss = roughCss
        self.fileName = fileName
        self.totalLength = len(roughCss)
        self.styleSheet = StyleSheet(fileName)
        self._parseErrors = []

    def doParse(self, config = None):
        prevChar = None
        inComment = False
        length = self.totalLength
        text = self.roughCss
        selector = '';
        commentText = ''
        i = -1
        comments = []
       
        while True:
            if (i == length - 1):
                break;
            i = i + 1
            char = text[i]
            if not inComment and isCommentStart(char, text, i):
                commentText = ''
                inComment = True
            if isCommentEnd(char, text, i):
                commentText = commentText + char
                inComment = False
                comments.append(commentText)
                commentText = ''
                continue
            if inComment:
                commentText = commentText + char
                continue;
            if isSpecialStart(char):
                nextPos, attrs, operator = handleSpecialStatement(text, i, length, char)
                if nextPos is not None:
                    realComment = ''
                    if len(comments) != 0:
                        realComment = '\n'.join(comments)
                        comments = []
                    self.styleSheet.addExtraStatement(operator, char + attrs + text[nextPos], realComment)
                    i = nextPos
                    selector = ''
                    commentText = ''
                    comments = []
                    continue
            if char == '{':
                nextBracePos, attributes = findCharFrom(text, i, length, '{', '}')
                # do not need the last brace
                realComment = ''
                if len(comments) != 0:
                    realComment = '\n'.join(comments)
                    comments = []
                if isNestedStatement(selector):
                    self.styleSheet.addNestedRuleSet(selector, attributes[:-1], realComment)
                else:
                    self.styleSheet.addRuleSetByStr(selector, attributes[:-1], realComment)
                commentText = ''
                i = nextBracePos
                selector = ''
            elif char == '}':
                selector = ''
            else:
                selector = selector + char

        for ruleSet in self.styleSheet.getRuleSets():
            errors = self.doParseRules(ruleSet)
            self._parseErrors.extend(errors)

    def getParseErrors(self):
        return self._parseErrors

    def doParseRules(self, ruleSet):
        errors = []
        if ruleSet.extra:
            return errors
        text = ruleSet.roughValue
        singleLine = len(text.split('\n')) == 1
        selector = ruleSet.selector.strip()
        i = -1
        length = len(text)
        inComment = False
        collector = ''
        attr = ''
        value = ''
        valueStarted = False
        while True:
            if i == length - 1:
                break;
            i = i + 1
            char = text[i]
            if not valueStarted and isCommentStart(char, text, i):
                inComment = True
                #errors.append([-1, 'find comment in values of "%s"' % selector])
                collector = ''
            if not valueStarted and isCommentEnd(char, text, i):
                collector = ''
                inComment = False
                continue
            if not valueStarted and inComment:
                continue
            if char == ':':
                if valueStarted is True:
                    collector = collector + char
                else:
                    valueStarted = True
                    attr = collector
                    collector = ''
            elif char == ';' or char == '\n' or i == length - 1:
                valueStarted = False
                if attr == '':
                    collector = ''
                    continue
                value = collector + char
                ruleSet.addRuleByStr(selector, attr, value)
                attr = ''
                value = ''
                collector = ''
            elif char == '{':
                nextBracePos, attributes = findCharFrom(text, i, length, '{', '}')
                collector = collector + char + attributes
                i = nextBracePos
            elif char == '}':
                collector = collector + char
            elif char == '(':
                nextBracePos, attributes = findCharFrom(text, i, length, '(', ')')
                collector = collector + char + attributes
                i = nextBracePos
                # .xxx {background-image:url(xxxx)}
                if i == length - 1:
                    ruleSet.addRuleByStr(selector, attr, collector)
                    break;
            else:
                collector = collector + char

        return errors

if __name__ == '__main__':
    text = '''@media screen and (-webkit-min-device-pixel-ratio:0) {
 .publisher-c .global-publisher-selector{ top:5px;}
 .publisher-a .global-publisher-selector-status a,
 .publisher-a .global-publisher-selector-status .global-publisher-status-trigger:hover,
 .publisher-a .global-publisher-selector .active .global-publisher-status-trigger {
    background-position: 0 1px;
}
 .publisher-a .global-publisher-selector-share a,
 .publisher-a .global-publisher-selector-share a:hover,
 .publisher-a .global-publisher-selector .active .global-publisher-share-trigger{
    background-position: 0 -48px;
 }
}'''
    parser = CssParser(text)
    parser.doParse()

########NEW FILE########
__FILENAME__ = helper
def isAlphaChar(char):
    return 97 <= ord(char) <= 122

specialTexts = [
    {'start':'@', 'text':'@import', 'end':';\n'},
    {'start':'@', 'text':'@charset', 'end':';\n'},
    {'start':'@', 'text':'@namespace', 'end':';'},
    {'start':'@', 'text':'@-css-compiler ', 'end':'}'},
    {'start':'@', 'text':'@-css-compiler{', 'end':'}'},
    {'start':'@', 'text':'@-css-compiler-', 'end':';\n'}]

specialStartChars = set([x['start'] for x in specialTexts])

nestedStatements = ['keyframes', '@media', '@-moz-document']

def isSpecialStart(char):
    for x in specialStartChars:
        if x == char:
            return True
    return False

def isNestedStatement(selector):
    if selector.find('@') == -1:
        return False
    for x in nestedStatements:
        if selector.find(x) != -1:
            return True
    return False

def handleSpecialStatement(text, i, length, char):
    for obj in specialTexts:
        if char == obj['start'] and isSpecialString(text, i, obj["text"]):
            a, b = findCharFrom(text, i, length, obj["end"])
            return a, b, obj["text"]
    return None, None, None

def findCharFrom(text, i, length, left, right = None):
    counter = 1
    collector = ''
    for j in range(i + 1, length):
        if right == None:
            if text[j] == left or left.find(text[j]) != -1:
                break;
            else:
                collector = collector + text[j]
        else:
            if text[j] == left:
                collector = collector + text[j]
                counter = counter + 1
            elif text[j] == right:
                collector = collector + text[j]
                counter = counter - 1
                if counter == 0:
                    break;
            else:
                collector = collector + text[j]
    return j, collector

def isSpecialString(text, i, string):
    return text[i: i + len(string)] == string

def isCommentStart(char, text, i):
    return char == '/' and i + 1 < len(text) and text[i + 1] == '*'

def isCommentEnd(char, text, i):
    return char == '/' and text[i - 1] == '*'


########NEW FILE########
__FILENAME__ = doCssCheck
#/usr/bin/python
#encoding=utf-8

import sys
import os
from .reporter.ReporterUtil import ReporterUtil
from .cssparser.CssFileParser import CssParser
from ckstyle.cmdconsole.ConsoleClass import console
from .CssCheckerWrapper import CssChecker
from .command import args as args

defaultConfig = args.CommandArgs()

def doCheck(fileContent, fileName = '', config = defaultConfig):
    '''封装一下'''

    config.operation = 'ckstyle'
    parser = CssParser(fileContent, fileName)
    parser.doParse(config)

    checker = CssChecker(parser, config)

    checker.loadPlugins(os.path.realpath(os.path.join(__file__, '../plugins')))
    checker.doCheck()

    return checker

def checkFile(filePath, config = defaultConfig):
    '''通过路径检查css文件'''
    fileContent = open(filePath).read()
    console.log('[ckstyle] checking %s' % filePath)
    checker = doCheck(fileContent, filePath, config)
    path = os.path.realpath(filePath + config.extension)
    if checker.hasError():
        reporter = ReporterUtil.getReporter('json' if config.exportJson else 'text', checker)
        reporter.doReport()
        if config.printFlag:
            if os.path.exists(path):
                os.remove(path)
            console.show(reporter.export() + '\n')
        else:
            open(path, 'w').write(reporter.export())
            console.show('[ckstyle] @see %s\n' % path)
        return False
    else:
        if config.exportJson:
            console.show('{"status":"ok","result":"%s is ok"}' % filePath)
        else:
            console.show('[ckstyle] %s is ok\n' % filePath)
        if os.path.exists(path):
            os.remove(path)
        return True

def checkDir(directory, config = defaultConfig):
    if config.recursive:
        checkDirRecursively(directory, config)
    else:
        checkDirSubFiles(directory, config)

def checkDirSubFiles(directory, config = defaultConfig):
    for filename in os.listdir(directory):
        if not filename.endswith('.css') or filename.startswith('_'):
            continue
        checkFile(os.path.join(directory, filename), config)

def checkDirRecursively(directory, config = defaultConfig):
    for dirpath, dirnames, filenames in os.walk(directory):
        for filename in filenames:
            if not filename.endswith('.css') or filename.startswith('_'):
                continue
            checkFile(os.path.join(dirpath, filename), config)

def checkCssText(text):
    checker = doCheck(text)
    reporter = ReporterUtil.getReporter('text', checker)
    reporter.doReport()
    console.show(reporter.export())

def main(arg = None):
    if len(sys.argv) == 1:
        console.error('at least two args')
    else:
        if checkCssFileByOpm(sys.argv[1]):
            console.show('no error in %s' % sys.argv[1])

if __name__ == '__main__':
    checkCssFileByOpm(sys.argv[1])

########NEW FILE########
__FILENAME__ = doCssCompress
#/usr/bin/python
#encoding=utf-8

import sys
import os
from .cssparser.CssFileParser import CssParser
from ckstyle.cmdconsole.ConsoleClass import console
from .CssCheckerWrapper import CssChecker
from .command import args as args

defaultConfig = args.CommandArgs()

def prepare(fileContent, fileName = '', config = defaultConfig):
    config.operation = 'compress'
    parser = CssParser(fileContent, fileName)
    parser.doParse(config)
    checker = CssChecker(parser, config)
    checker.loadPlugins(os.path.realpath(os.path.join(__file__, '../plugins')))

    return checker

def doCompress(fileContent, fileName = '', config = defaultConfig):
    '''封装一下'''
    checker = prepare(fileContent, fileName, config)
    message = checker.doCompress()
    return checker, message

def compressFile(filePath, config = defaultConfig):
    extension = config.compressConfig.extension
    if extension.lower() == 'none':
        extension = None
    if extension is not None and filePath.endswith(extension):
        return
    fileContent = open(filePath).read()
    if not config.printFlag:
        console.show('[compress] compressing %s' % filePath)
    path = filePath
    basic = filePath.split('.css')[0]
    if extension is None:
        # 防止替换
        if config.compressConfig.noBak is False:
            open(path + '.bak', 'w').write(fileContent)
    else:
        path = os.path.realpath(filePath.split('.css')[0] + extension)
        
    if config.compressConfig.browsers is None:
        checker, message = doCompress(fileContent, filePath, config)
        if config.printFlag:
            if extension is not None and os.path.exists(path):
                os.remove(path)
            console.show(message)
        else:
            open(path, 'w').write(message)
            console.show('[compress] compressed ==> %s' % path)
    else:
        items = config.compressConfig.browsers.items()
        onlyOne = len(items) == 1
        for key, value in items:
            # 每次都需要一个新的，避免上一次操作后的对象在内存中重复使用导致错误
            # 尤其是合并过的CSS规则集
            checker = prepare(fileContent, filePath, config)
            message = checker.doCompress(value)
            path = os.path.realpath(filePath.split('.css')[0] + '.' + key + '.min.css')
            if config.printFlag:
                if extension is not None and os.path.exists(path):
                    os.remove(path)
                console.show(((key + ' : ') if not onlyOne else '') + message)
            else:
                open(path, 'w').write(message)
                console.show('[compress] compressed ==> %s' % path)

def compressDir(directory, config = defaultConfig):
    if config.recursive:
        compressDirRecursively(directory, config)
    else:
        compressDirSubFiles(directory, config)

def compressDirSubFiles(directory, config = defaultConfig):
    for filename in os.listdir(directory):
        if not filename.endswith('.css') or filename.startswith('_'):
            continue
        compressFile(os.path.join(directory, filename), config)

def compressDirRecursively(directory, config = defaultConfig):
    for dirpath, dirnames, filenames in os.walk(directory):
        for filename in filenames:
            if not filename.endswith('.css') or filename.startswith('_'):
                continue
            compressFile(os.path.join(dirpath, filename), config)

########NEW FILE########
__FILENAME__ = doCssFix
#/usr/bin/python
#encoding=utf-8

import sys
import os
from .cssparser.CssFileParser import CssParser
from ckstyle.cmdconsole.ConsoleClass import console
from .CssCheckerWrapper import CssChecker
from .command import args as args

defaultConfig = args.CommandArgs()

def doFix(fileContent, fileName = '', config = defaultConfig):
    '''封装一下'''
    config.operation = 'fixstyle'

    parser = CssParser(fileContent, fileName)
    parser.doParse(config)

    checker = CssChecker(parser, config)

    checker.loadPlugins(os.path.realpath(os.path.join(__file__, '../plugins')))
    fixed = checker.doFix()

    return checker, fixed

def fixFile(filePath, config = defaultConfig):
    extension = config.fixedExtension
    if extension.lower() == 'none':
        extension = None
    if extension is not None and filePath.endswith(extension):
        return
    fileContent = open(filePath).read()
    if not config.printFlag:
        console.show('[fixstyle] fixing %s' % filePath)

    checker, msg = doFix(fileContent, filePath, config)

    path = filePath
    if extension is None:
        if config.noBak is False:
            open(path + '.bak', 'w').write(fileContent)
    else:
        path = os.path.realpath(filePath.split('.css')[0] + extension)

    if config.printFlag:
        if extension is not None and os.path.exists(path):
            os.remove(path)
        console.show(msg)
    else:
        open(path, 'w').write(msg)
        console.show('[fixstyle] fixed ==> %s' % path)

def fixDir(directory, config = defaultConfig):
    if config.recursive:
        fixDirRecursively(directory, config)
    else:
        fixDirSubFiles(directory, config)

def fixDirSubFiles(directory, config = defaultConfig):
    for filename in os.listdir(directory):
        if not filename.endswith('.css') or filename.startswith('_'):
            continue
        fixFile(os.path.join(directory, filename), config)

def fixDirRecursively(directory, config = defaultConfig):
    for dirpath, dirnames, filenames in os.walk(directory):
        for filename in filenames:
            if not filename.endswith('.css') or filename.startswith('_'):
                continue
            fixFile(os.path.join(dirpath, filename), config)

########NEW FILE########
__FILENAME__ = EntityUtil
from ckstyle.browsers.BinaryRule import ALL

import re
replacer1 = re.compile('\s*{\s*')
replacer2 = re.compile('\s*:\s*')
replacer3 = re.compile('\s*;\s*}\s*')
replacer4 = re.compile('\s*;\s*')
replacer5 = re.compile('\s\s+')
replacer6 = re.compile('\(\s+')
replacer7 = re.compile('\s+\)')
replacer8 = re.compile('\s+,')
replacer9 = re.compile(',\s+')

class Cleaner():
    @staticmethod
    def clean(msg):
        msg = msg.strip().replace('\r', '').replace('\n', '').replace(' ' * 4, ' ')
        msg = replacer1.sub('{', msg)
        msg = replacer2.sub(':', msg)
        msg = replacer3.sub('}', msg)
        msg = replacer4.sub(';', msg)
        msg = replacer5.sub(' ', msg)
        msg = replacer6.sub('(', msg)
        msg = replacer7.sub(')', msg)
        msg = replacer8.sub(',', msg)
        msg = replacer9.sub(',', msg)
        msg = msg.strip()
        return msg

    @staticmethod
    def clearName(name):
        name = name.strip()
        # #padding: 10px???
        if name.startswith('_') or name.startswith('*') or name.startswith('+') or name.startswith('#'):
            name = name[1:]
        if name.startswith('-'):
            if name.startswith('-moz-') or name.startswith('-webkit-') or name.startswith('-ms-') or name.startswith('-o-') or name.startswith('-khtml-'):
                name = '-'.join(name.split('-')[2:])
        return name.lower()

    @staticmethod
    def clearValue(value):
        value = value.strip()
        if value.endswith(';'):
            value = value[0: - 1]
        return value

    @staticmethod
    def clearValues(values):
        values = values.strip()
        return values

    @staticmethod
    def clearSelector(selector):
        return ' '.join(selector.split('\n')).strip()

    @staticmethod
    def clearComment(comment):
        comment = comment.strip()
        if len(comment) != 0 and comment.find('\n') == -1:
            comment = comment.replace('/*', '').replace('*/', '').strip()
            comment = '/* ' + comment + ' */'
        return comment

########NEW FILE########
__FILENAME__ = ExtraStatement
from .EntityUtil import Cleaner, ALL
from .RuleSet import RuleSet

class ExtraStatement(RuleSet):
    def __init__(self, operator, statement, comment, styleSheet = None):
        self.extra = True
        self.nested = False
        self.selector = self.operator = operator.strip()
        self.comment = comment
        self.statement = statement
        self.styleSheet = styleSheet

        self.fixedSelector = ''
        self.fixedStatement = ''

        self.browser = ALL
        self.toBeUsed = {}

    def isImport(self):
        return self.operator == '@import'

    def rebase(self):
        self.fixedSelector = ''
        self.fixedStatement = ''
        
    def isOpmOperator(self):
        return self.operator.find('@-css-compiler') != -1

    def compress(self, browser = ALL):
        # do not export @-css-compiler to online 
        if self.isOpmOperator():
            return ''

        if not self.browser & browser:
            return ''
        msg = Cleaner.clean(self.statement)
        if not msg.endswith('}') and not msg.endswith(';'):
            msg = msg + ';'
        return msg

    def fixed(self, config):
        return self.statement.strip() if len(self.comment) == 0 else self.comment + '\n' + self.statement.strip()

    def __str__(self):
        return '%s' % self.statement

########NEW FILE########
__FILENAME__ = NestedStatement
from .EntityUtil import Cleaner, ALL

class NestedStatement():
    def __init__(self, selector, statement, comments, styleSheet = None):
        self.extra = True
        self.nested = True
        self.selector = selector.strip()
        self.statement = statement.strip()
        self.roughStatement = statement
        self.comments = comments.strip()
        self.styleSheet = styleSheet

        self.fixedSelector = ''
        self.fixedStatement = ''

        self.browser = ALL
        self.toBeUsed = {}

    def rebase(self):
        self.fixedSelector = ''
        self.fixedStatement = ''
        
    def compress(self, browser = ALL):
        if not self.browser & browser:
            return ''
        return self.fixedSelector + self._compressedStatement()

    def fixed(self, config):
        return self.fixedSelector + ' {\n    ' + '\n    '.join(self.fixedStatement.split('\n')) + '\n}'

    def _compressedStatement(self):
        return '{' + Cleaner.clean(self.fixedStatement) + '}'

    def __str__(self):
        return '%s' % self.statement

########NEW FILE########
__FILENAME__ = Rule
from .EntityUtil import Cleaner, ALL

class Rule():
    def __init__(self, selector, name, value, ruleSet):
        self.roughName = name
        self.roughValue = value
        self.roughSelector = selector

        self.name = Cleaner.clearName(name)
        self.value = Cleaner.clearValue(value)
        self.selector = Cleaner.clearSelector(selector)

        self.strippedName = name.strip()
        self.strippedValue = value.strip()
        self.strippedSelector = selector.strip()

        self.fixedName = ''
        self.fixedValue = ''

        self.ruleSet = ruleSet

        self.browser = ALL
        self.toBeUsed = {}

    def rebase(self):
        self.fixedName = ''
        self.fixedValue = ''
        
    def reset(self, name, value):
        self.roughName = self.name = self.strippedName = self.fixedName = name
        self.roughValue = self.value = self.strippedValue = self.fixedValue = value

    def compress(self, browser = ALL):
        #print self.strippedName, self.value, bin(self.browser), bin(browser), self.browser & browser
        if not self.browser & browser:
            return ''
        name = self.name if self.fixedName == '' else self.fixedName.strip()
        value = self.value if self.fixedValue == '' else self.fixedValue.strip()
        return name + ':' + Cleaner.clean(value) + ';'

    def fixed(self):
        name = self.strippedName if self.fixedName == '' else self.fixedName
        value = self.strippedValue if self.fixedValue == '' else self.fixedValue
        return name + ': ' + Cleaner.clean(value) + ';'

    def getRuleSet(self):
        return self.ruleSet

    def __str__(self):
        return ' roughName: %s\n name: %s\n roughValue: %s\n value: %s\n' % (self.roughName, self.name, self.roughValue, self.value)

########NEW FILE########
__FILENAME__ = RuleSet
from .EntityUtil import Cleaner, ALL
from .Rule import Rule

class RuleSet():
    def __init__(self, selector, values, comment, styleSheet):
        self.extra = False
        self.roughSelector = selector
        self.roughValue = values
        self.roughComment = comment

        self.selector = Cleaner.clearSelector(selector)
        self.values = Cleaner.clearValues(values)
        self.comment = Cleaner.clearComment(comment)

        self.fixedSelector = ''
        self.fixedComment = ''

        self.styleSheet = styleSheet
        self._rules = []

        self.singleLineFlag = (len(self.roughValue.split('\n')) == 1)

        self.browser = ALL
        self.toBeUsed = {}

    def rebase(self):
        self.fixedSelector = ''
        self.fixedComment = ''

    def extendSelector(self, other):
        splited = [x.strip() for x in self.selector.split(',') if x.strip() is not '']
        otherSplited = [x.strip() for x in other.selector.split(',') if x.strip() is not '']

        for x in otherSplited:
            if x not in splited:
                self.selector = self.selector + ', ' + x
                self.roughSelector = self.roughSelector + ', ' + x
                self.fixedSelector = self.fixedSelector + ',' + x

        if len(other.comment) != 0 and self.comment.find(other.comment) == -1:
            # do not need duplicated comment
            self.roughComment = self.roughComment + ('\n' + other.roughComment)
            self.comment = self.comment + '\n' + other.comment
            self.fixedComment = self.fixedComment + '\n' + other.fixedComment

    def compressRules(self, browser = ALL):
        collector = []
        for rule in self._rules:
            compressed = rule.compress(browser)
            if compressed != '':
                collector.append(compressed)
        collected = ''.join(collector)
        if collected != '':
            collected = collected[0:-1]
        return collected

    def compress(self, browser = ALL):
        if not self.browser & browser:
            return ''
        result = self.selector if self.fixedSelector == '' else self.fixedSelector
        if result.find(','):
            # remove duplicated selectors
            selectors = []
            for x in result.split(','):
                x = x.strip()
                if x in selectors:
                    continue
                selectors.append(x)
            result = ','.join(selectors)
        compressed = self.compressRules(browser)
        if compressed == '':
            return ''
        result = result + '{' + compressed + '}'
        return result

    def fixedRules(self, config = None):
        collector = []
        spaces = ' ' * 4
        seperator = '\n'
        if config is not None and config.fixToSingleLine:
            spaces = ''
            seperator = ' '
        for rule in self._rules:
            collector.append(spaces + rule.fixed())
        collected = seperator.join(collector)
        return collected

    def fixed(self, config = None):
        comment = self.comment if self.fixedComment == '' else self.fixedComment
        selector = self.selector if self.fixedSelector == '' else self.fixedSelector
        if selector.find(','):
            # remove duplicated selectors
            selectors = []
            for x in selector.split(','):
                x = x.strip()
                if x in selectors:
                    continue
                selectors.append(x)
            selector = ',\n'.join(selectors)
        seperator = '\n'
        if config is not None and config.fixToSingleLine:
            seperator = ' '
        result = selector + ' {' + seperator + self.fixedRules(config) + seperator + '}'
        if comment != '':
            result = comment + '\n' + result
        return result

    def getSingleLineFlag(self):
        return self.singleLineFlag

    def getStyleSheet(self):
        return self.styleSheet

    def addRuleByStr(self, selector, attr, value):
        self._rules.append(Rule(selector, attr, value, self))

    def indexOf(self, name):
        counter = 0
        for rule in self._rules:
            if rule.roughName.strip() == name:
                return counter
            counter = counter + 1
        return -1
    
    def removeRuleByIndex(self, index):
        if index < len(self._rules):
            self._rules[index] = None

    def clean(self):
        newRules = []
        for rule in self._rules:
            if rule is None:
                continue
            newRules.append(rule)
        self._rules = newRules

    def existNames(self, name):
        if name.find(',') != -1:
            names = name.split(',')
        else:
            names = [name]
        for name in names:
            name = name.strip()
            for rule in self._rules:
                if rule.name == name:
                    return True
        return False

    def existRoughNames(self, name):
        if name.find(',') != -1:
            names = name.split(',')
        else:
            names = [name]
        for name in names:
            name = name.strip()
            for rule in self._rules:
                if rule.strippedName == name:
                    return True
        return False

    def getRuleByStrippedName(self, name):
        for rule in self._rules:
            if rule.strippedName == name:
                return rule

    def getRuleByRoughName(self, name):
        for rule in self._rules:
            if rule.roughName == name:
                return rule

    def getRuleByName(self, name):
        for rule in self._rules:
            if rule.name == name:
                return rule

    def getRules(self):
        return self._rules

    def setRules(self, newRules):
        self._rules = newRules

    def __str__(self):
        return '%s {%s}' % (self.selector, self.roughValue)

########NEW FILE########
__FILENAME__ = StyleSheet
from .RuleSet import RuleSet
from .ExtraStatement import ExtraStatement
from .NestedStatement import NestedStatement
from .EntityUtil import ALL

class StyleSheet():
    def __init__(self, fileName = ''):
        self._ruleSets = [];
        self._file = fileName
        self.browser = ALL
        self.toBeUsed = {}

    def addRuleSetByStr(self, selector, attrs, comment):
        self._ruleSets.append(RuleSet(selector, attrs, comment, self))

    def addExtraStatement(self, operator, statement, comment):
        self._ruleSets.append(ExtraStatement(operator, statement, comment, self))

    def addNestedRuleSet(self, selector, attrs, comment):
        self._ruleSets.append(NestedStatement(selector, attrs, comment, self))

    def setFile(self, fileName):
        self._file = fileName

    def getFile(self):
        return self._file

    def getRuleSets(self):
        return self._ruleSets

    def removeRuleSetByIndex(self, index):
        self._ruleSets[index] = None

    def removeRuleSet(self, ruleSet):
        newRuleSets = []
        for x in self._ruleSets:
            if x == ruleSet:
                continue
            newRuleSets.append(x)
        self._ruleSets = newRuleSets

    def clean(self):
        newRuleSets = []
        for x in self._ruleSets:
            if x is None:
                continue
            newRuleSets.append(x)
        self._ruleSets = newRuleSets

    def getRuleSetBySelector(self, selector):
        for ruleSet in self._ruleSets:
            if ruleSet.selector == selector:
                return ruleSet

    def compress(self, browser = ALL):
        result = []
        for ruleSet in self._ruleSets:
            if not ruleSet.browser & browser:
                continue
            result.append(ruleSet.compress(browser))
        return ''.join(result)

    def fixed(self, config):
        result = []
        for ruleSet in self._ruleSets:
            result.append(ruleSet.fixed(config))
        return '\n\n'.join(result)

    def rebase(self):
        for ruleSet in self._ruleSets:
            ruleSet.rebase()

########NEW FILE########
__FILENAME__ = Base
class ERROR_LEVEL:
    ERROR = 0
    WARNING = 1
    LOG = 2

class Checker():
    def __init__(self):
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg = '_default_msg'
    def check(self, xxx, config):
        pass
    def getMsg(self):
        return self.errorMsg
    def getLevel(self):
        return self.errorLevel

class RuleChecker(Checker):
    def __init__(self):
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg = ''
    def check(self, rule, config):
        return True

class RuleSetChecker(Checker):
    def __init__(self):
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg = ''
    def check(self, ruleSet, config):
        return True

class StyleSheetChecker(Checker):
    def __init__(self):
        self.errorLevel = ERROL_LEVEL.LOG
        self.errorMsg = ''
    def check(self, styleSheet, config):
        return True

class ExtraChecker(Checker):
    def __init__(self):
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg = ''
    def check(self, ruleSet, config):
        return True
########NEW FILE########
__FILENAME__ = Combiner
class Combiner():
    def combine(self, name, attrs):
        pass

########NEW FILE########
__FILENAME__ = CombinerFactory
from ckstyle.cmdconsole.ConsoleClass import console

def doCombine(name, props):
    pluginName = camelCase(name) + 'Combiner'
    pluginClass = NullCombiner
    try:
        plugin = __import__('ckstyle.plugins.combiners.' + pluginName, fromlist = [pluginName])
        if hasattr(plugin, pluginName):
            pluginClass = getattr(plugin, pluginName)
        else:
            console.error('%s should exist in %s.py' % (pluginName, pluginName))
    except ImportError as e:
        pass
    instance = pluginClass(name, props)
    return instance.combine()

class NullCombiner():
    def __init__(self, name, props):
        pass
    def combine(self):
        return None, [], False

def camelCase(name):
    splited = name.split('-')

    collector = []
    for x in splited:
        collector.append(x.capitalize())
    return ''.join(collector)

if __name__ == '__main__':
    print(doCombine('margin', [
        ['margin', 'margin', '50px auto 0 auto']
    ]))

########NEW FILE########
__FILENAME__ = helper
def containsHack(name, strippedName, value):
    return name != strippedName or value.find('\9') != -1

########NEW FILE########
__FILENAME__ = MarginCombiner
from .Combiner import Combiner
from .helper import containsHack

class MarginCombiner(Combiner):
    def __init__(self, name, attrs):
        self.name = name
        self.attrs = attrs
        self.combined = ''
        self.collector = {}
        self.deleted = []
        self.hasFather = False
        self.subs = ['left', 'top', 'bottom', 'right']
        self.initSubs()

    def initSubs(self):
        name = self.name
        for sub in self.subs:
            self.collector[name + '-' + sub] = ''

    def _seperate(self, value):
        splited = value.split(' ')
        top = right = bottom = left = ''
        length = len(splited)
        if length == 1:
            top = right = bottom = left = value
        elif length == 2:
            top = bottom = splited[0].strip()
            left = right = splited[1].strip()
        elif length == 3:
            top = splited[0].strip()
            left = right = splited[1].strip()
            bottom = splited[2].strip()
        elif length >= 4:
            top = splited[0].strip()
            right = splited[1].strip()
            bottom = splited[2].strip()
            left = splited[3].strip()
        name = self.name
        self.collector[self.name + '-top'] = top
        self.collector[self.name + '-right'] = right
        self.collector[self.name + '-bottom'] = bottom
        self.collector[self.name + '-left'] = left

    def collect(self):
        name = self.name
        attrs = self.attrs
        for prop in attrs:
            if containsHack(prop[0], prop[1], prop[2]):
                break;

            if prop[1] == name:
                self.hasFather = True
                self._seperate(prop[2])
            else:
                if not prop[1] in self.deleted:
                    self.deleted.append(prop[1])
                self.collector[prop[0]] = prop[2]

    def join(self):
        left = self.collector[self.name + '-left']
        top = self.collector[self.name + '-top']
        right = self.collector[self.name + '-right']
        bottom = self.collector[self.name + '-bottom']

        if left == '' or top == '' or right == '' or bottom == '':
            self.combined = None
            self.deleted = []
            return

        if left == right == bottom == top:
            self.combined = left
        elif left == right and bottom == top:
            self.combined = '%s %s' % (top, left)
        elif top != bottom and left == right:
            self.combined = '%s %s %s' % (top, right, bottom)
        else:
            self.combined = '%s %s %s %s' % (top, right, bottom, left)

    def combine(self):
        self.collect()
        self.join()
        return self.combined, self.deleted, self.hasFather

########NEW FILE########
__FILENAME__ = PaddingCombiner
from .Combiner import Combiner
from .helper import containsHack

class PaddingCombiner(Combiner):
    def __init__(self, name, attrs):
        self.name = name
        self.attrs = attrs
        self.combined = ''
        self.collector = {}
        self.deleted = []
        self.hasFather = False
        self.subs = ['left', 'top', 'bottom', 'right']
        self.initSubs()

    def initSubs(self):
        name = self.name
        for sub in self.subs:
            self.collector[name + '-' + sub] = ''

    def _seperate(self, value):
        splited = value.split(' ')
        top = right = bottom = left = ''
        length = len(splited)
        if length == 1:
            top = right = bottom = left = value
        elif length == 2:
            top = bottom = splited[0].strip()
            left = right = splited[1].strip()
        elif length == 3:
            top = splited[0].strip()
            left = right = splited[1].strip()
            bottom = splited[2].strip()
        elif length >= 4:
            top = splited[0].strip()
            right = splited[1].strip()
            bottom = splited[2].strip()
            left = splited[3].strip()
        name = self.name
        self.collector[self.name + '-top'] = top
        self.collector[self.name + '-right'] = right
        self.collector[self.name + '-bottom'] = bottom
        self.collector[self.name + '-left'] = left

    def collect(self):
        name = self.name
        attrs = self.attrs
        for prop in attrs:
            if containsHack(prop[0], prop[1], prop[2]):
                break;

            if prop[1] == name:
                self.hasFather = True
                self._seperate(prop[2])
            else:
                if not prop[1] in self.deleted:
                    self.deleted.append(prop[1])
                self.collector[prop[0]] = prop[2]

    def join(self):
        left = self.collector[self.name + '-left']
        top = self.collector[self.name + '-top']
        right = self.collector[self.name + '-right']
        bottom = self.collector[self.name + '-bottom']

        if left == '' or top == '' or right == '' or bottom == '':
            self.combined = None
            self.deleted = []
            return

        if left == right == bottom == top:
            self.combined = left
        elif left == right and bottom == top:
            self.combined = '%s %s' % (top, left)
        elif top != bottom and left == right:
            self.combined = '%s %s %s' % (top, right, bottom)
        else:
            self.combined = '%s %s %s %s' % (top, right, bottom, left)

    def combine(self):
        self.collect()
        self.join()
        return self.combined, self.deleted, self.hasFather

########NEW FILE########
__FILENAME__ = FEDCanNotSetFontFamily
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import isFontFamilyName

class FEDCanNotSetFontFamily(RuleChecker):
    
    '''{
        "summary":"不允许业务代码设置字体",
        "desc":"由于业务代码中随意设置字体，导致字体取值混乱，因此不允许随意在业务代码中设置字体"
    }'''

    def __init__(self):
        self.id = 'no-font-family'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'can not set font-family for "${selector}"'

    def check(self, rule, config):
        if rule.name == 'font-family':
            return False

        if rule.name == 'font':
            # many fonts
            if rule.value.find(',') != -1:
                return False

            # one font
            splited = rule.value.split(' ')
            if isFontFamilyName(splited[len(splited) - 1]):
                return False

        return True

########NEW FILE########
__FILENAME__ = FEDCombineInToOne
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import canBeCombined, isCss3PrefixProp, containsHack
from .combiners.CombinerFactory import doCombine

class FEDCombineInToOne(RuleSetChecker):
    
    '''{
        "summary":"将多个子样式合并",
        "desc":"有的子样式可以合并为总样式，包括
            <code>margin</code> <code>padding</code> <code>font</code> <code>background</code> <code>border</code>
            等，合并以后可以获得更好的执行效率和压缩效果，<br/>
            例如：<br/>
            <code>.test {margin:4px; margin-right:0;}</code><br/>
            <code>==></code><br/>
            <code>.test{margin:4px 0 4px 4px}</code><br/>
        "
    }'''

    def __init__(self):
        self.id = 'combine-into-one'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_rough = 'should combine "%s" to "%s" in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        rules = ruleSet.getRules()

        counter = self._countCanBeCombined(rules)

        for name, value in counter.items():
            if name == 'font' and len(value) > 2 or name != 'font' and len(value) > 1:
                self.errorMsg = self.errorMsg_rough % (','.join(value), name)
                return False
        return True 

    def fix(self, ruleSet, config):
        rules = ruleSet.getRules()
        counter = self._countCanBeCombined(rules, True)
        rules = self._combineAttrs(rules, counter)
        ruleSet.setRules(rules)

    def _countCanBeCombined(self, rules, forFix = False):
        counter = {}
        for rule in rules:
            name = rule.name
            if rule.name != rule.strippedName:
                continue
            # do not do any hack combine
            if containsHack(rule):
                continue
            # -moz-border-radius, -o-border-radius is not for me
            if isCss3PrefixProp(name):
                continue

            bigger = canBeCombined(name)
            if bigger is not None:
                if counter.has_key(bigger):
                    if forFix:
                        counter[bigger].append([name, rule.fixedName, rule.fixedValue])
                    else:
                        counter[bigger].append(name)
                else:
                    if forFix:
                        counter[bigger] = [[name, rule.fixedName, rule.fixedValue]]
                    else:
                        counter[bigger] = [name]
        return counter

    def _combineAttrs(self, rules, counter):
        originRules = rules
        for name, value in counter.items():
            combined, deleted, hasFather = doCombine(name, value)
            if combined == None:
                continue

            newRules = []
            for rule in originRules:
                if containsHack(rule):
                    newRules.append(rule)
                    continue
                # it is what i want
                if rule.fixedName == name:
                    rule.fixedValue = combined
                    newRules.append(rule)
                    continue
                # it is what i want to delete
                if rule.fixedName in deleted:
                    if not hasFather:
                        rule.reset(name, combined)
                        newRules.append(rule)
                        hasFather = True
                    continue
                newRules.append(rule)
            originRules = newRules
        return originRules

########NEW FILE########
__FILENAME__ = FEDCombineSameRuleSets
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import hasHackChars
from ckstyle.browsers.BinaryRule import ALL, STD
from ckstyle.browsers.Detector import doRuleSetDetect
class FEDCombineSameRuleSets(StyleSheetChecker):

    '''{
        "summary":"合并两个完全相同的规则集",
        "desc":"如果两个规则集完全一样，则可以进行合并。<br>
            需要指出的是：合并可能会带来功能上的问题。如果有问题，还请告知~<br>
            例如：<br>
            <code>.a {width:100px}</code><br>
            <code>.b {width:100px}</code><br>
            <code>==></code><br>
            <code>.a, .b {width:100px}</code><br>
            <br>
            <strong>安全模式下将不执行此规则</strong><br>
        "
    }'''

    def __init__(self):
        self.id = 'combine-same-rulesets'
        self.errorMsg_empty = '"%s" contains the same rules in "${file}"'
        self.errorMsg = ''
        self.errorLevel = ERROR_LEVEL.WARNING

    # can be checked correctly only after reorder/fix/compress, so do not check
    def check(self, styleSheet, config):
        ruleSets = styleSheet.getRuleSets()
        mapping = self._gen_hash(ruleSets, ALL)
        length = len(mapping)

        errors = {}
        for i in range(length):
            for j in range(i + 1, length):
                if mapping[i][1] == mapping[j][1]:
                    cssText = mapping[i][1]
                    if not errors.has_key(cssText):
                        errors[cssText] = []
                        errors[cssText].append(mapping[i][0])
                        errors[cssText].append(mapping[j][0])
                    elif mapping[j][0] not in errors[cssText]:
                        errors[cssText].append(mapping[j][0])
                    #errors.append(self.errorMsg_empty % (mapping[i][0], mapping[j][0]))
        if len(errors.keys()) == 0:
            return True
        msgs = [(self.errorMsg_empty % ', '.join(x)) for x in errors.values()]
        return msgs 

    def fix(self, styleSheet, config):
        browser = config._curBrowser if config._curBrowser is not None else ALL
        ruleSets = styleSheet.getRuleSets()
        mapping = self._gen_hash(ruleSets, browser)

        length = len(mapping)

        splitedSelectors = []
        for i in range(length):
            splitedSelectors.append([x.strip() for x in mapping[i][0].split(',') if x.strip() is not ''])

        for i in range(length):            
            if mapping[i][0] == 'extra':
                continue
            selectorHistory = []

            for j in range(i + 1, length):
                if mapping[i][1] != mapping[j][1]:
                    selectorHistory.extend(splitedSelectors[j])
                    continue

                # 合并则遵循如下策略：
                # 1、两者必须都与当前要求的浏览器兼容，即 browserI & browser != 0 and browserJ & browser != 0
                # 2、两者的浏览器兼容性必须完全一致，即 browserI ^ browserJ == 0
                # 第二点主要是因为有的属性合并以后，由于兼容性不同，受不兼容的selector影响，使本应该兼容的selector失效。
                browserI = doRuleSetDetect(mapping[i][0])
                browserJ = doRuleSetDetect(mapping[j][0])
                if not (browserI & browser != 0 and browserJ & browser != 0 and browserI ^ browserJ == 0):
                    continue

                # bakcground-position is dangerous, position设置必须在background-image之后
                if mapping[j][1].find('background-position') != -1:
                    selectorHistory.extend(splitedSelectors[j])
                    continue

                hasFlag = False
                # ".a {width:0} .a, .b{width:1}, .b{width:0}" 不应该被合并成 ".a, .b{width:0} .a, .b{width:1}"
                # 但是目前还有一个最严重的问题：
                # .c {width:1}, .d{width:0}, .b{width:1}, .a{width:0}
                # class="a c" => width 0
                # class="b d" => width 1
                # 一旦合并成 .b,.c{width:1} .d,.a{width:0} （不论往前合并还是往后合并，都是这个结果，囧）
                # class="a c" => width 0
                # class="b d" => width 0(本来为1)
                # 这是无法解决的问题，因为我不能在没有分析DOM的情况下，确定两个selector指向同一个dom
                # 为此，安全模式 --safeMode 诞生。
                for x in splitedSelectors[j]:
                    if x in selectorHistory:
                        hasFlag = True
                        break
                if hasFlag:
                    selectorHistory.extend(splitedSelectors[j])
                    continue

                # make it different
                mapping[j][1] = str(i) + str(j)
                mapping[j][0] = 'extra'

                # extend target selector
                target = styleSheet.getRuleSets()[i]
                src = styleSheet.getRuleSets()[j]
                target.extendSelector(src)

                # remove rule set
                styleSheet.removeRuleSetByIndex(j)
                selectorHistory.extend(splitedSelectors[j])

        # remember to clean after remove ruleset
        styleSheet.clean()

    def _gen_hash(self, ruleSets, browser):
        mapping = []
        counter = 0
        for r in ruleSets:
            if r.extra:# or doRuleSetDetect(r.selector) != STD:
                # make it impossible to equal
                mapping.append(['extra', "do_not_combine_" + str(counter)])
                counter = counter + 1
                continue
            mapping.append([r.selector, r.compressRules(browser)])
        return mapping

########NEW FILE########
__FILENAME__ = FEDCommentLengthLessThan80
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDCommentLengthLessThan80(RuleSetChecker):

    '''{
        "summary":"注释不能超过80个字符",
        "desc":"注释长度不能超过80个字符，40个汉字，如果超出，则应该要换行~"
    }'''

    def __init__(self):
        self.id = 'comment-length'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg = 'comment for "${selector}" length should less than 80 per line'

    def check(self, ruleSet, config):
        comment = ruleSet.roughComment
        if len(comment) == 0:
            return True

        cs = comment.split('\n')
        for c in cs:
            if len(c.strip()) > 80:
                return False
        return True 

########NEW FILE########
__FILENAME__ = FEDCss3PropPrefix
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import isCss3Prop, isCss3PrefixProp, doNotNeedPrefixNow

class FEDCss3PropPrefix(RuleChecker):

    '''{
        "summary":"CSS3前缀相关检查",
        "desc":"CSS3属性的前缀，有的可以省略，比如：<br>
            <code>border-radius</code><br>
            有的是省略，必须写全，比如：<br><code>transition</code> <code>transform</code>等<br>
            在编写顺序上，本工具要求按照<br>
            <code>-webkit-,-moz-,-ms-,-o-,std</code><br>的顺序来编写，并且严格将属性的第一个字符对齐。"
    }'''

    def __init__(self):
        self.id = 'css3-with-prefix'
        self.errorLevel_keepInOrder = ERROR_LEVEL.WARNING
        self.errorLevel_missing = ERROR_LEVEL.ERROR
        self.errorLevel = ERROR_LEVEL.LOG

        self.errorMsg_keepInOrder = 'css3 prop "${name}" should keep in "-webkit-,-moz-,-ms-,-o-,std" order in "${selector}"'
        self.errorMsg_missing = 'css3 prop "${name}" missing some of "-webkit-,-moz-,-o-,std" in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        name = rule.name
        # only for css3 props
        if not isCss3Prop(name):
            return True

        if not isCss3PrefixProp(name):
            return True

        if doNotNeedPrefixNow(name):
            return True
        
        ruleSet = rule.getRuleSet()
        webkitName = '-webkit-' + name
        mozName = '-moz-' + name
        msName = '-ms-' + name # not necessary
        oName = '-o-' + name

        if not (ruleSet.existRoughNames(webkitName) 
                and ruleSet.existRoughNames(mozName)
                and ruleSet.existRoughNames(oName)
                and ruleSet.existRoughNames(name)):
            self.errorMsg = self.errorMsg_missing
            self.errorLevel = self.errorLevel_missing
            return False

        # in order -webkit-  -moz-  -ms-  -o-  std
        webkit = ruleSet.indexOf(webkitName)
        moz = ruleSet.indexOf(mozName)
        ms = ruleSet.indexOf(msName)
        if ms == -1:
            ms = moz
        o = ruleSet.indexOf(oName)
        std = ruleSet.indexOf(name)

        if not (webkit < moz <= ms < o < std):
            self.errorMsg = self.errorMsg_keepInOrder
            self.errorLevel = self.errorLevel_keepInOrder
            return False
        return True

########NEW FILE########
__FILENAME__ = FEDCss3PropSpaces
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import isCss3Prop, isCss3PrefixProp, doNotNeedPrefixNow
import re

pattern = re.compile('%\d+')
class FEDCss3PropSpaces(RuleChecker):
    
    '''{
        "summary":"CSS3缩进相关检查",
        "desc":"CSS3属性的缩进，必须将属性名称的第一个字符对齐。即：<br>
            <code>-webkit-transition:3s;</code>
            <br><code>&nbsp;&nbsp;&nbsp;-moz-transition:3s;</code>
            <br><code>&nbsp;&nbsp;&nbsp;&nbsp;-ms-transition:3s;</code>
            <br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-o-transition:3s;</code>
            <br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transition:3s;</code>
        "
    }'''

    def __init__(self):
        self.id = 'css3-prop-spaces'

        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_multi = 'css3 prop "${name}" should align to right in "${selector}"'
        self.errorMsg_single = 'should have 1(only) space before css3 prop "${name}" in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        name = rule.name
        # only for css3 props
        if not isCss3Prop(name):
            return True

        if not isCss3PrefixProp(name):
            return True
        
        if doNotNeedPrefixNow(name):
            # if exists prefix, then should keep spaces
            if not rule.getRuleSet().existRoughNames('-webkit-%s,-moz-%s,-ms-%s,-o-%s' % (name,name,name,name)):
                return True

        roughName = rule.roughName

        if rule.getRuleSet().singleLineFlag is False:
            # 12 = 4 + 8, 4 spaces, 8 for align
            if len(roughName.split(name)[0]) != 12:
                self.errorMsg = self.errorMsg_multi
                return False
        else:
            if roughName.startswith('  ') or not roughName.startswith(' '):
                self.errorMsg = self.errorMsg_single
                return False
        return True

    def fix(self, rule, config):
        name = rule.name
        # only for css3 props
        if not isCss3Prop(name):
            return

        if not isCss3PrefixProp(name):
            return

        if not rule.getRuleSet().existRoughNames('-webkit-%s,-moz-%s,-ms-%s,-o-%s' % (name,name,name,name)):
            return

        fixedName = rule.fixedName
        prefix = fixedName.split(name)[0]
        if rule.selector.find('%') != -1:
            remained = '-webkit-,-moz-,-ms-,-o-,'.replace(prefix + ',', '')
            testString = ','.join([(x + name) for x in remained[:-1].split(',')])
            if not rule.getRuleSet().existRoughNames(testString):
                return
        rule.fixedName = ((8 - len(prefix)) * ' ' if not config.fixToSingleLine else '') + fixedName

########NEW FILE########
__FILENAME__ = FEDDistinguishBrowserExtra
#/usr/bin/python
#encoding=utf-8

from .Base import *
import string
from ckstyle.browsers.Detector import Browser

class FEDDistinguishBrowserExtra(ExtraChecker):
    
    '''{
        "summary":"嵌套规则区分浏览器",
        "desc":"目的是针对不同的浏览器，生成不同的CSS规则集"
    }'''

    def __init__(self):
        self.id = 'extra-for-browsers'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = ''

    def check(self, ruleSet, config):
        return True

    def fix(self, ruleSet, config):
        if not ruleSet.nested:
            return
        Browser.handleNestedStatement(ruleSet)
########NEW FILE########
__FILENAME__ = FEDDistinguishBrowserRule
#/usr/bin/python
#encoding=utf-8

from .Base import *
import string
from ckstyle.browsers.Detector import Browser

class FEDDistinguishBrowserRule(RuleChecker):
    
    '''{
        "summary":"在属性级别区分浏览器",
        "desc":"目的是针对不同的浏览器，生成不同的CSS"
    }'''

    def __init__(self):
        self.id = 'rule-for-browsers'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = ''

    def check(self, rule, config):
        return True

    def fix(self, rule, config):
        Browser.handleRule(rule)
########NEW FILE########
__FILENAME__ = FEDDistinguishBrowserRuleSet
#/usr/bin/python
#encoding=utf-8

from .Base import *
import string
from ckstyle.browsers.Detector import Browser

class FEDDistinguishBrowserRuleSet(RuleSetChecker):
    
    '''{
        "summary":"在规则集级别区分浏览器",
        "desc":"目的是针对不同的浏览器，生成不同的CSS规则集"
    }'''

    def __init__(self):
        self.id = 'ruleset-for-browsers'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = ''

    def check(self, ruleSet, config):
        return True

    def fix(self, ruleSet, config):
        Browser.handleRuleSet(ruleSet)
########NEW FILE########
__FILENAME__ = FEDDoNotSetStyleForSimpleSelector
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import isSimpleSelector

class FEDDoNotSetStyleForSimpleSelector(RuleSetChecker):
    
    '''{
        "summary":"不要为简单选择器设置样式",
        "desc":"一些简单的选择器，比如：<br>
            <code>.nav/.list/.content</code><br>
            非常容易造成属性的相互覆盖，因此在写这样的选择器时，最好加上前缀，比如<br>
            <code>.module-name .nav</code><br><br>
            工具现有的简单选择器判断，请参考：<br>
            <code>plugins/helper.py</code>"
    }'''

    def __init__(self):
        self.id = 'no-style-for-simple-selector'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_rough = 'should not set style for "%s" in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selector = ruleSet.selector.lower()

        if selector.find('@media') != -1:
            return True

        if selector.find('@-moz-document') != -1:
            return True

        selectors = selector.split(',')
        for s in selectors:
            s = s.strip()
            if isSimpleSelector(s):
                self.errorMsg = self.errorMsg_rough % s
                return False
        return True 

########NEW FILE########
__FILENAME__ = FEDDoNotSetStyleForTagOnly
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import isHTMLTag

class FEDDoNotSetStyleForTagOnly(RuleSetChecker):
    
    '''{
        "summary":"不要为html tag设置样式",
        "desc":"除了重置 CSS(如Reset.css) 的相关设置，其他代码一律不允许为html tag设置样式。"
    }'''

    def __init__(self):
        self.id = 'no-style-for-tag'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'should not set style for html tag in "${selector}"'

    def check(self, ruleSet, config):
        selector = ruleSet.selector.lower()
        if selector.find('@media') != -1:
            return True
        if selector.find('@-moz-document') != -1:
            return True
        selectors = selector.split(',')
        for s in selectors:
            if isHTMLTag(s.strip()):
                return False
        return True 

########NEW FILE########
__FILENAME__ = FEDFixCommentInValue
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDFixCommentInValue(RuleChecker):
    
    '''{
        "summary":"修复属性中的注释",
        "desc":"width:/* fdasfdas */ 100px /* fdafdas */; ==> width:100px;"
    }'''

    def __init__(self):
        self.id = 'fix-comment-in-value'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = ''
        self.private = True

    def check(self, rule, config):
        return True


    def fix(self, rule, config):
        if rule.name == 'expression':
            return
        value = rule.fixedValue
        if value.find('/*') == -1:
            return

        splited = value.split('/*')
        collector = []
        for x in splited:
            tmp = x.split('*/')
            if len(tmp) == 1:
                collector.append(tmp[0])
            else:
                collector.append(tmp[1])
        rule.fixedValue = ''.join(collector)

########NEW FILE########
__FILENAME__ = FEDFixNestedStatement
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDFixNestedStatement(ExtraChecker):
    
    '''{
        "summary":"修复嵌套的CSS",
        "desc":"@keyframes, @media之类的"
    }'''

    def __init__(self):
        self.id = 'fix-nested-ruleset'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = ''
        self.private = True

    def check(self, ruleSet, config):
        return True

    def fix(self, ruleSet, config):
        if not ruleSet.nested:
            return
        ruleSet.fixedSelector = ruleSet.fixedSelector.replace('"', '\'')
        statement = ruleSet.fixedStatement
        if (hasattr(config, 'operation') and getattr(config, 'operation') == 'compress'):
            from ckstyle.doCssCompress import prepare
            checker = prepare(statement, '', config)
            # 嵌套的CSS，如果是压缩，也需要精简
            msg = checker.doCompress(config._curBrowser)
            ruleSet.fixedStatement = msg
        else:
            from ckstyle.doCssFix import doFix
            checker, msg = doFix(statement, '', config)
            ruleSet.fixedStatement = msg

########NEW FILE########
__FILENAME__ = FEDFixOutlineZero
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDFixOutlineZero(RuleChecker):
    
    '''{
        "summary":"修复outline:none",
        "desc":"<code>outline:none</code> 和 <code>outline:0</code> 实现了相同的功能，但是后者的代码更简洁，便于压缩。"
    }'''

    def __init__(self):
        self.id = 'outline-zero'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = ''

    def check(self, rule, config):
        return True

    def fix(self, rule, config):
        if rule.name == 'outline' and rule.fixedValue == 'none':
            rule.fixedValue = '0'
########NEW FILE########
__FILENAME__ = FEDFontSizeShouldBePtOrPx
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDFontSizeShouldBePtOrPx(RuleChecker):
    
    '''{
        "summary":"字体的单位必须用px或pt",
        "desc":"字体的单位可以有很多种，比如 <code>px pt em %</code> 等等，为了统一取值，统一要求为 <code>px/pt</code> ， 例如：<br>
            <code>font-size: 12px;</code><br>
            <code>font-size: 14pt;</code>"
    }'''

    def __init__(self):
        self.id = 'font-unit'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_ptOrPx = 'font-size unit should be px/pt in "${selector}"'
        self.errorMsg_xsmall = 'font-size should not be small/medium/large in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        if rule.name != 'font-size':
            return True

        value = rule.value
        if value.find('small') != -1 or value.find('medium') != -1 or value.find('large') != -1:
            self.errorMsg = self.errorMsg_xsmall
            return False

        if value == '0':
            return True

        if value.endswith('pt'):
            return True

        if value.endswith('px'):
            return True

        self.errorMsg = self.errorMsg_ptOrPx
        return False

########NEW FILE########
__FILENAME__ = FEDHackAttributeInCorrectWay
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import isCss3PrefixProp

class FEDHackAttributeInCorrectWay(RuleChecker):
    
    '''{
        "summary":"hack属性时的检查",
        "desc":"必须使用正确的 hack 方式， 比如 <code>_ * +</code> 等，其他的属性前缀一律不允许"
    }'''

    def __init__(self):
        self.id = 'hack-prop'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = '"${name}" is not in correct hacking way in "${selector}"'

    def check(self, rule, config):
        if rule.value.find(r'\0') != -1:
            return False

        stripped = rule.roughName.strip()
        if rule.name == stripped.lower():
            return True

        if isCss3PrefixProp(rule.name):
            return True

        if not stripped.startswith('_') and not stripped.startswith('*') and not stripped.startswith('+'):
            return False

        return True 

########NEW FILE########
__FILENAME__ = FEDHackRuleSetInCorrectWay
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDHackRuleSetInCorrectWay(ExtraChecker):
    
    '''{
        "summary":"hack规则时的检查",
        "desc":"针对Firefox Opera Safari等浏览器的 hack 方式， <strong>人人FED CSS编码规范</strong>中有详细的描述， 
            不允许使用规定之外的方式进行规则级别的hack"
    }'''

    def __init__(self):
        self.id = 'hack-ruleset'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'not correct hacking way in "${selector}"'

    def check(self, ruleSet, config):
        if not ruleSet.nested:
            return True

        selector = ruleSet.selector.strip()
        if selector.find('@-moz-document') != -1:
            if selector != '@-moz-document url-prefix()':
                return False

        if selector.find('-webkit-min-device-pixel-ratio:0') != -1:
            if selector != '@media screen and (-webkit-min-device-pixel-ratio:0)' and selector.find('-webkit-min-device-pixel-ratio:10000') == -1:
                return False

        if selector.find('-webkit-min-device-pixel-ratio:10000') != -1:
            if selector.find('@media all') == -1 or selector.find('not all and') == -1 or selector.find('-webkit-min-device-pixel-ratio:0') == -1:
                return False

        return True 

########NEW FILE########
__FILENAME__ = FEDHexColorShouldUpper
#/usr/bin/python
#encoding=utf-8

from .Base import *
import re

pattern_color = re.compile(r'#([a-f0-9A-F]+)')

class FEDHexColorShouldUpper(RuleChecker):
    '''{
        "summary":"16进制颜色大写&缩写",
        "desc":"<p>浏览器会先将小写的颜色值转换成大写，所以写成大写格式可以省略这部分的开销，并且尽量省略，例如：
            </br><code>color:#ffffff; </code><br/><code>==></code><br/><code>color:#FFF;</code></p>"
    }'''

    def __init__(self):
        self.id = 'hexadecimal-color'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_length = 'wrong color length(should be 3 or 6) in "${selector}"'
        self.errorMsg_replace = 'replace "#%s" with "#%s" in "${selector}"'
        self.errorMsg_upper = 'color should in upper case in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        value = rule.value
        if value.find('#') == -1:
            return True

        found = self._findColor(rule.value)
        for f in found:
            flag = self._checkEach(f)
            if not flag:
                return False
        return True

    def _checkEach(self, found):
        if found is None:
            return True

        if self._isLower(found):
            self.errorMsg = self.errorMsg_upper
            return False

        if len(found) == 3:
            return True

        if self._wrongLength(found):
            self.errorMsg = self.errorMsg_length
            return False

        if self._isDuplicate(found):
            self.errorMsg = self.errorMsg_replace % (found, found[0]+found[2]+found[4])
            return False
        
        return True

    def fix(self, rule, config):
        value = rule.fixedValue
        if value.find('#') == -1:
            return

        hasImportant = rule.fixedValue.find('important') != -1
        found = self._findColor(rule.fixedValue)
        for f in found:
            self._fixEach(rule, f, hasImportant)

    def _fixEach(self, rule, found, hasImportant):
        if self._isLower(found):
            rule.fixedValue = rule.fixedValue.replace('#' + found, '#' + found.upper())
            found = found.upper()

        if len(found) == 3:
            return

        if not hasImportant and self._wrongLength(found):
            final = found[0:6] if len(found) > 6 else (found + (6 - len(found)) * 'F')
            rule.fixedValue = rule.fixedValue.replace('#' + found, '#' + final)
            found = final

        if self._isDuplicate(found):
            rule.fixedValue = rule.fixedValue.replace('#' + found, '#' + found[0] + found[2] + found[4])

    def _wrongLength(self, found):
        return len(found) != 3 and len(found) != 6

    def _isLower(self, found):
        return found is not None and found != found.upper()

    def _isDuplicate(self, found):
        return found[0] == found[1] and found[2] == found[3] and found[4] == found[5]

    def _findColor(self, value):
        splited = value.split(' ')
        found = []
        for x in splited:
            x = x.strip()
            matcher = pattern_color.findall(x)
            if matcher is not None:
                found.extend(matcher)
            #if x.startswith('#'):
            #    found.append(x.split('!important')[0][1:].split(',')[0].split(')')[0])
            #elif x.find('(#') != -1:
            #    found.append(x.split('(#')[1].split('!important')[0].split(',')[0].split(')')[0])
        return found

########NEW FILE########
__FILENAME__ = FEDHighPerformanceSelector
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import isHTMLTag

class FEDHighPerformanceSelector(RuleSetChecker):
    
    '''{
        "summary":"针对低性能的选择器的检查",
        "desc":"低性能选择器，害人害己还集体，本工具收集了一些低性能选择器的情形，具体请参见：<br>
            <code>FEDHighPerformanceSelector.py</code>中的相关内容"
    }'''

    def __init__(self):
        self.id = 'high-perf-selector'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_shorter = 'please shorter the selector "${selector}"'
        self.errorMsg_no1 = 'do not use low performance selector ">" in "${selector}"'
        self.errorMsg_lessTag = 'use less tag in "${selector}"'
        self.errorMsg_id = 'should not put "HTMLtag" and "#id" together in "${selector}"'
        self.errorMsg_class = 'should not put "HTMLtag" and ".class" together in "${selector}"'
        self.errorMsg_reg = 'should not use ~=,^=,|=,$=,*= in selector of "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selectors = ruleSet.selector.replace('  ', '').split(',')
        for s in selectors:
            if s.find('@media') != -1:
                continue

            if s.find('=') != -1:
                if s.find('~=') != -1 or s.find('^=') != -1 or s.find('|=') != -1 or s.find('$=') != -1 or s.find('*=') != -1:
                    self.errorMsg = self.errorMsg_reg
                    return False

            splited = s.split(' ')
            if len(splited) > 5:
                self.errorMsg = self.errorMsg_shorter
                return False
            counter = 0
            for p in splited:
                if p == '>':
                    self.errorMsg = self.errorMsg_no1
                    return False

                innerSplit = p.split('#')
                if len(innerSplit) == 2 and isHTMLTag(innerSplit[0]):
                    self.errorMsg = self.errorMsg_id
                    return False

                innerSplit = p.split('.')
                if len(innerSplit) == 2 and isHTMLTag(innerSplit[0]):
                    self.errorMsg = self.errorMsg_class
                    return False

                if isHTMLTag(p):
                    counter = counter + 1
            if counter > 1:
                self.errorMsg = self.errorMsg_lessTag
                return False

        noSpace = ruleSet.selector.replace(' ', '')
        if noSpace.find('ulli') != -1 or noSpace.find('olli') != -1 or noSpace.find('dldt') != -1 or noSpace.find('dldd') != -1:
            self.errorMsg = self.errorMsg_lessTag
            return False
        return True

########NEW FILE########
__FILENAME__ = FEDMultiLineBraces
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDMultiLineBraces(RuleSetChecker):
    
    '''{
        "summary":"多行CSS风格的括号检查",
        "desc":"用于检查多行风格下的 <code>{</code> 和 <code>}</code> 的编写风格，前后空格符和回车符的情况等。"
    }'''

    def __init__(self):
        self.id = 'multi-line-brace'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_shouldEnterAfterOpenningBrace = 'should "enter" after the opening brace in "${selector}"'
        self.errorMsg_shouldEnterBeforeClosingBrace = 'should "enter" before the closing brace in "${selector}"'
        self.errorMsg_extraSpaceAfterOpeningBrace = 'extra "space" after the opening brace in "${selector}"'
        self.errorMsg_everyAttrShouldInSingleLine = 'every name/value should in single line in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        singleLine = ruleSet.getSingleLineFlag()
        if singleLine:
            return True

        value = ruleSet.roughValue
        splited = value.split('\n')
        if splited[0].strip() != '':
            self.errorMsg = self.errorMsg_shouldEnterAfterOpenningBrace
            return False

        if splited[0].strip() == '' and splited[0].startswith(' '):
            self.errorMsg = self.errorMsg_extraSpaceAfterOpeningBrace
            return False

        ruleLength = len(ruleSet.getRules())
        if ruleLength != 0 and len(value.strip().split('\n')) != ruleLength:
            self.errorMsg = self.errorMsg_everyAttrShouldInSingleLine
            return False

        if not value.replace(' ', '').endswith('\n'):
            self.errorMsg = self.errorMsg_shouldEnterBeforeClosingBrace
            return False

        return True 

########NEW FILE########
__FILENAME__ = FEDMultiLineSelectors
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDMultiLineSelectors(RuleSetChecker):
    
    '''{
        "summary":"多行CSS风格的选择器检查",
        "desc":"多行风格下，每一个选择器单独占一行，并以逗号结尾，例如：<br>
            <code>.a,</code><br>
            <code>.b,</code><br>
            <code>.c {</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;width: 100px;</code><br>
            <code>}</code>
        "
    }'''

    def __init__(self):
        self.id = 'multi-line-selector'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_multiSelectorBeforeSemicolon = 'should not have "space" before semicolon in "${selector}"'
        self.errorMsg_multiSelectorBeforeSemicolon = 'should not have "space" after semicolon in "${selector}"'
        self.errorMsg_shouldEnter = 'should enter in multi-selector, in "${selector}"'
        self.errorMsg_tooManyEnters = 'too many "enter"s in "${selector}"'
        self.errorMsg_startsWithSpace = 'selector should not start with "space" in "${selector}"'
        self.errorMsg_extraSpaceAfterComma = 'extra "space" after comma in "${selector}"'
        self.errorMsg_extraSpaceBeforeComma = 'extra "space" before comma in "${selector}"'
        self.errorMsg_commaInTheEnd = 'comma should at the end of selector in "${selector}"'
        self.errorMsg_shouldAddSpaceForLast = 'should add "space" for last selector of "${selector}"'
        self.errorMsg_shouldNotEnterAtTheEnd = 'should not "enter" at the end of "${selector}"'
        self.errorMsg_selectorEndsWithSpace = 'selector should end with only one space "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selector = ruleSet.roughSelector

        if not selector.endswith(' ') or selector.endswith('  '):
            self.errorMsg = self.errorMsg_selectorEndsWithSpace
            return False

        if selector.find(',') == -1:
            return True

        if selector.replace(' ', '').endswith('\n'):
            self.errorMsg = self.errorMsg_shouldNotEnterAtTheEnd
            return False

        if selector.strip().find('\n') == -1:
            self.errorMsg = self.errorMsg_shouldEnter
            return False

        selectors = selector.split('\n')
        length = len(selectors)

        if len(selector.split(',')) != len(selector.strip().split('\n')):
            self.errorMsg = self.errorMsg_tooManyEnters
            return False

        realSelectors = []
        for s in selectors:
            if s.strip() != '':
                realSelectors.append(s)

        counter = 0
        length = len(realSelectors)
        for current in realSelectors:
            counter = counter + 1
            stripped = current.strip()
            if stripped == '':
                continue
            if current.startswith(' '):
                self.errorMsg = self.errorMsg_startsWithSpace
                return False
            if stripped.endswith(' ,'):
                self.errorMsg = self.errorMsg_extraSpaceBeforeComma
                return False
            if current.endswith(' ') and stripped.endswith(','):
                self.errorMsg = self.errorMsg_extraSpaceAfterComma
                return False
            if counter == length and not current.endswith(' '):
                self.errorMsg = self.errorMsg_shouldAddSpaceForLast
                return False
            if counter != length and stripped.find(',') == -1:
                self.errorMsg = self.errorMsg_commaInTheEnd
                return False

        return True 

        

########NEW FILE########
__FILENAME__ = FEDMultiLineSpaces
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import isCss3PrefixProp

class FEDMultiLineSpaces(RuleChecker):
    
    '''{
        "summary":"CSS多行风格的空格检查",
        "desc":"多行风格下，CSS的空格检查包括：
            <ol>
                <li>选择器的空格</li>
                <li>属性的空格</li>
                <li>结尾}的空格</li>
            </ol>
            具体请参见人人相关的CSS规范"
    }'''

    def __init__(self):
        self.id = 'multi-line-space'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_name_pre = 'should have 4 spaces before "${name}" in "${selector}"'
        self.errorMsg_name_after = 'should not have "space" after "${name}" in "${selector}"'
        self.errorMsg_value_pre = 'should have (only) one "space" before value of "${name}" in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        singleLine = rule.getRuleSet().getSingleLineFlag()
        if singleLine:
            return True
        
        prefix = ' ' * 4
        name = rule.roughName
        value = rule.roughValue
        stripped = rule.roughName.strip()

        # leave special css3 props for FEDCss3AttrChecker
        if isCss3PrefixProp(rule.name):
            if name.endswith(' '):
                self.errorMsg = self.errorMsg_name_after
                return False

            if not value.startswith(' ') or value.startswith('  '):
                self.errorMsg = self.errorMsg_value_pre
                return False

            return True

        if name.find('\t') != -1:
            name = name.replace('\t', prefix)
        if not name.startswith(prefix):
            self.errorMsg = self.errorMsg_name_pre
            return False
        if name.startswith(' ' * 5):
            self.errorMsg = self.errorMsg_name_pre
            return False
        if name.endswith(' '):
            self.errorMsg = self.errorMsg_name_after
            return False

        if not value.startswith(' ') or value.startswith('  '):
            self.errorMsg = self.errorMsg_value_pre
            return False

        return True 

########NEW FILE########
__FILENAME__ = FEDMustContainAuthorInfo
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import isHTMLTag

class FEDMustContainAuthorInfo(StyleSheetChecker):
    
    '''{
        "summary":"需要在文件中添加作者信息",
        "desc":"需要在文件中添加作者的信息，本工具认可的作者信息是在文件顶部的注释中添加 <code>@author:xxx</code>"
    }'''

    def __init__(self):
        self.id = 'add-author'
        self.errorMsg_author = 'should add @author in the head of "${file}"'
        self.errorMsg_empty = 'empty css file "${file}"'
        self.errorMsg = ''
        self.errorLevel = ERROR_LEVEL.ERROR

    def check(self, styleSheet, config):
        ruleSets = styleSheet.getRuleSets()
        if len(ruleSets) == 0:
            self.errorMsg = self.errorMsg_empty
            return False

        first = ruleSets[0]

        if styleSheet.getFile() != '' and first.comment.find('@author') == -1 and first.comment.find('@renren-inc.com') == -1:
            self.errorMsg = self.errorMsg_author
            return False
        return True 

########NEW FILE########
__FILENAME__ = FEDNoAlphaImageLoader
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDNoAlphaImageLoader(RuleChecker):
    
    '''{
        "summary":"不要使用AlphaImageLoader",
        "desc":"<code>AlphaImageLoader</code> 主要用于在IE6下显示半透明图片，此举实际上费力不讨好，
            对IE的性能影响极大，为了更好地实现网页的 <strong>渐进增强</strong> 
            ，建议不要使用 <code>AlphaImageLoader</code>"
    }'''

    def __init__(self):
        self.id = 'no-alpha-image-loader'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'should not use AlphaImageLoader in "${selector}"'

    def check(self, rule, config):
        if rule.value.find('AlphaImageLoader') != -1:
            return False
        return True 

########NEW FILE########
__FILENAME__ = FEDNoAppearanceNameInSelector
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import existsAppearanceWords

class FEDNoAppearanceNameInSelector(RuleSetChecker):
    
    '''{
        "summary":"选择器中避免表现相关的词汇",
        "desc":"避免将在selector中出现 <code>.red</code> <code>.left</code> 等描述性词汇，
            用具体的实际意义来代替，比如 <code>.error</code> <code>.sidebar</code> "
    }'''

    def __init__(self):
        self.id = 'no-appearance-word-in-selector'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_origin = 'should not use appearance word "%s" in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selector = ruleSet.selector.lower()

        if selector.find('@media') != -1:
            return True
        if selector.find('@-moz-document') != -1:
            return True

        word = existsAppearanceWords(selector)
        if word is not None:
            self.errorMsg = self.errorMsg_origin % word
            return False

        return True

########NEW FILE########
__FILENAME__ = FEDNoCommentInValues
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDNoCommentInValues(RuleSetChecker):
    
    '''{
        "summary":"不要在css属性中添加注释",
        "desc":"CSS的注释应该写在 <code>selector</code> 前面，属性中不允许添加css注释，例如：<br>
            <code>.selector {</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;width: 100px;/*comment here*/</code><br>
            <code>}</code>
        "
    }'''

    def __init__(self):
        self.id = 'no-comment-in-value'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg = 'find css comment (/* */) in "${selector}"'

    def check(self, ruleSet, config):
        if ruleSet.roughValue.find('/*') != -1 or ruleSet.roughValue.find('*/') != -1:
            return False
        return True 

########NEW FILE########
__FILENAME__ = FEDNoEmptyRuleSet
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDNoEmptyRuleSet(RuleSetChecker):
    
    '''{
        "summary":"删除空的规则",
        "desc":"空的CSS规则集是没有任何意义的，应该直接删除掉"
    }'''

    def __init__(self):
        self.id = 'no-empty-ruleset'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'empty ruleset found "${selector}"'

    def check(self, ruleSet, config):
        if len(ruleSet.getRules()) == 0:
            return False
        return True 

    def fix(self, ruleSet, config):
        if len(ruleSet.getRules()) == 0:
            styleSheet = ruleSet.getStyleSheet()
            styleSheet.removeRuleSet(ruleSet)

########NEW FILE########
__FILENAME__ = FEDNoExpression
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDNoExpression(RuleChecker):
    
    '''{
        "summary":"不要使用非一次性表达式",
        "desc":"IE下，非一次性expression对性能有很大的影响，或许一次鼠标移动，
            将触发<strong>成千上万次</strong>的expression表达式的执行，
            因此，为了浏览器的更新换代，应该杜绝使用非一次性表达式。<br>
            本工具针对一次性表达式的检查，将判断expression中是否有如下两个内容：<br>
            1. <code>Expressions</code><br>
            2. <code>this.style.attrName = </code>"
    }'''

    def __init__(self):
        self.id = 'no-expression'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_use = 'should not use expression in "${selector}" '
        self.errorMsg_hack = 'should add hack for expression in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        value = rule.value
        name = rule.name
        replaced = value.replace(' ', '')

        if value.find('expression') == -1:
            return True

        if replaced.find('Expressions') != -1 or replaced.find('this.style.' + name + '=') != -1 or replaced.find('this.runtimeStyle.' + name + '=') != -1:
            if rule.name == rule.strippedName:
                selector = rule.selector.replace(' ', '')
                if selector.find('*html') == -1:
                    self.errorMsg = self.errorMsg_hack
                    return False
            return True

        self.errorMsg = self.errorMsg_use
        return False

########NEW FILE########
__FILENAME__ = FEDNoSimpleNumberInSelector
#/usr/bin/python
#encoding=utf-8

from .Base import *
import re
pattern = re.compile('\d+')

class FEDNoSimpleNumberInSelector(RuleSetChecker):
    
    '''{
        "summary":"不要在选择器中使用简单数字",
        "desc":"在业务代码的css中，选择器中不要使用简单的 <code>1, 2, 3</code> 来进行命名，下面的命名方式就是错误的：<br>
            <code>.test1</code> <code>.main1</code>，但是允许使用 <code>v1</code> <code>step1</code> <code>item1</code> 
            来代表版本、步骤、第几个元素的意思"
    }'''

    def __init__(self):
        self.id = 'number-in-selector'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'do not simply use 1,2,3 as selector(use v1/step1/item1), in "${selector}"'

    def check(self, ruleSet, config):
        selector = ruleSet.selector

        if selector.find('@media') != -1:
            return True
            
        found = pattern.findall(selector)
        for x in found:
            if selector.find('v' + x) == -1 and selector.find('step' + x) == -1  and selector.find('item' + x) == -1 and selector.find('h' + x) == -1 :
                return False
        return True 

########NEW FILE########
__FILENAME__ = FEDNoStarInSelector
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDNoStarInSelector(RuleSetChecker):
    
    '''{
        "summary":"不要在选择器中使用星号",
        "desc":"禁止在选择器中加入<code>*</code>来选择所有元素，例如：<br>
            <br>
            <code>*html</code> <code>*+html</code> <code>*:not</code>等几种特殊hack除外"
    }'''

    def __init__(self):
        self.id = 'no-star-in-selector'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'please remove low performance selector "*" from "${selector}"'

    def check(self, ruleSet, config):
        selector = ruleSet.selector
        if selector.find('*') == -1:
            return True

        replaced = selector.replace(' ', '')
        if replaced.startswith('*html') or replaced.startswith('*+html'):
            return True

        if replaced.find('*:not') != -1:
            return True

        # give it to FEDHighPerformanceSelector.py
        if replaced.find('*=') != -1 and len(replaced.split('*')) == 2:
            return True

        return False

########NEW FILE########
__FILENAME__ = FEDNoUnitAfterZero
#/usr/bin/python
#encoding=utf-8

from .Base import *
import re

pattern_unit = re.compile(r'(0\s*[\w]+)')
replacer_unit = re.compile(',\s+')

class FEDNoUnitAfterZero(RuleChecker):
    
    '''{
        "summary":"删除0后面的单位",
        "desc":"0后面的单位可以删除，以实现更好的压缩。比如 <code>0px ==> 0</code> ，<code>0em ==> 0</code> 等，
            但是<code>transition: 0s</code>的<code>s</code>不能省略"
    }'''

    def __init__(self):
        self.id = 'del-unit-after-zero'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'unit should be removed when meet 0 in "${selector}"'

    def check(self, rule, config):

        values = rule.value.split(' ')

        for v in values:
            v = v.strip()
            if v.find('(') != -1:
                matched = self._startsWithZero(v.split('(')[1])
            else:
                matched = self._startsWithZero(v)

            if matched is None:
                continue

            for m in matched:
                if m != '0s':
                    return False

        return True 

    def fix(self, rule, config):
        if rule.name == 'expression':
            return

        fixed = rule.fixedValue
        rule.fixedValue = rule.fixedValue.replace(',', ', ')

        collector = []
        for v in rule.fixedValue.split(' '):
            v = v.strip()
            if v.find('(') != -1:
                matched = self._startsWithZero(v.split('(')[1])
            else:
                matched = self._startsWithZero(v)

            if matched is None:
                collector.append(v)
                continue

            finalV = v;
            for m in matched:
                if m != '0s':
                    finalV = finalV.replace(m, '0')
            collector.append(finalV)

        rule.fixedValue = replacer_unit.sub(', ', ' '.join(collector))

    def _startsWithZero(self, value):
        matcher = pattern_unit.match(value)
        if matcher is not None:
            return matcher.groups()
        return None

########NEW FILE########
__FILENAME__ = FEDNoZeroBeforeDot
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDNoZeroBeforeDot(RuleChecker):
    
    '''{
        "summary":"删除0.x前面的0",
        "desc":" 0.xxx 前面的 0 是可以删除的，以实现更好的压缩。例如<br>
            <code>0.3px ==> .3px</code><br><br>
            <code>rgba(0,0,0,0.3)<code><br>
            <code>==></code><br>
            <code>rgba(0,0,0,.3)</code>"
    }'''

    def __init__(self):
        self.id = 'no-zero-before-dot'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'zero should be removed when meet 0.xxx in "${selector}"'

    def check(self, rule, config):
        value = rule.value

        if self._startsWithZeroDot(value):
            return False

        values = rule.value.split(' ')
        for v in values:
            if self._startsWithZeroDot(v.strip()):
                return False

        return True 

    def fix(self, rule, config):
        fixedValue = rule.fixedValue
        for v in fixedValue.split(' '):
            if self._startsWithZeroDot(v):
                rule.fixedValue = rule.fixedValue.replace(v, v[1:])

    def _startsWithZeroDot(self, value):
        return value.startswith('0.')

########NEW FILE########
__FILENAME__ = FEDRemoveDuplicatedAttr
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDRemoveDuplicatedAttr(RuleSetChecker):
    
    '''{
        "summary":"删除重复的属性设置",
        "desc":"如果在一个规则集中，对相同的两个属性进行了赋值，而且取值相同，则可以删除前面的赋值，例如：
            <br>
            <code>.test {</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;width: 100px;</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;width: 100px;</code><br>
            <code>}</code><br>
            <code>==></code><br>
            <code>.test {</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;width: 100px;</code><br>
            <code>}</code>"
    }'''

    def __init__(self):
        self.id = 'remove-duplicated-attr'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'has more than 1 ${name} in "${selector}"'

    def check(self, ruleSet, config):
        rules = ruleSet.getRules()
        collector = []
        for rule in rules:
            info = self.ruleInfo(rule)
            if info in collector:
                return False
            collector.append(info)
        return True

    def fix(self, ruleSet, config):
        # make sure we use the last statement, so reverse and filter and reverse again
        # [a1, a2, b, c] ==> [c, b, a2, a1] ==> [c, b, a2] ==> [a2, b, c]
        rules = ruleSet.getRules()
        rules.reverse()
        newRules = []
        collector = []
        for rule in rules:
            info = self.ruleInfo(rule)
            if not info in collector:
                collector.append(info)
                newRules.append(rule)
        newRules.reverse()
        ruleSet.setRules(newRules)

    def ruleInfo(self, rule):
        if rule.fixedName != '':
            return rule.fixedName + ':' + rule.fixedValue
        return rule.strippedName + ':' + rule.strippedValue

########NEW FILE########
__FILENAME__ = FEDReplaceBorderZeroWithBorderNone
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDReplaceBorderZeroWithBorderNone(RuleChecker):
    
    '''{
        "summary":"用border:none替换border:0",
        "desc":"<code>border:0</code> 实际上是有border的，只不过宽度为0， 而 <code>border:none;</code> 
            是根本没有border的，对于浏览器来说后者的效率高，但是要注意，后者的代码长度稍微长一些。"
    }'''

    def __init__(self):
        self.id = 'no-border-zero'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_borderWidth = 'replace "border-width: 0" with "border-width: none" in "${selector}"'
        self.errorMsg_border = 'replace "border: 0" with "border: none" in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        if rule.name == 'border' and rule.value == '0':
            self.errorMsg = self.errorMsg_border
            return False

        if rule.name == 'border-width' and rule.value == '0':
            self.errorMsg = self.errorMsg_borderWidth
            return False

        return True

########NEW FILE########
__FILENAME__ = FEDSelectorNoUnderLine
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDSelectorNoUnderLine(RuleSetChecker):
    
    '''{
        "summary":"不要在选择器中使用下划线",
        "desc":"在selector中不要使用下划线 <code>_</code> ，可以使用中划线 <code>-</code>"
    }'''

    def __init__(self):
        self.id = 'no-underline-in-selector'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'should not use _ in selector "${selector}"'

    def check(self, ruleSet, config):
        selector = ruleSet.selector
        if selector.find('_') != -1:
            return False
        return True 

########NEW FILE########
__FILENAME__ = FEDSemicolonAfterValue
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDSemicolonAfterValue(RuleChecker):
    
    '''{
        "summary":"为每一个属性后添加分号",
        "desc":"按照CSS编码规范，每一个规则后面都必须加上分号 <code>;</code>"
    }'''

    def __init__(self):
        self.id = 'add-semicolon'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'each rule in "${selector}" need semicolon in the end, "${name}" has not'

    def check(self, rule, config):
        if not rule.roughValue.strip().endswith(';'):
            return False
        return True 

########NEW FILE########
__FILENAME__ = FEDShouldNotUseImportant
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDShouldNotUseImportant(RuleChecker):
    
    '''{
        "summary":"不要使用!important",
        "desc":"CSS中不要使用<code>!important</code>"
    }'''

    def __init__(self):
        self.id = 'do-not-use-important'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'Should not use !important in "${name}" of "${selector}"'

    def check(self, rule, config):
        value = rule.value
        if value.replace(' ', '').find('!important') != -1:
            return False
        return True 

########NEW FILE########
__FILENAME__ = FEDSingleLineBraces
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDSingleLineBraces(RuleSetChecker):
    
    '''{
        "summary":"单行的括号检查",
        "desc":"与单行CSS编码风格相关的括号检查"
    }'''

    def __init__(self):
        self.id = 'single-line-brace'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_openingBrace = 'should have "only one space" before the opening brace in "${selector}"'
        self.errorMsg_openingBraceEnd = 'should have "only one space" after the opening brace in "${selector}"'
        self.errorMsg_closingBrace = 'should have "only one space" before the closing brace in "${selector}"'
        self.errorMsg_closingBraceEnd = 'should have "only one space" before the closing brace in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        singleLine = ruleSet.getSingleLineFlag()
        if not singleLine:
            return True
        selector = ruleSet.roughSelector
        if selector.find(',') == -1:
            if selector.endswith('  ') or not selector.endswith(' '):
                self.errorMsg = self.errorMsg_openingBrace
                return False
        else:
            return True

        value = ruleSet.roughValue
        if not value.startswith(' ') or value.startswith('  '):
            self.errorMsg = self.errorMsg_openingBraceEnd
            return False
        if not value.endswith(' ') or value.endswith('  '):
            self.errorMsg = self.errorMsg_closingBraceEnd
            return False
        return True 

########NEW FILE########
__FILENAME__ = FEDSingleLineSelector
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDSingleLineSelector(RuleSetChecker):
    
    '''{
        "summary":"单行的选择器检查",
        "desc":"单行的选择器检查内容，请参考多行选择器检查和人人FED CSS编码规范"
    }'''

    def __init__(self):
        self.id = 'single-line-selector'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_noEnterInSingleSelector = 'should not "enter" at the end of "${selector}"'
        self.errorMsg_multiSelectorBeforeSemicolon = 'should not have "space" after semicolon in "${selector}"'
        self.errorMsg_shouldNotStartsWithSpace = 'should start with "space" in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selector = ruleSet.roughSelector
        if selector.find(',') != -1:
            return True

        if selector.lstrip().find('\n') != -1:
            self.errorMsg = self.errorMsg_noEnterInSingleSelector
            return False

        splited = selector.split('\n')
        realSelector = splited[len(splited) - 1]
        
        if realSelector.startswith(' '):
            self.errorMsg = self.errorMsg_shouldNotStartsWithSpace
            return False

        return True 

########NEW FILE########
__FILENAME__ = FEDSingleLineSpaces
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDSingleLineSpaces(RuleChecker):
    
    '''{
        "summary":"单行的空格检查",
        "desc":"单行CSS编码风格相关的空格检查，具体内容请参见CSS编码规范"
    }'''

    def __init__(self):
        self.id = 'single-line-space'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_noSpace = 'should have one "space" before "${name}" in "${selector}"'
        self.errorMsg_spaceEnd = 'should not have "space" after "${name}" in "${selector}"'
        self.errorMsg_noSpaceBeforeValue = 'should have one "space" before value of "${name}" in "${selector}"'
        self.errorMsg_extraSpaceAfterValue = 'found extra "space" after value of "${name}" in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        singleLine = rule.getRuleSet().getSingleLineFlag()
        if not singleLine:
            return True

        if not rule.roughName.startswith(' '):
            self.errorMsg = self.errorMsg_noSpace
            return False

        if rule.roughName.endswith(' '):
            self.errorMsg = self.errorMsg_spaceEnd
            return False
        
        if not rule.roughValue.startswith(' '):
            self.errorMsg = self.errorMsg_noSpaceBeforeValue
            return False

        value = rule.roughValue.strip()
        if value.endswith(' ;') or value.endswith(' '):
            self.errorMsg = self.errorMsg_extraSpaceAfterValue
            return False

        return True 

########NEW FILE########
__FILENAME__ = FEDStyleShouldInOrder
#/usr/bin/python
#encoding=utf-8

from .helper import getAttrOrder
from .Base import *

class FEDStyleShouldInOrder(RuleSetChecker):
    
    '''{
        "summary":"属性应该按照推荐的顺序编写",
        "desc":"相同的CSS属性，如果按照推荐的顺序来编写，浏览器的处理性能会更高，推荐的顺序一般为：<br>
            显示属性 => 盒模型属性 => 背景/行高 => 文本属性 => 其他"
    }'''

    def __init__(self):
        self.id = 'keep-in-order'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_rough = '"%s" should after "%s" in "${selector}" (order: display/box/text/other/css3)'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        rules = ruleSet.getRules()
        if len(rules) < 2:
            return True

        order = self._generateNameOrderMapping(rules)
        length = len(order)
        for i in range(length):
            if i == length - 1:
                break;
            current = order[i]
            nextAttr = order[i + 1]

            if current[0] > nextAttr[0]:
                self.errorMsg = self.errorMsg_rough % (current[1], nextAttr[1])
                return False

        return True 

    def fix(self, ruleSet, config):
        rules = ruleSet.getRules()
        if len(rules) < 2:
            return True

        def comp(a, b):
            return a[0] - b[0]

        mapping = self._generateNameRuleMapping(rules)
        mapping.sort(comp)
        sortedRules = []
        for x in range(len(mapping)):
            sortedRules.append(mapping[x][1])
        ruleSet.setRules(sortedRules)

    def _generateNameOrderMapping(self, rules):
        return [(getAttrOrder(rule.name, rule.strippedName), rule.strippedName) for rule in rules]

    def _generateNameRuleMapping(self, rules):
        return [(getAttrOrder(rule.name, rule.strippedName), rule) for rule in rules]

########NEW FILE########
__FILENAME__ = FEDTransChnFontFamilyNameIntoEng
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import containsChnChar

class FEDTransChnFontFamilyNameIntoEng(RuleChecker):
    
    '''{
        "summary":"字体设置时使用英文",
        "desc":"有的字体设置可以通过中文和英文两者方式来声明，比如<br>
            <code>微软雅黑</code> 和 <code>Microsoft Yahei</code> ，我们推荐用英文的方式来实现"
    }'''

    def __init__(self):
        self.id = 'no-chn-font-family'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'should not use chinese font family name in "${selector}"'

    def check(self, rule, config):
        if rule.name != 'font' and rule.name != 'font-family':
            return True

        if containsChnChar(rule.value):
            return False

        return True 

########NEW FILE########
__FILENAME__ = FEDUnknownCssNameChecker
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import isCssProp

class FEDUnknownCssNameChecker(RuleChecker):
    
    '''{
        "summary":"错误的css属性",
        "desc":"本工具会帮您查找错误的CSS属性，如果写错了，即可收到错误提示"
    }'''

    def __init__(self):
        self.id = 'unknown-css-prop'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'unknown attribute name "${name}" found in "${selector}"'

    def check(self, rule, config):
        return isCssProp(rule.name.lower())

########NEW FILE########
__FILENAME__ = FEDUnknownHTMLTagName
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .helper import isHTMLTag

class FEDUnknownHTMLTagName(RuleSetChecker):
    
    '''{
        "summary":"错误的HTML Tag",
        "desc":"如果您输入了错误的HTML Tag，本工具也会给出响应的提示"
    }'''

    def __init__(self):
        self.id = 'unknown-html-tag'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_rough = 'unknown html tag "%s" found in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selector = ruleSet.selector.lower()
        if selector.find('@media') != -1:
            return True
        if selector.find('@-moz-document') != -1:
            return True
        selectors = selector.split(',')
        for s in selectors:
            for r in s.split(' '):
                r = r.strip()
                if r != '':
                    if r.find('::') != -1:
                        # p::selection
                        tag = r.split('::')[0].split('.')[0].split('#')[0].strip()
                    else:
                        # abcd:hover
                        # abcd.class-name:hover
                        # abcd#class-name:hover
                        tag = r.split(':')[0].split('.')[0].split('#')[0].strip()

                    # .test > .inner
                    if tag == '' or tag == '>' or tag == '*' or tag == '+':
                        continue

                    # #id
                    if tag.find('#') != -1:
                        continue

                    # input[type=button]
                    if tag.find('[') != -1:
                        tag = tag.split('[')[0].strip()

                    # *+html
                    if tag.startswith('*+'):
                        tag = tag[2:]

                    # *html
                    elif tag.startswith('*'):
                        tag = tag[1:]

                    if not isHTMLTag(tag):
                        self.errorMsg = self.errorMsg_rough % tag
                        return False
        return True 

########NEW FILE########
__FILENAME__ = FEDUseLowerCaseProp
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDUseLowerCaseProp(RuleChecker):
    
    '''{
        "summary":"属性名称应该用小写",
        "desc":"所有的CSS属性名称一律小写，例如 <code>width</code> ，大写的方式是不正确的，
            例如： <code>WIDTH:100px;</code>"
    }'''

    def __init__(self):
        self.id = 'lowercase-prop'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_name = '"${name}" should use lower case, in "${selector}"'
        self.errorMsg_value = 'value of "${name}" should use lower case, in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        value = rule.value
        name = rule.strippedName

        # give it to FED16ColorShouldUpper.py
        if name == 'color':
            return True

        if value.find('expression') != -1:
            return True

        if name.lower() != name:
            self.errorMsg = self.errorMsg_name
            return False

        if value.find('#') != -1:
            return True

        if name != 'font' and name != 'font-family' and value != value.lower() and value.find('#') == -1:
            self.errorMsg = self.errorMsg_value
            return False

        if name == 'font-family':
            return True

        if name == 'font':
            if value.find(',') != -1:
                # font: italic bold 12px/30px 'Courier New', Georgia, serif;
                other = ' '.join(value.split(',')[0].split("'")[0].split(' ')[0:-1])
                if other != other.lower():
                    self.errorMsg = self.errorMsg_value
                    return False
            return True

        if value.lower() != value:
            self.errorMsg = self.errorMsg_value
            return False

        return True 

########NEW FILE########
__FILENAME__ = FEDUseLowerCaseSelector
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDUseLowerCaseSelector(RuleSetChecker):
    
    '''{
        "summary":"选择器用小写字母",
        "desc":"选择器应该用小写字母， 例如 <code>.demo</code> ， 不允许使用大写，例如： <code>.Demo .Test</code>"
    }'''

    def __init__(self):
        self.id = 'lowercase-selector'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'selector should use lower case, in "${selector}"'

    def check(self, ruleSet, config):
        selector = ruleSet.selector
        if selector.lower() != selector:
            return False

        return True 

    def fix(self, ruleSet, config):
        # if fix upper to lower, will cause error in HTML(do not do evil)
        pass
        #selector = ruleSet.selector
        #if selector.lower() != selector:
        #    ruleSet.fixedSelector = ruleSet.fixedSelector.lower()

########NEW FILE########
__FILENAME__ = FEDUseSingleQuotation
#/usr/bin/python
#encoding=utf-8

from .Base import *

class FEDUseSingleQuotation(RuleChecker):
    
    '''{
        "summary":"使用单引号",
        "desc":"CSS的属性取值一律使用单引号<code>'</code>， 不允许使用双引号"
    }'''

    def __init__(self):
        self.id = 'single-quotation'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'replace " with \' in "${selector}"'

    def check(self, rule, config):
        if self._findDouble(rule.value):
            return False

        return True

    def fix(self, rule, config):
        if self._findDouble(rule.value):
            rule.fixedValue = rule.value.replace('"', "'")

    def _findDouble(self, value):
        return value.find('"') != -1

########NEW FILE########
__FILENAME__ = FEDUseValidValues
#/usr/bin/python
#encoding=utf-8

from .Base import *
from .validators.ValidatorFactory import doValidate

class FEDUseValidValues(RuleChecker):
    
    '''{
        "summary":"不正确的属性取值",
        "desc":"检查不正确的属性取值，比如： <code>width: underline;</code> 等"
    }'''

    def __init__(self):
        self.id = 'valid-values'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_rough = '%s in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        flag, msg = doValidate(rule.name, rule.strippedValue)
        if flag is True:
            return True

        self.errorMsg = self.errorMsg_rough % msg
        return False

    def fix(self, rule, config):
        pass

########NEW FILE########
__FILENAME__ = FEDZIndexShouldInRange
#/usr/bin/python
#encoding=utf-8

from .Base import *
import string
from .helper import isCss3PrefixProp

class FEDZIndexShouldInRange(RuleChecker):
    
    '''{
        "summary":"z-index取值应符合范围要求",
        "desc":"<code>z-index</code> 的取值如果混乱，则会造成层之间的相互覆盖，
            因此 <code>z-index</code> 取值必须符合一定的范围要求，具体要求请参见人人FED CSS编码规范"
    }'''

    def __init__(self):
        self.id = 'z-index-in-range'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'value of "z-index" is not correct in "${selector}"'

    def check(self, rule, config):
        if rule.name != 'z-index':
            return True

        zIndex = None
        try:
            zIndex = string.atoi(rule.value)
        except ValueError:
            return False

        if zIndex < -1:
            return False

        if zIndex > 2100:
            return False

        return True 

########NEW FILE########
__FILENAME__ = helper
import re

pattern = re.compile(r'[@\*\[\]\(\):>]')

def hasHackChars(text):
    return len(pattern.findall(text)) != 0

def containsHack(rule):
    return rule.value.find('\\0') != -1 or rule.value.find('\\9') != -1

def getAttrOrder(attr, strippedName):
    if cssAttrOrders.has_key(attr):
        return cssAttrOrders[attr] + addCss3PrefixValue(strippedName)
    if attr.find('-') != -1:
        splited = attr.split('-')
        tmp = splited[0] + '-' + splited[len(splited) - 1]
        if cssAttrOrders.has_key(tmp):
            return cssAttrOrders[tmp] + addCss3PrefixValue(strippedName)
        while len(splited) != 0:
            splited = splited[0:-1]
            tmp = '-'.join(splited)
            if cssAttrOrders.has_key(tmp):
                return cssAttrOrders[tmp] + addCss3PrefixValue(strippedName)
    return 6000 + addCss3PrefixValue(strippedName)

def addCss3PrefixValue(attr):
    value = 0
    if attr.startswith('-webkit'):
        value = value - 5
    elif attr.startswith('-khtml'):
        value = value - 4
    elif attr.startswith('-moz'):
        value = value - 3
    elif attr.startswith('-ms'):
        value = value - 2
    elif attr.startswith('-o'):
        value = value - 1
    return value

def isHTMLTag(tag):
    return containsInArray(validHTMLTags, tag)

def isCssProp(prop):
    return containsInArray(validCSSAttrs, prop)

def isCss3Prop(prop):
    return containsInArray(allCss3Props, prop)

def canBeCombined(prop):
    prop = prop.strip()
    for x in canBeCombinedProps:
        if prop.startswith(x):
            return x
    return None

def containsChnChar(string):
    try: 
        trans = unicode(string, 'gb2312')
        return len(string) != len(trans)
    except UnicodeDecodeError:
        return True

def isCss3PrefixProp(prop):
    return containsInArray(prefixCss3Props, prop)

def isFontFamilyName(prop):
    prop = prop.lower()
    added = "," + prop + ","
    return containsInArray(fontFamilyNames, prop) or containsInArray(fontFamilyNames, added)

wordsPattern = re.compile('\w+')
def existsAppearanceWords(selector):
    selector = selector.lower()
    words = wordsPattern.findall(selector)
    for w in words:
        if w in appearanceWords:
            return w
    return None

def isSimpleSelector(selector):
    for s in simpleSelectors:
        if s == selector:
            return True
    return False

def containsInArray(array, value):
    return value in array

maybeDoNotNeedPrefix = 'border-radius'.split(' ')

def doNotNeedPrefixNow(attr):
    attr = attr.strip()
    if attr.startswith('border') and attr.endswith('radius'):
        return True

    for x in maybeDoNotNeedPrefix:
        if attr.find(x) != -1:
            return True

    return False

# from https://github.com/stubbornella/csslint/wiki/Require-compatible-vendor-prefixes
prefixCss3Props = 'animation animation-delay animation-direction animation-duration animation-fill-mode animation-iteration-count animation-name animation-play-state animation-timing-function appearance border-end border-end-color border-end-style border-end-width border-image border-radius border-start border-start-color border-start-style border-start-width box-align box-direction box-flex box-lines box-ordinal-group box-orient box-pack box-sizing box-shadow column-count column-gap column-rule column-rule-color column-rule-style column-rule-width column-width hyphens line-break margin-end margin-start marquee-speed marquee-style padding-end padding-start tab-size text-size-adjust transform transform-origin transition transition-delay transition-duration transition-property transition-timing-function user-modify user-select background-size writing-mode'.split(' ')

# according to http://fed.renren.com/archives/1212
cssAttrOrdersMap = {
    0 : ['display', 'position', 'left', 'top', 'bottom', 'right', 'float', 'list-style', 'clear'],
    200 : ['width', 'height', 'margin', 'padding', 'border'],
    400 : ['background'],
    600 : ['line-height'],
    800 : ['color', 'font', 'text-decoration', 'text-align', 'text-indent', 'vertical-align', 'white-space', 'content'],
    1000: ['cursor', 'z-index', 'zoom'],
    1200: prefixCss3Props
    # 1400 : ['other']
}

# convert 0:a, b to a:0, b:0
cssAttrOrders = {}
for key, value in cssAttrOrdersMap.items():
    counter = 0
    for x in value:
        cssAttrOrders[x] = key + counter
        counter = counter + 6


canBeCombinedProps = 'border margin padding background font'.split(' ')

# execute in http://www.w3schools.com/cssref/css_websafe_fonts.asp
#
# var tables = document.getElementsByClassName('reference');
# var values = [];
# for (var i = 0;  i < tables.length; i++) {
#     trs = tables[i].getElementsByTagName('tr')
#     for(var j = 0; j < trs.length; j++) {
#         td = trs[j].getElementsByTagName('td')[0];
#         if (td) {
#             var text = td.textContent.toLowerCase().trim()
#             var spliteds = text.split(',');
#             for (var k = 0; k < spliteds.length; k++) {
#                 values.push(spliteds[k].trim().replace('"', "'").replace('"', "'"))
#             }
#         }
#     }
# }
# values = values.slice(2);
# console.log(values.sort().join(','));

fontFamilyNames = ("'arial black','book antiqua','comic sans ms','courier new','lucida console','lucida grande','lucida sans unicode','palatino linotype','times new roman','trebuchet ms',arial,charcoal,courier,cursive,gadget,geneva,geneva,helvetica,helvetica,impact,monaco,monospace,monospace,palatino,sans-serif,sans-serif,sans-serif,sans-serif,sans-serif,sans-serif,sans-serif,sans-serif,serif,serif,tahoma,times,verdana" + ",georgia").split(',')

# add slowly and progressively
simpleSelectors = '.nav .sub #main #main2 #sidebar #sidebar2 .header .footer .publisher .box .login .site-nav .side'.split(' ')

# execute in http://www.w3schools.com/cssref/css_colornames.asp
#
#var tables = document.getElementsByClassName('reference');
#var values = [];
#for (var i = 0;  i < tables.length; i++) {
#    trs = tables[i].getElementsByTagName('tr')
#    for(var j = 0; j < trs.length; j++) {
#        td = trs[j].getElementsByTagName('td')[0];
#        if (td) {
#            var text = td.textContent.toLowerCase().trim()
#            if (text == 'h1') text = 'h1 h2 h3 h4 h5 h6';
#            values.push(text)
#        }
#    }
#}
#values = values.slice(2);
#console.log(values.join(' '));

appearanceWords = ("left right top bottom float" + " aqua aquamarine azure beige bisque black blanchedalmond blue blueviolet brown burlywood cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan darkblue darkcyan darkgoldenrod darkgray darkgrey darkgreen darkkhaki darkmagenta darkolivegreen darkorange darkorchid darkred darksalmon darkseagreen darkslateblue darkslategray darkslategrey darkturquoise darkviolet deeppink deepskyblue dimgray dimgrey dodgerblue firebrick floralwhite forestgreen fuchsia gainsboro ghostwhite goldenrod gray grey green greenyellow honeydew hotpink indianred indigo ivory khaki lavender lavenderblush lawngreen lemonchiffon lightblue lightcoral lightcyan lightgoldenrodyellow lightgray lightgrey lightgreen lightpink lightsalmon lightseagreen lightskyblue lightslategray lightslategrey lightsteelblue lightyellow lime limegreen linen magenta maroon mediumaquamarine mediumblue mediumorchid mediumpurple mediumseagreen mediumslateblue mediumspringgreen mediumturquoise mediumvioletred midnightblue mintcream mistyrose moccasin navajowhite navy oldlace olive olivedrab orange orangered orchid palegoldenrod palegreen paleturquoise palevioletred papayawhip peachpuff peru pink plum powderblue purple red rosybrown royalblue saddlebrown salmon sandybrown seagreen seashell sienna silver skyblue slateblue slategray slategrey snow springgreen steelblue thistle tomato turquoise violet wheat white whitesmoke yellow yellowgreen").split(' ')
# execute on http://www.w3schools.com/cssref/default.asp
#
# var tables = document.getElementsByClassName('reference');
# var values = [];
# for (var i = 0;  i < tables.length; i++) {
#     trs = tables[i].getElementsByTagName('tr')
#     for(var j = 0; j < trs.length; j++) {
#         td = trs[j].getElementsByTagName('td')[0];
#         if (td && trs[j].getElementsByTagName('td')[2].textContent == '3') {
#             var text = td.textContent
#             if (text == 'h1') text = 'h1 h2 h3 h4 h5 h6';
#             values.push(text)
#         }
#     }
# }
# values = values.slice(2);
# console.log(values.join(' '));
#
allCss3Props = 'animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-play-state background-clip background-origin background-size border-bottom-left-radius border-bottom-right-radius border-image border-image-outset border-image-repeat border-image-slice border-image-source border-image-width border-radius border-top-left-radius border-top-right-radius box-decoration-break box-shadow overflow-x overflow-y overflow-style rotation rotation-point color-profile opacity rendering-intent bookmark-label bookmark-level bookmark-target float-offset hyphenate-after hyphenate-before hyphenate-character hyphenate-lines hyphenate-resource hyphens image-resolution marks string-set box-align box-direction box-flex box-flex-group box-lines box-ordinal-group box-orient box-pack @font-face font-size-adjust font-stretch crop move-to page-policy grid-columns grid-rows target target-name target-new target-position alignment-adjust alignment-baseline baseline-shift dominant-baseline drop-initial-after-adjust drop-initial-after-align drop-initial-before-adjust drop-initial-before-align drop-initial-size inline-box-align line-stacking line-stacking-ruby line-stacking-shift line-stacking-strategy text-height marquee-direction marquee-play-count marquee-speed marquee-style column-count column-fill column-gap column-rule column-rule-color column-rule-style column-rule-width column-span column-width columns fit fit-position image-orientation page size ruby-align ruby-overhang ruby-position ruby-span mark mark-after mark-before phonemes rest rest-after rest-before voice-balance voice-duration voice-pitch voice-pitch-range voice-rate voice-stress voice-volume hanging-punctuation punctuation-trim text-align-last text-justify text-outline text-overflow text-shadow text-wrap word-break word-wrap transform transform-origin transform-style perspective perspective-origin backface-visibility transition transition-property transition-duration transition-timing-function transition-delay appearance box-sizing icon nav-down nav-index nav-left nav-right nav-up outline-offset user-select resize animation animation-fill-mode border-end border-end-color border-end-style border-end-width border-start border-start-color border-start-style border-start-width line-break margin-end margin-start padding-end padding-start tab-size text-size-adjust user-modify writing-mode'.split(' ')

# execute on http://www.w3schools.com/tags/default.asp
#
# var tables = document.getElementsByClassName('reference');
# var values = [];
# for (var i = 0;  i < tables.length; i++) {
#     trs = tables[i].getElementsByTagName('tr')
#     for(var j = 0; j < trs.length; j++) {
#         td = trs[j].getElementsByTagName('td')[0];
#         if (td) {
#             var text = td.textContent.split('>')[0].split('<')[1]
#             if (text == 'h1') text = 'h1 h2 h3 h4 h5 h6';
#             values.push(text)
#         }
#     }
# }
# values = values.slice(2);
# console.log(values.join(' '));

validHTMLTags = 'a abbr acronym address applet area article aside audio b base basefont bdi bdo big blockquote body br button canvas caption center cite code col colgroup command datalist dd del details dfn dir div dl dt em embed fieldset figcaption figure font footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins kbd keygen label legend li link map mark menu meta meter nav noframes noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strike strong style sub summary sup table tbody td textarea tfoot th thead time title tr track tt u ul var video wbr'.split(' ')


# execute on http://www.w3schools.com/cssref/default.asp
#var tables = document.getElementsByClassName('reference');
#var values = [];
#for (var i = 0;  i < tables.length; i++) {
#    trs = tables[i].getElementsByTagName('tr')
#    for(var j = 0; j < trs.length; j++) {
#        td = trs[j].getElementsByTagName('td')[0];
#        if (td) {
#            values.push(td.textContent)
#        }
#    }
#}
#console.log(values.join(' '));

validCSSAttrs = ('@keyframes animation animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-play-state ' + 
    'background background-attachment background-color background-image background-position background-repeat background-clip background-origin background-size background-inline-policy border border-bottom border-bottom-color border-bottom-style border-bottom-width border-color border-left border-left-color border-left-style border-left-width border-right border-right-color border-right-style border-right-width border-style border-top border-top-color border-top-style border-top-width border-width outline outline-color outline-style outline-width ' + 
    'border-bottom-left-radius border-bottom-right-radius border-image border-image-outset border-image-repeat border-image-slice border-image-source border-image-width border-radius border-top-left-radius border-top-right-radius box-decoration-break box-shadow overflow-x overflow-y overflow-style rotation rotation-point color-profile opacity rendering-intent bookmark-label bookmark-level bookmark-target float-offset ' + 
    'hyphenate-after hyphenate-before hyphenate-character hyphenate-lines hyphenate-resource hyphens image-resolution marks string-set height max-height max-width min-height min-width width box-align box-direction box-flex box-flex-group box-lines box-ordinal-group box-orient box-pack font font-family font-size font-style font-variant font-weight @font-face font-size-adjust font-stretch content counter-increment counter-reset quotes ' + 
    'crop move-to page-policy grid-columns grid-rows target target-name target-new target-position alignment-adjust alignment-baseline baseline-shift dominant-baseline drop-initial-after-adjust drop-initial-after-align drop-initial-before-adjust drop-initial-before-align drop-initial-size drop-initial-value inline-box-align line-stacking line-stacking-ruby line-stacking-shift line-stacking-strategy text-height list-style list-style-image ' + 
    'list-style-position list-style-type margin margin-bottom margin-left margin-right margin-top marquee-direction marquee-play-count marquee-speed marquee-style column-count column-fill column-gap column-rule column-rule-color column-rule-style column-rule-width column-span column-width columns padding padding-bottom padding-left padding-right padding-top fit fit-position image-orientation page size bottom clear clip cursor display ' + 
    'float left overflow position right top visibility z-index orphans page-break-after page-break-before page-break-inside widows ruby-align ruby-overhang ruby-position ruby-span mark mark-after mark-before phonemes rest rest-after rest-before voice-balance voice-duration voice-pitch voice-pitch-range voice-rate ' + 
    'voice-stress voice-volume border-collapse border-spacing caption-side empty-cells table-layout color direction letter-spacing line-height text-align text-decoration text-indent text-transform unicode-bidi vertical-align white-space word-spacing hanging-punctuation punctuation-trim text-align-last text-justify ' + 
    'text-outline text-overflow text-shadow text-wrap word-break word-wrap transform transform-origin transform-style perspective perspective-origin backface-visibility transition transition-property transition-duration transition-timing-function transition-delay appearance box-sizing icon nav-down nav-index nav-left ' + 
    'nav-right nav-up outline-offset resize expression filter zoom behavior').split(' ')


########NEW FILE########
__FILENAME__ = MarginValidator
class MarginValidator():
    def __init__(self, name, value):
        self.name = name
        self.value = value

    def validate(self):
        realValues = [x for x in self.value.split(' ') if x != '']
        if len(realValues) > 4:
            return False, 'value of margin is too much(items > 4)'
        return True, ''

########NEW FILE########
__FILENAME__ = ValidatorFactory
from ckstyle.cmdconsole.ConsoleClass import console

def doValidate(name, value):
    pluginName = camelCase(name) + 'Validator'
    pluginClass = NullValidator
    try:
        plugin = __import__('ckstyle.plugins.validators.' + pluginName, fromlist = [pluginName])
        #plugin = __import__(pluginName, fromlist = [pluginName])
        if hasattr(plugin, pluginName):
            pluginClass = getattr(plugin, pluginName)
        else:
            console.error('%s should exist in %s.py' % (pluginName, pluginName))
    except ImportError as e:
        pass
    instance = pluginClass(name, value)
    return instance.validate()

class NullValidator():
    def __init__(self, name, value):
        pass
    def validate(self):
        return True, None

def camelCase(name):
    splited = name.split('-')

    collector = []
    for x in splited:
        collector.append(x.capitalize())
    return ''.join(collector)

if __name__ == '__main__':
    print(doValidate('margin', '10 10      10 10'))

########NEW FILE########
__FILENAME__ = helper

def fill(obj):
	def fillRuleSet( obj):
	    errorMsg = obj["errorMsg"]
	    if errorMsg.find('${selector}') == -1:
	        errorMsg = errorMsg + ' (from "' + obj["selector"] + '")'
	    else:
	        errorMsg = errorMsg.replace('${selector}', obj["selector"])
	    return errorMsg

	def fillStyleSheet( obj):
	    errorMsg = obj["errorMsg"]
	    if errorMsg.find('${file}') == -1:
	        errorMsg = errorMsg + ' (from "' + obj["file"] + '")'
	    else:
	        errorMsg = errorMsg.replace('${file}', obj["file"])
	    return errorMsg

	def fillRule(obj):
	    errorMsg = obj["errorMsg"]
	    if errorMsg.find('${selector}') == -1:
	        errorMsg = errorMsg + ' (from "' + obj["selector"] + '")'
	    else:
	        errorMsg = errorMsg.replace('${selector}', obj["selector"])
	    errorMsg = errorMsg.replace('${name}', obj["name"])
	    errorMsg = errorMsg.replace('${value}', obj["value"])
	    return errorMsg

	level = obj["level"]
	if level == 'rule':
	    return fillRule(obj)
	elif level == 'ruleset':
	    return fillRuleSet(obj)
	elif level == 'stylesheet':
	    return fillStyleSheet(obj)
	return obj["errorMsg"]
########NEW FILE########
__FILENAME__ = JsonReporter
from .Reporter import Reporter
from .helper import fill
import json

class JsonReporter(Reporter):
    def __init__(self, checker):
        self.checker = checker
        self.msg = ''
        pass

    def doReport(self):
        checker = self.checker
        counter = 0
        formatter = '%s'

        logs, warns, errors = checker.errors()
        if len(logs) == 0 and len(warns) == 0 and len(errors) == 0:
            self.setMsg('{}')
            return
        for error in errors:
            error["errorMsg"] = fill(error)
        for warn in warns:
            warn["errorMsg"] = fill(warn)
        for log in logs:
            log["errorMsg"] = fill(log)
            
        self.setMsg('{"errors":%s,"warnings":%s,"logs":%s}' % (json.dumps(errors), json.dumps(warns), json.dumps(logs)))

    def export(self):
        return self.msg

    def setMsg(self, msg):
        self.msg = msg
########NEW FILE########
__FILENAME__ = Reporter
class Reporter():
    def __init__(self, checker):
        pass
    def doReport(self):
        pass
    def appendMsg(self):
        pass
    def export(self):
        pass

########NEW FILE########
__FILENAME__ = ReporterUtil
from .TextReporter import TextReporter
from .JsonReporter import JsonReporter
from .XMLReporter import XMLReporter

class ReporterUtil():
    @staticmethod
    def getReporter(reporterType, checker):
        if reporterType == 'text':
            return TextReporter(checker)
        elif reporterType == 'json':
            return JsonReporter(checker)

########NEW FILE########
__FILENAME__ = TextReporter
from .Reporter import Reporter
from .helper import fill

class TextReporter(Reporter):
    def __init__(self, checker):
        self.checker = checker
        self.msgs = []

    def doReport(self):
        checker = self.checker
        counter = 0
        formatter = '%s %s. %s'

        logs, warns, errors = checker.errors()
        if len(logs) == 0 and len(warns) == 0 and len(errors) == 0:
            self.appendMsg('aha, no problem')
            return

        for error in errors:
            counter = counter + 1
            self.appendMsg(formatter % ('[ERROR]', counter, fill(error)))
        for warn in warns:
            counter = counter + 1
            self.appendMsg(formatter % (' [WARN]', counter, fill(warn)))
        for log in logs:
            counter = counter + 1
            self.appendMsg(formatter % ('  [LOG]', counter, fill(log)))

    def appendMsg(self, msg):
        self.msgs.append(msg)

    def export(self):
        return '\n'.join(self.msgs)
########NEW FILE########
__FILENAME__ = XMLReporter
from .Reporter import Reporter

class XMLReporter(Reporter):
    def __init__(self, checker):
        pass

    def doReport(self):
        pass

    def appendMsg(self, msg):
        pass

    def export(self):
        pass

########NEW FILE########
__FILENAME__ = CkStylePlugin
#encoding=utf-8
import sublime, sublime_plugin
import os
from helper import getCkstylePath

class CkstyleCommand(sublime_plugin.TextCommand):

    def run(self, edit):
        path = os.path.realpath(self.view.file_name().decode('utf-8'))
        if os.path.splitext(path)[1] != '.css':
            sublime.error_message('Not a CSS file!')
            return

        cmd = getCkstylePath() + ' check "' + path + '"'
        os.popen3(cmd)
        resultFile = self.view.file_name() + '.ckstyle.txt'
        if os.path.exists(resultFile):
            self.view.window().open_file(self.view.file_name() + '.ckstyle.txt')
        else: 
            sublime.message_dialog('No mistake found in this CSS, NB!')

########NEW FILE########
__FILENAME__ = CssCompressPlugin
#encoding=utf-8
import sublime, sublime_plugin
import os
from helper import getCkstylePath

class CsscompressCommand(sublime_plugin.TextCommand):

    def run(self, edit):
        path = os.path.realpath(self.view.file_name()).decode('utf-8')
        if os.path.splitext(path)[1] != '.css':
            sublime.error_message('Not a CSS file!')
            return
            
        cmd = getCkstylePath() + ' compress -p "' + path + '"'
        returnValue = os.popen3(cmd)

        returnValue = returnValue[1].read() + returnValue[2].read()

        if returnValue.find('[console.error]') != -1:
            sublime.error_message(returnValue)
        else:
            region = sublime.Region(0, self.view.size())
            msg = self.getRealMsg(returnValue)
            try:
                self.view.replace(edit, region, msg)
            except Exception:
                sublime.error_message('ERROR, maybe because file encoding charset is not utf-8');
            self.view.end_edit(edit)

    def getRealMsg(self, msg):
        for charset in ['utf-8', 'gbk', 'gb2312']:
            try:
                msg.decode(charset)
                return msg.decode(charset)
            except Exception:
                pass
        return msg

########NEW FILE########
__FILENAME__ = FixStylePlugin
#encoding=utf-8
import sublime, sublime_plugin
import os
from helper import getCkstylePath

class FixstyleCommand(sublime_plugin.TextCommand):

    def run(self, edit):
        path = os.path.realpath(self.view.file_name().decode('utf-8'))
        if os.path.splitext(path)[1] != '.css':
            sublime.error_message('Not a CSS file!')
            return
        cmd = getCkstylePath() + ' fix -p "' + path + '"'
        returnValue = os.popen3(cmd)

        returnValue = returnValue[1].read() + returnValue[2].read()

        if returnValue.find('[console.error]') != -1:
            sublime.error_message(returnValue)
        else:
            region = sublime.Region(0, self.view.size())
            msg = self.getRealMsg(returnValue)
            try:
                self.view.replace(edit, region, msg)
            except Exception:
                sublime.error_message('ERROR, maybe because file encoding charset is not utf-8');
            self.view.end_edit(edit)

    def getRealMsg(self, msg):
        for charset in ['utf-8', 'gbk', 'gb2312']:
            try:
                msg.decode(charset)
                return msg.decode(charset)
            except Exception:
                pass
        return msg

########NEW FILE########
__FILENAME__ = FixStyleSafePlugin
#encoding=utf-8
import sublime, sublime_plugin
import os
from helper import getCkstylePath

class FixstylesafeCommand(sublime_plugin.TextCommand):

    def run(self, edit):
        path = os.path.realpath(self.view.file_name()).decode('utf-8')
        if os.path.splitext(path)[1] != '.css':
            sublime.error_message('Not a CSS file!')
            return
            
        cmd = getCkstylePath() + ' fix --safeMode -p "' + path + '"'
        returnValue = os.popen3(cmd)

        returnValue = returnValue[1].read() + returnValue[2].read()

        if returnValue.find('[console.error]') != -1:
            sublime.error_message(returnValue)
        else:
            region = sublime.Region(0, self.view.size())
            msg = self.getRealMsg(returnValue)
            try:
                self.view.replace(edit, region, msg)
            except Exception:
                sublime.error_message('ERROR, maybe because file encoding charset is not utf-8');
            self.view.end_edit(edit)

    def getRealMsg(self, msg):
        for charset in ['utf-8', 'gbk', 'gb2312']:
            try:
                msg.decode(charset)
                return msg.decode(charset)
            except Exception:
                pass
        return msg

########NEW FILE########
__FILENAME__ = FixStyleSingleLinePlugin
#encoding=utf-8
import sublime, sublime_plugin
import os
from helper import getCkstylePath

class FixstylesinglelineCommand(sublime_plugin.TextCommand):

    def run(self, edit):
        path = os.path.realpath(self.view.file_name()).decode('utf-8')
        if os.path.splitext(path)[1] != '.css':
            sublime.error_message('Not a CSS file!')
            return
            
        cmd = getCkstylePath() + ' fix -p --singleLine "' + path + '"'
        returnValue = os.popen3(cmd)

        returnValue = returnValue[1].read() + returnValue[2].read()

        if returnValue.find('[console.error]') != -1:
            sublime.error_message(returnValue)
        else:
            region = sublime.Region(0, self.view.size())
            msg = self.getRealMsg(returnValue)
            try:
                self.view.replace(edit, region, msg)
            except Exception:
                sublime.error_message('ERROR, maybe because file encoding charset is not utf-8');
            self.view.end_edit(edit)

    def getRealMsg(self, msg):
        for charset in ['utf-8', 'gbk', 'gb2312']:
            try:
                msg.decode(charset)
                return msg.decode(charset)
            except Exception:
                pass
        return msg

########NEW FILE########
__FILENAME__ = helper

import os
import sys

def getCkstylePath():
    cmdPath = 'ckstyle'
    if sys.platform == 'linux2' or sys.platform == 'darwin':
        returnValue = os.popen3('which ckstyle')
        returnValue = returnValue[1].read() + returnValue[2].read()
        cmdPath = returnValue
    return cmdPath
########NEW FILE########
__FILENAME__ = python
import os
homedir = os.getenv('USERPROFILE') or os.getenv('HOME')
print os.path.realpath(os.path.join(homedir, 'ckstyle.ini'))

########NEW FILE########
__FILENAME__ = test
import sys
from ckstyle.CssCheckerWrapper import doCheck
from ckstyle.reporter.ReporterUtil import ReporterUtil
from ckstyle.cssparser.CssFileParser import CssParser
from ckstyle.entity.StyleSheet import StyleSheet

def checkCssFileByOpm(filePath):
    fileContent = open(filePath).read()
    checker = doCheck(fileContent, filePath)
    if checker.hasError():
        reporter = ReporterUtil.getReporter('text', checker)
        reporter.doReport()
        print reporter.export()
        return False
    return True


if __name__ == '__main__':
    checkCssFileByOpm('test.css')

########NEW FILE########
__FILENAME__ = runUnitTests
import os
import string
import datetime
from ckstyle.cmdconsole.ConsoleClass import console
from ckstyle.plugins.Base import *
from ckstyle.doCssCheck import doCheck
from ckstyle.reporter.helper import fill

def realpath(directory, fileName):
    return os.path.realpath(os.path.join(directory, fileName))

def fillDicts(logs, warnings, errors, expectedErrors):
    for expected in expectedErrors:
        level = string.atoi(expected.name.strip())
        value = expected.value.split('(from ')[0].strip()

        if level == ERROR_LEVEL.LOG:
            logs[value] = 1
        elif level == ERROR_LEVEL.WARNING:
            warnings[value] = 1
        elif level == ERROR_LEVEL.ERROR:
            errors[value] = 1

def checkUnitTestResult(expecteds, reals, level, fileName):
    global okCounter
    global errorCounter
    for real in reals:
        real = fill(real)
        real = real.split('(from "')[0].strip()
        if expecteds.has_key(real):
            okCounter = okCounter + 1
            expecteds[real] = 0
        else:
            errorCounter = errorCounter + 1
            console.show('[UnitTest] [unexpected but has] level ' + level + '( ' + real + ' )' + ' in ' + fileName)

    for key, value in expecteds.items():
        if value == 1:
            errorCounter = errorCounter + 1
            console.show('[UnitTest] [expect but has not] level ' + level + '( ' + key + ' )' + ' in ' + fileName)

errorCounter = 0;
okCounter = 0;
fileCounter = 0;

def doCheckWithPythonFile(f, module):
    global fileCounter, okCounter, errorCounter

    caseName = os.path.splitext(f)[0]
    plugin = __import__(module + caseName, fromlist = [module + caseName])
    pluginMethod = None
    if hasattr(plugin, 'doTest'):
        pluginMethod = getattr(plugin, 'doTest')
    else:
        console.error('doTest should exist in %s' % f)
    if pluginMethod is None:
        return

    pluginMethod()

    getResults = None
    if hasattr(plugin, 'getResults'):
        getResults = getattr(plugin, 'getResults')
    else:
        console.error('[TOOL] %s should import asserts.py' % f)
    if getResults is None:
        return

    fileCounter = fileCounter + 1

    results = getResults()

    for result in results:
        if result[0] == False:
            errorCounter = errorCounter + 1
            console.show('[UnitTest] [' + f + ']' + result[1])
        else:
            okCounter = okCounter + 1

def fullsplit(path, result=None):
    if result is None:
        result = []
    head, tail = os.path.split(path)
    if head == '':
        return [tail] + result
    if head == path:
        return result
    return fullsplit(head, [tail] + result)

def runTestsInDir(filePath, module):
    global fileCounter
    for filename in os.listdir(filePath):
        if (os.path.isdir(os.path.join(filePath, filename))):
            runTestsInDir(os.path.join(filePath, filename), module + filename + '.')
            continue

        if filename == 'asserts.py' or filename == 'helper.py' or filename.startswith('_'):
            continue
        if filename.endswith('.py'):
            doCheckWithPythonFile(filename, module)
            continue
        if not filename.endswith('.css'):
            continue
        testFileName = realpath(filePath, filename)
        fileContent = open(testFileName).read()
        checker = doCheck(fileContent, filename)

        styleSheet = checker.getStyleSheet()

        testErrorSet = styleSheet.getRuleSetBySelector('@unit-test-expecteds')
        if testErrorSet is None:
            console.error('no @unit-test-expecteds in %s' % testFileName)
            continue
        expectedErrors = testErrorSet.getRules()
        if expectedErrors is None:
            console.error('no error instance in @unit-test-expecteds, %s' % testFileName)
            continue

        fileCounter = fileCounter + 1

        logs = {}
        errors = {}
        warnings = {}
        fillDicts(logs, warnings, errors, expectedErrors)

        realLogs, realWarnings, realErrors = checker.errors()

        checkUnitTestResult(logs, realLogs, '2', filename)
        checkUnitTestResult(warnings, realWarnings, '1', filename)
        checkUnitTestResult(errors, realErrors, '0', filename)


def runUnitTests():
    global fileCounter
    filePath = realpath(__file__, '../unit')

    start = datetime.datetime.now()
    runTestsInDir(filePath, 'unit.')
    end = datetime.datetime.now()

    delta = (end - start).microseconds / 1000
    console.show('[UnitTest] error: %s, pass: %s, in %s files, costs %s ms' % (errorCounter, okCounter, fileCounter, delta))

if __name__ == '__main__':
    runUnitTests()

########NEW FILE########
__FILENAME__ = test
import sys
import os
from ckstyle.doCssCheck import doCheck
from ckstyle.doCssFix import doFix
from ckstyle.doCssCompress import doCompress
from ckstyle.reporter.ReporterUtil import ReporterUtil
from ckstyle.cssparser.CssFileParser import CssParser
from ckstyle.entity.StyleSheet import StyleSheet

def checkCssFileByOpm(filePath):
    fileContent = open(filePath).read()
    checker = doCheck(fileContent, filePath)
    if checker.hasError():
        reporter = ReporterUtil.getReporter('text', checker)
        reporter.doReport()
        print reporter.export()
        return False
    return True

def fixCss(filePath):
    fileContent = open(filePath).read()
    checker = doFix(fileContent, filePath)
    print checker.parser.styleSheet.getRuleSets()[0].values
    print checker.parser.styleSheet.getRuleSets()[0].getRules()[0].fixedValue

def compressCss(filePath):
    fileContent = open(filePath).read()
    checker, content = doCompress(fileContent, filePath)
    print content

def findDupliated():
    dirpath = 'smallsite'
    content = ''
    for f in os.listdir(dirpath):
        selectors = {}
        path = dirpath + '/' + f
        parser = CssParser(open(path, 'r').read(), f)
        parser.doParse()
        for ruleSet in parser.styleSheet._ruleSets:
            selector = ruleSet.selector
            splited = selector.split(',')
            for x in splited:
                x = x.strip()
                if x == '':
                    continue
                if selectors.has_key(x):
                    selectors[x].append(f)
                else:
                    selectors[x] = [f]
        for name, value in selectors.items():
            if len(value) > 2:
                content = content + name + " =====> " + value[0] + "(" + str(len(value)) + 'times)\n'

    open('result.txt', 'w').write(content)

    #path = os.path.realpath(os.path.join(__file__, '../test.css'))
    #checkCssFileByOpm(path)
    #fixCss('test.css')
    #compressCss(path)

if __name__ == '__main__':
    dirpath = 'smallsite'
    content = ''
    counter = 0
    import re
    pattern = re.compile(r'[@\*>\[\]\(\):]')
    collector = []
    for f in os.listdir(dirpath):
        counter = counter + 1
        selectors = {}
        path = dirpath + '/' + f
        parser = CssParser(open(path, 'r').read(), f)
        parser.doParse()
        for ruleSet in parser.styleSheet._ruleSets:
            selector = ruleSet.selector
            if len(pattern.findall(selector)) != 0:
                collector.extend(pattern.findall(selector))
    #open('result.txt', 'w').write(content)
    print set(collector)
    print pattern.findall('@>*li:nth-child(even)')

########NEW FILE########
__FILENAME__ = asserts
results = []

def ok(expected, msg = 'ok'):
    results.append([expected, msg])

def equal(expected, actual, msg = 'ok'):
    if expected == actual:
        ok(True, msg)
    else:
        ok(False, msg + ' (expect: %s, actual: %s)' % (expected, actual))

def notEqual(expected, actual, msg = 'ok'):
    if expected != actual:
        ok(True, msg)
    else:
        ok(False, msg + ' (%s is equal to %s)' % (expected, actual))

def getResults():
    global results
    final = results
    results = []
    return final

########NEW FILE########
__FILENAME__ = demo
from helper import *
from ckstyle.reporter.helper import fill

def doTest():
    text = 'body {width: 1px}'
    logs, warns, errors = doCssCheck(text)
    equal(len(logs), 2, 'two logs')
    equal(len(warns), 1, 'one warn happened')
    equal(len(errors), 1, 'one error happened')
    equal(fill(warns[0]), r'each rule in "body" need semicolon in the end, "width" has not', 'warn rule text is ok')
    equal(fill(errors[0]), r'should not set style for html tag in "body"', 'error rule text is ok')

########NEW FILE########
__FILENAME__ = FEDNoEmptyFile
from asserts import ok, equal, notEqual, getResults
from helper import doCssCheck, doCssTextCheck
from ckstyle.reporter.helper import fill

def doTest():
    logs, warns, errors = doCssTextCheck('/* @author: zhifu.wang**/ /* .test {width: 100px;}*/', 'test.css')
    equal(len(errors), 1, 'one error occur')
    equal(fill(errors[0]), 'empty css file "test.css"')

    logs, warns, errors = doCssTextCheck('/* @author: zhifu.wang**/ /* .test {width: 100px;}*/ \n.test { width: 100px; }', 'test.css')
    equal(len(errors), 0, 'no error now')

########NEW FILE########
__FILENAME__ = helper
import os
import sys
sys.path.insert(0, os.path.realpath(os.path.join(__file__, '../../')))
for p in os.environ.get('PYTHONPATH', '').split(';'):
    sys.path.append(p)

from asserts import *
from ckstyle.doCssCheck import doCheck

def doCssCheck(fileContent, level = 2):
    checker = doCheck(fileContent)
    return checker.errors()

def doCssTextCheck(text, fileName = ''):
    checker = doCheck(text, fileName)
    return checker.errors()

########NEW FILE########
__FILENAME__ = helper
import os
import sys
sys.path.insert(0, os.path.realpath(os.path.join(__file__, '../../')))
for p in os.environ.get('PYTHONPATH', '').split(';'):
    sys.path.append(p)

from asserts import *
from ckstyle.doCssCompress import doCompress

def doCssCompress(fileContent, fileName = ''):
    checker, compressed = doCompress(fileContent, fileName)
    return compressed

def realpath(filepath):
    dirpath = os.path.realpath(os.path.join(__file__, '../'))
    path = os.path.join(dirpath, filepath)
    return path

def doCssFileCompress(path):
    fileContent = open(realpath(path), 'r').read()
    return doCssCompress(fileContent, path)

########NEW FILE########
__FILENAME__ = Try
from helper import *

def doTest():
    msg = doCssFileCompress('_test.css')
    equal(msg, '@import (url-here);.test,.test2,.test3,.test4,.test5{_width:100px;*height:100px}.test6{display:none;_width:100px;*height:100px}', 'totally compressed')

    msg = doCssFileCompress('_test_different_order.css')
    equal(msg, '.test1,.test2,.test3,.test4,.test5{*display:none;_display:inline-block;width:100px;height:200px;border:1px solid #FFF}', 'totally compressed')

    msg = doCssFileCompress('_with_margin.css')
    equal(msg, '.test,.test2,.test3,.test4,.test5{_width:100px;*height:100px;margin:20px 10px 10px}.test6{display:none;_width:100px;*height:100px}', 'margin compress ok')

    msg = doCssFileCompress('_just_margin.css')
    equal(msg, '.test,.test2,.test3,.test4{margin:20px 10px 10px}', 'just margin compress ok')

    msg = doCssFileCompress('_with_padding.css')
    equal(msg, '.test,.test2,.test3,.test4,.test5{_width:100px;*height:100px;padding:20px 10px 10px}.test6{display:none;_width:100px;*height:100px}', 'padding compress ok')

    msg = doCssFileCompress('_just_padding.css')
    equal(msg, '.test,.test2,.test3,.test4{padding:20px 10px 10px}', 'just padding compress ok')

########NEW FILE########
__FILENAME__ = helper
import os
import sys
sys.path.insert(0, os.path.realpath(os.path.join(__file__, '../../')))
for p in os.environ.get('PYTHONPATH', '').split(';'):
    sys.path.append(p)

from asserts import *
from ckstyle.command.ConsoleCommandParser import handleFixStyleCmdArgs, handleCkStyleCmdArgs, handleCompressCmdArgs

def doCheck(args):
    return doCkstyle(args, handleCkStyleCmdArgs)
def doFix(args):
    return doCkstyle(args, handleFixStyleCmdArgs)
def doCompress(args):
    return doCkstyle(args, handleCompressCmdArgs)

def doCkstyle(args, handler):
    old = sys.stdout
    output = realpath('_tmp.txt')
    sys.stdout = open(output, 'w')
    handler(args)
    sys.stdout = old

    result = open(output, 'r').read()
    os.remove(output)
    return result.strip()

def realpath(filepath):
    dirpath = os.path.realpath(os.path.join(__file__, '../'))
    path = os.path.join(dirpath, filepath)
    return path
########NEW FILE########
__FILENAME__ = Try
from helper import *

def doTest():
    res = doCheck([' ', 'check', '-p', realpath('./_test.css')])
    res = res.find('[ERROR] 1. should add @author in the head of')
    equal(res, 0, 'check by cmd line is ok')

    res = doFix([' ', 'fix', '-p', realpath('./_test.css')])
    expect = '''.test {
    width: 100px;
}'''
    equal(res, expect, 'fix by cmd line is ok')


    res = doCompress([' ', 'compress', '-p', realpath('./_test.css')])
    expect = '''.test{width:100px}'''
    equal(res, expect, 'compress by cmd line is ok')

    res = doCompress([' ', 'compress', '-p', realpath('./_test_browsers.css')])
    expect = '''.test{width:100px}.test[prop]{width:100px}'''
    equal(res, expect, 'compress by cmd line is ok')

    res = doCompress([' ', 'compress', '-p', '--browsers=ie6', realpath('./_test_browsers.css')])
    expect = '''.test{width:100px}'''
    equal(res, expect, 'compress by cmd line ie6 is ok')

    res = doCompress([' ', 'compress', '-p', '--browsers=ie7', realpath('./_test_browsers.css')])
    expect = '''.test{width:100px}.test[prop]{width:100px}'''
    equal(res, expect, 'compress by cmd line ie7 is ok')
########NEW FILE########
__FILENAME__ = CompressCssCompiler
from helper import *

def doTest():
    _no_space()
    _has_space()
    _just_prefix()

def _no_space():
    msg = doCssCompress('@-css-compiler{selector-compile:no-combinator;rule-compile:all}html{width:100px;}')
    equal(msg, 'html{width:100px}', '@css-compiler compressed')

def _has_space():
    msg = doCssCompress('@-css-compiler   {selector-compile:no-combinator;rule-compile:all}html{width:100px;}')
    equal(msg, 'html{width:100px}', '@css-compiler compressed')

def _just_prefix():
    msg = doCssCompress('@-css-compiler-prefix fdsafdsafdsa;html{width:100px;}')
    equal(msg, 'html{width:100px}', '@css-compiler compressed')
########NEW FILE########
__FILENAME__ = CompressFile
from helper import *

def doTest():
    _basic()
    _one_line_file()
    _with_extra()
    _compress_with_hack_chars()
    _extra_statement()
    _expression()

def _basic():
    msg = doCssFileCompress('_file.css')
    equal(msg, ".test{width:100px;height:200px;_z-index:111}@keyframes 'name'{10%{width:100px}}.another{*width:100px;background-color:#ABC;color:#DDD}", 'file compressed')

def _one_line_file():
    msg = doCssFileCompress('_one_line_file.css')
    equal(msg, ".test{width:100px;height:200px;_z-index:111}@keyframes 'name'{10%{width:100px}}.another{*width:100px;background-color:#ABC;color:#DDD}", 'file compressed')

def _with_extra():
    msg = doCssFileCompress('_with_extra.css')
    equal(msg, "@charset utf-8;@import url('xxxxx');@namespace lalala;.test{width:100px;height:200px;_z-index:111}@import url('xxx2');@import url('xxx3');", 'file compressed')
    
def _compress_with_hack_chars():
    msg = doCssFileCompress('_compress_special_hack_chars.css')
    equal(msg, "li:nth-child(even){background:gray}* html li.even{background:gray}.test[^=aaa]{background:gray}.test1,.test2{width:100px}", 'file compressed')
    
def _extra_statement():
    msg = doCssFileCompress('_extra_statement.css')
    # do not show @-css-compile content after compress
    equal(msg, "@charset utf-8;@import url(fdafdas/fdafdas.css);", 'extra statement compressed')

def _expression():
    msg = doCssFileCompress('_expression.css')
    equal(msg, "*html .feed-comment textarea{behavior:expression(function(ele){ele.runtimeStyle.behavior='none';Expressions.pseudo.hover(ele,'textarea_hover')}(this))}", 'expression compressed')

########NEW FILE########
__FILENAME__ = CompressNestedStatement
from helper import *

def doTest():
    _go()

def _go():
    msg = doCssCompress('@media print{/* Hide the cursor when printing */.CodeMirror div.CodeMirror-cursor{visibility:hidden}}')
    equal(msg, '@media print{.CodeMirror div.CodeMirror-cursor{visibility:hidden}}', 'nested statement compress is ok')

########NEW FILE########
__FILENAME__ = CompressToBrowsers
from helper import *

def doTest():
    _basic()
    _combine()
    _w3school_css3()
    _kimblim_selectors()
    _important_hacks()

def _basic():
    checker = doCssFileCompress2('_browsers.css')
    equal('a{-webkit-transform:1s;-moz-transform:1s;-o-transform:1s}b{width:300px;-moz-transform:1s}', checker.doCompress(STD | NONEIE), 'std is ok')
    checker = doCssFileCompress2('_browsers.css')
    equal('a{-webkit-transform:1s}b{width:300px}', checker.doCompress(STD | WEBKIT), 'webkit is ok')
    checker = doCssFileCompress2('_browsers.css')
    equal('a{-o-transform:1s}b{width:300px}', checker.doCompress(STD | OPERA), 'opera is ok')
    checker = doCssFileCompress2('_browsers.css')
    equal('a{-webkit-transform:1s}b{width:300px}', checker.doCompress(STD | CHROME), 'chrome is ok')
    checker = doCssFileCompress2('_browsers.css')
    equal('a{-moz-transform:1s}b{width:300px;-moz-transform:1s}', checker.doCompress(STD | FIREFOX), 'firefox is ok')
    checker = doCssFileCompress2('_browsers.css')
    equal('*html a{width:100px}b{width:300px;_width:400px}', checker.doCompress(STD | IE6), 'ie6 is ok')
    checker = doCssFileCompress2('_browsers.css')
    equal('*+html a{width:200px}b{width:300px}', checker.doCompress(STD | IE7), 'ie7 is ok')

def _combine():
	checker = doCssFileCompress2('_browsers_combine_ruleset.css')
	equal('a,b,d{width:300px;-moz-transform:1s}', checker.doCompress(STD | FIREFOX), 'firefox is ok')
	checker = doCssFileCompress2('_browsers_combine_ruleset.css')
	equal('a{width:300px;-webkit-transform:1s}b,d{width:300px}', checker.doCompress(STD | CHROME), 'chrome 2 is ok')

def _w3school_css3():
    checker = doCssFileCompress2('_browsers_from_w3school.css')
    equal('.test{background-clip:test;background-origin:test;animation:test;animation-delay:test;animation-direction:test;animation-duration:test;animation-iteration-count:test;animation-name:test;animation-play-state:test;animation-timing-function:test;appearance:test;border-image:test;border-image-outset:test;border-image-repeat:test;border-image-slice:test;border-image-source:test;border-image-width:test;border-bottom-left-radius:test;border-bottom-right-radius:test;border-radius:test;border-top-left-radius:test;border-top-right-radius:test;box-align:test;box-direction:test;box-flex:test;box-flex-group:test;box-ordinal-group:test;box-orient:test;box-pack:test;box-sizing:test;box-shadow:test;column-count:test;column-gap:test;column-rule:test;column-rule-color:test;column-rule-style:test;column-rule-width:test;column-width:test;marquee-speed:test;marquee-style:test;transform:test;transform-style:test;transform-origin:test;transition:test;transition-delay:test;transition-duration:test;transition-property:test;transition-timing-function:test;background-size:test;backface-visibility:test;column-span:test;columns:test;marquee-direction:test;marquee-play-count:test;opacity:test;outline-offset:test;overflow-x:test;overflow-y:test;perspective:test;perspective-origin:test;resize:test;text-overflow:test;text-shadow:test;word-break:test;word-wrap:test}', 
        checker.doCompress(STD | CHROME), 'chrome w3c is ok')

    equal('.test{background-clip:test;background-origin:test;font-size-adjust:test;animation:test;animation-delay:test;animation-direction:test;animation-duration:test;animation-iteration-count:test;animation-name:test;animation-play-state:test;animation-timing-function:test;appearance:test;border-image:test;border-image-outset:test;border-image-repeat:test;border-image-slice:test;border-image-source:test;border-image-width:test;border-bottom-left-radius:test;border-bottom-right-radius:test;border-radius:test;border-top-left-radius:test;border-top-right-radius:test;box-align:test;box-direction:test;box-flex:test;box-flex-group:test;box-ordinal-group:test;box-orient:test;box-pack:test;box-sizing:test;box-shadow:test;column-count:test;column-gap:test;column-rule:test;column-rule-color:test;column-rule-style:test;column-rule-width:test;column-width:test;transform:test;transform-style:test;transform-origin:test;transition:test;transition-delay:test;transition-duration:test;transition-property:test;transition-timing-function:test;background-size:test;backface-visibility:test;columns:test;opacity:test;outline-offset:test;overflow-x:test;overflow-y:test;resize:test;text-overflow:test;text-shadow:test;word-break:test;word-wrap:test}', 
        checker.doCompress(STD | FIREFOX), 'firefox w3c is ok')

    equal('.test{background-clip:test;background-origin:test;animation:test;animation-delay:test;animation-direction:test;animation-duration:test;animation-iteration-count:test;animation-name:test;animation-play-state:test;animation-timing-function:test;border-image:test;border-image-outset:test;border-image-repeat:test;border-image-slice:test;border-image-source:test;border-image-width:test;border-bottom-left-radius:test;border-bottom-right-radius:test;border-radius:test;border-top-left-radius:test;border-top-right-radius:test;box-flex:test;box-flex-group:test;box-sizing:test;box-shadow:test;column-count:test;column-gap:test;column-rule:test;column-rule-color:test;column-rule-style:test;column-rule-width:test;column-width:test;transform:test;transform-style:test;transform-origin:test;transition:test;transition-delay:test;transition-duration:test;transition-property:test;transition-timing-function:test;background-size:test;column-span:test;columns:test;nav-down:test;nav-index:test;nav-left:test;nav-right:test;nav-up:test;opacity:test;outline-offset:test;overflow-x:test;overflow-y:test;text-overflow:test;text-shadow:test;word-wrap:test}', 
        checker.doCompress(STD | OPERA), 'opera w3c is ok')

    equal('.test{background-clip:test;background-origin:test;animation:test;animation-delay:test;animation-direction:test;animation-duration:test;animation-iteration-count:test;animation-name:test;animation-play-state:test;animation-timing-function:test;appearance:test;border-image:test;border-image-outset:test;border-image-repeat:test;border-image-slice:test;border-image-source:test;border-image-width:test;border-bottom-left-radius:test;border-bottom-right-radius:test;border-radius:test;border-top-left-radius:test;border-top-right-radius:test;box-align:test;box-direction:test;box-flex:test;box-flex-group:test;box-ordinal-group:test;box-orient:test;box-pack:test;box-sizing:test;box-shadow:test;column-count:test;column-gap:test;column-rule:test;column-rule-color:test;column-rule-style:test;column-rule-width:test;column-width:test;marquee-speed:test;marquee-style:test;transform:test;transform-style:test;transform-origin:test;transition:test;transition-delay:test;transition-duration:test;transition-property:test;transition-timing-function:test;background-size:test;backface-visibility:test;column-span:test;columns:test;marquee-direction:test;marquee-play-count:test;opacity:test;outline-offset:test;overflow-x:test;overflow-y:test;perspective:test;perspective-origin:test;resize:test;text-overflow:test;text-shadow:test;word-break:test;word-wrap:test}', 
        checker.doCompress(STD | SAFARI), 'safari w3c is ok')

    equal('.test{text-justify:test;text-overflow:test;word-break:test;word-wrap:test}', 
        checker.doCompress(STD | IE6), 'ie6 w3c is ok')

    equal('.test{text-justify:test;text-overflow:test;word-break:test;word-wrap:test}', 
        checker.doCompress(STD | IE7), 'ie7 w3c is ok')

    equal('.test{background-clip:test;background-origin:test;animation:test;animation-delay:test;animation-direction:test;animation-duration:test;animation-iteration-count:test;animation-name:test;animation-play-state:test;animation-timing-function:test;border-bottom-left-radius:test;border-bottom-right-radius:test;border-radius:test;border-top-left-radius:test;border-top-right-radius:test;box-sizing:test;box-shadow:test;column-count:test;column-gap:test;column-rule:test;column-rule-color:test;column-rule-style:test;column-rule-width:test;column-width:test;transform:test;transform-style:test;transform-origin:test;transition:test;transition-delay:test;transition-duration:test;transition-property:test;transition-timing-function:test;background-size:test;backface-visibility:test;column-span:test;columns:test;opacity:test;overflow-x:test;overflow-y:test;ruby-align:test;ruby-overhang:test;ruby-position:test;text-justify:test;text-overflow:test;text-shadow:test;word-break:test;word-wrap:test}', 
        checker.doCompress(STD | IE9PLUS), 'ie9+ w3c is ok')

def _kimblim_selectors():
    checker = doCssFileCompress2('_selectors_from_kimblim.css')
    res = 'div,div span,:link,div:active,div:visited,div.classname,div#id,*,div:hover{width:100px}div:first-line,div:first-letter,.classname.classname,div > span,div:first-child,div + span,div[attr],div[attr="name"],div[attr~="name"],div ~ span,div[attr^="name"],div[attr$="name"],div[attr*="name"],div[attr|="name"]{width:100px}div:focus,div:before,div:after{width:100px}div:root,div:nth-of-type,div:nth-last-of-type,div:first-of-type,div:last-of-type,div:only-of-type,div:only-child,div:last-child,div:nth-child,div:nth-last-child,div:empty,div:target,div:checked,div::selection,div:enabled,div:disabled,div:not(s){width:100px}'
    equal(res, checker.doCompress(STD | NONEIE), 'std selectors is ok')

    checker = doCssFileCompress2('_selectors_from_kimblim.css')
    res = 'div,div span,:link,div:active,div:visited,div.classname,div#id,*,div:hover{width:100px}'
    equal(res, checker.doCompress(STD | IE6), 'ie6 selectors is ok')

    checker = doCssFileCompress2('_selectors_from_kimblim.css')
    res = 'div,div span,:link,div:active,div:visited,div.classname,div#id,*,div:hover{width:100px}div:first-line,div:first-letter,.classname.classname,div > span,div:first-child,div + span,div[attr],div[attr="name"],div[attr~="name"],div ~ span,div[attr^="name"],div[attr$="name"],div[attr*="name"],div[attr|="name"]{width:100px}'
    equal(res, checker.doCompress(STD | IE7), 'ie7 selectors is ok')

    checker = doCssFileCompress2('_selectors_from_kimblim.css')
    res = 'div,div span,:link,div:active,div:visited,div.classname,div#id,*,div:hover{width:100px}div:first-line,div:first-letter,.classname.classname,div > span,div:first-child,div + span,div[attr],div[attr="name"],div[attr~="name"],div ~ span,div[attr^="name"],div[attr$="name"],div[attr*="name"],div[attr|="name"]{width:100px}div:focus,div:before,div:after{width:100px}'
    equal(res, checker.doCompress(STD | IE8), 'ie8 selectors is ok')

    checker = doCssFileCompress2('_selectors_from_kimblim.css')
    res = 'div,div span,:link,div:active,div:visited,div.classname,div#id,*,div:hover{width:100px}div:first-line,div:first-letter,.classname.classname,div > span,div:first-child,div + span,div[attr],div[attr="name"],div[attr~="name"],div ~ span,div[attr^="name"],div[attr$="name"],div[attr*="name"],div[attr|="name"]{width:100px}div:focus,div:before,div:after{width:100px}div:root,div:nth-of-type,div:nth-last-of-type,div:first-of-type,div:last-of-type,div:only-of-type,div:only-child,div:last-child,div:nth-child,div:nth-last-child,div:empty,div:target,div:checked,div::selection,div:enabled,div:disabled,div:not(s){width:100px}'
    equal(res, checker.doCompress(STD | IE9PLUS), 'ie9 selectors is ok')

    checker = doCssFileCompress2('_selectors_from_kimblim.css')
    res = 'div,div span,:link,div:active,div:visited,div.classname,div#id,*,div:hover{width:100px}div:first-line,div:first-letter,.classname.classname,div > span,div:first-child,div + span,div[attr],div[attr="name"],div[attr~="name"],div ~ span,div[attr^="name"],div[attr$="name"],div[attr*="name"],div[attr|="name"]{width:100px}div:focus,div:before,div:after{width:100px}div:root,div:nth-of-type,div:nth-last-of-type,div:first-of-type,div:last-of-type,div:only-of-type,div:only-child,div:last-child,div:nth-child,div:nth-last-child,div:empty,div:target,div:checked,div::selection,div:enabled,div:disabled,div:not(s){width:100px}'
    equal(res, checker.doCompress(STD | OPERA), 'OPERA selectors is ok')

    checker = doCssFileCompress2('_selectors_from_kimblim.css')
    res = 'div,div span,:link,div:active,div:visited,div.classname,div#id,*,div:hover{width:100px}div:first-line,div:first-letter,.classname.classname,div > span,div:first-child,div + span,div[attr],div[attr="name"],div[attr~="name"],div ~ span,div[attr^="name"],div[attr$="name"],div[attr*="name"],div[attr|="name"]{width:100px}div:focus,div:before,div:after{width:100px}div:root,div:nth-of-type,div:nth-last-of-type,div:first-of-type,div:last-of-type,div:only-of-type,div:only-child,div:last-child,div:nth-child,div:nth-last-child,div:empty,div:target,div:checked,div::selection,div:enabled,div:disabled,div:not(s){width:100px}'
    equal(res, checker.doCompress(STD | WEBKIT), 'WEBKIT selectors is ok')

def _important_hacks():
    checker = doCssFileCompress2('_browsers_importanter_hacks.css')
    res = ''
    equal(res, checker.doCompress(STD | IE6), 'ie6 important selector is ok')

    checker = doCssFileCompress2('_browsers_importanter_hacks.css')
    res = '.test[fd~=df]{width:100px}'
    equal(res, checker.doCompress(STD | IE7), 'ie7 important selector is ok')

    checker = doCssFileCompress2('_browsers_importanter_hacks.css')
    res = '.test[fd~=df]{width:100px}'
    equal(res, checker.doCompress(STD | IE8), 'ie8 important selector is ok')

    checker = doCssFileCompress2('_browsers_importanter_hacks.css')
    res = '.test[fd*=df],.test:not(xxx){width:100px}.test[fd~=df]{width:100px}'
    equal(res, checker.doCompress(STD | CHROME), 'chrome important selector is ok')
########NEW FILE########
__FILENAME__ = CompressWithOrder
from helper import *

def doTest():
    _basic()
    _with_hack()
    _with_extra()
    _with_different_level()
    _with_css3_props()

def _basic():
    msg = doCssCompress('/* @wangjeaf */ .test {width: 100px; display:none; height: 100px;}')
    equal(msg, '.test{display:none;width:100px;height:100px}', 'general order compress is ok')

def _with_hack():
    msg = doCssCompress('.test {_width: 100px; *display:none;_display:none;display:block\9;*height: 100px;}')
    equal(msg, '.test{*display:none;_display:none;display:block\9;_width:100px;*height:100px}', 'hack order compress is ok')

def _with_extra():
    msg = doCssCompress('@import (url-here);.test {_width: 100px; *height: 100px;}')
    equal(msg, '@import (url-here);.test{_width:100px;*height:100px}', 'extra order compress is ok')

def _with_different_level():
    msg = doCssCompress('.test {cursor:pointer;color:red;line-height:10px;background-color:red;margin-top:10px;padding-bottom:10px;position:relative;}')
    equal(msg, '.test{position:relative;margin-top:10px;padding-bottom:10px;background-color:red;line-height:10px;color:red;cursor:pointer}', 'different levels is ok')

def _with_css3_props():
    msg = doCssCompress('.test {-moz-transform:xxxx;-webkit-transform:xxxx;transform:xxxx;*zoom:1;width:100px;display:none;}')
    equal(msg, '.test{display:none;width:100px;*zoom:1;-webkit-transform:xxxx;-moz-transform:xxxx;transform:xxxx}', 'different levels is ok')

########NEW FILE########
__FILENAME__ = helper
import os
import sys
sys.path.insert(0, os.path.realpath(os.path.join(__file__, '../../')))
for p in os.environ.get('PYTHONPATH', '').split(';'):
    sys.path.append(p)

from asserts import *
from ckstyle.doCssCompress import doCompress
from ckstyle.browsers.BinaryRule import *

def doCssCompress(fileContent, fileName = ''):
    checker, compressed = doCompress(fileContent, fileName)
    return compressed

def doCssCompress2(fileContent, fileName = ''):
    checker, compressed = doCompress(fileContent, fileName)
    return checker

def realpath(filepath):
    dirpath = os.path.realpath(os.path.join(__file__, '../'))
    path = os.path.join(dirpath, filepath)
    return path

def doCssFileCompress(path):
    fileContent = open(realpath(path), 'r').read()
    return doCssCompress(fileContent, path)

def doCssFileCompress2(path):
    fileContent = open(realpath(path), 'r').read()
    return doCssCompress2(fileContent, path)
########NEW FILE########
__FILENAME__ = Try
from helper import *

def doTest():
    _basic()
    _with_hack()
    _with_extra()
    _with_keyframes()
    _with_keyframes_enter()
    _only_comments()
    _with_complecated_keyframes()

def _basic():
    msg = doCssCompress('/* @wangjeaf */ .test {width: 100px; height: 100px;}')
    equal(msg, '.test{width:100px;height:100px}', 'compressed')

def _with_hack():
    msg = doCssCompress('.test {_width: 100px; *height: 100px;}')
    equal(msg, '.test{_width:100px;*height:100px}', 'hack compressed')

def _with_extra():
    msg = doCssCompress('@import (url-here);.test {_width: 100px; *height: 100px;}')
    equal(msg, '@import (url-here);.test{_width:100px;*height:100px}', 'extra compressed')

def _with_keyframes():
    msg = doCssCompress('@keyframes "test"{ \n10% {\nwidth:100px;\n} 60% {\nwidth: 200px;\n}}')
    equal(msg, '@keyframes \'test\'{10%{width:100px}60%{width:200px}}', 'keyframes compressed')

def _with_keyframes_enter():
    msg = doCssCompress('''
@keyframes .fdasfads {
    10% {
        width: 200px;
    }

    20% {
        width: 200px;
    }
}''')
    equal(msg, '@keyframes .fdasfads{10%{width:200px}20%{width:200px}}', 'keyframes compressed')

def _only_comments():
    msg = doCssCompress('/* a */ /* a */ /* a */ /* a */')
    equal(msg, '', 'nothing')

def _with_complecated_keyframes():
    msg = doCssCompress('@keyframes "test"{ \n10% {\nwidth:100px;\n} 60% {\nwidth: 200px;\n}}')
    equal(msg, '@keyframes \'test\'{10%{width:100px}60%{width:200px}}', 'keyframes compressed')

def _with_keyframes_enter():
    msg = doCssCompress('''@media screen and (-webkit-min-device-pixel-ratio:0) {
 .publisher-c .global-publisher-selector{ top:5px;}
 .publisher-a .global-publisher-selector-status a,
 .publisher-a .global-publisher-selector-status .global-publisher-status-trigger:hover,
 .publisher-a .global-publisher-selector .active .global-publisher-status-trigger {
    background-position: 0 1px;
}
 .publisher-a .global-publisher-selector-share a,
 .publisher-a .global-publisher-selector-share a:hover,
 .publisher-a .global-publisher-selector .active .global-publisher-share-trigger{
    background-position: 0 -48px;
 }
}''')
    equal(msg, '@media screen and (-webkit-min-device-pixel-ratio:0){.publisher-c .global-publisher-selector{top:5px}.publisher-a .global-publisher-selector-status a,.publisher-a .global-publisher-selector-status .global-publisher-status-trigger:hover,.publisher-a .global-publisher-selector .active .global-publisher-status-trigger{background-position:0 1px}.publisher-a .global-publisher-selector-share a,.publisher-a .global-publisher-selector-share a:hover,.publisher-a .global-publisher-selector .active .global-publisher-share-trigger{background-position:0 -48px}}', 'complecated keyframes compressed')

########NEW FILE########
__FILENAME__ = ConfigCommandLine
from helper import *

def doTest():
    _default()

def _default():
    config = parseCkStyleCmdArgs(realpath('ckstyle.ini'), [], [], True)
    equal(config.errorLevel, 0, 'errorLevel is 0')
    equal(config.recursive, False, 'recursive is False')
    equal(config.printFlag, False, 'print flag is False')
    equal(config.include, 'all', 'include is all')
    equal(config.exclude, 'none', 'exclude is none')
    equal(config.extension, '.ckstyle.txt', 'extension is ok')
    equal(config.fixedExtension, '.fixed.css', 'fixed extension is ok')
    equal(config.safeMode, False, 'safemode is false default')
    equal(config.noBak, False, 'no bak is false default')
    equal(len(config.ignoreRuleSets), 1, 'one ruleset to be ignored')

    equal(config.compressConfig.extension, '.min.css', 'extension is .min.css')
    equal(config.compressConfig.combineFile, False, 'combine file is False')
    equal(config.compressConfig.browsers, None, 'browsers is false')
    equal(config.compressConfig.noBak, False, 'no bak is false default')

    config = parseCkStyleCmdArgs(realpath('ckstyle.ini'), [("--errorLevel", "2"), ("--include", "abcde"), ("--exclude", "fghi"), ("-p", True), ("-r", True)], [], True)

    equal(config.errorLevel, 2, 'errorLevel is 2')
    equal(config.recursive, True, 'recursive is True')
    equal(config.printFlag, True, 'print flag is True')
    equal(config.include, 'abcde', 'include is abcde')
    equal(config.exclude, 'fghi', 'exclude is fghi')

    config = parseCompressCmdArgs(realpath('ckstyle.ini'), [("--errorLevel", "2"), ("--include", "abcde"), ("--exclude", "fghi"), ("-p", True), ("-r", True), ('--compressExtension', '.xxx.min.css'), ('--browsers', 'ie6,ie7,std'), ('--combineFile', 'true'), ("--safeMode", True), ("--noBak", True)], [], True)
    equal(config.errorLevel, 2, 'errorLevel is 2')
    equal(config.recursive, True, 'recursive is True')
    equal(config.printFlag, True, 'print flag is True')
    equal(config.include, 'abcde', 'include is abcde')
    equal(config.exclude, 'fghi', 'exclude is fghi')
    equal(config.safeMode, True, 'safemode is true')
    equal(config.noBak, False, 'noBak in config is true')
    equal(config.compressConfig.noBak, True, 'noBak in config.compressConfig is true')

    equal(config.compressConfig.extension, '.xxx.min.css', 'extension changed')
    equal(config.compressConfig.combineFile, True, 'combine file is true')
    equal(config.compressConfig.browsers.has_key('ie6'), True, 'browsers is true')

    config = parseFixStyleCmdArgs(realpath('ckstyle.ini'), [("--errorLevel", "2"), ("--include", "abcde"), ("--exclude", "fghi"), ("-p", True), ("-r", True), ('--fixedExtension', '.xxx.fixed.css'), ("--singleLine", True), ("--safeMode", True), ("--noBak", True)], [], True)
    equal(config.errorLevel, 2, 'errorLevel is 2')
    equal(config.recursive, True, 'recursive is True')
    equal(config.printFlag, True, 'print flag is True')
    equal(config.include, 'abcde', 'include is abcde')
    equal(config.exclude, 'fghi', 'exclude is fghi')
    equal(config.safeMode, True, 'safemode is true')
    equal(config.noBak, True, 'noBak in fixstyle is true')

    equal(config.fixToSingleLine, True, 'fix to single line is true')
    equal(config.fixedExtension, '.xxx.fixed.css', 'fixed extension changed')

########NEW FILE########
__FILENAME__ = ConfigFileContent
from helper import *

def doTest():
    _default()
    _configed()
    _missing()

def _missing():
    config = parseConfigFile('ckstyle_missing.ini')
    equal(config.errorLevel, 2, 'error level is 0(ERROR) from python')
    equal(config.printFlag, False, 'print flag is False from python')
    equal(config.extension, '.ckstyle.txt', 'extension is ok from python')
    equal(config.include, 'all', 'include is all from python')
    equal(config.exclude, 'none', 'exclude is none from python')
    equal(config.standard, 'standard3.css', 'standard css file name is ok')
    equal(config.fixedExtension, '.fixed2.css', 'fixed extension is ok from python')
    equal(config.fixToSingleLine, False, 'fix to single line is false')
    equal(config.safeMode, False, 'safemode is false by file')
    equal(len(config.ignoreRuleSets), 1, 'one ignored rule set')
    equal(config.noBak, False, 'no bak is False by default')

    args = config.compressConfig
    equal(args.combineFile, True, 'combine file is still True')
    equal(args.browsers, None, 'browsers is false')
    equal(args.extension, '.lala.min.css', 'extension changed')
    equal(args.noBak, False, 'no bak is False by default')

def _configed():
    config = parseConfigFile('ckstyle_configed.ini')
    equal(config.errorLevel, 2, 'error level is 2(LOG)')
    equal(config.printFlag, True, 'print flag is true')
    equal(config.extension, '.ckstyle2.txt', 'extension is ok')
    equal(config.include, 'abc', 'include is abc')
    equal(config.exclude, 'ddd', 'exclude is ddd')
    equal(config.standard, 'standard2.css', 'standard css file name is ok')
    equal(config.ignoreRuleSets[0], '@unit-test-expecteds', 'rule sets ignored')
    equal(config.ignoreRuleSets[1], '@unit-tests-fda', 'rule sets ignored')
    equal(len(config.ignoreRuleSets), 2, 'two ignored rule sets')
    equal(config.fixToSingleLine, True, 'fix to single line is true')
    equal(config.safeMode, True, 'safemode is True by file')
    equal(config.noBak, True, 'no bak is True by file')

    args = config.compressConfig
    equal(args.combineFile, True, 'combine file is True')
    equal(args.browsers.has_key('std'), True, 'browsers is True')
    equal(args.browsers.has_key('ie6'), True, 'browsers is True')
    equal(args.browsers.has_key('ie7'), True, 'browsers is True')
    equal(args.browsers.has_key('ie9'), False, 'browsers is True')
    equal(args.extension, '.min3.css', 'extension changed')
    equal(args.noBak, True, 'no bak is True')

def _default():
    config = parseConfigFile('ckstyle.ini')
    equal(config.errorLevel, 0, 'error level is 0(ERROR)')
    equal(config.printFlag, False, 'print flag is false')
    equal(config.extension, '.ckstyle.txt', 'extension is ok')
    equal(config.include, 'all', 'include is all')
    equal(config.exclude, 'none', 'exclude is none')
    equal(config.standard, 'standard.css', 'standard css file name is ok')
    equal(config.ignoreRuleSets[0], '@unit-test-expecteds', 'rule sets ignored')
    equal(len(config.ignoreRuleSets), 1, 'only one ignored rule set')
    equal(config.fixToSingleLine, False, 'fix to single line is false default')
    equal(config.safeMode, False, 'safemode is False by file')

########NEW FILE########
__FILENAME__ = helper
import os
import sys
sys.path.insert(0, os.path.realpath(os.path.join(__file__, '../../')))
for p in os.environ.get('PYTHONPATH', '').split(';'):
    sys.path.append(p)

from asserts import *
import ckstyle.command.CommandFileParser as CommandFileParser
from ckstyle.command.ConsoleCommandParser import parseCkStyleCmdArgs, parseCompressCmdArgs, parseFixStyleCmdArgs

def realpath(filepath):
    dirpath = os.path.realpath(os.path.join(__file__, '../'))
    path = os.path.join(dirpath, filepath)
    return path

def parseConfigFile(path):
    parser = CommandFileParser.CommandFileParser(realpath(path), True)
    config = parser.args
    return config

########NEW FILE########
__FILENAME__ = WithPlugin
from helper import *

def doTest():
    _default()

def _default():
    config = parseCkStyleCmdArgs(realpath('ckstyle_with_plugin.ini'), [], [], True)
    ok(config.pluginConfig is not None, 'plugin config is not none')
    
    options = config.pluginConfig
    ok(options.has_key('plugin-a-config'), 'plugin config a')
    ok(options.has_key('plugin-b-config'), 'plugin config b')
    # config in lower case
    ok(options.has_key('pluginCConfig'), 'plugin c')

    equal(options.get('plugin-a-config'), '1', 'value of plugin config a')
    equal(options.get('plugin-b-config'), '2', 'value of plugin config b')
    equal(options.get('pluginCConfig'), '3', 'value of plugin config c')
########NEW FILE########
__FILENAME__ = ExtraStatement
from helper import *

def doTest():
    _basic()
    _opm()
    _other()

def _basic():
    stmt = ExtraStatement('@import', '@import url("fjdaslkjfdsa")', None)
    ok(stmt.extra, '@import is extra statement')
    equal(stmt.operator, '@import', 'operator is @important')
    equal(stmt.statement, '@import url("fjdaslkjfdsa")', 'statement is ok')
    equal(stmt.styleSheet, None, 'no style sheet')
    ok(stmt.isImport(), 'yes, it is import statement')
    ok(not stmt.isOpmOperator(), 'no, it is not opm operator')

def _opm():
    stmt = ExtraStatement('@-css-compiler-xxx', '@-css-compiler-xxx fdjafdjafda;', None)
    ok(stmt.isOpmOperator(), 'yes, it is opm operator')

    stmt = ExtraStatement('@-css-compiler-xxx', '@-css-compiler-xxx fdjafdjafda;', None)
    ok(stmt.isOpmOperator(), 'yes, it is opm operator')

def _other():
    stmt = ExtraStatement('@namspace', '@namspace fdjafdjafda;', None)
    ok(not stmt.isOpmOperator(), 'no, it is not opm operator')
    ok(not stmt.isImport(), 'no, it is not import')

    stmt = ExtraStatement('@charset', '@charset utf-8;', None)
    ok(not stmt.isOpmOperator(), 'no, it is not opm operator')
    ok(not stmt.isImport(), 'no, it is not import')

########NEW FILE########
__FILENAME__ = helper
import os
import sys
sys.path.insert(0, os.path.realpath(os.path.join(__file__, '../../')))
for p in os.environ.get('PYTHONPATH', '').split(';'):
    sys.path.append(p)

from asserts import *


from ckstyle.entity.Rule import Rule
from ckstyle.entity.RuleSet import RuleSet
from ckstyle.entity.StyleSheet import StyleSheet
from ckstyle.entity.ExtraStatement import ExtraStatement

########NEW FILE########
__FILENAME__ = Rule
from helper import *

def doTest():
    _rule()
    _getRuleSet()

def _getRuleSet():
    ruleSet = RuleSet('.selector', 'width:100px;', '/* aa */', None)
    rule = Rule("", "", "", ruleSet)
    equal(rule.getRuleSet(), ruleSet, 'get rule set')
    equal(rule.getRuleSet().selector, '.selector', 'it is what I need')

def _rule():
    rule = Rule("   .test ", "  _width ", " 100px; ", None)
    equal(rule.selector, '.test', 'selector is ok')
    equal(rule.roughSelector, '   .test ', 'roughSelector is ok')
    equal(rule.roughName, '  _width ', 'roughName is ok')
    equal(rule.name, 'width', 'name is ok')
    equal(rule.roughValue, ' 100px; ', 'roughValue is ok')
    equal(rule.value, '100px', 'value is ok')
    equal(rule.strippedName, '_width', 'stripped name is ok')
    equal(rule.strippedValue, '100px;', 'strippedValue is ok')

########NEW FILE########
__FILENAME__ = RuleSet
from helper import *

def doTest():
    _ruleSet()

def _ruleSet():
    ruleSet = RuleSet('   .test ', '  width:100px;height:100px;  ', '/* aa */   ', None)
    ok(not ruleSet.extra, 'ruleset is not extra')
    equal(ruleSet.selector, '.test', 'selector is ok')
    equal(ruleSet.roughSelector, '   .test ', 'roughSelector is ok')
    equal(ruleSet.roughValue, '  width:100px;height:100px;  ', 'roughValue is ok')
    equal(ruleSet.roughComment, '/* aa */   ', 'rough comment is ok')
    equal(ruleSet.values, 'width:100px;height:100px;', 'values is ok')
    ok(ruleSet.singleLineFlag, 'it is single line')
    ok(ruleSet.getSingleLineFlag(), 'it is single line')
    equal(ruleSet.getStyleSheet(), None, 'no stylesheet')

    equal(len(ruleSet.getRules()), 0, 'no rules')
    equal(ruleSet.indexOf('width'), -1, 'no _width')
    equal(ruleSet.existNames('width'), False, 'no width again')
    equal(ruleSet.existNames('  _width '), False, 'no rough _width')
    equal(ruleSet.getRuleByName('width'), None, 'can not find width')
    equal(ruleSet.getRuleByRoughName('  _width '), None, 'can not find _width')

    ruleSet.addRuleByStr(' .aaa', '  _width ', ' 100px; ')
    
    equal(len(ruleSet.getRules()), 1, 'one rule')
    equal(ruleSet.indexOf('_width'), 0, 'found width')
    equal(ruleSet.existNames('width'), True, 'found width again')
    equal(ruleSet.existRoughNames('  _width '), True, 'found rough width')
    equal(ruleSet.getRuleByName('width').value, '100px', 'find width')
    equal(ruleSet.getRuleByRoughName('  _width ').value, '100px', 'find width by rough name')
    equal(ruleSet.getRuleByStrippedName('_width').value, '100px', 'find width by stripped name')

    ruleSet.addRuleByStr(' .aaa', 'height', '100px; ')
    equal(len(ruleSet.getRules()), 2, 'two rules')
    equal(ruleSet.getRules()[0].name, 'width', 'width is first')
    equal(ruleSet.getRules()[1].name, 'height', 'height is second')

########NEW FILE########
__FILENAME__ = StyleSheet
from helper import *

def doTest():
    _stylesheet()

def _stylesheet():
    styleSheet = StyleSheet('test.css')
    equal(styleSheet.getFile(), 'test.css', 'file name is ok')
    styleSheet.setFile('test2.css')
    equal(styleSheet.getFile(), 'test2.css', 'file nam changed')
    equal(styleSheet._file, styleSheet.getFile(), 'it is the same')

    equal(len(styleSheet.getRuleSets()), 0, 'no rule sets')
    equal(styleSheet.getRuleSetBySelector('.test'), None, 'can not find .test')

    styleSheet.addRuleSetByStr('.test', 'width:100px;height:100px', '/* fjdalkf */')
    equal(len(styleSheet.getRuleSets()), 1, 'one rule set')
    equal(styleSheet.getRuleSetBySelector('.test').selector, '.test', 'find .test')
    equal(styleSheet._ruleSets[0].comment, '/* fjdalkf */', 'comment is ok')

########NEW FILE########
__FILENAME__ = CommentForExtraStatement
from helper import *

def doTest():
    _with_comment()
    _without_comment()

def _with_comment():
    css = '''/**
 * @descript: topic pages
 * @author: ming.zhou
 * @date: 2012-12-7
 */

@import url(dfafdas);

@import url(dfafdas);'''

    expectedFixed = '''/**
 * @descript: topic pages
 * @author: ming.zhou
 * @date: 2012-12-7
 */
@import url(dfafdas);

@import url(dfafdas);
'''

    fixer, msg = doFix(css, '')
    equal(msg.strip(), expectedFixed.strip(), 'extra statement with comment is ok')
    
def _without_comment():
    css = '''

@import url(dfafdas);

@import url(dfafdas);'''

    expectedFixed = '''@import url(dfafdas);

@import url(dfafdas);
'''

    fixer, msg = doFix(css, '')
    equal(msg.strip(), expectedFixed.strip(), 'extra statement without comment is ok')
    

########NEW FILE########
__FILENAME__ = ExtraCss3Prefix
from helper import *

def doTest():
    _not_listed()
    _both_not_listed()

def _both_not_listed():
    css = '''html {
  -webkit-hyphens: auto;
  -moz-hyphens: auto;
  -ms-hyphens: auto;
  -o-hyphens: auto;
  hyphens: auto;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}'''

    expectedFixed = '''html {
    -webkit-hyphens: auto;
       -moz-hyphens: auto;
        -ms-hyphens: auto;
         -o-hyphens: auto;
            hyphens: auto;
    -webkit-user-select: none;
       -moz-user-select: none;
        -ms-user-select: none;
}'''

    fixer, msg = doFix(css, '')
    equal(msg.strip(), expectedFixed.strip(), 'both css3 prop not listed is ok')
    
def _not_listed():
    css = '''.html {
        -moz-box-sizing: 1px;
        -webkit-box-sizing: 1px;
        box-sizing: 1px;
    }'''

    expectedFixed = '''.html {
    -webkit-box-sizing: 1px;
       -moz-box-sizing: 1px;
            box-sizing: 1px;
}'''

    fixer, msg = doFix(css, '')
    equal(msg.strip(), expectedFixed.strip(), 'css3 prefix box-sizing is ok')

########NEW FILE########
__FILENAME__ = FEDCombineSameRuleSets
from helper import *

def doTest():
    _combine_should_not_make_mistake()
    _totally_same_ruleset()
    do_not_touch_background_position()
    _do_not_change_comment()

def _combine_should_not_make_mistake():
    css = '''.a {width:0px} 
.a, .b{width:1px}
.b{width:0px}'''

    expected = '''.a {
    width: 0;
}

.a,
.b {
    width: 1px;
}

.b {
    width: 0;
}'''
    fixer, msg = doFix(css, '')
    equal(msg, expected, 'do not make mistake when combine rulesets');

def do_not_touch_background_position():
    css = '''.a {background-position: 0 0} 
.test {width:1}
.b {background-position: 0 0} '''

    expected = '''.a {
    background-position: 0 0;
}

.test {
    width: 1;
}

.b {
    background-position: 0 0;
}'''
    fixer, msg = doFix(css, '')
    equal(msg, expected, 'do not combine background-position');

def _totally_same_ruleset():
    css = '''/*fdafda*/
.page-title {
   width: 100px;
   padding: 0px 1px;
}

.page-title {
   width: 100px;
   padding: 0px 1px;
}'''

    expected = '''/* fdafda */
.page-title {
    width: 100px;
    padding: 0 1px;
}'''
    fixer, msg = doFix(css, '')
    equal(msg, expected, 'it is the same ruleset');

def _do_not_change_comment():
    css = '''/*fdafda, fda,fda,fdas
    */
.page-title {
   width: 100px;
   padding: 0px 1px;
}

.page-title {
   width: 100px;
   padding: 0px 1px;
}'''

    expected = '''/*fdafda, fda,fda,fdas
    */
.page-title {
    width: 100px;
    padding: 0 1px;
}'''
    fixer, msg = doFix(css, '')
    equal(msg, expected, 'do not change comment is ok');
########NEW FILE########
__FILENAME__ = FEDFixNestedStatement
from helper import *

def doTest():
    _handle_nested_statement()
    _handle_nested_statement_qipa()

def _handle_nested_statement():
    css = '''@media screen and (-webkit-min-device-pixel-ratio:0) {
 .publisher-c .global-publisher-selector{ top:5px;}
 .publisher-a .global-publisher-selector-status a,
 .publisher-a .global-publisher-selector-status .global-publisher-status-trigger:hover,
 .publisher-a .global-publisher-selector .active .global-publisher-status-trigger {
    background-position: 0 1px;
}
 .publisher-a .global-publisher-selector-share a,
 .publisher-a .global-publisher-selector-share a:hover,
 .publisher-a .global-publisher-selector .active .global-publisher-share-trigger{
    background-position: 0 -48px;
 }
}'''

    expectedFixed = '''@media screen and (-webkit-min-device-pixel-ratio:0) {
    .publisher-c .global-publisher-selector {
        top: 5px;
    }
    
    .publisher-a .global-publisher-selector-status a,
    .publisher-a .global-publisher-selector-status .global-publisher-status-trigger:hover,
    .publisher-a .global-publisher-selector .active .global-publisher-status-trigger {
        background-position: 0 1px;
    }
    
    .publisher-a .global-publisher-selector-share a,
    .publisher-a .global-publisher-selector-share a:hover,
    .publisher-a .global-publisher-selector .active .global-publisher-share-trigger {
        background-position: 0 -48px;
    }
}'''

    fixer, msg = doFix(css, '')
    equal(msg.strip(), expectedFixed.strip(), 'nested statement is ok')

def _handle_nested_statement_qipa():
    css = '''@-moz-keyframes hinge {
    0% { -moz-transform: rotate(0); -o-transform: rotate(0); -moz-transform-origin: top left; -moz-animation-timing-function: ease-in-out; }    
    20%, 60% { -moz-transform: rotate(80deg); -moz-transform-origin: top left; -moz-animation-timing-function: ease-in-out; }   
    40% { -moz-transform: rotate(60deg); -moz-transform-origin: top left; -moz-animation-timing-function: ease-in-out; }    
    80% { -moz-transform: rotate(60deg) translateY(0); opacity: 1; -moz-transform-origin: top left; -moz-animation-timing-function: ease-in-out; }  
    100% { -moz-transform: translateY(700px); opacity: 0; }
}'''

    expectedFixed = '''@-moz-keyframes hinge {
    0% {
        -moz-animation-timing-function: ease-in-out;
           -moz-transform: rotate(0);
             -o-transform: rotate(0);
        -moz-transform-origin: top left;
    }
    
    20%,
    60% {
        -moz-animation-timing-function: ease-in-out;
        -moz-transform: rotate(80deg);
        -moz-transform-origin: top left;
    }
    
    40% {
        -moz-animation-timing-function: ease-in-out;
        -moz-transform: rotate(60deg);
        -moz-transform-origin: top left;
    }
    
    80% {
        -moz-animation-timing-function: ease-in-out;
        -moz-transform: rotate(60deg) translateY(0);
        -moz-transform-origin: top left;
        opacity: 1;
    }
    
    100% {
        -moz-transform: translateY(700px);
        opacity: 0;
    }
}'''

    fixer, msg = doFix(css, '')
    equal(msg.strip(), expectedFixed.strip(), 'qipa nested statement is ok')

    
########NEW FILE########
__FILENAME__ = FixAllInSafeMode
from helper import *

def doTest():
    _singleLine()
    _multiLine()

def _singleLine():
    defaultConfig.safeMode = True
    fixer, msg = doFix('.test {width:"100px";color:#DDDDDD;margin:0 auto 0 auto;} .test2 {width:"100px";color:#DDDDDD;margin-top:0;margin-left:auto;margin-right:auto;margin-bottom:0;}', fileName = '', config = defaultConfig)
    defaultConfig.safeMode = False
    equal(msg, 
'''.test {
    width: '100px';
    margin: 0 auto;
    color: #DDD;
}

.test2 {
    width: '100px';
    margin: 0 auto;
    color: #DDD;
}''', 'safe mode true, fix is ok')

def _multiLine():
    fixer, msg = doFix('.test {width:"100px";color:#DDDDDD;margin:0 auto 0 auto;} .test2 {width:"100px";color:#DDDDDD;margin-top:0;margin-left:auto;margin-right:auto;margin-bottom:0;}', '')
    equal(msg, 
'''.test,
.test2 {
    width: '100px';
    margin: 0 auto;
    color: #DDD;
}''', 'default safeMode is false, fix is ok')

########NEW FILE########
__FILENAME__ = FixComplicatedStatement
from helper import *

def doTest():
    _handle_complicated_statement()

def _handle_complicated_statement():
    css = '''.ui-bar-a {
    border: 1px solid       #333 /*{a-bar-border}*/;
    background:             #111 /*{a-bar-background-color}*/;
    color:                  #fff /*{a-bar-color}*/;
    font-weight: bold;
    text-shadow: 0 /*{a-bar-shadow-x}*/ -1px /*{a-bar-shadow-y}*/ 1px /*{a-bar-shadow-radius}*/ #000 /*{a-bar-shadow-color}*/;
    background-image: -webkit-gradient(linear, left top, left bottom, from( #3c3c3c /*{a-bar-background-start}*/), to( #111 /*{a-bar-background-end}*/)); /* Saf4+, Chrome */
    background-image: -webkit-linear-gradient( #3c3c3c /*{a-bar-background-start}*/, #111 /*{a-bar-background-end}*/); /* Chrome 10+, Saf5.1+ */
    background-image:    -moz-linear-gradient( #3c3c3c /*{a-bar-background-start}*/, #111 /*{a-bar-background-end}*/); /* FF3.6 */
    background-image:     -ms-linear-gradient( #3c3c3c /*{a-bar-background-start}*/, #111 /*{a-bar-background-end}*/); /* IE10 */
    background-image:      -o-linear-gradient( #3c3c3c /*{a-bar-background-start}*/, #111 /*{a-bar-background-end}*/); /* Opera 11.10+ */
    background-image:         linear-gradient( #3c3c3c /*{a-bar-background-start}*/, #111 /*{a-bar-background-end}*/);
}

.ui-bar-a .ui-link-inherit {
    color: #fff /*{a-bar-color}*/;
}'''

    expectedFixed = '''.ui-bar-a {
    border: 1px solid #333;
    background: #111;
    background-image: -webkit-gradient(linear,left top,left bottom,from(#3C3C3C),to(#111));
    background-image: -webkit-linear-gradient(#3C3C3C,#111);
    background-image: -moz-linear-gradient(#3C3C3C,#111);
    background-image: -ms-linear-gradient(#3C3C3C,#111);
    background-image: -o-linear-gradient(#3C3C3C,#111);
    background-image: linear-gradient(#3C3C3C,#111);
    color: #FFF;
    font-weight: bold;
    text-shadow: 0 -1px 1px #000;
}

.ui-bar-a .ui-link-inherit {
    color: #FFF;
}'''

    fixer, msg = doFix(css, '')
    equal(msg.strip(), expectedFixed.strip(), 'complicated statement is ok')
########NEW FILE########
__FILENAME__ = FixFEDCombineInToOne
from helper import *

def doTest():
    equal(getFixed('.test {margin:0 0 0 0}', 'margin'), '0', 'margin is fixed')
    equal(getFixed('.test {margin:0 auto 0 auto}', 'margin'), '0 auto', 'margin 2 is fixed')
    equal(getFixed('.test {margin:auto 0 0 auto}', 'margin'), 'auto 0 0 auto', 'margin 3 is fixed')
    equal(getFixed('.test {margin:0 0}', 'margin'), '0', 'margin 4 is fixed')
    equal(getFixed('.test {margin:0px 0}', 'margin'), '0', 'margin 5 is fixed')
    equal(getFixed('.test {margin:0px 1px 0px 1px}', 'margin'), '0 1px', 'margin 6 is fixed')
    equal(getFixed('.test {margin:0px auto 0px auto}', 'margin'), '0 auto', 'margin 7 is fixed')
    equal(getFixed('.test {margin:50px auto 0 auto}', 'margin'), '50px auto 0', 'margin 8 is fixed')
    equal(getFixed('.test {margin: -15px -15px 0 -15px}', 'margin'), '-15px -15px 0', 'margin 9 is fixed')

########NEW FILE########
__FILENAME__ = FixFEDCss3PropSpaces
from helper import *

def doTest():
    fixer, msg = doFix('.test {-webkit-border-radius: 3px;-moz-border-radius:3px;border-radius:3px;}', '')
    equal(msg, '.test {\n    -webkit-border-radius: 3px;\n       -moz-border-radius: 3px;\n            border-radius: 3px;\n}', 'ok')

    fixer, msg = doFix('.test {border-radius:3px;}', '')
    equal(msg, '.test {\n    border-radius: 3px;\n}', 'ok')

########NEW FILE########
__FILENAME__ = FixFEDHexColorShouldUpper
from helper import *

def doTest():
    _color()
    _complicated_color()
    _special()

def _complicated_color():
    fixer, msg = doFix('.test {background0:#dddddd url(dddddd) no-repeat left top;}', '')
    styleSheet = fixer.getStyleSheet()
    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.getRuleByName('background0').fixedValue, '#DDD url(dddddd) no-repeat left top', 'bgcolor 0 ok')
    
    fixer, msg = doFix('.test {border:1px solid #ffffff;}', '')
    styleSheet = fixer.getStyleSheet()
    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.getRuleByName('border').fixedValue, '1px solid #FFF', 'border is ok')

    fixer, msg = doFix('.test {border:1px solid red;}', '')
    styleSheet = fixer.getStyleSheet()
    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.getRuleByName('border').fixedValue, '1px solid red', 'red border is ok')

def _color():
    fixer, msg = doFix('.test {color0:red;color1:#DDD;color2:#DDDDDD;color3:#dddddd;color4:#ddd;color5:#DDFFCC;color6:#ABCDEF;color7:#ABCDEFGH;color8:#abcdef;color9:#ffff;color10:#f;}', '')

    styleSheet = fixer.getStyleSheet()
    equal(len(styleSheet.getRuleSets()), 1, 'one ruleset')
    equal(len(styleSheet.getRuleSets()[0].getRules()), 11, 'eleven rules')

    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.getRuleByName('color0').fixedValue, 'red', 'color0 ok')
    equal(ruleSet.getRuleByName('color1').fixedValue, '#DDD', 'color1 ok')
    equal(ruleSet.getRuleByName('color2').fixedValue, '#DDD', 'color2 ok')
    equal(ruleSet.getRuleByName('color3').fixedValue, '#DDD', 'color3 ok')
    equal(ruleSet.getRuleByName('color4').fixedValue, '#DDD', 'color4 ok')
    equal(ruleSet.getRuleByName('color5').fixedValue, '#DFC', 'color5 ok')
    equal(ruleSet.getRuleByName('color6').fixedValue, '#ABCDEF', 'color6 ok')
    equal(ruleSet.getRuleByName('color7').fixedValue, '#ABCDEFGH', 'color7 ok')
    equal(ruleSet.getRuleByName('color8').fixedValue, '#ABCDEF', 'color8 ok')
    equal(ruleSet.getRuleByName('color9').fixedValue, '#FFF', 'color9 ok')
    equal(ruleSet.getRuleByName('color10').fixedValue, '#FFF', 'color10 ok')

def _special():
    css = '.t{box-shadow:0 4px 5px 1px rgba(74, 116, 161, 0.1), inset 0 -1px #cadaea, inset 0 -2px #fbfcfe;}'
    fixer, msg = doFix(css, '')
    ruleSet = fixer.getStyleSheet().getRuleSets()[0]
    rule = ruleSet.getRules()[0]
    equal(rule.fixedValue, '0 4px 5px 1px rgba(74, 116, 161, .1), inset 0 -1px #CADAEA, inset 0 -2px #FBFCFE', 'fixed ok')

########NEW FILE########
__FILENAME__ = FixFEDNoEmptyRuleSet
from helper import *

def doTest():
    fixer, msg = doFix('.test {} .test2 {} .test3 {width:100px;} .test4 {}', '')

    styleSheet = fixer.getStyleSheet()
    equal(len(styleSheet.getRuleSets()), 1, 'one ruleset')
    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.selector, '.test3', 'it is test3')
    width = ruleSet.getRuleByName('width')
    equal(width.fixedValue,  "100px", 'width is fixed')
    equal(width.value, '100px', 'value of width is origin')

########NEW FILE########
__FILENAME__ = FixFEDNoUnitAfterZero
from helper import *

def doTest():
    _rgba()
    _rgba_no_space()

def _rgba_no_space():
    css = '''.test1 {
        box-shadow: inset 0 0px 0 0 rgba(0,0px,0px,0.1);
    }'''

    fixer, msg = doFix(css, '')
    expectedFixed = '''.test1 {
    box-shadow: inset 0 0 0 0 rgba(0,0,0,.1);
}'''
    equal(msg, expectedFixed, 'rgba no space is also ok')


def _rgba():
    css = '''html {
        -webkit-tap-highlight-color: rgba(0px, 0px, 0px, 0.1);
    }'''

    fixer, msg = doFix(css, '')

    styleSheet = fixer.getStyleSheet()
    ruleSet = styleSheet.getRuleSets()[0]
    color = ruleSet.getRuleByName('tap-highlight-color')
    equal(color.fixedValue, 'rgba(0, 0, 0, .1)', 'tap-highlight-color is fixed')
    equal(color.value, 'rgba(0px, 0px, 0px, 0.1)', 'tap-highlight-color is ok')

    css = '''.current-hot-films-ul {
        -webkit-transition:all 0.5s ease-in-out 0s;
           -moz-transition:all 0.5s ease-in-out 0s; 
             -o-transition:all 0.5s ease-in-out 0s;
                transition:all 0.5s ease-in-out 0s;
    }'''
    expectedFixed = '''.current-hot-films-ul {
    -webkit-transition: all .5s ease-in-out 0s;
       -moz-transition: all .5s ease-in-out 0s;
         -o-transition: all .5s ease-in-out 0s;
            transition: all .5s ease-in-out 0s;
}'''

    fixer, msg = doFix(css, '')
    equal(msg.strip(), expectedFixed.strip(), 'transition is ok, 0s can not be shorter')

########NEW FILE########
__FILENAME__ = FixFEDOutlineNone
from helper import *

def doTest():
    _try()

def _try():
    fixer, msg = doFix('.test {outline:none;}', '')
    equal(msg, '''.test {
    outline: 0;
}''', 'outline fix ok')

########NEW FILE########
__FILENAME__ = FixFEDUseLowerCaseSelector
from helper import *

def doTest():
    _lower()
    _upper()

def _lower():
    fixer, msg = doFix('.test {width:100px;}', '')
    styleSheet = fixer.getStyleSheet()
    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.fixedSelector, '.test', 'selector lower is ok')

def _upper():
    # if fix upper to lower, will cause error in HTML, do not do evil
    return
    fixer, msg = doFix('.TEST {width:100px;}', '')
    styleSheet = fixer.getStyleSheet()
    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.fixedSelector, '.test', 'selector all upper is ok')

    fixer, msg = doFix('.Test {width:100px;}', '')
    styleSheet = fixer.getStyleSheet()
    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.fixedSelector, '.test', 'selector one upper is ok')

    fixer, msg = doFix('.Test-WRAPPER {width:100px;}', '')
    styleSheet = fixer.getStyleSheet()
    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.fixedSelector, '.test-wrapper', 'selector upper with - is ok')

########NEW FILE########
__FILENAME__ = FixPropStartWithSharp
from helper import *

def doTest():
    go()

def go():
    css = '''.theme-hot li {
    float: left;
    padding: 0 10px 0 2px;
    #padding: 1px 10px 0 2px;
    padding: 1px 10px 0 2px\\0;
    _padding: 3px 10px 0 2px;
}'''

    expectedFixed = '''.theme-hot li {
    float: left;
    padding: 0 10px 0 2px;
    #padding: 1px 10px 0 2px;
    padding: 1px 10px 0 2px\\0;
    _padding: 3px 10px 0 2px;
}'''

    fixer, msg = doFix(css, '')
    equal(msg.strip(), expectedFixed.strip(), '#padding is ok, do not combine attr which in hack')
    

########NEW FILE########
__FILENAME__ = FixRuleSetsFormat
from helper import *

def doTest():
    _singleLine()
    _multiLine()

def _singleLine():
    defaultConfig.fixToSingleLine = True
    fixer, msg = doFix('.test {width:"100px";color:#DDDDDD;} .test2 {width:"100px";color:#DDDDDD;}', fileName = '', config = defaultConfig)
    defaultConfig.fixToSingleLine = False
    equal(msg, '''.test,
.test2 { width: '100px'; color: #DDD; }''', 'fix to single line is ok')

def _multiLine():
    fixer, msg = doFix('.test {width:"100px";color:#DDDDDD;} .test2 {width:"100px";color:#DDDDDD;}', '')
    equal(msg, '''.test,
.test2 {
    width: '100px';
    color: #DDD;
}''', 'fix to multi line is ok')

########NEW FILE########
__FILENAME__ = helper
import os
import sys
sys.path.insert(0, os.path.realpath(os.path.join(__file__, '../../')))
for p in os.environ.get('PYTHONPATH', '').split(';'):
    sys.path.append(p)

from asserts import *
from ckstyle.doCssFix import doFix
import ckstyle.command.args as args
defaultConfig = args.CommandArgs()

def getFixed(css, name):
    fixer, msg = doFix(css, '')

    ruleSet = fixer.getStyleSheet().getRuleSets()[0]
    rule = ruleSet.getRuleByName(name)
    return rule.fixedValue

########NEW FILE########
__FILENAME__ = SoManyColors
from helper import *

def doTest():
    css = '''.ui-dialog .ui-dialog-content .btn.confirm {
  background-color: #2996e3;
  background-image: -moz-linear-gradient(top, #2692de, #2d9deb);
  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#2692de), to(#2d9deb));
  background-image: -webkit-linear-gradient(top, #2692de, #2d9deb);
  background-image: -o-linear-gradient(top, #2692de, #2d9deb);
  background-image: linear-gradient(to bottom, #2692de, #2d9deb);
  background-repeat: repeat-x;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff2692', endColorstr='#ff2d9d', GradientType=0);
  color: #ffffff;
  text-shadow: 0 1px 1px rgba(255, 255, 255, 0.75);
  border-color: #2D9DEB;
}'''

    expected = '''.ui-dialog .ui-dialog-content .btn.confirm {
    border-color: #2D9DEB;
    background-color: #2996E3;
    background-image: -moz-linear-gradient(top,#2692DE,#2D9DEB);
    background-image: -webkit-gradient(linear,0 0,0 100%,from(#2692DE),to(#2D9DEB));
    background-image: -webkit-linear-gradient(top,#2692DE,#2D9DEB);
    background-image: -o-linear-gradient(top,#2692DE,#2D9DEB);
    background-image: linear-gradient(to bottom,#2692DE,#2D9DEB);
    background-repeat: repeat-x;
    color: #FFF;
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#FF2692',endColorstr='#FF2D9D',GradientType=0);
    text-shadow: 0 1px 1px rgba(255,255,255,.75);
}'''
    fixer, msg = doFix(css, '')
    equal(msg, expected, 'so many colors are ok');

########NEW FILE########
__FILENAME__ = Try
from helper import *

def doTest():
    fixer, msg = doFix('.test {width:"100px";color:#DDDDDD;}', '')

    styleSheet = fixer.getStyleSheet()
    equal(len(styleSheet.getRuleSets()), 1, 'one ruleset')
    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.selector, '.test', 'it is the selector that i need')
    width = ruleSet.getRuleByName('width')
    equal(width.fixedValue,  "'100px'", 'width is fixed')
    equal(width.value, '"100px"', 'value of width is origin')

    color = ruleSet.getRuleByName('color')
    equal(color.fixedValue, '#DDD', 'color is fixed')
    equal(color.value, '#DDDDDD', 'value of color is origin')

########NEW FILE########
__FILENAME__ = HackExtras
from helper import *

def doTest():
	_standard_hack()
	_keyframes()

def _standard_hack():
    equal(doExtraDetect('@media screen and (max-device-width: 480px)'.replace(' ', '')), WEBKIT, 'webkit mobile hack is ok')
    equal(doExtraDetect('@media screen and (-webkit-min-device-pixel-ratio:0)'.replace(' ', '')), WEBKIT, 'webkit hack is ok')
    equal(doExtraDetect('@media all and (-webkit-min-device-pixel-ratio:10000), not all and (-webkit-min-device-pixel-ratio:0)'.replace(' ', '')), OPERA, 'opera hack is ok')

def _keyframes():
	equal(doExtraDetect('@keyframes fda'), NONEIE | IE9PLUS, '@keyframes')
	equal(doExtraDetect('@-webkit-keyframes fda'), WEBKIT, '@-webkit-keyframes')
	equal(doExtraDetect('@-moz-keyframes fda'), FIREFOX, '@-moz-keyframes')
	equal(doExtraDetect('@-ms-keyframes fda'), IE9PLUS, '@-ms-keyframes')
	equal(doExtraDetect('@-o-keyframes fda'), OPERA, '@-o-keyframes')
########NEW FILE########
__FILENAME__ = HackRules
from helper import *

def doTest():
	_ie()
	_other()
	#_ms()
	#_moz()
	#_o()

def _ie():
	equal(doRuleDetect('_width', 'fd'), IE6, '_width')
	equal(doRuleDetect('*width', 'fd'), IE6 | IE7, '*width')
	equal(doRuleDetect('+width', 'fd'), IE6 | IE7, '+width')
	equal(doRuleDetect('width', r'fd\9'), ALLIE, 'width\\9')
	equal(doRuleDetect('width', r'fd\0/'), IE8, 'width\\0/')
	equal(doRuleDetect('width', r'fd\0'), IE8 | IE9PLUS, 'width\\0')
	equal(doRuleDetect('zoom', '1'), ALLIE, 'zoom')
	equal(doRuleDetect('behavior', '1'), ALLIE, 'behavior')
	equal(doRuleDetect('filter', '1'), ALLIE, 'filter')
	equal(doRuleDetect('width', 'xxxx.Microsoft.AlphaImageLoader'), ALLIE, 'Microsoft')
	equal(doRuleDetect('width', 'xxxx.microsoft.AlphaImageLoader'), ALLIE, 'microsoft')
	equal(doRuleDetect('width', 'expression()'), ALLIE, 'expression')

def _other():
	equal(doRuleDetect('-webkit-transition', 'fd'), WEBKIT, '-webkit-transition')
	equal(doRuleDetect('-moz-transition', 'fd'), FIREFOX, '-moz-transition')
	equal(doRuleDetect('-ms-transition', 'fd'), IE9PLUS, '-ms-transition')
	equal(doRuleDetect('-khtml-transition', 'fd'), ALLIE, '-khtml-transition')
	equal(doRuleDetect('-o-transition', 'fd'), OPERA, '-o-transition')

	equal(doRuleDetect('background', '-webkit-linear-gradient()'), WEBKIT, '-webkit-gradient')
	equal(doRuleDetect('background', '-moz-linear-gradient()'), FIREFOX, '-moz-gradient')
	equal(doRuleDetect('background', '-ms-linear-gradient()'), IE9PLUS, '-ms-gradient')
	equal(doRuleDetect('background', '-khtml-linear-gradient()'), ALLIE, '-khtml-gradient')
	equal(doRuleDetect('background', '-o-linear-gradient()'), OPERA, '-o-gradient')
########NEW FILE########
__FILENAME__ = HackRuleSets
from helper import *

def doTest():
	equal(doRuleSetDetect('* html .test'), IE6, '* html')
	equal(doRuleSetDetect('* + html .test'), IE7, '* + html')
	equal(doRuleSetDetect('*:first-child+html .test'), IE7, '*:first-child+html .test')
	equal(doRuleSetDetect('html > body .test'), IE7 | IE8 | IE9PLUS, 'html > body')
	equal(doRuleSetDetect('html>/**/body .test'), IE8 | IE9PLUS, 'html>/**/body')
	equal(doRuleSetDetect('::-webkit-selection {}'), WEBKIT, '::-webkit-selection')
	equal(doRuleSetDetect('::-moz-selection {}'), FIREFOX, '::-moz-selection')
	equal(doRuleSetDetect('::-ms-selection {}'), IE9PLUS, '::-ms-selection')
	equal(doRuleSetDetect('::-o-selection {}'), OPERA, '::-o-selection')
########NEW FILE########
__FILENAME__ = helper
import os
import sys
sys.path.insert(0, os.path.realpath(os.path.join(__file__, '../../')))
for p in os.environ.get('PYTHONPATH', '').split(';'):
    sys.path.append(p)

from asserts import *
from ckstyle.browsers.BinaryRule import *
from ckstyle.browsers.Hacks import *

########NEW FILE########
__FILENAME__ = helper
import os
import sys
sys.path.insert(0, os.path.realpath(os.path.join(__file__, '../../')))
for p in os.environ.get('PYTHONPATH', '').split(';'):
    sys.path.append(p)

from asserts import *
from ckstyle.doCssFix import doFix

########NEW FILE########
__FILENAME__ = InAMessOrder
from helper import *


def doTest():
    fixer, msg = doFix("a.feed-back-v6 { display: block; position: fixed; _position: absolute; top: 155px; _top: expression(documentElement.scrollTop + 'px'); _margin-top: 155px; right: 0; padding: 10px; font-size: 14px; font-weight: bold; width: 1em; background: #F7F7FF; z-index: 1999; }", '')

    equal(fixer.doCompress(), "a.feed-back-v6{display:block;position:fixed;_position:absolute;top:155px;_top:expression(documentElement.scrollTop + 'px');right:0;width:1em;_margin-top:155px;padding:10px;background:#F7F7FF;font-size:14px;font-weight:bold;z-index:1999}", 'compress feed-back-v6 is ok')

    styleSheet = fixer.getStyleSheet()
    equal(len(styleSheet.getRuleSets()), 1, 'one ruleset')
    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.selector, 'a.feed-back-v6', 'yes it is a.feed-back-v6')

    rules = ruleSet.getRules()
    equal(rules[0].name, 'display', 'element name is ok')
    equal(rules[1].name, 'position', 'element name is ok')
    equal(rules[2].name, 'position', 'element name is ok')
    equal(rules[3].name, 'top', 'element name is ok')
    equal(rules[4].name, 'top', 'element name is ok')
    equal(rules[5].name, 'right', 'element name is ok')
    equal(rules[6].name, 'width', 'element name is ok')
    equal(rules[7].name, 'margin-top', 'element name is ok')
    equal(rules[8].name, 'padding', 'element name is ok')
    equal(rules[9].name, 'background', 'element name is ok')
    equal(rules[10].name, 'font-size', 'element name is ok')
    equal(rules[11].name, 'font-weight', 'element name is ok')
    equal(rules[12].name, 'z-index', 'element name is ok')

########NEW FILE########
__FILENAME__ = Try
from helper import *

def doTest():
    fixer, msg = doFix('.test {width:100px; display:none;}', '')

    styleSheet = fixer.getStyleSheet()
    equal(len(styleSheet.getRuleSets()), 1, 'one ruleset')
    ruleSet = styleSheet.getRuleSets()[0]
    equal(ruleSet.selector, '.test', 'it is the selector that i need')

    rules = ruleSet.getRules()
    equal(rules[0].name, 'display', 'first element is display now')
    equal(rules[1].name, 'width', 'second element is width')

    equal(rules[0].value, 'none', 'first element value is ok')
    equal(rules[1].value, '100px', 'second element value is ok')

########NEW FILE########
__FILENAME__ = ExtraStatement
from helper import *

def doTest():
    _withEnter()
    _withoutEnter()

def _withoutEnter():
    parser = CssParser('@import url(xxxx);@charset utf-8;.test {_width : 100px;}')
    parser.doParse()
    ok(parser is not None, 'parser is not None')
    ok(parser.styleSheet is not None, 'parser.styleSheet is not None')
    equal(len(parser.styleSheet.getRuleSets()), 3, 'three rule set')

    styleSheet = parser.styleSheet
    importer = styleSheet.getRuleSets()[0]
    ok(importer.extra, 'import is extra')
    ok(importer.isImport(), 'it is import')
    equal(importer.operator, '@import', 'it is @import')
    equal(importer.statement, '@import url(xxxx);', 'statement is ok')

    charset = styleSheet.getRuleSets()[1]
    ok(charset.extra, 'charset is extra')
    ok(not charset.isImport(), 'it is not import')
    equal(charset.operator, '@charset', 'it is @charset')
    equal(charset.statement, '@charset utf-8;', 'statement is ok')

    rule = styleSheet.getRuleSets()[2]
    ok(not rule.extra, 'not extra')
    equal(rule.selector, '.test', 'selector is ok')
    equal(rule.getRuleByName('width').value, '100px', 'value is ok')

def _withEnter():
    parser = CssParser('@import url(xxxx);\n@charset utf-8;\n.test {_width : 100px;}')
    parser.doParse()
    ok(parser is not None, 'parser is not None')
    ok(parser.styleSheet is not None, 'parser.styleSheet is not None')
    equal(len(parser.styleSheet.getRuleSets()), 3, 'three rule set')

    styleSheet = parser.styleSheet
    importer = styleSheet.getRuleSets()[0]
    ok(importer.extra, 'import is extra')
    ok(importer.isImport(), 'it is import')
    equal(importer.operator, '@import', 'it is @import')
    equal(importer.statement, '@import url(xxxx);', 'statement is ok')

    charset = styleSheet.getRuleSets()[1]
    ok(charset.extra, 'charset is extra')
    ok(not charset.isImport(), 'it is not import')
    equal(charset.operator, '@charset', 'it is @charset')
    equal(charset.statement, '@charset utf-8;', 'statement is ok')

    rule = styleSheet.getRuleSets()[2]
    ok(not rule.extra, 'not extra')
    equal(rule.selector, '.test', 'selector is ok')
    equal(rule.getRuleByName('width').value, '100px', 'value is ok')

########NEW FILE########
__FILENAME__ = helper
import os
import sys
sys.path.insert(0, os.path.realpath(os.path.join(__file__, '../../')))
for p in os.environ.get('PYTHONPATH', '').split(';'):
    sys.path.append(p)

from asserts import *
from ckstyle.cssparser.CssFileParser import CssParser

########NEW FILE########
__FILENAME__ = NestedStatement
from helper import *

def doTest():
    _withoutEnter()

def _withoutEnter():
    parser = CssParser("@keyframes 'blala' {10% {width: 100px;} 20% {width: 300px;}}@keyframes 'blala2' {10% {width: 200px;}}.test {_width : 100px;}")
    parser.doParse()
    ok(parser is not None, 'parser is not None')
    ok(parser.styleSheet is not None, 'parser.styleSheet is not None')
    equal(len(parser.styleSheet.getRuleSets()), 3, 'three rule set')

    styleSheet = parser.styleSheet
    first = styleSheet.getRuleSets()[0]
    ok(first.extra, 'keyframes is extra')
    equal(first.selector, "@keyframes 'blala'", 'it is @keyframes')
    equal(first.statement, '10% {width: 100px;} 20% {width: 300px;}', 'statement is ok')

    second = styleSheet.getRuleSets()[1]
    ok(second.extra, 'keyframes is extra')
    equal(second.selector, "@keyframes 'blala2'", 'it is @keyframes')
    equal(second.statement, '10% {width: 200px;}', 'statement is ok')

    rule = styleSheet.getRuleSets()[2]
    ok(not rule.extra, 'not extra')
    equal(rule.selector, '.test', 'selector is ok')
    equal(rule.getRuleByName('width').value, '100px', 'value is ok')

########NEW FILE########
__FILENAME__ = ParserAndEntities
from helper import *

def doTest():
    _oneRule()
    _twoAndMoreRules()
    _rulesInComments()
    _strangeComments()

def _strangeComments():
    parser = CssParser('/* test0 /* test1 */ .test {width: 100px;}')
    parser.doParse()
    equal(len(parser.styleSheet.getRuleSets()), 1, 'one ruleset')
    ruleSet1 = parser.styleSheet.getRuleSetBySelector('.test')
    equal(ruleSet1.comment, '/* test0  test1 */', 'strange comment is ok')

def _rulesInComments():
    parser = CssParser('/* test0 */ /* test1 */ .test {width: 100px;} \n /* test2 */ /* test3 */ .test2 {width: 100px;}')
    parser.doParse()

    equal(len(parser.styleSheet.getRuleSets()), 2, 'two ruleSets')
    ruleSet1 = parser.styleSheet.getRuleSetBySelector('.test')
    ruleSet2 = parser.styleSheet.getRuleSetBySelector('.test2')
    ok(ruleSet1.comment.find('test0') != -1, 'comment contains test0')
    ok(ruleSet1.comment.find('test1') != -1, 'comment contains test1')

    ok(ruleSet2.comment.find('test2') != -1, 'comment contains test2')
    ok(ruleSet2.comment.find('test3') != -1, 'comment contains test3')

    equal(len(ruleSet2.comment.split('\n')), 2, 'string seperated by enter')
    equal(ruleSet1.selector, '.test', 'selector is ok')
    equal(ruleSet2.selector, '.test2', 'selector is ok')

    equal(ruleSet1.getRules()[0].name, 'width', 'first attr of selector 1 is width')
    equal(ruleSet2.getRules()[0].name, 'width', 'first attr of selector 2 is width')

    equal(len(ruleSet1.getRules()), 1, 'one rule in selector 1')
    equal(len(ruleSet2.getRules()), 1, 'one rule in selector 2')

def _twoAndMoreRules():
    parser = CssParser('.testa {width: 100px; \nheight: 100px;} .testb {width: 100px;}')
    parser.doParse()
    ok(parser.styleSheet is not None, 'parser.styleSheet is not None')
    equal(len(parser.styleSheet.getRuleSets()), 2, 'two rules')
    ruleSet1 = parser.styleSheet.getRuleSetBySelector('.testa')
    ok(ruleSet1 is not None, '.testa found')
    equal(len(ruleSet1.getRules()), 2, 'two rules')
    equal(ruleSet1.getRuleByName('width').value, '100px', 'value of width is 100px')
    equal(ruleSet1.getRuleByName('height').value, '100px', 'value of height is 100px')

    ruleSet2 = parser.styleSheet.getRuleSetBySelector('.testb')
    ok(ruleSet2 is not None, '.testb found')
    equal(ruleSet2.getRuleByName('width').value, '100px', 'value of width in .testb')

def _oneRule():
    parser = CssParser('.test {_width : 100px;}')
    parser.doParse()
    ok(parser is not None, 'parser is not None')
    ok(parser.styleSheet is not None, 'parser.styleSheet is not None')
    equal(len(parser.styleSheet.getRuleSets()), 1, 'one rule set')

    ruleSet = parser.styleSheet.getRuleSets()[0]
    equal(ruleSet.selector, '.test', 'selector is .test')
    equal(ruleSet.roughSelector, '.test ', 'roughSelector contains space')
    equal(len(ruleSet.getRules()), 1, 'one rule')

    rule = ruleSet.getRules()[0]
    equal(rule.name, 'width', 'name is width')
    equal(rule.value, '100px', 'value is 100px')
    equal(rule.roughName, '_width ', 'roughName is _width, contains space')
    equal(rule.roughValue, ' 100px;', 'roughValue contains space')
    equal(rule.strippedName, '_width', 'strippedName is _width, no space')
    equal(rule.strippedValue, '100px;', 'strippedValue contains no space')

########NEW FILE########
__FILENAME__ = helper
import os
import sys
sys.path.insert(0, os.path.realpath(os.path.join(__file__, '../../')))
for p in os.environ.get('PYTHONPATH', '').split(';'):
    sys.path.append(p)

from asserts import *
from ckstyle.doCssFix import doFix

########NEW FILE########
__FILENAME__ = TryParseKeyFrames
from helper import *

def doTest():
    pass

########NEW FILE########
__FILENAME__ = AllRules
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import isFontFamilyName

class FEDCanNotSetFontFamily(RuleChecker):
    
    '''{
        "summary":"不允许业务代码设置字体",
        "desc":"由于业务代码中随意设置字体，导致字体取值混乱，因此不允许随意在业务代码中设置字体"
    }'''

    def __init__(self):
        self.id = 'no-font-family'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'can not set font-family for "${selector}"'

    def check(self, rule, config):
        if rule.name == 'font-family':
            return False

        if rule.name == 'font':
            # many fonts
            if rule.value.find(',') != -1:
                return False

            # one font
            splited = rule.value.split(' ')
            if isFontFamilyName(splited[len(splited) - 1]):
                return False

        return True
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import canBeCombined, isCss3PrefixProp, containsHack
from combiners.CombinerFactory import doCombine

class FEDCombineInToOne(RuleSetChecker):
    
    '''{
        "summary":"将多个子样式合并",
        "desc":"有的子样式可以合并为总样式，包括
            <code>margin</code> <code>padding</code> <code>font</code> <code>background</code> <code>border</code>
            等，合并以后可以获得更好的执行效率和压缩效果，<br/>
            例如：<br/>
            <code>.test {margin:4px; margin-right:0;}</code><br/>
            <code>==></code><br/>
            <code>.test{margin:4px 0 4px 4px}</code><br/>
        "
    }'''

    def __init__(self):
        self.id = 'combine-into-one'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_rough = 'should combine "%s" to "%s" in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        rules = ruleSet.getRules()

        counter = self._countCanBeCombined(rules)

        for name, value in counter.items():
            if name == 'font' and len(value) > 2 or name != 'font' and len(value) > 1:
                self.errorMsg = self.errorMsg_rough % (','.join(value), name)
                return False
        return True 

    def fix(self, ruleSet, config):
        rules = ruleSet.getRules()
        counter = self._countCanBeCombined(rules, True)
        rules = self._combineAttrs(rules, counter)
        ruleSet.setRules(rules)

    def _countCanBeCombined(self, rules, forFix = False):
        counter = {}
        for rule in rules:
            name = rule.name
            if rule.name != rule.strippedName:
                continue
            # do not do any hack combine
            if containsHack(rule):
                continue
            # -moz-border-radius, -o-border-radius is not for me
            if isCss3PrefixProp(name):
                continue

            bigger = canBeCombined(name)
            if bigger is not None:
                if counter.has_key(bigger):
                    if forFix:
                        counter[bigger].append([name, rule.fixedName, rule.fixedValue])
                    else:
                        counter[bigger].append(name)
                else:
                    if forFix:
                        counter[bigger] = [[name, rule.fixedName, rule.fixedValue]]
                    else:
                        counter[bigger] = [name]
        return counter

    def _combineAttrs(self, rules, counter):
        originRules = rules
        for name, value in counter.items():
            combined, deleted, hasFather = doCombine(name, value)
            if combined == None:
                continue

            newRules = []
            for rule in originRules:
                if containsHack(rule):
                    newRules.append(rule)
                    continue
                # it is what i want
                if rule.fixedName == name:
                    rule.fixedValue = combined
                    newRules.append(rule)
                    continue
                # it is what i want to delete
                if rule.fixedName in deleted:
                    if not hasFather:
                        rule.reset(name, combined)
                        newRules.append(rule)
                        hasFather = True
                    continue
                newRules.append(rule)
            originRules = newRules
        return originRules
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import hasHackChars
from ckstyle.browsers.BinaryRule import ALL
class FEDCombineSameRuleSets(StyleSheetChecker):

    '''{
        "summary":"合并两个完全相同的规则集",
        "desc":"如果两个规则集完全一样，则可以进行合并。<br>
            需要指出的是：合并可能会带来功能上的问题。如果有问题，还请告知~<br>
            例如：<br>
            <code>.a {width:100px}</code><br>
            <code>.b {width:100px}</code><br>
            <code>==></code><br>
            <code>.a, .b {width:100px}</code><br>
            <br>
            <strong>安全模式下将不执行此规则</strong><br>
        "
    }'''

    def __init__(self):
        self.id = 'combine-same-rulesets'
        self.errorMsg_empty = '"%s" and "%s" contains same rules, should be combined in ${file}"'
        self.errorMsg = ''
        self.errorLevel = ERROR_LEVEL.ERROR

    # can be checked correctly only after reorder/fix/compress, so do not check
    def check(self, styleSheet, config):
        return True 

    def fix(self, styleSheet, config):
        browser = config._curBrowser if config._curBrowser is not None else ALL
        ruleSets = styleSheet.getRuleSets()
        mapping = self._gen_hash(ruleSets, browser)

        length = len(mapping)

        splitedSelectors = []
        for i in range(length):
            splitedSelectors.append([x.strip() for x in mapping[i][0].split(',') if x.strip() is not ''])

        # ".a {width:0} .a, .b{width:1}, .b{width:0}" should not be combined to ".a, .b{width:0} .a, .b{width:1}"
        for i in range(length):            
            if mapping[i][0] == 'extra':
                continue
            selectorHistory = []

            for j in range(i + 1, length):                
                if mapping[i][1] != mapping[j][1]:
                    selectorHistory.extend(splitedSelectors[j])
                    continue                    
                # bakcground-position is dangerous
                if mapping[j][1].find('background-position') != -1:
                    selectorHistory.extend(splitedSelectors[j])
                    continue

                hasFlag = False
                for x in splitedSelectors[j]:
                    if x in selectorHistory:
                        hasFlag = True
                        break
                if hasFlag:
                    selectorHistory.extend(splitedSelectors[j])
                    continue

                # make it different
                mapping[j][1] = str(i) + str(j)
                mapping[j][0] = 'extra'

                # extend target selector
                target = styleSheet.getRuleSets()[i]
                src = styleSheet.getRuleSets()[j]
                target.extendSelector(src)
                # remove rule set
                styleSheet.removeRuleSetByIndex(j)
                selectorHistory.extend(splitedSelectors[j])

        # remember to clean after remove ruleset
        styleSheet.clean()

    def _gen_hash(self, ruleSets, browser):
        mapping = []
        counter = 0
        for r in ruleSets:
            if r.extra or hasHackChars(r.selector) or r.selector.find('%') != -1:
                # make it impossible to equal
                mapping.append(['extra', "do_not_combine_" + str(counter)])
                counter = counter + 1
                continue
            mapping.append([r.selector, r.compressRules(browser)])
        return mapping
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDCommentLengthLessThan80(RuleSetChecker):

    '''{
        "summary":"注释不能超过80个字符",
        "desc":"注释长度不能超过80个字符，40个汉字，如果超出，则应该要换行~"
    }'''

    def __init__(self):
        self.id = 'comment-length'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg = 'comment for "${selector}" length should less than 80 per line'

    def check(self, ruleSet, config):
        comment = ruleSet.roughComment
        if len(comment) == 0:
            return True

        cs = comment.split('\n')
        for c in cs:
            if len(c.strip()) > 80:
                return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import isCss3Prop, isCss3PrefixProp, doNotNeedPrefixNow

class FEDCss3PropPrefix(RuleChecker):

    '''{
        "summary":"CSS3前缀相关检查",
        "desc":"CSS3属性的前缀，有的可以省略，比如：<br>
            <code>border-radius</code><br>
            有的是省略，必须写全，比如：<br><code>transition</code> <code>transform</code>等<br>
            在编写顺序上，本工具要求按照<br>
            <code>-webkit-,-moz-,-ms-,-o-,std</code><br>的顺序来编写，并且严格将属性的第一个字符对齐。"
    }'''

    def __init__(self):
        self.id = 'css3-with-prefix'
        self.errorLevel_keepInOrder = ERROR_LEVEL.WARNING
        self.errorLevel_missing = ERROR_LEVEL.ERROR
        self.errorLevel = ERROR_LEVEL.LOG

        self.errorMsg_keepInOrder = 'css3 prop "${name}" should keep in "-webkit-,-moz-,-ms-,-o-,std" order in "${selector}"'
        self.errorMsg_missing = 'css3 prop "${name}" missing some of "-webkit-,-moz-,-o-,std" in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        name = rule.name
        # only for css3 props
        if not isCss3Prop(name):
            return True

        if not isCss3PrefixProp(name):
            return True

        if doNotNeedPrefixNow(name):
            return True
        
        ruleSet = rule.getRuleSet()
        webkitName = '-webkit-' + name
        mozName = '-moz-' + name
        msName = '-ms-' + name # not necessary
        oName = '-o-' + name

        if not (ruleSet.existRoughNames(webkitName) 
                and ruleSet.existRoughNames(mozName)
                and ruleSet.existRoughNames(oName)
                and ruleSet.existRoughNames(name)):
            self.errorMsg = self.errorMsg_missing
            self.errorLevel = self.errorLevel_missing
            return False

        # in order -webkit-  -moz-  -ms-  -o-  std
        webkit = ruleSet.indexOf(webkitName)
        moz = ruleSet.indexOf(mozName)
        ms = ruleSet.indexOf(msName)
        if ms == -1:
            ms = moz
        o = ruleSet.indexOf(oName)
        std = ruleSet.indexOf(name)

        if not (webkit < moz <= ms < o < std):
            self.errorMsg = self.errorMsg_keepInOrder
            self.errorLevel = self.errorLevel_keepInOrder
            return False
        return True
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import isCss3Prop, isCss3PrefixProp, doNotNeedPrefixNow
import re

pattern = re.compile('%\d+')
class FEDCss3PropSpaces(RuleChecker):
    
    '''{
        "summary":"CSS3缩进相关检查",
        "desc":"CSS3属性的缩进，必须将属性名称的第一个字符对齐。即：<br>
            <code>-webkit-transition:3s;</code>
            <br><code>&nbsp;&nbsp;&nbsp;-moz-transition:3s;</code>
            <br><code>&nbsp;&nbsp;&nbsp;&nbsp;-ms-transition:3s;</code>
            <br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-o-transition:3s;</code>
            <br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transition:3s;</code>
        "
    }'''

    def __init__(self):
        self.id = 'css3-prop-spaces'

        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_multi = 'css3 prop "${name}" should align to right in "${selector}"'
        self.errorMsg_single = 'should have 1(only) space before css3 prop "${name}" in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        name = rule.name
        # only for css3 props
        if not isCss3Prop(name):
            return True

        if not isCss3PrefixProp(name):
            return True
        
        if doNotNeedPrefixNow(name):
            # if exists prefix, then should keep spaces
            if not rule.getRuleSet().existRoughNames('-webkit-%s,-moz-%s,-ms-%s,-o-%s' % (name,name,name,name)):
                return True

        roughName = rule.roughName

        if rule.getRuleSet().singleLineFlag is False:
            # 12 = 4 + 8, 4 spaces, 8 for align
            if len(roughName.split(name)[0]) != 12:
                self.errorMsg = self.errorMsg_multi
                return False
        else:
            if roughName.startswith('  ') or not roughName.startswith(' '):
                self.errorMsg = self.errorMsg_single
                return False
        return True

    def fix(self, rule, config):
        name = rule.name
        # only for css3 props
        if not isCss3Prop(name):
            return

        if not isCss3PrefixProp(name):
            return

        if not rule.getRuleSet().existRoughNames('-webkit-%s,-moz-%s,-ms-%s,-o-%s' % (name,name,name,name)):
            return

        fixedName = rule.fixedName
        prefix = fixedName.split(name)[0]
        if rule.selector.find('%') != -1:
            remained = '-webkit-,-moz-,-ms-,-o-,'.replace(prefix + ',', '')
            testString = ','.join([(x + name) for x in remained[:-1].split(',')])
            if not rule.getRuleSet().existRoughNames(testString):
                return
        rule.fixedName = ((8 - len(prefix)) * ' ' if not config.fixToSingleLine else '') + fixedName
#/usr/bin/python
#encoding=utf-8

from Base import *
import string
from ckstyle.browsers.Detector import Browser

class FEDDistinguishBrowserExtra(ExtraChecker):
    
    '''{
        "summary":"嵌套规则区分浏览器",
        "desc":"目的是针对不同的浏览器，生成不同的CSS规则集"
    }'''

    def __init__(self):
        self.id = 'extra-for-browsers'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = ''

    def check(self, ruleSet, config):
        return True

    def fix(self, ruleSet, config):
        if not ruleSet.nested:
            return
        Browser.handleNestedStatement(ruleSet)#/usr/bin/python
#encoding=utf-8

from Base import *
import string
from ckstyle.browsers.Detector import Browser

class FEDDistinguishBrowserRule(RuleChecker):
    
    '''{
        "summary":"在属性级别区分浏览器",
        "desc":"目的是针对不同的浏览器，生成不同的CSS"
    }'''

    def __init__(self):
        self.id = 'rule-for-browsers'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = ''

    def check(self, rule, config):
        return True

    def fix(self, rule, config):
        Browser.handleRule(rule)#/usr/bin/python
#encoding=utf-8

from Base import *
import string
from ckstyle.browsers.Detector import Browser

class FEDDistinguishBrowserRuleSet(RuleSetChecker):
    
    '''{
        "summary":"在规则集级别区分浏览器",
        "desc":"目的是针对不同的浏览器，生成不同的CSS规则集"
    }'''

    def __init__(self):
        self.id = 'ruleset-for-browsers'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = ''

    def check(self, ruleSet, config):
        return True

    def fix(self, ruleSet, config):
        Browser.handleRuleSet(ruleSet)#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import isSimpleSelector

class FEDDoNotSetStyleForSimpleSelector(RuleSetChecker):
    
    '''{
        "summary":"不要为简单选择器设置样式",
        "desc":"一些简单的选择器，比如：<br>
            <code>.nav/.list/.content</code><br>
            非常容易造成属性的相互覆盖，因此在写这样的选择器时，最好加上前缀，比如<br>
            <code>.module-name .nav</code><br><br>
            工具现有的简单选择器判断，请参考：<br>
            <code>plugins/helper.py</code>"
    }'''

    def __init__(self):
        self.id = 'no-style-for-simple-selector'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_rough = 'should not set style for "%s" in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selector = ruleSet.selector.lower()

        if selector.find('@media') != -1:
            return True

        if selector.find('@-moz-document') != -1:
            return True

        selectors = selector.split(',')
        for s in selectors:
            s = s.strip()
            if isSimpleSelector(s):
                self.errorMsg = self.errorMsg_rough % s
                return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import isHTMLTag

class FEDDoNotSetStyleForTagOnly(RuleSetChecker):
    
    '''{
        "summary":"不要为html tag设置样式",
        "desc":"除了重置 CSS(如Reset.css) 的相关设置，其他代码一律不允许为html tag设置样式。"
    }'''

    def __init__(self):
        self.id = 'no-style-for-tag'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'should not set style for html tag in "${selector}"'

    def check(self, ruleSet, config):
        selector = ruleSet.selector.lower()
        if selector.find('@media') != -1:
            return True
        if selector.find('@-moz-document') != -1:
            return True
        selectors = selector.split(',')
        for s in selectors:
            if isHTMLTag(s.strip()):
                return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDFixCommentInValue(RuleChecker):
    
    '''{
        "summary":"修复属性中的注释",
        "desc":"width:/* fdasfdas */ 100px /* fdafdas */; ==> width:100px;"
    }'''

    def __init__(self):
        self.id = 'fix-comment-in-value'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = ''
        self.private = True

    def check(self, rule, config):
        return True


    def fix(self, rule, config):
        if rule.name == 'expression':
            return
        value = rule.fixedValue
        if value.find('/*') == -1:
            return

        splited = value.split('/*')
        collector = []
        for x in splited:
            tmp = x.split('*/')
            if len(tmp) == 1:
                collector.append(tmp[0])
            else:
                collector.append(tmp[1])
        rule.fixedValue = ''.join(collector)
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDFixNestedStatement(ExtraChecker):
    
    '''{
        "summary":"修复嵌套的CSS",
        "desc":"@keyframes, @media之类的"
    }'''

    def __init__(self):
        self.id = 'fix-nested-ruleset'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = ''
        self.private = True

    def check(self, ruleSet, config):
        return True

    def fix(self, ruleSet, config):
        if not ruleSet.nested:
            return
        ruleSet.fixedSelector = ruleSet.fixedSelector.replace('"', '\'')
        statement = ruleSet.fixedStatement
        if (hasattr(config, 'operation') and getattr(config, 'operation') == 'compress'):
            from ckstyle.doCssCompress import prepare
            checker = prepare(statement, '', config)
            # 嵌套的CSS，如果是压缩，也需要精简
            msg = checker.doCompress(config._curBrowser)
            ruleSet.fixedStatement = msg
        else:
            from ckstyle.doCssFix import doFix
            checker, msg = doFix(statement, '', config)
            ruleSet.fixedStatement = msg
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDFixOutlineZero(RuleChecker):
    
    '''{
        "summary":"修复outline:none",
        "desc":"<code>outline:none</code> 和 <code>outline:0</code> 实现了相同的功能，但是后者的代码更简洁，便于压缩。"
    }'''

    def __init__(self):
        self.id = 'outline-zero'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = ''

    def check(self, rule, config):
        return True

    def fix(self, rule, config):
        if rule.name == 'outline' and rule.fixedValue == 'none':
            rule.fixedValue = '0'#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDFontSizeShouldBePtOrPx(RuleChecker):
    
    '''{
        "summary":"字体的单位必须用px或pt",
        "desc":"字体的单位可以有很多种，比如 <code>px pt em %</code> 等等，为了统一取值，统一要求为 <code>px/pt</code> ， 例如：<br>
            <code>font-size: 12px;</code><br>
            <code>font-size: 14pt;</code>"
    }'''

    def __init__(self):
        self.id = 'font-unit'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_ptOrPx = 'font-size unit should be px/pt in "${selector}"'
        self.errorMsg_xsmall = 'font-size should not be small/medium/large in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        if rule.name != 'font-size':
            return True

        value = rule.value
        if value.find('small') != -1 or value.find('medium') != -1 or value.find('large') != -1:
            self.errorMsg = self.errorMsg_xsmall
            return False

        if value == '0':
            return True

        if value.endswith('pt'):
            return True

        if value.endswith('px'):
            return True

        self.errorMsg = self.errorMsg_ptOrPx
        return False
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import isCss3PrefixProp

class FEDHackAttributeInCorrectWay(RuleChecker):
    
    '''{
        "summary":"hack属性时的检查",
        "desc":"必须使用正确的 hack 方式， 比如 <code>_ * +</code> 等，其他的属性前缀一律不允许"
    }'''

    def __init__(self):
        self.id = 'hack-prop'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = '"${name}" is not in correct hacking way in "${selector}"'

    def check(self, rule, config):
        if rule.value.find(r'\0') != -1:
            return False

        stripped = rule.roughName.strip()
        if rule.name == stripped.lower():
            return True

        if isCss3PrefixProp(rule.name):
            return True

        if not stripped.startswith('_') and not stripped.startswith('*') and not stripped.startswith('+'):
            return False

        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDHackRuleSetInCorrectWay(ExtraChecker):
    
    '''{
        "summary":"hack规则时的检查",
        "desc":"针对Firefox Opera Safari等浏览器的 hack 方式， <strong>人人FED CSS编码规范</strong>中有详细的描述， 
            不允许使用规定之外的方式进行规则级别的hack"
    }'''

    def __init__(self):
        self.id = 'hack-ruleset'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'not correct hacking way in "${selector}"'

    def check(self, ruleSet, config):
        if not ruleSet.nested:
            return True

        selector = ruleSet.selector.strip()
        if selector.find('@-moz-document') != -1:
            if selector != '@-moz-document url-prefix()':
                return False

        if selector.find('-webkit-min-device-pixel-ratio:0') != -1:
            if selector != '@media screen and (-webkit-min-device-pixel-ratio:0)' and selector.find('-webkit-min-device-pixel-ratio:10000') == -1:
                return False

        if selector.find('-webkit-min-device-pixel-ratio:10000') != -1:
            if selector.find('@media all') == -1 or selector.find('not all and') == -1 or selector.find('-webkit-min-device-pixel-ratio:0') == -1:
                return False

        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *
import re

pattern = re.compile(r'#([a-f0-9A-F]+)')

class FEDHexColorShouldUpper(RuleChecker):
    '''{
        "summary":"16进制颜色大写&缩写",
        "desc":"<p>浏览器会先将小写的颜色值转换成大写，所以写成大写格式可以省略这部分的开销，并且尽量省略，例如：
            </br><code>color:#ffffff; </code><br/><code>==></code><br/><code>color:#FFF;</code></p>"
    }'''

    def __init__(self):
        self.id = 'hexadecimal-color'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_length = 'wrong color length(should be 3 or 6) in "${selector}"'
        self.errorMsg_replace = 'replace "#%s" with "#%s" in "${selector}"'
        self.errorMsg_upper = 'color should in upper case in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        value = rule.value
        if value.find('#') == -1:
            return True

        found = self._findColor(rule.value)
        for f in found:
            flag = self._checkEach(f)
            if not flag:
                return False
        return True

    def _checkEach(self, found):
        if found is None:
            return True

        if self._isLower(found):
            self.errorMsg = self.errorMsg_upper
            return False

        if len(found) == 3:
            return True

        if self._wrongLength(found):
            self.errorMsg = self.errorMsg_length
            return False

        if self._isDuplicate(found):
            self.errorMsg = self.errorMsg_replace % (found, found[0]+found[2]+found[4])
            return False
        
        return True

    def fix(self, rule, config):
        value = rule.fixedValue
        if value.find('#') == -1:
            return

        hasImportant = rule.fixedValue.find('important') != -1
        found = self._findColor(rule.fixedValue)
        for f in found:
            self._fixEach(rule, f, hasImportant)

    def _fixEach(self, rule, found, hasImportant):
        if self._isLower(found):
            rule.fixedValue = rule.fixedValue.replace('#' + found, '#' + found.upper())
            found = found.upper()

        if len(found) == 3:
            return

        if not hasImportant and self._wrongLength(found):
            final = found[0:6] if len(found) > 6 else (found + (6 - len(found)) * 'F')
            rule.fixedValue = rule.fixedValue.replace('#' + found, '#' + final)
            found = final

        if self._isDuplicate(found):
            rule.fixedValue = rule.fixedValue.replace('#' + found, '#' + found[0] + found[2] + found[4])

    def _wrongLength(self, found):
        return len(found) != 3 and len(found) != 6

    def _isLower(self, found):
        return found is not None and found != found.upper()

    def _isDuplicate(self, found):
        return found[0] == found[1] and found[2] == found[3] and found[4] == found[5]

    def _findColor(self, value):
        splited = value.split(' ')
        found = []
        for x in splited:
            x = x.strip()
            matcher = pattern.findall(x)
            if matcher is not None:
                found.extend(matcher)
            #if x.startswith('#'):
            #    found.append(x.split('!important')[0][1:].split(',')[0].split(')')[0])
            #elif x.find('(#') != -1:
            #    found.append(x.split('(#')[1].split('!important')[0].split(',')[0].split(')')[0])
        return found
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import isHTMLTag

class FEDHighPerformanceSelector(RuleSetChecker):
    
    '''{
        "summary":"针对低性能的选择器的检查",
        "desc":"低性能选择器，害人害己还集体，本工具收集了一些低性能选择器的情形，具体请参见：<br>
            <code>FEDHighPerformanceSelector.py</code>中的相关内容"
    }'''

    def __init__(self):
        self.id = 'high-perf-selector'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_shorter = 'please shorter the selector "${selector}"'
        self.errorMsg_no1 = 'do not use low performance selector ">" in "${selector}"'
        self.errorMsg_lessTag = 'use less tag in "${selector}"'
        self.errorMsg_id = 'should not put "HTMLtag" and "#id" together in "${selector}"'
        self.errorMsg_class = 'should not put "HTMLtag" and ".class" together in "${selector}"'
        self.errorMsg_reg = 'should not use ~=,^=,|=,$=,*= in selector of "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selectors = ruleSet.selector.replace('  ', '').split(',')
        for s in selectors:
            if s.find('@media') != -1:
                continue

            if s.find('=') != -1:
                if s.find('~=') != -1 or s.find('^=') != -1 or s.find('|=') != -1 or s.find('$=') != -1 or s.find('*=') != -1:
                    self.errorMsg = self.errorMsg_reg
                    return False

            splited = s.split(' ')
            if len(splited) > 5:
                self.errorMsg = self.errorMsg_shorter
                return False
            counter = 0
            for p in splited:
                if p == '>':
                    self.errorMsg = self.errorMsg_no1
                    return False

                innerSplit = p.split('#')
                if len(innerSplit) == 2 and isHTMLTag(innerSplit[0]):
                    self.errorMsg = self.errorMsg_id
                    return False

                innerSplit = p.split('.')
                if len(innerSplit) == 2 and isHTMLTag(innerSplit[0]):
                    self.errorMsg = self.errorMsg_class
                    return False

                if isHTMLTag(p):
                    counter = counter + 1
            if counter > 1:
                self.errorMsg = self.errorMsg_lessTag
                return False

        noSpace = ruleSet.selector.replace(' ', '')
        if noSpace.find('ulli') != -1 or noSpace.find('olli') != -1 or noSpace.find('dldt') != -1 or noSpace.find('dldd') != -1:
            self.errorMsg = self.errorMsg_lessTag
            return False
        return True
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDMultiLineBraces(RuleSetChecker):
    
    '''{
        "summary":"多行CSS风格的括号检查",
        "desc":"用于检查多行风格下的 <code>{</code> 和 <code>}</code> 的编写风格，前后空格符和回车符的情况等。"
    }'''

    def __init__(self):
        self.id = 'multi-line-brace'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_shouldEnterAfterOpenningBrace = 'should "enter" after the opening brace in "${selector}"'
        self.errorMsg_shouldEnterBeforeClosingBrace = 'should "enter" before the closing brace in "${selector}"'
        self.errorMsg_extraSpaceAfterOpeningBrace = 'extra "space" after the opening brace in "${selector}"'
        self.errorMsg_everyAttrShouldInSingleLine = 'every name/value should in single line in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        singleLine = ruleSet.getSingleLineFlag()
        if singleLine:
            return True

        value = ruleSet.roughValue
        splited = value.split('\n')
        if splited[0].strip() != '':
            self.errorMsg = self.errorMsg_shouldEnterAfterOpenningBrace
            return False

        if splited[0].strip() == '' and splited[0].startswith(' '):
            self.errorMsg = self.errorMsg_extraSpaceAfterOpeningBrace
            return False

        ruleLength = len(ruleSet.getRules())
        if ruleLength != 0 and len(value.strip().split('\n')) != ruleLength:
            self.errorMsg = self.errorMsg_everyAttrShouldInSingleLine
            return False

        if not value.replace(' ', '').endswith('\n'):
            self.errorMsg = self.errorMsg_shouldEnterBeforeClosingBrace
            return False

        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDMultiLineSelectors(RuleSetChecker):
    
    '''{
        "summary":"多行CSS风格的选择器检查",
        "desc":"多行风格下，每一个选择器单独占一行，并以逗号结尾，例如：<br>
            <code>.a,</code><br>
            <code>.b,</code><br>
            <code>.c {</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;width: 100px;</code><br>
            <code>}</code>
        "
    }'''

    def __init__(self):
        self.id = 'multi-line-selector'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_multiSelectorBeforeSemicolon = 'should not have "space" before semicolon in "${selector}"'
        self.errorMsg_multiSelectorBeforeSemicolon = 'should not have "space" after semicolon in "${selector}"'
        self.errorMsg_shouldEnter = 'should enter in multi-selector, in "${selector}"'
        self.errorMsg_tooManyEnters = 'too many "enter"s in "${selector}"'
        self.errorMsg_startsWithSpace = 'selector should not start with "space" in "${selector}"'
        self.errorMsg_extraSpaceAfterComma = 'extra "space" after comma in "${selector}"'
        self.errorMsg_extraSpaceBeforeComma = 'extra "space" before comma in "${selector}"'
        self.errorMsg_commaInTheEnd = 'comma should at the end of selector in "${selector}"'
        self.errorMsg_shouldAddSpaceForLast = 'should add "space" for last selector of "${selector}"'
        self.errorMsg_shouldNotEnterAtTheEnd = 'should not "enter" at the end of "${selector}"'
        self.errorMsg_selectorEndsWithSpace = 'selector should end with only one space "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selector = ruleSet.roughSelector

        if not selector.endswith(' ') or selector.endswith('  '):
            self.errorMsg = self.errorMsg_selectorEndsWithSpace
            return False

        if selector.find(',') == -1:
            return True

        if selector.replace(' ', '').endswith('\n'):
            self.errorMsg = self.errorMsg_shouldNotEnterAtTheEnd
            return False

        if selector.strip().find('\n') == -1:
            self.errorMsg = self.errorMsg_shouldEnter
            return False

        selectors = selector.split('\n')
        length = len(selectors)

        if len(selector.split(',')) != len(selector.strip().split('\n')):
            self.errorMsg = self.errorMsg_tooManyEnters
            return False

        realSelectors = []
        for s in selectors:
            if s.strip() != '':
                realSelectors.append(s)

        counter = 0
        length = len(realSelectors)
        for current in realSelectors:
            counter = counter + 1
            stripped = current.strip()
            if stripped == '':
                continue
            if current.startswith(' '):
                self.errorMsg = self.errorMsg_startsWithSpace
                return False
            if stripped.endswith(' ,'):
                self.errorMsg = self.errorMsg_extraSpaceBeforeComma
                return False
            if current.endswith(' ') and stripped.endswith(','):
                self.errorMsg = self.errorMsg_extraSpaceAfterComma
                return False
            if counter == length and not current.endswith(' '):
                self.errorMsg = self.errorMsg_shouldAddSpaceForLast
                return False
            if counter != length and stripped.find(',') == -1:
                self.errorMsg = self.errorMsg_commaInTheEnd
                return False

        return True 

        
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import isCss3PrefixProp

class FEDMultiLineSpaces(RuleChecker):
    
    '''{
        "summary":"CSS多行风格的空格检查",
        "desc":"多行风格下，CSS的空格检查包括：
            <ol>
                <li>选择器的空格</li>
                <li>属性的空格</li>
                <li>结尾}的空格</li>
            </ol>
            具体请参见人人相关的CSS规范"
    }'''

    def __init__(self):
        self.id = 'multi-line-space'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_name_pre = 'should have 4 spaces before "${name}" in "${selector}"'
        self.errorMsg_name_after = 'should not have "space" after "${name}" in "${selector}"'
        self.errorMsg_value_pre = 'should have (only) one "space" before value of "${name}" in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        singleLine = rule.getRuleSet().getSingleLineFlag()
        if singleLine:
            return True
        
        prefix = ' ' * 4
        name = rule.roughName
        value = rule.roughValue
        stripped = rule.roughName.strip()

        # leave special css3 props for FEDCss3AttrChecker
        if isCss3PrefixProp(rule.name):
            if name.endswith(' '):
                self.errorMsg = self.errorMsg_name_after
                return False

            if not value.startswith(' ') or value.startswith('  '):
                self.errorMsg = self.errorMsg_value_pre
                return False

            return True

        if name.find('\t') != -1:
            name = name.replace('\t', prefix)
        if not name.startswith(prefix):
            self.errorMsg = self.errorMsg_name_pre
            return False
        if name.startswith(' ' * 5):
            self.errorMsg = self.errorMsg_name_pre
            return False
        if name.endswith(' '):
            self.errorMsg = self.errorMsg_name_after
            return False

        if not value.startswith(' ') or value.startswith('  '):
            self.errorMsg = self.errorMsg_value_pre
            return False

        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import isHTMLTag

class FEDMustContainAuthorInfo(StyleSheetChecker):
    
    '''{
        "summary":"需要在文件中添加作者信息",
        "desc":"需要在文件中添加作者的信息，本工具认可的作者信息是在文件顶部的注释中添加 <code>@author:xxx</code>"
    }'''

    def __init__(self):
        self.id = 'add-author'
        self.errorMsg_author = 'should add @author in the head of "${file}"'
        self.errorMsg_empty = 'empty css file "${file}"'
        self.errorMsg = ''
        self.errorLevel = ERROR_LEVEL.ERROR

    def check(self, styleSheet, config):
        ruleSets = styleSheet.getRuleSets()
        if len(ruleSets) == 0:
            self.errorMsg = self.errorMsg_empty
            return False

        first = ruleSets[0]

        if styleSheet.getFile() != '' and first.comment.find('@author') == -1 and first.comment.find('@renren-inc.com') == -1:
            self.errorMsg = self.errorMsg_author
            return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDNoAlphaImageLoader(RuleChecker):
    
    '''{
        "summary":"不要使用AlphaImageLoader",
        "desc":"<code>AlphaImageLoader</code> 主要用于在IE6下显示半透明图片，此举实际上费力不讨好，
            对IE的性能影响极大，为了更好地实现网页的 <strong>渐进增强</strong> 
            ，建议不要使用 <code>AlphaImageLoader</code>"
    }'''

    def __init__(self):
        self.id = 'no-alpha-image-loader'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'should not use AlphaImageLoader in "${selector}"'

    def check(self, rule, config):
        if rule.value.find('AlphaImageLoader') != -1:
            return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import existsAppearanceWords

class FEDNoAppearanceNameInSelector(RuleSetChecker):
    
    '''{
        "summary":"选择器中避免表现相关的词汇",
        "desc":"避免将在selector中出现 <code>.red</code> <code>.left</code> 等描述性词汇，
            用具体的实际意义来代替，比如 <code>.error</code> <code>.sidebar</code> "
    }'''

    def __init__(self):
        self.id = 'no-appearance-word-in-selector'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_origin = 'should not use appearance word "%s" in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selector = ruleSet.selector.lower()

        if selector.find('@media') != -1:
            return True
        if selector.find('@-moz-document') != -1:
            return True

        word = existsAppearanceWords(selector)
        if word is not None:
            self.errorMsg = self.errorMsg_origin % word
            return False

        return True
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDNoCommentInValues(RuleSetChecker):
    
    '''{
        "summary":"不要在css属性中添加注释",
        "desc":"CSS的注释应该写在 <code>selector</code> 前面，属性中不允许添加css注释，例如：<br>
            <code>.selector {</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;width: 100px;/*comment here*/</code><br>
            <code>}</code>
        "
    }'''

    def __init__(self):
        self.id = 'no-comment-in-value'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg = 'find css comment (/* */) in "${selector}"'

    def check(self, ruleSet, config):
        if ruleSet.roughValue.find('/*') != -1 or ruleSet.roughValue.find('*/') != -1:
            return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDNoEmptyRuleSet(RuleSetChecker):
    
    '''{
        "summary":"删除空的规则",
        "desc":"空的CSS规则集是没有任何意义的，应该直接删除掉"
    }'''

    def __init__(self):
        self.id = 'no-empty-ruleset'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'empty ruleset found "${selector}"'

    def check(self, ruleSet, config):
        if len(ruleSet.getRules()) == 0:
            return False
        return True 

    def fix(self, ruleSet, config):
        if len(ruleSet.getRules()) == 0:
            styleSheet = ruleSet.getStyleSheet()
            styleSheet.removeRuleSet(ruleSet)
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDNoExpression(RuleChecker):
    
    '''{
        "summary":"不要使用非一次性表达式",
        "desc":"IE下，非一次性expression对性能有很大的影响，或许一次鼠标移动，
            将触发<strong>成千上万次</strong>的expression表达式的执行，
            因此，为了浏览器的更新换代，应该杜绝使用非一次性表达式。<br>
            本工具针对一次性表达式的检查，将判断expression中是否有如下两个内容：<br>
            1. <code>Expressions</code><br>
            2. <code>this.style.attrName = </code>"
    }'''

    def __init__(self):
        self.id = 'no-expression'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_use = 'should not use expression in "${selector}" '
        self.errorMsg_hack = 'should add hack for expression in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        value = rule.value
        name = rule.name
        replaced = value.replace(' ', '')

        if value.find('expression') == -1:
            return True

        if replaced.find('Expressions') != -1 or replaced.find('this.style.' + name + '=') != -1 or replaced.find('this.runtimeStyle.' + name + '=') != -1:
            if rule.name == rule.strippedName:
                selector = rule.selector.replace(' ', '')
                if selector.find('*html') == -1:
                    self.errorMsg = self.errorMsg_hack
                    return False
            return True

        self.errorMsg = self.errorMsg_use
        return False
#/usr/bin/python
#encoding=utf-8

from Base import *
import re
pattern = re.compile('\d+')

class FEDNoSimpleNumberInSelector(RuleSetChecker):
    
    '''{
        "summary":"不要在选择器中使用简单数字",
        "desc":"在业务代码的css中，选择器中不要使用简单的 <code>1, 2, 3</code> 来进行命名，下面的命名方式就是错误的：<br>
            <code>.test1</code> <code>.main1</code>，但是允许使用 <code>v1</code> <code>step1</code> <code>item1</code> 
            来代表版本、步骤、第几个元素的意思"
    }'''

    def __init__(self):
        self.id = 'number-in-selector'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'do not simply use 1,2,3 as selector(use v1/step1/item1), in "${selector}"'

    def check(self, ruleSet, config):
        selector = ruleSet.selector

        if selector.find('@media') != -1:
            return True
            
        found = pattern.findall(selector)
        for x in found:
            if selector.find('v' + x) == -1 and selector.find('step' + x) == -1  and selector.find('item' + x) == -1 and selector.find('h' + x) == -1 :
                return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDNoStarInSelector(RuleSetChecker):
    
    '''{
        "summary":"不要在选择器中使用星号",
        "desc":"禁止在选择器中加入<code>*</code>来选择所有元素，例如：<br>
            <br>
            <code>*html</code> <code>*+html</code> <code>*:not</code>等几种特殊hack除外"
    }'''

    def __init__(self):
        self.id = 'no-star-in-selector'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'please remove low performance selector "*" from "${selector}"'

    def check(self, ruleSet, config):
        selector = ruleSet.selector
        if selector.find('*') == -1:
            return True

        replaced = selector.replace(' ', '')
        if replaced.startswith('*html') or replaced.startswith('*+html'):
            return True

        if replaced.find('*:not') != -1:
            return True

        # give it to FEDHighPerformanceSelector.py
        if replaced.find('*=') != -1 and len(replaced.split('*')) == 2:
            return True

        return False
#/usr/bin/python
#encoding=utf-8

from Base import *
import re

pattern = re.compile(r'(0\s*[\w]+)')
replacer = re.compile(',\s+')

class FEDNoUnitAfterZero(RuleChecker):
    
    '''{
        "summary":"删除0后面的单位",
        "desc":"0后面的单位可以删除，以实现更好的压缩。比如 <code>0px ==> 0</code> ，<code>0em ==> 0</code> 等，
            但是<code>transition: 0s</code>的<code>s</code>不能省略"
    }'''

    def __init__(self):
        self.id = 'del-unit-after-zero'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'unit should be removed when meet 0 in "${selector}"'

    def check(self, rule, config):

        values = rule.value.split(' ')

        for v in values:
            v = v.strip()
            if v.find('(') != -1:
                matched = self._startsWithZero(v.split('(')[1])
            else:
                matched = self._startsWithZero(v)

            if matched is None:
                continue

            for m in matched:
                if m != '0s':
                    return False

        return True 

    def fix(self, rule, config):
        if rule.name == 'expression':
            return

        fixed = rule.fixedValue
        rule.fixedValue = rule.fixedValue.replace(',', ', ')

        collector = []
        for v in rule.fixedValue.split(' '):
            v = v.strip()
            if v.find('(') != -1:
                matched = self._startsWithZero(v.split('(')[1])
            else:
                matched = self._startsWithZero(v)

            if matched is None:
                collector.append(v)
                continue

            finalV = v;
            for m in matched:
                if m != '0s':
                    finalV = finalV.replace(m, '0')
            collector.append(finalV)

        rule.fixedValue = replacer.sub(', ', ' '.join(collector))

    def _startsWithZero(self, value):
        matcher = pattern.match(value)
        if matcher is not None:
            return matcher.groups()
        return None
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDNoZeroBeforeDot(RuleChecker):
    
    '''{
        "summary":"删除0.x前面的0",
        "desc":" 0.xxx 前面的 0 是可以删除的，以实现更好的压缩。例如<br>
            <code>0.3px ==> .3px</code><br><br>
            <code>rgba(0,0,0,0.3)<code><br>
            <code>==></code><br>
            <code>rgba(0,0,0,.3)</code>"
    }'''

    def __init__(self):
        self.id = 'no-zero-before-dot'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'zero should be removed when meet 0.xxx in "${selector}"'

    def check(self, rule, config):
        value = rule.value

        if self._startsWithZeroDot(value):
            return False

        values = rule.value.split(' ')
        for v in values:
            if self._startsWithZeroDot(v.strip()):
                return False

        return True 

    def fix(self, rule, config):
        fixedValue = rule.fixedValue
        for v in fixedValue.split(' '):
            if self._startsWithZeroDot(v):
                rule.fixedValue = rule.fixedValue.replace(v, v[1:])

    def _startsWithZeroDot(self, value):
        return value.startswith('0.')
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDRemoveDuplicatedAttr(RuleSetChecker):
    
    '''{
        "summary":"删除重复的属性设置",
        "desc":"如果在一个规则集中，对相同的两个属性进行了赋值，而且取值相同，则可以删除前面的赋值，例如：
            <br>
            <code>.test {</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;width: 100px;</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;width: 100px;</code><br>
            <code>}</code><br>
            <code>==></code><br>
            <code>.test {</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;width: 100px;</code><br>
            <code>}</code>"
    }'''

    def __init__(self):
        self.id = 'remove-duplicated-attr'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'has more than 1 ${name} in "${selector}"'

    def check(self, ruleSet, config):
        rules = ruleSet.getRules()
        collector = []
        for rule in rules:
            info = self.ruleInfo(rule)
            if info in collector:
                return False
            collector.append(info)
        return True

    def fix(self, ruleSet, config):
        # make sure we use the last statement, so reverse and filter and reverse again
        # [a1, a2, b, c] ==> [c, b, a2, a1] ==> [c, b, a2] ==> [a2, b, c]
        rules = ruleSet.getRules()
        rules.reverse()
        newRules = []
        collector = []
        for rule in rules:
            info = self.ruleInfo(rule)
            if not info in collector:
                collector.append(info)
                newRules.append(rule)
        newRules.reverse()
        ruleSet.setRules(newRules)

    def ruleInfo(self, rule):
        if rule.fixedName != '':
            return rule.fixedName + ':' + rule.fixedValue
        return rule.strippedName + ':' + rule.strippedValue
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDReplaceBorderZeroWithBorderNone(RuleChecker):
    
    '''{
        "summary":"用border:none替换border:0",
        "desc":"<code>border:0</code> 实际上是有border的，只不过宽度为0， 而 <code>border:none;</code> 
            是根本没有border的，对于浏览器来说后者的效率高，但是要注意，后者的代码长度稍微长一些。"
    }'''

    def __init__(self):
        self.id = 'no-border-zero'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_borderWidth = 'replace "border-width: 0" with "border-width: none" in "${selector}"'
        self.errorMsg_border = 'replace "border: 0" with "border: none" in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        if rule.name == 'border' and rule.value == '0':
            self.errorMsg = self.errorMsg_border
            return False

        if rule.name == 'border-width' and rule.value == '0':
            self.errorMsg = self.errorMsg_borderWidth
            return False

        return True
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDSelectorNoUnderLine(RuleSetChecker):
    
    '''{
        "summary":"不要在选择器中使用下划线",
        "desc":"在selector中不要使用下划线 <code>_</code> ，可以使用中划线 <code>-</code>"
    }'''

    def __init__(self):
        self.id = 'no-underline-in-selector'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'should not use _ in selector "${selector}"'

    def check(self, ruleSet, config):
        selector = ruleSet.selector
        if selector.find('_') != -1:
            return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDSemicolonAfterValue(RuleChecker):
    
    '''{
        "summary":"为每一个属性后添加分号",
        "desc":"按照CSS编码规范，每一个规则后面都必须加上分号 <code>;</code>"
    }'''

    def __init__(self):
        self.id = 'add-semicolon'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'each rule in "${selector}" need semicolon in the end, "${name}" has not'

    def check(self, rule, config):
        if not rule.roughValue.strip().endswith(';'):
            return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDShouldNotUseImportant(RuleChecker):
    
    '''{
        "summary":"不要使用!important",
        "desc":"CSS中不要使用<code>!important</code>"
    }'''

    def __init__(self):
        self.id = 'do-not-use-important'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'Should not use !important in "${name}" of "${selector}"'

    def check(self, rule, config):
        value = rule.value
        if value.replace(' ', '').find('!important') != -1:
            return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDSingleLineBraces(RuleSetChecker):
    
    '''{
        "summary":"单行的括号检查",
        "desc":"与单行CSS编码风格相关的括号检查"
    }'''

    def __init__(self):
        self.id = 'single-line-brace'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_openingBrace = 'should have "only one space" before the opening brace in "${selector}"'
        self.errorMsg_openingBraceEnd = 'should have "only one space" after the opening brace in "${selector}"'
        self.errorMsg_closingBrace = 'should have "only one space" before the closing brace in "${selector}"'
        self.errorMsg_closingBraceEnd = 'should have "only one space" before the closing brace in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        singleLine = ruleSet.getSingleLineFlag()
        if not singleLine:
            return True
        selector = ruleSet.roughSelector
        if selector.find(',') == -1:
            if selector.endswith('  ') or not selector.endswith(' '):
                self.errorMsg = self.errorMsg_openingBrace
                return False
        else:
            return True

        value = ruleSet.roughValue
        if not value.startswith(' ') or value.startswith('  '):
            self.errorMsg = self.errorMsg_openingBraceEnd
            return False
        if not value.endswith(' ') or value.endswith('  '):
            self.errorMsg = self.errorMsg_closingBraceEnd
            return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDSingleLineSelector(RuleSetChecker):
    
    '''{
        "summary":"单行的选择器检查",
        "desc":"单行的选择器检查内容，请参考多行选择器检查和人人FED CSS编码规范"
    }'''

    def __init__(self):
        self.id = 'single-line-selector'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_noEnterInSingleSelector = 'should not "enter" at the end of "${selector}"'
        self.errorMsg_multiSelectorBeforeSemicolon = 'should not have "space" after semicolon in "${selector}"'
        self.errorMsg_shouldNotStartsWithSpace = 'should start with "space" in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selector = ruleSet.roughSelector
        if selector.find(',') != -1:
            return True

        if selector.lstrip().find('\n') != -1:
            self.errorMsg = self.errorMsg_noEnterInSingleSelector
            return False

        splited = selector.split('\n')
        realSelector = splited[len(splited) - 1]
        
        if realSelector.startswith(' '):
            self.errorMsg = self.errorMsg_shouldNotStartsWithSpace
            return False

        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDSingleLineSpaces(RuleChecker):
    
    '''{
        "summary":"单行的空格检查",
        "desc":"单行CSS编码风格相关的空格检查，具体内容请参见CSS编码规范"
    }'''

    def __init__(self):
        self.id = 'single-line-space'
        self.errorLevel = ERROR_LEVEL.LOG
        self.errorMsg_noSpace = 'should have one "space" before "${name}" in "${selector}"'
        self.errorMsg_spaceEnd = 'should not have "space" after "${name}" in "${selector}"'
        self.errorMsg_noSpaceBeforeValue = 'should have one "space" before value of "${name}" in "${selector}"'
        self.errorMsg_extraSpaceAfterValue = 'found extra "space" after value of "${name}" in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        singleLine = rule.getRuleSet().getSingleLineFlag()
        if not singleLine:
            return True

        if not rule.roughName.startswith(' '):
            self.errorMsg = self.errorMsg_noSpace
            return False

        if rule.roughName.endswith(' '):
            self.errorMsg = self.errorMsg_spaceEnd
            return False
        
        if not rule.roughValue.startswith(' '):
            self.errorMsg = self.errorMsg_noSpaceBeforeValue
            return False

        value = rule.roughValue.strip()
        if value.endswith(' ;') or value.endswith(' '):
            self.errorMsg = self.errorMsg_extraSpaceAfterValue
            return False

        return True 
#/usr/bin/python
#encoding=utf-8

from helper import getAttrOrder
from Base import *

class FEDStyleShouldInOrder(RuleSetChecker):
    
    '''{
        "summary":"属性应该按照推荐的顺序编写",
        "desc":"相同的CSS属性，如果按照推荐的顺序来编写，浏览器的处理性能会更高，推荐的顺序一般为：<br>
            显示属性 => 盒模型属性 => 背景/行高 => 文本属性 => 其他"
    }'''

    def __init__(self):
        self.id = 'keep-in-order'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_rough = '"%s" should after "%s" in "${selector}" (order: display/box/text/other/css3)'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        rules = ruleSet.getRules()
        if len(rules) < 2:
            return True

        order = self._generateNameOrderMapping(rules)
        length = len(order)
        for i in range(length):
            if i == length - 1:
                break;
            current = order[i]
            nextAttr = order[i + 1]

            if current[0] > nextAttr[0]:
                self.errorMsg = self.errorMsg_rough % (current[1], nextAttr[1])
                return False

        return True 

    def fix(self, ruleSet, config):
        rules = ruleSet.getRules()
        if len(rules) < 2:
            return True

        def comp(a, b):
            return a[0] - b[0]

        mapping = self._generateNameRuleMapping(rules)
        mapping.sort(comp)
        sortedRules = []
        for x in range(len(mapping)):
            sortedRules.append(mapping[x][1])
        ruleSet.setRules(sortedRules)

    def _generateNameOrderMapping(self, rules):
        return [(getAttrOrder(rule.name, rule.strippedName), rule.strippedName) for rule in rules]

    def _generateNameRuleMapping(self, rules):
        return [(getAttrOrder(rule.name, rule.strippedName), rule) for rule in rules]
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import containsChnChar

class FEDTransChnFontFamilyNameIntoEng(RuleChecker):
    
    '''{
        "summary":"字体设置时使用英文",
        "desc":"有的字体设置可以通过中文和英文两者方式来声明，比如<br>
            <code>微软雅黑</code> 和 <code>Microsoft Yahei</code> ，我们推荐用英文的方式来实现"
    }'''

    def __init__(self):
        self.id = 'no-chn-font-family'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'should not use chinese font family name in "${selector}"'

    def check(self, rule, config):
        if rule.name != 'font' and rule.name != 'font-family':
            return True

        if containsChnChar(rule.value):
            return False

        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import isCssProp

class FEDUnknownCssNameChecker(RuleChecker):
    
    '''{
        "summary":"错误的css属性",
        "desc":"本工具会帮您查找错误的CSS属性，如果写错了，即可收到错误提示"
    }'''

    def __init__(self):
        self.id = 'unknown-css-prop'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'unknown attribute name "${name}" found in "${selector}"'

    def check(self, rule, config):
        return isCssProp(rule.name.lower())
#/usr/bin/python
#encoding=utf-8

from Base import *
from helper import isHTMLTag

class FEDUnknownHTMLTagName(RuleSetChecker):
    
    '''{
        "summary":"错误的HTML Tag",
        "desc":"如果您输入了错误的HTML Tag，本工具也会给出响应的提示"
    }'''

    def __init__(self):
        self.id = 'unknown-html-tag'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_rough = 'unknown html tag "%s" found in "${selector}"'
        self.errorMsg = ''

    def check(self, ruleSet, config):
        selector = ruleSet.selector.lower()
        if selector.find('@media') != -1:
            return True
        if selector.find('@-moz-document') != -1:
            return True
        selectors = selector.split(',')
        for s in selectors:
            for r in s.split(' '):
                r = r.strip()
                if r != '':
                    if r.find('::') != -1:
                        # p::selection
                        tag = r.split('::')[0].split('.')[0].split('#')[0].strip()
                    else:
                        # abcd:hover
                        # abcd.class-name:hover
                        # abcd#class-name:hover
                        tag = r.split(':')[0].split('.')[0].split('#')[0].strip()

                    # .test > .inner
                    if tag == '' or tag == '>' or tag == '*' or tag == '+':
                        continue

                    # #id
                    if tag.find('#') != -1:
                        continue

                    # input[type=button]
                    if tag.find('[') != -1:
                        tag = tag.split('[')[0].strip()

                    # *+html
                    if tag.startswith('*+'):
                        tag = tag[2:]

                    # *html
                    elif tag.startswith('*'):
                        tag = tag[1:]

                    if not isHTMLTag(tag):
                        self.errorMsg = self.errorMsg_rough % tag
                        return False
        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDUseLowerCaseProp(RuleChecker):
    
    '''{
        "summary":"属性名称应该用小写",
        "desc":"所有的CSS属性名称一律小写，例如 <code>width</code> ，大写的方式是不正确的，
            例如： <code>WIDTH:100px;</code>"
    }'''

    def __init__(self):
        self.id = 'lowercase-prop'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg_name = '"${name}" should use lower case, in "${selector}"'
        self.errorMsg_value = 'value of "${name}" should use lower case, in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        value = rule.value
        name = rule.strippedName

        # give it to FED16ColorShouldUpper.py
        if name == 'color':
            return True

        if value.find('expression') != -1:
            return True

        if name.lower() != name:
            self.errorMsg = self.errorMsg_name
            return False

        if value.find('#') != -1:
            return True

        if name != 'font' and name != 'font-family' and value != value.lower() and value.find('#') == -1:
            self.errorMsg = self.errorMsg_value
            return False

        if name == 'font-family':
            return True

        if name == 'font':
            if value.find(',') != -1:
                # font: italic bold 12px/30px 'Courier New', Georgia, serif;
                other = ' '.join(value.split(',')[0].split("'")[0].split(' ')[0:-1])
                if other != other.lower():
                    self.errorMsg = self.errorMsg_value
                    return False
            return True

        if value.lower() != value:
            self.errorMsg = self.errorMsg_value
            return False

        return True 
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDUseLowerCaseSelector(RuleSetChecker):
    
    '''{
        "summary":"选择器用小写字母",
        "desc":"选择器应该用小写字母， 例如 <code>.demo</code> ， 不允许使用大写，例如： <code>.Demo .Test</code>"
    }'''

    def __init__(self):
        self.id = 'lowercase-selector'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'selector should use lower case, in "${selector}"'

    def check(self, ruleSet, config):
        selector = ruleSet.selector
        if selector.lower() != selector:
            return False

        return True 

    def fix(self, ruleSet, config):
        # if fix upper to lower, will cause error in HTML(do not do evil)
        pass
        #selector = ruleSet.selector
        #if selector.lower() != selector:
        #    ruleSet.fixedSelector = ruleSet.fixedSelector.lower()
#/usr/bin/python
#encoding=utf-8

from Base import *

class FEDUseSingleQuotation(RuleChecker):
    
    '''{
        "summary":"使用单引号",
        "desc":"CSS的属性取值一律使用单引号<code>'</code>， 不允许使用双引号"
    }'''

    def __init__(self):
        self.id = 'single-quotation'
        self.errorLevel = ERROR_LEVEL.WARNING
        self.errorMsg = 'replace " with \' in "${selector}"'

    def check(self, rule, config):
        if self._findDouble(rule.value):
            return False

        return True

    def fix(self, rule, config):
        if self._findDouble(rule.value):
            rule.fixedValue = rule.value.replace('"', "'")

    def _findDouble(self, value):
        return value.find('"') != -1
#/usr/bin/python
#encoding=utf-8

from Base import *
from validators.ValidatorFactory import doValidate

class FEDUseValidValues(RuleChecker):
    
    '''{
        "summary":"不正确的属性取值",
        "desc":"检查不正确的属性取值，比如： <code>width: underline;</code> 等"
    }'''

    def __init__(self):
        self.id = 'valid-values'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg_rough = '%s in "${selector}"'
        self.errorMsg = ''

    def check(self, rule, config):
        flag, msg = doValidate(rule.name, rule.strippedValue)
        if flag is True:
            return True

        self.errorMsg = self.errorMsg_rough % msg
        return False

    def fix(self, rule, config):
        pass
#/usr/bin/python
#encoding=utf-8

from Base import *
import string
from helper import isCss3PrefixProp

class FEDZIndexShouldInRange(RuleChecker):
    
    '''{
        "summary":"z-index取值应符合范围要求",
        "desc":"<code>z-index</code> 的取值如果混乱，则会造成层之间的相互覆盖，
            因此 <code>z-index</code> 取值必须符合一定的范围要求，具体要求请参见人人FED CSS编码规范"
    }'''

    def __init__(self):
        self.id = 'z-index-in-range'
        self.errorLevel = ERROR_LEVEL.ERROR
        self.errorMsg = 'value of "z-index" is not correct in "${selector}"'

    def check(self, rule, config):
        if rule.name != 'z-index':
            return True

        zIndex = None
        try:
            zIndex = string.atoi(rule.value)
        except ValueError:
            return False

        if zIndex < -1:
            return False

        if zIndex > 2100:
            return False

        return True 

########NEW FILE########
__FILENAME__ = combineRules
#/usr/bin/python
#encoding=utf-8
import os 
import json

def loadPlugins(pluginDir):
    ids = []
    content = ''
    '''从plugins目录动态载入检查类'''
    for filename in os.listdir(pluginDir):
        if not filename.endswith('.py') or filename.startswith('_'):
            continue
        if filename == 'Base.py' or filename == 'helper.py':
            continue
        content = content + open(pluginDir + '/' + filename, 'r').read()

    open('AllRules.py', 'w').write(content);

loadPlugins('../ckstyle/plugins')
########NEW FILE########
__FILENAME__ = exportRules
#/usr/bin/python
#encoding=utf-8
import os 
import json

def loadPlugins(pluginDir):
    ids = []
    tmp = '{id:"%s", priority:%s, summary:"%s", desc:"%s", checked:%s}';

    '''从plugins目录动态载入检查类'''
    for filename in os.listdir(pluginDir):
        if not filename.endswith('.py') or filename.startswith('_'):
            continue
        if filename == 'Base.py' or filename == 'helper.py':
            continue
        pluginName = os.path.splitext(filename)[0]

        # 获取plugins的引用
        plugin = __import__("ckstyle.plugins." + pluginName, fromlist = [pluginName])
        pluginClass = None
        if hasattr(plugin, pluginName):
            pluginClass = getattr(plugin, pluginName)
        else:
            console.error('[TOOL] class %s should exist in %s.py' % (pluginName, pluginName))
            continue
        # 构造plugin的类
        instance = pluginClass()
        if (hasattr(instance, 'private') and getattr(instance, 'private') is True):
            continue
        obj = {}
        obj["id"] = instance.id
        obj["priority"] = instance.errorLevel
        obj["desc"] = pluginClass.__name__
        obj["summary"] = pluginClass.__name__
        doc = pluginClass.__doc__

        data = None
        if (doc != None):
            doc = doc.replace('\n', '')
            doc = doc.replace('\t', '')
            doc = doc.replace('  ', '')
            try:
                data = json.loads(doc)
            except Exception, e:
                print '[JSON ERROR] doc error in ' + pluginClass.__name__ + ', not json format'
                obj["desc"] = pluginClass.__doc__
        if data is not None:
            if data.has_key('summary') and data['summary'] != 'xxx':
                obj['summary'] = data['summary'].encode('utf-8')
            if data.has_key('desc') and data['desc'] != 'xxx':
                obj['desc'] = data['desc'].encode('utf-8')

        obj["checked"] = 'true' if (instance.errorLevel == 0 or instance.errorLevel == 1) else 'false'
        ids.append(tmp % (obj["id"], obj["priority"], obj["summary"], obj["desc"], obj["checked"]))

    open('D:/git/CSSCheckStyle-website/js/rules.js', 'w').write('var RULES = [\n    ' + (',\n    '.join(ids)) + '\n];');

loadPlugins('../ckstyle/plugins')
########NEW FILE########
__FILENAME__ = test
plugin = __import__("ckstyle.plugins.AllRules", fromlist = ['AllRules'])
props = dir(plugin)
for prop in props:
	if prop.startswith('FED'):
		print prop
########NEW FILE########
