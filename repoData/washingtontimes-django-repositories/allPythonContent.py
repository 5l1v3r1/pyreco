__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# app documentation build configuration file, created by
# sphinx-quickstart on Wed Oct 21 13:18:22 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('..'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'example.settings'

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'repositories'
copyright = u'2009, me'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'repositoriesdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'app.tex', u'repositories Documentation',
   u'me', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for example project.

DEBUG = True
TEMPLATE_DEBUG = DEBUG
import os, sys
APP = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
sys.path.append(APP)

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS

DATABASE_ENGINE = 'sqlite3'           # 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
DATABASE_NAME = 'dev.db'             # Or path to database file if using sqlite3.
DATABASE_USER = ''             # Not used with sqlite3.
DATABASE_PASSWORD = ''         # Not used with sqlite3.
DATABASE_HOST = ''             # Set to empty string for localhost. Not used with sqlite3.
DATABASE_PORT = ''             # Set to empty string for default. Not used with sqlite3.

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = ''

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
# trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/media/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'g2_39yupn*6j4p*cg2%w643jiq-1n_annua*%i8+rq0dx9p=$n'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.load_template_source',
    'django.template.loaders.app_directories.load_template_source',
#     'django.template.loaders.eggs.load_template_source',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
)

ROOT_URLCONF = 'example.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'repositories',
)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Example:
    # (r'^example/', include('example.foo.urls')),

    # Uncomment the admin/doc line below and add 'django.contrib.admindocs' 
    # to INSTALLED_APPS to enable admin documentation:
    # (r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # (r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = admin
from django import forms
from django.contrib import admin
from models import SourceRepository, Metadata, RemoteSourceRepository
from django.conf import settings


class MetadataInline(admin.TabularInline):
    model=Metadata

class RemoteRepositoryForm(forms.ModelForm):
    class Meta:
        exclude = ('notes',)
        model=RemoteSourceRepository

class RemoteRepositoryInline(admin.TabularInline):
    form=RemoteRepositoryForm
    model=RemoteSourceRepository


if 'objectpermissions' in settings.INSTALLED_APPS:
    USE_OBJECT_PERMS = True
    from objectpermissions.admin import TabularUserPermInline, TabularGroupPermInline
    if 'projects' in settings.INSTALLED_APPS:
        repo_admin_inlines = [MetadataInline, RemoteRepositoryInline]
    else:
        repo_admin_inlines = [TabularUserPermInline, TabularGroupPermInline, MetadataInline, RemoteRepositoryInline]
else:
    USE_OBJECT_PERMS = False
    from models import RepositoryUser, RepositoryGroup
    
    class UserInline(admin.TabularInline):
        model=RepositoryUser
    
    class GroupInline(admin.TabularInline):
        model=RepositoryGroup
    
    repo_admin_inlines=[UserInline, GroupInline, MetadataInline, RemoteRepositoryInline]


class SourceRepositoryAdmin(admin.ModelAdmin):
    list_filter = ('anonymous_access', 'vc_system', 'inactive',)
    list_display = ('name', 'vc_system', 'anonymous_access', 'inactive',)
    list_editable = ('anonymous_access', 'inactive')
    ordering = ('name', 'vc_system', 'anonymous_access', )
    search_fields = ('name', 'description', 'summary')
    inlines = repo_admin_inlines
    popup_fields = ('name', 'vc_system', 'repo_template')
    
    def save_model(self, request, obj, form, change):
        super(SourceRepositoryAdmin, self).save_model(request, obj, form, change)
        if not change and USE_OBJECT_PERMS:
            request.user.grant_object_perm(obj, ['read','write','owner'])
    
    def queryset(self, request):
        """
        Filter the objects displayed in the change_list to show only those with
        write or owner permissions
        """
        if request.user.is_superuser:
            return super(SourceRepositoryAdmin, self).queryset(request)
        return SourceRepository.objects.get_for_user(request.user, 6) # write = 2, owner = 4
    
    def get_form(self, request, obj=None, **kwargs):
        """
        Return a different set of fields if the form is shown in a popup window
        versus a normal window. To provide better integration with a project
        manager, which will presumably be managing certain information, we 
        include only the bare necessity of fields in the popup menu.
        
        This is pretty much copied from Django source, with a bit to make it work
        with 1.1 as well as 1.2.
        
        Returns a Form class for use in the admin add view. This is used by
        add_view and change_view.
        """
        from django.contrib.admin.util import flatten_fieldsets
        from django.forms.models import modelform_factory
        from django.utils.functional import curry
        
        if request.REQUEST.has_key('_popup'):
            fields = flatten_fieldsets([(None, {'fields': self.popup_fields})])
        elif self.declared_fieldsets:
            fields = flatten_fieldsets(self.declared_fieldsets)
        else:
            fields = None
        if self.exclude is None:
            exclude = []
        else:
            exclude = list(self.exclude)
        exclude.extend(kwargs.get("exclude", []))
        
        if hasattr(self, 'get_readonly_fields'):
            exclude.extend(self.get_readonly_fields(request, obj))
        # if exclude is an empty list we pass None to be consistant with the
        # default on modelform_factory
        exclude = exclude or None
        defaults = {
            "form": self.form,
            "fields": fields,
            "exclude": exclude,
            "formfield_callback": curry(self.formfield_for_dbfield, request=request),
        }
        defaults.update(kwargs)
        return modelform_factory(self.model, **defaults)


admin.site.register(SourceRepository, SourceRepositoryAdmin)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from models import SourceRepository

class SourceRepositoryForm(forms.ModelForm):
    class Meta:
        model = SourceRepository

########NEW FILE########
__FILENAME__ = repo_check_for_updates
import os
from django.core.management.base import BaseCommand
from repositories import settings
from repositories.models import SourceRepository
from repositories.signals import repository_changed

class Command(BaseCommand):
    def handle(self, *args, **options):
        for repo in SourceRepository.objects.all():
            try:
                current_rev = repo._vcs.get_current_rev()
                if current_rev != repo.current_rev:
                    repo.previous_rev = repo.current_rev
                    repo.current_rev = current_rev
                    repo.save()
                    repository_changed.send(sender=repo, current_rev= current_rev, previous_rev=repo.previous_rev)
            except:
                # If there was an error, we'll move on.
                continue
########NEW FILE########
__FILENAME__ = repo_export
import os
from django.core.management.base import BaseCommand
from repositories import settings
from repositories.models import SourceRepository


class Command(BaseCommand):
    def handle(self, *args, **options):
        os.chdir(settings.REPO_EXPORT_DIR)
        for repo in SourceRepository.objects.filter(anonymous_access=True):
            if repo.get_vc_system_display() == 'Subversion':
                os.system('svn export file://%s/trunk %s' % (repo.repo_path, repo.name) )
                os.system('zip -r %s.zip %s' % (repo.name, repo.name) )
                os.system('tar -czvf  %s.tgz %s' % (repo.name, repo.name) )
                os.system('rm -rf %s' % repo.name)
            elif repo.get_vc_system_display() == 'Git':
                os.system('git clone file://%s %s' % (repo.repo_path, repo.name) )
                os.chdir(repo.name)
                os.system('git archive master --format=zip -o ../%s.zip' % repo.name)
                os.system('git archive master --format=tar  | gzip > ../%s.tgz' % repo.name)
                os.chdir('..')
                os.system('rm -rf %s' % repo.name)

########NEW FILE########
__FILENAME__ = repo_generate_apache_conf
import os
from django.core.management.base import BaseCommand, CommandError
from django.template import Template, Context
from django.template.loader import get_template

from repositories import settings

class Command(BaseCommand):
    def __init__(self):
        super(Command, self).__init__()
        VCS = {}
        for key, value in settings.VCS_CONFIG.items():
            VCS[value['name'].lower()] = value
        self.VCS = VCS
    
    def handle(self, *args, **options):
        tmpl = get_template('repositories/apache2_auth.conf')
        ctxt_dict = {}
        ctxt_dict['wsgi_auth_script_path'] = os.path.dirname(settings.WSGI_AUTH_SCRIPT)
        ctxt_dict['wsgi_auth_script'] = settings.WSGI_AUTH_SCRIPT
        ctxt_dict['wsgi_script'] = settings.WSGI_SCRIPT
        ctxt = Context(ctxt_dict)
        print tmpl.render(ctxt)
        
        for key in self.VCS.keys():
            self.handle_type(key)
    
    def handle_type(self, label, **options):
        try:
            vcs_config = self.VCS[label]
        except KeyError:
            raise CommandError("'%s' is not configured in REPO_VCS_CONFIG" % label)
        
        tmpl = get_template('repositories/apache2_%s.conf' % label)
        ctxt_dict = vcs_config.copy()
        ctxt_dict['wsgi_auth_script_path'] = os.path.dirname(settings.WSGI_AUTH_SCRIPT)
        ctxt_dict['wsgi_auth_script'] = settings.WSGI_AUTH_SCRIPT
        ctxt_dict['wsgi_script'] = settings.WSGI_SCRIPT
        ctxt = Context(ctxt_dict)
        print tmpl.render(ctxt)
########NEW FILE########
__FILENAME__ = repo_generate_auth
import os
from django.core.management.base import BaseCommand, CommandError
from django.template import Template, Context
from django.template.loader import get_template

from repositories import settings

class Command(BaseCommand):
    help = "Generate an auth.wsgi script given the path to the project"
    def handle(self, *args, **options):
        ctxt_dict = {}
        if len(args) == 1:
            ctxt_dict['project_root'] = args[0]
        else:
            path = ''
            for item in args:
                key, val = item.split('=')
                ctxt_dict[key] = val
        
        tmpl = get_template('repositories/auth.wsgi')
        ctxt_dict.update(options)
        ctxt = Context(ctxt_dict)
        print tmpl.render(ctxt)

########NEW FILE########
__FILENAME__ = models
import shutil, os

from django.db import models
from django.contrib.auth.models import User, Group
from django.conf import settings as global_settings
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext_lazy as _

import settings, vcs

"""
Uses the types of version control systems configured through the 
``REPO_VCS_CONFIG`` setting to create a ``list`` of ``integer``, ``string`` 
``tuples``. It is used for :attr:`SourceRepository.vc_system` choices.
"""
VC_TYPE_CHOICES = [(key, value['name']) for key, value in settings.VCS_CONFIG.items()]

"""A dictionary that maps a version control name to the appropriate class defined in :mod:`projectmgr.vcs`\ ."""
VCS = {}
for key, value in settings.VCS_CONFIG.items():
    VCS[key] = getattr(vcs, value['name']+'Repository')


#: Bitwise permissions:
#: 
#: * 1 = Read
#: * 2 = Write
#: * 4 = Owner
PERM_CHOICES = (
    (1, "Read"),
    (3, "Read/Write"),
    (7, "Owner")
)

class SourceRepositoryManager(models.Manager):
    
    def get_for_user(self, user, permission=3):
        """
        Return a list of source repositories which the user has at least the
        given permission level
        
        :param user: The :class:`User` for which to find :class:`SourceRepository` instances.
        :type user: :class:`User`
        :param permission: The type of permission, one of :data:`repositories.models.PERM_CHOICES`\ . **Default:** 3 (read/write)
        :type permission: `integer`
        :returns: A :class:`QuerySet` of :class:`SourceRepository`
        :rtype: :class:`QuerySet`
        """
        if settings.USE_OBJECT_PERMS:
            return user.get_objects_with_perms(SourceRepository, permission)
        project_ids = []
        if permission == 1:
            # We have to add in every Public source repository in only this case
            project_ids.extend([x[0] for x in SourceRepository.objects.filter(anonymous_access=True).values_list('id')])
        project_ids.extend([x[0] for x in RepositoryUser.objects.filter(user=user, permission__gte=permission).values_list('source_repository_id')])
        
        group_ids = [x[0] for x in user.groups.all().values_list('id')]
        repo_ids = [x[0] for x in RepositoryGroup.objects.filter(
                                permission__gte=permission, 
                                group__id__in=group_ids).values_list('source_repository_id')]
        project_ids.extend(repo_ids)
        return super(SourceRepositoryManager, self).get_query_set().filter(pk__in=project_ids).order_by('name')

class SourceRepository(models.Model):
    """
    A version controlled source code repository
    """
    name = models.SlugField(_("Name"))
    summary = models.CharField(_('Summary'), max_length=255, blank=True, null=True)
    description = models.TextField(_('Description'), blank=True,null=True)
    vc_system = models.IntegerField(_("Version Control System"), choices=VC_TYPE_CHOICES)
    anonymous_access = models.BooleanField(_("Allow Anonymous Viewing"), default=True)
    repo_template = models.CharField(_("Initial Repository Template"), 
        blank=True, choices=settings.get_repo_template_choices(), 
        max_length=255,
        help_text="Import this template into the repository when it is created. "\
                  "Changing it afterwards has no effect.")
    repo_path = models.CharField(editable=False, max_length=255)
    repo_url = models.CharField(editable=False, max_length=255)
    current_rev = models.CharField(blank=True, max_length=50, editable=False)
    previous_rev = models.CharField(blank=True, max_length=50, editable=False)
    inactive = models.BooleanField(default=False)
    
    class Meta:
        verbose_name = _("Source Repository")
        verbose_name_plural = _("Source Repositories")
        ordering = ('name',)
    
    def __unicode__(self):
        return self.name
    
    objects = SourceRepositoryManager()
    
    def __init__(self, *args, **kwargs):
        """
        When a :class:`SourceRepository` object is instantiated and the object
        has selected a version control system, it sets up the ``self._vcs`` 
        attribute to the :class:`VCSClass` implementation, else set it to ``None``
        """
        super(SourceRepository, self).__init__(*args, **kwargs)
        # Select the appropriate VCS class from the VCS dictionary and instantiate it
        if self.vc_system:
            VCSClass = VCS[self.vc_system]
            self._vcs = VCSClass(self.name, self.anonymous_access, self.repo_template)
        else:
            self._vcs = None
    
    @models.permalink
    def get_absolute_url(self):
        """
        The path to the repository
        
        :rtype: ``string``
        """
        return self._vcs.get_absolute_url()
    
    
    def owners(self):
        """
        Get the users with owner access, including users that are in a
        :class:`RepositoryGroup` with owner access.
        
        :rtype: ``list`` of :class:`User`
        """
        if settings.USE_OBJECT_PERMS:
            users = self.userpermission_set.filter()
        else:
            users = self.repositoryuser_set.filter(permission=7).select_related()
            groups = self.repositorygroup_set.filter(permission=7).select_related()
        
            user_set = set([i.user for i in users])
            for group in groups:
                user_set.update(set(group.user_set.all()))
        return list(user_set)
    
    
    def members(self):
        """
        Get the users with write access, including users that are in a
        :class:`RepositoryGroup` with write access.
        
        :rtype: ``list`` of :class:`User`
        """
        users = self.repositoryuser_set.filter(permission=3).select_related()
        groups = self.repositorygroup_set.filter(permission=3).select_related()
        
        user_set = set([i.user for i in users])
        for group in groups:
            user_set.update(set(group.user_set.all()))
        return list(user_set)
    
    
    def user_is_owner(self, userobj):
        """
        Is this user an owner of the project?
        
        :param userobj: The :class:`User` to test
        :type userobj: :class:`User`
        :returns: ``True`` if the :class:`User` is an owner
        :rtype: ``boolean``
        """
        if settings.USE_OBJECT_PERMS:
            return userobj.has_object_perm(self, self.perms.owner)
        else:
            try:
                repousr = self.repositoryuser_set.get(user=userobj)
                return repousr.permission > 4
            except:
                pass
        
            for group in self.repositorygroup_set.filter(permission__gte=5):
                if userobj in group.group.user_set.all():
                    return True
        
        return False
    
    
    def user_can_write(self, userobj):
        """
        Does this user have write access to this repository?
        
        :param userobj: The :class:`User` to test
        :type userobj: :class:`User`
        :returns: ``True`` if the :class:`User` can write to this repository
        :rtype: ``boolean``
        """
        if settings.USE_OBJECT_PERMS:
            return userobj.has_object_perm(self, self.perms.write)
        else:
            try:
                repousr = self.repositoryuser_set.get(user=userobj)
                return repousr.permission > 2
            except:
                pass
        
            for group in self.repositorygroup_set.filter(permission__gte=3):
                if userobj in group.group.user_set.all():
                    return True
        
        return False
    
    
    def user_can_read(self, userobj):
        """
        Does the user have read access to this repository?
        
        :param userobj: The :class:`User` to test
        :type userobj: :class:`User`
        :returns: ``True`` if the :class:`User` can read this repository
        :rtype: ``boolean``
        """
        if self.anonymous_access:
            return True
        if settings.USE_OBJECT_PERMS:
            return userobj.has_object_perm(self, self.perms.read)
        else:
            try:
                repousr = self.repositoryuser_set.get(user=userobj)
                return True # If we have a user, it must have at least read
            except:
                pass
        
            for group in self.repositorygroup_set.all():
                if userobj in group.group.user_set.all():
                    return True
        
        return False
    
    
    def move_to_public(self):
        """
        Move a repository from private to public. 
        
        Calls the instantiated version control object to do the low-level work,
        and then updates the :attr:`repo_path` and :attr:`repo_url`
        
        :returns: Nothing
        """
        self._vcs.make_public()
        self.repo_path = self._vcs.path
        self.repo_url = self._vcs.url
        
    
    def move_to_private(self):
        """
        Move a repository from public to private
        
        Calls the instantiated version control object to do the low-level work,
        and then updates the :attr:`repo_path` and :attr:`repo_url`
        
        :returns: Nothing
        """
        self._vcs.make_private()
        self.repo_path = self._vcs.path
        self.repo_url = self._vcs.url
        
    def save(self, force_insert=False, force_update=False):
        """
        We have to do a little maintenance before we save the record. It:
        
        * creates the repository if it is new
        * moves the repository from public to/from private as necessary
        * updates the :attr:`repo_path` and :attr:`repo_url`\ .
        """
        new = self.id is None
        if new:
            VCSClass = VCS[self.vc_system]
            self._vcs = VCSClass(self.name, self.anonymous_access, self.repo_template)
            self._vcs.create()
        if self._vcs.public != self.anonymous_access and not new:
            if self.anonymous_access:
                self._vcs.make_public()
            else:
                self._vcs.make_private()
        self.repo_path = self._vcs.path
        self.repo_url = self._vcs.url
        super(SourceRepository, self).save(force_insert, force_update)
    
    
    def delete(self):
        """
        Deletes the source repository before it deletes the record.
        """
        # Delete the source repository here
        self._vcs.delete()
        super(SourceRepository, self).delete()
    
    
    def list(self, path="/"):
        """
        Return a directory listing from the given repository path. **Not Implemented Yet**
        """
        pass


if settings.USE_OBJECT_PERMS:
    import objectpermissions
    objectpermissions.register(SourceRepository, ['read', 'write', 'owner'])


class RemoteSourceRepository(models.Model):
    """
    A source code repository on a remote server to which updates should be pushed.
    
    Pushing to a mirror on GitHub or LaunchPad is a common use.
    """
    repo = models.ForeignKey('SourceRepository', verbose_name=_('Repository'))
    name = models.SlugField(_('Name'))
    branch = models.CharField(_('Branch'), max_length=255, default='master')
    url = models.CharField(_('URL'), max_length=255, blank=True, help_text='Leave blank and the remote repository will be created')
    notes = models.TextField(_('Notes'), blank=True, 
        help_text=_('Notes about this remote repository'))
    active = models.BooleanField(_('Active'), default=True)
    
    def __unicode__(self):
        return '%s for %s' % (self.name, self.repo.name)
    
    def save(self, *args, **kwargs):
        VCSClass = VCS[self.repo.vc_system]
        self._vcs = VCSClass(self.repo.name, self.repo.anonymous_access, self.repo.repo_template)
        new = False
        if not self.id:
            new = True
            self.url = self.url or self._vcs.create_remote(self.repo.name)
        super(RemoteSourceRepository, self).save(*args, **kwargs)
        # Current only git is supported for remote repos
        if new and self.repo.vc_system == 3:
            self._vcs.add_remote(self.name, self.url, self.branch)
            generate_hooks(self.repo)
            
    def delete(self):
        VCSClass = VCS[self.repo.vc_system]
        self._vcs = VCSClass(self.repo.name, self.repo.anonymous_access, self.repo.repo_template)
        if self.repo.vc_system == 3:
            self._vcs.remove_remote(self.name)
            generate_hooks(self.name)
        super(RemoteSourceRepository, self).delete()
        
    class Meta:
        unique_together = ('repo', 'name')
        verbose_name_plural = 'Remote Source Repositories'

    
def generate_hooks(repo, htype='post-update', rtype='git'):
    if not isinstance(repo, SourceRepository):
        return
    if not htype:
        return
    # Only git repo's are supported atm.
    if rtype == 'git':
        try:
            import os, stat
            file_name = htype
            t = get_template('hooks/%s' % file_name)
            c = {'remote_repos': RemoteSourceRepository.objects.filter(repo__pk=repo.pk)}
            ret = render_to_string(t.name, c)
            file_path = '%s/hooks/%s' % (repo.repo_path, file_name)
            f = open(file_path, 'w+')
            f.write(ret)
            f.close()
            # set the premissions of the file
            os.chmod(file_path, stat.S_IWRITE | stat.S_IREAD | stat.S_IEXEC | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)
        except:
            pass

def update_remote(sender, current_rev, previous_rev, **kwargs):
    """
    Update a remote repository when it receives a repository_changed signal and
    it has one or more remote repositories.
    
    :param sender: The :class:`SourceRepository` that changed
    :type sender: :class:`SourceRepository`
    :param current_rev: The current revision
    :type current_rev: ``string``
    :param previous_rev: The previous revision found. There could be multiple
                         revisions in between, depending on the checking frequency
    :type previous_rev: ``string``
    """
    for remote_repo in sender.remotesourcerepository_set.all():
        sender._vcs.update_remote(name=remote_repo.name, branch=remote_repo.branch)

from signals import repository_changed
repository_changed.connect(update_remote)


class Metadata(models.Model):
    """
    Metadata for a SourceRepository. It is a key/value store. The value is a 
    freeform string. Examples of what one can use this metadata for:
    
    * Creating an install script.
    * Specifying dependencies
    * Current version
    
    The choices of metadata keys are configured in ``REPO_METADATA_KEYS``\ .
    A 'Version' key is added if it was not otherwise configured. A common choice
    for the metadata keys is the metadata for the Python Package Index.
    """
    source_repository = models.ForeignKey(SourceRepository)
    key = models.CharField(blank=False, null=False, max_length=255, choices=settings.METADATA_CHOICES)
    value = models.CharField(blank=True, null=True, max_length=255)
    
    def __unicode__(self):
        if self.value:
            return "%s = %s" % (self.key, self.value)
        else:
            return self.key


if not settings.USE_OBJECT_PERMS:
    # These classes are used instead of object permissions to 
    # remove the dependency on objectpermissions
    class RepositoryGroup(models.Model):
        """
        A group of people who have access to a repository and their access permissions.
        """
    
        source_repository = models.ForeignKey(SourceRepository)
        group = models.ForeignKey(Group)
        permission = models.IntegerField(_('Permission'), choices=PERM_CHOICES)
    
        def __unicode__(self):
            out = u"%s of %s with %s permission" % (self.group, 
                    self.source_repository, self.get_permission_display())
            return out


    class RepositoryUser(models.Model):
        """
        A User of a repository and that person's access permissions.
        """
    
        source_repository = models.ForeignKey(SourceRepository)
        user = models.ForeignKey(User)
        permission = models.IntegerField(_('Permission'), choices=PERM_CHOICES)
    
        def __unicode__(self):
            out = u"%s of %s with %s permission" % (self.user, 
                    self.source_repository, self.get_permission_display())
        
            return out

########NEW FILE########
__FILENAME__ = settings
import os
from django.conf import settings

USE_OBJECT_PERMS = 'objectpermissions' in settings.INSTALLED_APPS

BIN_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__),'bin'))

REPO_EXPORT_DIR = getattr(settings, 'REPO_EXPORT_DIR', 'exports')

default_base_repo_path = os.path.join(os.path.dirname(__file__), 'repositories')
BASE_REPO_PATH = getattr(settings, 'REPO_BASE_REPO_PATH', default_base_repo_path)

DEFAULT_VCS_CONFIG = {
    1:{
        'name':'Subversion',
        'command': 'svn',
        'public_path': os.path.join(BASE_REPO_PATH, 'svn', 'public') + "/",
        'private_path': os.path.join(BASE_REPO_PATH, 'svn', 'private') + "/",
        'public_url': '/svn/public/',
        'private_url': '/svn/private/',
        'config_dir': None,
    },
    2:{
        'name': 'Bazaar',
        'command': 'bzr',
        'public_path': os.path.join(BASE_REPO_PATH, 'bzr', 'public') + "/",
        'private_path': os.path.join(BASE_REPO_PATH, 'bzr', 'private') + "/",
        'public_url': '/bzr/public/',
        'private_url': '/bzr/private/',
    },
    3:{
        'name': 'Git',
        'command': 'git',
        'public_path': os.path.join(BASE_REPO_PATH, 'git', 'public') + "/",
        'private_path': os.path.join(BASE_REPO_PATH, 'git', 'private') + "/",
        'public_url': '/git/public/',
        'private_url': '/git/private/',
    },
    4:{
        'name': 'Mercurial',
        'command': 'hg',
        'public_path': os.path.join(BASE_REPO_PATH, 'hg', 'public') + "/",
        'private_path': os.path.join(BASE_REPO_PATH, 'hg', 'private') + "/",
        'public_url': '/hg/public/',
        'private_url': '/hg/private/',
    },
}

VCS_CONFIG = getattr(settings, 'REPO_VCS_CONFIG', DEFAULT_VCS_CONFIG)

DEFAULT_SVN_CONFIG_DIR = None
SVN_CONFIG_DIR = getattr(settings, 'REPO_SVN_CONFIG_DIR', DEFAULT_SVN_CONFIG_DIR)

def get_repo_template_choices():
    """
    Get a list of folders that contain the templates for first import.
    """
    rtmpls=os.listdir(os.path.abspath(os.path.join(os.path.dirname(__file__), 'repo-templates')))
    return [(item,item) for item in rtmpls if item[0] != '.']

DEFAULT_METADATA_KEYS = ['Version',]
METADATA_KEYS = getattr(settings, 'REPO_METADATA_KEYS', DEFAULT_METADATA_KEYS)
try:
    VERSION_KEY = [key for key in METADATA_KEYS if key.lower() == 'version'][0]
except IndexError:
    VERSION_KEY = 'Version'
    METADATA_KEYS.append(VERSION_KEY)
METADATA_CHOICES = [(key, key) for key in METADATA_KEYS]

DEFAULT_URL_PATTERN = r'^/\w+/\w+/(?P<repo_name>\w+)/'
URL_PATTERN = getattr(settings, 'REPO_URL_PATTERN', DEFAULT_URL_PATTERN)

DEFAULT_WSGI_AUTH_SCRIPT = os.path.join(os.path.dirname(__file__),'bin','auth.wsgi')
WSGI_AUTH_SCRIPT = getattr(settings, 'REPO_WSGI_AUTH_SCRIPT', DEFAULT_WSGI_AUTH_SCRIPT)

WSGI_SCRIPT = getattr(settings, 'WSGI_SCRIPT', '')

GITHUB_USERNAME = getattr(settings, 'REPO_GITHUB_USERNAME', '')
GITHUB_API_TOKEN = getattr(settings, 'REPO_GITHUB_API_TOKEN', '')
########NEW FILE########
__FILENAME__ = signals
import django.dispatch
repository_changed = django.dispatch.Signal(providing_args=["current_rev", "previous_rev"])

########NEW FILE########
__FILENAME__ = tests
import unittest, os
from models import SourceRepository
import settings
PUBLIC_REPO_DIR = settings.VCS_CONFIG[1]['public_path']
PRIVATE_REPO_DIR = settings.VCS_CONFIG[1]['private_path']

class SourceRepositoryTestCase(unittest.TestCase):
    def setUp(self):
        src_repo = SourceRepository(name="public-repo", vc_system=1, anonymous_access=True)
        src_repo.save()
        src_repo = SourceRepository(name="private-repo", vc_system=1, anonymous_access=False)
        src_repo.save()
    
    def tearDown(self):
        objs = SourceRepository.objects.all()
        for obj in objs:
            obj.delete()
    
    def testNewPublicRepo(self):
        """
        Creating a new SourceRepository object should create a new repository
        """
        src_repo = SourceRepository.objects.get(name="public-repo")
        self.assertEquals(src_repo.repo_path, os.path.abspath(os.path.join(PUBLIC_REPO_DIR, 'public-repo')))
        self.assertTrue(os.path.exists(src_repo.repo_path))
    
    def testNewPrivateRepo(self):
        """
        Creating a new SourceRepository object should create a new repository
        """
        src_repo = SourceRepository.objects.get(name="private-repo")
        self.assertEquals(src_repo.repo_path, os.path.abspath(os.path.join(PRIVATE_REPO_DIR, 'private-repo')))
        self.assertTrue(os.path.exists(src_repo.repo_path))
    
    def testMovePrivateToPublic(self):
        """
        Switching the anonymous_access flag should change the location of the 
        repository
        """
        src_repo = SourceRepository.objects.get(name="private-repo")
        src_repo.anonymous_access = True
        src_repo.save()
        self.assertEquals(src_repo.repo_path, os.path.abspath(os.path.join(PUBLIC_REPO_DIR, 'private-repo')))
        self.assertTrue(os.path.exists(src_repo.repo_path))
    
    def testMovePrivateToPublic(self):
        """
        Switching the anonymous_access flag should change the location of the 
        repository
        """
        src_repo = SourceRepository.objects.get(name="public-repo")
        src_repo.anonymous_access = False
        src_repo.save()
        self.assertEquals(src_repo.repo_path, os.path.abspath(os.path.join(PRIVATE_REPO_DIR, 'public-repo')))
        self.assertTrue(os.path.exists(src_repo.repo_path))
    
    def testDeletePublicRemovesRepo(self):
        """
        Deleting the repository should remove the repository
        """
        src_repo = SourceRepository.objects.get(anonymous_access=True)
        repo_path = src_repo.repo_path
        src_repo.delete()
        self.assertFalse(os.path.exists(repo_path))
    
    def testDeletePrivateRemovesRepo(self):
        """
        Deleting the repository should remove the repository
        """
        src_repo = SourceRepository.objects.get(anonymous_access=False)
        repo_path = src_repo.repo_path
        src_repo.delete()
        self.assertFalse(os.path.exists(repo_path))

if __name__ == '__main__':
    unittest.main()
    
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    url(r'^$', 'views.index', name='index'),
)

########NEW FILE########
__FILENAME__ = utils
from projectmgr.models import SourceRepository, Metadata
from projectmgr.settings import VERSION_KEY
from django.template import loader, Context
from django.contrib.sites.models import Site

try:
    from markdown2rest import markdown2rest
    mkdn2rest = markdown2rest
except ImportError:
    mkdn2rest = lambda a: a

def create_setup_script(sourcerepo):
    """
    Create a setup.py file and print it to standard out based on repository settings
    
    You can pass in a string/unicode for the name of the project, and int for
    the id of the project, or an instance of the model.
    """
    if isinstance(sourcerepo, (str,unicode)):
        repo = SourceRepository.objects.get(name=sourcerepo)
    elif isinstance(sourcerepo, int):
        repo = SourceRepository.objects.get(pk=sourcerepo)
    elif isinstance(sourcerepo, SourceRepository):
        repo = sourcerepo
    tpl = loader.get_template('setup_py.txt')
    
    site = Site.objects.get_current()
    authors = repo.owners()
    try:
        version = repo.metadata_set.get(key=VERSION_KEY).value
    except:
        version = '0.0.1'
    description = repo.summary or ''
    long_description = repo.description or ''
    context = Context({
        'name': repo.name,
        'version': version,
        'description': mkdn2rest(description),
        'long_description': mkdn2rest(long_description),
        'author': ", ".join([author.get_full_name() for author in authors]),
        'author_email': ", ".join([author.email for author in authors]),
        'url': "%s%s" % (site.domain,repo.get_absolute_url()),
        'classifications': [md.key for md in repo.metadata_set.all() if md.key != VERSION_KEY],
    })
    return tpl.render(context)

    
########NEW FILE########
__FILENAME__ = base
import os, shutil
import settings

class BaseVCS(object):
    def __init__(self, name, anonymous_access, template=None):
        """
        A base class to handle Version Control System functions
        
        name = name of the repository
        anonymous_access = Is it public?
        template = The name of the template to use
        """
        self.public = anonymous_access
        self.name = name
        self.template = template
        self.config = self.get_config()
        self._update_path() # Sets self.path and url
    
    def _update_path(self):
        """
        Determine where the repository is. It is called in __init__ and sets 
        self.path and self.url
        """
        if self.public:
            self.path = os.path.abspath(os.path.join(self.config['public_path'], self.name))
            self.url = "%s%s/" % (self.config['public_url'], self.name)
        else:
            self.path = os.path.abspath(os.path.join(self.config['private_path'], self.name))
            self.url = "%s%s/" % (self.config['private_url'], self.name)
    
    
    def get_config(self):
        """
        Search the configuration for the correct record
        """
        name = self.__class__.__name__.replace('Repository','')
        for value in settings.VCS_CONFIG.values():
            if value['name'] == name:
                return value
        raise Exception("The configuration for %s is missing." % name)
    
    def exists(self):
        """
        Does the repository exist on the file system?
        """
        return os.path.exists(self.path)
    
    def create(self):
        """
        Create a new repository
        """
        NotImplementedError
    
    def make_public(self):
        """
        Move a repository from private to public
        """
        dest = os.path.abspath(os.path.join(self.config['public_path'], self.name))
        source = self.path
        shutil.move(source, dest)
        self.public = True
        self._update_path()
    
    def make_private(self):
        """
        Move a repository from public to private
        """
        source = self.path
        dest = os.path.abspath(os.path.join(self.config['private_path'], self.name))
        shutil.move(source, dest)
        self.public = False
        self._update_path()
    
    def delete(self):
        """
        Delete the source repository here
        """
        if self.exists():
            shutil.rmtree(self.path)
    
    def create_remote(self, name, description='', homepage=''):
        """
        Create a remote repository on a separate service
        """
        raise NotImplementedError
    
    def add_remote(self, name, url, branch=None):
        """
        Add a remote repository
        """
        raise NotImplementedError
    
    def update_remote(self, name, branch=None):
        """
        Update a remote repository.
        """
        raise NotImplementedError
    
    def list_directory(self, path, revision=None, branch=None):
        """
        List the files directory in the repository
        
        Optionally can specify a revision or branch from which to show the directory.
        """
        raise NotImplementedError
    
    def get_file(self, path, revision=None, branch=None):
        """
        Get the contents from a file
        
        Optionally can specify a revision or branch from which to retrieve the contents
        """
        raise NotImplementedError
    
    def get_absolute_url(self):
        """
        Return the absolute url
        """
        return self.url
    
    def get_current_revision(self):
        """
        Get the current revision of he repository
        """
        raise NotImplementedError
    
    def get_archive(self, revision=None, tag=None):
        """
        Get an archive of the current revision, or specific revision or tag
        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = bzr
from base import BaseVCS

class BazaarRepository(BaseVCS):
    pass

########NEW FILE########
__FILENAME__ = git
import os
from base import BaseVCS
from repositories import settings

class GitRepository(BaseVCS):
    def __init__(self, name, anonymous_access, template=None):
        super(GitRepository, self).__init__(name, anonymous_access, template)
        if not self.name.endswith('.git'):
            self.name = "%s.git" % self.name
            self._update_path()
    
    def create_remote(self, name, description='', homepage=''):
        from github2.client import Github
        github = Github(username=settings.GITHUB_USER, api_token=settings.GITHUB_API_TOKEN)
        new_repo = github.repo.create(name, description, homepage, public=True)
        commit_url = new_repo.url.replace('http://','git@') + '.git'
        return commit_url
    
    def add_remote(self, name, url, branch=None):
        import subprocess
        repo_path = self.path
        cmd = ["cd %s;git remote add %s %s" % (repo_path, name, url),]
        try:
            subprocess.check_call(cmd, shell=True)
        except:
            pass
        
    def remove_remote(self, name):
        import subprocess
        repo_path = self.path
        cmd = ["cd %s;git remote rm %s" % (repo_path, name),]
        try:
            subprocess.check_call(cmd, shell=True)
        except:
            pass
    
    def update_remote(self, name, branch=None):
        import subprocess
        repo_path = self.path
        the_branch = branch or "master"
        cmd = ["cd %s;git push %s %s" % (repo_path, name, branch)]
        try:
            subproc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output = subproc.communicate()
        except:
            pass
    
    def create(self):
        import subprocess
        if self.exists():
            return
        if not os.path.exists(self.config['public_path']):
            os.makedirs(self.config['public_path'])
        if not os.path.exists(self.config['private_path']):
            os.makedirs(self.config['private_path'])
        repo_path = self.path
        os.mkdir(repo_path, 0744)
        cmd = ["cd %s;git --bare init;git --bare update-server-info" % repo_path,]
        subprocess.check_call(cmd, shell=True)
        cmd = ['%s file://%s/' % (os.path.join(settings.BIN_PATH, 'initialize_git_repo.sh'), repo_path)]
        subprocess.check_call(cmd, shell=True)
    
    def get_current_rev(self):
        from subprocess import PIPE, Popen
        cmd = ['cd %s;git show --pretty=format:"%%H" --quiet' % self.path,]
        return Popen(cmd, shell=True, stderr=PIPE, stdout=PIPE).communicate()[0]
    
    def archive(self, revision=None, tag=None):
        """
        Execute git archive <HEAD or revision or tag> | gzip -c 
        """
        pass
########NEW FILE########
__FILENAME__ = hg
from base import BaseVCS

class MercurialRepository(BaseVCS):
    pass

########NEW FILE########
__FILENAME__ = svn
import os
from base import BaseVCS

class SubversionRepository(BaseVCS):
    def create(self):
        """
        Create a source code repository
        """
        import subprocess
        if self.exists():
            return
        if not os.path.exists(self.config['public_path']):
            os.makedirs(self.config['public_path'])
        if not os.path.exists(self.config['private_path']):
            os.makedirs(self.config['private_path'])
        
        cmd = ["svnadmin","create", self.path]
        if self.config['config_dir']:
            cmd.extend(["--config-dir", self.config['config_dir']])
        subprocess.check_call(cmd)
        
        if self.template:
            template = os.path.join(os.path.dirname(__file__),'repo-templates',
                                        self.template)
            url = 'file://%s'%self.path
            cmd = ['svn', 'import', template, url, "-m", "\"Initial import.\""]
            if self.config['config_dir']:
                cmd.extend(["--config-dir", self.config['config_dir']])
            subprocess.check_call(cmd)
    
    def get_current_rev(self):
        rev = ''
        file_path = os.path.join(self.path, 'db/current')
        try:
            the_file = open(file_path, 'r')
            try:
                rev = the_file.readline().split()[0]
            finally:
                the_file.close()
        except IOError:
            pass
        return rev
    
    def list_directory(self, path):
        import pysvn, time
        client = pysvn.Client()
        dirlist = client.list("file://%s%s"%(self.path, path),
                              depth=pysvn.depth.immediates)
        results = []
        for item, locked in dirlist:
            if item.repos_path == path:
                continue
            results.append({
                'filename': os.path.basename(item.path),
                'dir_flag': (item.kind == pysvn.node_kind.dir),
                'size': item.size,
                'date': time.ctime(item.time),
                'author': item.last_author
            })
        return results

########NEW FILE########
__FILENAME__ = vcs.old
import os, shutil
import settings

class BaseVCS(object):
    def __init__(self, name, anonymous_access, template=None):
        """
        A base class to handle Version Control System functions
        
        name = name of the repository
        anonymous_access = Is it public?
        template = The name of the template to use
        """
        self.public = anonymous_access
        self.name = name
        self.template = template
        self.config = self.get_config()
        self._update_path() # Sets self.path and url
    
    def _update_path(self):
        """
        Determine where the repository is. It is called in __init__ and sets 
        self.path and self.url
        """
        if self.public:
            self.path = os.path.abspath(os.path.join(self.config['public_path'], self.name))
            self.url = "%s%s/" % (self.config['public_url'], self.name)
        else:
            self.path = os.path.abspath(os.path.join(self.config['private_path'], self.name))
            self.url = "%s%s/" % (self.config['private_url'], self.name)
    
    
    def get_config(self):
        """
        Search the configuration for the correct record
        """
        name = self.__class__.__name__.replace('Repository','')
        for value in settings.VCS_CONFIG.values():
            if value['name'] == name:
                return value
        raise Exception("The configuration for %s is missing." % name)
    
    def exists(self):
        """
        Does the repository exist on the file system?
        """
        return os.path.exists(self.path)
    
    def create(self):
        """
        Create a new repository
        """
        NotImplementedError
    
    def make_public(self):
        """
        Move a repository from private to public
        """
        dest = os.path.abspath(os.path.join(self.config['public_path'], self.name))
        source = self.path
        shutil.move(source, dest)
        self.public = True
        self._update_path()
    
    def make_private(self):
        """
        Move a repository from public to private
        """
        source = self.path
        dest = os.path.abspath(os.path.join(self.config['private_path'], self.name))
        shutil.move(source, dest)
        self.public = False
        self._update_path()
    
    def delete(self):
        """
        Delete the source repository here
        """
        if self.exists():
            shutil.rmtree(self.path)
    
    def create_remote(self, name, description='', homepage=''):
        """
        Create a remote repository on a separate service
        """
        raise NotImplementedError
    
    def add_remote(self, name, url, branch=None):
        """
        Add a remote repository
        """
        raise NotImplementedError
    
    def update_remote(self, name, branch=None):
        """
        Update a remote repository.
        """
        raise NotImplementedError
    
    def list_directory(self, path):
        """
        List the files directory in the repository
        """
        raise NotImplementedError
    
    def get_absolute_url(self):
        """
        Return the absolute url
        """
        return self.url
    
    def get_current_revision(self):
        """
        Get the current revision of he repository
        """
        raise NotImplementedError
    
    def get_archive(self, revision=None, tag=None):
        """
        Get an archive of the current revision, or specific revision or tag
        """
        raise NotImplementedError


class SubversionRepository(BaseVCS):
    def create(self):
        """
        Create a source code repository
        """
        import subprocess
        if self.exists():
            return
        if not os.path.exists(self.config['public_path']):
            os.makedirs(self.config['public_path'])
        if not os.path.exists(self.config['private_path']):
            os.makedirs(self.config['private_path'])
        
        cmd = ["svnadmin","create", self.path]
        if self.config['config_dir']:
            cmd.extend(["--config-dir", self.config['config_dir']])
        subprocess.check_call(cmd)
        
        if self.template:
            template = os.path.join(os.path.dirname(__file__),'repo-templates',
                                        self.template)
            url = 'file://%s'%self.path
            cmd = ['svn', 'import', template, url, "-m", "\"Initial import.\""]
            if self.config['config_dir']:
                cmd.extend(["--config-dir", self.config['config_dir']])
            subprocess.check_call(cmd)
    
    def get_current_rev(self):
        from subprocess import PIPE, Popen
        import re
        rev = ''
        file_path = os.path.join(self.path, 'db/current')
        try:
            the_file = open(file_path, 'r')
            try:
                rev = the_file.readline().split()[0]
            finally:
                the_file.close()
        except IOError:
            pass
        return rev
    
    def list_directory(self, path):
        import pysvn, time
        client = pysvn.Client()
        dirlist = client.list("file://%s%s"%(self.path, path),
                              depth=pysvn.depth.immediates)
        results = []
        for item, locked in dirlist:
            if item.repos_path == path:
                continue
            results.append({
                'filename': os.path.basename(item.path),
                'dir_flag': (item.kind == pysvn.node_kind.dir),
                'size': item.size,
                'date': time.ctime(item.time),
                'author': item.last_author
            })
        return results


class BazaarRepository(BaseVCS):
    pass


class MercurialRepository(BaseVCS):
    pass


class GitRepository(BaseVCS):
    def __init__(self, name, anonymous_access, template=None):
        super(GitRepository, self).__init__(name, anonymous_access, template)
        if not self.name.endswith('.git'):
            self.name = "%s.git" % self.name
            self._update_path()
    
    def create_remote(self, name, description='', homepage=''):
        from github2.client import Github
        github = Github(username=settings.GITHUB_USER, api_token=settings.GITHUB_API_TOKEN)
        new_repo = github.repo.create(name, description, homepage, public=True)
        commit_url = new_repo.url.replace('http://','git@') + '.git'
        return commit_url
    
    def add_remote(self, name, url, branch=None):
        import subprocess
        repo_path = self.path
        cmd = ["cd %s;git remote add %s %s" % (repo_path, name, url),]
        try:
            subprocess.check_call(cmd, shell=True)
        except:
            pass
        
    def remove_remote(self, name):
        import subprocess
        repo_path = self.path
        cmd = ["cd %s;git remote rm %s" % (repo_path, name),]
        try:
            subprocess.check_call(cmd, shell=True)
        except:
            pass
    
    def update_remote(self, name, branch=None):
        import subprocess
        repo_path = self.path
        the_branch = branch or "master"
        cmd = ["cd %s;git push %s %s" % (repo_path, name, branch)]
        try:
            subproc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output = subproc.communicate()
        except:
            pass
    
    def create(self):
        import subprocess
        if self.exists():
            return
        if not os.path.exists(self.config['public_path']):
            os.makedirs(self.config['public_path'])
        if not os.path.exists(self.config['private_path']):
            os.makedirs(self.config['private_path'])
        repo_path = self.path
        os.mkdir(repo_path, 0744)
        cmd = ["cd %s;git --bare init;git --bare update-server-info" % repo_path,]
        subprocess.check_call(cmd, shell=True)
        cmd = ['%s file://%s/' % (os.path.join(settings.BIN_PATH, 'initialize_git_repo.sh'), repo_path)]
        subprocess.check_call(cmd, shell=True)
    
    def get_current_rev(self):
        from subprocess import PIPE, Popen
        cmd = ['cd %s;git show --pretty=format:"%%H" --quiet' % self.path,]
        return Popen(cmd, shell=True, stderr=PIPE, stdout=PIPE).communicate()[0]
    
    def archive(self, revision=None, tag=None):
        """
        Execute git archive <HEAD or revision or tag> | gzip -c 
        """
        pass
########NEW FILE########
__FILENAME__ = views
from django.shortcuts import render_to_response
from django.http import HttpResponseRedirect, HttpResponseForbidden, Http404
from django.template import RequestContext
from django.utils.translation import ugettext, ugettext_lazy as _

########NEW FILE########
