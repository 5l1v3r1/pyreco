__FILENAME__ = export-help
#! python

"""
This script generates HTML pages from the built-in Frescobaldi manual,
for publication on the Frescobaldi web site.

Simply run this from the toplevel frescobaldi directory:

python export-help.py

It creates a help/ directory (by default) and puts the HTML and images there.

"""

from __future__ import unicode_literals

import os
import re
import glob
import time
import shutil

### set output directory here:
output_dir = os.path.abspath('help')

### languages to export help pages for:
export_languages = 'C nl es fr it cs'.split()


### HTML templates for every page to be generated:
templates = {

'C': """\
<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<title>{page_title} - Frescobaldi Project</title>
	<link rel="stylesheet" type="text/css" href="/style/1/style.css" />
	<link rel="shortcut icon" type="image/png" href="/favicon.png" />
	<meta http-equiv="Content-Type" content="application/xhtml+xml;charset=utf-8" />
	<meta name="author" content="Wilbert Berendsen" />
	<meta name="description" content="Frescobaldi is a LilyPond sheet music editor" />
	<meta name="keywords" content="lilypond, music notation, ide" />
</head>

<body>

<div id="header">
<h1>{page_title}</h1>
</div>

<div id="sidebar">
	<a accesskey="h" href="/"><u>H</u>ome</a>
	<a accesskey="s" href="screenshots"><u>S</u>creenshots</a>
	<a accesskey="d" href="download"><u>D</u>ownload</a>
	<a accesskey="u" href="uguide" class="selected"><u>U</u>ser Guide</a>
	<a accesskey="v" href="development">De<u>v</u>elopment</a>
	<a accesskey="l" href="links"><u>L</u>inks</a>
</div>

<div id="maincontents">

<p>(<a href="uguide-1">Frescobaldi 1.x User Guide</a>)</p>

{page_contents}

<address>
{page_address}
</address>

</div>

</body>
</html>
""",

"nl": """\
<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="nl" xml:lang="nl">
<head>
	<title>{page_title} - Frescobaldi Project</title>
	<link rel="stylesheet" type="text/css" href="/style/1/style.css" />
	<link rel="shortcut icon" type="image/png" href="/favicon.png" />
	<meta http-equiv="Content-Type" content="application/xhtml+xml;charset=utf-8" />
	<meta name="author" content="Wilbert Berendsen" />
	<meta name="description" content="Frescobaldi is een LilyPond muziek-editor" />
	<meta name="keywords" content="lilypond, music notation, ide" />
</head>

<body>

<div id="header">
<h1>{page_title}</h1>
</div>

<div id="sidebar">
	<a accesskey="h" href="/"><u>H</u>ome</a>
	<a accesskey="s" href="screenshots"><u>S</u>chermafbeeldingen</a>
	<a accesskey="d" href="download"><u>D</u>ownloaden</a>
	<a accesskey="u" href="uguide" class="selected">Gebr<u>u</u>ikershandleiding</a>
	<a accesskey="o" href="development"><u>O</u>ntwikkeling</a>
	<a accesskey="l" href="links"><u>L</u>inks</a>
</div>

<div id="maincontents">

<p>(<a href="uguide-1">Frescobaldi 1.x User Guide</a>)</p>

{page_contents}

<address>
{page_address}
</address>

</div>

</body>
</html>
""",


}



import sip
sip.setapi("QString", 2)
sip.setapi("QVariant", 2)

# make directory
if not os.path.isdir(output_dir):
    os.makedirs(output_dir)

# copy images
images = []
images_dir = os.path.join(output_dir, 'images')
images_prefix = 'uguide_'
if not os.path.isdir(images_dir):
    os.makedirs(images_dir)
for img in glob.glob('frescobaldi_app/help/*.png'):
    name = os.path.basename(img)
    images.append(name)
    shutil.copy(img, os.path.join(images_dir, images_prefix + name))

# regexp to adjust links to images in html
images_re = re.compile(
    r'''([Ss][Rr][Cc]\s*=\s*'''
    r'''['"])((?:''' + '|'.join(map(re.escape, images)) + r''')['"])''')

# avoid reading settings
os.environ["XDG_CONFIG_HOME"] = ""

# make frescobaldi_app accessible
import frescobaldi_app.toplevel
import po
import help.helpimpl
import help.contents
import language_names

po.install(None)

# create a MainWindow because of the keyboard shortcuts!
import mainwindow
w = mainwindow.MainWindow()


def set_language(lang):
    """Sets the language. If "C", all text is untranslated."""
    po.install(None if lang == "C" else po.find(lang))


def make_filename(name, lang):
    """Adds the language name to the filename (which must have an extension)."""
    if lang not in ("C", None):
        name = name.replace('.', '.' + lang + '.')
    return name


def make_page(lang):
    """Makes the HTML user guide for the given language."""
    
    html = []
    seen = set()
    
    def add(page, children=None, level=1):
        seen.add(page)
        html.append(
            '<h{1} id="help_{0}"><a name="help_{0}"></a>{2}</h{1}>\n'
            .format(page.name, min(5, level+1), page.title()))
        html.append(help.helpimpl.markexternal(page.body()))
        
        if page.seealso():
            html.append('<p>')
            html.append(_("See also:") + " ")
            html.append(', '.join(p.link() for p in page.seealso()))
            html.append('</p>\n')
        
        for p in children or page.children():
            add(p, None, level+1)

    set_language(lang)
    page = help.contents.contents
    # toc at start
    children = list(page.children())
    children.insert(0, children.pop())
    add(page, children)
    
    left = [page for page in help.helpimpl.all_pages.values()
            if page not in seen and page.name not in ('nohelp', 'page')]
    
    # add pages not in the toc structure
    if left:
        html.append('\n\n<hr />\n\n')
        for page in left:
            add(page, None, 2)
    
    html = ''.join(html)
    
    # make image links work
    html = images_re.sub(
        lambda m: m.group(1) + 'images/' + images_prefix + m.group(2), html)
    
    # make help links work
    html = html.replace('<a href="help:', '<a href="#help_')
    
    others = []
    for l in export_languages:
        if l is not lang:
            others.append('<a href="{0}">{1}</a>'.format(
                make_filename('uguide.html', l),
                "English" if l == "C" else language_names.languageName(l, l),
            ))
    footer = ', '.join(others)
    footer += ' | '
    footer += _("Last Modified: {date}").format(date=time.strftime('%d %b %Y'))
    
    html = templates.get(lang, templates['C']).format(
        page_title = _("Frescobaldi Manual"),
        page_contents = html,
        page_address = footer)
    
    filename = os.path.join(output_dir, make_filename('uguide.html', lang))
    print 'Exporting to:', filename
    with open(filename, 'w') as f:
        f.write(html.encode('utf-8'))


for lang in export_languages:
    make_page(lang)


########NEW FILE########
__FILENAME__ = freeze
#! python

# This script freezes Frescobaldi to a standalone application without
# needing to install any dependencies.
#
# Usage:
# C:\Python27\Python freeze.py
#
# How it works:
# It creates, using cx_Freeze, a frescobaldi executable inside the frozen/
# directory, along with all used (manually specified) Python modules.
# Then the whole frescobaldi_app directory is copied and the Python scripts
# byte-compiled.
# Finally, an installer is created using the Inno Setup console-mode compiler.

# the Inno Setup console-mode compiler
iscc = 'c:\\Program Files\\Inno Setup 5\\ISCC'

# where to build the frozen program folder
target_dir = 'frozen'

# import standard modules and cx_Freeze
import imp
import os
import py_compile
import shutil
import subprocess
import sys
from cx_Freeze import Executable, Freezer

# access meta-information such as version, etc.
from frescobaldi_app import info

# find pypm by adding the dir of pygame to sys.path
sys.path.append(imp.find_module('pygame')[1])

includes = [
    'sip',
    'PyQt4.QtCore',
    'PyQt4.QtGui',
    'PyQt4.QtWebKit',
    'PyQt4.QtNetwork',
    'PyQt4.QtSvg',
    'PyQt4.QtXml',
    'popplerqt4',
    'pypm',
    
    '__future__',
    'bisect',
    'contextlib',
    'difflib',
    'fractions',
    'glob',
    'json',
    'itertools',
    'functools',
    'optparse',
    'os',
    'platform',
    're',
    'sys',
    'shutil',
    'struct',
    'subprocess',
    'traceback',
    'types',
    'unicodedata',
    'weakref',
    'xml.etree.ElementTree',
]

excludes = [
    'frescobaldi_app',  # we'll add this one manually
    
]

frescobaldi = Executable(
    'frescobaldi',
    icon = 'frescobaldi_app/icons/frescobaldi.ico',
    appendScriptToExe = True,
    base = 'Win32GUI', # no console
)

f = Freezer(
    [frescobaldi],
    includes = includes,
    excludes = excludes,
    targetDir = target_dir,
    copyDependentFiles = True,
    compress = False,
    # silent = True,
)

f.Freeze()

def copy_plugins(name):
    """Copies a folder from the Qt4 plugins directory."""
    path = imp.find_module('PyQt4')[1]
    folder = os.path.join(path, 'plugins', name)
    target = os.path.join(target_dir, name)
    shutil.rmtree(target, ignore_errors = True)
    shutil.copytree(folder, target)

# copy Qt4 imageformat plugins
copy_plugins('imageformats')

# copy Qt4 iconengine plugins
copy_plugins('iconengines')

# copy the frescobaldi_app directory
subprocess.call([sys.executable, 'setup.py', 'build_py',
	'--build-lib', target_dir, '--compile'])

# make an Inno Setup installer
inno_script = b'''
[Setup]
AppName=Frescobaldi
AppVersion={version}
AppVerName=Frescobaldi {version}
AppPublisher={author}
AppPublisherURL={homepage}
AppComments={comments}

DefaultDirName={{pf}}\\Frescobaldi
DefaultGroupName=Frescobaldi
UninstallDisplayIcon={{app}}\\frescobaldi.exe
Compression=lzma2
SolidCompression=yes

SourceDir={target}\\
OutputDir=..\\dist\\
OutputBaseFilename="Frescobaldi Setup {version}"
SetupIconFile=frescobaldi_app\\icons\\frescobaldi.ico
LicenseFile=..\\COPYING
WizardImageFile=..\\frescobaldi-wininst.bmp
WizardImageStretch=no

[Files]
Source: "*.*"; DestDir: "{{app}}"; Flags: recursesubdirs;

[Icons]
Name: "{{group}}\Frescobaldi"; Filename: "{{app}}\\frescobaldi.exe";

[Tasks]
Name: assocly; Description: "{{cm:AssocFileExtension,Frescobaldi,.ly}}";

[Registry]
Root: HKCR; Subkey: "LilyPond\\shell\\frescobaldi";\
 ValueType: string; ValueName: ""; ValueData: "Edit with &Frescobaldi...";\
 Flags: uninsdeletekey
Root: HKCR; Subkey: "LilyPond\\shell\\frescobaldi\\command";\
 ValueType: string; ValueName: ""; ValueData: """{{app}}\\frescobaldi.exe"" ""%1"""
Tasks: assocly; Root: HKCR; Subkey: "LilyPond\\shell";\
 ValueType: string; ValueName: ""; ValueData: "frescobaldi";

[Run]
Filename: "{{app}}\\frescobaldi.exe";\
 Description: {{cm:LaunchProgram,Frescobaldi}};\
 Flags: postinstall nowait skipifsilent;

'''.format(
    version=info.version,
    homepage=info.url,
    author=info.maintainer,
    comments=info.description,
    target=target_dir,
)

subprocess.Popen([iscc, '-'], stdin=subprocess.PIPE).communicate(inno_script)


########NEW FILE########
__FILENAME__ = frescobaldi-wininst
#! python
"""
PostInstall/PostUninstall script for Frescobaldi on Windows

This install script is used by setup.py bdist_wininst

It is called with the '-install' argument after installing, and with the
'-remove' argument _after_ uninstalling.

"""

import os
import sys


# Windows register:
try:
    import winreg
except ImportError:
    try:
        import _winreg as winreg
    except ImportError:
        winreg = None


# Frescobaldi meta info (Possibly not accessible anymore on uninstall):
try:
    from frescobaldi_app import info
except ImportError:
    info = None


# Icon:
try:
    import frescobaldi_app
    icon = os.path.join(frescobaldi_app.__path__[0], 'icons', 'frescobaldi.ico')
except ImportError:
    icon = None


# Main application script and Python executable:
script = os.path.join(sys.prefix, 'Scripts', 'frescobaldi')
python = os.path.join(sys.exec_prefix, 'pythonw.exe') # because sys.executable points to installer


def install_association():
    """Installs a file association for the LilyPond file type.
    
    Sets HKEY_CLASSES_ROOT\\LilyPond\\shell\\frescobaldi to 'Open with &Frescobaldi...'
    Sets HKEY_CLASSES_ROOT\\LilyPond\\shell\\frescobaldi\\command
        to '{python} "{script}" "%1"'
    
    """
    key = winreg.CreateKey(winreg.HKEY_CLASSES_ROOT, "LilyPond\\shell\\frescobaldi")
    with key:
        winreg.SetValue(key, None, winreg.REG_SZ, "Open with &Frescobaldi...")
        winreg.SetValue(key, "command", winreg.REG_SZ, '{0} "{1}" "%1"'.format(python, script))
    print("* Created file association")

def remove_association():
    """Removes the file association.
    
    Removes HKEY_CLASSES_ROOT\\LilyPond\\shell\\frescobaldi
    
    """
    try:
        key = winreg.OpenKey(winreg.HKEY_CLASSES_ROOT, "LilyPond\\shell")
        with key:
            winreg.DeleteKey(key, "frescobaldi\\command")
            winreg.DeleteKey(key, "frescobaldi")
        print("* Removed file association")
    except WindowsError:
        print("*** Could not remove file association ***")

def install_startmenu():
    """Installs a shortcut in the startmenu."""
    for startmenu in (
            get_special_folder_path('CSIDL_COMMON_STARTMENU'),
            get_special_folder_path('CSIDL_STARTMENU'),
            ):
        menudir = os.path.join(startmenu, info.appname)
        if os.path.isdir(menudir):
            shortcut(menudir)
            break
        else:
            try:
                os.mkdir(menudir)
            except OSError:
                continue
            else:
                directory_created(menudir)
                shortcut(menudir)
                break

def shortcut(directory):
    """Makes the Frescobaldi shortcut in the specified directory."""
    lnk = os.path.join(directory, info.appname + ".lnk")
    create_shortcut(
        python,             # path
        info.description,   # description
        lnk,                # link name
        script,             # arguments
        "",                 # workdir
        icon,               # icon
        0,                  # icon index
    )
    file_created(lnk)
    print("* Added \"{0}\" to Start Menu".format(info.appname))

def welcome():
    """Prints a nice welcome message in the installer."""
    print("\nWelcome to {0} {1}!".format(info.appname, info.version))
    

### Main:
if sys.argv[1] == '-install':
    install_startmenu()
    install_association()
    welcome()
elif sys.argv[1] == '-remove':
    remove_association()


########NEW FILE########
__FILENAME__ = about
# -*- coding: utf-8 -*-
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
About dialog.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSettings, QSize, Qt, QUrl
from PyQt4.QtGui import (
    QDialog, QDialogButtonBox, QLabel, QLayout, QTabWidget, QTextBrowser,
    QVBoxLayout, QWidget)

import app
import info
import icons
import helpers
import bugreport
import userguide.page


class AboutDialog(QDialog):
    """A simple 'About Frescobaldi' dialog.
    
    Most of the information is taken from the info module.
    
    """
    def __init__(self, mainwindow):
        """Creates the about dialog. You can simply exec_() it."""
        super(AboutDialog, self).__init__(mainwindow)
        
        self.setWindowTitle(_("About {appname}").format(appname = info.appname))
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        tabw = QTabWidget()
        layout.addWidget(tabw)
        
        tabw.addTab(About(self), _("About"))
        tabw.addTab(Credits(self), _("Credits"))
        tabw.addTab(Version(self), _("Version"))
        
        button = QDialogButtonBox(QDialogButtonBox.Ok)
        button.setCenterButtons(True)
        button.accepted.connect(self.accept)
        layout.addWidget(button)
        layout.setSizeConstraint(QLayout.SetFixedSize)
        

class About(QWidget):
    """About widget."""
    def __init__(self, parent=None):
        super(About, self).__init__(parent)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        size = QSize(100, 100)
        pic = QLabel()
        pic.setPixmap(icons.get("frescobaldi").pixmap(size))
        pic.setFixedSize(size)
        layout.addWidget(pic, 0, Qt.AlignHCenter)

        text = QLabel()
        text.setText(html())
        text.linkActivated.connect(self.openLink)
        layout.addWidget(text)
    
    def openLink(self, url):
        helpers.openUrl(QUrl(url))


class Credits(QTextBrowser):
    """Credits widget."""
    def __init__(self, parent=None):
        super(Credits, self).__init__(parent)
        self.setOpenLinks(False)
        self.anchorClicked.connect(helpers.openUrl)
        self.setHtml(userguide.page.Page('credits').body())


class Version(QTextBrowser):
    """Version information."""
    def __init__(self, parent=None):
        super(Version, self).__init__(parent)
        self.setHtml(
            "<p>{app_name}: {app_version}</p>\n"
            "<p>Python: {python_version}<br />"
            "Qt: {qt_version}<br />\n"
            "PyQt4: {pyqt_version}<br />\n"
            "sip: {sip_version}</p>\n"
            "<p>{operating_system}:<br />\n"
            "{osname}</p>".format(
                app_name = info.appname,
                app_version = info.version,
                operating_system = _("Operating System"),
                **bugreport.versionInfo()))


def html():
    """Returns a HTML string for the about dialog."""
    appname = info.appname
    version = _("Version {version}").format(version = info.version)
    description = _("A LilyPond Music Editor")
    copyright = _("Copyright (c) {year} by {author}").format(
        year = "2008-2014",
        author = """<a href="mailto:{0}" title="{1}">{2}</a>""".format(
            info.maintainer_email,
            _("Send an e-mail message to the maintainers."),
            info.maintainer))
    # L10N: Translate this sentence and fill in your own name to have it appear in the About Dialog.
    translator = _("Translated by Your Name.")
    if translator == "Translated by Your Name.":
        translator = ""
    else:
        translator = "<p>{0}</p>".format(translator)
    license = _("Licensed under the {gpl}.").format(
        gpl = """<a href="http://www.gnu.org/licenses/gpl.html">GNU GPL</a>""")
    homepage = info.url
    
    return html_template.format(**locals())


html_template = """<html>
<body><div align="center">
<h1>{appname}</h1>
<h3>{version}</h3>
<p>{description}</p>
<p>{copyright}</p>
{translator}
<p>{license}</p>
<p><a href="{homepage}">{homepage}</a></p>
</div></body>
</html>
"""


########NEW FILE########
__FILENAME__ = actioncollection
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
In this module are two classes, ActionCollection and ShortcutCollection.
Both must be inherited to do something useful.

ActionCollection keeps a fixed list of QActions, set as instance attributes in
the createActions() method. The icons and default shortcuts may also be set in
the same method. The texts should be set in the translateUI() method.

The ActionCollection then keeps track of possibly changed keyboard shortcuts by
loading them from the config and connecting to the app.settingsChanged() signal.

ShortcutCollection keeps a variable list of QActions, for which default
shortcuts must be set in the createDefaultShortcuts() method.

This actions must not be connected to, but they are only used to set keyboard
shortcuts for a module that needs not to be loaded initially for the shortcuts
to work. If a shortcut is pressed, the real action is queried using the
realAction() method, which should return the corresponding action in the UI.
That one is than triggered.

The module may provide the user with a means to change the keyboard shortcuts,
which then should call setShortcuts() to do it. The module may also query the
currently set shortcuts for an action using shortcuts().
"""

from __future__ import unicode_literals

import weakref

from PyQt4.QtCore import QSettings, Qt
from PyQt4.QtGui import QAction, QKeySequence

import app


class ActionCollectionBase(object):
    """Abstract base class. Can load and keep a list of QActions.

    You must subclass this class and provide a name for the actioncollection
    in the 'name' class attribute.
    
    """
    def __init__(self, widget=None):
        self._widget = weakref.ref(widget) if widget else lambda: None
        self._actions = {}  # maps name to action
        self._defaults = {} # maps name to default list of shortcuts
        app.settingsChanged.connect(self.load)
    
    def widget(self):
        """Returns the widget given on construction or None."""
        return self._widget()
        
    def setDefaultShortcuts(self, name, shortcuts):
        """Set a default list of QKeySequence objects for the named action."""
        self._defaults[name] = shortcuts
        
    def defaultShortcuts(self, name):
        """Returns the default shortcuts (list of QKeySequences) for the action.
        
        If not defined, returns None.
        
        """
        return self._defaults.get(name)
        
    def actions(self):
        """Returns the dictionary with actions."""
        return self._actions
        
    def defaults(self):
        """Returns the dictionary with actions that have a default shortcut."""
        return self._defaults
        
    def shortcuts(self, name):
        """Returns the list of shortcuts for the named action, or None."""
        try:
            return self._actions[name].shortcuts()
        except KeyError:
            pass
    
    def setShortcuts(self, name, shortcuts):
        """Implement to set the shortcuts list for our action."""
        pass
    
    def settingsGroup(self):
        """Returns settings group to load/save shortcuts from or to."""
        s = QSettings()
        scheme = s.value("shortcut_scheme", "default", type(""))
        s.beginGroup("shortcuts/{0}/{1}".format(scheme, self.name))
        return s
        
    def load(self):
        """Implement to load shortcuts from our settingsGroup()."""
        pass
    
    def title(self):
        """If this returns a meaningful title, actions can be grouped in the shortcut settings dialog."""
        pass


class ActionCollection(ActionCollectionBase):
    """Keeps a fixed list of QActions as instance attributes.
    
    Subclass this and add the actions as instance attributes in
    the createActions() method.
    
    You can set the default shortcuts directly in the actions in the
    createActions() method, it is not needed to use the setDefaultShortcuts()
    method for that.
    
    Set the titles for the actions in the translateUI() method.
    
    """
    def __init__(self, parent=None):
        """Creates the ActionCollection.
        
        parent is an optional widget that is also the parent for the created actions.
        
        """
        super(ActionCollection, self).__init__(parent)
        self.createActions(parent)
        self._actions = dict(i for i in self.__dict__.items() if not i[0].startswith('_'))
        self.storeDefaults()
        self.load(False) # load the shortcuts without resettings defaults
        app.translateUI(self)
        
    def createActions(self, parent=None):
        """Should add actions as instance attributes.
        
        The QActions should get icons and shortcuts. Texts should be set
        in translateUI(). The actions are created with the parent given on instantiation.
        
        """
        pass

    def translateUI(self):
        """Should (re)translate all the titles of the actions."""
        pass
    
    def storeDefaults(self):
        """Saves the preset default QKeySequence lists for the actions."""
        for name, action in self._actions.items():
            if action.shortcuts():
                self.setDefaultShortcuts(name, action.shortcuts())

    def setShortcuts(self, name, shortcuts):
        """Sets the shortcuts list for our action. Use an empty list to remove the shortcuts."""
        action = self.actions().get(name)
        if not action:
            return
        
        default = self.defaultShortcuts(name)
        setting = self.settingsGroup()
        action.setShortcuts(shortcuts)
        setting.setValue(name, shortcuts)
        if default:
            if shortcuts == default:
                setting.remove(name)
            else:
                setting.setValue(name, shortcuts)
        else:
            if shortcuts:
                setting.setValue(name, shortcuts)
            else:
                setting.remove(name)
    
    def load(self, restoreDefaults=True):
        """Reads keyboard shortcuts from the settings.
        
        If restoreDefaults == True, resets the other shortcuts to their default
        values. If restoreDefaults == False, does not touch the other shortcuts.
        
        """
        settings = self.settingsGroup()
        keys = settings.allKeys()
        for name in keys:
            try:
                shortcuts = settings.value(name, [], QKeySequence)
            except TypeError:
                # PyQt4 raises TypeError when an empty list was stored
                shortcuts = []
            try:
                self._actions[name].setShortcuts(shortcuts)
            except KeyError:
                settings.remove(name)
        if restoreDefaults:
            for name in self._actions:
                if name not in keys:
                    self._actions[name].setShortcuts(self._defaults.get(name) or [])


class ShortcutCollection(ActionCollectionBase):
    """An ActionCollection type that only saves actions that have a keyboard shortcut.
    
    Should always be instantiated with a visible widget (preferably MainWindow)
    as parent.
    
    Use the setShortcuts() method to set a list (possibly empty) of QKeySequence
    objects.  Every change causes other instances of the same-named collection
    to reload.
    
    This serves two purposes:
    1. save keyboard shortcuts for actions created by the user or from a very large list
    2. make the keyboard shortcuts working even if the component the actions are
       contained in is not even loaded yet.
       
       To make this work, implement the realAction() method to instantiate the widget the
       action is meant for and then return the real action.
       
    """
    # save weak references to other instances with the same name and sync then.
    others = {}
    
    # shortcut context to use by default
    shortcutContext = Qt.WindowShortcut
    
    def __init__(self, widget):
        """Creates the ShortcutCollection.
        
        The widget is required as actions are added to it, so their keyboard
        shortcuts get triggered.
        
        """
        super(ShortcutCollection, self).__init__(widget)
        self.createDefaultShortcuts()
        self.load()
        self.others.setdefault(self.name, []).append(weakref.ref(self))
    
    def createDefaultShortcuts(self):
        """Should set some default shortcut lists using setDefaultShortcuts()."""
        pass
        
    def load(self):
        """Reads keyboard shortcuts from the settings.  Instantiates QActions as needed."""
        # clears all actions
        for a in self._actions.values():
            a.setParent(None)
        self._actions = {}
        # then set defaults
        for name, shortcuts in self.defaults().items():
            self.action(name).setShortcuts(shortcuts)
        # then load
        settings = self.settingsGroup()
        for name in settings.allKeys():
            try:
                shortcuts = settings.value(name, [], QKeySequence)
            except TypeError:
                # PyQt4 raises TypeError when an empty list was stored
                shortcuts = []
            if not shortcuts:
                if not self.removeAction(name):
                    # if it did not exist, remove key from config
                    settings.remove(name)
            else:
                self.action(name).setShortcuts(shortcuts)
    
    def setShortcuts(self, name, shortcuts):
        """Sets the shortcuts list for our action. Use an empty list to remove the shortcuts."""
        if shortcuts:
            self.action(name).setShortcuts(shortcuts)
            self.settingsGroup().setValue(name, shortcuts)
        else:
            self.removeAction(name)
            if name in self.defaults():
                # save empty list because there exists a default value
                self.settingsGroup().setValue(name, [])
            else:
                self.settingsGroup().remove(name)
        self.reloadOthers()
    
    def restoreDefaultShortcuts(self, name):
        """Resets the shortcuts for the specified action to their default value."""
        shortcuts = self.defaultShortcuts(name)
        if shortcuts:
            self.action(name).setShortcuts(shortcuts)
        else:
            self.removeAction(name)
        self.settingsGroup().remove(name)
        self.reloadOthers()
        
    def removeAction(self, name):
        """(Internal) Removes the named action, returning True it it did exist."""
        try:
            a = self._actions[name]
        except KeyError:
            return False
        a.setParent(None)
        del self._actions[name]
        return True
        
    def action(self, name):
        """Returns a QAction for the name, instantiating it if necessary."""
        try:
            a = self._actions[name]
        except KeyError:
            a = self._actions[name] = QAction(self.widget())
            a.setShortcutContext(self.shortcutContext)
            a.triggered.connect(lambda: self.triggerAction(name))
            self.widget().addAction(a)
        return a
    
    def triggerAction(self, name):
        """Called when the user presses a saved keyboard shortcut."""
        a = self.realAction(name)
        if a:
            a.trigger()
            
    def realAction(self, name):
        """Implement this to return the real action the name refers to,
        
        This is called when the text and icon are needed (e.g. when the shortcut
        dialog is opened) or when our "shadow" action keyboard shortcut is triggered.
        
        The function may return None, e.g. when the action our name refers to does
        not exist anymore.  In that case our action is also removed.
        
        """
        pass
    
    def actions(self):
        """Returns our real actions instead of the shadow ones."""
        d = {}
        changed = False
        for name in list(self._actions):
            a = self.realAction(name)
            if a:
                d[name] = a
            else:
                self.removeAction(name)
                changed = True
        if changed:
            self.reloadOthers()
        return d
    
    def reloadOthers(self):
        """Reload others managing the same shortcuts (e.g. in case of multiple mainwindows)."""
        for ref in self.others[self.name][:]:
            other = ref()
            if not other:
                self.others[self.name].remove(ref)
            elif other is not self:
                other.load()



########NEW FILE########
__FILENAME__ = actioncollectionmanager
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages ActionCollections for a MainWindow (and so, effectively, for the whole
application.)

This makes it possible to edit actions and check whether keyboard shortcuts of
actions conflict with other actions.
"""

from __future__ import unicode_literals

import weakref

import actioncollection
import plugin
import qutil


def manager(mainwindow):
    """Returns the ActionCollectionManager belonging to mainwindow."""
    return ActionCollectionManager.instance(mainwindow)

def action(collection_name, action_name):
    """Return a QAction from the application.
    
    May return None, if the named collection or action does not exist.
    
    """
    mgr = ActionCollectionManager.instances()[0]
    return mgr.action(collection_name, action_name)


class ActionCollectionManager(plugin.MainWindowPlugin):
    """Manages ActionCollections for a MainWindow."""
    def __init__(self, mainwindow):
        """Creates the ActionCollectionManager for the given mainwindow."""
        self._actioncollections = weakref.WeakValueDictionary()
    
    def addActionCollection(self, collection):
        """Add an actioncollection to our list (used for changing keyboard shortcuts).
        
        Does not keep a reference to it.  If the ActionCollection gets garbage collected,
        it is removed automatically from our list.
        
        """
        if collection.name not in self._actioncollections:
            self._actioncollections[collection.name] = collection
        
    def removeActionCollection(self, collection):
        """Removes the given ActionCollection from our list."""
        if collection.name in self._actioncollections:
            del self._actioncollections[collection.name]

    def actionCollections(self):
        """Iterate over the ActionCollections in our list."""
        return self._actioncollections.values()
        
    def action(self, collection_name, action_name):
        """Returns the named action from the named collection."""
        collection = self._actioncollections.get(collection_name)
        if collection:
            if isinstance(collection, actioncollection.ShortcutCollection):
                return collection.realAction(action_name)
            return getattr(collection, action_name, None)
    
    def iterShortcuts(self, skip=None):
        """Iter all shortcuts of all collections."""
        for collection in self.actionCollections():
            for name, a in collection.actions().items():
                if (collection, name) != skip:
                    for shortcut in collection.shortcuts(name):
                        yield shortcut, collection, name, a
    
    def findShortcutConflict(self, shortcut, skip):
        """Find the possible shortcut conflict and return the conflict name.
        
        skip must be a tuple (collection, name).
        it's the action to skip (the action that is about to be changed).
        
        """
        if shortcut:
            for data in self.iterShortcuts(skip):
                s1 = data[0]
                if s1.matches(shortcut) or shortcut.matches(s1):
                    return qutil.removeAccelerator(data[-1].text())
        return None
    
    def removeShortcuts(self, shortcuts):
        """Find and remove shorcuts of the given list."""
        for data in self.iterShortcuts():
            s1, collection, name = data[:3]
            for s2 in shortcuts:
                if s2.matches(s1) or s1.matches(s2):
                    collShortcuts = collection.shortcuts(name)
                    collShortcuts.remove(s1)
                    collection.setShortcuts(name, collShortcuts)
    

########NEW FILE########
__FILENAME__ = app
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The global things in Frescobaldi.
"""

from __future__ import unicode_literals

import os
import sys

from PyQt4.QtCore import QSettings, QThread
from PyQt4.QtGui import QApplication

import info

qApp = QApplication([os.path.abspath(sys.argv[0])] + sys.argv[1:])
QApplication.setApplicationName(info.name)
QApplication.setApplicationVersion(info.version)
QApplication.setOrganizationName(info.name)
QApplication.setOrganizationDomain(info.domain)

windows = []
documents = []

from signals import Signal, SignalContext

# signals
aboutToQuit = Signal()          # Use this and not qApp.aboutToQuit
mainwindowCreated = Signal()    # MainWindow
mainwindowClosed = Signal()     # MainWindow
documentCreated = Signal()      # Document
documentUrlChanged = Signal()   # Document
documentLoaded = Signal()       # Document
documentModificationChanged = Signal() # Document
documentClosed = Signal()       # Document
documentSaved = Signal()        # Document
documentSaving = SignalContext() # Document
viewCreated = Signal()          # View
viewSpaceCreated = Signal()     # ViewSpace (see viewmanager.py)
languageChanged = Signal()      # (no arguments)
settingsChanged = Signal()      # (no arguments)
sessionChanged = Signal()       # (name)
saveSessionData = Signal()      # (name)
jobStarted = Signal()           # (Document, Job)
jobFinished = Signal()          # (Document, Job, bool success)


def openUrl(url, encoding=None):
    """Returns a Document instance for the given QUrl.
    
    If there is already a document with that url, it is returned.
    
    """
    d = findDocument(url)
    if not d:
        # special case if there is only one document:
        # if that is empty and unedited, use it.
        if (len(documents) == 1
            and documents[0].url().isEmpty()
            and documents[0].isEmpty()
            and not documents[0].isUndoAvailable()
            and not documents[0].isRedoAvailable()):
            d = documents[0]
            d.setUrl(url)
            d.setEncoding(encoding)
            d.load()
        else:
            import document
            d = document.Document(url, encoding)
    return d

def findDocument(url):
    """Returns a Document instance for the given QUrl if already loaded.
    
    Returns None if no document with given url exists or if the url is empty.
    
    """
    if not url.isEmpty():
        for d in documents:
            if url == d.url():
                return d

def run():
    """Enter the Qt event loop."""
    result = qApp.exec_()
    aboutToQuit()
    return result

def restart():
    """Restarts Frescobaldi."""
    args = [os.path.abspath(sys.argv[0])] + sys.argv[1:]
    python_executable = sys.executable
    if python_executable:
        args = [python_executable] + args
    import subprocess
    subprocess.Popen(args)
    
def translateUI(obj, priority=0):
    """Translates texts in the object.
    
    Texts are translated again if the language is changed.
    The object must have a translateUI() method.  It is
    also called by this function.
    
    """
    languageChanged.connect(obj.translateUI, priority)
    obj.translateUI()

def caption(title):
    """Returns a nice dialog or window title with appname appended."""
    return "{0} \u2013 {1}".format(title, info.appname)

def filetypes(extension=None):
    """Returns a list of supported filetypes.
    
    If a type matches extension, it is placed first.
    
    """
    have, havenot = [], []
    for patterns, name in (
            ("{0} (*.ly *.lyi *.ily)",          _("LilyPond Files")),
            ("{0} (*.tex *.lytex *.latex)",     _("LaTeX Files")),
            ("{0} (*.docbook *.lyxml)",         _("DocBook Files")),
            ("{0} (*.html *.xml)",              _("HTML Files")),
            ("{0} (*.itely *.tely *.texi *.texinfo)", _("Texinfo Files")),
            ("{0} (*.scm)",                     _("Scheme Files")),
            ("{0} (*)",                         _("All Files")),
            ):
        if extension and extension in patterns:
            have.append(patterns.format(name))
        else:
            havenot.append(patterns.format(name))
    return ";;".join(have + havenot)

def basedir():
    """Returns a base directory for documents.

    First looks in the session settings, then the default settings.
    Returns "" if no directory was set. It is recommended to use the
    home directory in that case.

    """
    import sessions
    conf = sessions.currentSessionGroup()
    if conf:
        basedir = conf.value("basedir", "", type(""))
        if basedir:
            return basedir
    return QSettings().value("basedir", "", type(""))

def settings(name):
    """Returns a QSettings object referring a file in ~/.config/frescobaldi/"""
    s = QSettings()
    s.beginGroup(name)
    s.setFallbacksEnabled(False)
    return s

def excepthook(exctype, excvalue, exctb):
    """Called when a Python exception goes unhandled."""
    from traceback import format_exception
    sys.stderr.write(''.join(format_exception(exctype, excvalue, exctb)))
    if exctype != KeyboardInterrupt:
        # show dialog, but not when in non-GUI thread
        if QThread.currentThread() == qApp.thread():
            import exception
            exception.ExceptionDialog(exctype, excvalue, exctb)

def displayhook(obj):
    """Prevent normal displayhook from overwriting __builtin__._"""
    if obj is not None:
        print(repr(obj))


########NEW FILE########
__FILENAME__ = analyzer
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Analyze text to determine suitable completions.
"""

from __future__ import unicode_literals

import re
import os

import ly.lex as lx
import ly.lex.lilypond as lp
import ly.lex.scheme as scm
import ly.words
import tokeniter

from . import completiondata
from . import documentdata


class Analyzer(object):
    """Analyzes text at some cursor position and gives suitable completions."""
    def analyze(self, cursor):
        """Do the analyzing work; set the attributes column and model."""
        self.cursor = cursor
        block = cursor.block()
        self.column = column = cursor.position() - block.position()
        self.text = text = block.text()[:column]
        self.model = None
        
        # make a list of tokens exactly ending at the cursor position
        # and let state follow
        state = self.state = tokeniter.state(block)
        tokens = self.tokens = []
        for t in tokeniter.tokens(cursor.block()):
            if t.end > column:
                # cut off the last token and run the parser on it
                tokens.extend(state.tokens(text, t.pos))
                break
            tokens.append(t)
            state.follow(t)
            if t.end == column:
                break
        
        self.last = tokens[-1] if tokens else ''
        self.lastpos = self.last.pos if self.last else column
        
        parser = state.parser()
        
        # Map the parser class to a group of tests to return the model.
        # Try the tests until a model is returned.
        try:
            tests = self.tests[parser.__class__]
        except KeyError:
            return
        else:
            for function in tests:
                model = function(self)
                if model:
                    self.model = model
                    return

    def completions(self, cursor):
        """Analyzes text at cursor and returns a tuple (position, model).
        
        The position is an integer specifying the column in the line where the last
        text starts that should be completed.
        
        The model list the possible completions. If the model is None, there are no
        suitable completions.
        
        This function does its best to return extremely meaningful completions
        for the context the cursor is in.
        
        """
        self.analyze(cursor)
        return self.column, self.model
    
    def document_cursor(self):
        """Return the current QTextCursor, to harvest info from its document.
        
        By default this is simply the cursor given on analyze() or completions()
        but you can override this method to provide another cursor. This can
        be useful when the completion occurs in a small QTextDocument, which is
        in fact a part of the main document.
        
        """
        return self.cursor
    
    def tokenclasses(self):
        """Return the list of classes of the tokens."""
        return list(map(type, self.tokens))

    def backuntil(self, *classes):
        """Move self.column back until a token of *classes is encountered."""
        for t in self.tokens[::-1]:
            if isinstance(t, classes):
                break
            self.column = t.pos

    # Test functions that return a model or None
    def toplevel(self):
        """LilyPond toplevel document contents."""
        self.backuntil(lx.Space)
        return completiondata.lilypond_toplevel
        # maybe: check if behind \version or \language

    def book(self):
        """\\book {"""
        self.backuntil(lx.Space)
        cursor = self.document_cursor()
        return documentdata.doc(cursor.document()).bookcommands(cursor)
        
    def bookpart(self):
        """\\bookpart {"""
        self.backuntil(lx.Space)
        cursor = self.document_cursor()
        return documentdata.doc(cursor.document()).bookpartcommands(cursor)

    def score(self):
        """\\score {"""
        self.backuntil(lx.Space)
        cursor = self.document_cursor()
        return documentdata.doc(cursor.document()).scorecommands(cursor)

    def tweak(self):
        """complete property after \\tweak"""
        try:
            i = self.tokens.index('\\tweak')
        except ValueError:
            return
        tokens = self.tokens[i+1:]
        tokenclasses = self.tokenclasses()[i+1:]
        if tokenclasses == [lx.Space, lp.SchemeStart]:
            self.column -= 1
            return completiondata.lilypond_all_grob_properties
        elif tokenclasses == [lx.Space, lp.SchemeStart, scm.Quote]:
            self.column -= 2
            return completiondata.lilypond_all_grob_properties
        elif tokenclasses[:-1] == [lx.Space, lp.SchemeStart, scm.Quote]:
            self.column = self.lastpos - 2
            return completiondata.lilypond_all_grob_properties
        # 2.18-style [GrobName.]propertyname tweak
        if lp.GrobName in tokenclasses:
            self.backuntil(lx.Space, lp.DotPath)
            return completiondata.lilypond_grob_properties(tokens[1], False)
        if tokens:
            self.backuntil(lx.Space)
            return completiondata.lilypond_all_grob_properties_and_grob_names

    def key(self):
        """complete mode argument of '\\key'"""
        tokenclasses = self.tokenclasses()
        if '\\key' in self.tokens[-5:-2] and lp.Note in tokenclasses[-3:]:
            if self.last.startswith('\\'):
                self.column = self.lastpos
            return completiondata.lilypond_modes

    def clef(self):
        """complete \\clef names"""
        if '\\clef' in self.tokens[-4:-1]:
            self.backuntil(lx.Space, lp.StringQuotedStart)
            return completiondata.lilypond_clefs
            
    def repeat(self):
        """complete \\repeat types"""
        if '\\repeat' in self.tokens[-4:-1]:
            self.backuntil(lx.Space, lp.StringQuotedStart)
            return completiondata.lilypond_repeat_types

    def language(self):
        """complete \\language "name" """
        if '\\language' in self.tokens[-4:-1]:
            self.backuntil(lp.StringQuotedStart)
            return completiondata.language_names

    def include(self):
        """complete \\include """
        if '\\include' in self.tokens[-4:-2]:
            self.backuntil(lp.StringQuotedStart)
            dir = self.last[:self.last.rfind(os.sep)] if os.sep in self.last else None
            cursor = self.document_cursor()
            return documentdata.doc(cursor.document()).includenames(cursor, dir)

    def general_music(self):
        """fall back: generic music commands and user-defined commands."""
        if self.last.startswith('\\'):
            self.column = self.lastpos
        cursor = self.document_cursor()
        return documentdata.doc(cursor.document()).musiccommands(cursor)

    def lyricmode(self):
        """Commands inside lyric mode."""
        if self.last.startswith('\\'):
            self.column = self.lastpos
        cursor = self.document_cursor()
        return documentdata.doc(cursor.document()).lyriccommands(cursor)
        
    def music_glyph(self):
        """Complete \markup \musicglyph names."""
        try:
            i = self.tokens.index('\\musicglyph', -5, -3)
        except ValueError:
            return
        for t, cls in zip(self.tokens[i:], (
            lp.MarkupCommand, lx.Space, lp.SchemeStart, scm.StringQuotedStart, scm.String)):
            if type(t) is not cls:
                return
        if i + 4 < len(self.tokens):
            self.column = self.tokens[i + 4].pos
        return completiondata.music_glyphs

    def midi_instrument(self):
        """Complete midiInstrument = #"... """
        try:
            i = self.tokens.index('midiInstrument', -7, -2)
        except ValueError:
            return
        if self.last != '"':
            self.column = self.lastpos
        return completiondata.midi_instruments
        
    def font_name(self):
        """Complete #'font-name = #"..."""
        try:
            i = self.tokens.index('font-name', -7, -3)
        except ValueError:
            return
        if self.last != '"':
            self.column = self.lastpos
        return completiondata.font_names()
        
    def scheme_word(self):
        """Complete scheme word from scheme functions, etc."""
        if isinstance(self.last, scm.Word):
            self.column = self.lastpos
            cursor = self.document_cursor()
            return documentdata.doc(cursor.document()).schemewords()
        
    def markup(self):
        """\\markup {"""
        if self.last.startswith('\\'):
            if (self.last[1:] not in ly.words.markupcommands
                and self.last != '\\markup'):
                self.column = self.lastpos
            else:
                return completiondata.lilypond_markup_commands
        else:
            m = re.search(r'\w+$', self.last)
            if m:
                self.column = self.lastpos + m.start()
        cursor = self.document_cursor()
        return documentdata.doc(cursor.document()).markup(cursor)
        
    def header(self):
        """\\header {"""
        if '=' in self.tokens[-3:] or self.last.startswith('\\'):
            if self.last.startswith('\\'):
                self.column = self.lastpos
            return completiondata.lilypond_markup
        if self.last[:1].isalpha():
            self.column = self.lastpos
        return completiondata.lilypond_header_variables

    def paper(self):
        """\\paper {"""
        if '=' in self.tokens[-3:] or self.last.startswith('\\'):
            if self.last.startswith('\\'):
                self.column = self.lastpos
            return completiondata.lilypond_markup
        if self.last[:1].isalpha():
            self.column = self.lastpos
        return completiondata.lilypond_paper_variables
        
    def layout(self):
        """\\layout {"""
        self.backuntil(lx.Space)
        return completiondata.lilypond_layout_variables

    def midi(self):
        """\\midi {"""
        self.backuntil(lx.Space)
        return completiondata.lilypond_midi_variables

    def engraver(self):
        """Complete engraver names."""
        cmd_in = lambda tokens: '\\remove' in tokens or '\\consists' in tokens
        if isinstance(self.state.parser(), lp.ParseString):
            if not cmd_in(self.tokens[-5:-2]):
                return
            if self.last != '"':
                if '"' not in self.tokens[-2:-1]:
                    return
                self.column = self.lastpos
            return completiondata.lilypond_engravers
        if cmd_in(self.tokens[-3:-1]):
            self.backuntil(lx.Space)
            return completiondata.lilypond_engravers
        
    def context_variable_set(self):
        if '=' in self.tokens[-4:]:
            if isinstance(self.last, scm.Word):
                self.column = self.lastpos
                cursor = self.document_cursor()
                return documentdata.doc(cursor.document()).schemewords()
            if self.last.startswith('\\'):
                self.column = self.lastpos
            return completiondata.lilypond_markup

    def context(self):
        self.backuntil(lx.Space)
        return completiondata.lilypond_context_contents

    def with_(self):
        self.backuntil(lx.Space)
        return completiondata.lilypond_with_contents

    def translator(self):
        """complete context name after \\new, \\change or \\context in music"""
        for t in self.tokens[-2::-1]:
            if isinstance(t, lp.ContextName):
                return
            elif isinstance(t, lp.Translator):
                break
        self.backuntil(lx.Space)
        return completiondata.lilypond_contexts

    def override(self):
        """\\override and \\revert"""
        tokenclasses = self.tokenclasses()
        try:
            # check if there is a GrobName in the last 5 tokens
            i = tokenclasses.index(lp.GrobName, -5)
        except ValueError:
            # not found, then complete Contexts and or Grobs
            # (only if we are in the override parser and there's no "=")
            if isinstance(self.state.parser(), scm.ParseScheme):
                return
            self.backuntil(lp.DotPath, lx.Space)
            if (isinstance(self.state.parsers()[1], (
                    lp.ParseWith,
                    lp.ParseContext,
                    ))
                or lp.DotPath in tokenclasses):
                return completiondata.lilypond_grobs
            return completiondata.lilypond_contexts_and_grobs
        # yes, there is a GrobName at i
        count = len(self.tokens) - i - 1 # tokens after grobname
        if count == 0:
            self.column = self.lastpos
            return completiondata.lilypond_grobs
        elif count >= 2:
            # set the place of the scheme-start "#" as the column
            self.column = self.tokens[i+2].pos
        test = [lx.Space, lp.SchemeStart, scm.Quote, scm.Word]
        if tokenclasses[i+1:] == test[:count]:
            return completiondata.lilypond_grob_properties(self.tokens[i])
        self.backuntil(lp.DotPath, lx.Space)
        return completiondata.lilypond_grob_properties(self.tokens[i], False)
    
    def revert(self):
        """test for \\revert in general music expressions
        
        (because the revert parser drops out of invalid constructs, which happen
        during typing).
        
        """
        if '\\revert' in self.tokens:
            return self.override()
    
    def set_unset(self):
        """\\set and \\unset"""
        tokenclasses = self.tokenclasses()
        self.backuntil(lx.Space, lp.DotPath)
        if lp.ContextProperty in tokenclasses and isinstance(self.last, lx.Space):
            return # fall back to music?
        elif lp.DotPath in tokenclasses:
            return completiondata.lilypond_context_properties
        return completiondata.lilypond_contexts_and_properties

    def markup_override(self):
        """test for \\markup \\override inside scheme"""
        try:
            i = self.tokens.index('\\override', -6, -4)
        except ValueError:
            return
        for t, cls in zip(self.tokens[i:], (
            lp.MarkupCommand, lx.Space, lp.SchemeStart, scm.Quote, scm.OpenParen)):
            if type(t) is not cls:
                return
        if len(self.tokens) > i + 5:
            self.column = self.lastpos
        return completiondata.lilypond_markup_properties

    def scheme_other(self):
        """test for other scheme words"""
        if isinstance(self.last, (
            lp.SchemeStart,
            scm.OpenParen,
            scm.Word,
            )):
            if isinstance(self.last, scm.Word):
                self.column = self.lastpos
            cursor = self.document_cursor()
            return documentdata.doc(cursor.document()).schemewords()
    
    def accidental_style(self):
        """test for \accidentalStyle"""
        try:
            i = self.tokens.index("\\accidentalStyle")
        except ValueError:
            return
        self.backuntil(lx.Space, lp.DotPath)
        tokens = self.tokens[i+1:]
        tokenclasses = self.tokenclasses()[i+1:]
        try:
            i = tokenclasses.index(lp.AccidentalStyleSpecifier)
        except ValueError:
            pass
        else:
            if lx.Space in tokenclasses[i+1:]:
                return
        if lp.ContextName in tokenclasses:
            return completiondata.lilypond_accidental_styles
        return completiondata.lilypond_accidental_styles_contexts

    def hide_omit(self):
        """test for \omit and \hide"""
        indices = []
        for t in "\\omit", "\\hide":
            try:
                indices.append(self.tokens.index(t, -6))
            except ValueError:
                pass
        if not indices:
            return
        self.backuntil(lx.Space, lp.DotPath)
        i = max(indices)
        tokens = self.tokens[i+1:]
        tokenclasses = self.tokenclasses()[i+1:]
        if lp.GrobName not in tokenclasses[:-1]:
            if lp.ContextName in tokenclasses:
                return completiondata.lilypond_grobs
            return completiondata.lilypond_contexts_and_grobs


    # Mapping from Parsers to the lists of functions to run.
    tests = {
        lp.ParseGlobal: (
            repeat,
            toplevel,
        ),
        lp.ParseBook: (
            book,
        ),
        lp.ParseBookPart: (
            bookpart,
        ),
        lp.ParseScore: (
            score,
        ),
        lp.ParseMusic: (
            tweak,
            scheme_word,
            key,
            clef,
            repeat,
            accidental_style,
            hide_omit,
            revert,
            general_music,
        ),
        lp.ParseNoteMode: (
            tweak,
            scheme_word,
            key,
            clef,
            repeat,
            accidental_style,
            hide_omit,
            revert,
            general_music,
        ),
        lp.ParseMarkup: (
            markup,
        ),
        lp.ParseHeader: (
            header,
        ),
        lp.ParsePaper: (
            paper,
        ),
        lp.ParseLayout: (
            accidental_style,
            hide_omit,
            layout,
        ),
        lp.ParseMidi: (
            midi,
        ),
        lp.ParseContext: (
            engraver,
            context_variable_set,
            context,
        ),
        lp.ParseWith: (
            engraver,
            context_variable_set,
            with_,
        ),
        lp.ParseTranslator: (
            translator,
        ),
        lp.ExpectTranslatorId: (
            translator,
        ),
        lp.ParseOverride: (
            override,
        ),
        lp.ParseRevert: (
            override,
        ),
        lp.ParseSet: (
            set_unset,
        ),
        lp.ParseUnset: (
            set_unset,
        ),
        lp.ParseTweak: (
            tweak,
        ),
        lp.ParseTweakGrobProperty: (
            tweak,
        ),
        lp.ParseString: (
            engraver,
            clef,
            repeat,
            midi_instrument,
            include,
            language,
        ),
        lp.ParseClef: (
            clef,
        ),
        lp.ParseRepeat: (
            repeat,
        ),
        scm.ParseScheme: (
            override,
            tweak,
            markup_override,
            scheme_other,
        ),
        scm.ParseString: (
            music_glyph,
            midi_instrument,
            font_name,
        ),
        lp.ParseLyricMode: (
            repeat,
            lyricmode,
        ),
        lp.ParseAccidentalStyle: (
            accidental_style,
        ),
        lp.ParseScriptAbbreviationOrFingering: (
            accidental_style,
        ),
        lp.ParseHideOmit: (
            hide_omit,
        ),
        lp.ParseGrobPropertyPath: (
            revert,
        ),
    }


########NEW FILE########
__FILENAME__ = completer
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The completer for Frescobaldi.
"""

from __future__ import unicode_literals

import re

from PyQt4.QtGui import QTextCursor

import app
import textformats
import widgets.completer


class Completer(widgets.completer.Completer):
    def __init__(self):
        super(Completer, self).__init__()
        self.setMaxVisibleItems(16)
        self.popup().setMinimumWidth(100)
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
    
    def readSettings(self):
        self.popup().setFont(textformats.formatData('editor').font)
        self.popup().setPalette(textformats.formatData('editor').palette())
    
    def completionCursor(self):
        cursor = self.textCursor()
        # trick: if we are still visible we don't have to analyze the text again
        if not (self.popup().isVisible() and self._pos < cursor.position()):
            analyzer = self.analyzer()
            pos, model = analyzer.completions(cursor)
            if not model:
                return
            self._pos = cursor.block().position() + pos
            if self.model() != model:
                self.setModel(model)
        cursor.setPosition(self._pos, QTextCursor.KeepAnchor)
        return cursor

    def analyzer(self):
        from . import analyzer
        return analyzer.Analyzer()



########NEW FILE########
__FILENAME__ = completiondata
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
All completions data.
"""

from __future__ import unicode_literals

import itertools

from PyQt4.QtCore import Qt
from PyQt4.QtGui import QFont, QFontDatabase

import listmodel
import ly.words
import ly.data
import ly.pitch

from . import util


# some groups of basic lilypond commands

# markup (toplevel, book and bookpart)
markup = (
    'markup',
    'markuplines',
    'markuplist',
    'pageBreak',
    'noPageBreak',
)

# these can occur (almost) everywhere
everywhere = (
    'pointAndClickOn',
    'pointAndClickOff',
    'include',
)

# commands that change input mode, can introduce a music expression
inputmodes = (
    'chords',
    'chordmode {',
    'drums',
    'drummode {',
    'figures',
    'figuremode {',
    'lyrics',
    'lyricmode {',
    'addlyrics {',
)

# commands that only occur at the global file level
toplevel = (
    'language',
    'version',
    'sourcefileline',
    'sourcefilename',
)

# other commands that can start a music expression
start_music = (
    'repeat',
    'alternative {',
    'relative',
    'transpose',
    'partcombine',
    'keepWithTag #\'',
    'removeWithTag #\'',
    'new',
    'context',
    'with',
)

# tweak commands may be assigned, in toplevel
tweaks = (
    'once',
    'override',
    'revert',
    'set',
    'unset',
)

# modes book, bookpart and score
modes = (
    'book {',
    'bookpart {',
    'score {',
)

# blocks: paper, header, layout
blocks = (
    'paper {',
    'header {',
    'layout {',
)

# commands that are used in context definitions
cmds_context = (
    'override',
    'consists',
    'remove',
    'RemoveEmptyStaves',
    'accepts',
    'alias',
    'defaultchild',
    'denies',
    'name',
)

# in \with { } a smaller set
cmds_with = cmds_context[:3]


# variables that make sense to be set at toplevel
toplevel_variables = (
    'pipeSymbol',
    'showFirstLength',
    'showLastLength',
)


# stuff inside \score {}
score = sorted(
    everywhere + inputmodes + start_music + blocks[1:] + (
    'midi {',
))


# stuff inside \bookpart {}
bookpart = sorted(
    everywhere + inputmodes + markup + start_music + modes[2:] + blocks
)

    
# stuff inside \book {}
book = sorted(
    everywhere + inputmodes + markup + start_music
    + modes[1:] + blocks + (
    'bookOutputName',
    'bookOutputSuffix',
))


lilypond_markup = listmodel.ListModel(['\\markup'])

lilypond_markup_commands = listmodel.ListModel(
    sorted(ly.words.markupcommands),
    display = util.command)

lilypond_header_variables = listmodel.ListModel(
    sorted(ly.words.headervariables, key=lambda i: i[:3]), edit = util.variable)

lilypond_paper_variables = listmodel.ListModel(
    sorted(ly.words.papervariables), edit = util.variable)

lilypond_layout_variables = listmodel.ListModel([
        '\\context {',
        '\\override',
        '\\set',
        '\\hide',
        '\\omit',
        '\\accidentalStyle',
        ] + sorted(ly.words.layoutvariables),
    edit = util.cmd_or_var)

lilypond_midi_variables = listmodel.ListModel(
    ['\\context {', '\\override', '\\set', '\\tempo',] +
    sorted(ly.words.midivariables),
    edit = util.cmd_or_var)

lilypond_contexts = listmodel.ListModel(sorted(ly.words.contexts))

lilypond_grobs = listmodel.ListModel(ly.data.grobs())

lilypond_contexts_and_grobs = listmodel.ListModel(
    sorted(ly.words.contexts) + ly.data.grobs())

lilypond_context_properties = listmodel.ListModel(
    ly.data.context_properties())

lilypond_contexts_and_properties = listmodel.ListModel(
    sorted(ly.words.contexts) + ly.data.context_properties())

lilypond_context_contents = listmodel.ListModel(sorted(itertools.chain(
    util.make_cmds(ly.words.contexts),
    ly.data.context_properties(),
    util.make_cmds(cmds_context),
    )), edit = util.cmd_or_var)

lilypond_with_contents = listmodel.ListModel(sorted(itertools.chain(
    ly.data.context_properties(),
    util.make_cmds(cmds_with),
    )), edit = util.cmd_or_var)

lilypond_toplevel = listmodel.ListModel(sorted(itertools.chain(util.make_cmds(
    toplevel + everywhere + inputmodes + markup + start_music + tweaks
    + modes + blocks
    ), toplevel_variables)), edit = util.cmd_or_var)

lilypond_book = listmodel.ListModel(book, display = util.command)

lilypond_bookpart = listmodel.ListModel(bookpart, display = util.command)
    
lilypond_score = listmodel.ListModel(score, display = util.command)

lilypond_engravers = listmodel.ListModel(ly.data.engravers())
    
def lilypond_grob_properties(grob, hash_quote=True):
    display = (lambda item: "#'" + item) if hash_quote else (lambda item: item)
    return listmodel.ListModel(ly.data.grob_properties(grob),
        display = display)

lilypond_all_grob_properties = listmodel.ListModel(ly.data.all_grob_properties(),
    display = lambda item: "#'" + item)

lilypond_all_grob_properties_and_grob_names = listmodel.ListModel(
    ly.data.all_grob_properties() + ly.data.grobs())

lilypond_markup_properties = listmodel.ListModel(
    sorted(set(sum(map(ly.data.grob_interface_properties, (
        # see lilypond docs about \markup \override
        'font-interface',
        'text-interface',
        'instrument-specific-markup-interface',
    )), []))))

lilypond_modes = listmodel.ListModel(ly.words.modes, display = util.command)

lilypond_clefs = listmodel.ListModel(ly.words.clefs_plain)

lilypond_accidental_styles = listmodel.ListModel(ly.words.accidentalstyles)

lilypond_accidental_styles_contexts = listmodel.ListModel(
    ly.words.contexts + ly.words.accidentalstyles)

lilypond_repeat_types = listmodel.ListModel(ly.words.repeat_types)

music_glyphs = listmodel.ListModel(ly.data.music_glyphs())

midi_instruments = listmodel.ListModel(ly.words.midi_instruments)

language_names = listmodel.ListModel(sorted(ly.pitch.pitchInfo))

def font_names():
    model = listmodel.ListModel(sorted(QFontDatabase().families()))
    model.setRoleFunction(Qt.FontRole, QFont)
    return model


########NEW FILE########
__FILENAME__ = documentdata
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Completions data harvested from a Document.
"""

from __future__ import unicode_literals

import itertools
import os

import listmodel
import plugin
import ly.words
import ly.data

from . import completiondata
from . import harvest
from . import util


def doc(document):
    """Returns the DocumentDataSource for the specified Document."""
    return DocumentDataSource.instance(document)


class DocumentDataSource(plugin.DocumentPlugin):
    @util.keep
    def words(self):
        """Returns the list of words in comments, markup etc."""
        return listmodel.ListModel(
            sorted(set(harvest.words(self.document()))))

    @util.keep
    def schemewords(self):
        """Scheme names, including those harvested from document."""
        schemewords = set(itertools.chain(
            ly.data.all_scheme_words(),
            (unicode(t)
                for t in harvest.schemewords(self.document())
                if len(t) > 2),
            ))
        return listmodel.ListModel(sorted(schemewords))

    @util.keep
    def markup(self, cursor):
        """Completes markup commands and normal text from the document."""
        return listmodel.ListModel(
            ['\\' + w for w in sorted(ly.words.markupcommands)]
            + [ '\\' + w for w in sorted(set(itertools.chain(
                harvest.markup_commands(cursor),
                harvest.include_markup_commands(cursor))))]
            + sorted(set(harvest.words(self.document()))))

    @util.keep
    def scorecommands(self, cursor):
        """Stuff inside \\score { }. """
        return listmodel.ListModel(sorted(set(itertools.chain(
            completiondata.score,
            harvest.include_identifiers(cursor),
            harvest.names(cursor)))), display = util.command)
    
    @util.keep
    def bookpartcommands(self, cursor):
        """Stuff inside \\bookpart { }. """
        return listmodel.ListModel(sorted(set(itertools.chain(
            completiondata.bookpart,
            harvest.include_identifiers(cursor),
            harvest.names(cursor)))), display = util.command)
    
    @util.keep
    def bookcommands(self, cursor):
        """Stuff inside \\book { }. """
        return listmodel.ListModel(sorted(set(itertools.chain(
            completiondata.book,
            harvest.include_identifiers(cursor),
            harvest.names(cursor)))), display = util.command)
    
    
    @util.keep
    def musiccommands(self, cursor):
        return listmodel.ListModel(sorted(set(itertools.chain(
            ly.words.lilypond_keywords,
            ly.words.lilypond_music_commands,
            ly.words.articulations,
            ly.words.ornaments,
            ly.words.fermatas,
            ly.words.instrument_scripts,
            ly.words.repeat_scripts,
            harvest.include_identifiers(cursor),
            harvest.names(cursor)))), display = util.command)

    @util.keep
    def lyriccommands(self, cursor):
        return listmodel.ListModel(sorted(set(itertools.chain(
            ('set stanza = ', 'set', 'override', 'markup', 'notemode', 'repeat'),
            harvest.include_identifiers(cursor),
            harvest.names(cursor)))), display = util.command)

    def includenames(self, cursor, directory=None):
        """Finds files relative to the directory of the cursor's document.
        
        If the document has a local filename, looks in that directory,
        also in a subdirectory of it, if the directory argument is given.
        
        Then looks recursively in the user-set include paths, 
        and finally in LilyPond's own ly/ folder.
        
        """
        names = []
        # names in current dir
        path = self.document().url().toLocalFile()
        if path:
            basedir = os.path.dirname(path)
            if directory:
                basedir = os.path.join(basedir, directory)
                names.extend(sorted(os.path.join(directory, f)
                    for f in get_filenames(basedir, True)))
            else:
                names.extend(sorted(get_filenames(basedir, True)))
        
        # names in specified include paths
        import documentinfo
        for basedir in documentinfo.info(self.document()).includepath():
            
            # store dir relative to specified include path root
            reldir = directory if directory else ""
            # look for files in the current relative directory
            for f in sorted(get_filenames(os.path.join(basedir, reldir), True)):
                names.append(os.path.join(reldir, f))
        
        # names from LilyPond itself
        import engrave.command
        datadir = engrave.command.info(self.document()).datadir()
        if datadir:
            basedir = os.path.join(datadir, 'ly')
            # get the filenames but avoid the -init files here
            names.extend(sorted(f for f in get_filenames(basedir)
                if not f.endswith('init.ly')
                and f.islower()))
        
        return listmodel.ListModel(names)


def get_filenames(path, directories = False):
    try:
        for root, dirs, files in os.walk(path):
            for f in files:
                if f and f[0] not in '.~':
                    name, ext = os.path.splitext(f)
                    if ext.lower() in ('.ly', '.lyi', '.ily'):
                        yield f
            if directories:
                for f in dirs:
                    if f and not f.startswith('.'):
                        yield f + os.sep
            return
    except UnicodeDecodeError:
        # this only happens when there are filenames in the wrong encoding,
        # but never ever bug the user about this while typing :)
        pass



########NEW FILE########
__FILENAME__ = harvest
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Harvest strings from document for autocompletion purposes.
"""

from __future__ import unicode_literals

import itertools
import re

import documentinfo
import fileinfo
import tokeniter
import ly.lex.lilypond
import ly.lex.scheme


def get_docinfo(cursor):
    """Return a ly DocInfo instance for the cursor's document upto its position."""
    dinfo = documentinfo.info(cursor.document())
    return dinfo.lydocinfo().range(0, cursor.position())


def names(cursor):
    """Harvests names from assignments until the cursor."""
    return get_docinfo(cursor).definitions()


def markup_commands(cursor):
    """Harvest markup command definitions until the cursor."""
    return get_docinfo(cursor).markup_definitions()

    
def schemewords(document):
    """Harvests all schemewords from the document."""
    for t in tokeniter.all_tokens(document):
        if type(t) is ly.lex.scheme.Word:
            yield t


def include_identifiers(cursor):
    """Harvests identifier definitions from included files."""
    dinfo = documentinfo.info(cursor.document())
    files = fileinfo.includefiles(get_docinfo(cursor), dinfo.includepath())
    return itertools.chain.from_iterable(fileinfo.docinfo(f).definitions()
                                         for f in files)


def include_markup_commands(cursor):
    """Harvest markup command definitions from included files."""
    dinfo = documentinfo.info(cursor.document())
    files = fileinfo.includefiles(get_docinfo(cursor), dinfo.includepath())
    return itertools.chain.from_iterable(fileinfo.docinfo(f).markup_definitions()
                                         for f in files)
    

_words = re.compile(r'\w{5,}|\w{2,}(?:[:-]\w+)+').finditer
_word_types = (
    ly.lex.String, ly.lex.Comment, ly.lex.Unparsed,
    ly.lex.lilypond.MarkupWord, ly.lex.lilypond.LyricText)

def words(document):
    """Harvests words from strings, lyrics, markup and comments."""
    for t in tokeniter.all_tokens(document):
        if isinstance(t, _word_types):
            for m in _words(t):
                yield m.group()


########NEW FILE########
__FILENAME__ = util
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Utility functions used in the autocomplete package.
"""

from __future__ import unicode_literals

import functools
import time
import weakref


def keep(f):
    """Returns a decorator that remembers its return value for some time."""
    _delay = 5.0 # sec
    _cache = weakref.WeakKeyDictionary()
    @functools.wraps(f)
    def decorator(self, *args):
        try:
            result = _cache[self]
        except KeyError:
            pass
        else:
            t, ret = result
            if (time.time() - t) < _delay:
                return ret
        ret = f(self, *args)
        _cache[self] = (time.time(), ret)
        return ret
    return decorator


# helper functions for displaying data from models
def command(item):
    """Prepends '\\' to item."""
    return '\\' + item


def variable(item):
    """Appends ' = ' to item."""
    return item + " = "


def cmd_or_var(item):
    """Appends ' = ' to item if it does not start with '\\'."""
    return item if item.startswith('\\') else item + " = "


def make_cmds(words):
    """Returns generator prepending '\\' to every word."""
    return ('\\' + w for w in words)



########NEW FILE########
__FILENAME__ = backup
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Backup files before overwriting
"""

from __future__ import unicode_literals

import os
import shutil

from PyQt4.QtCore import QSettings


def backup(filename):
    """Makes a backup of 'filename'.
    
    Returns True if the backup succeeded.
    
    """
    if filename:
        try:
            shutil.copy(filename, backupName(filename))
            return True
        except (IOError, OSError):
            pass
    return False


def removeBackup(filename):
    """Removes filename's backup unless the user has configured to keep it."""
    if filename and not QSettings().value("backup_keep", False, bool):
        try:
            os.remove(backupName(filename))
        except (IOError, OSError):
            pass


def scheme():
    """Returns a string that must contain "FILE".
    
    Replacing that part yields the backup name.
    
    """
    s = QSettings().value("backup_scheme", "FILE~")
    assert 'FILE' in s and s != 'FILE'
    return s


def backupName(filename):
    """Returns the backup file name for the given filename."""
    return scheme().replace("FILE", filename)



########NEW FILE########
__FILENAME__ = bookmarkmanager
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages the actions that manipulate the bookmarks (see also bookmarks.py).
"""

from __future__ import unicode_literals

from PyQt4.QtCore import Qt
from PyQt4.QtGui import QAction

import actioncollection
import actioncollectionmanager
import icons
import bookmarks
import plugin


class BookmarkManager(plugin.MainWindowPlugin):
    def __init__(self, mainwindow):
        ac = self.actionCollection = Actions()
        actioncollectionmanager.manager(mainwindow).addActionCollection(ac)
        ac.view_next_mark.triggered.connect(self.nextMark)
        ac.view_previous_mark.triggered.connect(self.previousMark)
        ac.view_bookmark.triggered.connect(self.markCurrentLine)
        ac.view_clear_error_marks.triggered.connect(self.clearErrorMarks)
        ac.view_clear_all_marks.triggered.connect(self.clearAllMarks)
        mainwindow.currentViewChanged.connect(self.slotViewChanged)
        mainwindow.currentDocumentChanged.connect(self.slotDocumentChanged)
        if mainwindow.currentView():
            self.slotViewChanged(mainwindow.currentView())
            self.slotDocumentChanged(mainwindow.currentDocument())
    
    def slotViewChanged(self, view, prev=None):
        if prev:
            prev.cursorPositionChanged.disconnect(self.updateMarkStatus)
        view.cursorPositionChanged.connect(self.updateMarkStatus)

    def slotDocumentChanged(self, doc, prev=None):
        if prev:
            bookmarks.bookmarks(prev).marksChanged.disconnect(self.updateMarkStatus)
        bookmarks.bookmarks(doc).marksChanged.connect(self.updateMarkStatus)

    def updateMarkStatus(self):
        view = self.mainwindow().currentView()
        self.actionCollection.view_bookmark.setChecked(
            bookmarks.bookmarks(view.document()).hasMark(view.textCursor().blockNumber(), 'mark'))

    def markCurrentLine(self):
        view = self.mainwindow().currentView()
        lineNumber = view.textCursor().blockNumber()
        bookmarks.bookmarks(view.document()).toggleMark(lineNumber, 'mark')
    
    def clearErrorMarks(self):
        doc = self.mainwindow().currentDocument()
        bookmarks.bookmarks(doc).clear('error')
        
    def clearAllMarks(self):
        doc = self.mainwindow().currentDocument()
        bookmarks.bookmarks(doc).clear()
    
    def nextMark(self):
        view = self.mainwindow().currentView()
        cursor = view.textCursor()
        cursor = bookmarks.bookmarks(view.document()).nextMark(cursor)
        if cursor:
            view.setTextCursor(cursor)
            
    def previousMark(self):
        view = self.mainwindow().currentView()
        cursor = view.textCursor()
        cursor = bookmarks.bookmarks(view.document()).previousMark(cursor)
        if cursor:
            view.setTextCursor(cursor)


class Actions(actioncollection.ActionCollection):
    name = "bookmarkmanager"
    def createActions(self, parent):
        self.view_bookmark = QAction(parent)
        self.view_bookmark.setCheckable(True)
        self.view_clear_error_marks = QAction(parent)
        self.view_clear_all_marks = QAction(parent)
        self.view_next_mark = QAction(parent)
        self.view_previous_mark = QAction(parent)

        self.view_bookmark.setShortcut(Qt.CTRL + Qt.Key_B)
        self.view_next_mark.setShortcut(Qt.ALT + Qt.Key_PageDown)
        self.view_previous_mark.setShortcut(Qt.ALT + Qt.Key_PageUp)

        self.view_bookmark.setIcon(icons.get('bookmark-new'))
        self.view_clear_all_marks.setIcon(icons.get('edit-clear'))

    def translateUI(self):
        self.view_bookmark.setText(_("&Mark Current Line"))
        self.view_clear_error_marks.setText(_("Clear &Error Marks"))
        self.view_clear_all_marks.setText(_("Clear &All Marks"))
        self.view_next_mark.setText(_("Next Mark"))
        self.view_previous_mark.setText(_("Previous Mark"))



########NEW FILE########
__FILENAME__ = bookmarks
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages marked lines (bookmarks) for a Document.

A mark is simply a QTextCursor that maintains its position in the document.

There are different types (categories) of marks, listed in the module-global
types variable. Currently the available types are 'mark' (a normal mark)
and 'error' (marking a line containing an error).

"""

from __future__ import unicode_literals

import bisect
import json

from PyQt4.QtGui import QTextCursor

import metainfo
import signals
import plugin

types = (
    'mark',
    'error',
)


metainfo.define('bookmarks', json.dumps(None), bytes)


def bookmarks(document):
    """Returns the Bookmarks instance for the document."""
    return Bookmarks.instance(document)


class Bookmarks(plugin.DocumentPlugin):
    """Manages bookmarks (marked lines) for a Document.
    
    The marks are stored in the metainfo for the Document.
    
    """
    marksChanged = signals.Signal()
    
    def __init__(self, document):
        """Creates the Bookmarks instance."""
        document.loaded.connect(self.load)
        document.saved.connect(self.save)
        document.closed.connect(self.save)
        self.load() # initializes self._marks
        
    def marks(self, type=None):
        """Returns marks (QTextCursor instances).
        
        If type is specified (one of the names in the module-global types variable),
        the list of marks of that type is returned.
        If type is None, a dictionary listing all types mapped to lists of marks
        is returned.
        
        """
        
        return self._marks[type] if type else self._marks
    
    def setMark(self, linenum, type):
        """Marks the given line number with a mark of the given type."""
        nums = [mark.blockNumber() for mark in self._marks[type]]
        if linenum in nums:
            return
        index = bisect.bisect_left(nums, linenum)
        mark = QTextCursor(self.document().findBlockByNumber(linenum))
        try:
            # only available in very recent PyQt4 versions
            mark.setKeepPositionOnInsert(True)
        except AttributeError:
            pass
        self._marks[type].insert(index, mark)
        self.marksChanged()
        
    def unsetMark(self, linenum, type):
        """Removes a mark of the given type on the given line."""
        nums = [mark.blockNumber() for mark in self._marks[type]]
        if linenum in nums:
            # remove double occurrences
            while True:
                index = bisect.bisect_left(nums, linenum)
                del self._marks[type][index]
                del nums[index]
                if linenum not in nums:
                    break
            self.marksChanged()
        
    def toggleMark(self, linenum, type):
        """Toggles the mark of the given type on the given line."""
        nums = [mark.blockNumber() for mark in self._marks[type]]
        index = bisect.bisect_left(nums, linenum)
        if linenum in nums:
            # remove double occurrences
            while True:
                del self._marks[type][index]
                del nums[index]
                if linenum not in nums:
                    break
                index = bisect.bisect_left(nums, linenum)
        else:
            mark = QTextCursor(self.document().findBlockByNumber(linenum))
            try:
                # only available in very recent PyQt4 versions
                mark.setKeepPositionOnInsert(True)
            except AttributeError:
                pass
            self._marks[type].insert(index, mark)
        self.marksChanged()

    def hasMark(self, linenum, type=None):
        """Returns True if the line has a mark (of the given type if specified) else False."""
        for type in types if type is None else (type,):
            for mark in self._marks[type]:
                if mark.blockNumber() == linenum:
                    return True
        return False
        
    def clear(self, type=None):
        """Removes all marks, or only all marks of the given type. if specified."""
        if type is None:
            for type in types:
                self._marks[type] = []
        else:
            self._marks[type] = []
        self.marksChanged()

    def nextMark(self, cursor, type=None):
        """Finds the first mark after the cursor (of the type if specified)."""
        if type is None:
            marks = []
            for type in types:
                marks += self._marks[type]
            # sort the marks on line number
            marks.sort(key=lambda mark: mark.blockNumber())
        else:
            marks = self._marks[type]
        nums = [mark.blockNumber() for mark in marks]
        index = bisect.bisect_right(nums, cursor.blockNumber())
        if index < len(nums):
            return QTextCursor(marks[index].block())
        
    def previousMark(self, cursor, type=None):
        """Finds the first mark before the cursor (of the type if specified)."""
        if type is None:
            marks = []
            for type in types:
                marks += self._marks[type]
            # sort the marks on line number
            marks.sort(key=lambda mark: mark.blockNumber())
        else:
            marks = self._marks[type]
        nums = [mark.blockNumber() for mark in marks]
        index = bisect.bisect_left(nums, cursor.blockNumber())
        if index > 0:
            return QTextCursor(marks[index-1].block())

    def load(self):
        """Loads the marks from the metainfo."""
        self._marks = dict((type, []) for type in types)
        marks = metainfo.info(self.document()).bookmarks
        try:
            d = json.loads(marks) or {}
        except ValueError:
            return # No JSON object could be decoded
        for type in types:
            self._marks[type] = [QTextCursor(self.document().findBlockByNumber(num)) for num in d.get(type, [])]
        self.marksChanged()
        
    def save(self):
        """Saves the marks to the metainfo."""
        d = {}
        for type in types:
            d[type] = lines = []
            for mark in self._marks[type]:
                linenum = mark.blockNumber()
                if linenum not in lines:
                    lines.append(linenum)
        metainfo.info(self.document()).bookmarks = json.dumps(d)



########NEW FILE########
__FILENAME__ = browseriface
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2014 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Provides a browser-like interface for switching documents and cursor positions.

Remembers the current position and view when jumping to another location.
Provides buttons to go back or forward.

"""

from __future__ import unicode_literals

from PyQt4.QtCore import Qt
from PyQt4.QtGui import QAction, QKeySequence

import app
import actioncollection
import actioncollectionmanager
import plugin
import icons


class Position(object):
    cursor = None
    find_open_view = None


def get(mainwindow):
    """Returns the BrowserIface instance for the specified MainWindow."""
    return BrowserIface.instance(mainwindow)


class BrowserIface(plugin.MainWindowPlugin):
    def __init__(self, mainwindow):
        ac = self.actionCollection = Actions()
        actioncollectionmanager.manager(mainwindow).addActionCollection(ac)
        ac.go_back.triggered.connect(self.goBack)
        ac.go_forward.triggered.connect(self.goForward)
        app.documentClosed.connect(self._documentClosed)
        self._history = [Position()]
        self._index = 0    # the index points to the current position
        self.updateActions()
    
    def goBack(self):
        """Called when the user activates the go_back action."""
        if self._index > 0:
            self._history[self._index].cursor = self.mainwindow().textCursor()
            self._index -= 1
            p = self._history[self._index]
            self.mainwindow().setTextCursor(p.cursor, p.find_open_view)
            self.updateActions()
            
    def goForward(self):
        """Called when the user activates the go_forward action."""
        if self._index < len(self._history) - 1:
            self._history[self._index].cursor = self.mainwindow().textCursor()
            self._index += 1
            p = self._history[self._index]
            self.mainwindow().setTextCursor(p.cursor, p.find_open_view)
            self.updateActions()

    def setTextCursor(self, cursor, findOpenView=None):
        """Move to the new cursor position and remember the current one."""
        self._remember(findOpenView)
        self.mainwindow().setTextCursor(cursor, findOpenView)
    
    def setCurrentDocument(self, doc, findOpenView=None):
        """Switch to a different document and remember the current cursor position."""
        self._remember(findOpenView)
        self.mainwindow().setCurrentDocument(doc, findOpenView)
    
    def updateActions(self):
        """Update the actions depending on current position in history."""
        self.actionCollection.go_back.setEnabled(self._index > 0)
        self.actionCollection.go_forward.setEnabled(self._index < len(self._history) - 1)
    
    def _remember(self, findOpenView):
        """(Internal) Remember the current cursor position and whether a new view was requested."""
        pos = self._history[self._index]
        pos.cursor = self.mainwindow().textCursor()
        pos.find_open_view = findOpenView
        self._index += 1
        del self._history[self._index:]
        self._history.append(Position())
        self.updateActions()
    
    def _documentClosed(self, doc):
        """(Internal) Called when a document is closed.
        
        Removes the positions in the history of that document.
        
        """
        for i, pos in reversed(list(enumerate(self._history))):   # copy
            if pos.cursor and doc is pos.cursor.document():
                del self._history[i]
                if self._index > i:
                    self._index -= 1
        if not self._history:
            self._history = [Position()]
        if self._index > len(self._history) - 1:
            self._index = len(self._history) - 1
        self.updateActions()


class Actions(actioncollection.ActionCollection):
    name = "browseriface"
    def createActions(self, parent):
        self.go_back = QAction(parent)
        self.go_forward = QAction(parent)
        
        self.go_back.setIcon(icons.get('go-previous'))
        self.go_forward.setIcon(icons.get('go-next'))
        
        self.go_back.setShortcut(QKeySequence(Qt.ALT + Qt.Key_Backspace))
        self.go_forward.setShortcut(QKeySequence(Qt.ALT + Qt.Key_End))
    
    def translateUI(self):
        self.go_back.setText(_("Go to previous position"))
        self.go_back.setIconText(_("Back"))
        self.go_forward.setText(_("Go to next position"))
        self.go_forward.setIconText(_("Forward"))


########NEW FILE########
__FILENAME__ = bugreport
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Functions to compose a bugreport via e-mail and to get version information.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QUrl

import helpers
import info


def versionInfo():
    """Returns version and platform information as a dict for debugging purposes."""
    try:
        import sip
        sip_version = sip.SIP_VERSION_STR
    except (ImportError, NameError):
        sip_version = "unknown"
    
    try:
        import PyQt4.QtCore
        pyqt_version = PyQt4.QtCore.PYQT_VERSION_STR
    except (ImportError, NameError):
        pyqt_version = "unknown"
    
    try:
        qt_version = PyQt4.QtCore.QT_VERSION_STR
    except NameError:
        qt_version = "unknown"
    
    try:
        import platform
        python_version = platform.python_version()
        osname = platform.platform().decode('utf-8')
    except (ImportError, NameError):
        python_version = "unknown"
        osname = "unknown"
    
    return locals()


def versionInfoString():
    """Returns the information from versionInfo() formatted as a terse string."""
    return (
        "Python: {python_version} -- "
        "Qt: {qt_version} -- "
        "PyQt4: {pyqt_version} -- "
        "sip: {sip_version}\n"
        "OS: {osname}".format(**versionInfo()))
    

def email(subject, body):
    """Opens the e-mail composer with the given subject and body, with version information added to it."""
    subject = "[{0} {1}] {2}".format(info.appname, info.version, subject)
    body = "{0}: {1}\n\n{2}\n\n{3}\n\n".format(info.appname, info.version, versionInfoString(), body)
    url = QUrl("mailto:" + info.maintainer_email)
    url.addQueryItem("subject", subject)
    url.addQueryItem("body", body)
    helpers.openUrl(url, "email")


########NEW FILE########
__FILENAME__ = cachedproperty
# cachedproperty.py -- a property that caches its asynchronously computed value
#
# Copyright (c) 2012 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
An advanced property that computes and caches expensive operations
(such as running an external command and reading its output).

A callback when a value is computed/read is also supported.

You may inherit from CachedProperty to implement the logic to compute
or retrieve the value, or you may use the CachedProperty as a decorator,
where the function is called once to return the result or to assign it
to the property.

If you are using the property as a descriptor e.g.:

import cachedproperty

class MyClass(object):
    version = cachedproperty.cachedproperty()

obj = MyClass()

you can retrieve the value with

    obj.version()

Note that, unlike the Python 'property' built-in, parentheses are needed to get
the value. Without parentheses the property itself is returned, which has some
additional features. obj.version() is equivalent to obj.version.get()

If the returned value is None, the property is considered to be unset (i.e.
not set or computed yet). You can force the value to be computed with:

    obj.version.start()

(and be notified when set with:

    obj.version.computed.connect(myfunction)

), and delete the value with:

    del obj.version

You can also assign a value:

    obj.version = 123

In that case, the value will not be computed anymore.

If you want the value now or later, you can also use

    obj.version.callback(myfunction)

which will call myfunction either now or later with the value.

Properties can also depend on each other:

class MyClass(object):

    @cachedproperty.cachedproperty
    def command(self):
        # ....
    
    @cachedproperty.cachedproperty(depends=command)
    def version(self):
        cmd = self.command()
        # command has already been computed when this function runs.


When used this way, the function can either return the value for the property
or set if directly. If the function returns None, it is assumed to set the
property by itself now or later. If the function returns a different value, the
default implementation sets the property to the returned value.

This module uses the signals module for the callback logic.

"""

from __future__ import unicode_literals

import weakref

import signals


class CachedProperty(object):    
    """An advanced property that can compute and cache expensive operations.
    
    This can be used to e.g. run an external command and read its output.

    A callback when a value is computed/read is also supported, either via
    the callback() method or the computed() signal.
    
    """
    # descriptor part
    @classmethod
    def cachedproperty(cls, func=None, depends=None):
        """Decorator to make cached properties."""
        if func is not None:
            return cls(func, depends)
        elif depends is None:
            return cls
        def decorator(func):
            return cls(func, depends)
        return decorator
    
    def __init__(self, func=None, depends=None):
        """Initialize the property/descriptor."""
        self._func = func
        if depends is None:
            self._depends = ()
        elif not isinstance(depends, (tuple, list)):
            self._depends = (depends,)
        else:
            self._depends = depends
        self._state = weakref.WeakKeyDictionary()
        
    def __get__(self, instance, cls=None):
        if instance is None:
            return self._func or self
        return self.bound(instance)
    
    def __set__(self, instance, value):
        self.__get__(instance).set(value)
    
    def __delete__(self, instance):
        self.__get__(instance).unset()
    
    def bound(self, instance):
        """Returns a bound instance."""
        cls = type(self)
        prop = cls.__new__(cls)
        prop._instance = instance
        prop._property = self
        return prop
    
    # instance part
    class State(object):
        signal = signals.Signal()
        def __init__(self):
            self.value = None
            self.running = False
    
    def state(self):
        """Returns the state for the instance."""
        instance = self.instance()
        d = self._property._state
        try:
            state = d[instance]
        except KeyError:
            state = d[instance] = self.State()
        return state
    
    def instance(self):
        """The instance we are a property for."""
        return self._instance
    
    @property
    def computed(self):
        """The signal that is emitted when the value is set."""
        return self.state().signal
    
    def set(self, value):
        """Sets a value.
        
        If the value is not None, the computed(value) signal is emitted.
        
        """
        state = self.state()
        state.value = value
        state.running = False
        if value is not None:
            self.computed.emit(value)
            self.computed.clear()
        
    def unset(self):
        """Sets the value to None, the property is considered unset."""
        self.state().value = None
    
    def get(self):
        """Retrieves the value, which may be None (unset)."""
        return self.state().value
    
    def __call__(self):
        """Retrieves the value, starting the computation if needed.
        
        If the function immediately returns a value it is returned;
        otherwise None is returned.
        
        """
        state = self.state()
        if state.value is None:
            self.start()
        return state.value
    
    def name(self):
        """Returns the name of the property, if given via the function."""
        if self._property._func:
            return self._property._func.__name__
    
    def isset(self):
        """Returns True if the property is set."""
        return self.state().value is not None
    
    def iscomputing(self):
        """Returns True if the property is being computed."""
        return self.state().running
        
    def callback(self, func):
        """Calls the specified function back with the value.
        
        If the value already is known, the callback is performed immediately
        (synchronous) and this method returns True.
        
        If the value yet has to be computed, the function is connected to the
        computed() signal and start() is called, so the function is called later
        with the value. In that case this method returns None.
        
        """
        value = self.state().value
        if value is not None:
            func(value)
            return True
        self.computed.connect(func)
        self.start()
    
    def start(self):
        """Starts the machinery that computes the value.
        
        This simply happens by calling run(), which should be reimplemented
        to perform the actual action.
        
        """
        state = self.state()
        if not state.running and state.value is None:
            state.running = True
            self.checkstart()
    
    def checkstart(self):
        """Starts if all dependencies are met."""
        for d in self._property._depends:
            prop = d.__get__(self.instance())
            if prop.get() is None:
                prop.computed.connect(self.checkstart)
                prop.start()
                break
        else:
            self.run()
    
    def run(self):
        """Starts the computation.
        
        The result must be set using self.set(value), which will automatically
        call all registered callbacks once.
        
        The default implementation starts the function, if given on init.
        
        """
        if self._property._func:
            result = self._property._func(self.instance())
            if result is not None:
                self.set(result)
        else:
            self.set("(null)")


cachedproperty = CachedProperty.cachedproperty


########NEW FILE########
__FILENAME__ = widget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The special characters tool widget.
"""

from __future__ import unicode_literals

import sys
import itertools

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import widgets.charmap
import unicode_blocks
import listmodel


# avoid handling characters above 0xFFFF in narrow Python builds
_blocks = tuple(itertools.takewhile(
	lambda block: block.end < sys.maxunicode,
	unicode_blocks.blocks()))


class Widget(QWidget):
    def __init__(self, tool):
        super(Widget, self).__init__(tool)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        layout.setContentsMargins(0, 0, 0, 0)
        
        self.blockCombo = QComboBox()
        self.charmap = CharMapWidget()

        layout.addWidget(self.blockCombo)
        layout.addWidget(self.charmap)

        # size policy of combo
        p = self.blockCombo.sizePolicy()
        p.setHorizontalPolicy(QSizePolicy.Ignored)
        self.blockCombo.setSizePolicy(p)
        
        # size policy of combo popup
        p = self.blockCombo.view().sizePolicy()
        p.setHorizontalPolicy(QSizePolicy.MinimumExpanding)
        self.blockCombo.view().setSizePolicy(p)
        
        model = listmodel.ListModel(_blocks,
            display = lambda b: b.name)
        self.blockCombo.setModel(model)
        
        # load block setting
        name = QSettings().value("charmaptool/last_block", "", type(""))
        if name:
            for i, b in enumerate(_blocks):
                if b.name == name:
                    self.blockCombo.setCurrentIndex(i)
                    break
        
        self.blockCombo.activated[int].connect(self.updateBlock)
        self.updateBlock()
        
        self.loadSettings()
        app.settingsChanged.connect(self.loadSettings)
    
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("charmaptool")
        font = self.font()
        family = s.value("fontfamily", "", type(""))
        if family:
            font.setFamily(family)
        self.charmap.charmap.setDisplayFont(font)
        size = s.value("fontsize", font.pointSizeF(), float)
        self.charmap.charmap.setDisplayFontSizeF(size)
    
    def updateBlock(self):
        i = self.blockCombo.currentIndex()
        if 0 <= i < len(_blocks):
            first, last, name = _blocks[i]
            self.charmap.charmap.setRange(first, last)
            QSettings().setValue("charmaptool/last_block", name)





class CharMapWidget(QScrollArea):
    def __init__(self, parent=None):
        super(CharMapWidget, self).__init__(parent)
        self.charmap = widgets.charmap.CharMap()
        self.setWidget(self.charmap)
        # TEMP
        self.charmap.setRange(32, 1023)
        self.charmap.setColumnCount(8)
    
    def resizeEvent(self, ev):
        self.charmap.setColumnCount(
            self.charmap.columnCountForWidth(ev.size().width()))




########NEW FILE########
__FILENAME__ = completionmodel
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A simple persistent completion model (e.g. for QLineEdits).
"""

import atexit
import weakref

from PyQt4.QtCore import QSettings, QTimer
from PyQt4.QtGui import QCompleter, QStringListModel

_models = {}


def model(key):
    """Returns the model for the given settings key.
    
    A Model is instantiated if necessary.
    The model remains alive until the application exits, at which
    moment the data is saved.
    
    """
    try:
        return _models[key]
    except KeyError:
        m = _models[key] = Model(key)
        atexit.register(m.save)
        return m


def complete(lineedit, key):
    """A convenience function that installs a completer on the QLineEdit.
    
    The key is the QSettings key used to store the completions persistently.
    By default, the function tries to add the text in the line edit to 
    the stored completions when the window() of the lineedit is a Dialog
    and its accepted signal is fired.
    
    Returned is a callable a signal can be connected to, that stores the text
    in the line edit in the completions. (You don't have to use that if your
    widget is in a QDialog that has an accepted() signal.)
    
    """
    m = model(key)
    c = QCompleter(m, lineedit)
    lineedit.setCompleter(c)
    def store(completer = weakref.ref(c)):
        """Stores the contents of the line edit in the completer's model.
        
        Does not keep a reference to any object.
        
        """
        c = completer()
        if c:
            model = c.model()
            lineedit = c.parent()
            if model and lineedit:
                text = lineedit.text().strip()
                if text:
                    model.addString(text)
    def connect():
        """Try to connect the store() function to the accepted() signal of the parent QDialog.
        
        Return True if that succeeds, else False.
        
        """
        dlg = lineedit.window()
        try:
            dlg.accepted.connect(store)
        except AttributeError:
            return False
        return True
    connect() or QTimer.singleShot(0, connect)
    return store


class Model(QStringListModel):
    """A simple model providing a list of strings for a QCompleter.
    
    Instantiate the model with a QSettings key, e.g. 'somegroup/names'.
    Use the addString() method to add a string.
    
    """
    def __init__(self, key):
        super(Model, self).__init__()
        self.key = key
        self._changed = False
        self.load()
        
    def load(self):
        try:
            strings = QSettings().value(self.key, [], type(""))
        except TypeError:
            strings = []
        self.setStringList(sorted(strings))
        self._changed = False
    
    def save(self):
        if self._changed:
            QSettings().setValue(self.key, self.stringList())
            self._changed = False

    def addString(self, text):
        strings = self.stringList()
        if text not in strings:
            strings.append(text)
            strings.sort()
            self.setStringList(strings)
            self._changed = True



########NEW FILE########
__FILENAME__ = contextmenu
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The contextmenu of the editor.

This module is imported when a contextmenu event occurs in the View (view.py).

"""

from __future__ import unicode_literals

from PyQt4.QtCore import QTimer, QUrl
from PyQt4.QtGui import QAction

import icons
import util
import browseriface


def contextmenu(view):
    cursor = view.textCursor()
    menu = view.createStandardContextMenu()
    mainwindow = view.window()

    # create the actions in the actions list
    actions = []
    
    actions.extend(open_files(cursor, menu, mainwindow))
    
    actions.extend(jump_to_definition(cursor, menu, mainwindow))
    
    
    if cursor.hasSelection():
        import panelmanager
        actions.append(panelmanager.manager(mainwindow).snippettool.actionCollection.copy_to_snippet)
        actions.append(mainwindow.actionCollection.edit_copy_colored_html)
    
    # now add the actions to the standard menu
    if actions:
        first_action = menu.actions()[0] if menu.actions() else None
        if first_action:
            first_action = menu.insertSeparator(first_action)
            menu.insertActions(first_action, actions)
        else:
            menu.addActions(actions)
    return menu


def open_files(cursor, menu, mainwindow):
    """Return a list of actions (maybe empty) for files at the cursor to open."""
    def action(filename):
        url = QUrl.fromLocalFile(filename)
        a = QAction(menu)
        a.setText(_("Open \"{url}\"").format(url=util.homify(filename)))
        a.setIcon(icons.get('document-open'))
        @a.triggered.connect
        def open_doc():
            d = mainwindow.openUrl(url)
            browseriface.get(mainwindow).setCurrentDocument(d)
        return a
    import open_file_at_cursor
    return list(map(action, open_file_at_cursor.filenames_at_cursor(cursor)))


def jump_to_definition(cursor, menu, mainwindow):
    """Return a list of context menu actions jumping to the definition."""
    import definition
    node = definition.refnode(cursor)
    if node:
        a = QAction(menu)
        def complete():
            target = definition.target(node)
            if target:
                if target.document is node.document:
                    a.setText(_("&Jump to definition (line {num})").format(
                        num = node.document.index(node.document.block(target.position)) + 1))
                else:
                    a.setText(_("&Jump to definition (in {filename})").format(
                        filename=util.homify(target.document.filename)))
                @a.triggered.connect
                def activate():
                    definition.goto_target(mainwindow, target)
            else:
                a.setText(_("&Jump to definition (unknown)"))
                a.setEnabled(False)
        QTimer.singleShot(0, complete)
        return [a]
    return []


########NEW FILE########
__FILENAME__ = convert_ly
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Updates a document using convert-ly.
"""

from __future__ import unicode_literals

import textwrap
import os
import subprocess

from PyQt4.QtCore import QSettings, QSize
from PyQt4.QtGui import (
    QCheckBox, QComboBox, QDialog, QDialogButtonBox, QGridLayout, QLabel,
    QLineEdit, QTabWidget, QTextBrowser, QVBoxLayout)

import app
import util
import qutil
import icons
import widgets
import htmldiff
import cursordiff
import lilychooser
import documentinfo
import textformats


def convert(mainwindow):
    """Shows the dialog."""
    dlg = Dialog(mainwindow)
    dlg.addAction(mainwindow.actionCollection.help_whatsthis)
    dlg.setDocument(mainwindow.currentDocument())
    dlg.setModal(True)
    dlg.show()
    dlg.run()
    if dlg.exec_():
        c = mainwindow.textCursor()
        c.select(c.Document)
        text = dlg.convertedText()
        if dlg.copyCheck.isChecked():
            msgs = textwrap.fill(dlg.messages.toPlainText())
            text += '\n\n%{\n' + msgs + '\n%}\n'
        cursordiff.insert_text(c, text)
    dlg.deleteLater()


class Dialog(QDialog):
    def __init__(self, parent=None):
        super(Dialog, self).__init__(parent)
        
        self._info = None
        self._text = ''
        self._convertedtext = ''
        self._encoding = None
        
        self.fromVersionLabel = QLabel()
        self.fromVersion = QLineEdit()
        self.reason = QLabel()
        self.toVersionLabel = QLabel()
        self.toVersion = QLineEdit()
        self.lilyChooser = lilychooser.LilyChooser()
        self.messages = QTextBrowser()
        self.diff = QTextBrowser(lineWrapMode=QTextBrowser.NoWrap)
        self.copyCheck = QCheckBox(checked=
            QSettings().value('convert_ly/copy_messages', True, bool))
        self.tabw = QTabWidget()
        
        self.tabw.addTab(self.messages, '')
        self.tabw.addTab(self.diff, '')
        
        self.buttons = QDialogButtonBox(
            QDialogButtonBox.Reset |
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        self.buttons.button(QDialogButtonBox.Reset).clicked.connect(self.run)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        grid = QGridLayout()
        grid.addWidget(self.fromVersionLabel, 0, 0)
        grid.addWidget(self.fromVersion, 0, 1)
        grid.addWidget(self.reason, 0, 2, 1, 3)
        grid.addWidget(self.toVersionLabel, 1, 0)
        grid.addWidget(self.toVersion, 1, 1)
        grid.addWidget(self.lilyChooser, 1, 3, 1, 2)
        
        layout.addLayout(grid)
        layout.addWidget(self.tabw)
        layout.addWidget(self.copyCheck)
        layout.addWidget(widgets.Separator())
        layout.addWidget(self.buttons)
        
        app.translateUI(self)
        qutil.saveDialogSize(self, 'convert_ly/dialog/size', QSize(600, 300))
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
        self.finished.connect(self.saveCopyCheckSetting)
        self.lilyChooser.currentIndexChanged.connect(self.slotLilyPondVersionChanged)
        self.slotLilyPondVersionChanged()
        
    def translateUI(self):
        self.fromVersionLabel.setText(_("From version:"))
        self.toVersionLabel.setText(_("To version:"))
        self.copyCheck.setText(_("Save convert-ly messages in document"))
        self.copyCheck.setToolTip(_(
            "If checked, the messages of convert-ly are appended as a "
            "comment to the end of the document."))
        self.tabw.setTabText(0, _("&Messages"))
        self.tabw.setTabText(1, _("&Changes"))
        self.buttons.button(QDialogButtonBox.Reset).setText(_("Run Again"))
        self.setCaption()
    
    def saveCopyCheckSetting(self):
        QSettings().setValue('convert_ly/copy_messages', self.copyCheck.isChecked())
    
    def readSettings(self):
        font = textformats.formatData('editor').font
        self.diff.setFont(font)
    
    def slotLilyPondVersionChanged(self):
        self.setLilyPondInfo(self.lilyChooser.lilyPondInfo())
    
    def setCaption(self):
        version = self._info and self._info.versionString() or _("<unknown>")
        title = _("Convert-ly from LilyPond {version}").format(version=version)
        self.setWindowTitle(app.caption(title))

    def setLilyPondInfo(self, info):
        self._info = info
        self.setCaption()
        self.toVersion.setText(info.versionString())
        self.setConvertedText()
        self.messages.clear()
    
    def setConvertedText(self, text=''):
        self._convertedtext = text
        self.buttons.button(QDialogButtonBox.Ok).setEnabled(bool(text))
        if text:
            self.diff.setHtml(htmldiff.htmldiff(
                self._text, text,
                _("Current Document"), _("Converted Document"),
                wrapcolumn=100))
        else:
            self.diff.clear()
    
    def convertedText(self):
        return self._convertedtext or ''
    
    def setDocument(self, doc):
        v = documentinfo.docinfo(doc).version_string()
        if v:
            self.fromVersion.setText(v)
            self.reason.setText(_("(set in document)"))
        else:
            self.reason.clear()
        self._text = doc.toPlainText()
        self._encoding = doc.encoding() or 'UTF-8'
        self.setConvertedText()
        
    def run(self):
        """Runs convert-ly (again)."""
        fromVersion = self.fromVersion.text()
        toVersion = self.toVersion.text()
        if not fromVersion or not toVersion:
            self.messages.setPlainText(_(
                "Both 'from' and 'to' versions need to be set."))
            return
        info = self._info
        command = info.toolcommand(info.convert_ly)
        command += ['-f', fromVersion, '-t', toVersion, '-']
        
        # if the user wants english messages, do it also here: LANGUAGE=C
        env = None
        if QSettings().value("lilypond_settings/no_translation", False, bool):
            if os.name == "nt":
                # Python 2.7 subprocess on Windows chokes on unicode in env
                env = util.bytes_environ()
                env[b'LANGUAGE'] = b'C'
            else:
                env = dict(os.environ)
                env['LANGUAGE'] = 'C'
        
        with qutil.busyCursor():
            try:
                proc = subprocess.Popen(command,
                    universal_newlines = True,
                    env = env,
                    stdin = subprocess.PIPE,
                    stdout = subprocess.PIPE,
                    stderr = subprocess.PIPE)
                out, err = proc.communicate(self._text.encode(self._encoding))
            except OSError as e:
                self.messages.setPlainText(_(
                    "Could not start {convert_ly}:\n\n"
                    "{message}\n").format(convert_ly = convert_ly, message = e))
                return
            self.messages.setPlainText(err.decode('UTF-8'))
            self.setConvertedText(out.decode('UTF-8'))
            if not out or self._convertedtext == self._text:
                self.messages.append('\n' + _("The document has not been changed."))



########NEW FILE########
__FILENAME__ = cursordiff
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Replaces selected text of a QTextCursor without erasing all the other
QTextCursor instances that exist in the selected range.

This is done by making a diff between the existing selection and the replacing
text, and applying that diff.
"""

from __future__ import unicode_literals

import difflib

import cursortools


def insert_text(cursor, text):
    """Replaces selected text of a QTextCursor.
    
    This is done without erasing all the other QTextCursor instances that could
    exist in the selected range. It works by making a diff between the
    existing selection and the replacement text, and applying that diff.
    
    """
    if not cursor.hasSelection() or text == "":
        cursor.insertText(text)
        return
    
    start = cursor.selectionStart()
    new_pos = start + len(text)
    
    old = cursor.selection().toPlainText()
    diff = difflib.SequenceMatcher(None, old, text).get_opcodes()
    
    # make a list of edits
    edits = sorted(
        ((start + i1, start + i2, text[j1:j2])
         for tag, i1, i2, j1, j2 in diff
         if tag != 'equal'),
        reverse = True)
    
    # perform the edits
    with cursortools.compress_undo(cursor):
        for pos, end, text in edits:
            cursor.setPosition(pos)
            cursor.setPosition(end, cursor.KeepAnchor)
            cursor.insertText(text)
    cursor.setPosition(new_pos)



########NEW FILE########
__FILENAME__ = cursortools
# cursortools.py -- QTextCursor utility functions
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Functions manipulating QTextCursors and their selections.
"""

from __future__ import unicode_literals

import contextlib
import operator

from PyQt4.QtGui import QTextBlock, QTextBlockUserData, QTextCursor


def block(cursor):
    """Returns the cursor's block.
    
    If the cursor has a selection, returns the block the selection starts in
    (regardless of the cursor's position()).
    
    """
    if cursor.hasSelection():
        return cursor.document().findBlock(cursor.selectionStart())
    return cursor.block()

    
def blocks(cursor):
    """Yields the block(s) containing the cursor or selection."""
    d = cursor.document()
    block = d.findBlock(cursor.selectionStart())
    end = d.findBlock(cursor.selectionEnd())
    while True:
        yield block
        if block == end:
            break
        block = block.next()
     

def contains(c1, c2):
    """Returns True if cursor2's selection falls inside cursor1's."""
    return (c1.selectionStart() <= c2.selectionStart()
            and c1.selectionEnd() >= c2.selectionEnd())


def forwards(block, until=QTextBlock()):
    """Yields the block and all following blocks.
    
    If until is a valid block, yields the blocks until the specified block.
    
    """
    if until.isValid():
        while block.isValid() and block <= until:
            yield block
            block = block.next()
    else:
        while block.isValid():
            yield block
            block = block.next()


def backwards(block, until=QTextBlock()):
    """Yields the block and all preceding blocks.
    
    If until is a valid block, yields the blocks until the specified block.
    
    """
    if until.isValid():
        while block.isValid() and block >= until:
            yield block
            block = block.previous()
    else:
        while block.isValid():
            yield block
            block = block.previous()

    
def all_blocks(document):
    """Yields all blocks of the document."""
    return forwards(document.firstBlock())


def partition(cursor):
    """Returns a three-tuple of strings (before, selection, after).
    
    'before' is the text before the cursor's position or selection start,
    'after' is the text after the cursor's position or selection end,
    'selection' is the selected text.
    
    before and after never contain a newline.
    
    """
    start = cursor.document().findBlock(cursor.selectionStart())
    end = cursor.document().findBlock(cursor.selectionEnd())
    before = start.text()[:cursor.selectionStart() - start.position()]
    selection = cursor.selection().toPlainText()
    after = end.text()[cursor.selectionEnd() - end.position():]
    return before, selection, after


@contextlib.contextmanager
def compress_undo(cursor, join_previous = False):
    """Returns a context manager to perform operations on cursor as a single undo-item."""
    cursor.joinPreviousEditBlock() if join_previous else cursor.beginEditBlock()
    try:
        yield
    finally:
        cursor.endEditBlock()


@contextlib.contextmanager
def keep_selection(cursor, edit=None):
    """Performs operations inside the selection and restore the selection afterwards.
    
    If edit is given, call setTextCursor(cursor) on the Q(Plain)TextEdit afterwards.
    
    """
    start, end, pos = cursor.selectionStart(), cursor.selectionEnd(), cursor.position()
    cur2 = QTextCursor(cursor)
    cur2.setPosition(end)
    
    try:
        yield
    finally:
        if pos == start:
            cursor.setPosition(cur2.position())
            cursor.setPosition(start, QTextCursor.KeepAnchor)
        else:
            cursor.setPosition(start)
            cursor.setPosition(cur2.position(), QTextCursor.KeepAnchor)
        if edit:
            edit.setTextCursor(cursor)


def strip_selection(cursor, chars=None):
    """Adjusts the selection of the cursor just like Python's strip().
    
    If there is no selection or the selection would vanish completely,
    nothing is done.
    
    """
    if not cursor.hasSelection():
        return
    text = cursor.selection().toPlainText()
    if not text.strip(chars):
        return
    l = len(text) - len(text.lstrip(chars))
    r = len(text) - len(text.rstrip(chars))
    s = cursor.selectionStart() + l
    e = cursor.selectionEnd() - r
    if cursor.position() < cursor.anchor():
        s, e = e, s
    cursor.setPosition(s)
    cursor.setPosition(e, QTextCursor.KeepAnchor)


def strip_indent(cursor):
    """Moves the cursor in its block to the first non-space character."""
    text = cursor.block().text()
    pos = len(text) - len(text.lstrip())
    cursor.setPosition(cursor.block().position() + pos)


def insert_select(cursor, text):
    """Inserts text and then selects all inserted text in the cursor."""
    pos = cursor.selectionStart()
    cursor.insertText(text)
    new = cursor.position()
    cursor.setPosition(pos)
    cursor.setPosition(new, QTextCursor.KeepAnchor)


def isblank(block):
    """Returns True if the block is an empty or blank line."""
    text = block.text()
    return not text or text.isspace()


def isblank_before(cursor):
    """Returns True if there's no text on the current line before the cursor."""
    if cursor.atBlockStart():
        return True
    text = cursor.block().text()[:cursor.position() - cursor.block().position()]
    return not text or text.isspace()


def isblank_after(cursor):
    """Returns True if there's no text on the current line after the cursor."""
    if cursor.atBlockEnd():
        return True
    text = cursor.block().text()[cursor.position() - cursor.block().position():]
    return not text or text.isspace()


def next_blank(block):
    """Returns the next block that is the first block of one or more blank blocks."""
    bb = forwards(block)
    for b in bb:
        if not isblank(b):
            for b in bb:
                if isblank(b):
                    return b


def previous_blank(block):
    """Returns the previous block that is the first block of one or more blank blocks."""
    bb = backwards(block)
    for b in bb:
        if not isblank(b):
            for b in bb:
                if isblank(b):
                    for b in bb:
                        if not isblank(b):
                            b = b.next()
                            break
                    return b


def data(block):
    """Get the block's QTextBlockUserData, creating it if necessary.""" 
    data = block.userData()
    if not data:
        data = QTextBlockUserData()
        block.setUserData(data)
    return data



########NEW FILE########
__FILENAME__ = cut_assign
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Cut selected text and assign it to a LilyPond variable.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QTextCursor

import cursortools
import tokeniter
import ly.lex.lilypond
import metainfo
import indent
import inputdialog


def cut_assign(cursor):
    """Cuts selected text and assigns it to a LilyPond variable."""
    # ask the variable name
    name = inputdialog.getText(None, _("Cut and Assign"), _(
        "Please enter the name for the variable to assign the selected "
        "text to:"), regexp="[A-Za-z]+")
    if not name:
        return
    
    cursortools.strip_selection(cursor)
    
    # determine state at cursor
    block = cursortools.block(cursor)
    state = tokeniter.state(block)
    for t in tokeniter.partition(cursor).left:
        state.follow(t)
    
    mode = ""
    for p in state.parsers():
        if isinstance(p, ly.lex.lilypond.ParseInputMode):
            if isinstance(p, ly.lex.lilypond.ParseLyricMode):
                mode = " \\lyricmode"
            elif isinstance(p, ly.lex.lilypond.ParseChordMode):
                mode = " \\chordmode"
            elif isinstance(p, ly.lex.lilypond.ParseFigureMode):
                mode = " \\figuremode"
            elif isinstance(p, ly.lex.lilypond.ParseDrumMode):
                mode = " \\drummode"
            break

    # find insertion place:
    found = False
    while block.previous().isValid():
        block = block.previous()
        state = tokeniter.state(block)
        if isinstance(state.parser(), ly.lex.lilypond.ParseGlobal):
            found = True
            break
        tokens = tokeniter.tokens(block)
        for t in tokens:
            if isinstance(t, ly.lex.lilypond.Name):
                found = True
                break
            elif not isinstance(t, (ly.lex.Space, ly.lex.Comment)):
                break
        if found:
            break
    insert = QTextCursor(block)
    text = cursor.selection().toPlainText()
    space = '\n' if '\n' in text else ' '
    text = ''.join((name, ' =', mode, ' {', space, text, space, '}\n\n'))
    with cursortools.compress_undo(cursor):
        cursor.insertText('\\' + name)
        pos = insert.selectionStart()
        insert.insertText(text)
    if metainfo.info(cursor.document()).auto_indent:
        insert.setPosition(pos, QTextCursor.KeepAnchor)
        with cursortools.compress_undo(insert, True):
            indent.re_indent(insert)



########NEW FILE########
__FILENAME__ = debug
#! python
# This module helps with debugging Frescobaldi.
#
# Start a Python shell
# Enter: from frescobaldi_app.debug import *
# This runs Frescobaldi, installs some nice __repr__() methods, connects some
# signals to debug-print functions, and imports the most important modules such
# as app.

from __future__ import unicode_literals

import sys

try:
    from . import main
    del main
except (ImportError, ValueError):
    pass # this was a reload()

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import document
    


def doc_repr(self):
    index = app.documents.index(self)
    return '<Document #{0} "{1}">'.format(index, self.url().toString())
document.Document.__repr__ = doc_repr
    
@app.documentCreated.connect
def f(doc): 
    print("created:", doc)

@app.documentLoaded.connect
def f(doc):
    print("loaded:", doc)

@app.documentClosed.connect
def f(doc):
    print("closed:", doc)

@app.jobStarted.connect
def f(doc, job):
    print('job started:', doc)
    print(job.command)

@app.jobFinished.connect
def f(doc, job, success):
    print('job finished', doc)
    print('success:', success)


# more to add...
    
    
# delete unneeded stuff
del f, doc_repr

def modules():
    """Print the list of loaded modules."""
    print('\n'.join(v.__name__ for k, v in sorted(sys.modules.items()) if v is not None))


########NEW FILE########
__FILENAME__ = definition
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2014 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Find the definition of variables.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QUrl
from PyQt4.QtGui import QTextCursor

import app
import documentinfo
import ly.music.items
import browseriface


def refnode(cursor):
    """Return the music item at the cursor if that probably is a reference to a definition elsewhere."""
    node = documentinfo.music(cursor.document()).node(cursor.position())
    if (node and node.end_position() >= cursor.selectionEnd()
        and isinstance(node, (
                ly.music.items.UserCommand,
                ly.music.items.MarkupUserCommand,
        ))):
        return node


def target(node):
    """Return the target node (where the node is defined)."""
    value = node.value()
    if value:
        target = value.parent()
        if isinstance(target, ly.music.items.Document):
            target = value # happens with #(define-markup-command ...)
        return target


def goto_definition(mainwindow, cursor=None):
    """Go to the definition of the item the mainwindow's cursor is at.
    
    Return True if there was a definition.
    
    """
    if cursor is None:
        cursor = mainwindow.textCursor()
    node = refnode(cursor)
    if node:
        t = target(node)
        if t:
            goto_target(mainwindow, t)
            return True


def goto_target(mainwindow, target):
    """Switch to the document and location where the node target is."""
    filename = target.document.filename
    doc = app.openUrl(QUrl.fromLocalFile(filename))
    cursor = QTextCursor(doc)
    cursor.setPosition(target.position)
    browseriface.get(mainwindow).setTextCursor(cursor)
    mainwindow.currentView().centerCursor()



########NEW FILE########
__FILENAME__ = browser
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The browser widget for the help browser.
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import *
from PyQt4.QtGui import *
from PyQt4.QtWebKit import *

import app
import icons
import helpers
import widgets.lineedit
import lilypondinfo
import lilydoc.manager
import lilydoc.network
import textformats


class Browser(QWidget):
    """LilyPond documentation browser widget."""
    def __init__(self, dockwidget):
        super(Browser, self).__init__(dockwidget)
        
        layout = QVBoxLayout(spacing=0)
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)
        
        self.toolbar = tb = QToolBar()
        self.webview = QWebView(contextMenuPolicy=Qt.CustomContextMenu)
        self.chooser = QComboBox(sizeAdjustPolicy=QComboBox.AdjustToContents)
        self.search = SearchEntry(maximumWidth=200)
        
        layout.addWidget(self.toolbar)
        layout.addWidget(self.webview)
        
        ac = dockwidget.actionCollection
        ac.help_back.triggered.connect(self.webview.back)
        ac.help_forward.triggered.connect(self.webview.forward)
        ac.help_home.triggered.connect(self.showHomePage)
        ac.help_print.triggered.connect(self.slotPrint)
        
        self.webview.page().setNetworkAccessManager(lilydoc.network.accessmanager())
        self.webview.page().setLinkDelegationPolicy(QWebPage.DelegateAllLinks)
        self.webview.page().linkClicked.connect(self.openUrl)
        self.webview.page().setForwardUnsupportedContent(True)
        self.webview.page().unsupportedContent.connect(self.slotUnsupported)
        self.webview.urlChanged.connect(self.slotUrlChanged)
        self.webview.customContextMenuRequested.connect(self.slotShowContextMenu)
        
        tb.addAction(ac.help_back)
        tb.addAction(ac.help_forward)
        tb.addSeparator()
        tb.addAction(ac.help_home)
        tb.addAction(ac.help_print)
        tb.addSeparator()
        tb.addWidget(self.chooser)
        tb.addWidget(self.search)
        
        self.chooser.activated[int].connect(self.showHomePage)
        self.search.textEdited.connect(self.slotSearchChanged)
        self.search.returnPressed.connect(self.slotSearchReturnPressed)
        dockwidget.mainwindow().iconSizeChanged.connect(self.updateToolBarSettings)
        dockwidget.mainwindow().toolButtonStyleChanged.connect(self.updateToolBarSettings)
        
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
        self.loadDocumentation()
        self.showInitialPage()
        app.settingsChanged.connect(self.loadDocumentation)
        app.translateUI(self)
    
    def readSettings(self):
        s = QSettings()
        s.beginGroup("documentation")
        ws = self.webview.page().settings()
        family = s.value("fontfamily", self.font().family(), type(""))
        size = s.value("fontsize", 16, int)
        ws.setFontFamily(QWebSettings.StandardFont, family)
        ws.setFontSize(QWebSettings.DefaultFontSize, size)
        fixed = textformats.formatData('editor').font
        ws.setFontFamily(QWebSettings.FixedFont, fixed.family())
        ws.setFontSize(QWebSettings.DefaultFixedFontSize, fixed.pointSizeF() * 96 / 72)
        
    def keyPressEvent(self, ev):
        if ev.text() == "/":
            self.search.setFocus()
        else:
            super(Browser, self).keyPressEvent(ev)
        
    def translateUI(self):
        try:
            self.search.setPlaceholderText(_("Search..."))
        except AttributeError:
            pass # not in Qt 4.6
    
    def showInitialPage(self):
        """Shows the preferred start page.
        
        If a local documentation instance already has a suitable version,
        just loads it. Otherwise connects to the allLoaded signal, that is
        emitted when all the documentation instances have loaded their version
        information and then shows the start page (if another page wasn't yet
        loaded).
        
        """
        if self.webview.url().isEmpty():
            docs = lilydoc.manager.docs()
            version = lilypondinfo.preferred().version()
            index = -1
            if version:
                for num, doc in enumerate(docs):
                    if doc.version() is not None and doc.version() >= version:
                        index = num # a suitable documentation is found
                        break
            if index == -1:
                # nothing found (or LilyPond version not available),
                # wait for loading or show the most recent version
                if not lilydoc.manager.loaded():
                    lilydoc.manager.allLoaded.connect(self.showInitialPage)
                    return
                index = len(docs) - 1
            self.chooser.setCurrentIndex(index)
            self.showHomePage()
    
    def loadDocumentation(self):
        """Puts the available documentation instances in the combobox."""
        i = self.chooser.currentIndex()
        self.chooser.clear()
        for doc in lilydoc.manager.docs():
            v = doc.versionString()
            if doc.isLocal():
                t = _("(local)")
            else:
                t = _("({hostname})").format(hostname=doc.url().host())
            self.chooser.addItem("{0} {1}".format(v or _("<unknown>"), t))
        self.chooser.setCurrentIndex(i)
        if not lilydoc.manager.loaded():
            lilydoc.manager.allLoaded.connect(self.loadDocumentation, -1)
            return
        
    def updateToolBarSettings(self):
        mainwin = self.parentWidget().mainwindow()
        self.toolbar.setIconSize(mainwin.iconSize())
        self.toolbar.setToolButtonStyle(mainwin.toolButtonStyle())
        
    def showManual(self):
        """Invoked when the user presses F1."""
        self.slotHomeFrescobaldi() # TEMP
        
    def slotUrlChanged(self):
        ac = self.parentWidget().actionCollection
        ac.help_back.setEnabled(self.webview.history().canGoBack())
        ac.help_forward.setEnabled(self.webview.history().canGoForward())
    
    def openUrl(self, url):
        if url.path().endswith(('.ily', '.lyi', '.ly')):
            self.sourceViewer().showReply(lilydoc.network.get(url))
        else:
            self.webview.load(url)
    
    def slotUnsupported(self, reply):
        helpers.openUrl(reply.url())
    
    def slotSearchChanged(self):
        text = self.search.text()
        if not text.startswith(':'):
            self.webview.page().findText(text, QWebPage.FindWrapsAroundDocument)
    
    def slotSearchReturnPressed(self):
        text = self.search.text()
        if not text.startswith(':'):
            self.slotSearchChanged()
        else:
            pass # TODO: implement full doc search
    
    def sourceViewer(self):
        try:
            return self._sourceviewer
        except AttributeError:
            from . import sourceviewer
            self._sourceviewer = sourceviewer.SourceViewer(self)
            return self._sourceviewer
    
    def showHomePage(self):
        """Shows the homepage of the LilyPond documentation."""
        i = self.chooser.currentIndex()
        if i < 0:
            i = 0
        doc = lilydoc.manager.docs()[i]
        
        url = doc.home()
        if doc.isLocal():
            path = url.toLocalFile()
            langs = lilydoc.network.langs()
            if langs:
                for lang in langs:
                    if os.path.exists(path + '.' + lang + '.html'):
                        path += '.' + lang
                        break
            url = QUrl.fromLocalFile(path + '.html')
        self.webview.load(url)
    
    def slotPrint(self):
        printer = QPrinter()
        dlg = QPrintDialog(printer, self)
        dlg.setWindowTitle(app.caption(_("Print")))
        if dlg.exec_():
            self.webview.print_(printer)
    
    def slotShowContextMenu(self, pos):
        hit = self.webview.page().currentFrame().hitTestContent(pos)
        menu = QMenu()
        if hit.linkUrl().isValid():
            a = self.webview.pageAction(QWebPage.CopyLinkToClipboard)
            a.setIcon(icons.get("edit-copy"))
            a.setText(_("Copy &Link"))
            menu.addAction(a)
            menu.addSeparator()
            a = menu.addAction(icons.get("window-new"), _("Open Link in &New Window"))
            a.triggered.connect((lambda url: lambda: self.slotNewWindow(url))(hit.linkUrl()))
        else:
            if hit.isContentSelected():
                a = self.webview.pageAction(QWebPage.Copy)
                a.setIcon(icons.get("edit-copy"))
                a.setText(_("&Copy"))
                menu.addAction(a)
                menu.addSeparator()
            a = menu.addAction(icons.get("window-new"), _("Open Document in &New Window"))
            a.triggered.connect((lambda url: lambda: self.slotNewWindow(url))(self.webview.url()))
        if menu.actions():
            menu.exec_(self.webview.mapToGlobal(pos))
    
    def slotNewWindow(self, url):
        helpers.openUrl(url)


class SearchEntry(widgets.lineedit.LineEdit):
    """A line edit that clears itself when ESC is pressed."""
    def keyPressEvent(self, ev):
        if ev.key() == Qt.Key_Escape:
            if self.text():
                self.clear()
            else:
                webview = self.parentWidget().parentWidget().webview
                webview.setFocus()
                webview.page().findText(None)
        elif any(ev.matches(key) for key in (
            QKeySequence.MoveToNextLine, QKeySequence.MoveToPreviousLine,
            QKeySequence.MoveToNextPage, QKeySequence.MoveToPreviousPage,
                )):
            webview = self.parentWidget().parentWidget().webview
            webview.keyPressEvent(ev)
        else:
            super(SearchEntry, self).keyPressEvent(ev)



########NEW FILE########
__FILENAME__ = sourceviewer
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A dialog to view LilyPond source.
"""

from __future__ import unicode_literals


from PyQt4.QtCore import QSettings, QSize, Qt
from PyQt4.QtGui import QDialog, QLabel, QSizePolicy, QTextBrowser, QVBoxLayout


import app
import qutil
import highlighter
import textformats


class SourceViewer(QDialog):
    def __init__(self, browser):
        super(SourceViewer, self).__init__(browser.parentWidget())

        layout = QVBoxLayout()
        layout.setContentsMargins(4, 4, 4, 4)
        self.setLayout(layout)
        
        self.urlLabel = QLabel(wordWrap=True)
        layout.addWidget(self.urlLabel)
        self.textbrowser = QTextBrowser()
        layout.addWidget(self.textbrowser)
        
        self.urlLabel.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        self.textbrowser.setLineWrapMode(QTextBrowser.NoWrap)
        
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
        app.translateUI(self)
        qutil.saveDialogSize(self, "helpbrowser/sourceviewer/size", QSize(400, 300))
        
    def translateUI(self):
        self.setWindowTitle(app.caption(_("LilyPond Source")))
        
    def readSettings(self):
        data = textformats.formatData('editor')
        self.textbrowser.setPalette(data.palette())
        self.textbrowser.setFont(data.font)
        highlighter.highlight(self.textbrowser.document())
        
    def showReply(self, reply):
        reply.setParent(self)
        self.urlLabel.setText(reply.url().toString())
        reply.finished.connect(self.loadingFinished)
        self._reply = reply
        self.textbrowser.clear()
        self.show()
        
    def loadingFinished(self):
        data = self._reply.readAll()
        self._reply.close()
        self._reply.deleteLater()
        del self._reply
        self.textbrowser.clear()
        self.textbrowser.setText(unicode(data, 'utf-8', 'replace'))
        highlighter.highlight(self.textbrowser.document())


########NEW FILE########
__FILENAME__ = widget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The documents list tool widget.
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import util
import qutil

import icons
import jobmanager
import jobattributes
import engrave


def path(url):
    """Returns the path, as a string, of the url to group documents.
    
    Returns None if the document is nameless.
    
    """
    if url.isEmpty():
        return None
    elif url.toLocalFile():
        return util.homify(os.path.dirname(url.toLocalFile()))
    else:
        return url.resolved(QUrl('.')).toString(QUrl.RemoveUserInfo)


class Widget(QTreeWidget):
    def __init__(self, tool):
        super(Widget, self).__init__(tool, headerHidden=True)
        self.setRootIsDecorated(False)
        self.setSelectionMode(QTreeWidget.ExtendedSelection)
        app.documentCreated.connect(self.addDocument)
        app.documentClosed.connect(self.removeDocument)
        app.documentLoaded.connect(self.setDocumentStatus)
        app.documentModificationChanged.connect(self.setDocumentStatus)
        app.documentUrlChanged.connect(self.setDocumentStatus)
        app.jobStarted.connect(self.setDocumentStatus)
        app.jobFinished.connect(self.setDocumentStatus)
        engraver = engrave.Engraver.instance(tool.mainwindow())
        engraver.stickyChanged.connect(self.setDocumentStatus)
        tool.mainwindow().currentDocumentChanged.connect(self.selectDocument)
        self.itemSelectionChanged.connect(self.slotItemSelectionChanged)
        app.settingsChanged.connect(self.populate)
        self.populate()
    
    def populate(self):
        self._group = QSettings().value("document_list/group_by_folder", False, bool)
        self.clear()
        self._paths = {}
        self._items = {}
        with qutil.signalsBlocked(self):
            # add all existing docs to the list
            for d in app.documents:
                self.addDocument(d)
            doc = self.parentWidget().mainwindow().currentDocument()
            if doc:
                self.selectDocument(doc)
        
    def addDocument(self, doc):
        self._items[doc] = QTreeWidgetItem(self)
        self.setDocumentStatus(doc)
    
    def removeDocument(self, doc):
        i = self._items.pop(doc)
        if not self._group:
            self.takeTopLevelItem(self.indexOfTopLevelItem(i))
            return
        parent = i.parent()
        parent.takeChild(parent.indexOfChild(i))
        if parent.childCount() == 0:
            self.takeTopLevelItem(self.indexOfTopLevelItem(parent))
            del self._paths[parent._path]
    
    def selectDocument(self, doc):
        self.setCurrentItem(self._items[doc], 0, QItemSelectionModel.ClearAndSelect)

    def setDocumentStatus(self, doc):
        i = self._items[doc]
        # set properties according to document
        i.setText(0, doc.documentName())
        job = jobmanager.job(doc)
        if job and job.isRunning() and not jobattributes.get(job).hidden:
            icon = 'lilypond-run'
        elif engrave.Engraver.instance(self.parentWidget().mainwindow()).stickyDocument() is doc:
            icon = 'pushpin'
        elif doc.isModified():
            icon = 'document-save'
        else:
            icon = 'text-plain'
        i.setIcon(0, icons.get(icon))
        i.setToolTip(0, path(doc.url()))
        # handle ordering in groups if desired
        if self._group:
            self.groupDocument(doc)
        else:
            self.sortItems(0, Qt.AscendingOrder)
    
    def groupDocument(self, doc):
        """Called, if grouping is enabled, to group the document."""
        i = self._items[doc]
        p = path(doc.url())
        new_parent = self._paths.get(p)
        if new_parent is None:
            new_parent = self._paths[p] = QTreeWidgetItem(self)
            new_parent._path = p
            new_parent.setText(0, p or _("Untitled"))
            new_parent.setIcon(0, icons.get("folder-open"))
            new_parent.setFlags(Qt.ItemIsEnabled)
            new_parent.setExpanded(True)
            self.sortItems(0, Qt.AscendingOrder)
        old_parent = i.parent()
        if old_parent == new_parent:
            return
        if old_parent:
            old_parent.takeChild(old_parent.indexOfChild(i))
            if old_parent.childCount() == 0:
                self.takeTopLevelItem(self.indexOfTopLevelItem(old_parent))
                del self._paths[old_parent._path]
        else:
            self.takeTopLevelItem(self.indexOfTopLevelItem(i))
        new_parent.addChild(i)
        new_parent.sortChildren(0, Qt.AscendingOrder)
    
    def document(self, item):
        """Returns the document for item."""
        for d, i in self._items.items():
            if i == item:
                return d
        
    def slotItemSelectionChanged(self):
        if len(self.selectedItems()) == 1:
            doc = self.document(self.selectedItems()[0])
            if doc:
                self.parentWidget().mainwindow().setCurrentDocument(doc)
    
    def contextMenuEvent(self, ev):
        item = self.itemAt(ev.pos())
        if not item:
            return
        
        mainwindow = self.parentWidget().mainwindow()
        
        selection = self.selectedItems()
        doc = self.document(item)
        
        if len(selection) <= 1 and doc:
            # a single document is right-clicked
            import documentcontextmenu
            menu = documentcontextmenu.DocumentContextMenu(mainwindow)
            menu.exec_(doc, ev.globalPos())
            menu.deleteLater()
            return
        
        menu = QMenu(mainwindow)
        save = menu.addAction(icons.get('document-save'), '')
        menu.addSeparator()
        close = menu.addAction(icons.get('document-close'), '')
        
        if len(selection) > 1:
            # multiple documents are selected
            save.setText(_("Save selected documents"))
            close.setText(_("Close selected documents"))
            documents = [self.document(item) for item in selection]
        else:
            documents = [self.document(item.child(i)) for i in range(item.childCount())]
            if item._path:
                # a directory item is right-clicked
                save.setText(_("Save documents in this folder"))
                close.setText(_("Close documents in this folder"))
            else:
                # the "Untitled" group is right-clicked
                save.setText(_("Save all untitled documents"))
                close.setText(_("Close all untitled documents"))
        
        @save.triggered.connect
        def savedocuments():
            for d in documents:
                if d.url().isEmpty() or d.isModified():
                    mainwindow.setCurrentDocument(d)
                if not mainwindow.saveDocument(d):
                    break
        
        @close.triggered.connect
        def close_documents():
            for d in documents:
                if not mainwindow.closeDocument(d):
                    break
        
        menu.exec_(ev.globalPos())
        menu.deleteLater()



########NEW FILE########
__FILENAME__ = document
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A Frescobaldi (LilyPond) document.
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import QUrl
from PyQt4.QtGui import QPlainTextDocumentLayout, QTextCursor, QTextDocument

import app
import util
import variables
import signals


class Document(QTextDocument):
    
    urlChanged = signals.Signal() # new url, old url
    closed = signals.Signal()
    loaded = signals.Signal()
    saved = signals.Signal()
    
    def __init__(self, url=None, encoding=None):
        super(Document, self).__init__()
        self.setDocumentLayout(QPlainTextDocumentLayout(self))
        self._encoding = encoding
        if url is None:
            url = QUrl()
        self._url = url # avoid urlChanged on init
        self.setUrl(url)
        self.modificationChanged.connect(self.slotModificationChanged)
        app.documents.append(self)
        app.documentCreated(self)
        self.load()
        
    def slotModificationChanged(self):
        app.documentModificationChanged(self)

    def close(self):
        self.closed()
        app.documentClosed(self)
        app.documents.remove(self)

    def load(self, keepUndo=False):
        """Loads the current url.
        
        Returns True if loading succeeded, False if an error occurred,
        and None when the current url is empty or non-local.
        Currently only local files are supported.
        
        If keepUndo is True, the loading can be undone (with Ctrl-Z).
        
        """
        fileName = self.url().toLocalFile()
        if fileName:
            try:
                with open(fileName) as f:
                    data = f.read()
            except (IOError, OSError):
                return False # errors are caught in MainWindow.openUrl()
            text = util.decode(data)
            if keepUndo:
                c = QTextCursor(self)
                c.select(QTextCursor.Document)
                c.insertText(text)
            else:
                self.setPlainText(text)
            self.setModified(False)
            self.loaded()
            app.documentLoaded(self)
            return True
            
    def save(self):
        """Saves the document to the current url.
        
        Returns True if saving succeeded, False if an error occurred,
        and None when the current url is empty or non-local.
        Currently only local files are supported.
        
        """
        with app.documentSaving(self):
            fileName = self.url().toLocalFile()
            if fileName:
                try:
                    with open(fileName, "w") as f:
                        f.write(self.encodedText())
                        f.flush()
                        os.fsync(f.fileno())
                except (IOError, OSError):
                    return False
                self.setModified(False)
                self.saved()
                app.documentSaved(self)
                return True

    def url(self):
        return self._url
        
    def setUrl(self, url):
        """ Change the url for this document. """
        if url is None:
            url = QUrl()
        old, self._url = self._url, url
        changed = old != url
        # number for nameless documents
        if self._url.isEmpty():
            nums = [0]
            nums.extend(doc._num for doc in app.documents if doc is not self)
            self._num = max(nums) + 1
        else:
            self._num = 0
        if changed:
            self.urlChanged(url, old)
            app.documentUrlChanged(self, url, old)
    
    def encoding(self):
        return variables.get(self, "coding") or self._encoding
        
    def setEncoding(self, encoding):
        self._encoding = encoding
    
    def encodedText(self):
        """Returns the text of the document encoded in the correct encoding.
        
        Useful to save to a file.
        
        """
        try:
            return self.toPlainText().encode(self.encoding() or 'utf-8')
        except (UnicodeError, LookupError):
            return self.toPlainText().encode('utf-8')
        
    def documentName(self):
        """ Returns a suitable name for this document. """
        if self._url.isEmpty():
            if self._num == 1:
                return _("Untitled")
            else:
                return _("Untitled ({num})").format(num=self._num)
        else:
            return os.path.basename(self._url.path())



########NEW FILE########
__FILENAME__ = documentactions
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages some actions and per-document preferences that are set in metainfo.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import Qt
from PyQt4.QtGui import QAction, QKeySequence

import actioncollection
import actioncollectionmanager
import highlighter
import metainfo
import plugin
import icons


def get(mainwindow):
    """Returns the DocumentActions instance for the specified MainWindow."""
    return DocumentActions.instance(mainwindow)


class DocumentActions(plugin.MainWindowPlugin):
    def __init__(self, mainwindow):
        ac = self.actionCollection = Actions()
        actioncollectionmanager.manager(mainwindow).addActionCollection(ac)
        ac.view_goto_file_or_definition.triggered.connect(self.gotoFileOrDefinition)
        ac.edit_cut_assign.triggered.connect(self.cutAssign)
        ac.view_highlighting.triggered.connect(self.toggleHighlighting)
        ac.tools_indent_auto.triggered.connect(self.toggleAuto_indent)
        ac.tools_indent_indent.triggered.connect(self.re_indent)
        ac.tools_reformat.triggered.connect(self.reFormat)
        ac.tools_remove_trailing_whitespace.triggered.connect(self.removeTrailingWhitespace)
        ac.tools_convert_ly.triggered.connect(self.convertLy)
        ac.tools_quick_remove_articulations.triggered.connect(self.quickRemoveArticulations)
        ac.tools_quick_remove_ornaments.triggered.connect(self.quickRemoveOrnaments)
        ac.tools_quick_remove_instrument_scripts.triggered.connect(self.quickRemoveInstrumentScripts)
        ac.tools_quick_remove_slurs.triggered.connect(self.quickRemoveSlurs)
        ac.tools_quick_remove_dynamics.triggered.connect(self.quickRemoveDynamics)
        ac.tools_quick_remove_markup.triggered.connect(self.quickRemoveMarkup)
        
        mainwindow.currentDocumentChanged.connect(self.updateDocActions)
        mainwindow.selectionStateChanged.connect(self.updateSelectionActions)
        
    def updateDocActions(self, doc):
        minfo = metainfo.info(doc)
        if minfo.highlighting:
            highlighter.highlighter(doc)
        ac = self.actionCollection
        ac.view_highlighting.setChecked(minfo.highlighting)
        ac.tools_indent_auto.setChecked(minfo.auto_indent)
    
    def updateSelectionActions(self, selection):
        self.actionCollection.edit_cut_assign.setEnabled(selection)
        self.actionCollection.tools_quick_remove_articulations.setEnabled(selection)
        self.actionCollection.tools_quick_remove_ornaments.setEnabled(selection)
        self.actionCollection.tools_quick_remove_instrument_scripts.setEnabled(selection)
        self.actionCollection.tools_quick_remove_slurs.setEnabled(selection)
        self.actionCollection.tools_quick_remove_dynamics.setEnabled(selection)
        self.actionCollection.tools_quick_remove_markup.setEnabled(selection)
    
    def currentView(self):
        return self.mainwindow().currentView()
    
    def currentDocument(self):
        return self.mainwindow().currentDocument()
        
    def updateOtherDocActions(self):
        """Calls updateDocActions() in other instances that show same document."""
        doc = self.currentDocument()
        for i in self.instances():
            if i is not self and i.currentDocument() == doc:
                i.updateDocActions(doc)
    
    def gotoFileOrDefinition(self):
        import open_file_at_cursor
        result = open_file_at_cursor.open_file_at_cursor(self.mainwindow())
        if not result:
            import definition
            definition.goto_definition(self.mainwindow())
    
    def cutAssign(self):
        import cut_assign
        cut_assign.cut_assign(self.currentView().textCursor())
        
    def toggleAuto_indent(self):
        minfo = metainfo.info(self.currentDocument())
        minfo.auto_indent = not minfo.auto_indent
        self.updateOtherDocActions()
    
    def re_indent(self):
        import indent
        indent.re_indent(self.currentView().textCursor())
    
    def reFormat(self):
        import reformat
        reformat.reformat(self.currentView().textCursor())
    
    def removeTrailingWhitespace(self):
        import reformat
        reformat.remove_trailing_whitespace(self.currentView().textCursor())
    
    def toggleHighlighting(self):
        doc = self.currentDocument()
        minfo = metainfo.info(doc)
        minfo.highlighting = not minfo.highlighting
        highlighter.highlighter(doc).setHighlighting(minfo.highlighting)
        self.updateOtherDocActions()
    
    def convertLy(self):
        import convert_ly
        convert_ly.convert(self.mainwindow())
    
    def quickRemoveArticulations(self):
        import quickremove
        quickremove.articulations(self.mainwindow().textCursor())
    
    def quickRemoveOrnaments(self):
        import quickremove
        quickremove.ornaments(self.mainwindow().textCursor())
    
    def quickRemoveInstrumentScripts(self):
        import quickremove
        quickremove.instrument_scripts(self.mainwindow().textCursor())
    
    def quickRemoveSlurs(self):
        import quickremove
        quickremove.slurs(self.mainwindow().textCursor())
    
    def quickRemoveDynamics(self):
        import quickremove
        quickremove.dynamics(self.mainwindow().textCursor())
    
    def quickRemoveMarkup(self):
        import quickremove
        quickremove.markup(self.mainwindow().textCursor())


class Actions(actioncollection.ActionCollection):
    name = "documentactions"
    def createActions(self, parent):
        self.edit_cut_assign = QAction(parent)
        self.view_highlighting = QAction(parent)
        self.view_highlighting.setCheckable(True)
        self.view_goto_file_or_definition = QAction(parent)
        self.tools_indent_auto = QAction(parent)
        self.tools_indent_auto.setCheckable(True)
        self.tools_indent_indent = QAction(parent)
        self.tools_reformat = QAction(parent)
        self.tools_remove_trailing_whitespace = QAction(parent)
        self.tools_convert_ly = QAction(parent)
        self.tools_quick_remove_articulations = QAction(parent)
        self.tools_quick_remove_ornaments = QAction(parent)
        self.tools_quick_remove_instrument_scripts = QAction(parent)
        self.tools_quick_remove_slurs = QAction(parent)
        self.tools_quick_remove_dynamics = QAction(parent)
        self.tools_quick_remove_markup = QAction(parent)
        
        self.edit_cut_assign.setIcon(icons.get('edit-cut'))

        self.view_goto_file_or_definition.setShortcut(QKeySequence(Qt.ALT + Qt.Key_Return))
        self.edit_cut_assign.setShortcut(QKeySequence(Qt.SHIFT + Qt.CTRL + Qt.Key_X))
    
    def translateUI(self):
        self.edit_cut_assign.setText(_("Cut and Assign..."))
        self.view_highlighting.setText(_("Syntax &Highlighting"))
        self.view_goto_file_or_definition.setText(_("View File or Definition at &Cursor"))
        self.tools_indent_auto.setText(_("&Automatic Indent"))
        self.tools_indent_indent.setText(_("Re-&Indent"))
        self.tools_reformat.setText(_("&Format"))
        self.tools_remove_trailing_whitespace.setText(_("Remove Trailing &Whitespace"))
        self.tools_convert_ly.setText(_("&Update with convert-ly...")) 
        self.tools_quick_remove_articulations.setText(_("Remove &Articulations"))
        self.tools_quick_remove_ornaments.setText(_("Remove &Ornaments"))
        self.tools_quick_remove_instrument_scripts.setText(_("Remove &Instrument Scripts"))
        self.tools_quick_remove_slurs.setText(_("Remove &Slurs"))
        self.tools_quick_remove_dynamics.setText(_("Remove &Dynamics"))
        self.tools_quick_remove_markup.setText(_("Remove Text &Markup (from music)"))


########NEW FILE########
__FILENAME__ = documentcontextmenu
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A context menu with actions for a Document.
Used by the tabbar and the doclist tool.
"""

from __future__ import unicode_literals

import weakref

from PyQt4.QtGui import QMenu

import app
import icons


class DocumentContextMenu(QMenu):
    def __init__(self, mainwindow):
        super(DocumentContextMenu, self).__init__(mainwindow)
        self._doc = lambda: None
        
        self.createActions()
        app.translateUI(self)
        self.aboutToShow.connect(self.updateActions)
    
    def createActions(self):
        self.doc_save = self.addAction(icons.get('document-save'), '')
        self.doc_save_as = self.addAction(icons.get('document-save-as'), '')
        self.addSeparator()
        self.doc_close = self.addAction(icons.get('document-close'), '')
        self.doc_close_others = self.addAction(icons.get('document-close'), '')
        self.addSeparator()
        self.doc_toggle_sticky = self.addAction(icons.get('pushpin'), '')
        self.doc_toggle_sticky.setCheckable(True)
        
        self.doc_save.triggered.connect(self.docSave)
        self.doc_save_as.triggered.connect(self.docSaveAs)
        self.doc_close.triggered.connect(self.docClose)
        self.doc_close_others.triggered.connect(self.docCloseOther)
        self.doc_toggle_sticky.triggered.connect(self.docToggleSticky)
    
    def updateActions(self):
        """Called just before show."""
        doc = self._doc()
        if doc:
            import engrave
            engraver = engrave.Engraver.instance(self.mainwindow())
            self.doc_toggle_sticky.setChecked(doc is engraver.stickyDocument())
    
    def translateUI(self):
        self.doc_save.setText(_("&Save"))
        self.doc_save_as.setText(_("Save &As..."))
        self.doc_close.setText(_("&Close"))
        self.doc_close_others.setText(_("Close Other Documents"))
        self.doc_toggle_sticky.setText(_("Always &Engrave This Document"))
    
    def mainwindow(self):
        return self.parentWidget()
        
    def exec_(self, document, pos):
        self._doc = weakref.ref(document)
        super(DocumentContextMenu, self).exec_(pos)
    
    def docSave(self):
        doc = self._doc()
        if doc:
            self.mainwindow().saveDocument(doc)
    
    def docSaveAs(self):
        doc = self._doc()
        if doc:
            self.mainwindow().saveDocumentAs(doc)
    
    def docClose(self):
        doc = self._doc()
        if doc:
            self.mainwindow().closeDocument(doc)

    def docCloseOther(self):
        """ Closes all documents that are not our current document. """
        cur = self._doc()
        if not cur:
            return # not clear which to keep open...
        win = self.mainwindow()
        win.setCurrentDocument(cur, findOpenView=True)
        win.closeOtherDocuments()

    def docToggleSticky(self):
        doc = self._doc()
        if doc:
            import engrave
            engraver = engrave.Engraver.instance(self.mainwindow())
            if doc is engraver.stickyDocument():
                engraver.setStickyDocument(None)
            else:
                engraver.setStickyDocument(doc)



########NEW FILE########
__FILENAME__ = documentinfo
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Delivers information about a document.
"""

from __future__ import unicode_literals

import itertools
import functools
import os
import re
import weakref

from PyQt4.QtCore import QSettings, QUrl

import ly.lex
import lydocinfo
import lydocument
import app
import fileinfo
import cursortools
import tokeniter
import plugin
import variables


__all__ = ['docinfo', 'info', 'mode']


def info(document):
    """Returns a DocumentInfo instance for the given Document."""
    return DocumentInfo.instance(document)


def docinfo(document):
    """Return a LyDocInfo instance for the document."""
    return info(document).lydocinfo()


def music(document):
    """Return a music.Document instance for the document."""
    return info(document).music()


def mode(document, guess=True):
    """Returns the type of the given document. See DocumentInfo.mode()."""
    return info(document).mode(guess)

    
class DocumentInfo(plugin.DocumentPlugin):
    """Computes and caches various information about a Document."""
    def __init__(self, document):
        document.contentsChanged.connect(self._reset)
        document.closed.connect(self._reset)
        self._reset()
        
    def _reset(self):
        """Called when the document is changed."""
        self._lydocinfo = None
        self._music = None
    
    def lydocinfo(self):
        """Return the lydocinfo instance for our document."""
        if self._lydocinfo is None:
            doc = lydocument.Document(self.document())
            v = variables.manager(self.document()).variables()
            self._lydocinfo = lydocinfo.DocInfo(doc, v)
        return self._lydocinfo
    
    def music(self):
        """Return the music.Document instance for our document."""
        if self._music is None:
            import music
            doc = lydocument.Document(self.document())
            self._music = music.Document(doc)
        self._music.include_path = self.includepath()
        return self._music
    
    def mode(self, guess=True):
        """Returns the type of document ('lilypond, 'html', etc.).
        
        The mode can be set using the "mode" document variable.
        If guess is True (default), the mode is auto-recognized based on the contents
        if not set explicitly using the "mode" variable. In this case, this function
        always returns an existing mode.
        
        If guess is False, auto-recognizing is not done and the function returns None
        if the mode wasn't set explicitly.
        
        """
        mode = variables.get(self.document(), "mode")
        if mode in ly.lex.modes:
            return mode
        if guess:
            return self.lydocinfo().mode()
    
    def includepath(self):
        """Returns the configured include path. Currently the document does not matter."""
        try:
            include_path = QSettings().value("lilypond_settings/include_path", [], type(""))
        except TypeError:
            include_path = []
        return include_path
        
    def jobinfo(self, create=False):
        """Returns a two-tuple(filename, includepath).
        
        The filename is the file LilyPond shall be run on. This can be the 
        original filename of the document (if it has a filename and is not 
        modified), but also the filename of a temporarily saved copy of the 
        document.
        
        The includepath is the same as self.includepath(), but with the 
        directory of the original file prepended, only if a temporary 
        'scratchdir'-area is used and the document does include other files 
        (and therefore the original folder should be given in the include 
        path to LilyPond).
        
        """
        includepath = self.includepath()
        filename = self.document().url().toLocalFile()
        
        # Determine the filename to run the engraving job on
        if not filename or self.document().isModified():
            # We need to use a scratchdir to save our contents to
            import scratchdir
            scratch = scratchdir.scratchdir(self.document())
            if create:
                scratch.saveDocument()
            if filename and self.lydocinfo().include_args():
                includepath.insert(0, os.path.dirname(filename))
            if create or (scratch.path() and os.path.exists(scratch.path())):
                filename = scratch.path()
        return filename, includepath
    
    def includefiles(self):
        """Returns a set of filenames that are included by this document.
        
        The document's own filename is not added to the set.
        The configured include path is used to find files.
        Included files are checked recursively, relative to our file,
        relative to the including file, and if that still yields no file, relative
        to the directories in the includepath().
        
        This method uses caching for both the document contents and the other files.
        
        """
        return fileinfo.includefiles(self.lydocinfo(), self.includepath())

    def child_urls(self):
        """Return a tuple of urls included by the Document.
        
        This only returns urls that are referenced directly, not searching
        via an include path. If the Document has no url set, an empty tuple
        is returned. 
        
        """
        url = self.document().url()
        if url.isEmpty():
            return ()
        return tuple(url.resolved(QUrl(arg)) for arg in self.lydocinfo().include_args())
        
    def basenames(self):
        """Returns a list of basenames that our document is expected to create.
        
        The list is created based on include files and the define output-suffix and
        \bookOutputName and \bookOutputSuffix commands.
        You should add '.ext' and/or '-[0-9]+.ext' to find created files.
        
        """
        # if the file defines an 'output' variable, it is used instead
        output = variables.get(self.document(), 'output')
        filename = self.jobinfo()[0]
        if output:
            dirname = os.path.dirname(filename)
            return [os.path.join(dirname, name.strip())
                    for name in output.split(',')]
        
        mode = self.mode()
        
        if mode == "lilypond":
            return fileinfo.basenames(self.lydocinfo(), self.includefiles(), filename)
        
        elif mode == "html":
            pass
        
        elif mode == "texinfo":
            pass
        
        elif mode == "latex":
            pass
        
        elif mode == "docbook":
            pass
        
        return []



########NEW FILE########
__FILENAME__ = documentmenu
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Documents menu.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QAction, QActionGroup, QIcon, QMenu

import app
import icons
import plugin
import engrave
import jobmanager


class DocumentMenu(QMenu):
    def __init__(self, mainwindow):
        super(DocumentMenu, self).__init__(mainwindow)
        self.aboutToShow.connect(self.populate)
        app.translateUI(self)
    
    def translateUI(self):
        self.setTitle(_('menu title', '&Documents'))
    
    def populate(self):
        self.clear()
        mainwindow = self.parentWidget()
        for a in DocumentActionGroup.instance(mainwindow).actions():
            self.addAction(a)
            

class DocumentActionGroup(QActionGroup, plugin.MainWindowPlugin):
    """Maintains a list of actions to set the current document.
    
    The actions are added to the View->Documents menu in the order
    of the tabbar. The actions also get accelerators that are kept
    during the lifetime of a document.
    
    """
    def __init__(self, mainwindow):
        super(DocumentActionGroup, self).__init__(mainwindow)
        self._acts = {}
        self._accels = {}
        self.setExclusive(True)
        for d in app.documents:
            self.addDocument(d)
        app.documentCreated.connect(self.addDocument)
        app.documentClosed.connect(self.removeDocument)
        app.documentUrlChanged.connect(self.setDocumentStatus)
        app.documentModificationChanged.connect(self.setDocumentStatus)
        app.jobStarted.connect(self.setDocumentStatus)
        app.jobFinished.connect(self.setDocumentStatus)
        mainwindow.currentDocumentChanged.connect(self.setCurrentDocument)
        engrave.engraver(mainwindow).stickyChanged.connect(self.setDocumentStatus)
        self.triggered.connect(self.slotTriggered)
    
    def actions(self):
        return [self._acts[doc] for doc in self.mainwindow().documents()]

    def addDocument(self, doc):
        a = QAction(self)
        a.setCheckable(True)
        if doc is self.mainwindow().currentDocument():
            a.setChecked(True)
        self._acts[doc] = a
        self.setDocumentStatus(doc)
        
    def removeDocument(self, doc):
        self._acts[doc].deleteLater()
        del self._acts[doc]
        del self._accels[doc]
        
    def setCurrentDocument(self, doc):
        self._acts[doc].setChecked(True)

    def setDocumentStatus(self, doc):
        # create accels
        accels = [self._accels[d] for d in self._accels if d is not doc]
        name = doc.documentName().replace('&', '&&')
        for index, char in enumerate(name):
            if char.isalnum() and char.lower() not in accels:
                name = name[:index] + '&' + name[index:]
                self._accels[doc] = char.lower()
                break
        else:
            self._accels[doc] = ''
        # add [sticky] mark if necessary
        if doc == engrave.engraver(self.mainwindow()).stickyDocument():
            # L10N: 'always engraved': the document is marked as 'Always Engrave' in the LilyPond menu
            name += " " + _("[always engraved]")
        self._acts[doc].setText(name)
        # set the icon
        if jobmanager.isRunning(doc):
            icon = icons.get('lilypond-run')
        elif doc.isModified():
            icon = icons.get('document-save')
        else:
            icon = QIcon()
        self._acts[doc].setIcon(icon)
    
    def slotTriggered(self, action):
        self.mainwindow().setCurrentDocument(self._acts.keys()[self._acts.values().index(action)])



########NEW FILE########
__FILENAME__ = documentstructure
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Maintains an overview of the structure of a Document.
"""

from __future__ import unicode_literals

import re

from PyQt4.QtCore import QSettings

import app
import plugin


default_outline_patterns = [
r"(?P<title>\\(score|book|bookpart))\b",
r"^\\(paper|layout|header)\b",
r"\\(new|context)\s+[A-Z]\w+",
r"(?P<title>BEGIN[^\n]*)[ \t]*$",
r"^[a-zA-Z]+\s*=",
r"^<<",
r"^\{",
r"^\\relative([ \t]+\w+[',]*)?",
r"\b(?P<alert>(FIXME|HACK|XXX+)\b\W*\w+)",
]


# cache the outline regexp
_outline_re = None


def outline_re():
    """Return the expression to look for document outline items."""
    global _outline_re
    if _outline_re is None:
        _outline_re = create_outline_re()
    return _outline_re


def _reset_outline_re():
    global _outline_re
    _outline_re = None


app.settingsChanged.connect(_reset_outline_re, -999)


def create_outline_re():
    """Create and return the expression to look for document outline items."""
    try:
        rx = QSettings().value("documentstructure/outline_patterns",
                               default_outline_patterns, type(""))
    except TypeError:
        rx = []
    # suffix duplicate named groups with a number
    groups = {}
    new_rx = []
    for e in rx:
        try:
            c = re.compile(e)
        except re.error:
            continue
        if c.groupindex:
            for name in c.groupindex:
                if name in groups:
                    groups[name] += 1
                    new_name = name + format(groups[name])
                    e = e.replace("(?P<{0}>".format(name), "(?P<{0}>".format(new_name))
                else:
                    groups[name] = 0
        new_rx.append(e)
    rx = '|'.join(new_rx)
    return re.compile(rx, re.MULTILINE | re.UNICODE)


class DocumentStructure(plugin.DocumentPlugin):
    def __init__(self, document):
        self._outline = None
    
    def invalidate(self):
        """Called when the document changes or the settings are changed."""
        self._outline = None
        app.settingsChanged.disconnect(self.invalidate)
        self.document().contentsChanged.disconnect(self.invalidate)
    
    def outline(self):
        """Return the document outline as a series of match objects."""
        if self._outline is None:
            self._outline = list(outline_re().finditer(self.document().toPlainText()))
            self.document().contentsChanged.connect(self.invalidate)
            app.settingsChanged.connect(self.invalidate, -999)
        return self._outline




########NEW FILE########
__FILENAME__ = documenttooltip
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Display a tooltip showing part of a Document.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSize
from PyQt4.QtGui import (
    QFont, QLabel, QPainter, QPixmap, QTextCursor, QTextDocument)

import metainfo
import tokeniter
import highlighter
import textformats
import widgets.customtooltip


def show(cursor, pos=None, num_lines=6):
    """Displays a tooltip showing part of the cursor's Document.
    
    If the cursor has a selection, those blocks are displayed.
    Otherwise, num_lines lines are displayed.
    
    If pos is not given, the global mouse position is used.
    
    """
    block = cursor.document().findBlock(cursor.selectionStart())
    c2 = QTextCursor(block)
    if cursor.hasSelection():
        c2.setPosition(cursor.selectionEnd(), QTextCursor.KeepAnchor)
        c2.movePosition(QTextCursor.EndOfBlock, QTextCursor.KeepAnchor)
    else:
        c2.movePosition(QTextCursor.NextBlock, QTextCursor.KeepAnchor, num_lines)
    
    data = textformats.formatData('editor')
    
    doc = QTextDocument()
    font = QFont(data.font)
    font.setPointSizeF(font.pointSizeF() * .8)
    doc.setDefaultFont(font)
    doc.setPlainText(c2.selection().toPlainText())
    if metainfo.info(cursor.document()).highlighting:
        highlighter.highlight(doc, state=tokeniter.state(block))
    size = doc.size().toSize() + QSize(8, -4)
    pix = QPixmap(size)
    pix.fill(data.baseColors['background'])
    doc.drawContents(QPainter(pix))
    label = QLabel()
    label.setPixmap(pix)
    label.setStyleSheet("QLabel { border: 1px solid #777; }")
    label.resize(size)
    widgets.customtooltip.show(label, pos)



########NEW FILE########
__FILENAME__ = documenttree
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Group all Document instances in a tree structure.

Documents that are included by other Documents are considered a child of that
Document instance.

If a Document is included by multiple documents, it shows up as a child of one
of them. If a Document includes other files that exist on disk but are not open
yet, they can also show up.

"""

from __future__ import unicode_literals

import os

import node
import app
import documentinfo


class DocumentNode(node.Node):
    document = None
    url = None


def tree(urls=False):
    """Return the open documents as a tree structure.
    
    Returned is a node.Node instance having the toplevel documents (documents
    that are not included by other open documents) as children. The children of
    the nodes are the documents that are included by the toplevel document.
    
    Every node has the Document in its document attribute.
    
    If urls == True, nodes will also be generated for urls that refer to
    documents that are not yet open. They will have the QUrl in their url
    attribute.
    
    It is not checked whether the referred to urls or files actually exist.
    
    """
    root = node.Node()
    nodes = {}
    for doc in app.documents:
        try:
            n = nodes[doc]
        except KeyError:
            n = nodes[doc] = DocumentNode(root)
            n.document = doc
        for u in documentinfo.info(doc).child_urls():
            d = app.findDocument(u)
            if d:
                try:
                    n.append(nodes[d])
                except KeyError:
                    n1 = nodes[d] = DocumentNode(n)
                    n1.document = d
            elif urls:
                try:
                    n.append(nodes[u.toString()])
                except KeyError:
                    n1 = nodes[u.toString()] = DocumentNode(n)
                    n1.url = u
    return root



########NEW FILE########
__FILENAME__ = documentwatcher
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
This module checks if documents are changed on disk.

The documentChangedOnDisk(Document) signal is emitted once when a document is
changed on the disk.  The 'changed' attribute of the Document's DocumentWatcher
instance is set to True.  Saving or reloading a Document sets the 'changed'
flag back to False.

Use start() to start the document watcher, and stop() to stop it if desired.

"""

from __future__ import unicode_literals

import contextlib
import os

from PyQt4.QtCore import QFileSystemWatcher, QUrl

import app
import plugin
import signals


__all__ = ['documentChangedOnDisk', 'DocumentWatcher', 'start', 'stop']


documentChangedOnDisk = signals.Signal() # Document


# one global QFileSystemWatcher instance
watcher = None


class DocumentWatcher(plugin.DocumentPlugin):
    """Maintains if a change was detected for a document."""
    def __init__(self, d):
        self.changed = False
    
    def isdeleted(self):
        """Return True if some change has occured, the document has a local
        filename, but the file is not existing on disk.
        
        """
        if self.changed:
            filename = self.document().url().toLocalFile()
            if filename:
                return not os.path.isfile(filename)
        return False


def addUrl(url):
    """Add a url (QUrl) to the filesystem watcher."""
    filename = url.toLocalFile()
    if filename and filename not in watcher.files():
        watcher.addPath(filename)


def removeUrl(url):
    """Remove a url (QUrl) from the filesystem watcher."""
    filename = url.toLocalFile()
    if filename:
        watcher.removePath(filename)

    
def unchange(document):
    """Mark document as not changed (anymore)."""
    DocumentWatcher.instance(document).changed = False


def documentUrlChanged(document, url, old):
    """Called whenever the URL of an existing Document changes."""
    for d in app.documents:
        if d.url() == old:
            break
    else:
        removeUrl(old)
    addUrl(url)

            
def documentClosed(document):
    """Called whenever a document closes."""
    for d in app.documents:
        if d is not document and d.url() == document.url():
            return
    removeUrl(document.url())


def documentLoaded(document):
    """Called whenever a document loads."""
    addUrl(document.url())


@contextlib.contextmanager
def whileSaving(document):
    """Temporarily suppress the watching of the document during a code block."""
    try:
        removeUrl(document.url())
        yield
    finally:
        addUrl(document.url())

    
def fileChanged(filename):
    """Called whenever the global filesystem watcher detects a change."""
    url = QUrl.fromLocalFile(filename)
    doc = app.findDocument(url)
    if doc:
        w = DocumentWatcher.instance(doc)
        if not w.changed:
            w.changed = True
            documentChangedOnDisk(doc)


def start():
    """Start the document watcher."""
    global watcher
    if watcher is None:
        watcher = QFileSystemWatcher()
        app.documentLoaded.connect(documentLoaded)
        app.documentUrlChanged.connect(documentUrlChanged)
        app.documentClosed.connect(documentClosed)
        app.documentSaving.connect(whileSaving)
        watcher.fileChanged.connect(fileChanged)
        for d in app.documents:
            documentLoaded(d)


def stop():
    """Stop the document watcher."""
    global watcher
    if watcher is not None:
        watcher.fileChanged.disconnect(fileChanged)
        watcher.removePaths(watcher.files())
        app.documentLoaded.disconnect(documentLoaded)
        app.documentUrlChanged.disconnect(documentUrlChanged)
        app.documentClosed.disconnect(documentClosed)
        app.documentSaving.disconnect(whileSaving)
        watcher.deleteLater()
        watcher = None


# always-on connections
app.documentLoaded.connect(unchange)
app.documentSaved.connect(unchange)
app.documentUrlChanged.connect(unchange)

########NEW FILE########
__FILENAME__ = autocompile
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Continuous Auto-compile the sticky or master document.

This is a (mainwindow) global action that can be enabled.

It runs LilyPond in preview mode, always using a temporary file.
When a document is modified after the last run, LilyPond is run again after
a certain time, if the document looks complete
(documentinfo.docinfo(doc).complete()).

The log is not displayed.

"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSettings, QTimer

import app
import documentinfo
import resultfiles
import jobattributes
import jobmanager
import plugin
import ly.lex

from . import engraver
from . import command


class AutoCompiler(plugin.MainWindowPlugin):
    def __init__(self, mainwindow):
        self._enabled = False
        self._timer = QTimer(singleShot=True)
        self._timer.timeout.connect(self.slotTimeout)
    
    def setEnabled(self, enabled):
        """Switch the autocompiler on or off."""
        enabled = bool(enabled)
        if enabled == self._enabled:
            return
        self._enabled = enabled

        doc = self.mainwindow().currentDocument()
        if enabled:
            self.mainwindow().currentDocumentChanged.connect(self.slotDocumentChanged)
            app.documentUrlChanged.connect(self.startTimer)
            if doc:
                self.slotDocumentChanged(doc, None)
        else:
            self.mainwindow().currentDocumentChanged.disconnect(self.slotDocumentChanged)
            app.documentUrlChanged.disconnect(self.startTimer)
            if doc:
                self.slotDocumentChanged(None, doc)
    
    def slotDocumentChanged(self, new=None, old=None):
        """Called when the mainwindow changes the current document."""
        if old:
            old.contentsChanged.disconnect(self.startTimer)
            old.loaded.disconnect(self.startTimer)
        if new:
            new.contentsChanged.connect(self.startTimer)
            new.loaded.connect(self.startTimer)
            if self._enabled:
                self.startTimer()
    
    def startTimer(self):
        """Called to trigger a soon auto-compile try."""
        self._timer.start(750)
    
    def slotTimeout(self):
        """Called when the autocompile timer expires."""
        eng = engraver(self.mainwindow())
        doc = eng.document()
        rjob = jobmanager.job(doc)
        if rjob and rjob.isRunning() and not jobattributes.get(rjob).hidden:
            # a real job is running, come back when that is done
            rjob.done.connect(self.startTimer)
            return
        
        mgr = AutoCompileManager.instance(doc)
        may_compile = mgr.may_compile()
        if not may_compile:
            cur = self.mainwindow().currentDocument()
            if doc is not cur and not cur.isModified() and not cur.url().isEmpty():
                mgr = AutoCompileManager.instance(cur)
                may_compile = mgr.may_compile()
                if may_compile:
                    mgr.slotJobStarted()
        if may_compile:
            job = command.defaultJob(doc, ['-dpoint-and-click'])
            jobattributes.get(job).hidden = True
            eng.runJob(job, doc)


class AutoCompileManager(plugin.DocumentPlugin):
    def __init__(self, document):
        document.contentsChanged.connect(self.slotDocumentContentsChanged)
        document.saved.connect(self.slotDocumentSaved)
        if document.isModified():
            self._dirty = True
        else:
            # look for existing result files in the default output format
            s = QSettings()
            s.beginGroup("lilypond_settings")
            if s.value("default_output_target", "pdf", type("")) == "svg":
                ext = '.svg*'
            else:
                ext = '.pdf'
            self._dirty = not resultfiles.results(document).files(ext)
        self._hash = None if self._dirty else documentinfo.docinfo(document).token_hash()
        jobmanager.manager(document).started.connect(self.slotJobStarted)
    
    def may_compile(self):
        """Return True if we could need to compile the document."""
        if self._dirty:
            dinfo = documentinfo.docinfo(self.document())
            if (dinfo.mode() == "lilypond"
                and dinfo.complete()
                and documentinfo.music(self.document()).has_output()):
                h = dinfo.token_hash()
                if h != self._hash:
                    self._hash = h
                    if h != hash(tuple()):
                        return True
            self._dirty = False
    
    def slotDocumentContentsChanged(self):
        """Called when the user modifies the document."""
        self._dirty = True

    def slotDocumentSaved(self):
        """Called when the document is saved. Forces auto-compile once."""
        self._dirty = True
        self._hash = None
    
    def slotJobStarted(self):
        """Called when an engraving job is started on this document."""
        if self._dirty:
            self._dirty = False
            self._hash = documentinfo.docinfo(self.document()).token_hash()



########NEW FILE########
__FILENAME__ = command
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Creates the commandline or Job to engrave a music document.
"""

from __future__ import unicode_literals

import os, sys

from PyQt4.QtCore import QSettings

import job
import documentinfo
import lilypondinfo


def info(document):
    """Returns a LilyPondInfo instance that should be used by default to engrave the document."""
    version = documentinfo.docinfo(document).version()
    if version and QSettings().value("lilypond_settings/autoversion", False, bool):
        return lilypondinfo.suitable(version)
    return lilypondinfo.preferred()


def defaultJob(document, args=None):
    """Return a default job for the document.
    
    The 'args' argument, if given, must be a list of commandline arguments
    that are given to LilyPond, and may enable specific preview modes.
    
    If args is not given, the Job will cause LilyPond to run in Publish mode,
    with point and click turned off.
    
    """
    filename, includepath = documentinfo.info(document).jobinfo(True)
    
    i = info(document)
    j = job.Job()
    
    command = [i.abscommand() or i.command]
    s = QSettings()
    s.beginGroup("lilypond_settings")
    if s.value("delete_intermediate_files", True, bool):
        command.append('-ddelete-intermediate-files')
    else:
        command.append('-dno-delete-intermediate-files')
    
    if args:
        command.extend(args)
    else:
        command.append('-dno-point-and-click')
    
    if s.value("default_output_target", "pdf", type("")) == "svg":
        command.append('-dbackend=svg')
    else:
        command.append('--pdf')
        
    command.extend('-I' + path for path in includepath)
    j.directory = os.path.dirname(filename)
    command.append(filename)
    j.command = command
    if s.value("no_translation", False, bool):
        j.environment['LANG'] = 'C'
    j.setTitle("{0} {1} [{2}]".format(
        os.path.basename(i.command), i.versionString(), document.documentName()))
    return j

########NEW FILE########
__FILENAME__ = custom
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Custom engraving dialog.
"""

from __future__ import unicode_literals

import os
import collections

from PyQt4.QtCore import QSettings, QSize, Qt
from PyQt4.QtGui import (QCheckBox, QComboBox, QDialog, QDialogButtonBox,
    QGridLayout, QLabel, QSpinBox, QTextEdit)

import app
import documentinfo
import userguide
import icons
import job
import jobmanager
import panelmanager
import lilychooser
import listmodel
import widgets
import qutil
import util

from . import command


class Dialog(QDialog):
    def __init__(self, mainwindow):
        super(Dialog, self).__init__(mainwindow)
        self._document = None
        
        layout = QGridLayout()
        self.setLayout(layout)
        
        self.versionLabel = QLabel()
        self.lilyChooser = lilychooser.LilyChooser()
        
        self.outputLabel = QLabel()
        self.outputCombo = QComboBox()
        
        self.resolutionLabel = QLabel()
        self.resolutionCombo = QComboBox(editable=True)
        
        self.antialiasLabel = QLabel()
        self.antialiasSpin = QSpinBox(minimum=1, maximum=128, value=1)
        
        self.modeLabel = QLabel()
        self.modeCombo = QComboBox()
        
        self.englishCheck = QCheckBox()
        self.deleteCheck = QCheckBox()
        
        self.commandLineLabel = QLabel()
        self.commandLine = QTextEdit(acceptRichText=False)
        
        self.buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttons.button(QDialogButtonBox.Ok).setIcon(icons.get("lilypond-run"))
        userguide.addButton(self.buttons, "engrave_custom")
        
        self.resolutionCombo.addItems(['100', '200', '300', '600', '1200'])
        self.resolutionCombo.setCurrentIndex(2)
        
        self.modeCombo.addItems(['preview', 'publish', 'debug'])
        layout.addWidget(self.versionLabel, 0, 0)
        layout.addWidget(self.lilyChooser, 0, 1, 1, 3)
        layout.addWidget(self.outputLabel, 1, 0)
        layout.addWidget(self.outputCombo, 1, 1, 1, 3)
        layout.addWidget(self.resolutionLabel, 2, 0)
        layout.addWidget(self.resolutionCombo, 2, 1)
        layout.addWidget(self.antialiasLabel, 2, 2, Qt.AlignRight)
        layout.addWidget(self.antialiasSpin, 2, 3)
        layout.addWidget(self.modeLabel, 3, 0)
        layout.addWidget(self.modeCombo, 3, 1, 1, 3)
        layout.addWidget(self.englishCheck, 4, 0, 1, 4)
        layout.addWidget(self.deleteCheck, 5, 0, 1, 4)
        layout.addWidget(self.commandLineLabel, 6, 0, 1, 4)
        layout.addWidget(self.commandLine, 7, 0, 1, 4)
        layout.addWidget(widgets.Separator(), 8, 0, 1, 4)
        layout.addWidget(self.buttons, 9, 0, 1, 4)
        
        app.translateUI(self)
        qutil.saveDialogSize(self, "engrave/custom/dialog/size", QSize(480, 260))
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        
        model = listmodel.ListModel(formats, display=lambda f: f.title(),
            icon=lambda f: icons.file_type(f.type))
        self.outputCombo.setModel(model)
        
        s = QSettings()
        s.beginGroup("lilypond_settings")
        self.englishCheck.setChecked(
            s.value("no_translation", False, bool))
        self.deleteCheck.setChecked(
            s.value("delete_intermediate_files", True, bool))
        
        if s.value("default_output_target", "pdf", type("")) == "svg":
            self.outputCombo.setCurrentIndex(3)
        
        app.jobFinished.connect(self.slotJobFinished)
        self.outputCombo.currentIndexChanged.connect(self.makeCommandLine)
        self.modeCombo.currentIndexChanged.connect(self.makeCommandLine)
        self.deleteCheck.toggled.connect(self.makeCommandLine)
        self.resolutionCombo.editTextChanged.connect(self.makeCommandLine)
        self.antialiasSpin.valueChanged.connect(self.makeCommandLine)
        self.makeCommandLine()
        panelmanager.manager(mainwindow).layoutcontrol.widget().optionsChanged.connect(self.makeCommandLine)
    
    def translateUI(self):
        self.setWindowTitle(app.caption(_("Engrave custom")))
        self.versionLabel.setText(_("LilyPond Version:"))
        self.outputLabel.setText(_("Output Format:"))
        self.resolutionLabel.setText(_("Resolution:"))
        self.antialiasLabel.setText(_("Antialias Factor:"))
        self.modeLabel.setText(_("Engraving mode:"))
        self.modeCombo.setItemText(0, _("Preview"))
        self.modeCombo.setItemText(1, _("Publish"))
        self.modeCombo.setItemText(2, _("Layout Control"))
        self.englishCheck.setText(_("Run LilyPond with English messages"))
        self.deleteCheck.setText(_("Delete intermediate output files"))
        self.commandLineLabel.setText(_("Command line:"))
        self.buttons.button(QDialogButtonBox.Ok).setText(_("Run LilyPond"))
        self.outputCombo.update()
    
    def slotJobFinished(self, doc):
        if doc == self._document:
            self.buttons.button(QDialogButtonBox.Ok).setEnabled(True)
            self._document = None
    
    def setDocument(self, doc):
        self.lilyChooser.setLilyPondInfo(command.info(doc))
        if jobmanager.isRunning(doc):
            self._document = doc
            self.buttons.button(QDialogButtonBox.Ok).setEnabled(False)
        
    def makeCommandLine(self):
        """Reads the widgets and builds a command line."""
        f = formats[self.outputCombo.currentIndex()]
        self.resolutionCombo.setEnabled('resolution' in f.widgets)
        self.antialiasSpin.setEnabled('antialias' in f.widgets)
        cmd = ["$lilypond"]
        
        if self.modeCombo.currentIndex() == 0:   # preview mode
            cmd.append('-dpoint-and-click')
        elif self.modeCombo.currentIndex() == 1: # publish mode
            cmd.append('-dno-point-and-click')
        else:                                    # debug mode
            args = panelmanager.manager(self.parent()).layoutcontrol.widget().preview_options()
            cmd.extend(args)
        
        if self.deleteCheck.isChecked():
            cmd.append('-ddelete-intermediate-files')
        else:
            cmd.append('-dno-delete-intermediate-files')
        d = {
            'version': self.lilyChooser.lilyPondInfo().version,
            'resolution': self.resolutionCombo.currentText(),
            'antialias': self.antialiasSpin.value(),
        }
        cmd.append("$include")
        cmd.extend(f.options(d))
        cmd.append("$filename")
        self.commandLine.setText(' '.join(cmd))
    
    def getJob(self, document):
        """Returns a Job to start."""
        filename, includepath = documentinfo.info(document).jobinfo(True)
        i = self.lilyChooser.lilyPondInfo()
        cmd = []
        for t in self.commandLine.toPlainText().split():
            if t == '$lilypond':
                cmd.append(i.abscommand() or i.command)
            elif t == '$filename':
                cmd.append(filename)
            elif t == '$include':
                cmd.extend('-I' + path for path in includepath)
            else:
                cmd.append(t)
        j = job.Job()
        j.directory = os.path.dirname(filename)
        j.command = cmd
        if self.englishCheck.isChecked():
            j.environment['LANG'] = 'C'
        j.setTitle("{0} {1} [{2}]".format(
            os.path.basename(i.command), i.versionString(), document.documentName()))
        return j


Format = collections.namedtuple("Format", "type title options widgets")

formats = [
    Format(
        "pdf",
        lambda: _("PDF"),
        lambda d: ['--pdf'],
        (),
    ),
    Format(
        "ps",
        lambda: _("PostScript"),
        lambda d: ['--ps'],
        (),
    ),
    Format(
        "png",
        lambda: _("PNG"),
        lambda d: [
            '--png',
            '-dresolution={resolution}'.format(**d),
            '-danti-alias-factor={antialias}'.format(**d),
        ],
        ('resolution', 'antialias'),
    ),
    Format(
        "svg",
        lambda: _("SVG"),
        lambda d: ['-dbackend=svg'],
        (),
    ),
    Format(
        "pdf",
        lambda: _("PDF (EPS Backend)"),
        lambda d: ['--pdf', '-dbackend=eps'],
        (),
    ),
    Format(
        "eps",
        lambda: _("Encapsulated PostScript (EPS Backend)"),
        lambda d: ['--ps', '-dbackend=eps'],
        (),
    ),
    Format(
        "png",
        lambda: _("PNG (EPS Backend)"),
        lambda d: [
            '--png',
            '-dbackend=eps',
            '-dresolution={resolution}'.format(**d),
            '-danti-alias-factor={antialias}'.format(**d),
        ],
        ('resolution', 'antialias'),
    ),
]



########NEW FILE########
__FILENAME__ = lytools
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Run LilyPond to get various types of output.
"""

from __future__ import unicode_literals

import codecs

from PyQt4.QtCore import QSize, Qt

import app
import job
import log
import qutil
import widgets.dialog


def show_available_fonts(mainwin, info):
    """Display a dialog with the available fonts of LilyPond specified by info."""
    dlg = Dialog(mainwin)
    dlg.setWindowTitle(app.caption("Available Fonts"))
    dlg.run_command(info, ['-dshow-available-fonts'], _("Available Fonts"))
    dlg.setMessage(_(
        "List of fonts detected by {version}").format(version=info.prettyName()))
    qutil.saveDialogSize(dlg, "engrave/tools/available-fonts/dialog/size", QSize(640, 400))
    dlg.show()
    

class Dialog(widgets.dialog.Dialog):
    """Dialog to run a certain LilyPond command and simply show the log."""
    def __init__(self, parent):
        super(Dialog, self).__init__(
            parent,
            buttons=('close',),
        )
        self.setWindowModality(Qt.NonModal)
        self.log = log.Log(self)
        self.setMainWidget(self.log)
        self.setAttribute(Qt.WA_DeleteOnClose)

    def run_command(self, info, args, title=None):
        """Run lilypond from info with the args list, and a job title."""
        j = self.job = job.Job()
        j.errors = 'replace'
        j.decoder_stdout = j.decoder_stderr = codecs.getdecoder('utf-8')
        j.command = [info.abscommand() or info.command] + list(args)
        if title:
            j.setTitle(title)
        self.log.connectJob(j)
        j.start()



########NEW FILE########
__FILENAME__ = result_menu
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Frescobaldi "Generated Files" menu.
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import QUrl
from PyQt4.QtGui import QMenu

import app
import icons
import util
import qutil


class Menu(QMenu):
    def __init__(self, mainwindow):
        super(Menu, self).__init__(mainwindow)
        self.aboutToShow.connect(self.populate)
        app.jobFinished.connect(self.slotJobFinished)
        self.triggered.connect(self.actionTriggered)
        app.translateUI(self)
    
    def translateUI(self):
        self.setTitle(_("Generated &Files"))
        
    def populate(self):
        self.clear()
        doc = self.parentWidget().currentDocument()
        if doc:
            import resultfiles
            files = resultfiles.results(doc).files()
            first = True
            for group in util.group_files(files,
                    ('pdf', 'mid midi', 'svg svgz', 'png', '!ly ily lyi')):
                if group:
                    if not first:
                        self.addSeparator()
                    first = False
                    for f in group:
                        name = os.path.split(f)[1]
                        a = self.addAction(name)
                        a.setIcon(icons.file_type(f))
                        a.filename = f
            if not self.actions():
                a = self.addAction(_("No files available"))
                a.setEnabled(False)
            else:
                qutil.addAccelerators(self.actions())
    
    def actionTriggered(self, action):
        import helpers
        helpers.openUrl(QUrl.fromLocalFile(action.filename))
    
    def slotJobFinished(self, doc):
        if self.isVisible() and doc == self.parentWidget().currentDocument():
            self.populate()



########NEW FILE########
__FILENAME__ = exception
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Exception dialog for unhandled Python exceptions
(which are bugs in our program).
"""

from __future__ import unicode_literals

import traceback

from PyQt4.QtGui import (
    QDialog, QDialogButtonBox, QLabel, QTextBrowser, QTextCursor, QVBoxLayout)

import app
import icons
import widgets
import bugreport


class ExceptionDialog(QDialog):
    """Single-use dialog displaying a Python exception."""
    def __init__(self, exctype, excvalue, exctb):
        super(ExceptionDialog, self).__init__()
        
        self._tbshort = ''.join(traceback.format_exception_only(exctype, excvalue))
        self._tbfull = ''.join(traceback.format_exception(exctype, excvalue, exctb))
 
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.errorLabel = QLabel()
        layout.addWidget(self.errorLabel)
        textview = QTextBrowser()
        layout.addWidget(textview)
        textview.setText(self._tbfull)
        textview.moveCursor(QTextCursor.End)
        
        layout.addWidget(widgets.Separator())
        
        b = self.buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        b.button(QDialogButtonBox.Ok).setIcon(icons.get("tools-report-bug"))
        layout.addWidget(b)
        
        b.accepted.connect(self.accept)
        b.rejected.connect(self.reject)
        self.resize(600,300)
        app.translateUI(self)
        self.exec_()

    def translateUI(self):
        self.errorLabel.setText(_("An internal error has occurred:"))
        self.setWindowTitle(app.caption(_("Internal Error")))
        self.buttons.button(QDialogButtonBox.Ok).setText(_("Email Bug Report..."))

    def done(self, result):
        if result:
           self.reportBug()
        super(ExceptionDialog, self).done(result)
        
    def reportBug(self):
        bugreport.email(self._tbshort, self._tbfull + '\n' + _("Optionally describe below what you were doing:"))



########NEW FILE########
__FILENAME__ = widget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The window displayed when a Document is modified by an external program.
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import qutil
import util
import icons
import htmldiff
import document
import widgets.dialog
import documentwatcher
import userguide

from . import enabled, setEnabled


def window():
    global _window
    try:
        return _window
    except NameError:
        _window = ChangedDocumentsListDialog()
    return _window


class ChangedDocumentsListDialog(widgets.dialog.Dialog):
    def __init__(self):
        super(ChangedDocumentsListDialog, self).__init__(buttons=('close',))
        self.setWindowModality(Qt.NonModal)
        self.setAttribute(Qt.WA_QuitOnClose, False)
        
        layout = QGridLayout(margin=0)
        self.mainWidget().setLayout(layout)
        self.tree = QTreeWidget(headerHidden=True, rootIsDecorated=False,
                                columnCount=2, itemsExpandable=False)
        self.tree.setSelectionMode(QTreeWidget.ExtendedSelection)
        
        self.buttonReload = QPushButton()
        self.buttonReloadAll = QPushButton()
        self.buttonSave = QPushButton()
        self.buttonSaveAll = QPushButton()
        self.buttonShowDiff = QPushButton()
        self.checkWatchingEnabled = QCheckBox(checked=enabled())
        
        layout.addWidget(self.tree, 0, 0, 6, 1)
        layout.addWidget(self.buttonReload, 0, 1)
        layout.addWidget(self.buttonReloadAll, 1, 1)
        layout.addWidget(self.buttonSave, 2, 1)
        layout.addWidget(self.buttonSaveAll, 3, 1)
        layout.addWidget(self.buttonShowDiff, 4, 1)
        layout.addWidget(self.checkWatchingEnabled, 6, 0, 1, 2)
        layout.setRowStretch(5, 10)
        
        app.documentClosed.connect(self.removeDocument)
        app.documentSaved.connect(self.removeDocument)
        app.documentUrlChanged.connect(self.removeDocument)
        app.documentLoaded.connect(self.removeDocument)
        self.tree.itemSelectionChanged.connect(self.updateButtons)
        self.buttonReload.clicked.connect(self.slotButtonReload)
        self.buttonReloadAll.clicked.connect(self.slotButtonReloadAll)
        self.buttonSave.clicked.connect(self.slotButtonSave)
        self.buttonSaveAll.clicked.connect(self.slotButtonSaveAll)
        self.buttonShowDiff.clicked.connect(self.slotButtonShowDiff)
        self.checkWatchingEnabled.toggled.connect(setEnabled)
    
        app.translateUI(self)
        qutil.saveDialogSize(self, 'externalchanges/dialog/size', QSize(400, 200))
        userguide.addButton(self.buttonBox(), "externalchanges")
        self.button('close').setFocus()
    
    def translateUI(self):
        self.setWindowTitle(app.caption(_("Modified Files")))
        self.setMessage(_(
            "The following files were modified or deleted by other "
            "applications:"))
        self.buttonReload.setText(_("Reload"))
        self.buttonReload.setToolTip(_(
            "Reloads the selected documents from disk. "
            "(You can still reach the previous state of the document "
            "using the Undo command.)"))
        self.buttonReloadAll.setText(_("Reload All"))
        self.buttonReloadAll.setToolTip(_(
            "Reloads all externally modified documents from disk. "
            "(You can still reach the previous state of the document "
            "using the Undo command.)"))
        self.buttonSave.setText(_("Save"))
        self.buttonSave.setToolTip(_(
            "Saves the selected documents to disk, overwriting the "
            "modifications by another program."))
        self.buttonSaveAll.setText(_("Save All"))
        self.buttonSaveAll.setToolTip(_(
            "Saves all documents to disk, overwriting the modifications by "
            "another program."))
        self.buttonShowDiff.setText(_("Show Difference..."))
        self.buttonShowDiff.setToolTip(_(
            "Shows the differences between the current document "
            "and the file on disk."))
        self.checkWatchingEnabled.setText(_(
            "Enable watching documents for external changes"))
        self.checkWatchingEnabled.setToolTip(_(
            "If checked, Frescobaldi will warn you when opened files are "
            "modified or deleted by other applications."))
    
    def setDocuments(self, documents):
        """Display the specified documents in the list."""
        # clear the treewidget
        for d in self.tree.invisibleRootItem().takeChildren():
            for i in d.takeChildren():
                i.doc = None
        # group the documents by directory
        dirs = {}
        for d in documents:
            path = d.url().toLocalFile()
            if path:
                dirname, filename = os.path.split(path)
                dirs.setdefault(dirname, []).append((filename, d))
        for dirname in sorted(dirs, key=util.naturalsort):
            diritem = QTreeWidgetItem()
            diritem.setText(0, util.homify(dirname))
            self.tree.addTopLevelItem(diritem)
            diritem.setExpanded(True)
            diritem.setFlags(Qt.ItemIsEnabled)
            diritem.setIcon(0, icons.get('folder-open'))
            for filename, document in sorted(dirs[dirname],
                                              key=lambda item: util.naturalsort(item[0])):
                fileitem = QTreeWidgetItem()
                diritem.addChild(fileitem)
                if documentwatcher.DocumentWatcher.instance(document).isdeleted():
                    itemtext = _("[deleted]") 
                    icon = "dialog-error"
                else:
                    itemtext = _("[modified]")
                    icon = "document-edit"
                fileitem.setIcon(0, icons.get(icon))
                fileitem.setText(0, filename)
                fileitem.setText(1, itemtext)
                fileitem.doc = document
        # select the item if there is only one
        if len(dirs) == 1 and len(dirs.values()[0]) == 1:
            fileitem.setSelected(True)
        self.tree.resizeColumnToContents(0)
        self.tree.resizeColumnToContents(1)
        self.updateButtons()
        
    def removeDocument(self, document):
        """Remove the specified document from our list."""
        for d in range(self.tree.topLevelItemCount()):
            diritem = self.tree.topLevelItem(d)
            for f in range(diritem.childCount()):
                if diritem.child(f).doc is document:
                    i = diritem.takeChild(f)
                    i.doc = None
                    if diritem.childCount() == 0:
                        self.tree.takeTopLevelItem(d)
                    break
            else:
                continue
            break
        self.updateButtons()
        # hide if no documents are left
        if self.tree.topLevelItemCount() == 0:
            self.hide()
    
    def selectedDocuments(self):
        """Return the selected documents."""
        return [i.doc for i in self.tree.selectedItems()]
    
    def allDocuments(self):
        """Return all shown documents."""
        return [self.tree.topLevelItem(d).child(f).doc
                for d in range(self.tree.topLevelItemCount())
                for f in range(self.tree.topLevelItem(d).childCount())]
    
    def updateButtons(self):
        """Updates the buttons regarding the selection."""
        docs_sel = self.selectedDocuments()
        docs_all = self.allDocuments()
        all_deleted_sel = all(documentwatcher.DocumentWatcher.instance(d).isdeleted()
                              for d in docs_sel)
        all_deleted_all = all(documentwatcher.DocumentWatcher.instance(d).isdeleted()
                              for d in docs_all)
        self.buttonSave.setEnabled(len(docs_sel) > 0)
        self.buttonSaveAll.setEnabled(len(docs_all) > 0)
        self.buttonReload.setEnabled(not all_deleted_sel)
        self.buttonReloadAll.setEnabled(not all_deleted_all)
        self.buttonShowDiff.setEnabled(len(docs_sel) == 1 and not all_deleted_sel)
    
    def slotButtonReload(self):
        """Called when the user clicks Reload."""
        for d in self.selectedDocuments():
            d.load(True)
        
    def slotButtonReloadAll(self):
        """Called when the user clicks Reload All."""
        for d in self.allDocuments():
            d.load(True)
    
    def slotButtonSave(self):
        """Called when the user clicks Save."""
        self.saveDocuments(self.selectedDocuments())
    
    def slotButtonSaveAll(self):
        """Called when the user clicks Save All."""
        self.saveDocuments(self.allDocuments())
    
    def saveDocuments(self, documents):
        """Used by slotButtonSave and slotButtonSaveAll."""
        results = [d.save() for d in documents]
        if False in results:
            if len(documents) == 1:
                msg = _("The document could not be saved.")
            elif results.count(False) == 1:
                msg = _("One document could not be saved.")
            else:
                msg = _("Some documents could not be saved.")
            QMessageBox.warning(self, app.caption(_("Error")), "\n".join((msg,
            _("Maybe the directory does not exist anymore."),
            _("Please save the document using the \"Save As...\" dialog.",
              "Please save the documents using the \"Save As...\" dialog.",
              results.count(False)))))
        
    def slotButtonShowDiff(self):
        """Called when the user clicks Show Difference."""
        docs = self.selectedDocuments() or self.allDocuments()
        if not docs:
            return
        d = docs[0]
        if documentwatcher.DocumentWatcher.instance(d).isdeleted():
            return
        
        filename = d.url().toLocalFile()
        try:
            with open(filename) as f:
                disktext = util.decode(f.read())
        except (IOError, OSError):
            return
        
        currenttext = d.toPlainText()
        
        html = htmldiff.htmldiff(
            currenttext, disktext, 
            _("Current Document"), _("Document on Disk"), numlines=5)
        dlg = widgets.dialog.Dialog(self, buttons=('close',))
        view = QTextBrowser(lineWrapMode=QTextBrowser.NoWrap)
        view.setHtml(html)
        dlg.setMainWidget(view)
        dlg.setWindowTitle(app.caption("Differences"))
        dlg.setMessage(_(
            "Document: {url}\n"
            "Difference between the current document and the file on disk:").format(
                url=filename))
        dlg.setWindowModality(Qt.NonModal)
        dlg.setAttribute(Qt.WA_QuitOnClose, False)
        dlg.setAttribute(Qt.WA_DeleteOnClose)
        qutil.saveDialogSize(dlg, "externalchanges/diff/dialog/size", QSize(600, 300))
        dlg.show()



########NEW FILE########
__FILENAME__ = filecache
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Caches information about files, and checks the mtime upon request.
"""

from __future__ import unicode_literals

import os
import weakref


class FileCache(object):
    """Caches information about files, and checks the mtime upon request.
    
    Has __setitem__, __getitem__, __delitem__, clear etc. methods like a dict.
    
    """
    def __init__(self):
        self._cache = {}
        
    def __getitem__(self, filename):
        mtime, value = self._cache[filename]
        try:
            if mtime == os.path.getmtime(filename):
                return value
        except (IOError, OSError):
            pass
        del self._cache[filename]
        raise KeyError
    
    def __setitem__(self, filename, value):
        try:
            self._cache[filename] = (os.path.getmtime(filename), value)
        except (IOError, OSError):
            pass
    
    def __delitem__(self, filename):
        del self._cache[filename]
        
    def __contains__(self, filename):
        try:
            self[filename]
            return True
        except KeyError:
            return False
    
    def filename(self, value):
        """Returns the filename of the cached value (if available)."""
        for filename in self.filenames():
            mtime, obj = self._cache[filename]
            if obj == value:
                return filename
        
    def filenames(self):
        """Yields filenames that are still valid in the cache."""
        for filename in list(self._cache):
            try:
                self[filename]
                yield filename
            except KeyError:
                pass
                
    def clear(self):
        self._cache.clear()


class WeakFileCache(FileCache):
    """Caches information about files like FileCache, but with a weak reference.
    
    This means the object is discarded if you don't keep a reference to it
    elsewhere.
    
    """
    def __getitem__(self, filename):
        mtime, valueref = self._cache[filename]
        value = valueref()
        if value is not None:
            try:
                if mtime == os.path.getmtime(filename):
                    return value
            except (IOError, OSError):
                pass
        del self._cache[filename]
        raise KeyError
    
    def __setitem__(self, filename, value):
        valueref = weakref.ref(value)
        try:
            self._cache[filename] = (os.path.getmtime(filename), valueref)
        except (IOError, OSError):
            pass



########NEW FILE########
__FILENAME__ = fileinfo
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Computes and caches various information about files.
"""

from __future__ import unicode_literals

import itertools
import re
import os
import atexit

import ly.document
import lydocinfo
import ly.lex
import filecache
import util
import variables


_document_cache = filecache.FileCache()
_suffix_chars_re = re.compile(r'[^-\w]', re.UNICODE)


### XXX otherwise I get a segfault on shutdown when very large music trees
### are made (and every node references the document).
### (The segfault is preceded by a "corrupted double-linked list" message.)
atexit.register(_document_cache.clear)


class _CachedDocument(object):
    """Contains a document and related items."""
    filename = None
    document = None
    variables = None
    docinfo = None
    music = None


def _cached(filename):
    """Return a _CachedDocument instance for the filename, else creates one."""
    filename = os.path.realpath(filename)
    try:
        c = _document_cache[filename]
    except KeyError:
        with open(filename) as f:
            text = util.decode(f.read())
        c = _document_cache[filename] = _CachedDocument()
        c.variables = v = variables.variables(text)
        c.document = ly.document.Document(text, v.get("mode"))
        c.filename = c.document.filename = filename
    return c


def document(filename):
    """Return a (cached) ly.document.Document for the filename."""
    return _cached(filename).document


def docinfo(filename):
    """Return a (cached) LyDocInfo instance for the specified file."""
    c = _cached(filename)
    if c.docinfo is None:
        c.docinfo = lydocinfo.DocInfo(c.document, c.variables)
    return c.docinfo


def music(filename):
    """Return a (cached) music.Document instance for the specified file."""
    c = _cached(filename)
    if c.music is None:
        import music
        c.music = music.Document(c.document)
    return c.music
    

def textmode(text, guess=True):
    """Returns the type of the given text ('lilypond, 'html', etc.).
    
    Checks the mode variable and guesses otherwise if guess is True.
    
    """
    mode = variables.variables(text).get("mode")
    if mode in ly.lex.modes:
        return mode
    if guess:
        return ly.lex.guessMode(text)


def includefiles(dinfo, include_path=()):
    """Returns a set of filenames that are included by the DocInfo's document.
        
    The specified include path is used to find files. The own filename 
    is NOT added to the set. Included files are checked recursively, 
    relative to our file, relative to the including file, and if that 
    still yields no file, relative to the directories in the include_path.
    
    If the document has no local filename, only the include_path is 
    searched for files.
    
    """
    filename = dinfo.document.filename
    basedir = os.path.dirname(filename) if filename else None
    files = set()
    
    def tryarg(directory, arg):
        path = os.path.realpath(os.path.join(directory, arg))
        if path not in files and os.path.isfile(path):
            files.add(path)
            args = docinfo(path).include_args()
            find(args, os.path.dirname(path))
            return True
            
    def find(incl_args, directory):
        for arg in incl_args:
            # new, recursive, relative include
            if not (directory and tryarg(directory, arg)):
                # old include (relative to master file)
                if not (basedir and tryarg(basedir, arg)):
                    # if path is given, also search there:
                    for p in include_path:
                        if tryarg(p, arg):
                            break
    
    find(dinfo.include_args(), basedir)
    return files


def basenames(dinfo, includefiles=(), filename=None, replace_suffix=True):
    """Returns the list of basenames a document is expected to create.
    
    The list is created based on includefiles and the define output-suffix and
    \bookOutputName and \bookOutputSuffix commands.
    You should add '.ext' and/or '-[0-9]+.ext' to find created files.
    
    If filename is given, it is regarded as the filename LilyPond is run on. 
    Otherwise, the filename of the info's document is read.
    
    If replace_suffix is True (the default), special characters and spaces 
    in the suffix are replaced with underscores (in the same way as LilyPond 
    does it), using the replace_suffix_chars() function.
    
    """
    basenames = []
    basepath = os.path.splitext(filename or dinfo.document.filename)[0]
    dirname, basename = os.path.split(basepath)

    if basepath:
        basenames.append(basepath)
    
    def args():
        yield dinfo.output_args()
        for filename in includefiles:
            yield docinfo(filename).output_args()
                
    for type, arg in itertools.chain.from_iterable(args()):
        if type == "suffix":
            if replace_suffix:
                # LilyPond (lily-library.scm:223) does this, too
                arg = replace_suffix_chars(arg)
            arg = basename + '-' + arg
        path = os.path.normpath(os.path.join(dirname, arg))
        if path not in basenames:
            basenames.append(path)
    return basenames


def replace_suffix_chars(s):
    """Replace spaces and most non-alphanumeric characters with underscores.
    
    This is used to mimic the behaviour of LilyPond, which also does this,
    for the output-suffix. (See scm/lily-library.scm:223.)
    
    """
    return _suffix_chars_re.sub('_', s)



########NEW FILE########
__FILENAME__ = fileprinter
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Constructs a printcommand to print a PDF file.
"""

from __future__ import unicode_literals

import itertools
import os

from PyQt4.QtGui import QPrinter


lpr_commands = (
    "lpr-cups",
    "lpr.cups",
    "lpr",
    "lp",
)

def lprCommand():
    """Returns a suitable 'lpr'-like command to send a file to the printer queue.
    
    Returns None if no such command could be found.
    Prefers the CUPS command 'lpr' or 'lp' if it can be found.
    
    """
    paths = os.environ.get("PATH", os.defpath).split(os.pathsep)
    for cmd, path in itertools.product(lpr_commands, paths):
        if os.access(os.path.join(path, cmd), os.X_OK):
            return cmd


def printCommand(cmd, printer, filename):
    """Returns a commandline (list) to print a PDF file.
    
    cmd:      "lpr" or "lp" (or something like that)
    printer:  a QPrinter instance
    filename: the filename of the PDF document to print.
    
    """
    command = [cmd]
    
    # printer name
    if cmd == "lp":
        command.append('-d')
    else:
        command.append('-P')
    command.append(printer.printerName())
    
    # copies
    numCopies = 1
    try:
        numCopies = printer.copyCount()
    except AttributeError: # only in Qt >= 4.7
        try:
            numCopies = printer.actualNumCopies()
        except AttributeError: # only in Qt >= 4.6
            numCopies = printer.numCopies()
    
    if cmd == "lp":
        command.append('-n')
        command.append(format(numCopies))
    else:
        command.append('-#{0}'.format(numCopies))
    
    # job name
    if cmd == "lp":
        command.append('-t')
    else:
        command.append('-J')
    command.append(printer.docName() or os.path.basename(filename))
    
    # page range
    if printer.printRange() == QPrinter.PageRange:
        pageRange = "{0}-{1}".format(printer.fromPage(), printer.toPage())
        if cmd == "lp":
            command.append('-P')
            command.append(pageRange)
        else:
            command.append('-o')
            command.append('page-ranges=' + pageRange)

    command.append(filename)
    return command




########NEW FILE########
__FILENAME__ = musicxml
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Import Music XML dialog.
Uses musicxml2ly to create ly fil from xml
In the dialog the options of musicxml2ly can be set 
"""

from __future__ import unicode_literals

import os
import subprocess
import collections

from PyQt4.QtCore import QSettings, QSize
from PyQt4.QtGui import (QCheckBox, QComboBox, QDialog, QDialogButtonBox,
    QGridLayout, QLabel, QTabWidget, QTextEdit, QWidget)

import app
import documentinfo
import userguide
import icons
import job
import jobmanager
import lilypondinfo
import listmodel
import widgets
import qutil
import util

# language names musicxml2ly allows
_langlist = [
    'nederlands',
    'catalan',
    'deutsch',
    'english',
    'espanol',
    'italiano',
    'norsk',
    'portugues',
    'suomi',
    'svenska',
    'vlaams',
]


class Dialog(QDialog):
	
    def __init__(self, parent=None):
        super(Dialog, self).__init__(parent)
        self._document = None
        self._path = None
        
        mainLayout = QGridLayout()
        self.setLayout(mainLayout)
        
        tabs = QTabWidget()
        
        import_tab = QWidget()
        post_tab = QWidget()
        
        itabLayout = QGridLayout(import_tab)
        ptabLayout = QGridLayout(post_tab)
        
        tabs.addTab(import_tab, "musicxml2ly")
        tabs.addTab(post_tab, "after import")
        
        self.noartCheck = QCheckBox()
        self.norestCheck = QCheckBox()
        self.nolayoutCheck = QCheckBox()
        self.nobeamCheck = QCheckBox()
        self.useAbsCheck = QCheckBox()
        
        self.langCombo = QComboBox()
        self.langLabel = QLabel()
        
        self.impChecks = [self.noartCheck,
						  self.norestCheck,
						  self.nolayoutCheck,
						  self.nobeamCheck,
						  self.useAbsCheck]
		
        self.formatCheck = QCheckBox()
        self.trimDurCheck = QCheckBox()
        self.removeScalesCheck = QCheckBox()
        self.runEngraverCheck = QCheckBox()
						   
        self.postChecks = [self.formatCheck,
						   self.trimDurCheck,
						   self.removeScalesCheck,
						   self.runEngraverCheck]								  
        
        self.commandLineLabel = QLabel()
        self.commandLine = QTextEdit(acceptRichText=False)
        
        self.setChecksObjectNames()
        
        self.buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        userguide.addButton(self.buttons, "musicxml_import")
        
        self.langCombo.addItem('')
        self.langCombo.addItems(_langlist)

        itabLayout.addWidget(self.noartCheck, 0, 0, 1, 2)
        itabLayout.addWidget(self.norestCheck, 1, 0, 1, 2)
        itabLayout.addWidget(self.nolayoutCheck, 2, 0, 1, 2)
        itabLayout.addWidget(self.nobeamCheck, 3, 0, 1, 2)
        itabLayout.addWidget(self.useAbsCheck, 4, 0, 1, 2)
        itabLayout.addWidget(self.langLabel, 5, 0, 1, 2)
        itabLayout.addWidget(self.langCombo, 6, 0, 1, 2)
        itabLayout.addWidget(widgets.Separator(), 7, 0, 1, 2)
        itabLayout.addWidget(self.commandLineLabel, 8, 0, 1, 2)
        itabLayout.addWidget(self.commandLine, 9, 0, 1, 2)
        
        ptabLayout.addWidget(self.formatCheck, 0, 0, 1, 2)
        ptabLayout.addWidget(self.trimDurCheck, 1, 0, 1, 2)       
        ptabLayout.addWidget(self.removeScalesCheck, 2, 0, 1, 2)
        ptabLayout.addWidget(self.runEngraverCheck, 3, 0, 1, 2)
        ptabLayout.setRowStretch(4, 10)
        
        mainLayout.addWidget(tabs, 0, 0, 9, 2)
        mainLayout.addWidget(self.buttons, 10, 0, 1, 2)
        
        app.translateUI(self)
        qutil.saveDialogSize(self, "xml_import/dialog/size", QSize(480, 260))
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        
        self.noartCheck.toggled.connect(self.makeCommandLine)
        self.norestCheck.toggled.connect(self.makeCommandLine)
        self.nolayoutCheck.toggled.connect(self.makeCommandLine)
        self.nobeamCheck.toggled.connect(self.makeCommandLine)
        self.useAbsCheck.toggled.connect(self.makeCommandLine)
        self.langCombo.currentIndexChanged.connect(self.makeCommandLine)
        self.makeCommandLine()
        
        self.loadSettings()
        
    def setChecksObjectNames(self):
        self.noartCheck.setObjectName("articulation-directions")
        self.norestCheck.setObjectName("rest-positions")
        self.nolayoutCheck.setObjectName("page-layout")
        self.nobeamCheck.setObjectName("import-beaming")
        self.useAbsCheck.setObjectName("absolute-mode")
        
        self.formatCheck.setObjectName("reformat")
        self.trimDurCheck.setObjectName("trim-durations")
        self.removeScalesCheck.setObjectName("remove-scaling")
        self.runEngraverCheck.setObjectName("engrave-directly")
    
    def translateUI(self):
        self.setWindowTitle(app.caption(_("Import Music XML")))
        self.noartCheck.setText(_("Import articulation directions"))
        self.norestCheck.setText(_("Import rest positions"))
        self.nolayoutCheck.setText(_("Import page layout"))
        self.nobeamCheck.setText(_("Import beaming"))
        self.useAbsCheck.setText(_("Pitches in absolute mode"))
        self.commandLineLabel.setText(_("Command line:"))
        
        self.langLabel.setText(_("Language for pitch names"))
        self.langCombo.setItemText(0, _("Default"))
        self.formatCheck.setText(_("Reformat source"))
        self.trimDurCheck.setText(_("Trim durations (Make implicit per line)"))
        self.removeScalesCheck.setText(_("Remove fraction duration scaling"))
        self.runEngraverCheck.setText(_("Engrave directly"))
        
        self.buttons.button(QDialogButtonBox.Ok).setText(_("Run musicxml2ly"))

    
    def setDocument(self, path):
        """Set the full path to the MusicXML document."""
        self._document = path
    
    def makeCommandLine(self):
        """Reads the widgets and builds a command line."""
        cmd = ["$musicxml2ly"]
        if self.useAbsCheck.isChecked():
            cmd.append('-a')
        if not self.noartCheck.isChecked():
            cmd.append('--nd')
        if not self.norestCheck.isChecked():
            cmd.append('--nrp')
        if not self.nolayoutCheck.isChecked():
            cmd.append('--npl')
        if not self.nobeamCheck.isChecked():
            cmd.append('--no-beaming')
        index = self.langCombo.currentIndex()
        if index > 0:
			cmd.append('--language=' + _langlist[index-1])

        cmd.append("$filename")
        self.commandLine.setText(' '.join(cmd))
    
    def getCmd(self):
        """Returns the command line."""
        cmd = []
        for t in self.commandLine.toPlainText().split():
            if t == '$musicxml2ly':
                cmd.extend(lilypondinfo.preferred().toolcommand('musicxml2ly'))
            elif t == '$filename':
                cmd.append(self._document)
            else:
                cmd.append(t)
        cmd.extend(['--output', '-'])
        return cmd
        
    def run_command(self):
        """ Run command line """
        cmd = self.getCmd()
        directory = os.path.dirname(self._document)
        proc = subprocess.Popen(cmd, cwd=directory,
            universal_newlines = True,
            stdin = subprocess.PIPE,
            stdout = subprocess.PIPE,
            stderr = subprocess.PIPE)
        stdouterr = proc.communicate()
        return stdouterr
		
    def getPostSettings(self):
        """ returns settings in the post import tab """
        post = []
        for p in self.postChecks:
            post.append(p.isChecked())
        return post
        
    def loadSettings(self):
        """ get users previous settings """
        imp_default = [False, False, False, False, False]
        post_default = [True, False, False, True]
        s = QSettings()
        s.beginGroup('xml_import')
        for i, d in zip(self.impChecks, imp_default):
            i.setChecked(s.value(i.objectName(), d, bool))
        for p, f in zip(self.postChecks, post_default):
            p.setChecked(s.value(p.objectName(), f, bool))
        lang = s.value("language", "default", type(""))
        try:
            index = _langlist.index(lang)
        except ValueError:
            index = -1
        self.langCombo.setCurrentIndex(index + 1)
        
    def saveSettings(self):
        """ save users last settings """
        s = QSettings()
        s.beginGroup('xml_import')
        for i in self.impChecks:
            s.setValue(i.objectName(), i.isChecked())
        for p in self.postChecks:
            s.setValue(p.objectName(), p.isChecked())
        index = self.langCombo.currentIndex()
        s.setValue('language', 'default' if index == 0 else _langlist[index-1])


########NEW FILE########
__FILENAME__ = folding
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2012 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Provides code folding.

The sidebar/ manages the visibility of the folding area.

"""

from __future__ import unicode_literals

import cursortools
import tokeniter
import ly.lex
import widgets.folding


line_painter = widgets.folding.LinePainter()


class Folder(widgets.folding.Folder):
    def fold_events(self, block):
        """Provides folding information by looking at indent/dedent tokens."""
        for t in tokeniter.tokens(block):
            if isinstance(t, ly.lex.Indent):
                yield widgets.folding.START
            elif isinstance(t, ly.lex.Dedent):
                yield widgets.folding.STOP
    
    def mark(self, block, state=None):
        if state is None:
            try:
                return block.userData().folded
            except AttributeError:
                return False
        elif state:
            cursortools.data(block).folded = state
        else:
            try:
                del block.userData().folded
            except AttributeError:
                pass


class FoldingArea(widgets.folding.FoldingArea):
    Folder = Folder




########NEW FILE########
__FILENAME__ = globalfontdialog
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Global Font Dialog, used to set the three fonts for the make-pango-font-tree
command.

It keeps its settings.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import qutil
import widgets.dialog

class GlobalFontDialog(widgets.dialog.Dialog):
    def __init__(self, parent=None):
        super(GlobalFontDialog, self).__init__(parent)
        self._messageLabel.setWordWrap(True)
        
        layout = QGridLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        self.mainWidget().setLayout(layout)
        
        self.romanLabel = QLabel()
        self.romanCombo = QFontComboBox()
        self.sansLabel = QLabel()
        self.sansCombo = QFontComboBox()
        self.typewriterLabel = QLabel()
        self.typewriterCombo = QFontComboBox(fontFilters=QFontComboBox.MonospacedFonts)
        
        layout.addWidget(self.romanLabel, 0, 0)
        layout.addWidget(self.romanCombo, 0, 1, 1, 2)
        layout.addWidget(self.sansLabel, 1, 0)
        layout.addWidget(self.sansCombo, 1, 1, 1, 2)
        layout.addWidget(self.typewriterLabel, 2, 0)
        layout.addWidget(self.typewriterCombo, 2, 1, 1, 2)
        
        self.loadSettings()
        self.finished.connect(self.saveSettings)
        app.translateUI(self)
        
    def translateUI(self):
        self.setWindowTitle(app.caption(_("Global Fonts")))
        self.setMessage(_(
            "Please select the three global fonts to use for "
            r"<code>\roman</code>, <code>\sans</code>, and <code>\typewriter</code> "
            "respectively."))
        self.romanLabel.setText(_("Roman Font:"))
        self.sansLabel.setText(_("Sans Font:"))
        self.typewriterLabel.setText(_("Typewriter Font:"))
    
    def romanFont(self):
        return self.romanCombo.currentFont().family()
    
    def setromanFont(self, family):
        self.romanCombo.setCurrentFont(QFont(family))
    
    def sansFont(self):
        return self.sansCombo.currentFont().family()
    
    def setSansFont(self, family):
        self.sansCombo.setCurrentFont(QFont(family))
    
    def typewriterFont(self):
        return self.typewriterCombo.currentFont().family()
    
    def settypewriterFont(self, family):
        self.typewriterCombo.setCurrentFont(QFont(family))
    
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("global_font_dialog")
        roman = s.value("roman", "Century Schoolbook L", type(""))
        self.romanCombo.setCurrentFont(QFont(roman))
        sans = s.value("sans", "sans-serif", type(""))
        self.sansCombo.setCurrentFont(QFont(sans))
        typewriter = s.value("typewriter", "monospace", type(""))
        self.typewriterCombo.setCurrentFont(QFont(typewriter))
    
    def saveSettings(self):
        s = QSettings()
        s.beginGroup("global_font_dialog")
        s.setValue("roman", self.romanCombo.currentFont().family())
        s.setValue("sans", self.sansCombo.currentFont().family())
        s.setValue("typewriter", self.typewriterCombo.currentFont().family())



########NEW FILE########
__FILENAME__ = guistyle
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Sets the user interface style.
"""

from __future__ import unicode_literals


from PyQt4.QtCore import QSettings
from PyQt4.QtGui import QStyleFactory

import app

_system_default = app.qApp.style().objectName()


def keys():
    return [name.lower() for name in QStyleFactory.keys()]


def setStyle():
    style = QSettings().value("guistyle", "", type("")).lower()
    if style not in keys():
        style = _system_default
    if style != app.qApp.style().objectName():
        app.qApp.setStyle(QStyleFactory.create(style))


app.settingsChanged.connect(setStyle)
setStyle()

########NEW FILE########
__FILENAME__ = helpers
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Helper application stuff.
"""

from __future__ import unicode_literals

import os
import re
import subprocess
import sys

from PyQt4.QtCore import QSettings
from PyQt4.QtGui import QDesktopServices, QMessageBox

def shell_split(cmd):
    """Split a string like the UNIX shell, returning a list.
    
    Double quoted parts are kept together with the quotes removed.
    
    """
    # remove double quotes, keeping quoted parts together
    # (because shlex does not yet work with unicode...)
    return [item.replace('"', '') for item in 
        re.findall(r'[^\s"]*"[^"]*"[^\s"]*|[^\s"]+', cmd)]


def command(type):
    """Returns the command for the specified type as a list.
    
    Returns None if no command was specified.
    
    """
    cmd = QSettings().value("helper_applications/" + type, "")
    if not cmd:
        return
    
    if os.path.isabs(cmd) and os.access(cmd, os.X_OK):
        return [cmd]

    return shell_split(cmd)


def openUrl(url, type="browser"):
    """Opens the specified QUrl, using the specified type."""
    # be sure to pick a suitable type
    if url.scheme() == "mailto":
        type = "email"
    elif type == "browser" and url.toLocalFile():
        ext = os.path.splitext(url.toLocalFile())[1].lower()
        if os.path.isdir(url.toLocalFile()):
            type = "directory"
        elif ext == '.pdf':
            type = "pdf"
        elif ext in ('.png', '.jpg', '.jpeg'):
            type = "image"
        elif ext in ('.midi', '.mid'):
            type = "midi"
    
    # get the command
    cmd = command(type)
    if not cmd:
        if type != "shell":
            QDesktopServices.openUrl(url)
            return
        for cmd in terminalCommands():
            break # get the first
    
    prog = cmd.pop(0)
    
    workdir = None
    if url.toLocalFile():
        workdir = url.toLocalFile()
        if type != "shell":
            workdir = os.path.dirname(workdir)
    
    if any('$f' in a or '$u' in a for a in cmd):
        cmd = [a.replace('$u', url.toString())
                if '$u' in a else a.replace('$f', url.toLocalFile())
                for a in cmd]
    elif type in ("browser", "email"):
        cmd.append(url.toString())
    elif type != "shell":
        cmd.append(url.toLocalFile())
    
    try:
        subprocess.Popen([prog] + cmd, cwd=workdir)
    except OSError:
        QMessageBox.critical(None, _("Error"), _(
            "Could not start {program}.\n"
            "Please check path and permissions.").format(program=prog))


def terminalCommands():
    """Yields suitable commands to open a terminal/shell window.
    
    There is always yielded at least one, which is suitable as default.
    
    """
    if os.name == "nt":
        yield ['cmd.exe']
    elif sys.platform == 'darwin':
        yield ['open', '-a', 'Terminal', '$f']
    else:
        # find a default linux terminal
        paths = os.environ.get('PATH', os.defpath).split(os.pathsep)
        for cmd in (
            ['lxterminal', '--working-directory=$f'],
            ['xfce4-terminal', '--working-directory=$f'],
            ['konsole', '--workdir', '$f'],
            ['gnome-terminal', '--working-directory=$f'],
            ):
            for p in paths:
                if p:
                    prog = os.path.join(p, cmd[0])
                    if os.access(prog, os.X_OK):
                         yield cmd
        yield ['xterm']



########NEW FILE########
__FILENAME__ = highlight2html
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Export syntax-highlighted text as HTML.
"""

from __future__ import unicode_literals

import lydocument
import textformats
import ly.document
import ly.colorize


def html_text(text, mode=None, scheme='editor', inline=True, number_lines=False, full_html=True):
    """Converts the text to HTML using the specified or guessed mode."""
    c = ly.document.Cursor(ly.document.Document(text, mode))
    return html(c, scheme, inline, number_lines, full_html)

def html_inline(cursor, scheme='editor', inline=True, number_lines=False, full_html=True):
    """Return an (by default) inline-styled HTML document for the cursor's selection."""
    c = lydocument.cursor(cursor)
    return html(c, scheme, inline, number_lines, full_html)

def html_document(document, scheme='editor', inline=False, number_lines=False, full_html=True):
    """Return a (by default) css-styled HTML document for the full document."""
    c = lydocument.Cursor(lydocument.Document(document))
    return html(c, scheme, inline, number_lines, full_html)

def html(cursor, scheme='editor', inline=False, number_lines=False, full_html=True):
    """Return a HTML document with the syntax-highlighted region.
    
    The tokens are marked with <span> tags. The cursor is a 
    ly.document.Cursor instance. The specified text formats scheme is used 
    (by default 'editor'). If inline is True, the span tags have inline 
    style attributes. If inline is False, the span tags have class 
    attributes and a stylesheet is included.
    
    Set number_lines to True to add line numbers.
    
    """
    data = textformats.formatData(scheme)       # the current highlighting scheme
    w = ly.colorize.HtmlWriter()
    w.inline_style = inline
    w.number_lines = number_lines
    w.full_html = full_html
    w.fgcolor = data.baseColors['text'].name()
    w.bgcolor = data.baseColors['background'].name()
    w.css_scheme = data.css_scheme()
    return w.html(cursor)



########NEW FILE########
__FILENAME__ = highlighter
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Highlighter class provides syntax highlighting and more information
about a document's contents.
"""

from __future__ import unicode_literals


from PyQt4.QtGui import (
    QColor, QSyntaxHighlighter, QTextBlockUserData, QTextCharFormat,
    QTextCursor, QTextDocument)


import ly.lex
import ly.colorize

import app
import cursortools
import textformats
import metainfo
import plugin
import variables
import documentinfo


metainfo.define('highlighting', True)


def mapping(data):
    """Return a dictionary mapping token classes from ly.lex to QTextCharFormats.
    
    The QTextFormats are queried from the specified TextFormatData instance.
    The returned dictionary is a ly.colorize.Mapping instance.
    
    """
    return ly.colorize.Mapper((cls, data.textFormat(mode, style.name))
                        for mode, styles in ly.colorize.default_mapping()
                            for style in styles
                                for cls in style.classes)


def highlighter(document):
    """Return the Highlighter for this document."""
    return Highlighter.instance(document)


def highlight_mapping():
    """Return the global Mapping instance that maps token class to QTextCharFormat."""
    global _highlight_mapping
    try:
        return _highlight_mapping
    except NameError:
        _highlight_mapping = mapping(textformats.formatData('editor'))
        return _highlight_mapping


def _reset_highlight_mapping():
    """Remove the global HighlightFormats instance, so it's recreated next time."""
    global _highlight_mapping
    try:
        del _highlight_mapping
    except NameError:
        pass

app.settingsChanged.connect(_reset_highlight_mapping, -100) # before all others


class Highlighter(QSyntaxHighlighter, plugin.Plugin):
    """A QSyntaxHighlighter that can highlight a QTextDocument.
    
    It can be used for both generic QTextDocuments as well as
    document.Document objects. In the latter case it automatically:
    - initializes whether highlighting is enabled from the document's metainfo
    - picks the mode from the variables if they specify that
    
    The Highlighter automatically re-reads the highlighting settings if they
    are changed.
    
    """
    def __init__(self, document):
        QSyntaxHighlighter.__init__(self, document)
        self._fridge = ly.lex.Fridge()
        app.settingsChanged.connect(self.rehighlight)
        self._initialState = None
        self._highlighting = True
        self._mode = None
        self.initializeDocument()
    
    def initializeDocument(self):
        """This method is always called by the __init__ method.
        
        The default implementation does nothing for generic QTextDocuments,
        but for document.Document instances it connects to some additional
        signals to keep the mode up-to-date (reading it from the variables if
        needed) and initializes whether to enable visual highlighting from the
        document's metainfo.
        
        """
        document = self.document()
        if hasattr(document, 'url'):
            self._highlighting = metainfo.info(document).highlighting
            document.loaded.connect(self._resetHighlighting)
            self._mode = documentinfo.mode(document, False)
            variables.manager(document).changed.connect(self._variablesChange)
        
    def _variablesChange(self):
        """Called whenever the variables have changed. Checks the mode."""
        mode = documentinfo.mode(self.document(), False)
        if mode != self._mode:
            self._mode = mode
            self.rehighlight()
            
    def _resetHighlighting(self):
        """Switch highlighting on or off depending on saved metainfo."""
        self.setHighlighting(metainfo.info(self.document()).highlighting)
        
    def highlightBlock(self, text):
        """Called by Qt when the highlighting of the current line needs updating."""
        # find the state of the previous line
        prev = self.previousBlockState()
        state = self._fridge.thaw(prev)
        blank = not state and (not text or text.isspace())
        if not state:
            state = self.initialState()

        # collect and save the tokens
        tokens = tuple(state.tokens(text))
        cursortools.data(self.currentBlock()).tokens = tokens
        
        # if blank thus far, keep the highlighter coming back
        # because the parsing state is not yet known; else save the state
        self.setCurrentBlockState(prev - 1 if blank else self._fridge.freeze(state))
        
        # apply highlighting if desired
        if self._highlighting:
            setFormat = lambda f: self.setFormat(token.pos, len(token), f)
            mapping = highlight_mapping()
            for token in tokens:
                f = mapping[token]
                if f:
                    setFormat(f)
        
    def setHighlighting(self, enable):
        """Enable or disable highlighting."""
        changed = enable != self._highlighting
        self._highlighting = enable
        if changed:
            self.rehighlight()
            
    def isHighlighting(self):
        """Return whether highlighting is active."""
        return self._highlighting
        
    def state(self, block):
        """Return a thawn ly.lex.State() object at the *end* of the QTextBlock.
        
        Do not use this method directly. Instead use tokeniter.state() or
        tokeniter.state_end(), because that assures the highlighter has run
        at least once.
        
        """
        return self._fridge.thaw(block.userState()) or self.initialState()

    def setInitialState(self, state):
        """Force the initial state. Use None to enable auto-detection."""
        self._initialState = self._fridge.freeze(state) if state else None
        
    def initialState(self):
        """Return the initial State for this document."""
        if self._initialState is None:
            mode = self._mode or ly.lex.guessMode(self.document().toPlainText())
            return ly.lex.state(mode)
        return self._fridge.thaw(self._initialState)


def html_copy(cursor, scheme='editor', number_lines=False):
    """Return a new QTextDocument with highlighting set as HTML textcharformats.
    
    The cursor is a cursor of a document.Document instance. If the cursor 
    has a selection, only the selection is put in the new document.
    
    If number_lines is True, line numbers are added.
    
    """
    data = textformats.formatData(scheme)
    doc = QTextDocument()
    doc.setDefaultFont(data.font)
    doc.setPlainText(cursor.document().toPlainText())
    if metainfo.info(cursor.document()).highlighting:
        highlight(doc, mapping(data), ly.lex.state(documentinfo.mode(cursor.document())))
    if cursor.hasSelection():
        # cut out not selected text
        start, end = cursor.selectionStart(), cursor.selectionEnd()
        cur1 = QTextCursor(doc)
        cur1.setPosition(start, QTextCursor.KeepAnchor)
        cur2 = QTextCursor(doc)
        cur2.setPosition(end)
        cur2.movePosition(QTextCursor.End, QTextCursor.KeepAnchor)
        cur2.removeSelectedText()
        cur1.removeSelectedText()
    if number_lines:
        c = QTextCursor(doc)
        f = QTextCharFormat()
        f.setBackground(QColor('#eeeeee'))
        if cursor.hasSelection():
            num = cursor.document().findBlock(cursor.selectionStart()).blockNumber() + 1
            last = cursor.document().findBlock(cursor.selectionEnd())
        else:
            num = 1
            last = cursor.document().lastBlock()
        lastnum = last.blockNumber() + 1
        padding = len(format(lastnum))
        block = doc.firstBlock()
        while block.isValid():
            c.setPosition(block.position())
            c.setCharFormat(f)
            c.insertText('{0:>{1}d} '.format(num, padding))
            block = block.next()
            num += 1
    return doc


def highlight(document, mapping=None, state=None):
    """Highlight a generic QTextDocument once.
    
    mapping is an optional Mapping instance, defaulting to the current 
    configured editor highlighting formats (returned by highlight_mapping()).
    state is an optional ly.lex.State instance. By default the text type is 
    guessed.
    
    """
    if mapping is None:
        mapping = highlight_mapping()
    if state is None:
        state = ly.lex.guessState(document.toPlainText())
    cursor = QTextCursor(document)
    block = document.firstBlock()
    while block.isValid():
        for token in state.tokens(block.text()):
            f = mapping[token]
            if f:
                cursor.setPosition(block.position() + token.pos)
                cursor.setPosition(block.position() + token.end, QTextCursor.KeepAnchor)
                cursor.setCharFormat(f)
        block = block.next()



########NEW FILE########
__FILENAME__ = historymanager
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages the history of the open documents of a MainWindow.
Contains smart logic to switch documents if the active document is closed.

If no documents remain, listen to other HistoryManager instances and
make the document set-current there also current here.
"""

import weakref

import app
import signals

# This signal is emitted whenever a MainWindow sets a document current (active)
# Any HistoryManager can listen to it and follow it if no document is current
_setCurrentDocument = signals.Signal()  # Document


class HistoryManager(object):
    """Keeps the history of document switches by the user.
    
    If a document is closed, the previously active document is set active.
    If no documents remain, nothing is done.
    
    """
    def __init__(self, mainwindow, othermanager=None):
        self.mainwindow = weakref.ref(mainwindow)
        self._documents = list(othermanager._documents if othermanager else app.documents)
        self._has_current = bool(self._documents)
        mainwindow.currentDocumentChanged.connect(self.setCurrentDocument)
        app.documentCreated.connect(self.addDocument, 1)
        app.documentClosed.connect(self.removeDocument, 1)
        _setCurrentDocument.connect(self._listen)
        
    def addDocument(self, doc):
        self._documents.insert(-1, doc)

    def removeDocument(self, doc):
        active = doc is self._documents[-1]
        if active:
            if len(self._documents) > 1:
                self.mainwindow().setCurrentDocument(self._documents[-2])
            else:
                # last document removed; listen to setCurrentDocument from others
                self._has_current = False
        self._documents.remove(doc)
    
    def setCurrentDocument(self, doc):
        self._documents.remove(doc)
        self._documents.append(doc)
        self._has_current = True
        # notify possible interested parties
        _setCurrentDocument(doc)
    
    def documents(self):
        """Returns the documents in order of most recent been active."""
        return self._documents[::-1]

    def _listen(self, document):
        """Called when any MainWindow emits the currentDocumentChanged."""
        if not self._has_current:
            # prevent nested emits of this signal from reacting MainWindows
            with _setCurrentDocument.blocked():
                self.mainwindow().setCurrentDocument(document)



########NEW FILE########
__FILENAME__ = homekey
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Simple eventfilter that makes Home and Shift+Home in text editor widgets
go to the first non-space character of a line, instead of the very beginning.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QEvent, QObject
from PyQt4.QtGui import QKeySequence, QTextCursor


def handle(edit, ev):
    """Returns True if a Home/Shift+Home key press event was handled.
    
    edit: Q(Plain)TextEdit instance
    ev: the KeyPress QEvent
    
    """
    home = ev == QKeySequence.MoveToStartOfLine
    s_home = ev == QKeySequence.SelectStartOfLine
    if home or s_home:
        # go to first non-space character if not already there
        cursor = edit.textCursor()
        text = cursor.block().text()
        pos = cursor.block().position() + len(text) - len(text.lstrip())
        if cursor.position() != pos:
            mode = QTextCursor.KeepAnchor if s_home else QTextCursor.MoveAnchor
            cursor.setPosition(pos, mode)
            edit.setTextCursor(cursor)
            return True
    return False


class Handler(QObject):
    def eventFilter(self, obj, ev):
        if ev.type() == QEvent.KeyPress:
            return handle(obj, ev)
        return False


handler = Handler()



########NEW FILE########
__FILENAME__ = htmldiff
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2012 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Create a HTML diff view from two text strings.
"""

from __future__ import unicode_literals

import re
import difflib


def htmldiff(oldtext, newtext, oldtitle="", newtitle="",
             context=True, numlines=3, tabsize=8, wrapcolumn=None):
    """Return a HTML diff from oldtext to newtext.
    
    See also the Python documentation for difflib.HtmlDiff().make_table().
    
    """
    table = difflib.HtmlDiff(tabsize=tabsize, wrapcolumn=wrapcolumn).make_table(
        oldtext.splitlines(), newtext.splitlines(),
        oldtitle, newtitle, context, numlines)
    # overcome a QTextBrowser limitation (no text-align css support)
    table = table.replace('<td class="diff_header"', '<td align="right" class="diff_header"')
    # make horizontal lines between sections
    table = re.sub(r'</tbody>\s*<tbody>', '<tr><td colspan="6"><hr/></td></tr>', table)
    legend = _legend.format(
        colors = _("Colors:"),
        added = _("Added"),
        changed = _("Changed"),
        deleted = _("Deleted"),
        links = _("Links:"),
        first_change = _("First Change"),
        next_change = _("Next Change"),
        top = _("Top"))
    return _htmltemplate.format(diff = table, css = _css, legend = legend)


_htmltemplate = """
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
    <title></title>
    <style type="text/css">{css}</style>
</head>

<body>
    {diff}
    {legend}
</body>
</html>"""

_css = """
    table.diff {
        border:medium;
    }
    .diff_header {
        background-color:#e0e0e0;
    }
    td.diff_header {
        text-align:right;
        padding-right: 10px;
        color: #606060;
    }
    .diff_next {
        background-color:#c0c0c0;
        padding-left: 4px;
        padding-right: 4px;
    }
    .diff_add {
        background-color:#aaffaa;
    }
    .diff_chg {
        background-color:#ffff77;
    }
    .diff_sub {
        background-color:#ffaaaa;
    }
"""

_legend = """<p>
<b>{colors}</b>
<span class="diff_add">&nbsp;{added}&nbsp;</span>,
<span class="diff_chg">&nbsp;{changed}&nbsp;</span>,
<span class="diff_sub">&nbsp;{deleted}&nbsp;</span>
<br />
<b>{links}</b>
f: {first_change},
n: {next_change},
t: {top}
</p>
"""


########NEW FILE########
__FILENAME__ = hyphenator
"""

This is a Pure Python module to hyphenate text.

It is inspired by Ruby's Text::Hyphen, but currently reads standard *.dic files,
that must be installed separately.

In the future it's maybe nice if dictionaries could be distributed together with
this module, in a slightly prepared form, like in Ruby's Text::Hyphen.

Wilbert Berendsen, March 2008
info@wilbertberendsen.nl

License: LGPL. More info: http://python-hyphenator.googlecode.com/

"""
from __future__ import unicode_literals

import codecs
import re


__all__ = ["Hyphenator"]

# cache of per-file HyphenationDictionary objects
_hdcache = {}

# precompile some regular expressions
parse = re.compile(r'(\d?)(\D?)').findall


# Match ^^xx where xx is a two-digit hexadecimal value
_hex_re = re.compile(r'\^{2}([0-9a-f]{2})')

# replace the matched hex string with the corresponding unicode character
_hex_repl = lambda matchObj: unichr(int(matchObj.group(1), 16))

def replace_hex(text):
    """Replaces ^^xx (where xx is a two-digit hexadecimal value) occurrences
    by the corresponding unicode character.
    
    """
    return _hex_re.sub(_hex_repl, text)


class ParsedAlternative(object):
    """Parse nonstandard hyphen pattern alternative.
    
    when called with an odd value, the instance returns an integer with data
    attribute (DataInt) about the current position in the pattern.
    
    """
    def __init__(self, pat, alt):
        alt = alt.split(',')
        self.change = alt[0]
        if len(alt) > 2:
            self.index = int(alt[1])
            self.cut = int(alt[2]) + 1
        else:
            self.index = 1
            self.cut = len(re.sub(r'[\d\.]', '', pat)) + 1
        if pat.startswith('.'):
            self.index += 1

    def __call__(self, val):
        self.index -= 1
        val = int(val)
        if val & 1:
            return DataInt(val, (self.change, self.index, self.cut))
        else:
            return val


class DataInt(int):
    """An integer with a data attribute.
    
    Just an int some other data can be stuck to in a data attribute.
    Instantiate with ref=other to use the data from the other DataInt.
    
    """
    def __new__(cls, value, data=None, ref=None):
        obj = int.__new__(cls, value)
        if ref and type(ref) is DataInt:
            obj.data = ref.data
        else:
            obj.data = data
        return obj


class HyphenationDictionary(object):
    """Reads a hyph_*.dic file and stores the hyphenation patterns.
    
    Parameters:
    filename : filename of hyph_*.dic pattern file to read
    
    """
    def __init__(self, filename):
        self.patterns = {}
        with open(filename) as f:
            # use correct encoding, specified in first line
            for encoding in f.readline().split():
                if encoding != "charset":
                    try:
                        decoder = codecs.getreader(encoding)
                        break
                    except LookupError:
                        pass
            else:
                decoder = codecs.getreader('latin1')
            
            for pat in decoder(f):
                pat = pat.strip()
                if not pat or pat[0] == '%':
                    continue
                # replace ^^hh with the real character
                pat = replace_hex(pat)
                # read nonstandard hyphen alternatives
                if '/' in pat:
                    pat, alt = pat.split('/', 1)
                    factory = ParsedAlternative(pat, alt)
                else:
                    factory = int
                tag, values = zip(*[(s, factory(i or "0"))
                                                    for i, s in parse(pat)])
                # if only zeros, skip this pattern
                if any(values):
                    # strip zeros and store start offset.
                    start, end = 0, len(values)
                    while not values[start]:
                        start += 1
                    while not values[end-1]:
                        end -= 1
                    self.patterns[''.join(tag)] = start, values[start:end]
        self.cache = {}
        self.maxlen = max(map(len, self.patterns))

    def positions(self, word):
        """Returns a list of positions where the word can be hyphenated.
        
        E.g. for the dutch word 'lettergrepen' this method returns
        the list [3, 6, 9].

        Each position is a 'data int' (DataInt) with a data attribute.
        If the data attribute is not None, it contains a tuple with
        information about nonstandard hyphenation at that point:
        (change, index, cut)

        change: is a string like 'ff=f', that describes how hyphenation
            should take place.
        index: where to substitute the change, counting from the current
            point
        cut: how many characters to remove while substituting the nonstandard
            hyphenation
        
        """
        word = word.lower()
        try:
            return self.cache[word]
        except KeyError:
            pass
        prepWord = '.' + word + '.'
        res = [0] * (len(prepWord) + 1)
        for i in range(len(prepWord) - 1):
            for j in range(i + 1, min(i + self.maxlen, len(prepWord)) + 1):
                p = self.patterns.get(prepWord[i:j])
                if p:
                    offset, values = p
                    s = slice(i + offset, i + offset + len(values))
                    res[s] = map(max, values, res[s])

        positions = [DataInt(i - 1, ref=r) for i, r in enumerate(res) if r % 2]
        self.cache[word] = positions
        return positions


class Hyphenator(object):
    """Reads a hyph_*.dic file and stores the hyphenation patterns.
    
    Provides methods to hyphenate strings in various ways.
    Parameters:
    -filename : filename of hyph_*.dic to read
    -left: make the first syllabe not shorter than this
    -right: make the last syllabe not shorter than this
    -cache: if true (default), use a cached copy of the dic file, if possible

    left and right may also later be changed:
      h = Hyphenator(file)
      h.left = 1
    
    """
    def __init__(self, filename, left=2, right=2, cache=True):
        self.left  = left
        self.right = right
        if not cache or filename not in _hdcache:
            _hdcache[filename] = HyphenationDictionary(filename)
        self.hd = _hdcache[filename]

    def positions(self, word):
        """Returns a list of positions where the word can be hyphenated.
        
        See also HyphenationDictionary.positions. The points that are too far to
        the left or right are removed.
        
        """
        right = len(word) - self.right
        return [i for i in self.hd.positions(word) if self.left <= i <= right]

    def iterate(self, word):
        """Iterate over all hyphenation possibilities, the longest first."""
        for p in reversed(self.positions(word)):
            if p.data:
                # get the nonstandard hyphenation data
                change, index, cut = p.data
                if word.isupper():
                    change = change.upper()
                c1, c2 = change.split('=')
                yield word[:p+index] + c1, c2 + word[p+index+cut:]
            else:
                yield word[:p], word[p:]

    def wrap(self, word, width, hyphen='-'):
        """Returns the longest possible first part and the last part of the
        hyphenated word.
        
        The first part has the hyphen already attached. Returns None, if there
        is no hyphenation point before width, or if the word could not be
        hyphenated.
        
        """
        width -= len(hyphen)
        for w1, w2 in self.iterate(word):
            if len(w1) <= width:
                return w1 + hyphen, w2

    def inserted(self, word, hyphen='-'):
        """Returns the word as a string with all the possible hyphens inserted.
        
        E.g. for the dutch word 'lettergrepen' this method returns the string
        'let-ter-gre-pen'. The hyphen string to use can be given as the second
        parameter, that defaults to '-'.
        
        """
        l = list(word)
        for p in reversed(self.positions(word)):
            if p.data:
                # get the nonstandard hyphenation data
                change, index, cut = p.data
                if word.isupper():
                    change = change.upper()
                l[p + index : p + index + cut] = change.replace('=', hyphen)
            else:
                l.insert(p, hyphen)
        return ''.join(l)

    __call__ = iterate


if __name__ == "__main__":
    import sys
    dict_file = sys.argv[1]
    word = sys.argv[2].decode('latin1')

    h = Hyphenator(dict_file, left=1, right=1)

    for i in h(word):
        print(i)


########NEW FILE########
__FILENAME__ = hyphendialog
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Dialog for selecting a hyphen language,
and code for finding hyphenation dictionaries to present the user a  choice.
"""

from __future__ import unicode_literals

import glob
import locale
import os

from PyQt4.QtCore import QSettings, Qt
from PyQt4.QtGui import QDialog, QDialogButtonBox, QLabel, QListWidget, QVBoxLayout

import app
import qutil
import userguide
import language_names
import widgets
import hyphdicts
import hyphenator
import po.setup

# paths to check for hyphen dicts
default_paths = [
    "share/hyphen",
    "share/myspell",
    "share/myspell/dicts",
    "share/dict/ooo",
    "share/apps/koffice/hyphdicts",
    "lib/scribus/dicts",
    "share/scribus/dicts",
    "share/scribus-ng/dicts",
    "share/hunspell",
]


def settings():
    """Returns the QSettings group for our settings."""
    settings = QSettings()
    settings.beginGroup("hyphenation")
    return settings

def directories():
    """ Yields a list of existing paths based on config """
    # prefixes to look in for relative paths
    prefixes = ['/usr/', '/usr/local/']
    
    def gen():
        # if the path is not absolute, add it to all prefixes.
        paths = settings().value("paths", default_paths, type(""))
        for path in paths:
            if os.path.isabs(path):
                yield path
            else:
                for pref in prefixes:
                    yield os.path.join(pref, path)
        yield hyphdicts.path
    return filter(os.path.isdir, gen())

def findDicts():
    """ Find installed hyphen dictionary files """
    
    # now find the hyph_xx_XX.dic files
    dicfiles = (f for p in directories()
                  for f in glob.glob(os.path.join(p, 'hyph_*.dic')) if os.access(f, os.R_OK))

    return dict((os.path.basename(dic)[5:-4], dic) for dic in dicfiles)


class HyphenDialog(QDialog):
    def __init__(self, mainwindow):
        super(HyphenDialog, self).__init__(mainwindow)
        self.setWindowModality(Qt.WindowModal)
        layout = QVBoxLayout()
        self.setLayout(layout)
        self.topLabel = QLabel()
        self.listWidget = QListWidget()
        
        layout.addWidget(self.topLabel)
        layout.addWidget(self.listWidget)
        layout.addWidget(widgets.Separator())
        
        self.buttons = b = QDialogButtonBox()
        layout.addWidget(b)
        b.setStandardButtons(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        userguide.addButton(b, "lyrics")
        b.rejected.connect(self.reject)
        b.accepted.connect(self.accept)
        
        self.load()
        app.translateUI(self)
        qutil.saveDialogSize(self, "hyphenation/dialog/size")
        
    def translateUI(self):
        self.setWindowTitle(app.caption(_("Hyphenate Lyrics Text")))
        self.topLabel.setText(_("Please select a language:"))
        
    def load(self):
        current = po.setup.current()
        self._langs = [(language_names.languageName(lang, current), lang, dic)
                       for lang, dic in findDicts().iteritems()]
        self._langs.sort()
        for name, lang, dic in self._langs:
            self.listWidget.addItem("{0}  ({1})".format(name, lang))
            
        def select():
            lastused = settings().value("lastused", "", type(""))
            if lastused:
                yield lastused
            lang = po.setup.preferred()[0]
            yield lang
            yield lang.split('_')[0]
        
        langs = [item[1] for item in self._langs]
        for preselect in select():
            try:
                self.listWidget.setCurrentRow(langs.index(preselect))
                break
            except ValueError:
                continue
   
    def hyphenator(self):
        if self.exec_() and self._langs:
            lang, dic = self._langs[self.listWidget.currentRow()][1:]
            result = hyphenator.Hyphenator(dic)
            settings().setValue("lastused", lang)
        else:
            result = None
        self.deleteLater()
        return result



########NEW FILE########
__FILENAME__ = indent
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Indent and auto-indent.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSettings

import ly.lex
import ly.indent
import cursortools
import tokeniter
import variables
import lydocument


def indent_variables(document=None):
    """Return a dictionary with indentation preferences.
    
    If a document (a Frescobaldi/QTextDocument) is specified, the document 
    variables are also read.
    
    For the variables and their default variables, see userguide/docvars.md.

    """
    s = QSettings()
    s.beginGroup("indent")
    nspaces = s.value("indent_spaces", 2, int)
    tabwidth = s.value("tab_width", 8, int)
    dspaces = s.value("document_spaces", 8, int)
    prefs = {
        'indent-tabs': nspaces == 0,
        'indent-width': 2 if nspaces == 0 else nspaces,
        'tab-width': tabwidth,
        'document-tabs': dspaces == 0,
        'document-tab-width': 8 if dspaces == 0 else dspaces,
    }
    return variables.update(document, prefs) if document else prefs
    
def indenter(document=None):
    """Return a ly.indent.Indenter, setup for the document."""
    indent_vars = indent_variables(document)
    i = ly.indent.Indenter()
    i.indent_width = indent_vars['indent-width']
    i.indent_tabs = indent_vars['indent-tabs']
    return i
    
def auto_indent_block(block):
    """Auto-indents the given block."""
    i = indenter(block.document())
    d = lydocument.Document(block.document())
    current_indent = i.get_indent(d, block)
    if current_indent is False:
        return
    indent = i.compute_indent(d, block)
    d.combine_undo = True
    with d:
        d[d.position(block):d.position(block)+len(current_indent)] = indent

def indentable(cursor):
    """Returns True if the cursor is at a dedent token and running the auto-indenter makes sense."""
    block = cursor.block()
    pos = cursor.position() - block.position()
    for token in tokeniter.tokens(block):
        if token.end >= pos:
            return isinstance(token, (ly.lex.Dedent, ly.lex.BlockCommentEnd))
        elif not isinstance(token, (ly.lex.Space, ly.lex.Dedent)):
            return

def increase_indent(cursor):
    """Increases the indent of the line the cursor is at (or the selected lines).
    
    If there is no selection or the cursor is not in the first indent space,
    just inserts a Tab (or spaces).
    
    """
    c = lydocument.cursor(cursor)
    indenter(cursor.document()).increase_indent(c)

def decrease_indent(cursor):
    """Decreases the indent of the line the cursor is at (or the selected lines)."""
    c = lydocument.cursor(cursor)
    indenter(cursor.document()).decrease_indent(c)

def re_indent(cursor, indent_blank_lines=False):
    """Re-indents the selected region or the whole document.
    
    If indent_blank_lines is True, the indent of blank lines is made larger 
    if necessary. If False (the default), the indent of blank lines if not 
    changed if it is shorter than it should be.
    
    """
    c = lydocument.cursor(cursor, select_all=True)
    indenter(cursor.document()).indent(c, indent_blank_lines)


########NEW FILE########
__FILENAME__ = info
# -*- coding: utf-8 -*-
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Information about the Frescobaldi application.
"""

from __future__ import unicode_literals

# these variables are also used by the distutils setup
name = "frescobaldi"
version = "2.0.16-dev"
description = "LilyPond Music Editor"
long_description = \
    "Frescobaldi is an advanced text editor to edit LilyPond sheet music files. " \
    "Features include an integrated PDF preview and a powerful Score Wizard."
maintainer = "Wilbert Berendsen"
maintainer_email = "info@frescobaldi.org"
domain = "frescobaldi.org"
url = "http://www.{0}/".format(domain)
license = "GPL"

# this one is used everywhere in the application
appname = "Frescobaldi"

########NEW FILE########
__FILENAME__ = inputdialog
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Simple dialogs to ask input from the user.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSettings, Qt
from PyQt4.QtGui import QCompleter, QColor, QColorDialog, QWidget

import app
import widgets.dialog
import userguide


def getText(
        parent = None,
        title = "",
        message = "",
        text = "",
        icon = None,
        help = None,
        validate = None,
        regexp = None,
        wordWrap = True,
        complete = None,
        ):
    """Asks a string of text from the user.
    
    Arguments:
    
    parent: parent widget or None
    title: dialog window title (without appname)
    message: message, question
    text: pre-entered text in the line edit
    icon: which icon to show
    help: help page or name
    validate: a function that accepts text and returns whether it is valid.
    regexp: a regular expression string. If given it provides an alternate
        validation method using a QRegExpValidator.
    wordWrap: whether to word-wrap the message text (default: True).
    complete: a string list or QAbstractItemModel to provide completions.
    
    """    
    dlg = widgets.dialog.TextDialog(parent,
        title=app.caption(title), message=message, icon=icon)
    dlg.setText(text)
    dlg.setMinimumWidth(320)
    dlg.messageLabel().setWordWrap(wordWrap)
    if help is not None:
        userguide.addButton(dlg.buttonBox(), help)
        dlg.setWindowModality(Qt.WindowModal)
    else:
        dlg.setWindowModality(Qt.ApplicationModal)
    if regexp:
        dlg.setValidateRegExp(regexp)
    elif validate:
        dlg.setValidateFunction(validate)
    if complete:
        c = QCompleter(complete, dlg.lineEdit())
        dlg.lineEdit().setCompleter(c)
    if dlg.exec_():
        return dlg.text()


def getColor(
        parent = None,
        title = "",
        color = None,
        alpha = False,
        ):
    """Ask the user a color."""
    global _savedColor
    if color is None:
        color = _savedColor
    dlg = QColorDialog(color, parent)
    options = QColorDialog.ColorDialogOptions()
    if alpha:
        options |= QColorDialog.ShowAlphaChannel
    if not QSettings().value("native_dialogs/colordialog", True, bool):
        options |= QColorDialog.DontUseNativeDialog
    dlg.setOptions(options)
    dlg.setWindowTitle(title or app.caption(_("Select Color")))
    if dlg.exec_():
        _savedColor = dlg.selectedColor()
        return _savedColor

_savedColor = QColor(Qt.white)



########NEW FILE########
__FILENAME__ = update
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Performs upgrades in the settings structure.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSettings

import info

def update(version):
    """Call subroutines listed below for version upgrades."""
    
    if version < 1:
        moveSettingsToNewRoot()
    
    # ... add other setting updates here...
    


def moveSettingsToNewRoot():
    """Move all settings to one application file."""
    movelist = [[info.name, info.url, False], "metainfo", "snippets", "sessions", "sessiondata"]
    for moveitem in movelist:
        if isinstance(moveitem, basestring):
            moveitem = [moveitem, info.name, True]
        o = QSettings(moveitem[1], moveitem[0])
        o.setFallbacksEnabled(False)
        keys = o.allKeys()
        if len(keys) > 0:
            s = QSettings()
            if moveitem[2]:
                s.beginGroup(moveitem[0])
            for k in keys:
                s.setValue(k, o.value(k))
            o.clear()
    

########NEW FILE########
__FILENAME__ = job
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A Job runs LilyPond (or another process) and captures the output
to get it later or to have a log follow it.
"""

from __future__ import unicode_literals

import codecs
import os
import time

from PyQt4.QtCore import QCoreApplication, QProcess

try:
    from PyQt4.QtCore import QProcessEnvironment # only in Qt >= 4.6
except ImportError:
    QProcessEnvironment = None

import signals


# message status:
STDOUT  = 1
STDERR  = 2
NEUTRAL = 4
SUCCESS = 8
FAILURE = 16

# output from the process
OUTPUT = STDERR | STDOUT

# status messages
STATUS = NEUTRAL | SUCCESS | FAILURE

# all
ALL = OUTPUT | STATUS


class Job(object):
    """Manages a process.
    
    Set the command attribute to a list of strings describing the program and
    its arguments.
    Set the directory attribute to a working directory.
    The environment attribute is a dictionary; if you set an item it will be
    added to the environment for the process (the rest will be inherited from
    the system); if you set an item to None, it will be unset.
    
    Call start() to start the process.
    The output() signal emits output (stderr or stdout) from the process.
    The done() signal is always emitted when the process has ended.
    The history() method returns all status messages and output so far.
    
    When the process has finished, the error and success attributes are set.
    The success attribute is set to True When the process exited normally and
    successful. When the process did not exit normally and successfully, the
    error attribute is set to the QProcess.ProcessError value that occurred
    last. Before start(), error and success both are None.
    
    The status messages and output all are in one of five categories:
    STDERR, STDOUT (output from the process) or NEUTRAL, FAILURE or SUCCESS
    (status messages). When displaying these messages in a log, it is advised
    to take special care for newlines, esp when a status message is displayed.
    Status messages normally have no newlines, so you must add them if needed,
    while output coming from the process may continue in the same line.
    
    """
    output = signals.Signal()
    done = signals.Signal()
    titleChanged = signals.Signal() # title (string)
    
    def __init__(self):
        self.command = []
        self.directory = ""
        self.environment = {}
        self.success = None
        self.error = None
        self._title = ""
        self._aborted = False
        self._process = None
        self._history = []
        self._starttime = 0.0
        self._elapsed = 0.0
        self.decoder_stdout = self.createDecoder(STDOUT)
        self.decoder_stderr = self.createDecoder(STDERR)
        self.errors = 'strict'  # codecs error handling
    
    def createDecoder(self, channel):
        """Should return a decoder for the given channel (STDOUT/STDERR).
        
        This decoder is then used to decode the 8bit bytestrings into Python
        unicode strings. The default implementation returns a 'latin1'
        decoder for both channels.
        
        """
        return codecs.getdecoder('latin1')
        
    def title(self):
        """Returns the job title, set with setTitle(), defaults to an empty string."""
        return self._title
        
    def setTitle(self, title):
        """Sets the title and if changed, emits the titleChanged(title) signal."""
        old, self._title = self._title, title
        if title != old:
            self.titleChanged(title)
    
    def start(self):
        """Starts the process."""
        self.success = None
        self.error = None
        self._aborted = False
        self._history = []
        self._elapsed = 0.0
        self._starttime = time.time()
        if self._process is None:
            self.setProcess(QProcess())
        self.startMessage()
        if os.path.isdir(self.directory):
            self._process.setWorkingDirectory(self.directory)
        if self.environment:
            self._updateProcessEnvironment()
        self._process.start(self.command[0], self.command[1:])
    
    def elapsed(self):
        """Returns how many seconds this process has been running."""
        if self._elapsed:
            return self._elapsed
        elif self._starttime:
            return time.time() - self._starttime
        return 0.0

    def abort(self):
        """Aborts the process."""
        if self._process:
            self._aborted = True
            self.abortMessage()
            if os.name == "nt":
                self._process.kill()
            else:
                self._process.terminate()
    
    def isAborted(self):
        """Returns True if the job was aborted by calling abort()."""
        return self._aborted
        
    def isRunning(self):
        """Returns True if this job is running."""
        return bool(self._process)
    
    def failedToStart(self):
        """Return True if the process failed to start.
        
        (Call this method after the process has finished.)
        
        """
        return self.error == QProcess.FailedToStart
    
    def setProcess(self, process):
        """Sets a QProcess instance and connects the signals."""
        self._process = process
        if process.parent() is None:
            process.setParent(QCoreApplication.instance())
        process.finished.connect(self._finished)
        process.error.connect(self._error)
        process.readyReadStandardError.connect(self._readstderr)
        process.readyReadStandardOutput.connect(self._readstdout)
    
    if QProcessEnvironment is not None:
        # use the preferred method (Qt >= 4.6)
        def _updateProcessEnvironment(self):
            """Called internally; initializes the environment for the process."""
            se = QProcessEnvironment.systemEnvironment()
            for k, v in self.environment.items():
                se.remove(k) if v is None else se.insert(k, v)
            self._process.setProcessEnvironment(se)
    else:
        # use the deprecated method (Qt < 4.6)
        def _updateProcessEnvironment(self):
            """Called internally; initializes the environment for the process."""
            env = dict(os.environ) # copy
            for k, v in self.environment.items():
                if v is None:
                    if k in env:
                        del env[k]
                else:
                    env[k] = v
            se = [k + '=' + v for k, v in env.items()]
            self._process.setEnvironment(se)
    
    def message(self, text, type=NEUTRAL):
        """Outputs some text as the given type (NEUTRAL, SUCCESS, FAILURE, STDOUT or STDERR)."""
        self.output(text, type)
        self._history.append((text, type))
        
    def history(self, types=ALL):
        """Yields the output messages as two-tuples (text, type) since the process started.
        
        If types is given, it should be an OR-ed combination of the status types
        STDERR, STDOUT, NEUTRAL, SUCCESS or FAILURE.
        
        """
        for msg, type in self._history:
            if type & types:
                yield msg, type
        
    def stdout(self):
        """Return the standard output of the process as unicode text."""
        return "".join(self.history(STDOUT))
    
    def stderr(self):
        """Return the standard error of the process as unicode text."""
        return "".join(self.history(STDERR))
    
    def _finished(self, exitCode, exitStatus):
        """Called when the process has finished."""
        self.finishMessage(exitCode, exitStatus)
        success = exitCode == 0 and exitStatus == QProcess.NormalExit
        self._bye(success)
        
    def _error(self, error):
        """Called when an error occurs."""
        self.errorMessage(error)
        if self._process.state() == QProcess.NotRunning:
            self._bye(False)
    
    def _bye(self, success):
        """Ends and emits the done() signal."""
        self._elapsed = time.time() - self._starttime
        if not success:
            self.error = self._process.error()
        self.success = success
        self._process.deleteLater()
        self._process = None
        self.done(success)
        
    def _readstderr(self):
        """Called when STDERR can be read."""
        output = self._process.readAllStandardError()
        self.message(self.decoder_stderr(output, self.errors)[0], STDERR)
        
    def _readstdout(self):
        """Called when STDOUT can be read."""
        output = self._process.readAllStandardOutput()
        self.message(self.decoder_stdout(output, self.errors)[0], STDOUT)

    def startMessage(self):
        """Outputs a message the process has started."""
        name = self.title() or os.path.basename(self.command[0])
        self.message(_("Starting {job}...").format(job=name), NEUTRAL)
    
    def abortMessage(self):
        """Outputs a message the process has been aborted."""
        name = self.title() or os.path.basename(self.command[0])
        self.message(_("Aborting {job}...").format(job=name), NEUTRAL)
    
    def errorMessage(self, error):
        """Outputs a message describing the given QProcess.Error."""
        if error == QProcess.FailedToStart:
            self.message(_(
                "Could not start {program}.\n"
                "Please check path and permissions.").format(program = self.command[0]), FAILURE)
        elif error == QProcess.ReadError:
            self.message(_("Could not read from the process."), FAILURE)
        elif self._process.state() == QProcess.NotRunning:
            self.message(_("An unknown error occured."), FAILURE)

    def finishMessage(self, exitCode, exitStatus):
        """Outputs a message on completion of the process."""
        if exitCode:
            self.message(_("Exited with return code {code}.").format(code=exitCode), FAILURE)
        elif exitStatus:
            self.message(_("Exited with exit status {status}.").format(status=exitStatus), FAILURE)
        else:
            time = elapsed2str(self.elapsed())
            self.message(_("Completed successfully in {time}.").format(time=time), SUCCESS)



def elapsed2str(seconds):
    """Returns a short display for the given time period (in seconds)."""
    minutes, seconds = divmod(seconds, 60)
    if minutes:
        return "{0:.0f}'{1:.0f}\"".format(minutes, seconds)
    return '{0:.1f}"'.format(seconds)



########NEW FILE########
__FILENAME__ = jobattributes
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages a collection of attributes that can be set on a Job.

E.g. from which mainwindow it was started, etc.
"""

import plugin


def get(job):
    """Returns the JobAttributes for the specified Job."""
    return JobAttributes.instance(job)


class JobAttributes(plugin.AttributePlugin):
    """Manages attributes of a Job.
    
    The attributes can be set simply as instance attributes.
    If possible, weak references are made so the attributes do not keep
    references to the objects they refer to.
    
    If an attribute is requested but not set, None is returned.
    
    Usage e.g.:
    
    attrs = jobattributes.get(job)
    attrs.mainwindow = mainwindow
    
    """
    def job(self):
        return self._parent()



########NEW FILE########
__FILENAME__ = jobmanager
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A JobManager exists for every Document, and ensures no two jobs are running
at the same time.

It also sends the app-wide signals jobStarted() and jobFinished().

"""

from __future__ import unicode_literals

import app
import plugin
import signals


def manager(document):
    return JobManager.instance(document)


def job(document):
    return JobManager.instance(document).job()


def isRunning(document):
    if job(document):
        return job(document).isRunning()
    return False


class JobManager(plugin.DocumentPlugin):
    
    started = signals.Signal()  # Job
    finished = signals.Signal() # Job, success
    
    def __init__(self, document):
        self._job = None
        
    def startJob(self, job):
        """Starts a Job on our behalf."""
        if not self.isRunning():
            self._job = job
            job.done.connect(self._finished)
            job.start()
            self.started(job)
            app.jobStarted(self.document(), job)
        
    def _finished(self, success):
        self.finished(job, success)
        app.jobFinished(self.document(), self._job, success)
    
    def job(self):
        """Returns the last job if any."""
        return self._job

    def isRunning(self):
        """Returns True when a job is running."""
        if self._job:
            return self._job.isRunning() and not self._job.isAborted()




########NEW FILE########
__FILENAME__ = data
#! python
# -*- coding: utf-8;

# Do not edit, this file is generated. See generate.py.

from __future__ import unicode_literals


language_names = {
"C": {
 "aa":"Afar",
 "ab":"Abkhazian",
 "ae":"Avestan",
 "af":"Afrikaans",
 "am":"Amharic",
 "ar":"Arabic",
 "as":"Assamese",
 "ast":"Asturian",
 "ay":"Aymara",
 "az":"Azerbaijani",
 "ba":"Bashkir",
 "be":"Belarusian",
 "be@latin":"Belarusian (Latin)",
 "bg":"Bulgarian",
 "bh":"Bihari",
 "bi":"Bislama",
 "bn":"Bengali",
 "bn_IN":"Bengali (India)",
 "bo":"Tibetan",
 "br":"Breton",
 "bs":"Bosnian",
 "ca":"Catalan",
 "ca@valencia":"Catalan (Valencian)",
 "ce":"Chechen",
 "ch":"Chamorro",
 "co":"Corsican",
 "crh":"Crimean Tatar",
 "cs":"Czech",
 "csb":"Kashubian",
 "cu":"Church Slavic",
 "cv":"Chuvash",
 "cy":"Welsh",
 "da":"Danish",
 "de":"German",
 "dsb":"Lower Sorbian",
 "dz":"Dzongkha",
 "el":"Greek",
 "en":"English",
 "en_GB":"British English",
 "en_US":"American English",
 "eo":"Esperanto",
 "es":"Spanish",
 "et":"Estonian",
 "eu":"Basque",
 "fa":"Farsi (Persian)",
 "fi":"Finnish",
 "fj":"Fijian",
 "fo":"Faroese",
 "fr":"French",
 "fy":"Frisian",
 "ga":"Irish Gaelic",
 "gd":"Gaelic",
 "gl":"Galician",
 "gn":"Guarani",
 "gu":"Gujarati",
 "gv":"Manx",
 "ha":"Hausa",
 "he":"Hebrew",
 "hi":"Hindi",
 "hne":"Chhattisgarhi",
 "ho":"Hiri Motu",
 "hr":"Croatian",
 "hsb":"Upper Sorbian",
 "hu":"Hungarian",
 "hy":"Armenian",
 "hz":"Herero",
 "ia":"Interlingua",
 "id":"Indonesian",
 "ie":"Interlingue",
 "ik":"Inupiaq",
 "io":"Ido",
 "is":"Icelandic",
 "it":"Italian",
 "iu":"Inuktitut",
 "ja":"Japanese",
 "jv":"Javanese",
 "ka":"Georgian",
 "ki":"Kikuyu",
 "kk":"Kazakh",
 "kl":"Kalaallisut",
 "km":"Khmer",
 "kn":"Kannada",
 "ko":"Korean",
 "ks":"Kashmiri",
 "ku":"Kurdish",
 "kv":"Komi",
 "kw":"Cornish",
 "ky":"Kirghiz",
 "la":"Latin",
 "lb":"Luxembourgish",
 "li":"Limburgan",
 "ln":"Lingala",
 "lo":"Lao",
 "lt":"Lithuanian",
 "lv":"Latvian",
 "mai":"Maithili",
 "mg":"Malagasy",
 "mh":"Marshallese",
 "mi":"Maori",
 "mk":"Macedonian",
 "ml":"Malayalam",
 "mn":"Mongolian",
 "mo":"Moldavian",
 "mr":"Marathi",
 "ms":"Malay",
 "mt":"Maltese",
 "my":"Burmese",
 "na":"Nauru",
 "nb":"Norwegian Bokmål",
 "nd":"Ndebele, North",
 "nds":"Low Saxon",
 "ne":"Nepali",
 "ng":"Ndonga",
 "nl":"Dutch",
 "nn":"Norwegian Nynorsk",
 "nr":"Ndebele, South",
 "nso":"Northern Sotho",
 "nv":"Navajo",
 "ny":"Chichewa",
 "oc":"Occitan",
 "om":"Oromo",
 "or":"Oriya",
 "os":"Ossetian",
 "pa":"Punjabi/Panjabi",
 "pi":"Pali",
 "pl":"Polish",
 "ps":"Pushto",
 "pt":"Portuguese",
 "pt_BR":"Brazilian Portuguese",
 "qu":"Quechua",
 "rn":"Rundi",
 "ro":"Romanian",
 "rom":"Romany",
 "ru":"Russian",
 "rw":"Kinyarwanda",
 "sa":"Sanskrit",
 "sc":"Sardinian",
 "sd":"Sindhi",
 "se":"Northern Sami",
 "sg":"Sango",
 "si":"Sinhala",
 "sk":"Slovak",
 "sl":"Slovenian",
 "sm":"Samoan",
 "sn":"Shona",
 "so":"Somali",
 "sq":"Albanian",
 "sr":"Serbian",
 "sr@ijekavian":"Serbian Ijekavian",
 "sr@ijekavianlatin":"Serbian Ijekavian Latin",
 "sr@latin":"Serbian Latin",
 "ss":"Swati",
 "st":"Sotho, Southern",
 "su":"Sundanese",
 "sv":"Swedish",
 "sw":"Swahili",
 "ta":"Tamil",
 "te":"Telugu",
 "tg":"Tajik",
 "th":"Thai",
 "ti":"Tigrinya",
 "tk":"Turkmen",
 "tn":"Tswana",
 "to":"Tonga",
 "tr":"Turkish",
 "ts":"Tsonga",
 "tt":"Tatar",
 "tw":"Twi",
 "ty":"Tahitian",
 "ug":"Uyghur",
 "uk":"Ukrainian",
 "ur":"Urdu",
 "uz":"Uzbek",
 "uz@cyrillic":"Uzbek (Cyrillic)",
 "ven":"Venda",
 "vi":"Vietnamese",
 "vo":"Volapük",
 "wa":"Walloon",
 "wo":"Wolof",
 "xh":"Xhosa",
 "yi":"Yiddish",
 "yo":"Yoruba",
 "za":"Zhuang",
 "zh":"Chinese",
 "zh_CN":"Chinese Simplified",
 "zh_HK":"Chinese (Hong Kong)",
 "zh_TW":"Chinese Traditional",
 "zu":"Zulu",
},
"cs": {
 "aa":"Afar",
 "ab":"Abcházský",
 "ae":"Avestánský",
 "af":"Afrikánský",
 "am":"Amharský",
 "ar":"Arabský",
 "as":"Asamský",
 "ast":"Asturijský",
 "ay":"Aymara",
 "az":"Ázerbajdžánský",
 "ba":"Baškirský",
 "be":"Běloruský",
 "be@latin":"Běloruský (latinka)",
 "bg":"Bulharský",
 "bh":"Bihari",
 "bi":"Bislama",
 "bn":"Bengálský",
 "bn_IN":"Bengálský (Indie)",
 "bo":"Tibetský",
 "br":"Bretonský",
 "bs":"Bosenský",
 "ca":"Katalánský",
 "ca@valencia":"Katalánský (Valencie)",
 "ce":"Čečenský",
 "ch":"Chamorro",
 "co":"Korsický",
 "crh":"Krymská tatarština",
 "cs":"Český",
 "csb":"Kašubský",
 "cu":"Staroslověnský",
 "cv":"Čuvašský",
 "cy":"Welšský",
 "da":"Dánský",
 "de":"Německý",
 "dsb":"Dolnolužicko srbský",
 "dz":"Dzongkha",
 "el":"Řecký",
 "en":"Anglický",
 "en_GB":"Britská angličtina",
 "en_US":"Americká angličtina",
 "eo":"Esperanto",
 "es":"Španělský",
 "et":"Estonský",
 "eu":"Baskický",
 "fa":"Farsi (Perský)",
 "fi":"Finský",
 "fj":"Fidžijský",
 "fo":"Faerský",
 "fr":"Francouzský",
 "fy":"Fríský",
 "ga":"Galský (irština)",
 "gd":"Galský",
 "gl":"Galicijský",
 "gn":"Guarani",
 "gu":"Gujarati",
 "gv":"Manx",
 "ha":"Hausa",
 "he":"Hebrejský",
 "hi":"Hindský",
 "hne":"Chhattisgarhi",
 "ho":"Hiri Motu",
 "hr":"Chorvatský",
 "hsb":"Hornolužicko srbský",
 "hu":"Maďarský",
 "hy":"Arménský",
 "hz":"Herero",
 "ia":"Interlingua",
 "id":"Indonéský",
 "ie":"Interlingue",
 "ik":"Inupiaq",
 "io":"Ido",
 "is":"Islandský",
 "it":"Italský",
 "iu":"Inuktitut",
 "ja":"Japonský",
 "jv":"Jávský",
 "ka":"Gruzínský",
 "ki":"Kikuyu",
 "kk":"Kazašský",
 "kl":"Kalaallisut",
 "km":"Kmérský",
 "kn":"Kannada",
 "ko":"Korejský",
 "ks":"Kašmírský",
 "ku":"Kurdský",
 "kv":"Komi",
 "kw":"Kornišský",
 "ky":"Kyrgizský",
 "la":"Latina",
 "lb":"Lucemburský",
 "li":"Limburgan",
 "ln":"Lingala",
 "lo":"Laoský",
 "lt":"Litevský",
 "lv":"Lotyšský",
 "mai":"Maithili",
 "mg":"Malagasy",
 "mh":"Marshallský",
 "mi":"Maorský",
 "mk":"Makedonský",
 "ml":"Malayalam",
 "mn":"Mongolský",
 "mo":"Moldavský",
 "mr":"Marathi",
 "ms":"Malajský",
 "mt":"Maltézský",
 "my":"Burmský",
 "na":"Nauru",
 "nb":"Norský (Bokmål)",
 "nd":"Ndebele, Severní",
 "nds":"Dolnosaský",
 "ne":"Nepálský",
 "ng":"Ndonga",
 "nl":"Holandský",
 "nn":"Norský (Nynorsk)",
 "nr":"Ndebele, Jižní",
 "nso":"Severní Sotho",
 "nv":"Navajo",
 "ny":"Chichewa",
 "oc":"Okcitánský",
 "om":"Oromo",
 "or":"Oriya",
 "os":"Osetský",
 "pa":"Pandžábský",
 "pi":"Pali",
 "pl":"Polský",
 "ps":"Pushto",
 "pt":"Portugalský",
 "pt_BR":"Portugalský (Brazílie)",
 "qu":"Quechua",
 "rn":"Rundi",
 "ro":"Rumunský",
 "rom":"Romský",
 "ru":"Ruský",
 "rw":"Kinyarwanda",
 "sa":"Sanskrit",
 "sc":"Sardinský",
 "sd":"Sindhi",
 "se":"Severní Sami",
 "sg":"Sango",
 "si":"Sinhalský",
 "sk":"Slovenský",
 "sl":"Slovinský",
 "sm":"Samojský",
 "sn":"Shona",
 "so":"Somálský",
 "sq":"Albánský",
 "sr":"Srbský",
 "sr@ijekavian":"Srbský Ijekavský",
 "sr@ijekavianlatin":"Srbský (Ijekavská latinka)",
 "sr@latin":"Srbský (latinka)",
 "ss":"Swati",
 "st":"Sotho, Jižní",
 "su":"Sundanský",
 "sv":"Švédský",
 "sw":"Svahilský",
 "ta":"Tamilský",
 "te":"Telugu",
 "tg":"Tádžikský",
 "th":"Thajský",
 "ti":"Tigrinya",
 "tk":"Turkmenský",
 "tn":"Tswana",
 "to":"Tonga",
 "tr":"Turecký",
 "ts":"Tsonga",
 "tt":"Tatarský",
 "tw":"Twi",
 "ty":"Tahitský",
 "ug":"Ujgurský",
 "uk":"Ukrajinský",
 "ur":"Urdu",
 "uz":"Uzbecký",
 "uz@cyrillic":"Uzbecký (azbuka)",
 "ven":"Venda",
 "vi":"Vietnamský",
 "vo":"Volapük",
 "wa":"Wallonský",
 "wo":"Wolof",
 "xh":"Xhosa",
 "yi":"Jidiš",
 "yo":"Yoruba",
 "za":"Zhuang",
 "zh":"Čínský",
 "zh_CN":"Čínský (zjednodušená)",
 "zh_HK":"Čínský (Hong Kong)",
 "zh_TW":"Čínský (tradiční)",
 "zu":"Zulu",
},
"de": {
 "aa":"Afar",
 "ab":"Abhasisch",
 "ae":"Avestisch",
 "af":"Afrikaans",
 "am":"Amharisch",
 "ar":"Arabisch",
 "as":"Assamesisch",
 "ast":"Asturisch",
 "ay":"Aimara",
 "az":"Aserbaidschanisch",
 "ba":"Baschkirisch",
 "be":"Weißrussisch",
 "be@latin":"Weißrussisch (lat. Alphabet)",
 "bg":"Bulgarisch",
 "bh":"Biharisch",
 "bi":"Bislama",
 "bn":"Bengalisch",
 "bn_IN":"Bengalisch (Indien)",
 "bo":"Tibetisch",
 "br":"Bretonisch",
 "bs":"Bosnisch",
 "ca":"Katalanisch",
 "ca@valencia":"Katalanisch (Valenciana)",
 "ce":"Tschetschenisch",
 "ch":"Chamorro",
 "co":"Korsisch",
 "crh":"Krimtatarisch",
 "cs":"Tschechisch",
 "csb":"Kaschubisch",
 "cu":"Kirchenslawisch",
 "cv":"Tschuwaschisch",
 "cy":"Walisisch",
 "da":"Dänisch",
 "de":"Deutsch",
 "dsb":"Niedersorbisch",
 "dz":"Dzongkha",
 "el":"Griechisch",
 "en":"Englisch",
 "en_GB":"Englisch (UK)",
 "en_US":"Englisch (US)",
 "eo":"Esperanto",
 "es":"Spanisch",
 "et":"Estnisch",
 "eu":"Baskisch",
 "fa":"Farsi (Persisch)",
 "fi":"Finnisch",
 "fj":"Fidschi",
 "fo":"Färöisch",
 "fr":"Französisch",
 "fy":"Friesisch",
 "ga":"Irisches Gälisch",
 "gd":"Gälisch",
 "gl":"Galicisch",
 "gn":"Guarani",
 "gu":"Gujarati",
 "gv":"Manx",
 "ha":"Hausa",
 "he":"Hebräisch",
 "hi":"Hindi",
 "hne":"Chhattisgarhi",
 "ho":"Hiri Motu",
 "hr":"Kroatisch",
 "hsb":"Obersorbisch",
 "hu":"Ungarisch",
 "hy":"Armenisch",
 "hz":"Herero",
 "ia":"Interlingua",
 "id":"Indonesisch",
 "ie":"Interlingue",
 "ik":"Inupiaq",
 "io":"Ido",
 "is":"Isländisch",
 "it":"Italienisch",
 "iu":"Inuktitut",
 "ja":"Japanisch",
 "jv":"Javanisch",
 "ka":"Georgisch",
 "ki":"Kikuyu",
 "kk":"Kasachisch",
 "kl":"Kalaallisut",
 "km":"Khmer",
 "kn":"Kannada",
 "ko":"Koreanisch",
 "ks":"Kashmiri",
 "ku":"Kurdisch",
 "kv":"Komi",
 "kw":"Kornisch",
 "ky":"Kirgisisch",
 "la":"Latein",
 "lb":"Luxemburgisch",
 "li":"Limburgisch",
 "ln":"Lingala",
 "lo":"Laotisch",
 "lt":"Litauisch",
 "lv":"Lettisch",
 "mai":"Maithili",
 "mg":"Madagassisch",
 "mh":"Marshallisch",
 "mi":"Maori",
 "mk":"Mazedonisch",
 "ml":"Malayalam",
 "mn":"Mongolisch",
 "mo":"Moldawisch",
 "mr":"Marathi",
 "ms":"Malaiisch",
 "mt":"Maltesisch",
 "my":"Burmesisch",
 "na":"Nauruisch",
 "nb":"Norwegisch (Bokmål)",
 "nd":"Ndebele (nördliches)",
 "nds":"Niederdeutsch",
 "ne":"Nepali",
 "ng":"Oshivambo",
 "nl":"Niederländisch",
 "nn":"Norwegisch (Nynorsk)",
 "nr":"Ndebele (südliches)",
 "nso":"Nord-Sotho",
 "nv":"Navajo",
 "ny":"Nyanja",
 "oc":"Okzitanisch",
 "om":"Oromo",
 "or":"Oriya",
 "os":"Ossetisch",
 "pa":"Pandschabi",
 "pi":"Pali",
 "pl":"Polnisch",
 "ps":"Paschtu",
 "pt":"Portugiesisch",
 "pt_BR":"Brasilianisches Portugiesisch",
 "qu":"Quechua",
 "rn":"Rundi",
 "ro":"Rumänisch",
 "rom":"Romani",
 "ru":"Russisch",
 "rw":"Kinyarwanda",
 "sa":"Sanskrit",
 "sc":"Sardisch",
 "sd":"Sindhi",
 "se":"Nördliches Sami",
 "sg":"Sango",
 "si":"Singhalesisch",
 "sk":"Slowakisch",
 "sl":"Slowenisch",
 "sm":"Samoanisch",
 "sn":"Shona",
 "so":"Somali",
 "sq":"Albanisch",
 "sr":"Serbisch",
 "sr@ijekavian":"Štokavisch",
 "sr@ijekavianlatin":"Štokavisch (lat. Alphabet)",
 "sr@latin":"Serbisch (lat. Alphabet)",
 "ss":"Swati",
 "st":"Südliches Sotho",
 "su":"Sundanesisch",
 "sv":"Schwedisch",
 "sw":"Swahili",
 "ta":"Tamil",
 "te":"Telugu",
 "tg":"Tadschikisch",
 "th":"Thailändisch",
 "ti":"Tigrinja",
 "tk":"Turkmenisch",
 "tn":"Tswana",
 "to":"Tonga",
 "tr":"Türkisch",
 "ts":"Tsonga",
 "tt":"Tatarisch",
 "tw":"Twi",
 "ty":"Tahitianisch",
 "ug":"Uigurisch",
 "uk":"Ukrainisch",
 "ur":"Urdu",
 "uz":"Usbekisch",
 "uz@cyrillic":"Usbekisch (Kyrillisch)",
 "ven":"Tshivenda",
 "vi":"Vietnamesisch",
 "vo":"Volapük",
 "wa":"Wallonisch",
 "wo":"Wolof",
 "xh":"Xhosa",
 "yi":"Jiddish",
 "yo":"Yoruba",
 "za":"Zhuang",
 "zh":"Chinesisch",
 "zh_CN":"Chinesisch (Kurzzeichen)",
 "zh_HK":"Chinesisch (Hongkong)",
 "zh_TW":"Chinesisch (Langzeichen)",
 "zu":"Zulu",
},
"es": {
 "aa":"Afar",
 "ab":"Abjaso",
 "ae":"Avéstico",
 "af":"Afrikaans",
 "am":"Amárico",
 "ar":"Árabe",
 "as":"Asamés",
 "ast":"Asturiano",
 "ay":"Aymara",
 "az":"Azerbayano",
 "ba":"Baskir",
 "be":"Bielorruso",
 "be@latin":"Bielorruso (Latino)",
 "bg":"Búlgaro",
 "bh":"Bihari",
 "bi":"Bislama",
 "bn":"Bengalí",
 "bn_IN":"Bengalí (India)",
 "bo":"Tibetano",
 "br":"Bretón",
 "bs":"Bosnio",
 "ca":"Catalán",
 "ca@valencia":"Catalán (Valenciano)",
 "ce":"Checheno",
 "ch":"Chamorro",
 "co":"Corso",
 "crh":"Tártaro de Crimea",
 "cs":"Checo",
 "csb":"Casubio",
 "cu":"Eslavo eclesiástico",
 "cv":"Chuvasio",
 "cy":"Galés",
 "da":"Danés",
 "de":"Alemán",
 "dsb":"Bajo sorabo",
 "dz":"Dzongkha",
 "el":"Griego",
 "en":"Inglés",
 "en_GB":"Inglés británico",
 "en_US":"Inglés americano",
 "eo":"Esperanto",
 "es":"Español",
 "et":"Estonio",
 "eu":"Euskera",
 "fa":"Persa",
 "fi":"Finés",
 "fj":"Fiyiano",
 "fo":"Feroés",
 "fr":"Francés",
 "fy":"Frisio",
 "ga":"Gaélico irlandés",
 "gd":"Gaélico",
 "gl":"Gallego",
 "gn":"Guaraní",
 "gu":"Gujarati",
 "gv":"Manés",
 "ha":"Hausa",
 "he":"Hebreo",
 "hi":"Hindi",
 "hne":"Chhattisgarhi",
 "ho":"Hiri Motu",
 "hr":"Croata",
 "hsb":"Alto sorabo",
 "hu":"Húngaro",
 "hy":"Armenio",
 "hz":"Herero",
 "ia":"Interlingua",
 "id":"Indonesio",
 "ie":"Idioma occidental",
 "ik":"Inupiaq",
 "io":"Ido",
 "is":"Islandés",
 "it":"Italiano",
 "iu":"Inuktitut",
 "ja":"Japonés",
 "jv":"Javanés",
 "ka":"Georgiano",
 "ki":"Kikuyu",
 "kk":"Kazajo",
 "kl":"Kalaallisut",
 "km":"Camboyano",
 "kn":"Kannada",
 "ko":"Coreano",
 "ks":"Kashmiri",
 "ku":"Kurdo",
 "kv":"Komi",
 "kw":"Cornuallés",
 "ky":"Kirguiz",
 "la":"Latín",
 "lb":"Luxemburgués",
 "li":"Limburgano",
 "ln":"Lingala",
 "lo":"Laosiano",
 "lt":"Lituano",
 "lv":"Letón",
 "mai":"Maithili",
 "mg":"Malagasio",
 "mh":"Marshalés",
 "mi":"Maorí",
 "mk":"Macedonio",
 "ml":"Malabar",
 "mn":"Mongol",
 "mo":"Moldavo",
 "mr":"Maratí",
 "ms":"Malayo",
 "mt":"Maltés",
 "my":"Burmés",
 "na":"Nauru",
 "nb":"Noruego Bokmål",
 "nd":"Ndebele del norte",
 "nds":"Bajo sajón",
 "ne":"Nepalí",
 "ng":"Ndonga",
 "nl":"Holandés",
 "nn":"Noruego Nynorsk",
 "nr":"Ndebele del sur",
 "nso":"Sotho del norte",
 "nv":"Navajo",
 "ny":"Chichewa",
 "oc":"Occitano",
 "om":"Oromo",
 "or":"Oriya",
 "os":"Osetio",
 "pa":"Punjabi",
 "pi":"Palí",
 "pl":"Polaco",
 "ps":"Pastún",
 "pt":"Portugués",
 "pt_BR":"Portugués brasileño",
 "qu":"Quechua",
 "rn":"Rundi",
 "ro":"Rumano",
 "rom":"Rumaní",
 "ru":"Ruso",
 "rw":"Kinyarwanda",
 "sa":"Sánscrito",
 "sc":"Sardo",
 "sd":"Sindhi",
 "se":"Samí del norte",
 "sg":"Sango",
 "si":"Cingalés",
 "sk":"Eslovaco",
 "sl":"Esloveno",
 "sm":"Samoano",
 "sn":"Shona",
 "so":"Somalí",
 "sq":"Albanés",
 "sr":"Serbio",
 "sr@ijekavian":"Serbio ijekaviano",
 "sr@ijekavianlatin":"Serbio latino ijekaviano",
 "sr@latin":"Serbio latino",
 "ss":"Swati",
 "st":"Sotho del sur",
 "su":"Sudanés",
 "sv":"Sueco",
 "sw":"Suahili",
 "ta":"Tamil",
 "te":"Telugu",
 "tg":"Tayiko",
 "th":"Tailandés",
 "ti":"Tigrinya",
 "tk":"Turkmenio",
 "tn":"Tswana",
 "to":"Tonga",
 "tr":"Turco",
 "ts":"Tsonga",
 "tt":"Tatar",
 "tw":"Twi",
 "ty":"Tahitiano",
 "ug":"Uigur",
 "uk":"Ucraniano",
 "ur":"Urdu",
 "uz":"Uzbeko",
 "uz@cyrillic":"Uzbeko (Cirílico)",
 "ven":"Venda",
 "vi":"Vietnamita",
 "vo":"Volapük",
 "wa":"Walloon",
 "wo":"Wolof",
 "xh":"Xhosa",
 "yi":"Yiddish",
 "yo":"Yoruba",
 "za":"Zhuang",
 "zh":"Chino",
 "zh_CN":"Chino simplificado",
 "zh_HK":"Chino (Hong Kong)",
 "zh_TW":"Chino tradicional",
 "zu":"Zulú",
},
"fr": {
 "aa":"Afar",
 "ab":"Abkhaze",
 "ae":"Avestan",
 "af":"Afrikaans",
 "am":"Amharique",
 "ar":"Arabe",
 "as":"Assamais",
 "ast":"Asturien",
 "ay":"Aymara",
 "az":"Azerbaïdjanais",
 "ba":"Bachkir",
 "be":"Biélorusse",
 "be@latin":"Biélorusse (Latin)",
 "bg":"Bulgare",
 "bh":"Bihari",
 "bi":"Bichlamar",
 "bn":"Bengalî",
 "bn_IN":"Bengali (Inde)",
 "bo":"Tibétain",
 "br":"Breton",
 "bs":"Bosniaque",
 "ca":"Catalan",
 "ca@valencia":"Catalan (Valence)",
 "ce":"Tchétchène",
 "ch":"Chamorro",
 "co":"Corse",
 "crh":"Tatars de Crimée",
 "cs":"Tchèque",
 "csb":"Kachoube",
 "cu":"Vieux-slave liturgique",
 "cv":"Tchouvache",
 "cy":"Gallois",
 "da":"Danois",
 "de":"Allemand",
 "dsb":"Bas-Sorabe",
 "dz":"Dzongkha",
 "el":"Grec",
 "en":"Anglais",
 "en_GB":"Anglais britannique",
 "en_US":"Anglais américain",
 "eo":"Espéranto",
 "es":"Espagnol",
 "et":"Estonien",
 "eu":"Basque",
 "fa":"Persan",
 "fi":"Finnois",
 "fj":"Fidjien",
 "fo":"Féroïen",
 "fr":"Français",
 "fy":"Frison",
 "ga":"Gaélique irlandais",
 "gd":"Gaélique",
 "gl":"Galicien",
 "gn":"Guarani",
 "gu":"Gujarati",
 "gv":"Mannois",
 "ha":"Haoussa",
 "he":"Hébreu",
 "hi":"Hindi",
 "hne":"Chhattisgarhi",
 "ho":"Hiri motu",
 "hr":"Croate",
 "hsb":"Haut-Sorabe",
 "hu":"Hongrois",
 "hy":"Arménien",
 "hz":"Herero",
 "ia":"Interlingua",
 "id":"Indonésien",
 "ie":"Interlingue",
 "ik":"Inupiaq",
 "io":"Ido",
 "is":"Islandais",
 "it":"Italien",
 "iu":"Inuktitut",
 "ja":"Japonais",
 "jv":"Javanais",
 "ka":"Géorgien",
 "ki":"Kikuyu",
 "kk":"Kazakh",
 "kl":"Kalaallisut",
 "km":"Khmer",
 "kn":"Kannada",
 "ko":"Coréen",
 "ks":"Kashmiri",
 "ku":"Kurde",
 "kv":"Komi",
 "kw":"Cornique",
 "ky":"Kirghize",
 "la":"Latin",
 "lb":"Luxembourgeois",
 "li":"Limbourgeois",
 "ln":"Lingala",
 "lo":"Lao",
 "lt":"Lituanien",
 "lv":"Letton",
 "mai":"Maïthili",
 "mg":"Malgache",
 "mh":"Marshall",
 "mi":"Maori",
 "mk":"Macédonien",
 "ml":"Malayalam",
 "mn":"Mongol",
 "mo":"Moldave",
 "mr":"Marathe",
 "ms":"Malais",
 "mt":"Maltais",
 "my":"Birman",
 "na":"Nauruan",
 "nb":"Norvégien Bokmaal",
 "nd":"Ndébélé du Nord",
 "nds":"Bas saxon",
 "ne":"Népalais",
 "ng":"Ndonga",
 "nl":"Hollandais",
 "nn":"Norvégien Nynorsk",
 "nr":"Ndébélé du Sud",
 "nso":"Sotho du Nord",
 "nv":"Navaho",
 "ny":"Chichewa",
 "oc":"Occitan",
 "om":"Oromo",
 "or":"Oriya",
 "os":"Ossète",
 "pa":"Panjabi / Punjabi",
 "pi":"Pali",
 "pl":"Polonais",
 "ps":"Pushto",
 "pt":"Portugais",
 "pt_BR":"Portugais Brésilien",
 "qu":"Quechua",
 "rn":"Rundi",
 "ro":"Roumain",
 "rom":"Rromani",
 "ru":"Russe",
 "rw":"Kinyarwanda",
 "sa":"Sanskrit",
 "sc":"Sarde",
 "sd":"Sindhi",
 "se":"Sami du Nord",
 "sg":"Sango",
 "si":"Cingalais",
 "sk":"Slovaque",
 "sl":"Slovène",
 "sm":"Samoan",
 "sn":"Shona",
 "so":"Somali",
 "sq":"Albanais",
 "sr":"Serbe",
 "sr@ijekavian":"Serbe Ijékavien",
 "sr@ijekavianlatin":"Serbe Ijékavien Latin",
 "sr@latin":"Serbe Latin",
 "ss":"Swati",
 "st":"Sotho du Sud",
 "su":"Soudanais",
 "sv":"Suédois",
 "sw":"Swahili",
 "ta":"Tamoul",
 "te":"Télougou",
 "tg":"Tadjik",
 "th":"Thaïlandais",
 "ti":"Tigrigna",
 "tk":"Turkmène",
 "tn":"Tswana",
 "to":"Tonga",
 "tr":"Turc",
 "ts":"Tsonga",
 "tt":"Tatar",
 "tw":"Twi",
 "ty":"Tahitien",
 "ug":"Ouïghour",
 "uk":"Ukrainien",
 "ur":"Urdu",
 "uz":"Ouzbek",
 "uz@cyrillic":"Ouzbek (Cyrillique)",
 "ven":"Venda",
 "vi":"Vietnamien",
 "vo":"Volapük",
 "wa":"Wallon",
 "wo":"Wolof",
 "xh":"Xhosa",
 "yi":"Yiddish",
 "yo":"Yoruba",
 "za":"Zhuang",
 "zh":"Chinois",
 "zh_CN":"Chinois simplifié",
 "zh_HK":"Chinois (Hong Kong)",
 "zh_TW":"Chinois traditionnel",
 "zu":"Zoulou",
},
"gl": {
 "aa":"Afar",
 "ab":"Abxasio",
 "ae":"Avestaní",
 "af":"Africáner",
 "am":"Amhárico",
 "ar":"Árabe",
 "as":"Asamixa",
 "ast":"Asturiano",
 "ay":"Aimará",
 "az":"Azerí",
 "ba":"Bashquir",
 "be":"Bielorruso",
 "be@latin":"Bielorruso (latino)",
 "bg":"Búlgaro",
 "bh":"Bihari",
 "bi":"Bislama",
 "bn":"Bengalí",
 "bn_IN":"Bengalí (India)",
 "bo":"Tibetano",
 "br":"Bretón",
 "bs":"Bosnio",
 "ca":"Catalán",
 "ca@valencia":"Catalán (valenciano)",
 "ce":"Checheno",
 "ch":"Chamorro",
 "co":"Corso",
 "crh":"Tártaro da Crimea",
 "cs":"Checo",
 "csb":"Kashubí",
 "cu":"Eslavo eclesiástico",
 "cv":"Chuvash",
 "cy":"Galés",
 "da":"Dinamarqués",
 "de":"Alemán",
 "dsb":"Baixo sórabo",
 "dz":"Dzongca",
 "el":"Grego",
 "en":"Inglés",
 "en_GB":"Inglés británico",
 "en_US":"Inglés americano",
 "eo":"Esperanto",
 "es":"Castelán",
 "et":"Estoniano",
 "eu":"Basco",
 "fa":"Frisón (Parsi)",
 "fi":"Finlandés",
 "fj":"Fixiano",
 "fo":"Feroés",
 "fr":"Francés",
 "fy":"Frisio",
 "ga":"Gaélico irlandés",
 "gd":"Gaélico",
 "gl":"Galego",
 "gn":"Guaraní",
 "gu":"Guxarati",
 "gv":"Manés",
 "ha":"Hausa",
 "he":"Hebreu",
 "hi":"Hindi",
 "hne":"Chhattisgarhi",
 "ho":"Hiri Motu",
 "hr":"Croata",
 "hsb":"Alto sórabo",
 "hu":"Húngaro",
 "hy":"Armenio",
 "hz":"Herero",
 "ia":"Interlingua",
 "id":"Indonesio",
 "ie":"Interlingua",
 "ik":"Inupiaq",
 "io":"Ido",
 "is":"Islandés",
 "it":"Italiano",
 "iu":"Inuktitut",
 "ja":"Xaponés",
 "jv":"Xavanés",
 "ka":"Xeorxiano",
 "ki":"Kikuyu",
 "kk":"Cazaxo",
 "kl":"Groenlandés",
 "km":"Khmer",
 "kn":"Kannada",
 "ko":"Coreano",
 "ks":"Caxemir",
 "ku":"Kurdo",
 "kv":"Komi",
 "kw":"Córnico",
 "ky":"Quirguiz",
 "la":"Latín",
 "lb":"Luxemburgués",
 "li":"Limburgano",
 "ln":"Lingala",
 "lo":"Lao",
 "lt":"Lituano",
 "lv":"Letón",
 "mai":"Maithili",
 "mg":"Malgaxe",
 "mh":"Marshalés",
 "mi":"Maorí",
 "mk":"Macedonio",
 "ml":"Malaialam",
 "mn":"Mongol",
 "mo":"Moldavo",
 "mr":"Marata",
 "ms":"Malaio",
 "mt":"Maltés",
 "my":"Burmés",
 "na":"Nauru",
 "nb":"Noruegués Bokmål",
 "nd":"Ndebele do norte",
 "nds":"Baixo saxón",
 "ne":"Nepalí",
 "ng":"Ndonga",
 "nl":"Holandés",
 "nn":"Noruegués Nynorsk",
 "nr":"Ndebele do sur",
 "nso":"Sotho do norte",
 "nv":"Navaxo",
 "ny":"Chichewa",
 "oc":"Occitano",
 "om":"Oromo",
 "or":"Orisa",
 "os":"Oseto",
 "pa":"Punxabí/Panxabí",
 "pi":"Pali",
 "pl":"Polaco",
 "ps":"Pushto",
 "pt":"Portugués",
 "pt_BR":"Portugués do Brasil",
 "qu":"Quechua",
 "rn":"Rundi",
 "ro":"Romanés",
 "rom":"Romaní",
 "ru":"Ruso",
 "rw":"Quiñaruanda",
 "sa":"Sánscrito",
 "sc":"Sardo",
 "sd":"Sindhi",
 "se":"Sami do norte",
 "sg":"Sango",
 "si":"Sinhala",
 "sk":"Eslovaco",
 "sl":"Esloveno",
 "sm":"Samoano",
 "sn":"Shona",
 "so":"Somalí",
 "sq":"Albanés",
 "sr":"Serbio",
 "sr@ijekavian":"Serbio ixtocavio",
 "sr@ijekavianlatin":"Serbio ishtocavio Latino",
 "sr@latin":"Serbio latino",
 "ss":"Swati",
 "st":"Sotho do sur",
 "su":"Sudanés",
 "sv":"Sueco",
 "sw":"Swahili",
 "ta":"Tamil",
 "te":"Telugu",
 "tg":"Taxico",
 "th":"Tailandés",
 "ti":"Tigrignan",
 "tk":"Turquemeno",
 "tn":"Tswana",
 "to":"Tonga",
 "tr":"Turco",
 "ts":"Tsonga",
 "tt":"Tártaro",
 "tw":"Twi",
 "ty":"Tahitiano",
 "ug":"Uigur",
 "uk":"Ucraíno",
 "ur":"Urdú",
 "uz":"Usbeco",
 "uz@cyrillic":"Usbeco (cirílico)",
 "ven":"Venda",
 "vi":"Vietnamita",
 "vo":"Volapük",
 "wa":"Valón",
 "wo":"Wolof",
 "xh":"Xhosa",
 "yi":"Iídiche",
 "yo":"Yorubá",
 "za":"Chuan",
 "zh":"Chinés",
 "zh_CN":"Chinés simplificado",
 "zh_HK":"Chinés (Hong Kong)",
 "zh_TW":"Chinés tradicional",
 "zu":"Zulú",
},
"hu": {
 "aa":"Afar",
 "ab":"Abház",
 "ae":"Avesztáni",
 "af":"Afrikaans",
 "am":"Amhár",
 "ar":"Arab",
 "as":"Asszámi",
 "ast":"Asztúriai",
 "ay":"Ajmara",
 "az":"Azerbajdzsán",
 "ba":"Baskír",
 "be":"Belorusz",
 "be@latin":"Belorusz (latin betűs)",
 "bg":"Bolgár",
 "bh":"Bihari",
 "bi":"Biszlama",
 "bn":"Bengáli",
 "bn_IN":"Bengáli (India)",
 "bo":"Tibeti",
 "br":"Breton",
 "bs":"Bosnyák",
 "ca":"Katalán",
 "ca@valencia":"Katalán (valenciai)",
 "ce":"Csecsen",
 "ch":"Chamorro",
 "co":"Korzikai",
 "crh":"Krími tatár",
 "cs":"Cseh",
 "csb":"Kasub",
 "cu":"Szláv (egyházi)",
 "cv":"Csuvas",
 "cy":"Velszi",
 "da":"Dán",
 "de":"Német",
 "dsb":"Alsó szorb",
 "dz":"Dzongkha",
 "el":"Görög",
 "en":"Angol",
 "en_GB":"Angol (brit)",
 "en_US":"Angol (amerikai)",
 "eo":"Eszperantó",
 "es":"Spanyol",
 "et":"Észt",
 "eu":"Baszk",
 "fa":"Fárszi (perzsa)",
 "fi":"Finn",
 "fj":"Fidzsi",
 "fo":"Faröei",
 "fr":"Francia",
 "fy":"Fríz",
 "ga":"Gall (ír)",
 "gd":"Gall",
 "gl":"Galíciai",
 "gn":"Guarani",
 "gu":"Gudzsarati",
 "gv":"Manx",
 "ha":"Hausa",
 "he":"Héber",
 "hi":"Hindi",
 "hne":"Cshattíszgarhi",
 "ho":"Hiri motu",
 "hr":"Horvát",
 "hsb":"Felső szorb",
 "hu":"Magyar",
 "hy":"Örmény",
 "hz":"Hereró",
 "ia":"Interlingua",
 "id":"Indonéz",
 "ie":"Interlingue",
 "ik":"Inupiak",
 "io":"Ido",
 "is":"Izlandi",
 "it":"Olasz",
 "iu":"Inuktitut",
 "ja":"Japán",
 "jv":"Jávai",
 "ka":"Grúz",
 "ki":"Kikuju",
 "kk":"Kazah",
 "kl":"Kalaalliszut",
 "km":"Khmer",
 "kn":"Kannada",
 "ko":"Koreai",
 "ks":"Kasmír",
 "ku":"Kurd",
 "kv":"Komi",
 "kw":"Korn",
 "ky":"Kirgiz",
 "la":"Latin",
 "lb":"Luxemburgi",
 "li":"Limburgi",
 "ln":"Lingala",
 "lo":"Lao",
 "lt":"Litván",
 "lv":"Lett",
 "mai":"Maithili",
 "mg":"Malagazi",
 "mh":"Marsalli",
 "mi":"Maori",
 "mk":"Macedón",
 "ml":"Malajalam",
 "mn":"Mongol",
 "mo":"Moldáv",
 "mr":"Marati",
 "ms":"Maláj",
 "mt":"Máltai",
 "my":"Burmai",
 "na":"Nauru",
 "nb":"Norvég (bokmal)",
 "nd":"Ndebele (északi)",
 "nds":"Alsószász",
 "ne":"Nepáli",
 "ng":"Ndonga",
 "nl":"Holland",
 "nn":"Norvég (nynorsk)",
 "nr":"Ndebele (déli)",
 "nso":"Északi sotho",
 "nv":"Navajo",
 "ny":"Csicseva",
 "oc":"Okcitán",
 "om":"Oromo",
 "or":"Orija",
 "os":"Oszét",
 "pa":"Pandzsabi",
 "pi":"Pali",
 "pl":"Lengyel",
 "ps":"Pusto",
 "pt":"Portugál",
 "pt_BR":"Portugál (brazil)",
 "qu":"Kecsua",
 "rn":"Rundi",
 "ro":"Román",
 "rom":"Lovári cigány",
 "ru":"Orosz",
 "rw":"Kinjarvanda",
 "sa":"Szanszkrit",
 "sc":"Szardíniai",
 "sd":"Szindi",
 "se":"Északi szami",
 "sg":"Szangó",
 "si":"Szingaléz",
 "sk":"Szlovák",
 "sl":"Szlovén",
 "sm":"Szamoai",
 "sn":"Sona",
 "so":"Szomáli",
 "sq":"Albán",
 "sr":"Szerb",
 "sr@ijekavian":"Szerb (ijekavica)",
 "sr@ijekavianlatin":"Szerb (ijekavica, latin betűs)",
 "sr@latin":"Szerb (latin betűs)",
 "ss":"Szvati",
 "st":"Sotho (déli)",
 "su":"Szundanéz",
 "sv":"Svéd",
 "sw":"Szvahili",
 "ta":"Tamil",
 "te":"Telugu",
 "tg":"Tádzsik",
 "th":"Thai",
 "ti":"Tigrinja",
 "tk":"Türkmén",
 "tn":"Tszvana",
 "to":"Tonga",
 "tr":"Török",
 "ts":"Tsonga",
 "tt":"Tatár",
 "tw":"Tvi",
 "ty":"Tahiti",
 "ug":"Ujgur",
 "uk":"Ukrán",
 "ur":"Urdu",
 "uz":"Üzbég",
 "uz@cyrillic":"Üzbég (cirill)",
 "ven":"Venda",
 "vi":"Vietnami",
 "vo":"Volapük",
 "wa":"Vallon",
 "wo":"Volof",
 "xh":"Xhosza",
 "yi":"Jiddis",
 "yo":"Joruba",
 "za":"Zhuang",
 "zh":"Kínai",
 "zh_CN":"Kínai (egyszerűsített)",
 "zh_HK":"Kínai (hongkongi)",
 "zh_TW":"Kínai (hagyományos)",
 "zu":"Zulu",
},
"it": {
 "aa":"Afar",
 "ab":"Abcaso",
 "ae":"Avestano",
 "af":"Afrikaans",
 "am":"Amarico",
 "ar":"Arabo",
 "as":"Assamese",
 "ast":"Asturiano",
 "ay":"Aymara",
 "az":"Azero",
 "ba":"Baškiro",
 "be":"Bielorusso",
 "be@latin":"Bielorusso (Latino)",
 "bg":"Bulgaro",
 "bh":"Bihari",
 "bi":"Bislama",
 "bn":"Bengalese",
 "bn_IN":"Bengalese (India)",
 "bo":"Tibetano",
 "br":"Bretone",
 "bs":"Bosniaco",
 "ca":"Catalano",
 "ca@valencia":"Catalano (Valenziano)",
 "ce":"Ceceno",
 "ch":"Chamorro",
 "co":"Corso",
 "crh":"Tataro di Crimea",
 "cs":"Ceco",
 "csb":"Casciubico",
 "cu":"Slavo ecclesiastico",
 "cv":"Ciuvascio",
 "cy":"Gallese",
 "da":"Danese",
 "de":"Tedesco",
 "dsb":"Basso sorabo",
 "dz":"Dzongkha",
 "el":"Greco",
 "en":"Inglese",
 "en_GB":"Inglese britannico",
 "en_US":"Inglese americano",
 "eo":"Esperanto",
 "es":"Spagnolo",
 "et":"Estone",
 "eu":"Basco",
 "fa":"Farsi (Persiano)",
 "fi":"Finlandese",
 "fj":"Figiano",
 "fo":"Faroese",
 "fr":"Francese",
 "fy":"Frisone",
 "ga":"Gaelico irlandese",
 "gd":"Gaelico",
 "gl":"Gallego",
 "gn":"Guaraní",
 "gu":"Gujarati",
 "gv":"Mannese",
 "ha":"Hausa",
 "he":"Ebraico",
 "hi":"Hindi",
 "hne":"Chhattisgarhi",
 "ho":"Hiri motu",
 "hr":"Croato",
 "hsb":"Alto sorabo",
 "hu":"Ungherese",
 "hy":"Armeno",
 "hz":"Herero",
 "ia":"Interlingua",
 "id":"Indonesiano",
 "ie":"Interlingue",
 "ik":"Inupiak",
 "io":"Ido",
 "is":"Islandese",
 "it":"Italiano",
 "iu":"Inuktitut",
 "ja":"Giapponese",
 "jv":"Giavanese",
 "ka":"Georgiano",
 "ki":"Kikuyu",
 "kk":"Kazako",
 "kl":"Groenlandese",
 "km":"Khmer",
 "kn":"Kannada",
 "ko":"Coreano",
 "ks":"Kašmiro",
 "ku":"Curdo",
 "kv":"Komi",
 "kw":"Cornico",
 "ky":"Kirghiso",
 "la":"Latino",
 "lb":"Lussemburghese",
 "li":"Limburghese",
 "ln":"Lingala",
 "lo":"Lao",
 "lt":"Lituano",
 "lv":"Lettone",
 "mai":"Maithili",
 "mg":"Malgascio",
 "mh":"Marsciallese",
 "mi":"Maori",
 "mk":"Macedone",
 "ml":"Malayalam",
 "mn":"Mongolo",
 "mo":"Moldavo",
 "mr":"Marathi",
 "ms":"Malese",
 "mt":"Maltese",
 "my":"Birmano",
 "na":"Nauruano",
 "nb":"Norvegese bokmål",
 "nd":"Ndebele settentrionale",
 "nds":"Basso sassone",
 "ne":"Nepalese",
 "ng":"Ndonga",
 "nl":"Nederlandese",
 "nn":"Norvegese nynorsk",
 "nr":"Ndebele meridionale",
 "nso":"Sesotho del nord",
 "nv":"Navajo",
 "ny":"Chichewa",
 "oc":"Occitano",
 "om":"Oromo",
 "or":"Oriya",
 "os":"Osseto",
 "pa":"Panjabi",
 "pi":"Pali",
 "pl":"Polacco",
 "ps":"Paštu",
 "pt":"Portoghese",
 "pt_BR":"Portoghese brasiliano",
 "qu":"Quechua",
 "rn":"Kirundi",
 "ro":"Rumeno",
 "rom":"Romaní",
 "ru":"Russo",
 "rw":"Kinyarwanda",
 "sa":"Sanscrito",
 "sc":"Sardo",
 "sd":"Sindhi",
 "se":"Sami settentrionale",
 "sg":"Sango",
 "si":"Singalese",
 "sk":"Slovacco",
 "sl":"Sloveno",
 "sm":"Samoano",
 "sn":"Shona",
 "so":"Somalo",
 "sq":"Albanese",
 "sr":"Serbo",
 "sr@ijekavian":"Serbo ijekavo",
 "sr@ijekavianlatin":"Serbo ijekavo latino",
 "sr@latin":"Serbo latino",
 "ss":"Swati",
 "st":"Sesotho meridionale",
 "su":"Sondanese",
 "sv":"Svedese",
 "sw":"Swahili",
 "ta":"Tamil",
 "te":"Telugu",
 "tg":"Tagico",
 "th":"Thailandese",
 "ti":"Tigrino",
 "tk":"Turkmeno",
 "tn":"Tswana",
 "to":"Tonga",
 "tr":"Turco",
 "ts":"Tsonga",
 "tt":"Tataro",
 "tw":"Twi",
 "ty":"Tahitiano",
 "ug":"Uiguro",
 "uk":"Ucraino",
 "ur":"Urdu",
 "uz":"Usbeco",
 "uz@cyrillic":"Usbeco (cirillico)",
 "ven":"Venda",
 "vi":"Vietnamita",
 "vo":"Volapük",
 "wa":"Vallone",
 "wo":"Wolof",
 "xh":"Xhosa",
 "yi":"Yiddish",
 "yo":"Yoruba",
 "za":"Zhuang",
 "zh":"Cinese",
 "zh_CN":"Cinese semplificato",
 "zh_HK":"Cinese (Hong Kong)",
 "zh_TW":"Cinese tradizionale",
 "zu":"Zulu",
},
"ja": {
 "aa":"アファル語",
 "ab":"アブハズ語",
 "ae":"アベスタ語",
 "af":"アフリカーンス語",
 "am":"アムハラ語",
 "ar":"アラビア語",
 "as":"アッサム語",
 "ast":"アストゥリアス語",
 "ay":"アイマラ語",
 "az":"アゼルバイジャン語",
 "ba":"バシュキール語",
 "be":"ベラルーシ語",
 "be@latin":"ベラルーシ語 (ラテン文字)",
 "bg":"ブルガリア語",
 "bh":"ビハール語",
 "bi":"ビスラマ語",
 "bn":"ベンガル語",
 "bn_IN":"ベンガル語 (インド)",
 "bo":"チベット語",
 "br":"ブルトン語",
 "bs":"ボスニア語",
 "ca":"カタロニア語",
 "ca@valencia":"バレンシア語",
 "ce":"チェチェン語",
 "ch":"チャモロ語",
 "co":"コルシカ語",
 "crh":"クリミア・タタール語",
 "cs":"チェコ語",
 "csb":"カシューブ語",
 "cu":"教会スラブ語",
 "cv":"チュワシュ語",
 "cy":"ウェールズ語",
 "da":"デンマーク語",
 "de":"ドイツ語",
 "dsb":"下ソルブ語",
 "dz":"ゾンカ語",
 "el":"ギリシャ語",
 "en":"英語",
 "en_GB":"イギリス英語",
 "en_US":"アメリカ英語",
 "eo":"エスペラント語",
 "es":"スペイン語",
 "et":"エストニア語",
 "eu":"バスク語",
 "fa":"ペルシア語",
 "fi":"フィンランド語",
 "fj":"フィジー語",
 "fo":"フェーロー語",
 "fr":"フランス語",
 "fy":"フリジア語",
 "ga":"アイルランド系ゲール語",
 "gd":"ゲール語",
 "gl":"ガリシア語",
 "gn":"グァラニ語",
 "gu":"グジャラート語",
 "gv":"マン島語",
 "ha":"ハウサ語",
 "he":"ヘブライ語",
 "hi":"ヒンディー語",
 "hne":"チャッティースガリー語",
 "ho":"ヒリモトゥ語",
 "hr":"クロアチア語",
 "hsb":"上ソルブ語",
 "hu":"ハンガリー語",
 "hy":"アルメニア語",
 "hz":"ヘレロ語",
 "ia":"インターリンガ",
 "id":"インドネシア語",
 "ie":"インターリング",
 "ik":"イヌピアック語",
 "io":"イド語",
 "is":"アイスランド語",
 "it":"イタリア語",
 "iu":"イヌイット語",
 "ja":"日本語",
 "jv":"ジャワ語",
 "ka":"グルジア語",
 "ki":"キクユ語",
 "kk":"カザフ語",
 "kl":"グリーンランド語",
 "km":"クメール語",
 "kn":"カンナダ語",
 "ko":"韓国語・朝鮮語",
 "ks":"カシュミール語",
 "ku":"クルド語",
 "kv":"コミ語",
 "kw":"コーンウォール語",
 "ky":"キルギス語",
 "la":"ラテン語",
 "lb":"ルクセンブルク語",
 "li":"リグリア語",
 "ln":"リンガラ語",
 "lo":"ラオ語",
 "lt":"リトアニア語",
 "lv":"ラトビア語",
 "mai":"マイティリー語",
 "mg":"マラガシ語",
 "mh":"マーシャル語",
 "mi":"マオリ語",
 "mk":"マケドニア語",
 "ml":"マラヤーラム語",
 "mn":"モンゴル語",
 "mo":"モルダビア語",
 "mr":"マラーティー語",
 "ms":"マレー語",
 "mt":"マルタ語",
 "my":"ビルマ語",
 "na":"ナウル語",
 "nb":"ノルウェー語 (ブークモール)",
 "nd":"北ンデベレ語",
 "nds":"低ザクセン語",
 "ne":"ネパール語",
 "ng":"ンドゥンガ語",
 "nl":"オランダ語",
 "nn":"ノルウェー語 (ニーノシュク)",
 "nr":"南ンデベレ語",
 "nso":"北ソト語",
 "nv":"ナバホ語",
 "ny":"チェワ語",
 "oc":"オック語",
 "om":"オロモ語",
 "or":"オリヤー語",
 "os":"オセット語",
 "pa":"パンジャーブ語",
 "pi":"パーリ語",
 "pl":"ポーランド語",
 "ps":"パシュトー語",
 "pt":"ポルトガル語",
 "pt_BR":"ブラジル ポルトガル語",
 "qu":"ケチュア語",
 "rn":"ルンディ語",
 "ro":"ルーマニア語",
 "rom":"ロマ語",
 "ru":"ロシア語",
 "rw":"ルワンダ語",
 "sa":"サンスクリット語",
 "sc":"サルデーニャ語",
 "sd":"シンド語",
 "se":"北サーミ語",
 "sg":"サンゴ語",
 "si":"シンハラ語",
 "sk":"スロバキア語",
 "sl":"スロベニア語",
 "sm":"サモア語",
 "sn":"ショナ語",
 "so":"ソマリ語",
 "sq":"アルバニア語",
 "sr":"セルビア語",
 "sr@ijekavian":"セルビア語イェ方言",
 "sr@ijekavianlatin":"セルビア語イェ方言 (ラテン文字)",
 "sr@latin":"セルビア語 (ラテン文字)",
 "ss":"スワティ語",
 "st":"南ソト語",
 "su":"スンダ語",
 "sv":"スウェーデン語",
 "sw":"スワヒリ語",
 "ta":"タミル語",
 "te":"テルグ語",
 "tg":"タジク語",
 "th":"タイ語",
 "ti":"ティグリニア語",
 "tk":"トルクメン語",
 "tn":"ツワナ語",
 "to":"トンガ語",
 "tr":"トルコ語",
 "ts":"ツォンガ語",
 "tt":"タタール語",
 "tw":"チュイ語",
 "ty":"タヒチ語",
 "ug":"ウイグル語",
 "uk":"ウクライナ語",
 "ur":"ウルドゥー語",
 "uz":"ウズベク語",
 "uz@cyrillic":"ウズベク語 (キリル文字)",
 "ven":"ベンダ語",
 "vi":"ベトナム語",
 "vo":"ボラピューク語",
 "wa":"ワロン語",
 "wo":"ウォロフ語",
 "xh":"コサ語",
 "yi":"イディッシュ語",
 "yo":"ヨルバ語",
 "za":"チュワン語",
 "zh":"中国語",
 "zh_CN":"中国語 簡体字",
 "zh_HK":"中国語 (香港)",
 "zh_TW":"中国語 繁体字",
 "zu":"ズールー語",
},
"nl": {
 "aa":"Afar",
 "ab":"Abkhazian",
 "ae":"Avestan",
 "af":"Afrikaans",
 "am":"Amharisch",
 "ar":"Arabisch",
 "as":"Assamees",
 "ast":"Asturisch",
 "ay":"Aymara",
 "az":"Azerbeidjaans",
 "ba":"Bashkir",
 "be":"Wit-Rusland",
 "be@latin":"Wit-Rusland (Latijn)",
 "bg":"Bulgaars",
 "bh":"Bihari",
 "bi":"Bislama",
 "bn":"Bengali",
 "bn_IN":"Bengali (India)",
 "bo":"Tibetaans",
 "br":"Bretons",
 "bs":"Bosnisch",
 "ca":"Catalaans",
 "ca@valencia":"Catalaans (Valentiaans)",
 "ce":"Chechen",
 "ch":"Chamorro",
 "co":"Corsicaans",
 "crh":"Krim-Tataars",
 "cs":"Tsjechisch",
 "csb":"Kashubian",
 "cu":"Kerk Slavisch",
 "cv":"Chuvash",
 "cy":"Welsh",
 "da":"Deens",
 "de":"Duits",
 "dsb":"Nedersorbisch",
 "dz":"Dzongkha",
 "el":"Grieks",
 "en":"Engels",
 "en_GB":"Engels (Brits)",
 "en_US":"Engels (Amerikaans)",
 "eo":"Esperanto",
 "es":"Spaans",
 "et":"Ests",
 "eu":"Baskisch",
 "fa":"Farsi (Perzisch)",
 "fi":"Fins",
 "fj":"Fijisch",
 "fo":"Faroese",
 "fr":"Frans",
 "fy":"Frysk",
 "ga":"Gaelic (Iers)",
 "gd":"Gaelic",
 "gl":"Galicisch",
 "gn":"Guarani",
 "gu":"Gujarati",
 "gv":"Manx",
 "ha":"Hausa",
 "he":"Hebreeuws",
 "hi":"Hindi",
 "hne":"Chhattisgarhi",
 "ho":"Hiri Motu",
 "hr":"Kroatisch",
 "hsb":"Opper Sorbian",
 "hu":"Hongaars",
 "hy":"Armeens",
 "hz":"Herero",
 "ia":"Interlingua",
 "id":"Indonesisch",
 "ie":"Interlingue",
 "ik":"Inupiaq",
 "io":"Ido",
 "is":"IJslands",
 "it":"Italiaans",
 "iu":"Inuktitut",
 "ja":"Japans",
 "jv":"Javaans",
 "ka":"Georgisch",
 "ki":"Kikuyu",
 "kk":"Kazakh",
 "kl":"Kalaallisut",
 "km":"Khmer",
 "kn":"Kannada",
 "ko":"Koreaans",
 "ks":"Kashmiri",
 "ku":"Koerdisch",
 "kv":"Komi",
 "kw":"Cornish",
 "ky":"Kirghizisch",
 "la":"Latijn",
 "lb":"Letzenburgs",
 "li":"Limburgs",
 "ln":"Lingala",
 "lo":"Lao",
 "lt":"Litouws",
 "lv":"Lets",
 "mai":"Maithili",
 "mg":"Malagasy",
 "mh":"Marshallees",
 "mi":"Maori",
 "mk":"Macedonisch",
 "ml":"Malayalam",
 "mn":"Mongolisch",
 "mo":"Moldavisch",
 "mr":"Marathi",
 "ms":"Malay",
 "mt":"Maltees",
 "my":"Burmees",
 "na":"Nauru",
 "nb":"Noors Bokmål",
 "nd":"Ndebele, Noord",
 "nds":"Nedersaksisch",
 "ne":"Nepalees",
 "ng":"Ndonga",
 "nl":"Nederlands",
 "nn":"Noors, Nynorsk",
 "nr":"Ndebele, Zuid",
 "nso":"Noord-Sotho",
 "nv":"Navajo",
 "ny":"Chichewa",
 "oc":"Occitan",
 "om":"Oromo",
 "or":"Oriya",
 "os":"Ossetisch",
 "pa":"Panjabi",
 "pi":"Pali",
 "pl":"Pools",
 "ps":"Pushto",
 "pt":"Portugees",
 "pt_BR":"Braziliaans Portugees",
 "qu":"Quechua",
 "rn":"Rundi",
 "ro":"Roemeens",
 "rom":"Roma",
 "ru":"Russisch",
 "rw":"Kinyarwanda",
 "sa":"Sanskrit",
 "sc":"Sardinisch",
 "sd":"Sindhi",
 "se":"Noord Sami",
 "sg":"Sango",
 "si":"Singalees",
 "sk":"Slowaaks",
 "sl":"Sloweens",
 "sm":"Samoaans",
 "sn":"Shona",
 "so":"Somalisch",
 "sq":"Albanisch",
 "sr":"Servisch",
 "sr@ijekavian":"Servisch Ijekavian",
 "sr@ijekavianlatin":"Servisch Ijekavian Latijn",
 "sr@latin":"Servisch Latijn",
 "ss":"Swati",
 "st":"Sotho, Zuid",
 "su":"Sundanees",
 "sv":"Zweeds",
 "sw":"Swahili",
 "ta":"Tamil",
 "te":"Telugu",
 "tg":"Tajiks",
 "th":"Thais",
 "ti":"Tigrinya",
 "tk":"Turkmeens",
 "tn":"Tswana",
 "to":"Tonga",
 "tr":"Turks",
 "ts":"Tsonga",
 "tt":"Tataars",
 "tw":"Twi",
 "ty":"Tahitiaans",
 "ug":"Oeigoers",
 "uk":"Oekraïns",
 "ur":"Urdu",
 "uz":"Oezbeeks",
 "uz@cyrillic":"Oezbeeks (Cyrilisch)",
 "ven":"Venda",
 "vi":"Vietnamees",
 "vo":"Volapúk",
 "wa":"Waals",
 "wo":"Wolof",
 "xh":"Xhosa",
 "yi":"Yiddish",
 "yo":"Yoruba",
 "za":"Zhuang",
 "zh":"Chinees",
 "zh_CN":"Chinees (Vereenvoudigd)",
 "zh_HK":"Chinees (Hong Kong)",
 "zh_TW":"Chinees (Traditioneel)",
 "zu":"Zulu",
},
"pl": {
 "aa":"Afarski",
 "ab":"Abchaski",
 "ae":"Awestański (Irański)",
 "af":"Afrykanerski",
 "am":"Etiopski",
 "ar":"Arabski",
 "as":"Assamijski",
 "ast":"Asturyjski",
 "ay":"Aymara",
 "az":"Azerbejdżański",
 "ba":"Baszkirski",
 "be":"Białoruski",
 "be@latin":"Białoruski (alfabet łaciński)",
 "bg":"Bułgarski",
 "bh":"Bihari",
 "bi":"Bislama",
 "bn":"Bengalski",
 "bn_IN":"Bengalski (Indie)",
 "bo":"Tybetański",
 "br":"Bretoński",
 "bs":"Bośniacki",
 "ca":"Kataloński",
 "ca@valencia":"Kataloński (walencki)",
 "ce":"Czeczeński",
 "ch":"Chamorro",
 "co":"Korsykański",
 "crh":"Tatarski (Krymski)",
 "cs":"Czeski",
 "csb":"Kaszubski",
 "cu":"Starocerkiewno-słowiański",
 "cv":"Czuwaski",
 "cy":"Walijski",
 "da":"Duński",
 "de":"Niemiecki",
 "dsb":"Dolnołużycki",
 "dz":"Dzongkha",
 "el":"Grecki",
 "en":"Angielski",
 "en_GB":"Angielski brytyjski",
 "en_US":"Angielski amerykański",
 "eo":"Esperanto",
 "es":"Hiszpański",
 "et":"Estoński",
 "eu":"Baskijski",
 "fa":"Farsi (Perski)",
 "fi":"Fiński",
 "fj":"z Fiji",
 "fo":"z Wysp Owczych",
 "fr":"Francuski",
 "fy":"Fryzyjski",
 "ga":"Irlandzki Gaelic",
 "gd":"celtycki (gaelic)",
 "gl":"Galicyjski",
 "gn":"Guarani",
 "gu":"Gujarati",
 "gv":"Manx",
 "ha":"Hausa",
 "he":"Hebrajski",
 "hi":"Hindi",
 "hne":"Chhattisgarhi",
 "ho":"Hiri Motu",
 "hr":"Chorwacki",
 "hsb":"Górnołużycki",
 "hu":"Węgierski",
 "hy":"Ormiański",
 "hz":"Herero",
 "ia":"Interlingua",
 "id":"Indonezyjski",
 "ie":"Interlingue",
 "ik":"Inupiaq",
 "io":"Ido",
 "is":"Islandzki",
 "it":"Włoski",
 "iu":"Inuktitut",
 "ja":"Japoński",
 "jv":"Jawański",
 "ka":"Gruziński",
 "ki":"Kikuyu",
 "kk":"Kazachski",
 "kl":"Kalaallisut",
 "km":"Khmerski",
 "kn":"Kannada",
 "ko":"Koreański",
 "ks":"Kaszmirski",
 "ku":"Kurdyjski",
 "kv":"z Komi",
 "kw":"Kornwalijski",
 "ky":"Kirgiski",
 "la":"Łaciński",
 "lb":"Luksemburski",
 "li":"Limburgiański",
 "ln":"Lingala",
 "lo":"Laotański",
 "lt":"Litewski",
 "lv":"Łotewski",
 "mai":"Maithili",
 "mg":"Madagaskarski",
 "mh":"z Wysp Marshalla",
 "mi":"Maoryjski",
 "mk":"Macedoński",
 "ml":"Malajalam",
 "mn":"Mongolski",
 "mo":"Mołdawski",
 "mr":"Marathi (Hinduski)",
 "ms":"Malajski",
 "mt":"Maltański",
 "my":"Birmański",
 "na":"Nauru",
 "nb":"Norweski Bokmaal",
 "nd":"Ndebele, Północ",
 "nds":"Dolnosaksoński",
 "ne":"Nepalski",
 "ng":"Ndonga",
 "nl":"Holenderski",
 "nn":"Norweski Nynorsk",
 "nr":"Ndebele, Południe",
 "nso":"Północne Sotho",
 "nv":"Navajo",
 "ny":"Chichewa",
 "oc":"Okcytański",
 "om":"Oromo",
 "or":"Oriya",
 "os":"Osetański",
 "pa":"Pendżabski",
 "pi":"Pali",
 "pl":"Polski",
 "ps":"Pushto",
 "pt":"Portugalski",
 "pt_BR":"Portugalski (brazylijski)",
 "qu":"Quechua",
 "rn":"Rundi",
 "ro":"Rumuński",
 "rom":"Romski",
 "ru":"Rosyjski",
 "rw":"Kinyarwanda",
 "sa":"Sanskryt",
 "sc":"Sardyński",
 "sd":"Sindhi",
 "se":"Północny Sami",
 "sg":"Sango",
 "si":"Sinhala",
 "sk":"Słowacki",
 "sl":"Słoweński",
 "sm":"Samoański",
 "sn":"Shona",
 "so":"Somalijski",
 "sq":"Albański",
 "sr":"Serbski",
 "sr@ijekavian":"Serbski ijekawski",
 "sr@ijekavianlatin":"Serbski ijekawski łaciński",
 "sr@latin":"Serbski łaciński",
 "ss":"Swati",
 "st":"Sotho, Południowy",
 "su":"Sudański",
 "sv":"Szwedzki",
 "sw":"Swahili",
 "ta":"Tamiljski",
 "te":"Telugu",
 "tg":"Tadżycki",
 "th":"Tajski",
 "ti":"Tigrinya",
 "tk":"Turkmeński",
 "tn":"Tswana",
 "to":"Tonga",
 "tr":"Turecki",
 "ts":"Tsonga",
 "tt":"Tatarski",
 "tw":"Twi",
 "ty":"Tahitański",
 "ug":"Ujgurski",
 "uk":"Ukraiński",
 "ur":"Urdu",
 "uz":"Uzbecki",
 "uz@cyrillic":"Uzbecki (cyrlica)",
 "ven":"Venda",
 "vi":"Wietnamski",
 "vo":"Volapük",
 "wa":"Waloński",
 "wo":"Wolof",
 "xh":"Xhosa",
 "yi":"Jidysz",
 "yo":"Yoruba",
 "za":"Zhuang",
 "zh":"Chiński",
 "zh_CN":"Chiński uproszczony",
 "zh_HK":"Chiński (Hong Kong)",
 "zh_TW":"Chiński tradycyjny",
 "zu":"Zuluski",
},
"pt_BR": {
 "aa":"Afar",
 "ab":"Abcázio",
 "ae":"Avéstico",
 "af":"Africâner",
 "am":"Amárico",
 "ar":"Árabe",
 "as":"Assamês",
 "ast":"Asturiano",
 "ay":"Aimará",
 "az":"Azeri",
 "ba":"Basquir",
 "be":"Bielorrusso",
 "be@latin":"Bielorrusso (latino)",
 "bg":"Búlgaro",
 "bh":"Bihari",
 "bi":"Bislama",
 "bn":"Bengali",
 "bn_IN":"Bengali (Índia)",
 "bo":"Tibetano",
 "br":"Bretão",
 "bs":"Bósnio",
 "ca":"Catalão",
 "ca@valencia":"Catalão (valenciano)",
 "ce":"Checheno",
 "ch":"Chamorro",
 "co":"Corso",
 "crh":"Tártaro da Crimeia",
 "cs":"Tcheco",
 "csb":"Cassúbia",
 "cu":"Eslavo eclesiástico",
 "cv":"Tchuvache",
 "cy":"Galês",
 "da":"Dinamarquês",
 "de":"Alemão",
 "dsb":"Baixo Sorábio",
 "dz":"Dzongkha",
 "el":"Grego",
 "en":"Inglês",
 "en_GB":"Inglês britânico",
 "en_US":"Inglês americano",
 "eo":"Esperanto",
 "es":"Espanhol",
 "et":"Estoniano",
 "eu":"Basco",
 "fa":"Farsi (Persa)",
 "fi":"Finlandês",
 "fj":"Fijiano",
 "fo":"Feroês",
 "fr":"Francês",
 "fy":"Frisão",
 "ga":"Gaélico irlandês",
 "gd":"Gaélico",
 "gl":"Galego",
 "gn":"Guarani",
 "gu":"Guzerate",
 "gv":"Manês",
 "ha":"Haussá",
 "he":"Hebraico",
 "hi":"Hindi",
 "hne":"Chhattisgarhi",
 "ho":"Hiri Motu",
 "hr":"Croata",
 "hsb":"Alto Sorábio",
 "hu":"Húngaro",
 "hy":"Armênio",
 "hz":"Hereró",
 "ia":"Interlíngua",
 "id":"Indonésio",
 "ie":"Interlingue",
 "ik":"Inupiaq",
 "io":"Ido",
 "is":"Islandês",
 "it":"Italiano",
 "iu":"Inuktitut",
 "ja":"Japonês",
 "jv":"Javanês",
 "ka":"Georgiano",
 "ki":"Kikuyu",
 "kk":"Cazaque",
 "kl":"Groenlandês",
 "km":"Cambojano",
 "kn":"Canarês",
 "ko":"Coreano",
 "ks":"Caxemira",
 "ku":"Curdo",
 "kv":"Komi",
 "kw":"Córnico",
 "ky":"Quirguiz",
 "la":"Latim",
 "lb":"Luxemburguês",
 "li":"Limburguês",
 "ln":"Lingala",
 "lo":"Laociano",
 "lt":"Lituano",
 "lv":"Letão",
 "mai":"Maithili",
 "mg":"Malgaxe",
 "mh":"Marchalês",
 "mi":"Maori",
 "mk":"Macedônio",
 "ml":"Malaiala",
 "mn":"Mongol",
 "mo":"Moldavo",
 "mr":"Marata",
 "ms":"Malaio",
 "mt":"Maltês",
 "my":"Birmanês",
 "na":"Nauruano",
 "nb":"Dano-norueguês",
 "nd":"Ndebele do norte",
 "nds":"Baixo Saxão",
 "ne":"Nepalês",
 "ng":"Ndonga",
 "nl":"Holandês",
 "nn":"Novo Norueguês",
 "nr":"Ndebele do Sul",
 "nso":"Sotho setentrional",
 "nv":"Navajo",
 "ny":"Cinianja",
 "oc":"Occitano",
 "om":"Oromo",
 "or":"Oriá",
 "os":"Osseto",
 "pa":"Panjabi",
 "pi":"Pali",
 "pl":"Polonês",
 "ps":"Afegão",
 "pt":"Português",
 "pt_BR":"Português do Brasil",
 "qu":"Quíchua",
 "rn":"Rundi",
 "ro":"Romeno",
 "rom":"Romani",
 "ru":"Russo",
 "rw":"Kinyarwanda",
 "sa":"Sânscrito",
 "sc":"Sardo",
 "sd":"Sindi",
 "se":"Sami setentrional",
 "sg":"Sango",
 "si":"Cingalês",
 "sk":"Eslovaco",
 "sl":"Esloveno",
 "sm":"Samoano",
 "sn":"Chona",
 "so":"Somali",
 "sq":"Albanês",
 "sr":"Sérvio",
 "sr@ijekavian":"Sérvio ijekavian",
 "sr@ijekavianlatin":"Sérvio latino ijekavian",
 "sr@latin":"Sérvio latino",
 "ss":"Suázi",
 "st":"Sotho meridional",
 "su":"Sudanês",
 "sv":"Sueco",
 "sw":"Suaíli",
 "ta":"Tâmil",
 "te":"Telugu",
 "tg":"Tajique",
 "th":"Tailandês",
 "ti":"Tigrino",
 "tk":"Turcomeno",
 "tn":"Tswana",
 "to":"Tonganês",
 "tr":"Turco",
 "ts":"Tsonga",
 "tt":"Tártaro",
 "tw":"Twi",
 "ty":"Taitiano",
 "ug":"Uigur",
 "uk":"Ucraniano",
 "ur":"Urdu",
 "uz":"Uzbeque",
 "uz@cyrillic":"Uzbeque (Cirílico)",
 "ven":"Venda",
 "vi":"Vietnamita",
 "vo":"Volapuque",
 "wa":"Valão",
 "wo":"Jalofo",
 "xh":"Xhosa",
 "yi":"Iídiche",
 "yo":"Iorubá",
 "za":"Zhuang",
 "zh":"Chinês",
 "zh_CN":"Chinês simplificado",
 "zh_HK":"Chinês (Hong Kong)",
 "zh_TW":"Chinês tradicional",
 "zu":"Zulu",
},
"ru": {
 "aa":"Афарский",
 "ab":"Абхазский",
 "ae":"Авестийский",
 "af":"Африкаанс",
 "am":"Амхарский",
 "ar":"Арабский",
 "as":"Ассамский",
 "ast":"Астурийский",
 "ay":"Аймарский",
 "az":"Азербайджанский",
 "ba":"Башкирский",
 "be":"Белорусский",
 "be@latin":"Белорусский (латиница)",
 "bg":"Болгарский",
 "bh":"Бихарский",
 "bi":"Бислама",
 "bn":"Бенгальский",
 "bn_IN":"Бенгальский (Индия)",
 "bo":"Тибетский",
 "br":"Бретонский",
 "bs":"Боснийский",
 "ca":"Каталонский",
 "ca@valencia":"Каталонский (Валенсия)",
 "ce":"Чеченский",
 "ch":"Чаморро",
 "co":"Корсиканский",
 "crh":"Крымско-татарский",
 "cs":"Чешский",
 "csb":"Кашубский",
 "cu":"Церковнославянский",
 "cv":"Чувашский",
 "cy":"Валлийский",
 "da":"Датский",
 "de":"Немецкий",
 "dsb":"Нижнелужицкий",
 "dz":"Дзонгка (Бутан)",
 "el":"Греческий",
 "en":"Английский",
 "en_GB":"Английский (Великобритания)",
 "en_US":"Английский (США)",
 "eo":"Эсперанто",
 "es":"Испанский",
 "et":"Эстонский",
 "eu":"Баскский",
 "fa":"Персидский",
 "fi":"Финский",
 "fj":"Фиджи",
 "fo":"Фарерский",
 "fr":"Французский",
 "fy":"Фризский",
 "ga":"Ирландский",
 "gd":"Шотландский",
 "gl":"Галисийский",
 "gn":"Гуарани",
 "gu":"Гуджарати",
 "gv":"Мэнский",
 "ha":"Хауса",
 "he":"Иврит",
 "hi":"Хинди",
 "hne":"Чхаттисгархи",
 "ho":"Хири-моту",
 "hr":"Хорватский",
 "hsb":"Верхнелужицкий",
 "hu":"Венгерский",
 "hy":"Армянский",
 "hz":"Эреро",
 "ia":"Интерлингва",
 "id":"Индонезийский",
 "ie":"Окциденталь",
 "ik":"Инупиак",
 "io":"Идо",
 "is":"Исландский",
 "it":"Итальянский",
 "iu":"Инуктитут",
 "ja":"Японский",
 "jv":"Яванский",
 "ka":"Грузинский",
 "ki":"Кикуйю",
 "kk":"Казахский",
 "kl":"Гренландский",
 "km":"Кхмерский",
 "kn":"Каннада",
 "ko":"Корейский",
 "ks":"Кашмирский",
 "ku":"Курдский",
 "kv":"Коми",
 "kw":"Корнский",
 "ky":"Киргизский",
 "la":"Латинский",
 "lb":"Люксембургский",
 "li":"Лимбуржский",
 "ln":"Лингала",
 "lo":"Лаосский",
 "lt":"Литовский",
 "lv":"Латышский",
 "mai":"Майтхили",
 "mg":"Мальгашский",
 "mh":"Маршалльский",
 "mi":"Маори",
 "mk":"Македонский",
 "ml":"Малаялам",
 "mn":"Монгольский",
 "mo":"Молдавский",
 "mr":"Маратхи",
 "ms":"Малайский",
 "mt":"Мальтийский",
 "my":"Бирманский",
 "na":"Науру",
 "nb":"Норвежский (литературный)",
 "nd":"Северный ндебеле",
 "nds":"Нижнесаксонский",
 "ne":"Непальский",
 "ng":"Ндонга",
 "nl":"Голландский",
 "nn":"Норвежский (нюнорск)",
 "nr":"Южный ндебеле",
 "nso":"Северный сото",
 "nv":"Навахо",
 "ny":"Чичева",
 "oc":"Окситанский",
 "om":"Оромо",
 "or":"Ория",
 "os":"Осетинский",
 "pa":"Панджаби",
 "pi":"Пали",
 "pl":"Польский",
 "ps":"Пушту",
 "pt":"Португальский",
 "pt_BR":"Португальский (Бразилия)",
 "qu":"Кечуа",
 "rn":"Рунди",
 "ro":"Румынский",
 "rom":"Цыганский",
 "ru":"Русский",
 "rw":"Киньяруанда",
 "sa":"Санскрит",
 "sc":"Сардинский",
 "sd":"Синдхи",
 "se":"Северносаамский",
 "sg":"Санго",
 "si":"Сингальский",
 "sk":"Словацкий",
 "sl":"Словенский",
 "sm":"Самоанский",
 "sn":"Шона",
 "so":"Сомалийский",
 "sq":"Албанский",
 "sr":"Сербский",
 "sr@ijekavian":"Сербский (иекавский)",
 "sr@ijekavianlatin":"Сербский (иекавский, латиница)",
 "sr@latin":"Сербский (латиница)",
 "ss":"Свати",
 "st":"Южный сото",
 "su":"Сунданский",
 "sv":"Шведский",
 "sw":"Суахили",
 "ta":"Тамильский",
 "te":"Телугу",
 "tg":"Таджикский",
 "th":"Тайский",
 "ti":"Тигринья",
 "tk":"Туркменский",
 "tn":"Тсвана",
 "to":"Тонганский",
 "tr":"Турецкий",
 "ts":"Тсонга",
 "tt":"Татарский",
 "tw":"Тви",
 "ty":"Таитянский",
 "ug":"Уйгурский",
 "uk":"Украинский",
 "ur":"Урду",
 "uz":"Узбекский",
 "uz@cyrillic":"Узбекский (кириллица)",
 "ven":"Венда",
 "vi":"Вьетнамский",
 "vo":"Волапюк",
 "wa":"Валлонский",
 "wo":"Волоф",
 "xh":"Коса",
 "yi":"Идиш",
 "yo":"Йоруба",
 "za":"Чжуанский",
 "zh":"Китайский",
 "zh_CN":"Китайский (Китай)",
 "zh_HK":"Китайский (Гонконг)",
 "zh_TW":"Китайский (Тайвань)",
 "zu":"Зулусский",
},
"tr": {
 "aa":"Afar",
 "ab":"Abkhazian",
 "ae":"Avestan",
 "af":"Afrika Dili",
 "am":"Amharic",
 "ar":"Arapça",
 "as":"Assamese",
 "ast":"Avusturya Dili",
 "ay":"Aymara",
 "az":"Azerbeycanca",
 "ba":"Bashkir",
 "be":"Belarus Dili",
 "be@latin":"Belarus Dili (Latin)",
 "bg":"Bulgarca",
 "bh":"Bihari",
 "bi":"Bislama",
 "bn":"Bengalce",
 "bn_IN":"Bengalce (Hindistan)",
 "bo":"Tibetan",
 "br":"Britanya Dili",
 "bs":"Boşnakça",
 "ca":"Katalan Dili",
 "ca@valencia":"Katalan (Valencia)",
 "ce":"Çeçen",
 "ch":"Chamorro",
 "co":"Korsikaca",
 "crh":"Kırım Tatarcası",
 "cs":"Çekçe",
 "csb":"Kashubian",
 "cu":"Church Slavic",
 "cv":"Çuvaşça",
 "cy":"Gallerce",
 "da":"Danimarka Dili",
 "de":"Almanca",
 "dsb":"Aşağı Sırpça",
 "dz":"Dzongkha",
 "el":"Yunanca",
 "en":"İngilizce",
 "en_GB":"İngiliz İngilizcesi",
 "en_US":"Amerikan İngilizcesi",
 "eo":"Esperanto",
 "es":"İspanyolca",
 "et":"Estonya Dili",
 "eu":"Bask Dili",
 "fa":"Farsça (İran)",
 "fi":"Fince",
 "fj":"Fijian",
 "fo":"Faroese",
 "fr":"Fransızca",
 "fy":"Frisian",
 "ga":"İrlanda Galik",
 "gd":"Galik",
 "gl":"Galce",
 "gn":"Guarani",
 "gu":"Gujarati",
 "gv":"Manx",
 "ha":"Hausa",
 "he":"İbranice",
 "hi":"Hintçe",
 "hne":"Chhattisgarhi",
 "ho":"Hiri Motu",
 "hr":"Hırvatça",
 "hsb":"Yukarı Sırpça",
 "hu":"Macarca",
 "hy":"Ermenice",
 "hz":"Herero",
 "ia":"Interlingua",
 "id":"İndonezya Dili",
 "ie":"Interlingue",
 "ik":"Inupiaq",
 "io":"Ido",
 "is":"İzlanda Dili",
 "it":"İtalyanca",
 "iu":"Inuktitut",
 "ja":"Japonca",
 "jv":"Javanese",
 "ka":"Gürcüce",
 "ki":"Kikuyu",
 "kk":"Kazakça",
 "kl":"Kalaallisut",
 "km":"Khmer",
 "kn":"Kannada",
 "ko":"Korece",
 "ks":"Kashmiri",
 "ku":"Kürtçe",
 "kv":"Komi",
 "kw":"Cornish",
 "ky":"Kırgız",
 "la":"Latin",
 "lb":"Luxembourgish",
 "li":"Limburgan",
 "ln":"Lingala",
 "lo":"Lao",
 "lt":"Litvanya Dili",
 "lv":"Litvanya Dili",
 "mai":"Maithili",
 "mg":"Malagasy",
 "mh":"Marshallese",
 "mi":"Maori Dili",
 "mk":"Makedonca",
 "ml":"Malayalam",
 "mn":"Moğolca",
 "mo":"Moldavya Dili",
 "mr":"Marathi",
 "ms":"Malay",
 "mt":"Malta Dili",
 "my":"Burmese",
 "na":"Nauru",
 "nb":"Norveççe Bokmål",
 "nd":"Ndebele, North",
 "nds":"Aşağı Saksonca",
 "ne":"Nepalce",
 "ng":"Ndonga",
 "nl":"Flamanca",
 "nn":"Norveççe Nynorsk",
 "nr":"Ndebele, South",
 "nso":"Northern Sotho",
 "nv":"Navajo",
 "ny":"Chichewa",
 "oc":"Oksitan dili",
 "om":"Oromo",
 "or":"Oriya",
 "os":"Ossetian",
 "pa":"Punjabi/Panjabi",
 "pi":"Pali",
 "pl":"Lehçe",
 "ps":"Pushto",
 "pt":"Portekizce",
 "pt_BR":"Brezilya Portekizcesi",
 "qu":"Quechua",
 "rn":"Rundi",
 "ro":"Romence",
 "rom":"Çingene Dili",
 "ru":"Rusça",
 "rw":"Kinyarwanda",
 "sa":"Sanskrit",
 "sc":"Sardinian",
 "sd":"Sindhi",
 "se":"Northern Sami",
 "sg":"Sango",
 "si":"Sinhala",
 "sk":"Slovakça",
 "sl":"Slovence",
 "sm":"Samoan",
 "sn":"Shona",
 "so":"Somalice",
 "sq":"Albanian",
 "sr":"Sırpça",
 "sr@ijekavian":"Sırpça Ijekavian",
 "sr@ijekavianlatin":"Sırpça Ijekavian Latin",
 "sr@latin":"Sırpça Latin",
 "ss":"Swati",
 "st":"Sotho, Southern",
 "su":"Sundanese",
 "sv":"İsveççe",
 "sw":"Swahili",
 "ta":"Tamil Dili",
 "te":"Telugu",
 "tg":"Tajik",
 "th":"Thai",
 "ti":"Tigrinya",
 "tk":"Türkmence",
 "tn":"Tswana",
 "to":"Tonga",
 "tr":"Türkçe",
 "ts":"Tsonga",
 "tt":"Tatar",
 "tw":"Twi",
 "ty":"Tahitian",
 "ug":"Uygurca",
 "uk":"Ukrayna Dili",
 "ur":"Urdu",
 "uz":"Özbek",
 "uz@cyrillic":"Özbekçe (Kiril)",
 "ven":"Venda",
 "vi":"Vietnamca",
 "vo":"Volapük",
 "wa":"Valonca",
 "wo":"Wolof",
 "xh":"Xhosa",
 "yi":"Yiddish",
 "yo":"Yoruba",
 "za":"Zhuang",
 "zh":"Çince",
 "zh_CN":"Basitleştirilmiş Çince",
 "zh_HK":"Çince (Hong Kong)",
 "zh_TW":"Geleneksel Çince",
 "zu":"Zulu",
},
"uk": {
 "aa":"Афар",
 "ab":"Абхазька",
 "ae":"Авестан",
 "af":"Африкаанс",
 "am":"Амхарська",
 "ar":"Арабська",
 "as":"Асамійська",
 "ast":"Астурійська",
 "ay":"Аймарська",
 "az":"Азербайджанська",
 "ba":"Башкирська",
 "be":"Білоруська",
 "be@latin":"Білоруська (латиниця)",
 "bg":"Болгарська",
 "bh":"Біхарі",
 "bi":"Біслама",
 "bn":"Бенгальська",
 "bn_IN":"Бенгальська (Індія)",
 "bo":"Тибетська",
 "br":"Бретонська",
 "bs":"Боснійська",
 "ca":"Каталонська",
 "ca@valencia":"Каталонська (валенсійський діалект)",
 "ce":"Чеченська",
 "ch":"Чаморо",
 "co":"Корсиканська",
 "crh":"Кримсько-татарська",
 "cs":"Чеська",
 "csb":"Кашубська",
 "cu":"Церковнослов'янська",
 "cv":"Чуваська",
 "cy":"Уельська",
 "da":"Данська",
 "de":"Німецька",
 "dsb":"Нижньолужицька",
 "dz":"Дзонг-ке",
 "el":"Грецька",
 "en":"Англійська",
 "en_GB":"Англійська (Великобританія)",
 "en_US":"Англійська (США)",
 "eo":"Есперанто",
 "es":"Іспанська",
 "et":"Естонська",
 "eu":"Баскська",
 "fa":"Фарсі (Перська)",
 "fi":"Фінська",
 "fj":"Фіджійська",
 "fo":"Фарерська",
 "fr":"Французька",
 "fy":"Фризька",
 "ga":"Гаельська (Ірландія)",
 "gd":"Гаельська",
 "gl":"Галісійська",
 "gn":"Гуарані",
 "gu":"Гуджараті",
 "gv":"Манкс",
 "ha":"Гауса",
 "he":"Єврейська",
 "hi":"Хінді",
 "hne":"Чхатісгарі",
 "ho":"Хірімоту",
 "hr":"Хорватська",
 "hsb":"Верхньолужицька",
 "hu":"Угорська",
 "hy":"Вірменська",
 "hz":"Гереро",
 "ia":"Інтерлінгва",
 "id":"Індонезійська",
 "ie":"Окциденталь",
 "ik":"Інупіак",
 "io":"Ідо",
 "is":"Ісландська",
 "it":"Італійська",
 "iu":"Інуктітут",
 "ja":"Японська",
 "jv":"Яванська",
 "ka":"Грузинська",
 "ki":"Кікуйю",
 "kk":"Казахська",
 "kl":"Калаалісут",
 "km":"Кхмерська",
 "kn":"Каннада",
 "ko":"Корейська",
 "ks":"Кашмірська",
 "ku":"Курдська",
 "kv":"Комі",
 "kw":"Корнійська",
 "ky":"Киргизька",
 "la":"Латинська",
 "lb":"Люксембурзька",
 "li":"Лімбурганська",
 "ln":"Лінгала",
 "lo":"Лаоська",
 "lt":"Литовська",
 "lv":"Латвійська",
 "mai":"Майтхілі",
 "mg":"Малагасійська",
 "mh":"Маршальська",
 "mi":"Маорі",
 "mk":"Македонська",
 "ml":"Малайська",
 "mn":"Монгольська",
 "mo":"Молдовська",
 "mr":"Мараті",
 "ms":"Малайська",
 "mt":"Мальтійська",
 "my":"Бірманська",
 "na":"Науру",
 "nb":"Норвезька (Bokmål)",
 "nd":"Ндебелє, Північна",
 "nds":"Нижньосаксонська",
 "ne":"Непальська",
 "ng":"Ндонга",
 "nl":"Голландська",
 "nn":"Норвезька (Nynorsk)",
 "nr":"Ндебелє, Південна",
 "nso":"Північне Сото",
 "nv":"Навахо",
 "ny":"Чічеванська",
 "oc":"Оксітанська",
 "om":"Оромо",
 "or":"Орія",
 "os":"Осетинська",
 "pa":"Панджабська",
 "pi":"Палі",
 "pl":"Польська",
 "ps":"Пуштунська",
 "pt":"Португальська",
 "pt_BR":"Бразильська португальська",
 "qu":"Кечуа",
 "rn":"Рунді",
 "ro":"Румунська",
 "rom":"Циганська",
 "ru":"Російська",
 "rw":"Кіньяруанда",
 "sa":"Санскрит",
 "sc":"Сардинська",
 "sd":"Синдхі",
 "se":"Північна Саамі",
 "sg":"Санго",
 "si":"Сингала",
 "sk":"Словацька",
 "sl":"Словенська",
 "sm":"Самоанська",
 "sn":"Шона",
 "so":"Сомалійська",
 "sq":"Албанська",
 "sr":"Сербська",
 "sr@ijekavian":"Сербська (ієкавиця)",
 "sr@ijekavianlatin":"Сербська (ієкавиця, латиниця)",
 "sr@latin":"Сербська (латиниця)",
 "ss":"Свазі",
 "st":"Сото, Південна",
 "su":"Сунданська",
 "sv":"Шведська",
 "sw":"Суахілі",
 "ta":"Тамільська",
 "te":"Телугу",
 "tg":"Таджицька",
 "th":"Тайська",
 "ti":"Тигринійська",
 "tk":"Туркменська",
 "tn":"Тсвана",
 "to":"Тонга",
 "tr":"Турецька",
 "ts":"Цонґа",
 "tt":"Татарська",
 "tw":"Тві",
 "ty":"Таїтянська",
 "ug":"Уйгурська",
 "uk":"Українська",
 "ur":"Урду",
 "uz":"Узбецька",
 "uz@cyrillic":"Узбецька (Кирилиця)",
 "ven":"Венда",
 "vi":"В'єтнамська",
 "vo":"Волапюк",
 "wa":"Валлонська",
 "wo":"Волоф",
 "xh":"Хоза",
 "yi":"Ідиш",
 "yo":"Йоруба",
 "za":"Чжуань",
 "zh":"Китайська",
 "zh_CN":"Китайська (спрощена)",
 "zh_HK":"Китайська (Гонконг)",
 "zh_TW":"Китайська (традиційна)",
 "zu":"Зулуська",
},
"zh": {
 "aa":"阿法尔语",
 "ab":"阿布哈西亚语",
 "ae":"阿维斯陀语",
 "af":"南非荷兰语",
 "am":"阿比西尼亚语",
 "ar":"阿拉伯语",
 "as":"阿萨姆语",
 "ast":"阿斯图里亚斯语",
 "ay":"艾马拉语",
 "az":"阿塞拜疆语",
 "ba":"巴什基尔语",
 "be":"白俄罗斯语",
 "be@latin":"白俄罗斯语(拉丁语系)",
 "bg":"保加利亚语",
 "bh":"比哈尔语",
 "bi":"比斯拉马语",
 "bn":"孟加拉语",
 "bn_IN":"孟加拉语(印度)",
 "bo":"藏语",
 "br":"布里多尼语",
 "bs":"波斯尼亚语",
 "ca":"加泰罗尼亚语",
 "ca@valencia":"加泰罗尼亚(瓦伦西亚)语",
 "ce":"车臣语",
 "ch":"查莫罗语",
 "co":"科西嘉语",
 "crh":"克里米亚鞑靼语",
 "cs":"捷克语",
 "csb":"卡舒比语",
 "cu":"古教会斯拉夫语",
 "cv":"楚瓦什语",
 "cy":"威尔士语",
 "da":"丹麦语",
 "de":"德语",
 "dsb":"下索布语",
 "dz":"不丹语",
 "el":"希腊语",
 "en":"英语",
 "en_GB":"英国英语",
 "en_US":"美国英语",
 "eo":"世界语",
 "es":"西班牙语",
 "et":"爱沙尼亚语",
 "eu":"巴斯克语",
 "fa":"波斯语",
 "fi":"芬兰语",
 "fj":"斐济语",
 "fo":"法罗群岛语",
 "fr":"法语",
 "fy":"弗里斯兰语",
 "ga":"爱尔兰盖尔语",
 "gd":"盖尔语",
 "gl":"加利西亚语",
 "gn":"瓜拉尼语",
 "gu":"古吉拉特语",
 "gv":"马恩语",
 "ha":"豪撒语",
 "he":"希伯来语",
 "hi":"印度语",
 "hne":"恰蒂斯加尔语",
 "ho":"希里莫图语",
 "hr":"克罗地亚语",
 "hsb":"上索布语",
 "hu":"匈牙利语",
 "hy":"亚美尼亚语",
 "hz":"赫雷罗语",
 "ia":"拉丁国际语",
 "id":"印度尼西亚语",
 "ie":"国际语",
 "ik":"因纽皮特语",
 "io":"伊多语",
 "is":"冰岛语",
 "it":"意大利语",
 "iu":"因纽特语",
 "ja":"日语",
 "jv":"爪哇语",
 "ka":"乔治亚语",
 "ki":"基库尤语",
 "kk":"哈萨克语",
 "kl":"格陵兰语",
 "km":"高棉语",
 "kn":"卡纳达语",
 "ko":"韩语",
 "ks":"克什米尔语",
 "ku":"库尔德语",
 "kv":"科米语",
 "kw":"康沃尔语",
 "ky":"吉尔吉斯语",
 "la":"拉丁语",
 "lb":"卢森堡语",
 "li":"林堡语",
 "ln":"林加拉语",
 "lo":"老挝语",
 "lt":"立陶宛语",
 "lv":"拉脱维亚语",
 "mai":"迈蒂利语",
 "mg":"马尔加什语",
 "mh":"马绍尔语",
 "mi":"毛利语",
 "mk":"马其顿语",
 "ml":"马拉亚拉姆语",
 "mn":"蒙古语",
 "mo":"摩尔多瓦语",
 "mr":"马拉提语",
 "ms":"马来语",
 "mt":"马耳他语",
 "my":"缅甸语",
 "na":"瑙鲁语",
 "nb":"挪威语(博克马尔语)",
 "nd":"恩德贝莱语(北部)",
 "nds":"下撒克逊语",
 "ne":"尼泊尔语",
 "ng":"恩东加语",
 "nl":"荷兰语",
 "nn":"挪威语(尼诺斯克语)",
 "nr":"恩德贝莱语(南部)",
 "nso":"北索托语",
 "nv":"纳瓦霍语",
 "ny":"齐佩瓦语",
 "oc":"欧西坦语",
 "om":"奥罗莫语",
 "or":"奥利亚语",
 "os":"奥塞梯语",
 "pa":"旁遮普语",
 "pi":"巴利语",
 "pl":"波兰语",
 "ps":"普什图语",
 "pt":"葡萄牙语",
 "pt_BR":"巴西葡萄牙语",
 "qu":"盖丘亚语",
 "rn":"隆迪语",
 "ro":"罗马尼亚语",
 "rom":"吉普赛语",
 "ru":"俄语",
 "rw":"基尼亚卢旺达语",
 "sa":"梵文",
 "sc":"撒丁语",
 "sd":"信德语",
 "se":"北萨米语",
 "sg":"桑戈语",
 "si":"僧伽罗语",
 "sk":"斯洛伐克语",
 "sl":"斯洛文尼亚语",
 "sm":"萨摩亚语",
 "sn":"修纳语",
 "so":"索马里语",
 "sq":"阿尔巴尼亚语",
 "sr":"塞尔维亚语",
 "sr@ijekavian":"塞尔维亚 Ijekavian 口音语言",
 "sr@ijekavianlatin":"塞尔维亚 Ijekavian 口音拉丁语",
 "sr@latin":"塞尔维亚拉丁语",
 "ss":"斯瓦蒂语",
 "st":"索托语(南部)",
 "su":"巽他语",
 "sv":"瑞典语",
 "sw":"斯瓦希里语",
 "ta":"泰米尔语",
 "te":"泰卢固语",
 "tg":"塔吉克语",
 "th":"泰语",
 "ti":"提格里尼亚语",
 "tk":"土库曼语",
 "tn":"茨瓦纳语",
 "to":"汤加语",
 "tr":"土耳其语",
 "ts":"聪加语",
 "tt":"鞑靼语",
 "tw":"特威语",
 "ty":"塔希提语",
 "ug":"维吾尔语",
 "uk":"乌克兰语",
 "ur":"乌尔都语",
 "uz":"乌兹别克语",
 "uz@cyrillic":"乌兹别克语(西里尔语系)",
 "ven":"文达语",
 "vi":"越南语",
 "vo":"沃拉普克语",
 "wa":"瓦龙语",
 "wo":"沃洛夫语",
 "xh":"科萨语",
 "yi":"依地语",
 "yo":"约鲁巴语",
 "za":"壮语",
 "zh":"中文",
 "zh_CN":"简体中文",
 "zh_HK":"繁体中文(香港)",
 "zh_TW":"繁体中文",
 "zu":"祖鲁语",
},
}

# End of data.py

########NEW FILE########
__FILENAME__ = generate
#!/usr/bin/python
# -*- coding: utf-8 -*-

from __future__ import unicode_literals

import codecs
import collections
import re

"""
This script van generate a dictionary of language names.
This dictionary looks as follows:

language_names = {
    "C": {
        "nl": "Dutch",
        "de": "German",
        "en": "English",
    },
    "nl": {
        "nl": "Nederlands",
        "de": "Duits",
        "en": "Engels",
    },
}

Etcetera.

It can be created from:

- the 'all_languages' file that is part of KDE (currently the only option).


This generate.py script writes the dictionary to a file named
data.py.

This script needs not to be installed to be able to use the language_names package.

"""

# Here you should name the language names to be extracted.
# If empty, all are used. "C" must be named.

# lang_names = []
lang_names = [
    "C", "en", "de", "fr", "es", "nl", "pl", "pt_BR",
    "cs", "ru", "hu", "gl", "it", "tr", "uk",
    "ja", "zh",
]


def generate_kde(fileName="/usr/share/locale/all_languages"):
    """Uses the KDE file to extract languge names.
    
    Returns the dictionary. All strings are in unicode form.
    
    """
    langs = collections.defaultdict(dict)

    group = None
    for line in codecs.open(fileName, "r", "utf-8"):
        line = line.strip()
        m = re.match(r"\[([^]]+)\]", line)
        if m:
            group = m.group(1)
        elif group and group != 'x-test':
            m = re.match(r"Name(?:\[([^]]+)\])?\s*=(.*)$", line)
            if m:
                lang, name = m.group(1) or "C", m.group(2)
                langs[lang][group] = name
    
    # correct KDE mistake
    langs["cs"]["gl"] = "Galicijský"
    return dict(langs)
    

def makestring(text):
    """Returns the text wrapped in quotes, usable as Python input (expecting unicode_literals)."""
    return '"' + re.sub(r'([\\"])', r'\\\1', text) + '"'
    

def write_dict(langs):
    """Writes the dictionary file to the 'data.py' file."""
    
    keys = sorted(filter(lambda k: k in langs, lang_names) if lang_names else langs)

    with codecs.open("data.py", "w", "utf-8") as output:
        output.write("#! python\n# -*- coding: utf-8;\n\n")
        output.write("# Do not edit, this file is generated. See generate.py.\n")
        output.write("\nfrom __future__ import unicode_literals\n")
        output.write("\n\n")    
        
        output.write("language_names = {\n")
        for key in keys:
            output.write('{0}: {{\n'.format(makestring(key)))
            for lang in sorted(langs[key]):
                output.write(' {0}:{1},\n'.format(makestring(lang), makestring(langs[key][lang])))
            output.write('},\n')
        output.write("}\n\n# End of data.py\n")


if __name__ == "__main__":
    langs = generate_kde()
    langs['zh'] = langs['zh_CN']
    write_dict(langs)


########NEW FILE########
__FILENAME__ = widget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Layout Control options widget.
"""

from __future__ import unicode_literals

import sys

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import icons
import layoutcontrol
import engrave
import userguide


class Widget(QWidget):
    
    optionsChanged = pyqtSignal()
    
    def __init__(self, tool):
        super(Widget, self).__init__(tool)
        
        layout = QVBoxLayout(spacing=1)
        self.setLayout(layout)
        
        # manual mode UI elements that need special treatment
        self.CBverbose = QCheckBox(clicked=self.optionsChanged)
        self.CBpointandclick = QCheckBox(clicked=self.optionsChanged)
        self.CBcustomfile = QCheckBox(clicked=self.optionsChanged)
        self.LEcustomfile = QLineEdit(enabled=False)
        
        # run Lily button
        self.engraveButton = QToolButton()
        self.engraveButton.setDefaultAction(
            engrave.engraver(tool.mainwindow()).actionCollection.engrave_debug)
        
        # help button
        self.helpButton = QToolButton(clicked=self.helpButtonClicked)
        self.helpButton.setIcon(icons.get('help-contents'))
        
        # add manual widgets
        hbox = QHBoxLayout()
        hbox.setContentsMargins(0, 0, 0, 0)
        hbox.addWidget(self.engraveButton)
        hbox.addWidget(self.helpButton)
        hbox.addStretch(1)
        layout.addLayout(hbox)
        layout.addWidget(self.CBverbose)
        layout.addWidget(self.CBpointandclick)
        
        # automatically processed modes
        self.checkboxes = {}
        for mode in layoutcontrol.modelist():
            self.checkboxes[mode] = cb = QCheckBox(clicked=self.optionsChanged)
            layout.addWidget(cb)
        
        # add manual widgets
        layout.addWidget(self.CBcustomfile)
        layout.addWidget(self.LEcustomfile)
        layout.addStretch(1)
        
        # connect manual widgets
        self.CBcustomfile.toggled.connect(self.LEcustomfile.setEnabled)
        self.LEcustomfile.textEdited.connect(self.optionsChanged)
        
        app.translateUI(self)
        self.loadSettings()
        tool.mainwindow().aboutToClose.connect(self.saveSettings)
    
    def translateUI(self):
        for mode in layoutcontrol.modelist():
            label = layoutcontrol.label(mode)
            tooltip = layoutcontrol.tooltip(mode)
            self.checkboxes[mode].setText(label)
            self.checkboxes[mode].setToolTip(tooltip)
        self.helpButton.setText(_("Help"))
        self.helpButton.setToolTip(_("Help"))
        self.CBverbose.setText(_("Verbose output"))
        self.CBverbose.setToolTip(_("Run LilyPond with verbose output"))
        self.CBpointandclick.setText(_("Point-and-Click"))
        self.CBpointandclick.setToolTip(_("Run LilyPond in preview mode (with Point and Click)"))
        self.CBcustomfile.setText(_("Include Custom File:"))
        self.CBcustomfile.setToolTip(_("Include a custom file with definitions\n"
                      "for additional Layout Control Modes"))
        self.LEcustomfile.setToolTip(_("Filename to be included"))
    
    def loadSettings(self):
        """Called on construction. Load settings and set checkboxes state."""
        s = QSettings()
        s.beginGroup('lilypond_settings')
        for mode in layoutcontrol.modelist():
            self.checkboxes[mode].setChecked(s.value(mode, False, bool))
        self.CBverbose.setChecked(s.value('verbose', False, bool))
        self.CBpointandclick.setChecked(s.value('point-and-click', True, bool))
        self.CBcustomfile.setChecked(s.value('custom-file', False, bool))
        self.LEcustomfile.setText(s.value('custom-filename', '', type("")))
        
    def saveSettings(self):
        """Called on close. Save settings and checkboxes state."""
        s = QSettings()
        s.beginGroup('lilypond_settings')
        for mode in layoutcontrol.modelist():
            s.setValue(mode, self.checkboxes[mode].isChecked())
        s.setValue('verbose', self.CBverbose.isChecked())
        s.setValue('point-and-click', self.CBpointandclick.isChecked())
        s.setValue('custom-file', self.CBcustomfile.isChecked())
        s.setValue('custom-filename', self.LEcustomfile.text())

    def helpButtonClicked(self):
        userguide.show("engrave_layout")
        
    def preview_options(self):
        """Return a list of Debug Mode command line options for LilyPond."""
        args = []
        
        # 'automatic' widgets
        for mode in layoutcontrol.modelist():
            if self.checkboxes[mode].isChecked():
                args.append(layoutcontrol.option(mode))
        
        # manual widgets
        if self.CBcustomfile.isChecked():
            file_to_include = self.LEcustomfile.text()
            args.append('-ddebug-custom-file=' + file_to_include)
        
        # if at least one debug mode is used, add the directory with the
        # preview-mode files to the search path
        if args:
            args.insert(0, '-I' + layoutcontrol.__path__[0])
            # File that conditionally includes different formatters
            args.insert(1, '-dinclude-settings=debug-layout-options.ly') 
        
        if self.CBpointandclick.isChecked():
            args.insert(0, '-dpoint-and-click')
        else:
            args.insert(0, '-dno-point-and-click')
        
        if self.CBverbose.isChecked():
            args.insert(0, '--verbose')
        
        if self.CBcustomfile.isChecked():
            file_to_include = self.LEcustomfile.text()
            if file_to_include:
                args.append('-ddebug-custom-file=' + file_to_include)
        return args



########NEW FILE########
__FILENAME__ = lilychooser
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A chooser combobox to choose a LilyPond instance.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QComboBox

import app
import lilypondinfo
import icons


class LilyChooser(QComboBox):
    def __init__(self, parent=None):
        super(LilyChooser, self).__init__(parent)
        self._infos = []
        app.translateUI(self)
        app.settingsChanged.connect(self.load)
        self.load()
    
    def translateUI(self):
        self.setToolTip(_("Choose the desired LilyPond version."""))
    
    def setLilyPondInfo(self, info):
        """Set the current LilyPond info (one of lilypondinfo.infos())."""
        try:
            self.setCurrentIndex(self._infos.index(info))
        except IndexError:
            pass
    
    def lilyPondInfo(self):
        """Get the current LilyPond info."""
        if self._infos:
            return self._infos[self.currentIndex()]
    
    def load(self):
        """Load the available LilyPond infos."""
        infos = lilypondinfo.infos() or [lilypondinfo.default()]
        infos.sort(key = lambda i: i.version() or (999,))
        cur = self._infos[self.currentIndex()] if self._infos else lilypondinfo.preferred()
        self._infos = infos
        block = self.blockSignals(True)
        try:
            self.clear()
            index = 0
            for i, info in enumerate(infos):
                icon = 'lilypond-run' if info.version() else 'dialog-error'
                self.addItem(icons.get(icon), info.prettyName())
                if info.abscommand() == cur.abscommand() or info.command == cur.command:
                    index = i
            self.setCurrentIndex(index)
        finally:
            self.blockSignals(block)



########NEW FILE########
__FILENAME__ = documentation
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manage access to LilyPond documentation.
"""

from __future__ import unicode_literals

import os
import re

from PyQt4.QtCore import pyqtSignal, QObject, QUrl
from PyQt4.QtNetwork import QNetworkRequest

import network


class Documentation(QObject):
    """An instance of LilyPond documentation."""
    versionLoaded = pyqtSignal(bool)
    
    def __init__(self, url):
        QObject.__init__(self)
        self._url = url
        self._localFile = url.toLocalFile()
        self._versionString = None
        
        # determine version
        url = self.url()
        sep = '/' if not url.path().endswith('/') else ''
        url.setPath(url.path() + sep + 'VERSION')
        self._request(url)
    
    def _request(self, url):
        """Request a URL to read the version from."""
        reply = self._reply = network.get(url)
        if reply.isFinished():
            self._handleReply()
        else:
            reply.finished.connect(self._handleReply)
    
    def _handleReply(self):
        self._reply.deleteLater()
        if self._reply.error():
            self._versionString = ''
        else:
            # HTTP redirect?
            url = self._reply.attribute(QNetworkRequest.RedirectionTargetAttribute)
            if url is not None:
                if url.path().endswith('/VERSION'):
                    self._request(self._reply.url().resolved(url))
                    return
                else:
                    # the redirect was not to a VERSION file, discard it
                    self._versionString = ''
            else:
                v = bytes(self._reply.readAll()).strip()
                if v.startswith(b'<'):
                    # probably some HTML network error message
                    self._versionString = ''
                else:
                    self._versionString = v[:16].decode('utf-8', 'replace')
        self.versionLoaded.emit(bool(self._versionString))
        
    def url(self):
        return QUrl(self._url)
    
    def home(self):
        """Returns the url with 'Documentation' appended."""
        url = self.url()
        sep = '/' if not url.path().endswith('/') else ''
        url.setPath(url.path() + sep + 'Documentation')
        if self.version() is not None and self.version() >= (2, 13, 8):
            url.setPath(url.path() + '/web/manuals')
        else:
            url.setPath(url.path() + '/index')
        return url
    
    def versionString(self):
        """Returns the version as a string.
        
        If the version is not yet determined, returns None.
        If the version could not be determined, returns the empty string.
        
        """
        return self._versionString
    
    def version(self):
        """Returns the version as a tuple of ints.
        
        If the version is not yet determined, returns None.
        If the version could not be determined, returns the empty tuple.
        
        """
        if self._versionString is not None:
            return tuple(map(int, re.findall(br"\d+", self._versionString)))
    
    def isLocal(self):
        """Returns True if the documentation is on the local system."""
        return bool(self._localFile)



########NEW FILE########
__FILENAME__ = manager
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manage access to LilyPond documentation.
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import QSettings, QUrl

import app
import util
import signals

from . import documentation


# cache the LilyPond Documentation instances
_documentations = None


allLoaded = signals.Signal()


def docs():
    """Returns the list of Documentation instances that are found."""
    global _documentations
    if _documentations is None:
        _documentations = [documentation.Documentation(url) for url in urls()]
        _sort_docs()
        # check whether they need to fully load their version number yet
        _check_doc_versions()
    return list(_documentations)


def clear():
    """Clears the cached documentation instances."""
    global _documentations
    _documentations = None


app.settingsChanged.connect(clear, -100)


def loaded():
    """Returns True if all Documentation are loaded (i.e. know their version).
    
    If this function returns False, you can connect to the allLoaded signal
    to get a notification when all Documentation instances have loaded their
    version information. This signal will only be emitted once, after that all
    connections will be removed from the signal.
    
    """
    for d in docs():
        if d.versionString() is None:
            return False
    return True


def _check_doc_versions():
    """Checks if all documentation instances have their version loaded.
    
    Emits the allLoaded signal when all are loaded, also sorts the documentation
    instances then on local/remote and then version number.
    
    """
    for d in _documentations:
        if d.versionString() is None:
            def makefunc(doc):
                def func():
                    doc.versionLoaded.disconnect(func)
                    _check_doc_versions()
                return func
            d.versionLoaded.connect(makefunc(d))
            return
    _sort_docs()
    allLoaded.emit()
    allLoaded.clear()


def _sort_docs():
    """Sorts all documentation instances on local/remote and then version."""
    _documentations.sort(key = lambda d: (not d.isLocal(), d.version() or ()))


def urls():
    """Returns a list of QUrls where documentation can be found.
    
    Remote urls (from the users settings) are not checked but simply returned.
    For user-set local directories, if the directory itself does not contain
    LilyPond documentation, all directories one level deep are searched.
    
    This makes it possible to set one directory for local documentation and
    put there multiple sets of documentation in subdirectories (e.g. with the
    version number in the path name).
    
    The paths in the settings are read, and also the usual system directories
    are scanned.
    
    """
    try:
        user_paths = QSettings().value("documentation/paths", [], type(""))
    except TypeError:
        user_paths = []
    system_prefixes = [p for p in (
        '/usr',
        '/usr/local',
        '/usr/share/doc',
        '/usr/doc',
    ) if os.path.isdir(p)]
    # split in local and non-local ones (local are preferred)
    user_prefixes = []
    local = []
    remote = []
    for p in user_paths:
        user_prefixes.append(p) if os.path.isdir(p) else remote.append(p)
    remote.sort(key=util.naturalsort)
    
    # now find all instances of LilyPond documentation in the local paths
    def paths(path):
        """Yields possible places where LilyPond documentation could live."""
        yield path
        path = os.path.join(path, 'share', 'doc', 'lilypond', 'html')
        yield path
        yield os.path.join(path, 'offline-root')
    
    def find(path):
        """Finds LilyPond documentation."""
        for p in paths(path):
            if os.path.isdir(os.path.join(p, 'Documentation')):
                return p
    
    # search in the user-set directories, if no docs, scan one level deeper
    for p in user_prefixes:
        n = find(p)
        if n:
            local.append(n)
        elif p not in system_prefixes:
            for name, dirs, files in os.walk(p):
                for d in sorted(dirs, key=util.naturalsort):
                    n = find(os.path.join(p, d))
                    if n:
                        local.append(n)
                break
    # now add the system directories if documentation is found there
    for p in system_prefixes:
        if p not in user_prefixes:
            n = find(p)
            if n:
                local.append(n)
    urls = []
    urls.extend(map(QUrl.fromLocalFile, local))
    urls.extend(map(QUrl, remote))
    if not urls:
        urls.append(QUrl("http://lilypond.org/doc/stable"))
    return urls



########NEW FILE########
__FILENAME__ = manual
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A Manual manages a searchable index for a LilyPond manual.
"""

from __future__ import unicode_literals


from PyQt4.QtCore import QObject, QUrl, pyqtSignal


class Manual(QObject):
    
    loaded = pyqtSignal(bool)
    
    def __init__(self, lilydoc):
        self._loaded = None
    
    def isLoaded(self):
        """True: successfully loaded, False: load failed, None: load pending."""
        return self._loaded
    


class NotationManual(Manual):
    """Represents the Notation Manual."""


class LearningManual(Manual):
    """Represents the Learning Manual."""
    

class InternalsReference(Manual):
    """Represents the Internals Reference."""




########NEW FILE########
__FILENAME__ = network
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Network-related utility functions for LilyPond Documentation.
"""

from PyQt4.QtCore import QSettings
from PyQt4.QtNetwork import QNetworkReply, QNetworkRequest

import app
import po
import networkaccessmanager


def accessmanager():
    """Returns a global NetworkAccessManager."""
    global _accessmanager
    try:
        _accessmanager
    except NameError:
        _accessmanager = NetworkAccessManager()
    return _accessmanager


def get(url):
    """Downloads a URL, returns a QNetworkReply."""
    request = QNetworkRequest(url)
    return accessmanager().get(request)


def langs():
    """Returns a list of language codes wished for documentation.
    
    If the list is empty, english (untranslated) is assumed.
    If a language code also has a country suffix, a hyphen will be used
    as separator (as required per RFC2616, Accept-Language header).
    
    """
    s = QSettings()
    langs = []
    lang = s.value("documentation/language", "default", type(""))

    if lang == "default":
        lang = s.value("language", "", type(""))
    if lang and lang != "C":
        langs.append(lang)
    langs.extend(po.setup.preferred())
    
    # now fixup the list, remove dups and
    # language/country codes in Accept-Language headers must have '-' and not '_'
    result = []
    def add(item):
        if item not in result:
            result.append(item)
    for l in langs:
        # if there is a language/country code, insert also the generic language code
        if '_' in l:
            add(l.replace('_', '-'))
            add(l.split('_')[0])
        else:
            add(l)
    return result


class NetworkAccessManager(networkaccessmanager.NetworkAccessManager):
    """A NetworkAccessManager that maintains some settings from the preferences."""
    def __init__(self, parent=None):
        super(NetworkAccessManager, self).__init__(parent)
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
    
    def readSettings(self):
        l = langs()
        if 'en' not in l:
            l.append('en')
        self.headers['Accept-Language'] = ','.join(l)




########NEW FILE########
__FILENAME__ = lilypondinfo
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Settings stuff and handling for different LilyPond versions.
"""

from __future__ import unicode_literals

import glob
import os
import sys
import re

from PyQt4.QtCore import QEventLoop, QSettings, QTimer
from PyQt4.QtGui import QProgressDialog

import app
import cachedproperty
import process
import util
import qutil


_scheduler = process.Scheduler()


_infos = None   # this can hold a list of configured LilyPondInfo instances


def infos():
    """Returns all configured LilyPondInfo for the different used LilyPond versions."""
    global _infos
    if _infos is None:
        s = QSettings()
        _infos = []
        for i in range(s.beginReadArray("lilypondinfo")):
            s.setArrayIndex(i)
            info = LilyPondInfo.read(s)
            if info:
                _infos.append(info)
        s.endArray()
        if not _infos:
            info = default()
            if info.abscommand():
                _infos.append(info)
        app.aboutToQuit.connect(saveinfos)
    return _infos


def setinfos(infos):
    """Sets the info's to the given list of LilyPondInfo instances."""
    global _infos
    _infos = infos
    

def saveinfos():
    """Saves the info's."""
    s = QSettings()
    s.beginWriteArray("lilypondinfo")
    for i, info in enumerate(infos()):
        s.setArrayIndex(i)
        info.write(s)
    s.endArray()


def default():
    """Returns a default LilyPondInfo instance with the default LilyPond command.
    
    On Windows, the default command is "lilypond-windows.exe",
    on other platforms simply "lilypond".
    
    """
    lilypond = "lilypond-windows.exe" if os.name == "nt" else "lilypond"
    return LilyPondInfo(lilypond)


def preferred():
    """Returns the preferred (user set default) LilyPondInfo instance."""
    infos_ = infos()
    if not infos_:
        return default()
    elif len(infos_) == 1:
        return infos_[0]
    s = QSettings()
    s.beginGroup("lilypond_settings")
    # find default version
    defaultCommand = "lilypond-windows.exe" if os.name == "nt" else "lilypond"
    userDefault = s.value("default", defaultCommand, type(""))
    if userDefault != defaultCommand:
        for info in infos_:
            if info.command == userDefault:
                return info
    for info in infos_:
        if info.command == defaultCommand:
            return info
    return infos_[0]


def suitable(version):
    """Return a LilyPondInfo with a suitable version if found.
    
    Otherwise the most recent LilyPond version is returned.
    
    """
    infos_ = [i for i in infos() if i.auto]
    if infos_:
        infos_.sort(key=lambda i: i.version())
        for i in infos_:
            if i.version() >= version:
                return i
        return i # return the latest anyway
    return preferred()


class CachedProperty(cachedproperty.CachedProperty):
    def wait(self, msg=None, timeout=0):
        """Returns the value for the property, waiting for it to be computed.
        
        If this lasts longer than 2 seconds, a progress dialog is displayed.
        
        """
        if self.get() is None:
            self.start()
            if self.get() is None:
                if msg is None:
                    msg = _("Running LilyPond, this can take some time...")
                qutil.waitForSignal(self.computed, msg, timeout)
        return self.get()
    
    __call__ = wait


class LilyPondInfo(object):
    def __init__(self, command):
        self._command = command
        self.auto = True
        self.name = "LilyPond"
        self.lilypond_book = 'lilypond-book'
        self.convert_ly = 'convert-ly'
    
    @property
    def command(self):
        return self._command
    
    @CachedProperty.cachedproperty
    def abscommand(self):
        """The absolute path of the command."""
        if os.name == "nt":
            # on Windows, newer versions of LilyPond don't add themselves to the
            # PATH, so add a probable path here
            path = glob.glob(os.path.join(
                os.environ.get('ProgramFiles', 'C:\\Program Files'),
                'LilyPond*', 'usr', 'bin'))
        elif sys.platform.startswith('darwin'):
            # also on Mac OS X, LilyPond is not automatically added to the PATH
            path = [
                os.path.join('/Applications', 'LilyPond.app', 'Contents', 'Resources', 'bin'),
                os.path.join('/opt', 'local', 'bin'),
            ]
        else:
            path = None
        return util.findexe(self.command, path) or False
    
    @CachedProperty.cachedproperty(depends=abscommand)
    def displaycommand(self):
        """The path to the command in a format pretty to display.
        
        This removes the 'out/bin/lilypond' part of custom build LilyPond
        versions, and on Mac OS X it removes the
        '/Contents/Resources/bin/lilypond' part.
        
        Finally it replaces the users home directory with '~'.
        
        The empty string is returned if LilyPond is not installed on the users'
        system.
        """
        command = self.abscommand()
        if command:
            outstrip='out/bin/lilypond'
            if command.endswith(outstrip):
                command=command[:-len(outstrip)]
            macstrip='/Contents/Resources/bin/lilypond'
            if sys.platform.startswith('darwin') and command.endswith('.app' + macstrip):
                command=command[:-len(macstrip)]
            return util.homify(command)
        else:
            return self.command
    
    @CachedProperty.cachedproperty(depends=abscommand)
    def versionString(self):
        if not self.abscommand():
            return ""
        
        p = process.Process([self.abscommand(), '--version'])
        
        @p.done.connect
        def done(success):
            if success:
                output = unicode(p.process.readLine())
                m = re.search(r"\d+\.\d+(.\d+)?", output)
                self.versionString = m.group() if m else ""
            else:
                self.versionString = ""
        
        _scheduler.add(p)
    
    @CachedProperty.cachedproperty(depends=versionString)
    def version(self):
        if self.versionString():
            return tuple(map(int, self.versionString().split('.')))
        return ()
    
    @CachedProperty.cachedproperty(depends=abscommand)
    def bindir(self):
        """Returns the directory the LilyPond command is in."""
        if self.abscommand():
            return os.path.dirname(self.abscommand())
        return False
    
    @CachedProperty.cachedproperty(depends=bindir)
    def prefix(self):
        """Returns the prefix LilyPond was installed to."""
        if self.bindir():
            return os.path.dirname(self.bindir())
        return False
        
    @CachedProperty.cachedproperty(depends=(prefix, versionString))
    def datadir(self):
        """Returns the datadir of this LilyPond instance.
        
        Most times this is something like "/usr/share/lilypond/2.13.3/"
        If this method returns False, the datadir could not be determined.
        
        """
        if not self.abscommand():
            return False
        
        # First ask LilyPond itself.
        p = process.Process([self.abscommand(), '-e',
            "(display (ly:get-option 'datadir)) (newline) (exit)"])
        @p.done.connect
        def done(success):
            if success:
                d = unicode(p.process.readLine()).strip('\n')
                if os.path.isabs(d) and os.path.isdir(d):
                    self.datadir = d
                    return
            
            # Then find out via the prefix.
            if self.prefix():
                dirs = ['current']
                if self.versionString():
                    dirs.append(self.versionString())
                for suffix in dirs:
                    d = os.path.join(self.prefix(), 'share', 'lilypond', suffix)
                    if os.path.isdir(d):
                        self.datadir = d
                        return
            self.datadir = False
        _scheduler.add(p)
    
    def toolcommand(self, command):
        """Return a list containing the commandline to run a tool, e.g. convert-ly.
        
        On Unix and Mac OS X, the list has one element: the full path to the tool.
        On Windows, the list has two elements: the LilyPond-provided Python
        interpeter and the tool path.
        
        """
        toolpath = os.path.join(self.bindir(), command)
        
        # on Windows the tool command is not directly executable, but
        # must be started using the LilyPond-provided Python interpreter
        if os.name == "nt":
            if not os.access(toolpath, os.R_OK) and not toolpath.endswith('.py'):
                toolpath += '.py'
            command = [self.python(), toolpath]
        else:
            command = [toolpath]
        return command
    
    @CachedProperty.cachedproperty(depends=versionString)
    def prettyName(self):
        """Return a pretty-printable name for this LilyPond instance."""
        return "{name} {version} ({command})".format(
            name = self.name,
            version = self.versionString(),
            command = self.displaycommand())
    
    @classmethod
    def read(cls, settings):
        """Returns a new LilyPondInfo instance, filled from a QSettings instance.
        
        May return None, if the command is not existing.
        
        """
        cmd = settings.value("command", "", type(""))
        if cmd:
            info = cls(cmd)
            if info.abscommand.wait():
                info.auto = settings.value("auto", True, bool)
                info.name = settings.value("name", "LilyPond", type(""))
                info.lilypond_book = settings.value("lilypond-book", "lilypond-book", type(""))
                info.convert_ly = settings.value("convert-ly", "convert-ly", type(""))
                if int(os.path.getmtime(info.abscommand())) == int(settings.value("mtime", 0, float)):
                    info.versionString = settings.value("version", "", type(""))
                    datadir = settings.value("datadir", "", type(""))
                    if datadir and os.path.isdir(datadir):
                        info.datadir = datadir
                return info

    def write(self, settings):
        """Writes ourselves to a QSettings instance. We should be valid."""
        settings.setValue("command", self.command)
        settings.setValue("version", self.versionString())
        settings.setValue("datadir", self.datadir() or "")
        if self.abscommand():
            settings.setValue("mtime", int(os.path.getmtime(self.abscommand())))
        settings.setValue("auto", self.auto)
        settings.setValue("name", self.name)
        settings.setValue("lilypond-book", self.lilypond_book)
        settings.setValue("convert-ly", self.convert_ly)

    def python(self):
        """Returns the path to the LilyPond-provided Python interpreter.
        
        This is only used on Windows, where tools like convert-ly can't be
        run directly.
        
        """
        if self.bindir():
            for python in ('python-windows.exe', 'pythonw.exe', 'python.exe'):
                interpreter = os.path.join(self.bindir(), python)
                if os.access(interpreter, os.X_OK):
                    return interpreter
        return 'pythonw.exe'



########NEW FILE########
__FILENAME__ = listmodel
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Simple readonly subclass of QAbstractListModel around a Python sequence.

Functions are used to present the data from an item for a role.
There are some predefined functions to use in this module.
"""

from PyQt4.QtCore import QAbstractListModel, Qt


def display(item):
    """Displays an item unchanged."""
    return item

def translate(item):
    """Calls an item (normally returning a translation of the item)."""
    return item()

def display_index(index):
    """Returns a function that displays the given index of an item."""
    return lambda item: item[index]

def translate_index(index):
    """Returns a function that translates the given index of an item."""
    return lambda item: item[index]()


class ListModel(QAbstractListModel):
    """A simple QAbstractListModel around a Python list."""
    def __init__(self, data, parent=None, display=display, edit=None, tooltip=None, icon=None):
        """Initializes the list.
        
        parent may be a parent QObject.
        display, tooltip and icon may be functions that extract the data from an item
        for the respective role (DisplayRole, ToolTipRole or DecorationRole).
        
        The original data can be found in the _data attribute.
        
        """
        super(ListModel, self).__init__(parent)
        self._data = data
        self._roles = {}
        if edit is None:
            edit = display
        if display:
            self._roles[Qt.DisplayRole] = display
        if edit:
            self._roles[Qt.EditRole] = edit
        if tooltip:
            self._roles[Qt.ToolTipRole] = tooltip
        if icon:
            self._roles[Qt.DecorationRole] = icon
    
    def setRoleFunction(self, role, function):
        """Sets a function that returns a value for a Qt.ItemDataRole.
        
        The function accepts an item in the data list given on construction
        as argument. If function is None, deletes a previously set function.
        
        """
        if function:
            self._roles[role] = function
        elif role in self._roles:
            del self._roles[role]
    
    def rowCount(self, parent):
        return 0 if parent.isValid() else len(self._data)
    
    def data(self, index, role):
        try:
            data = self._data[index.row()]
        except IndexError:
            return
        try:
            f = self._roles[role]
        except KeyError:
            return
        return f(data)

    def update(self):
        """Emits the dataChanged signal for all entries.
        
        This can e.g. be used to request that translated strings are redisplayed.
        
        """
        self.dataChanged.emit(
            self.createIndex(0, 0),
            self.createIndex(len(self._data) - 1, 0))



########NEW FILE########
__FILENAME__ = log
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A Log shows the output of a Job.
"""

from __future__ import unicode_literals

import contextlib

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import job
import qutil


class Log(QTextBrowser):
    """Widget displaying output from a Job."""
    def __init__(self, parent=None):
        super(Log, self).__init__(parent)
        self.setOpenLinks(False)
        self.cursor = QTextCursor(self.document())
        self._types = job.ALL
        self._lasttype = None
        self._formats = self.logformats()
        
    def setMessageTypes(self, types):
        """Set the types of Job output to display.
        
        types is a constant bitmask from job, like job.STDOUT etc.
        By default job.ALL is used.
        
        """
        self._types = types
    
    def messageTypes(self):
        """Return the set message types (job.ALL by default)."""
        return self._types
    
    def connectJob(self, job):
        """Gives us the output from the Job (past and upcoming)."""
        for msg, type in job.history():
            self.write(msg, type)
        job.output.connect(self.write)
        
    def textFormat(self, type):
        """Returns a QTextFormat() for the given type."""
        return self._formats[type]

    def write(self, message, type):
        """Writes the given message with the given type to the log.
        
        The keepScrolledDown context manager is used to scroll the log further
        down if it was scrolled down at that moment.
        
        If two messages of a different type are written after each other a newline
        is inserted if otherwise the message would continue on the same line.
        
        """
        if type & self._types:
            with self.keepScrolledDown():
                changed = type != self._lasttype
                self._lasttype = type
                if changed and self.cursor.block().text() and not message.startswith('\n'):
                    self.cursor.insertText('\n')
                self.writeMessage(message, type)
    
    def writeMessage(self, message, type):
        """Inserts the given message in the text with the textformat belonging to type."""
        self.cursor.insertText(message, self.textFormat(type))
    
    @contextlib.contextmanager
    def keepScrolledDown(self):
        """Performs a function, ensuring the log stays scrolled down if it was scrolled down on start."""
        vbar = self.verticalScrollBar()
        scrolleddown = vbar.value() == vbar.maximum()
        try:
            yield
        finally:
            if scrolleddown:
                vbar.setValue(vbar.maximum())
    
    def logformats(self):
        """Returns a dictionary with QTextCharFormats for the different types of messages.
        
        Besides the STDOUT, STDERR, NEUTRAL, FAILURE and SUCCESS formats there is also
        a "link" format, that looks basically the same as the output formats, but blueish
        and underlined, to make parts of the output (e.g. filenames) look clickable.
        
        """
        textColor = QApplication.palette().color(QPalette.WindowText)
        successColor = qutil.addcolor(textColor, 0, 128, 0) # more green
        failureColor = qutil.addcolor(textColor, 128, 0, 0) # more red
        linkColor    = qutil.addcolor(textColor, 0, 0, 128) # more blue
        stdoutColor  = qutil.addcolor(textColor, 64, 64, 0) # more purple
        
        s = QSettings()
        s.beginGroup("log")
        outputFont = QFont(s.value("fontfamily", "monospace", type("")))
        outputFont.setPointSizeF(s.value("fontsize", 9.0, float))
        
        output = QTextCharFormat()
        output.setFont(outputFont)
        
        stdout = QTextCharFormat(output)
        stdout.setForeground(stdoutColor)
        
        stderr = QTextCharFormat(output)
        link   = QTextCharFormat(output)
        link.setForeground(linkColor)
        link.setFontUnderline(True)
        
        status = QTextCharFormat()
        status.setFontWeight(QFont.Bold)
        
        neutral = QTextCharFormat(status)
        
        success = QTextCharFormat(status)
        success.setForeground(successColor)
        
        failure = QTextCharFormat(status)
        failure.setForeground(failureColor)
        
        return {
            job.STDOUT: stdout,
            job.STDERR: stderr,
            job.NEUTRAL: neutral,
            job.SUCCESS: success,
            job.FAILURE: failure,
            'link': link,
        }




########NEW FILE########
__FILENAME__ = errors
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages cursor positions of file-references in error messages.
"""

from __future__ import unicode_literals

import os
import re
import sys

from PyQt4.QtCore import QSettings, QUrl
from PyQt4.QtGui import QTextCursor

import app
import bookmarks
import plugin
import job
import jobmanager
import jobattributes
import scratchdir
import util


# finds file references (filename:line:col:) in messages
message_re = re.compile(br"^((.*?):(\d+)(?::(\d+))?)(?=:)", re.M)


def errors(document):
    return Errors.instance(document)


class Errors(plugin.DocumentPlugin):
    """Maintains the list of references (errors/warnings) to documents after a Job run."""
    
    def __init__(self, document):
        self._refs = {}
        mgr = jobmanager.manager(document)
        if mgr.job():
            self.connectJob(mgr.job())
        mgr.started.connect(self.connectJob)
        
    def connectJob(self, job):
        """Starts collecting the references of a started Job.
        
        Output already created by the Job is read and we start
        listening for new output.
        
        """
        # do not collect errors for auto-engrave jobs if the user has disabled it
        if jobattributes.get(job).hidden and QSettings().value("log/hide_auto_engrave", False, bool):
            return
        # clear earlier set error marks
        docs = set([self.document()])
        for ref in self._refs.values():
            c = ref.cursor(False)
            if c:
                docs.add(c.document())
        for doc in docs:
            bookmarks.bookmarks(doc).clear("error")
        self._refs.clear()
        # take over history and connect
        for msg, type in job.history():
            self.slotJobOutput(msg, type)
        job.output.connect(self.slotJobOutput)
    
    def slotJobOutput(self, message, type):
        """Called whenever the job has output.
        
        The output is checked for error messages that contain
        a filename:line:column expression.
        
        """
        if type == job.STDERR:
            enc = sys.getfilesystemencoding()
            for m in message_re.finditer(message.encode('latin1')):
                url = m.group(1).decode(enc)
                filename = m.group(2).decode(enc)
                filename = util.normpath(filename)
                line, column = int(m.group(3)), int(m.group(4) or 0)
                self._refs[url] = Reference(filename, line, column)
        
    def cursor(self, url, load=False):
        """Returns a QTextCursor belonging to the url (string).
        
        If load (defaulting to False) is True, the document is loaded
        if it wasn't already loaded.
        Returns None if the url was not valid or the document could not be loaded.
        
        """
        return self._refs[url].cursor(load)


class Reference(object):
    """Represents a reference to a line/column pair (a cursor position) in a Document."""
    def __init__(self, filename, line, column):
        """Creates the reference to filename, line and column.
        
        lines start numbering with 1, columns with 0 (LilyPond convention).
        
        If a document with the given filename is already loaded (or the filename
        refers to the scratchdir for a document) a QTextCursor is created immediately.
        
        Otherwise, when a Document is loaded later with our filename, a QTextCursor
        is created then (by the bind() method).
        
        """
        self._filename = filename
        self._line = line
        self._column = column
        self._cursor = None
        
        app.documentLoaded.connect(self.trybind)
        for d in app.documents:
            s = scratchdir.scratchdir(d)
            if (s.directory() and util.equal_paths(filename, s.path())
                or d.url().toLocalFile() == filename):
                self.bind(d)
                break
    
    def bind(self, document):
        """Called when a document is loaded this Reference points to.
        
        Creates a QTextCursor so the position is maintained even if the document
        changes.
        
        """
        b = document.findBlockByNumber(max(0, self._line - 1))
        if b.isValid():
            self._cursor = c = QTextCursor(document)
            c.setPosition(b.position() + self._column)
            document.closed.connect(self.unbind)
            if self._line > 0:
                bookmarks.bookmarks(document).setMark(self._line - 1, "error")
        else:
            self._cursor = None
            
    def unbind(self):
        """Called when previously "bound" document is closed."""
        self._cursor = None
    
    def trybind(self, document):
        """Called whenever a new Document is loaded, checks the filename."""
        if document.url().toLocalFile() == self._filename:
            self.bind(document)

    def cursor(self, load):
        """Returns a QTextCursor for this reference.
        
        load should be True or False and determines if a not-loaded document should be loaded.
        Returns None if the document could not be loaded.
        
        """
        if self._cursor:
            return self._cursor
        if load:
            app.openUrl(QUrl.fromLocalFile(self._filename)) # also calls bind
            if self._cursor:
                return self._cursor



########NEW FILE########
__FILENAME__ = logwidget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The LogWidget.
"""

from __future__ import unicode_literals

import itertools
import os
import re
import sys
import weakref

from PyQt4.QtCore import QSettings
from PyQt4.QtGui import (
    QColor, QTextCharFormat, QTextCursor, QTextEdit, QTextFormat)

import app
import log
import job
import jobmanager
import jobattributes
import qutil

from . import errors


class LogWidget(log.Log):
    """A Log widget that tracks document changes in the MainWindow."""
    def __init__(self, logtool):
        super(LogWidget, self).__init__(logtool)
        self._rawView = True
        self._document = lambda: None
        self._errors = []
        self._currentErrorIndex = -1
        self.readSettings()
        self.anchorClicked.connect(self.slotAnchorClicked)
        logtool.mainwindow().currentDocumentChanged.connect(self.switchDocument)
        app.documentClosed.connect(self.documentClosed)
        app.settingsChanged.connect(self.readSettings)
        doc = logtool.mainwindow().currentDocument()
        if doc:
            self.switchDocument(doc)
    
    def readSettings(self):
        self._formats = self.logformats()
        self._rawView = QSettings().value("log/rawview", True, bool)
        if self._document():
            self.switchDocument(self._document()) # reload
    
    def switchDocument(self, doc):
        """Called when the document is changed."""
        job = jobmanager.job(doc)
        if job:
            # do not show the messages for auto-engrave jobs if the user has disabled it
            if jobattributes.get(job).hidden and QSettings().value("log/hide_auto_engrave", False, bool):
                return
            prevDoc = self._document()
            if prevDoc and prevDoc != doc:
                prevJob = jobmanager.job(prevDoc)
                if prevJob:
                    prevJob.output.disconnect(self.write)
            self._document = weakref.ref(doc)
            self.clear()
            self.connectJob(job)
            
    def documentClosed(self, doc):
        if doc == self._document():
            self.clear()

    def clear(self):
        self._errors = []
        self._currentErrorIndex = -1
        self.setExtraSelections([])
        super(LogWidget, self).clear()
    
    def writeMessage(self, message, type):
        """This writes both status and output messages to the log.
        
        For output messages also the correct encoding is re-applied:
        LilyPond writes filenames out in the system's filesystemencoding,
        while the messages are always written in UTF-8 encoding...
        
        """
        if type == job.STDERR:
            # find filenames in message:
            parts = iter(errors.message_re.split(message.encode('latin1')))
            msg = next(parts).decode('utf-8', 'replace')
            self.cursor.insertText(msg, self.textFormat(type))
            enc = sys.getfilesystemencoding()
            
            for url, path, line, col, msg in zip(*itertools.repeat(parts, 5)):
                url = url.decode(enc)
                path = path.decode(enc)
                msg = msg.decode('utf-8', 'replace')
                if self._rawView:
                    fmt = QTextCharFormat(self.textFormat(type))
                    display_url = url
                else:
                    fmt = QTextCharFormat(self.textFormat("link"))
                    display_url = os.path.basename(path)
                fmt.setAnchor(True)
                fmt.setAnchorHref(str(len(self._errors)))
                fmt.setToolTip(_("Click to edit this file"))
                
                pos = self.cursor.position()
                self.cursor.insertText(display_url, fmt)
                self.cursor.insertText(msg, self.textFormat(type))
                self._errors.append((pos, self.cursor.position(), url))
        else:
            if type == job.STDOUT:
                message = message.encode('latin1').decode('utf-8')
            super(LogWidget, self).writeMessage(message, type)

    def slotAnchorClicked(self, url):
        """Called when the user clicks a filename in the log."""
        index = int(url.toString())
        if 0 <= index < len(self._errors):
            self.highlightError(index)
    
    def gotoError(self, direction):
        """Jumps to the next (1) or previous (-1) error message."""
        if self._errors:
            i = self._currentErrorIndex + direction
            if i < 0:
                i = len(self._errors) - 1
            elif i >= len(self._errors):
                i = 0
            self.highlightError(i)
    
    def highlightError(self, index):
        """Hihglights the error message at the given index and jumps to its location."""
        self._currentErrorIndex = index
        # set text format
        pos, anchor, url = self._errors[index]
        es = QTextEdit.ExtraSelection()
        es.cursor = QTextCursor(self.document())
        es.cursor.setPosition(pos)
        es.cursor.setPosition(anchor, QTextCursor.KeepAnchor)
        bg = qutil.mixcolor(self.palette().highlight().color(), self.palette().base().color(), 0.4)
        es.format.setBackground(bg)
        es.format.setProperty(QTextFormat.FullWidthSelection, True)
        self.setExtraSelections([es])
        # scroll log to the message
        cursor = QTextCursor(self.document())
        cursor.setPosition(anchor)
        self.setTextCursor(cursor)
        cursor.setPosition(pos)
        self.setTextCursor(cursor)
        # jump to the error location
        cursor = errors.errors(self._document()).cursor(url, True)
        if cursor:
            self.parentWidget().mainwindow().setTextCursor(cursor, findOpenView=True)



########NEW FILE########
__FILENAME__ = barcheck
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Add, check or remove bar checks in selected music.
"""

from __future__ import unicode_literals

import collections
import itertools

import ly.document
import ly.lex.lilypond


def remove(cursor):
    """Remove bar checks from the selected music."""
    s = ly.document.Source(cursor, tokens_with_position=True)
    prv, cur = None, None
    with cursor.document as d:
        for nxt in itertools.chain(s, (None,)):
            if isinstance(cur, ly.lex.lilypond.PipeSymbol):
                if isinstance(prv, ly.lex.Space):
                    # pipesymbol and adjacent space may be deleted
                    if nxt == '\n':
                        del d[prv.pos:cur.end]
                    elif isinstance(nxt, ly.lex.Space):
                        del d[cur.pos:nxt.end]
                    else:
                        del d[cur.pos:cur.end]
                elif isinstance(nxt, ly.lex.Space):
                    # delete if followed by a space 
                    del d[cur.pos:cur.end]
                else:
                    # replace "|" with a space
                    d[cur.pos:cur.end] = " "
            prv, cur = cur, nxt


class event(object):
    """A limited event type at a certain time."""
    def __init__(self):
        self._nodes = []
        self.cadenza = None
        self.barcheck = False
        self.timesig = None
        self.partial = None
    
    def append(self, node):
        self._nodes.append(node)

    def __repr__(self):
        s = []
        if self.cadenza is not None:
            s.append('cadenza' + ('On' if self.cadenza else 'Off'))
        if self.barcheck:
            s.append('bar')
        if self.timesig is not None:
            s.append('T{0}'.format(self.timesig))
        if self.partial is not None:
            s.append('P{0}'.format(self.partial))
        if self._nodes:
            s.append(repr(self._nodes))
        return '<event {0}>'.format(' '.join(s))


def insert(cursor, music=None):
    """Insert bar checks within the selected range."""
    if music is None:
        import ly.music
        music = ly.music.document(cursor.document)
    
    if len(music) == 0:
        return
    
    if cursor.start:
        n = music.node(cursor.start, 1)
        nodes = itertools.chain((n,), n.forward())
    else:
        nodes = music
    if cursor.end is None:
        iter_nodes = iter
    else:
        predicate = lambda node: node.position < cursor.end
        def iter_nodes(it):
            return itertools.takewhile(predicate, it)
    
    # make time-based lists of events
    event_lists = []
    
    def do_topnode(node):
        if not isinstance(node, ly.music.items.Music):
            for n in node:
                do_topnode(n)
            return
        
        def do_node(node, time, scaling):
            if isinstance(node, (ly.music.items.Durable, ly.music.items.UserCommand)):
                if node.position >= cursor.start:
                    events[time].append(node)
                time += node.length() * scaling
            elif isinstance(node, ly.music.items.TimeSignature):
                events[time].timesig = node.measure_length()
            elif isinstance(node, ly.music.items.Partial):
                events[time].partial = node.length()
            elif isinstance(node, ly.music.items.PipeSymbol):
                events[time].barcheck = True
            elif isinstance(node, ly.music.items.Command) and node.token in (
                    'cadenzaOn', 'cadenzaOff'):
                events[time].cadenza = node.token == 'cadenzaOn'
            elif isinstance(node, ly.music.items.Grace):
                pass
            elif isinstance(node, ly.music.items.LyricMode):
                pass
            elif isinstance(node, ly.music.items.MusicList) and node.simultaneous:
                time = max(do_node(n, time, scaling) for n in iter_nodes(node))
            elif isinstance(node, ly.music.items.Music):
                if isinstance(node, ly.music.items.Scaler):
                    scaling *= node.scaling
                for n in iter_nodes(node):
                    time = do_node(n, time, scaling)
            else:
                do_topnode(node)
            return time
        
        events = collections.defaultdict(event)
        do_node(node, 0, 1)
        event_lists.append(sorted(events.items()))
    
    do_topnode(nodes)
    
    for event_list in event_lists:
        
        # default to 4/4 without pickup
        measure_length = 1
        measure_pos = 0
        
        for time, evt in event_list:
            print(time, evt)



########NEW FILE########
__FILENAME__ = command
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2014 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The commands that are available to the command line.
"""

from __future__ import unicode_literals

import re
import sys

import ly.docinfo
import ly.indent
import ly.pitch
import ly.reformat


class _command(object):
    """Base class for commands.
    
    If the __init__() fails with TypeError or ValueError, the command is
    considered invalid and an error message will be written to the console
    in the parse_command() function in main.py.
    
    By default, __init__() expects no arguments. If your command does accept
    arguments, they are provided in a single argument that you should parse
    yourself.
    
    """
    def __init__(self):
        pass

    def run(self, opts, cursor, output):
        pass


class set_variable(_command):
    """set a variable to a value"""
    def __init__(self, arg):
        self.name, self.value = arg.split('=', 1)

    def run(self, opts, cursor, output):
        opts.set_variable(self.name, self.value)
    

class _info_command(_command):
    """base class for commands that print some output to stdout."""
    def run(self, opts, cursor, output):
        info = ly.docinfo.DocInfo(cursor.document)
        text = self.get_info(info)
        if text:
            if opts.with_filename:
                text = cursor.document.filename + ":" + text
            sys.stdout.write(text + '\n')
    
    def get_info(self, info):
        """Should return the desired information from the docinfo object.
        
        If it returns None or an empty string, nothing is printed.
        
        """
        raise NotImplementedError()


class mode(_info_command):
    """print mode to stdout"""
    def get_info(self, info):
        return info.mode()


class version(_info_command):
    """print version to stdout"""
    def get_info(self, info):
        return info.version_string()


class language(_info_command):
    """print language to stdout"""
    def get_info(self, info):
        return info.language()


class _edit_command(_command):
    """a command that edits the source file"""
    pass


class indent(_edit_command):
    """run the indenter"""
    def indenter(self, opts):
        """Get a ly.indent.Indenter initialized with our options."""
        i = ly.indent.Indenter()
        i.indent_tabs = opts.indent_tabs
        i.indent_width = opts.indent_width
        return i
    
    def run(self, opts, cursor, output):
        self.indenter(opts).indent(cursor)


class reformat(indent):
    """reformat the document"""
    def run(self, opts, cursor, output):
        ly.reformat.reformat(cursor, self.indenter(opts))


class translate(_edit_command):
    """translate pitch names"""
    def __init__(self, language):
        if language not in ly.pitch.pitchInfo:
            raise ValueError()
        self.language = language
    
    def run(self, opts, cursor, output):
        import ly.pitch.translate
        try:
            changed = ly.pitch.translate.translate(cursor, self.language)
        except ly.pitch.PitchNameNotAvailable:
            sys.stderr.write(
                "warning: transate: pitch names not available in \"{0}\"\n"
                "  skipping file: {1}\n".format(self.language, cursor.document.filename))
            return
        if not changed:
            version = ly.docinfo.DocInfo(cursor.document).version()
            ly.pitch.translate.insert_language(cursor.document, self.language, version)


class transpose(_edit_command):
    """transpose music"""
    def __init__(self, arg):
        result = []
        for pitch, octave in re.findall(r"([a-z]+)([,']*)", arg):
            r = ly.pitch.pitchReader("nederlands")(pitch)
            if r:
                result.append(ly.pitch.Pitch(*r, octave=ly.pitch.octaveToNum(octave)))
        self.from_pitch, self.to_pitch = result
    
    def run(self, opts, cursor, output):
        import ly.pitch.transpose
        transposer = ly.pitch.transpose.Transposer(self.from_pitch, self.to_pitch)
        try:
            ly.pitch.transpose.transpose(cursor, transposer)
        except ly.pitch.PitchNameNotAvailable:
            language = ly.docinfo.DocInfo(cursor.document).language() or "nederlands"
            sys.stderr.write(
                "warning: transpose: pitch names not available in \"{0}\"\n"
                "  skipping file: {1}\n".format(language, cursor.document.filename))


class rel2abs(_edit_command):
    """convert relative music to absolute"""
    def run(self, opts, cursor, output):
        import ly.pitch.rel2abs
        ly.pitch.rel2abs.rel2abs(cursor)


class abs2rel(_edit_command):
    """convert absolute music to relative"""
    def run(self, opts, cursor, output):
        import ly.pitch.abs2rel
        ly.pitch.rel2abs.abs2rel(cursor)


class _export_command(_command):
    """Command that exports to a file."""
    def __init__(self, output=None):
        self.output = output


class musicxml(_export_command):
    def run(self, opts, cursor, output):
        import ly.musicxml
        writer = ly.musicxml.writer()
        writer.parse_tokens(ly.docinfo.DocInfo(cursor.document).tokens)
        xml = writer.musicxml()
        if self.output:
            filename = self.output
        else:
            filename = output.get_filename(opts, cursor.document.filename)
        encoding = opts.output_encoding or "utf-8"
        with output.file(opts, filename, "binary") as f:
            xml.write(f, encoding)


class write(_command):
    """write the source file."""
    def __init__(self, output=None):
        self.output = output
    
    def run(self, opts, cursor, output):
        # determine the real output filename to use
        encoding = opts.output_encoding or opts.encoding
        if self.output:
            filename = self.output
        elif opts.in_place:
            if not cursor.document.modified and encoding == opts.encoding:
                return
            filename = cursor.document.filename
        else:
            filename = output.get_filename(opts, cursor.document.filename)
        with output.file(opts, filename, encoding) as f:
            f.write(cursor.document.plaintext())


class highlight(_export_command):
    """write syntax colored HTML."""
    def run(self, opts, cursor, output):
        import ly.colorize
        w = ly.colorize.HtmlWriter()
        
        w.inline_style = opts.inline_style
        w.stylesheet_ref = opts.stylesheet
        w.number_lines = opts.number_lines
        w.title = cursor.document.filename
        w.encoding = opts.output_encoding or "utf-8"
        
        doc = w.html(cursor)
        if self.output:
            filename = self.output
        else:
            filename = output.get_filename(opts, cursor.document.filename)
        with output.file(opts, filename, w.encoding) as f:
            f.write(doc)


hl = highlight


########NEW FILE########
__FILENAME__ = main
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2014 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The entry point for the 'ly' command.
"""

from __future__ import unicode_literals

import contextlib
import copy
import io
import os
import shutil
import sys

import ly.pkginfo


def usage():
    """Print usage info."""
    sys.stdout.write("""\
Usage: ly [options] commands file, ...

A tool for manipulating LilyPond source files

OPTIONS

  -v, --version         show version number and exit
  -h, --help            show this help text and exit
  -i, --in-place        overwrite input files
  -o, --output NAME     output file name
  -e, --encoding ENC    (input) encoding (default UTF-8)
  --output-encoding ENC output encoding (default to input encoding)
  -d variable=value     set a variable
  --                    consider the remaining arguments to be file names

ARGUMENTS

The command is one argument with semicolon-separated commands. In most cases
you'll quote the command so that it is seen as one argument.

You can specify more than one LilyPond file. If you want to process many 
files and write the results of the operations on each file to a separate 
output file, you can use two special characters in the output filename: a 
'*' will be replaced with the full path name of the current input file 
(without extension), and a '?' will be replaced with the input filename 
(without path and extension). If you don't want to have '*' or '?' replaced 
in the output filename, you can set -d replace-pattern=false.

If you don't specify input or output filenames, standard input is read and
standard output is written to.


COMMANDS
  
Informative commands that write information to standard output and do not
change the file:

  mode                  print the mode (guessing if not given) of the document
  version               print the LilyPond version, if set in the document
  language              print the pitch name language, if set in the document
  
Commands that change the file:

  indent                re-indent the file
  reformat              reformat the file
  translate language    translate the pitch names to the language
  transpose from to     transpose the file like LilyPond would do, pitches
                        are given in the 'nederlands' language
  abs2rel               convert absolute music to relative
  rel2abs               convert relative music to absolute
  write [filename]      write the file to the given filename or the output
                        variable. If the last command was an editing command,
                        write is automatically called.

Commands that export the file to another format:

  musicxml [filename]   exports to MusicXML (in development, far from complete)
  highlight [filename]  exports the document as syntax colored HTML
  hl [filename]         alias for highlight

Between commands, you can set or unset a variable using:

  variable=value        set a variable to value. Special values are true, false,
                        which are interpreted as boolean values, or digits,
                        which will be interpreted as integer values.
  variable=             unset a variable


VARIABLES

The following variables can be set to influence the behaviour of commands.
If there is a default value, it is written between brackets:

  mode                  mode of the file to read (default automatic) can be one
                        of: lilypond, scheme, latex, html, docbook, texinfo.
  output [-]            the output filename (also set by -o argument)
  encoding [UTF-8]      encoding to read (also set by -e argument)
  output-encoding       encoding to write (defaults to encoding, also
                        set by --output-encoding argument)
  in-place [false]      whether to overwrite input files (same as -i)
  backup-suffix [~]     suffix to use when editing files in-place, if set,
                        backs up the original file before overwriting it
  replace-pattern [true] whether to replace '*' and '?' in the output filename.
  indent-tabs [false]   whether to use tabs for indent
  indent-width [2]      how many spaces for each indent level (if not using
                        tabs)
  stylesheet            filename to reference as an external stylesheet for
                        syntax-highlighted HTML. This filename is literally used
                        in the <link rel="stylesheet"> tag.
  inline-style [false]  whether to use inline style attributes for syntax-
                        highlighted HTML. By default a css shylesheet is embed-
                        ded.
  number-lines [false]  whether to add line numbers when creating syntax-
                        highlighted HTML.

These variables influence the output of information commands:

  with-filename         prints the filename next to information like version,
                        etc. This is true by default if there is more than one
                        file specified.

Example:

  ly "reformat; transpose c d" -o output.ly file.ly

Example using the '*' in the output file name:

  ly "transpose c d" *.ly -o '*-transposed.ly'
  ly highlight *.ly -o 'html/?.html'


""")

def usage_short():
    """Print short usage info."""
    sys.stdout.write("""\
Usage: ly [options] commands file, ...

A tool for manipulating LilyPond source files

See ly -h for a full list of commands and options.
""")

def version():
    """Print version info."""
    sys.stdout.write("ly {0}\n".format(ly.pkginfo.version))

def die(message):
    """Exit with message to STDERR."""
    sys.stderr.write("error: " + message + '\n')
    sys.stderr.write(
        "See ly -h for a full list of commands and options.\n")
    sys.exit(1)
        
class Options(object):
    """Store all the startup options and their defaults."""
    def __init__(self):
        self.mode = None
        self.in_place = False
        self.encoding = 'UTF-8'
        self.output_encoding = None
        self.output = None
        self.replace_pattern = True
        self.backup_suffix = '~'
        self.with_filename = None
        
        self.indent_width = 2
        self.indent_tabs = False
        self.tab_width = 8
        
        self.inline_style = False
        self.stylesheet = None
        self.number_lines = False
    
    def set_variable(self, name, value):
        name = name.replace('-', '_')
        if value.lower() in ('yes', 'on', 'true'):
            value = True
        elif value.lower() in ('no', 'off', 'false'):
            value = False
        elif value.isdigit():
            value = int(value)
        setattr(self, name, value)
    
class Output(object):
    """Object living for a whole file/command operation, handling the output.
    
    When opening a file it has already opened earlier, the file is appended to
    (like awk).
    
    """
    def __init__(self):
        self._seen_filenames = set()
    
    def get_filename(self, opts, filename):
        """Queries the output attribute from the Options and returns it.
        
        If replace_pattern is True (by default) and the attribute contains a 
        '*', it is replaced with the full path of the specified filename, 
        but without extension. It the attribute contains a '?', it is 
        replaced with the filename without path and extension.
        
        If '-' is returned, it denotes standard output.
        
        """
        if not opts.output:
            return '-'
        elif opts.replace_pattern:
            path, ext = os.path.splitext(filename)
            directory, name = os.path.split(path)
            return opts.output.replace('?', name).replace('*', path)
        else:
            return opts.output
    
    @contextlib.contextmanager
    def file(self, opts, filename, encoding):
        """Return a context manager for writing to.
        
        If you set encoding to "binary" or False, the file is opened in binary
        mode and you should encode the data you write yourself.
        
        """
        if not filename or filename == '-':
            filename, mode = sys.stdout.fileno(), 'w'
        else:
            if filename not in self._seen_filenames:
                self._seen_filenames.add(filename)
                if opts.backup_suffix and os.path.exists(filename):
                    shutil.copy(filename, filename + opts.backup_suffix)
                mode = 'w'
            else:
                mode = 'a'
        if encoding in (False, "binary"):
            f = io.open(filename, mode + 'b')
        else:
            f = io.open(filename, mode, encoding=encoding)
        try:
            yield f
        finally:
            f.close()

def parse_command_line():
    """Return a three-tuple(options, commands, files).
    
    options is an Options instance with all the command-line options
    commands is a list of command.command instances
    files is the list of filename arguments
    
    Also performs error handling and may exit on certain circumstances.
    
    """
    if len(sys.argv) < 2:
        usage_short()
        sys.exit(2)
    
    # are the arguments unicode? python2 leaves them encoded...
    if type(sys.argv[0]) != type(''):
        args = (a.decode(sys.stdin.encoding) for a in sys.argv[1:])
    else:
        args = iter(sys.argv[1:])
    
    opts = Options()
    commands = []
    files = []
    
    def next_arg(message):
        """Get the next argument, if missing, die with message."""
        try:
            return next(args)
        except StopIteration:
            die(message)
    
    for arg in args:
        if arg in ('-h', '--help'):
            usage()
            sys.exit(0)
        elif arg in ('-v', '--version'):
            version()
            sys.exit(0)
        elif arg in ('-i', '--in-place'):
            opts.in_place = True
        elif arg in ('-o', '--output'):
            opts.output = next_arg("missing output filename")
        elif arg == '-d':
            s = next_arg("missing variable=value")
            try:
                name, value = s.split('=', 1)
            except ValueError:
                die("missing '=' in variable set")
            opts.set_variable(name, value)
        elif arg in ('-e', '--encoding'):
            opts.encoding = next_arg("missing encoding name")
        elif arg == '--output-encoding':
            opts.output_encoding = next_arg("missing output encoding name")
        elif arg == '--':
            files.extend(args)
        elif arg.startswith('-'):
            die('unknown option: ' + arg)
        elif not commands:
            commands = parse_command(arg)
        else:
            files.append(arg)
    from . import command
    if not commands or isinstance(commands[-1], command._edit_command):
        commands.append(command.write())
    if not files:
        files.append('-')
    if opts.with_filename is None:
        opts.with_filename = len(files) > 1
    return opts, commands, files

def parse_command(arg):
    """Parse the command string, returning a list of command.command instances.
    
    Exits when a command is invalid.
    
    """
    from . import command

    result = []
    
    for c in arg.split(';'):
        args = c.split(None, 1)
        if args:
            if '=' in args[0]:
                args = ['set_variable', c]
            cmd = args.pop(0)
            try:
                result.append(getattr(command, cmd.replace('-', '_'))(*args))
            except AttributeError:
                die("unknown command: " + cmd)
            except (TypeError, ValueError):
                die("invalid arguments: " + c)
    return result

def load(filename, encoding, mode):
    """Load a file, returning a ly.document.Document"""
    import ly.document
    if filename == '-':
        doc = ly.document.Document.load(sys.stdin.fileno(), encoding, mode)
        doc.filename = '-'
    else:
        doc = ly.document.Document.load(filename, encoding, mode)
    return doc

def main():
    opts, commands, files = parse_command_line()
    import ly.document
    output = Output()
    exit_code = 0
    for filename in files:
        options = copy.deepcopy(opts)
        try:
            doc = load(filename, options.encoding, options.mode)
        except IOError as err:
            sys.stderr.write('warning: skipping file "{0}":\n  {1}\n'.format(filename, err))
            exit_code = 1
            continue
        cursor = ly.document.Cursor(doc)
        for c in commands:
            c.run(options, cursor, output)
    return exit_code

sys.exit(main())

########NEW FILE########
__FILENAME__ = colorize
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Classes and functions to colorize (syntax-highlight) parsed source.

Highlighting is based on CSS properties and their values, although the Mapping
object can map a token's class to any object or value.

The Mapping object normally maps a token's class basically to a CSS class and
possibly a base CSS class. This way you can define base styles (e.g. string,
comment, etc) and have specific classes (e.g. LilyPond string, Scheme 
comment) inherit from that base style. This css class is described by the 
css_class named tuple, with its three fields: mode, ccscls, base. E.g. 
('lilypond', 'articulation', 'keyword'). The base field may be None.

The css classes are mapped to dictionaries of css properties, like
{'font-weight': 'bold', 'color': '#4800ff'}, etc.

A scheme (a collection of styles) is simply a dictionary mapping the mode to
a dictionary of CSS dictionaries. The base styles are in the [None] item of the
scheme dictionary.


"""

from __future__ import unicode_literals
from __future__ import absolute_import

import collections

import ly.lex


# don't test all the Token base classes
_token_mro_slice = slice(1, -len(ly.lex.Token.__mro__))


style = collections.namedtuple("style", "name base classes")
css_class = collections.namedtuple("css_class", "mode name base")


class Mapper(dict):
    """Maps token classes to arbitrary values, which can be highlighting styles.
    
    Mapper behaves like a dict, you set items with a token class as key to an
    arbitrary value.
    
    But getting items can be done using a token. The token class's method 
    resolution order is walked up and the value for the first available 
    class found in the keys is returned. The class is also cached to speed 
    up requests for other tokens.
    
    """
    def __getitem__(self, token):
        cls = type(token)
        try:
            return dict.__getitem__(self, cls)
        except KeyError:
            for c in cls.__mro__[_token_mro_slice]:
                try:
                    value = dict.__getitem__(self, c)
                    break
                except KeyError:
                    pass
            else:
                value = None
            self[cls] = value
            return value


def default_mapping():
    """Return a good default mapping from token class(es) to style and default style, per group."""
    from ly.lex import lilypond
    from ly.lex import scheme
    from ly.lex import html
    from ly.lex import texinfo
    #from ly.lex import latex
    #from ly.lex import docbook
    
    return (
        ('lilypond', (
            style('keyword', 'keyword', (lilypond.Keyword,)),
            style('command', 'function', (lilypond.Command, lilypond.Skip)),
            style('pitch', None, (lilypond.MusicItem,)),
            style('octave', None, (lilypond.Octave,)),
            style('accidental', None, (lilypond.Accidental, lilypond.FigureAccidental)),
            style('duration', None, (lilypond.Duration,)),
            style('dynamic', None, (lilypond.Dynamic,)),
            style('check', None, (lilypond.OctaveCheck, lilypond.PipeSymbol)),
            style('articulation', None, (lilypond.Direction, lilypond.Articulation)),
            style('fingering', None, (lilypond.Fingering,)),
            style('stringnumber', None, (lilypond.StringNumber,)),
            style('slur', None, (lilypond.Slur,)),
            style('beam', None, (lilypond.Beam, lilypond.FigureBracket,)),
            style('chord', None, (lilypond.Chord, lilypond.ChordItem)),
            style('markup', 'function', (lilypond.Markup,)),
            style('lyricmode', 'function', (lilypond.LyricMode,)),
            style('lyrictext', None, (lilypond.Lyric,)),
            style('repeat', 'function', (lilypond.Repeat, lilypond.Tremolo,)),
            style('specifier', 'variable', (lilypond.Specifier,)),
            style('usercommand', 'variable', (lilypond.UserCommand,)),
            style('figbass', None, (lilypond.Figure,)),
            style('figbstep', None, (lilypond.FigureStep,)),
            style('figbmodif', None, (lilypond.FigureModifier,)),
            style('delimiter', 'keyword', (lilypond.Delimiter,)),
            style('context', None, (lilypond.ContextName,)),
            style('grob', None, (lilypond.GrobName,)),
            style('property', 'variable', (lilypond.ContextProperty,)),
            style('variable', 'variable', (lilypond.Variable,)),
            style('uservariable', None, (lilypond.UserVariable,)),
            style('value', 'value', (lilypond.Value,)),
            style('string', 'string', (lilypond.String,)),
            style('stringescape', 'escape', (lilypond.StringQuoteEscape,)),
            style('comment', 'comment', (lilypond.Comment,)),
            style('error', 'error', (lilypond.Error,)),
        )),
        ('scheme', (
            style('scheme', None, (lilypond.SchemeStart, scheme.Scheme,)),
            style('string', 'string', (scheme.String,)),
            style('comment', 'comment', (scheme.Comment,)),
            style('number', 'value', (scheme.Number,)),
            style('lilypond', None, (scheme.LilyPond,)),
            style('keyword', 'keyword', (scheme.Keyword,)),
            style('function', 'function', (scheme.Function,)),
            style('variable', 'variable', (scheme.Variable,)),
            style('constant', 'variable', (scheme.Constant,)),
            style('delimiter', None, (scheme.OpenParen, scheme.CloseParen,)),
        )),
        ('html', (
            style('tag', 'keyword', (html.Tag,)),
            style('attribute', 'variable', (html.AttrName,)),
            style('value', 'value', (html.Value,)),
            style('string', 'string', (html.String,)),
            style('entityref', 'escape', (html.EntityRef,)),
            style('comment', 'comment', (html.Comment,)),
            style('lilypondtag', 'function', (html.LilyPondTag,)),
        )),
        ('texinfo', (
            style('keyword', 'keyword', (texinfo.Keyword,)),
            style('block', 'function', (texinfo.Block,)),
            style('attribute', 'variable', (texinfo.Attribute,)),
            style('escapechar', 'escape', (texinfo.EscapeChar,)),
            style('verbatim', 'string', (texinfo.Verbatim,)),
            style('comment', 'comment', (texinfo.Comment,)),
        )),
    ) # end of mapping


default_scheme = {
    # the base styles
    None: {
        'keyword': {
            'font-weight': 'bold',
        },
        'function': {
            'font-weight': 'bold',
            'color': '#0000c0',
        },
        'variable': {
            'color': '#0000ff',
        },
        'value': {
            'color': '#808000',
        },
        'string': {
            'color': '#c00000',
        },
        'escape': {
            'color': '#008080',
        },
        'comment': {
            'color': '#808080',
            'font-style': 'italic',
        },
        'error': {
            'color': '#ff0000',
            'text-decoration': 'underline',
            'text-decoration-color': '#ff0000',
        },
    },
    'lilypond': {
        'duration': {
            'color': '#008080',
        },
        'markup': {
            'color': '#008000',
            'font-weight': 'normal',
        },
        'lyricmode': {
            'color': '#006000',
        },
        'lyrictext': {
            'color': '#006000',
        },
        'grob': {
            'color': '#c000c0',
        },
        'context': {
            'font-weight': 'bold',
        },
        'slur': {
            'font-weight': 'bold',
        },
        'articulation': {
            'font-weight': 'bold',
            'color': '#ff8000',
        },
        'dynamic': {
            'font-weight': 'bold',
            'color': '#ff8000',
        },
        'fingering': {
            'color': '#ff8000',
        },
        'stringnumber': {
            'color': '#ff8000',
        },
    },
    'scheme': {
    },
    'html': {
    },
    'texinfo': {
    },
} # end of default_css_styles


def get_tokens(cursor):
    """Return the list of tokens for the cursor.
    
    Tokens that are partially inside the cursor's selection are re-created
    so that they fall exactly within the selection.
    
    This can be used to convert a highlighted part of a document to e.g. HTML.
    
    """
    tokens = list(ly.document.Source(cursor, None, ly.document.PARTIAL, True))
    if tokens:
        if cursor.end is not None and tokens[-1].end > cursor.end:
            t = tokens[-1]
            tokens[-1] = type(t)(t[:cursor.end - t.end], t.pos)
        if cursor.start > tokens[0].pos:
            t = tokens[0]
            tokens[0] = type(t)(t[cursor.start - t.pos:], cursor.start)
    return tokens


def map_tokens(cursor, mapper):
    """Yield a two-tuple(token, style) for every token.
    
    The style is what mapper[token] returns.
    Style may be None, which also happens with unparsed (not-tokenized) text.
    
    """
    text = cursor.document.plaintext()
    start = cursor.start
    tokens = get_tokens(cursor)
    t = None
    for t in tokens:
        if t.pos > start:
            yield text[start:t.pos], None
        yield t, mapper[t]
        start = t.end
    if t and cursor.end is not None and cursor.end > t.end:
        yield text[t.end:cursor.end]


def melt_mapped_tokens(mapped_tokens):
    """Melt adjacent tokens with the same mapping together."""
    prev_tokens = []
    prev_style = None
    for t, s in mapped_tokens:
        if s == prev_style:
            prev_tokens.append(t)
        else:
            if prev_tokens:
                yield ''.join(prev_tokens), prev_style
            prev_tokens = [t]
            prev_style = s
    if prev_tokens:
        yield ''.join(prev_tokens), prev_style


def css_mapper(mapping=None):
    """Return a Mapper dict, mapping token classes to two CSS classes.
    
    By default the mapping returned by default_mapping() is used.
    
    """
    if mapping is None:
        mapping = default_mapping()
    return Mapper((cls, css_class(mode, style.name, style.base))
                        for mode, styles in mapping
                            for style in styles
                                for cls in style.classes)


def css_dict(css_style, scheme=default_scheme):
    """Return the css properties dict for the style, taken from the scheme.
    
    This can be used for inline style attributes.
    
    """
    d = {}
    try:
        d.update(scheme[None][css_style.base])
    except KeyError:
        pass
    try:
        d.update(scheme[css_style.mode][css_style.name])
    except KeyError:
        pass
    return d


def css_item(i):
    """Return "name: value;" where i = (name, value)."""
    return '{0}: {1};'.format(*i)


def css_attr(d):
    """Return a dictionary with a 'style' key.
    
    The value is the style items in d formatted with css_item() joined with 
    spaces. If d is empty, an empty dictionary is returned.
    
    """
    if d:
        return {'style': ' '.join(map(css_item, sorted(d.items())))}
    return {}


def css_group(selector, d):
    """Return a "selector { items...}" part of a CSS stylesheet."""
    return '{0} {{\n  {1}\n}}\n'.format(
        selector, '\n  '.join(map(css_item, sorted(d.items()))))


def format_css_span_class(css_style):
    """Return a string like 'class="mode-style base"' for the specified style."""
    c = css_style.mode + '-' + css_style.name
    if css_style.base:
        c += ' ' + css_style.base
    return 'class="{0}"'.format(c)


class css_style_attribute_formatter(object):
    """Return the inline style attribute for a specified style."""
    def __init__(self, scheme=default_scheme):
        self.scheme = scheme
    
    def __call__(self, css_style):
        d = css_dict(css_style, self.scheme)
        if d:
            return 'style="{0}"'.format(' '.join(map(css_item, sorted(d.items()))))


def format_stylesheet(scheme=default_scheme):
    """Return a formatted stylesheet for the stylesheet scheme dictionary."""
    sheet = []
    key = lambda i: '' if i[0] is None else i[0]
    for mode, styles in sorted(scheme.items(), key=key):
        if styles:
            sheet.append('/* {0} */'.format(
                "mode: " + mode if mode else "base styles"))
        for css_class, d in sorted(styles.items()):
            if mode:
                selector = 'span.{0}-{1}'.format(mode, css_class)
            else:
                selector = '.' + css_class
            sheet.append(css_group(selector, d))
    return '\n'.join(sheet)


def html_escape(text):
    """Escape &, < and >."""
    return text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')


def html_escape_attr(text):
    """Escape &, ", < and >."""
    return html_escape(text).replace('"', '&quot;')


def html_format_attrs(d):
    """Format the attributes dict as a string.
    
    The attributes are escaped correctly. A space is prepended for every 
    assignment.
    
    """
    return ''.join(' {0}="{1}"'.format(
            k, html_escape_attr(format(v))) for k, v in d.items())


def html(cursor, mapper, span=format_css_span_class):
    """Return a HTML string with the tokens wrapped in <span class=> elements.
    
    The span argument is a function returning an attribute for the <span> 
    tag for the specified style. By default the format_css_span_class() 
    function is used, that returns a 'class="group style base"' string. 
    You'll want to wrap the HTML inside <pre> tokens and add a CSS stylesheet.
    
    """
    result = []
    for t, style in melt_mapped_tokens(map_tokens(cursor, mapper)):
        arg = span(style) if style else None
        if arg:
            result.append('<span {0}>'.format(arg))
            result.append(html_escape(t))
            result.append('</span>')
        else:
            result.append(html_escape(t))
    return ''.join(result)


def add_line_numbers(cursor, html, linenum_attrs=None, document_attrs=None):
    """Combines the html (returned by html()) with the line numbers in a HTML table.
    
    The linenum_attrs are put in the <td> tag for the line numbers. The 
    default value is: {"style": "background: #eeeeee;"}. The document_attrs 
    are put in the <td> tag for the document. The default is empty.
    
    By default, the id for the linenumbers <td> is set to "linenumbers", 
    and the id for the document <td> is set to "document".
    
    """
    linenum_attrs = dict(linenum_attrs) if linenum_attrs else {"style": "background: #eeeeee;"}
    document_attrs = dict(document_attrs) if document_attrs else {}
    linenum_attrs.setdefault('id', 'linenumbers')
    document_attrs.setdefault('id', 'document')
    linenum_attrs['valign'] = 'top'
    linenum_attrs['align'] = 'right'
    linenum_attrs['style'] = linenum_attrs.get('style', '') + 'vertical-align: top; text-align: right;'
    document_attrs['valign'] = 'top'
    document_attrs['style'] = document_attrs.get('style', '') + 'vertical-align: top;'
    
    start_num = cursor.document.index(cursor.start_block()) + 1
    end_num = cursor.document.index(cursor.end_block()) + 1
    linenumbers = '<pre>{0}</pre>'.format('\n'.join(map(format, range(start_num, end_num))))
    body = '<pre>{0}</pre>'.format(html)
    return (
        '<table border="0" cellpadding="4" cellspacing="0">'
        '<tbody><tr>'
        '<td{0}>'
        '\n{1}\n'
        '</td>'
        '<td{2}>'
        '\n{3}\n'
        '</td></tr></tbody></table>\n').format(
            html_format_attrs(linenum_attrs), linenumbers,
            html_format_attrs(document_attrs), body)


def format_html_document(body, title="", stylesheet=None, stylesheet_ref=None, encoding='UTF-8'):
    """Return a complete HTML document.
    
    The body is put inside body tags unchanged.  The title is html-escaped. 
    If stylesheet_ref is given, it is put as a <link> reference in the HTML; 
    if stylesheet is given, it is put verbatim in a <style> section in the 
    HTML. The encoding is set in the meta http-equiv field, but the returned 
    HTML is in normal Python unicode (python2) or str (python3) format, you 
    should encode it yourself in the same encoding (by default utf-8) when 
    writing it to a file.
    
    """
    css = ""
    if stylesheet_ref:
        css += '<link rel="stylesheet" type="text/css" href="{0}"/>\n'.format(html_escape_attr(stylesheet_ref))
    if stylesheet:
        css += '<style type="text/css">\n{0}\n</style>\n'.format(stylesheet)
    return (
        '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">\n'
        '<html><head>\n'
        '<title>{title}</title>\n'
        '<meta http-equiv="Content-Type" content="text/html; charset={encoding}" />\n'
        '{css}'
        '</head>\n'
        '<body>\n{body}</body>\n</html>\n').format(
            title = html_escape(title),
            encoding = encoding,
            body = body,
            css = css,
        )


class HtmlWriter(object):
    """A do-it-all object to create syntax highlighted HTML.
    
    You can set the instance attributes to configure the behaviour in all
    details. Then call the html(cursor) method to get the HTML.
    
    """
    
    fgcolor = None
    bgcolor = None
    
    linenumbers_fgcolor = None
    linenumbers_bgcolor = "#eeeeee"
    
    inline_style = False
    number_lines = False
    
    document_id = "document"
    linenumbers_id = "linenumbers"
    
    title = ""
    css_scheme = default_scheme
    css_mapper = None
    encoding = 'UTF-8'
    
    stylesheet_ref = None
    full_html = True
    
    def html(self, cursor):
        """Return the output HTML."""
        doc_style = {}
        if self.fgcolor:
            doc_style['color'] = self.fgcolor
        if self.bgcolor:
            doc_style['background'] = self.bgcolor
        
        num_style = {}
        if self.linenumbers_fgcolor:
            num_style['color'] = self.linenumbers_fgcolor
        if self.linenumbers_bgcolor:
            num_style['background'] = self.linenumbers_bgcolor
        
        num_attrs = {'id': self.linenumbers_id}
        doc_attrs = {'id': self.document_id}
        
        css = []
        if self.inline_style:
            formatter = css_style_attribute_formatter(self.css_scheme)
            num_attrs.update(css_attr(num_style))
            doc_attrs.update(css_attr(doc_style))
        else:
            formatter = format_css_span_class
            css.append(css_group('#' + self.document_id, doc_style))
            if self.number_lines:
                css.append(css_group('#' + self.linenumbers_id, num_style))
            css.append(format_stylesheet(self.css_scheme))
        
        body = html(cursor, self.css_mapper or css_mapper(), formatter)
        
        if self.number_lines:
            body = add_line_numbers(cursor, body, num_attrs, doc_attrs)
        else:
            body = '<pre{0}>{1}</pre>'.format(html_format_attrs(doc_attrs), body)
        
        if not self.full_html:
            return body
        
        if self.stylesheet_ref:
            css = None
        else:
            css = '\n'.join(css)
        return format_html_document(body, self.title, css, self.stylesheet_ref, self.encoding)



########NEW FILE########
__FILENAME__ = cursortools
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Routines manipulating ly.document.Cursor instances.

"""

from __future__ import unicode_literals


import ly.lex
import ly.document


def find_indent(iterable):
    """Yield (token, is_indent, nest) for every occurring indent/dedent token.
    
    The tokens are yielded from the specified iterable.
    
    """
    nest = 0
    for token in iterable:
        if isinstance(token, ly.lex.Indent):
            nest += 1
            yield token, True, nest
        elif isinstance(token, ly.lex.Dedent):
            nest -= 1
            yield token, False, nest


def select_block(cursor):
    """Try to select a meaningful block.
    
    Searches backwards for an indenting token, then selects up to the 
    corresponding dedenting token. If needed searches an extra level back to 
    always extend the selection. Returns True if the cursor's selection has 
    changed.
    
    """
    end = cursor.end if cursor.end is not None else cursor.document.size()
    tokens = ly.document.Runner.at(cursor, after_token=True)
    # search backwards to the first indenting token
    for token, isindent, nest in find_indent(tokens.backward()):
        if isindent and nest == 1:
            pos1 = tokens.position()
            startpoint = tokens.copy()
            # found, now look forward
            for token, isindent, nest in find_indent(tokens.forward()):
                if not isindent and nest < 0 and tokens.position() + len(token) >= end:
                    # we found the endpoint
                    pos2 = tokens.position() + len(token)
                    if nest < -1:
                        threshold = 1 - nest
                        for token, isindent, nest in find_indent(startpoint.backward()):
                            if isindent and nest == threshold:
                                pos1 = tokens.position()
                                break
                    cursor.start, cursor.end = pos1, pos2
                    return True
            return


########NEW FILE########
__FILENAME__ = makeschemedata
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
generate all scheme words in the _scheme_data.py file
"""
from __future__ import unicode_literals

import _scheme_data
import urllib
import os
import re


VERSION = "2.17"
GUILE_URL = "https://www.gnu.org/software/guile/docs/docs-1.8/guile-ref/Procedure-Index.html#Procedure-Index"
LY_FUNCTION_URL = "http://lilypond.org/doc/v2.17/Documentation/internals/scheme-functions"
SCM_PATH = os.path.join(os.environ['HOME'], 'lilypond/usr/share/lilypond/current/scm')

GUILE_IGNONED_TYPE = (
    'Apply Traps',
    'Common Trap Options',
    'Continuations',
    'Debug on Error',
    'Display Backtrace',
    'Encryption',
    'Entry Traps',
    'Exit Traps',
    'Garbage Collection Functions',
    'getopt-long Reference',
    'Internationalization',
    'Location Traps',
    'Network Databases',
    'Network Socket Address',
    'Network Sockets and Communication',
    'Procedure Traps',
    'Signals',
    'Threads',
    'Trap Utilities',
    'Source Traps',
    'Step Traps',
    'SRFI-37',
    'Stepping and Continuing',
    'System asyncs',
    'System Identification',
    'User asyncs',
    'User Information',
    'User level options interfaces',
)

GUILE_OTHER_WORDS = ['else', 'set!']

def writeList(file_, name, lst):
    file_.write("{} = [\n".format(name))
    for word in sorted(set(lst)):
        file_.write("    '{0}',\n".format(word))
    file_.write("]\n\n")

def replace(word):
    word = word.replace('&lt;', '<')
    word = word.replace('&gt;', '>')
    return word

guilePage = urllib.urlopen(GUILE_URL).read()
guilePat = re.compile(r"<code>([a-z\d\+\?\!\*&;/=:-]+)</code></a>: <a href=\".+\">(.+)</a>")

lyFunctionPage = urllib.urlopen(LY_FUNCTION_URL).read()
lyFunctionPat = re.compile(r'<u>Function:</u> <b>(ly:.+)</b>')


defineFunc = re.compile(r'\((?:define\*?|define-safe)-public\s+\(([-><a-zA-Z:\?]+)[\s\)]')
defineMacro = re.compile(r'\(defmacro\*?-public\s+([-><a-zA-Z:\?]+)[\s\)]')
defineVar = re.compile(r'\((?:define\*?|define-safe)-public\s+([-><a-zA-Z:\?]+)[\s\)]')
startWithLy = re.compile(r"(ly:[-><a-zA-Z:\?]+)[\s\)]")


schemeDataPath = os.path.join(os.path.split(_scheme_data.__file__)[0], '_scheme_data.py')
with open(schemeDataPath, "w") as f:
    f.write("#! python\n#generated by makeschemedata.py\n\nversion=\"{}\"\n\n".format(VERSION))
    
    guileWords = []
    for m in guilePat.finditer(guilePage):
        if m.group(2) not in GUILE_IGNONED_TYPE:
            proc = m.group(1)
            if not proc.startswith('gds-'):
                guileWords.append(replace(proc))
    guileWords += GUILE_OTHER_WORDS
    
    
    lyFunctions = []
    lyVars = []
    lyCons = []
    for word in lyFunctionPat.finditer(lyFunctionPage):
        lyFunctions.append(replace(word.group(1)))
        
    for filename in os.listdir(SCM_PATH):
        path = os.path.join(SCM_PATH, filename)
        with open(path) as inp:
            text = inp.read()
            for m in defineFunc.finditer(text):
                lyFunctions.append(m.group(1))
            
            for m in defineMacro.finditer(text):
                lyFunctions.append(m.group(1))
                
            for m in startWithLy.finditer(text):
                lyFunctions.append(m.group(1))
            
            for m in defineVar.finditer(text):
                word = m.group(1)
                if word.isupper():
                    lyCons.append(word)
                else:
                    lyVars.append(word)
                    
    for word in lyFunctions:
        if word in lyVars:
            lyVars.remove(word)
    
    lyVars.remove('parser')
    
    writeList(f, 'scheme_keywords', guileWords) 
    writeList(f, 'scheme_functions', lyFunctions)
    writeList(f, 'scheme_variables', lyVars)
    writeList(f, 'scheme_constants', lyCons)
    

########NEW FILE########
__FILENAME__ = _data
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Load the LilyPond-generated data, and add some missing things.
"""

from ._lilypond_data import *
from ._scheme_data import *

# BarLine #'bar-extent
if "bar-extent" not in interfaces["bar-line-interface"]:
    interfaces["bar-line-interface"].insert(1, "bar-extent")



########NEW FILE########
__FILENAME__ = _lilypond_data
#! python
# generated by LilyPond 2.16.2

version = "2.16.2"

interfaces = {
    "accidental-interface": [
        "alteration",
        "avoid-slur",
        "glyph-name-alist",
        "hide-tied-accidental-after-break",
        "parenthesized",
        "restore-first",
    ],
    "accidental-placement-interface": [
        "direction",
        "padding",
        "positioning-done",
        "right-padding",
        "script-priority",
    ],
    "accidental-suggestion-interface": [],
    "align-interface": [
        "align-dir",
        "axes",
        "padding",
        "positioning-done",
        "stacking-dir",
    ],
    "ambitus-interface": [
        "gap",
        "thickness",
    ],
    "arpeggio-interface": [
        "arpeggio-direction",
        "dash-definition",
        "positions",
        "script-priority",
    ],
    "axis-group-interface": [
        "axes",
        "default-staff-staff-spacing",
        "max-stretch",
        "no-alignment",
        "nonstaff-nonstaff-spacing",
        "nonstaff-relatedstaff-spacing",
        "nonstaff-unrelatedstaff-spacing",
        "staff-affinity",
        "staff-staff-spacing",
        "vertical-skylines",
    ],
    "balloon-interface": [
        "annotation-balloon",
        "annotation-line",
        "padding",
        "text",
    ],
    "bar-line-interface": [
        "allow-span-bar",
        "bar-extent",
        "gap",
        "glyph",
        "glyph-name",
        "hair-thickness",
        "kern",
        "thick-thickness",
        "thin-kern",
    ],
    "bass-figure-alignment-interface": [],
    "bass-figure-interface": [
        "implicit",
    ],
    "beam-interface": [
        "X-positions",
        "annotation",
        "auto-knee-gap",
        "beam-thickness",
        "beamed-stem-shorten",
        "beaming",
        "break-overshoot",
        "clip-edges",
        "collision-interfaces",
        "collision-voice-only",
        "concaveness",
        "damping",
        "details",
        "direction",
        "gap",
        "gap-count",
        "grow-direction",
        "inspect-quants",
        "knee",
        "length-fraction",
        "neutral-direction",
        "positions",
        "skip-quanting",
    ],
    "bend-after-interface": [
        "thickness",
    ],
    "break-alignable-interface": [
        "break-align-symbols",
        "non-break-align-symbols",
    ],
    "break-aligned-interface": [
        "break-align-anchor",
        "break-align-anchor-alignment",
        "break-align-symbol",
        "space-alist",
    ],
    "break-alignment-interface": [
        "break-align-orders",
        "positioning-done",
    ],
    "breathing-sign-interface": [
        "direction",
    ],
    "chord-name-interface": [],
    "clef-interface": [
        "full-size-change",
        "glyph",
        "glyph-name",
        "non-default",
    ],
    "cluster-beacon-interface": [
        "positions",
    ],
    "cluster-interface": [
        "padding",
        "style",
    ],
    "custos-interface": [
        "neutral-direction",
        "neutral-position",
        "style",
    ],
    "dot-column-interface": [
        "direction",
        "positioning-done",
    ],
    "dots-interface": [
        "direction",
        "dot-count",
        "style",
    ],
    "dynamic-interface": [],
    "dynamic-line-spanner-interface": [
        "avoid-slur",
    ],
    "dynamic-text-interface": [
        "right-padding",
    ],
    "dynamic-text-spanner-interface": [
        "text",
    ],
    "enclosing-bracket-interface": [
        "bracket-flare",
        "edge-height",
        "padding",
        "shorten-pair",
        "thickness",
    ],
    "episema-interface": [],
    "figured-bass-continuation-interface": [
        "padding",
        "thickness",
    ],
    "finger-interface": [],
    "flag-interface": [
        "stroke-style",
        "style",
    ],
    "font-interface": [
        "font-encoding",
        "font-family",
        "font-name",
        "font-series",
        "font-shape",
        "font-size",
    ],
    "footnote-interface": [
        "automatically-numbered",
        "footnote",
        "footnote-text",
    ],
    "footnote-spanner-interface": [
        "footnote-text",
    ],
    "fret-diagram-interface": [
        "align-dir",
        "dot-placement-list",
        "fret-diagram-details",
        "size",
        "thickness",
    ],
    "glissando-interface": [],
    "grace-spacing-interface": [
        "common-shortest-duration",
    ],
    "gregorian-ligature-interface": [],
    "grid-line-interface": [
        "thickness",
    ],
    "grid-point-interface": [],
    "grob-interface": [
        "X-extent",
        "X-offset",
        "Y-extent",
        "Y-offset",
        "after-line-breaking",
        "avoid-slur",
        "before-line-breaking",
        "color",
        "cross-staff",
        "extra-X-extent",
        "extra-Y-extent",
        "extra-offset",
        "footnote-music",
        "forced-spacing",
        "id",
        "layer",
        "minimum-X-extent",
        "minimum-Y-extent",
        "outside-staff-horizontal-padding",
        "outside-staff-padding",
        "outside-staff-priority",
        "rotation",
        "springs-and-rods",
        "stencil",
        "transparent",
        "whiteout",
    ],
    "hairpin-interface": [
        "bound-padding",
        "broken-bound-padding",
        "circled-tip",
        "grow-direction",
        "height",
    ],
    "hara-kiri-group-spanner-interface": [
        "remove-empty",
        "remove-first",
    ],
    "horizontal-bracket-interface": [
        "bracket-flare",
        "connect-to-neighbor",
        "edge-height",
        "shorten-pair",
    ],
    "inline-accidental-interface": [],
    "instrument-specific-markup-interface": [
        "fret-diagram-details",
        "graphical",
        "harp-pedal-details",
        "size",
        "thickness",
    ],
    "item-interface": [
        "break-visibility",
        "extra-spacing-height",
        "extra-spacing-width",
        "non-musical",
    ],
    "key-cancellation-interface": [],
    "key-signature-interface": [
        "alteration-alist",
        "c0-position",
        "glyph-name-alist",
        "padding",
        "padding-pairs",
    ],
    "ledger-line-spanner-interface": [
        "gap",
        "length-fraction",
        "minimum-length-fraction",
        "thickness",
    ],
    "ledgered-interface": [
        "no-ledgers",
    ],
    "ligature-bracket-interface": [
        "height",
        "thickness",
        "width",
    ],
    "ligature-head-interface": [],
    "ligature-interface": [],
    "line-interface": [
        "arrow-length",
        "arrow-width",
        "dash-fraction",
        "dash-period",
        "style",
        "thickness",
        "zigzag-length",
        "zigzag-width",
    ],
    "line-spanner-interface": [
        "bound-details",
        "extra-dy",
        "gap",
        "left-bound-info",
        "right-bound-info",
        "simple-Y",
        "thickness",
        "to-barline",
    ],
    "lyric-extender-interface": [
        "left-padding",
        "next",
        "right-padding",
        "thickness",
    ],
    "lyric-hyphen-interface": [
        "dash-period",
        "height",
        "length",
        "minimum-distance",
        "minimum-length",
        "padding",
        "thickness",
    ],
    "lyric-interface": [],
    "lyric-syllable-interface": [],
    "mark-interface": [],
    "measure-grouping-interface": [
        "height",
        "style",
        "thickness",
    ],
    "melody-spanner-interface": [
        "neutral-direction",
    ],
    "mensural-ligature-interface": [
        "thickness",
    ],
    "metronome-mark-interface": [],
    "multi-measure-interface": [
        "bound-padding",
    ],
    "multi-measure-rest-interface": [
        "bound-padding",
        "expand-limit",
        "hair-thickness",
        "measure-count",
        "minimum-length",
        "round-up-exceptions",
        "round-up-to-longer-rest",
        "spacing-pair",
        "thick-thickness",
        "usable-duration-logs",
    ],
    "note-collision-interface": [
        "merge-differently-dotted",
        "merge-differently-headed",
        "positioning-done",
        "prefer-dotted-right",
    ],
    "note-column-interface": [
        "force-hshift",
        "horizontal-shift",
        "ignore-collision",
    ],
    "note-head-interface": [
        "glyph-name",
        "note-names",
        "stem-attachment",
        "style",
    ],
    "note-name-interface": [],
    "note-spacing-interface": [
        "knee-spacing-correction",
        "same-direction-correction",
        "space-to-barline",
        "stem-spacing-correction",
    ],
    "only-prebreak-interface": [],
    "ottava-bracket-interface": [
        "bracket-flare",
        "edge-height",
        "minimum-length",
        "shorten-pair",
    ],
    "paper-column-interface": [
        "between-cols",
        "full-measure-extra-space",
        "labels",
        "line-break-penalty",
        "line-break-permission",
        "line-break-system-details",
        "page-break-penalty",
        "page-break-permission",
        "page-turn-penalty",
        "page-turn-permission",
        "rhythmic-location",
        "shortest-playing-duration",
        "shortest-starter-duration",
        "used",
        "when",
    ],
    "parentheses-interface": [
        "padding",
        "stencils",
    ],
    "percent-repeat-interface": [
        "dot-negative-kern",
        "slash-negative-kern",
        "slope",
        "thickness",
    ],
    "percent-repeat-item-interface": [
        "dot-negative-kern",
        "slash-negative-kern",
        "slope",
        "thickness",
    ],
    "piano-pedal-bracket-interface": [
        "bound-padding",
        "bracket-flare",
        "edge-height",
        "shorten-pair",
    ],
    "piano-pedal-interface": [],
    "piano-pedal-script-interface": [],
    "pitched-trill-interface": [],
    "pure-from-neighbor-interface": [],
    "rest-collision-interface": [
        "minimum-distance",
        "positioning-done",
    ],
    "rest-interface": [
        "direction",
        "minimum-distance",
        "style",
    ],
    "rhythmic-grob-interface": [],
    "rhythmic-head-interface": [
        "duration-log",
        "glissando-skip",
    ],
    "script-column-interface": [],
    "script-interface": [
        "add-stem-support",
        "avoid-slur",
        "positioning-done",
        "script-priority",
        "side-relative-direction",
        "slur-padding",
        "toward-stem-shift",
    ],
    "self-alignment-interface": [
        "collision-bias",
        "collision-padding",
        "self-alignment-X",
        "self-alignment-Y",
    ],
    "semi-tie-column-interface": [
        "head-direction",
        "positioning-done",
        "tie-configuration",
    ],
    "semi-tie-interface": [
        "control-points",
        "details",
        "direction",
        "head-direction",
        "thickness",
    ],
    "separation-item-interface": [
        "X-extent",
        "horizontal-skylines",
        "padding",
        "skyline-vertical-padding",
    ],
    "side-position-interface": [
        "direction",
        "minimum-space",
        "padding",
        "side-axis",
        "slur-padding",
        "staff-padding",
        "use-skylines",
    ],
    "slur-interface": [
        "annotation",
        "avoid-slur",
        "control-points",
        "dash-definition",
        "details",
        "direction",
        "eccentricity",
        "height-limit",
        "inspect-index",
        "inspect-quants",
        "line-thickness",
        "positions",
        "ratio",
        "thickness",
        "vertical-skylines",
    ],
    "spaceable-grob-interface": [
        "allow-loose-spacing",
        "keep-inside-line",
        "measure-length",
    ],
    "spacing-interface": [],
    "spacing-options-interface": [
        "shortest-duration-space",
        "spacing-increment",
    ],
    "spacing-spanner-interface": [
        "average-spacing-wishes",
        "base-shortest-duration",
        "common-shortest-duration",
        "packed-spacing",
        "shortest-duration-space",
        "spacing-increment",
        "strict-grace-spacing",
        "strict-note-spacing",
        "uniform-stretching",
    ],
    "span-bar-interface": [
        "glyph-name",
    ],
    "spanner-interface": [
        "minimum-length",
        "normalized-endpoints",
        "spanner-id",
        "to-barline",
    ],
    "staff-grouper-interface": [
        "staff-staff-spacing",
        "staffgroup-staff-spacing",
    ],
    "staff-spacing-interface": [
        "stem-spacing-correction",
    ],
    "staff-symbol-interface": [
        "ledger-extra",
        "ledger-line-thickness",
        "ledger-positions",
        "line-count",
        "line-positions",
        "staff-space",
        "thickness",
        "width",
    ],
    "staff-symbol-referencer-interface": [
        "staff-position",
    ],
    "stanza-number-interface": [],
    "stem-interface": [
        "avoid-note-head",
        "beaming",
        "beamlet-default-length",
        "beamlet-max-length-proportion",
        "default-direction",
        "details",
        "direction",
        "duration-log",
        "french-beaming",
        "length",
        "length-fraction",
        "max-beam-connect",
        "neutral-direction",
        "no-stem-extend",
        "positioning-done",
        "stem-begin-position",
        "stemlet-length",
        "thickness",
    ],
    "stem-tremolo-interface": [
        "beam-thickness",
        "beam-width",
        "flag-count",
        "length-fraction",
        "slope",
        "style",
    ],
    "string-number-interface": [],
    "stroke-finger-interface": [
        "digit-names",
    ],
    "system-interface": [
        "labels",
        "skyline-horizontal-padding",
    ],
    "system-start-delimiter-interface": [
        "collapse-height",
        "style",
        "thickness",
    ],
    "system-start-text-interface": [
        "long-text",
        "self-alignment-X",
        "self-alignment-Y",
        "text",
    ],
    "tab-note-head-interface": [
        "details",
    ],
    "text-interface": [
        "baseline-skip",
        "replacement-alist",
        "text",
        "text-direction",
        "word-space",
    ],
    "text-script-interface": [
        "add-stem-support",
        "avoid-slur",
        "script-priority",
    ],
    "tie-column-interface": [
        "positioning-done",
        "tie-configuration",
    ],
    "tie-interface": [
        "annotation",
        "avoid-slur",
        "control-points",
        "dash-definition",
        "details",
        "direction",
        "head-direction",
        "line-thickness",
        "neutral-direction",
        "staff-position",
        "thickness",
    ],
    "time-signature-interface": [
        "fraction",
        "style",
    ],
    "trill-pitch-accidental-interface": [],
    "trill-spanner-interface": [],
    "tuplet-bracket-interface": [
        "X-positions",
        "avoid-scripts",
        "bracket-flare",
        "bracket-visibility",
        "break-overshoot",
        "connect-to-neighbor",
        "direction",
        "edge-height",
        "edge-text",
        "full-length-padding",
        "full-length-to-extent",
        "gap",
        "padding",
        "positions",
        "shorten-pair",
        "staff-padding",
        "thickness",
    ],
    "tuplet-number-interface": [
        "avoid-slur",
        "direction",
    ],
    "unbreakable-spanner-interface": [
        "breakable",
    ],
    "vaticana-ligature-interface": [
        "glyph-name",
        "thickness",
    ],
    "volta-bracket-interface": [
        "height",
        "thickness",
    ],
    "volta-interface": [],
}


grobs = {
    "Accidental": [
        "accidental-interface",
        "font-interface",
        "grob-interface",
        "inline-accidental-interface",
        "item-interface",
    ],
    "AccidentalCautionary": [
        "accidental-interface",
        "font-interface",
        "grob-interface",
        "inline-accidental-interface",
        "item-interface",
    ],
    "AccidentalPlacement": [
        "accidental-placement-interface",
        "grob-interface",
        "item-interface",
    ],
    "AccidentalSuggestion": [
        "accidental-interface",
        "accidental-suggestion-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "script-interface",
        "self-alignment-interface",
        "side-position-interface",
    ],
    "Ambitus": [
        "ambitus-interface",
        "axis-group-interface",
        "break-aligned-interface",
        "grob-interface",
        "item-interface",
    ],
    "AmbitusAccidental": [
        "accidental-interface",
        "break-aligned-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "side-position-interface",
    ],
    "AmbitusLine": [
        "ambitus-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
    ],
    "AmbitusNoteHead": [
        "ambitus-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "ledgered-interface",
        "note-head-interface",
        "rhythmic-head-interface",
        "staff-symbol-referencer-interface",
    ],
    "Arpeggio": [
        "arpeggio-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "side-position-interface",
        "staff-symbol-referencer-interface",
    ],
    "BalloonTextItem": [
        "balloon-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "text-interface",
    ],
    "BarLine": [
        "bar-line-interface",
        "break-aligned-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "pure-from-neighbor-interface",
    ],
    "BarNumber": [
        "break-alignable-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "self-alignment-interface",
        "side-position-interface",
        "text-interface",
    ],
    "BassFigure": [
        "bass-figure-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "rhythmic-grob-interface",
        "text-interface",
    ],
    "BassFigureAlignment": [
        "align-interface",
        "axis-group-interface",
        "bass-figure-alignment-interface",
        "grob-interface",
        "spanner-interface",
    ],
    "BassFigureAlignmentPositioning": [
        "axis-group-interface",
        "grob-interface",
        "side-position-interface",
        "spanner-interface",
    ],
    "BassFigureBracket": [
        "enclosing-bracket-interface",
        "grob-interface",
        "item-interface",
    ],
    "BassFigureContinuation": [
        "figured-bass-continuation-interface",
        "grob-interface",
        "spanner-interface",
    ],
    "BassFigureLine": [
        "axis-group-interface",
        "grob-interface",
        "spanner-interface",
    ],
    "Beam": [
        "beam-interface",
        "font-interface",
        "grob-interface",
        "spanner-interface",
        "staff-symbol-referencer-interface",
        "unbreakable-spanner-interface",
    ],
    "BendAfter": [
        "bend-after-interface",
        "grob-interface",
        "spanner-interface",
    ],
    "BreakAlignGroup": [
        "axis-group-interface",
        "break-aligned-interface",
        "grob-interface",
        "item-interface",
    ],
    "BreakAlignment": [
        "axis-group-interface",
        "break-alignment-interface",
        "grob-interface",
        "item-interface",
    ],
    "BreathingSign": [
        "break-aligned-interface",
        "breathing-sign-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "text-interface",
    ],
    "ChordName": [
        "chord-name-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "rhythmic-grob-interface",
        "text-interface",
    ],
    "Clef": [
        "break-aligned-interface",
        "clef-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "pure-from-neighbor-interface",
        "staff-symbol-referencer-interface",
    ],
    "ClusterSpanner": [
        "cluster-interface",
        "grob-interface",
        "spanner-interface",
    ],
    "ClusterSpannerBeacon": [
        "cluster-beacon-interface",
        "grob-interface",
        "item-interface",
        "rhythmic-grob-interface",
    ],
    "CombineTextScript": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "side-position-interface",
        "text-interface",
        "text-script-interface",
    ],
    "CueClef": [
        "break-aligned-interface",
        "clef-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "pure-from-neighbor-interface",
        "staff-symbol-referencer-interface",
    ],
    "CueEndClef": [
        "break-aligned-interface",
        "clef-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "pure-from-neighbor-interface",
        "staff-symbol-referencer-interface",
    ],
    "Custos": [
        "break-aligned-interface",
        "custos-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "staff-symbol-referencer-interface",
    ],
    "DotColumn": [
        "axis-group-interface",
        "dot-column-interface",
        "grob-interface",
        "item-interface",
    ],
    "Dots": [
        "dots-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "staff-symbol-referencer-interface",
    ],
    "DoublePercentRepeat": [
        "break-aligned-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "percent-repeat-interface",
        "percent-repeat-item-interface",
    ],
    "DoublePercentRepeatCounter": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "percent-repeat-interface",
        "percent-repeat-item-interface",
        "self-alignment-interface",
        "side-position-interface",
        "text-interface",
    ],
    "DoubleRepeatSlash": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "percent-repeat-interface",
        "percent-repeat-item-interface",
        "rhythmic-grob-interface",
    ],
    "DynamicLineSpanner": [
        "axis-group-interface",
        "dynamic-interface",
        "dynamic-line-spanner-interface",
        "grob-interface",
        "side-position-interface",
        "spanner-interface",
    ],
    "DynamicText": [
        "dynamic-interface",
        "dynamic-text-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "script-interface",
        "self-alignment-interface",
        "text-interface",
    ],
    "DynamicTextSpanner": [
        "dynamic-interface",
        "dynamic-text-spanner-interface",
        "font-interface",
        "grob-interface",
        "line-interface",
        "line-spanner-interface",
        "spanner-interface",
        "text-interface",
    ],
    "Episema": [
        "episema-interface",
        "font-interface",
        "grob-interface",
        "line-interface",
        "line-spanner-interface",
        "side-position-interface",
        "spanner-interface",
    ],
    "Fingering": [
        "finger-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "self-alignment-interface",
        "side-position-interface",
        "text-interface",
        "text-script-interface",
    ],
    "Flag": [
        "flag-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
    ],
    "FootnoteItem": [
        "balloon-interface",
        "font-interface",
        "footnote-interface",
        "grob-interface",
        "item-interface",
        "text-interface",
    ],
    "FootnoteSpanner": [
        "balloon-interface",
        "font-interface",
        "footnote-interface",
        "footnote-spanner-interface",
        "grob-interface",
        "spanner-interface",
        "text-interface",
    ],
    "FretBoard": [
        "chord-name-interface",
        "font-interface",
        "fret-diagram-interface",
        "grob-interface",
        "item-interface",
        "rhythmic-grob-interface",
    ],
    "Glissando": [
        "glissando-interface",
        "grob-interface",
        "line-interface",
        "line-spanner-interface",
        "spanner-interface",
        "unbreakable-spanner-interface",
    ],
    "GraceSpacing": [
        "grace-spacing-interface",
        "grob-interface",
        "spacing-options-interface",
        "spanner-interface",
    ],
    "GridLine": [
        "grid-line-interface",
        "grob-interface",
        "item-interface",
        "self-alignment-interface",
    ],
    "GridPoint": [
        "grid-point-interface",
        "grob-interface",
        "item-interface",
    ],
    "Hairpin": [
        "dynamic-interface",
        "grob-interface",
        "hairpin-interface",
        "line-interface",
        "self-alignment-interface",
        "spanner-interface",
    ],
    "HorizontalBracket": [
        "grob-interface",
        "horizontal-bracket-interface",
        "line-interface",
        "side-position-interface",
        "spanner-interface",
    ],
    "InstrumentName": [
        "font-interface",
        "grob-interface",
        "self-alignment-interface",
        "side-position-interface",
        "spanner-interface",
        "system-start-text-interface",
    ],
    "InstrumentSwitch": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "self-alignment-interface",
        "side-position-interface",
        "text-interface",
    ],
    "KeyCancellation": [
        "break-aligned-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "key-cancellation-interface",
        "key-signature-interface",
        "pure-from-neighbor-interface",
        "staff-symbol-referencer-interface",
    ],
    "KeySignature": [
        "break-aligned-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "key-signature-interface",
        "pure-from-neighbor-interface",
        "staff-symbol-referencer-interface",
    ],
    "LaissezVibrerTie": [
        "grob-interface",
        "item-interface",
        "semi-tie-interface",
    ],
    "LaissezVibrerTieColumn": [
        "grob-interface",
        "item-interface",
        "semi-tie-column-interface",
    ],
    "LedgerLineSpanner": [
        "grob-interface",
        "ledger-line-spanner-interface",
        "spanner-interface",
    ],
    "LeftEdge": [
        "break-aligned-interface",
        "grob-interface",
        "item-interface",
    ],
    "LigatureBracket": [
        "grob-interface",
        "line-interface",
        "spanner-interface",
        "tuplet-bracket-interface",
    ],
    "LyricExtender": [
        "grob-interface",
        "lyric-extender-interface",
        "lyric-interface",
        "spanner-interface",
    ],
    "LyricHyphen": [
        "font-interface",
        "grob-interface",
        "lyric-hyphen-interface",
        "lyric-interface",
        "spanner-interface",
    ],
    "LyricSpace": [
        "grob-interface",
        "lyric-hyphen-interface",
        "spanner-interface",
    ],
    "LyricText": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "lyric-syllable-interface",
        "rhythmic-grob-interface",
        "self-alignment-interface",
        "text-interface",
    ],
    "MeasureGrouping": [
        "grob-interface",
        "measure-grouping-interface",
        "side-position-interface",
        "spanner-interface",
    ],
    "MelodyItem": [
        "grob-interface",
        "item-interface",
        "melody-spanner-interface",
    ],
    "MensuralLigature": [
        "font-interface",
        "grob-interface",
        "mensural-ligature-interface",
        "spanner-interface",
    ],
    "MetronomeMark": [
        "break-alignable-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "metronome-mark-interface",
        "self-alignment-interface",
        "side-position-interface",
        "text-interface",
    ],
    "MultiMeasureRest": [
        "font-interface",
        "grob-interface",
        "multi-measure-interface",
        "multi-measure-rest-interface",
        "rest-interface",
        "spanner-interface",
        "staff-symbol-referencer-interface",
    ],
    "MultiMeasureRestNumber": [
        "font-interface",
        "grob-interface",
        "multi-measure-interface",
        "self-alignment-interface",
        "side-position-interface",
        "spanner-interface",
        "text-interface",
    ],
    "MultiMeasureRestText": [
        "font-interface",
        "grob-interface",
        "multi-measure-interface",
        "self-alignment-interface",
        "side-position-interface",
        "spanner-interface",
        "text-interface",
    ],
    "NonMusicalPaperColumn": [
        "axis-group-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "paper-column-interface",
        "separation-item-interface",
        "spaceable-grob-interface",
    ],
    "NoteCollision": [
        "axis-group-interface",
        "grob-interface",
        "item-interface",
        "note-collision-interface",
    ],
    "NoteColumn": [
        "axis-group-interface",
        "grob-interface",
        "item-interface",
        "note-column-interface",
        "separation-item-interface",
    ],
    "NoteHead": [
        "font-interface",
        "gregorian-ligature-interface",
        "grob-interface",
        "item-interface",
        "ledgered-interface",
        "ligature-head-interface",
        "mensural-ligature-interface",
        "note-head-interface",
        "rhythmic-grob-interface",
        "rhythmic-head-interface",
        "staff-symbol-referencer-interface",
        "vaticana-ligature-interface",
    ],
    "NoteName": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "note-name-interface",
        "text-interface",
    ],
    "NoteSpacing": [
        "grob-interface",
        "item-interface",
        "note-spacing-interface",
        "spacing-interface",
    ],
    "OctavateEight": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "self-alignment-interface",
        "side-position-interface",
        "text-interface",
    ],
    "OttavaBracket": [
        "font-interface",
        "grob-interface",
        "horizontal-bracket-interface",
        "line-interface",
        "ottava-bracket-interface",
        "side-position-interface",
        "spanner-interface",
        "text-interface",
    ],
    "PaperColumn": [
        "axis-group-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "paper-column-interface",
        "separation-item-interface",
        "spaceable-grob-interface",
    ],
    "ParenthesesItem": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "parentheses-interface",
    ],
    "PercentRepeat": [
        "font-interface",
        "grob-interface",
        "multi-measure-rest-interface",
        "percent-repeat-interface",
        "spanner-interface",
    ],
    "PercentRepeatCounter": [
        "font-interface",
        "grob-interface",
        "percent-repeat-interface",
        "self-alignment-interface",
        "side-position-interface",
        "spanner-interface",
        "text-interface",
    ],
    "PhrasingSlur": [
        "grob-interface",
        "slur-interface",
        "spanner-interface",
    ],
    "PianoPedalBracket": [
        "grob-interface",
        "line-interface",
        "piano-pedal-bracket-interface",
        "piano-pedal-interface",
        "spanner-interface",
    ],
    "RehearsalMark": [
        "break-alignable-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "mark-interface",
        "self-alignment-interface",
        "side-position-interface",
        "text-interface",
    ],
    "RepeatSlash": [
        "grob-interface",
        "item-interface",
        "percent-repeat-interface",
        "percent-repeat-item-interface",
        "rhythmic-grob-interface",
    ],
    "RepeatTie": [
        "grob-interface",
        "item-interface",
        "semi-tie-interface",
    ],
    "RepeatTieColumn": [
        "grob-interface",
        "item-interface",
        "semi-tie-column-interface",
    ],
    "Rest": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "rest-interface",
        "rhythmic-grob-interface",
        "rhythmic-head-interface",
        "staff-symbol-referencer-interface",
    ],
    "RestCollision": [
        "grob-interface",
        "item-interface",
        "rest-collision-interface",
    ],
    "Script": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "script-interface",
        "side-position-interface",
    ],
    "ScriptColumn": [
        "grob-interface",
        "item-interface",
        "script-column-interface",
    ],
    "ScriptRow": [
        "grob-interface",
        "item-interface",
        "script-column-interface",
    ],
    "Slur": [
        "grob-interface",
        "slur-interface",
        "spanner-interface",
    ],
    "SostenutoPedal": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "piano-pedal-script-interface",
        "self-alignment-interface",
        "text-interface",
    ],
    "SostenutoPedalLineSpanner": [
        "axis-group-interface",
        "grob-interface",
        "piano-pedal-interface",
        "side-position-interface",
        "spanner-interface",
    ],
    "SpacingSpanner": [
        "grob-interface",
        "spacing-options-interface",
        "spacing-spanner-interface",
        "spanner-interface",
    ],
    "SpanBar": [
        "bar-line-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "span-bar-interface",
    ],
    "SpanBarStub": [
        "grob-interface",
        "item-interface",
        "pure-from-neighbor-interface",
    ],
    "StaffGrouper": [
        "grob-interface",
        "spanner-interface",
        "staff-grouper-interface",
    ],
    "StaffSpacing": [
        "grob-interface",
        "item-interface",
        "spacing-interface",
        "staff-spacing-interface",
    ],
    "StaffSymbol": [
        "grob-interface",
        "spanner-interface",
        "staff-symbol-interface",
    ],
    "StanzaNumber": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "side-position-interface",
        "stanza-number-interface",
        "text-interface",
    ],
    "Stem": [
        "grob-interface",
        "item-interface",
        "stem-interface",
    ],
    "StemStub": [
        "grob-interface",
        "item-interface",
    ],
    "StemTremolo": [
        "grob-interface",
        "item-interface",
        "self-alignment-interface",
        "stem-tremolo-interface",
    ],
    "StringNumber": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "self-alignment-interface",
        "side-position-interface",
        "string-number-interface",
        "text-interface",
        "text-script-interface",
    ],
    "StrokeFinger": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "self-alignment-interface",
        "side-position-interface",
        "stroke-finger-interface",
        "text-interface",
        "text-script-interface",
    ],
    "SustainPedal": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "piano-pedal-interface",
        "piano-pedal-script-interface",
        "self-alignment-interface",
        "text-interface",
    ],
    "SustainPedalLineSpanner": [
        "axis-group-interface",
        "grob-interface",
        "piano-pedal-interface",
        "side-position-interface",
        "spanner-interface",
    ],
    "System": [
        "axis-group-interface",
        "grob-interface",
        "spanner-interface",
        "system-interface",
    ],
    "SystemStartBar": [
        "grob-interface",
        "side-position-interface",
        "spanner-interface",
        "system-start-delimiter-interface",
    ],
    "SystemStartBrace": [
        "font-interface",
        "grob-interface",
        "side-position-interface",
        "spanner-interface",
        "system-start-delimiter-interface",
    ],
    "SystemStartBracket": [
        "font-interface",
        "grob-interface",
        "side-position-interface",
        "spanner-interface",
        "system-start-delimiter-interface",
    ],
    "SystemStartSquare": [
        "font-interface",
        "grob-interface",
        "side-position-interface",
        "spanner-interface",
        "system-start-delimiter-interface",
    ],
    "TabNoteHead": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "note-head-interface",
        "rhythmic-grob-interface",
        "rhythmic-head-interface",
        "staff-symbol-referencer-interface",
        "tab-note-head-interface",
        "text-interface",
    ],
    "TextScript": [
        "font-interface",
        "grob-interface",
        "instrument-specific-markup-interface",
        "item-interface",
        "self-alignment-interface",
        "side-position-interface",
        "text-interface",
        "text-script-interface",
    ],
    "TextSpanner": [
        "font-interface",
        "grob-interface",
        "line-interface",
        "line-spanner-interface",
        "side-position-interface",
        "spanner-interface",
    ],
    "Tie": [
        "grob-interface",
        "spanner-interface",
        "tie-interface",
    ],
    "TieColumn": [
        "grob-interface",
        "spanner-interface",
        "tie-column-interface",
    ],
    "TimeSignature": [
        "break-aligned-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "pure-from-neighbor-interface",
        "time-signature-interface",
    ],
    "TrillPitchAccidental": [
        "accidental-interface",
        "font-interface",
        "grob-interface",
        "inline-accidental-interface",
        "item-interface",
        "side-position-interface",
        "trill-pitch-accidental-interface",
    ],
    "TrillPitchGroup": [
        "axis-group-interface",
        "font-interface",
        "grob-interface",
        "item-interface",
        "note-head-interface",
        "parentheses-interface",
        "side-position-interface",
    ],
    "TrillPitchHead": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "ledgered-interface",
        "pitched-trill-interface",
        "rhythmic-head-interface",
        "staff-symbol-referencer-interface",
    ],
    "TrillSpanner": [
        "font-interface",
        "grob-interface",
        "line-interface",
        "line-spanner-interface",
        "side-position-interface",
        "spanner-interface",
        "trill-spanner-interface",
    ],
    "TupletBracket": [
        "grob-interface",
        "line-interface",
        "spanner-interface",
        "tuplet-bracket-interface",
    ],
    "TupletNumber": [
        "font-interface",
        "grob-interface",
        "spanner-interface",
        "text-interface",
        "tuplet-number-interface",
    ],
    "UnaCordaPedal": [
        "font-interface",
        "grob-interface",
        "item-interface",
        "piano-pedal-script-interface",
        "self-alignment-interface",
        "text-interface",
    ],
    "UnaCordaPedalLineSpanner": [
        "axis-group-interface",
        "grob-interface",
        "piano-pedal-interface",
        "side-position-interface",
        "spanner-interface",
    ],
    "VaticanaLigature": [
        "font-interface",
        "grob-interface",
        "spanner-interface",
        "vaticana-ligature-interface",
    ],
    "VerticalAlignment": [
        "align-interface",
        "axis-group-interface",
        "grob-interface",
        "spanner-interface",
    ],
    "VerticalAxisGroup": [
        "axis-group-interface",
        "grob-interface",
        "hara-kiri-group-spanner-interface",
        "spanner-interface",
    ],
    "VoiceFollower": [
        "grob-interface",
        "line-interface",
        "line-spanner-interface",
        "spanner-interface",
    ],
    "VoltaBracket": [
        "font-interface",
        "grob-interface",
        "horizontal-bracket-interface",
        "line-interface",
        "side-position-interface",
        "spanner-interface",
        "text-interface",
        "volta-bracket-interface",
        "volta-interface",
    ],
    "VoltaBracketSpanner": [
        "axis-group-interface",
        "grob-interface",
        "side-position-interface",
        "spanner-interface",
        "volta-interface",
    ],
}


contextproperties = [
    "aDueText",
    "additionalPitchPrefix",
    "alignAboveContext",
    "alignBassFigureAccidentals",
    "alignBelowContext",
    "alternativeNumberingStyle",
    "associatedVoice",
    "autoAccidentals",
    "autoBeamCheck",
    "autoBeaming",
    "autoCautionaries",
    "automaticBars",
    "barAlways",
    "barCheckSynchronize",
    "barNumberFormatter",
    "barNumberVisibility",
    "baseMoment",
    "bassFigureFormatFunction",
    "bassStaffProperties",
    "beamExceptions",
    "beamHalfMeasure",
    "beatStructure",
    "chordChanges",
    "chordNameExceptions",
    "chordNameExceptionsFull",
    "chordNameExceptionsPartial",
    "chordNameFunction",
    "chordNameLowercaseMinor",
    "chordNameSeparator",
    "chordNoteNamer",
    "chordPrefixSpacer",
    "chordRootNamer",
    "clefGlyph",
    "clefOctavation",
    "clefPosition",
    "completionBusy",
    "completionUnit",
    "connectArpeggios",
    "countPercentRepeats",
    "createKeyOnClefChange",
    "createSpacing",
    "crescendoSpanner",
    "crescendoText",
    "cueClefGlyph",
    "cueClefOctavation",
    "cueClefPosition",
    "currentBarNumber",
    "decrescendoSpanner",
    "decrescendoText",
    "defaultBarType",
    "defaultStrings",
    "doubleRepeatSegnoType",
    "doubleRepeatType",
    "doubleSlurs",
    "drumPitchTable",
    "drumStyleTable",
    "endRepeatSegnoType",
    "endRepeatType",
    "explicitClefVisibility",
    "explicitCueClefVisibility",
    "explicitKeySignatureVisibility",
    "extendersOverRests",
    "extraNatural",
    "figuredBassAlterationDirection",
    "figuredBassCenterContinuations",
    "figuredBassFormatter",
    "figuredBassPlusDirection",
    "fingeringOrientations",
    "firstClef",
    "followVoice",
    "fontSize",
    "forbidBreak",
    "forceClef",
    "fretLabels",
    "glissandoMap",
    "gridInterval",
    "handleNegativeFrets",
    "harmonicAccidentals",
    "harmonicDots",
    "highStringOne",
    "ignoreBarChecks",
    "ignoreFiguredBassRest",
    "ignoreMelismata",
    "implicitBassFigures",
    "implicitTimeSignatureVisibility",
    "includeGraceNotes",
    "instrumentCueName",
    "instrumentEqualizer",
    "instrumentName",
    "instrumentTransposition",
    "internalBarNumber",
    "keepAliveInterfaces",
    "keyAlterationOrder",
    "keySignature",
    "lyricMelismaAlignment",
    "majorSevenSymbol",
    "markFormatter",
    "maximumFretStretch",
    "measureLength",
    "measurePosition",
    "melismaBusyProperties",
    "metronomeMarkFormatter",
    "middleCClefPosition",
    "middleCCuePosition",
    "middleCOffset",
    "middleCPosition",
    "midiChannelMapping",
    "midiInstrument",
    "midiMaximumVolume",
    "midiMergeUnisons",
    "midiMinimumVolume",
    "minimumFret",
    "minimumPageTurnLength",
    "minimumRepeatLengthForPageTurn",
    "minorChordModifier",
    "noChordSymbol",
    "noteToFretFunction",
    "ottavation",
    "output",
    "partCombineTextsOnNote",
    "pedalSostenutoStrings",
    "pedalSostenutoStyle",
    "pedalSustainStrings",
    "pedalSustainStyle",
    "pedalUnaCordaStrings",
    "pedalUnaCordaStyle",
    "predefinedDiagramTable",
    "printKeyCancellation",
    "printOctaveNames",
    "printPartCombineTexts",
    "proportionalNotationDuration",
    "rehearsalMark",
    "repeatCommands",
    "repeatCountVisibility",
    "restCompletionBusy",
    "restNumberThreshold",
    "restrainOpenStrings",
    "searchForVoice",
    "segnoType",
    "shapeNoteStyles",
    "shortInstrumentName",
    "shortVocalName",
    "skipBars",
    "skipTypesetting",
    "slashChordSeparator",
    "soloIIText",
    "soloText",
    "squashedPosition",
    "staffLineLayoutFunction",
    "stanza",
    "startRepeatSegnoType",
    "startRepeatType",
    "stemLeftBeamCount",
    "stemRightBeamCount",
    "strictBeatBeaming",
    "stringNumberOrientations",
    "stringOneTopmost",
    "stringTunings",
    "strokeFingerOrientations",
    "subdivideBeams",
    "suggestAccidentals",
    "systemStartDelimiter",
    "systemStartDelimiterHierarchy",
    "tabStaffLineLayoutFunction",
    "tablatureFormat",
    "tempoHideNote",
    "tempoWholesPerMinute",
    "tieWaitForNote",
    "timeSignatureFraction",
    "timeSignatureSettings",
    "timing",
    "tonic",
    "topLevelAlignment",
    "trebleStaffProperties",
    "tremoloFlags",
    "tupletFullLength",
    "tupletFullLengthNote",
    "tupletSpannerDuration",
    "useBassFigureExtenders",
    "vocalName",
    "voltaSpannerDuration",
    "whichBar",
]


engravers = [
    "Accidental_engraver",
    "Ambitus_engraver",
    "Arpeggio_engraver",
    "Auto_beam_engraver",
    "Axis_group_engraver",
    "Balloon_engraver",
    "Bar_engraver",
    "Bar_number_engraver",
    "Beam_collision_engraver",
    "Beam_engraver",
    "Beam_performer",
    "Bend_engraver",
    "Break_align_engraver",
    "Breathing_sign_engraver",
    "Chord_name_engraver",
    "Chord_tremolo_engraver",
    "Clef_engraver",
    "Cluster_spanner_engraver",
    "Collision_engraver",
    "Completion_heads_engraver",
    "Completion_rest_engraver",
    "Concurrent_hairpin_engraver",
    "Control_track_performer",
    "Cue_clef_engraver",
    "Custos_engraver",
    "Default_bar_line_engraver",
    "Dot_column_engraver",
    "Dots_engraver",
    "Double_percent_repeat_engraver",
    "Drum_note_performer",
    "Drum_notes_engraver",
    "Dynamic_align_engraver",
    "Dynamic_engraver",
    "Dynamic_performer",
    "Engraver",
    "Episema_engraver",
    "Extender_engraver",
    "Figured_bass_engraver",
    "Figured_bass_position_engraver",
    "Fingering_engraver",
    "Font_size_engraver",
    "Footnote_engraver",
    "Forbid_line_break_engraver",
    "Fretboard_engraver",
    "Glissando_engraver",
    "Grace_beam_engraver",
    "Grace_engraver",
    "Grace_spacing_engraver",
    "Grid_line_span_engraver",
    "Grid_point_engraver",
    "Grob_pq_engraver",
    "Hara_kiri_engraver",
    "Horizontal_bracket_engraver",
    "Hyphen_engraver",
    "Instrument_name_engraver",
    "Instrument_switch_engraver",
    "Keep_alive_together_engraver",
    "Key_engraver",
    "Key_performer",
    "Laissez_vibrer_engraver",
    "Ledger_line_engraver",
    "Ligature_bracket_engraver",
    "Lyric_engraver",
    "Lyric_performer",
    "Mark_engraver",
    "Measure_grouping_engraver",
    "Melody_engraver",
    "Mensural_ligature_engraver",
    "Metronome_mark_engraver",
    "Multi_measure_rest_engraver",
    "New_dynamic_engraver",
    "New_fingering_engraver",
    "Note_head_line_engraver",
    "Note_heads_engraver",
    "Note_name_engraver",
    "Note_performer",
    "Note_spacing_engraver",
    "Ottava_spanner_engraver",
    "Output_property_engraver",
    "Page_turn_engraver",
    "Paper_column_engraver",
    "Parenthesis_engraver",
    "Part_combine_engraver",
    "Percent_repeat_engraver",
    "Phrasing_slur_engraver",
    "Piano_pedal_align_engraver",
    "Piano_pedal_engraver",
    "Piano_pedal_performer",
    "Pitch_squash_engraver",
    "Pitched_trill_engraver",
    "Pure_from_neighbor_engraver",
    "Repeat_acknowledge_engraver",
    "Repeat_tie_engraver",
    "Rest_collision_engraver",
    "Rest_engraver",
    "Rhythmic_column_engraver",
    "Scheme_engraver",
    "Script_column_engraver",
    "Script_engraver",
    "Script_row_engraver",
    "Separating_line_group_engraver",
    "Slash_repeat_engraver",
    "Slur_engraver",
    "Slur_performer",
    "Spacing_engraver",
    "Span_arpeggio_engraver",
    "Span_bar_engraver",
    "Span_bar_stub_engraver",
    "Spanner_break_forbid_engraver",
    "Staff_collecting_engraver",
    "Staff_performer",
    "Staff_symbol_engraver",
    "Stanza_number_align_engraver",
    "Stanza_number_engraver",
    "Stem_engraver",
    "System_start_delimiter_engraver",
    "Tab_note_heads_engraver",
    "Tab_staff_symbol_engraver",
    "Tab_tie_follow_engraver",
    "Tempo_performer",
    "Text_engraver",
    "Text_spanner_engraver",
    "Tie_engraver",
    "Tie_performer",
    "Time_signature_engraver",
    "Time_signature_performer",
    "Timing_translator",
    "Translator",
    "Trill_spanner_engraver",
    "Tuplet_engraver",
    "Tweak_engraver",
    "Vaticana_ligature_engraver",
    "Vertical_align_engraver",
    "Volta_engraver",
]


musicglyphs = [
    "accidentals.doublesharp",
    "accidentals.flat",
    "accidentals.flat.arrowboth",
    "accidentals.flat.arrowdown",
    "accidentals.flat.arrowup",
    "accidentals.flat.slash",
    "accidentals.flat.slashslash",
    "accidentals.flatflat",
    "accidentals.flatflat.slash",
    "accidentals.hufnagelM1",
    "accidentals.kievan1",
    "accidentals.kievanM1",
    "accidentals.leftparen",
    "accidentals.medicaeaM1",
    "accidentals.mensural1",
    "accidentals.mensuralM1",
    "accidentals.mirroredflat",
    "accidentals.mirroredflat.backslash",
    "accidentals.mirroredflat.flat",
    "accidentals.natural",
    "accidentals.natural.arrowboth",
    "accidentals.natural.arrowdown",
    "accidentals.natural.arrowup",
    "accidentals.rightparen",
    "accidentals.sharp",
    "accidentals.sharp.arrowboth",
    "accidentals.sharp.arrowdown",
    "accidentals.sharp.arrowup",
    "accidentals.sharp.slashslash.stem",
    "accidentals.sharp.slashslash.stemstemstem",
    "accidentals.sharp.slashslashslash.stem",
    "accidentals.sharp.slashslashslash.stemstem",
    "accidentals.vaticana0",
    "accidentals.vaticanaM1",
    "accordion.bayanbass",
    "accordion.discant",
    "accordion.dot",
    "accordion.freebass",
    "accordion.oldEE",
    "accordion.pull",
    "accordion.push",
    "accordion.stdbass",
    "arrowheads.close.01",
    "arrowheads.close.0M1",
    "arrowheads.close.11",
    "arrowheads.close.1M1",
    "arrowheads.open.01",
    "arrowheads.open.0M1",
    "arrowheads.open.11",
    "arrowheads.open.1M1",
    "brackettips.down",
    "brackettips.up",
    "clefs.C",
    "clefs.C_change",
    "clefs.F",
    "clefs.F_change",
    "clefs.G",
    "clefs.G_change",
    "clefs.hufnagel.do",
    "clefs.hufnagel.do.fa",
    "clefs.hufnagel.do.fa_change",
    "clefs.hufnagel.do_change",
    "clefs.hufnagel.fa",
    "clefs.hufnagel.fa_change",
    "clefs.kievan.do",
    "clefs.kievan.do_change",
    "clefs.medicaea.do",
    "clefs.medicaea.do_change",
    "clefs.medicaea.fa",
    "clefs.medicaea.fa_change",
    "clefs.mensural.c",
    "clefs.mensural.c_change",
    "clefs.mensural.f",
    "clefs.mensural.f_change",
    "clefs.mensural.g",
    "clefs.mensural.g_change",
    "clefs.neomensural.c",
    "clefs.neomensural.c_change",
    "clefs.percussion",
    "clefs.percussion_change",
    "clefs.petrucci.c1",
    "clefs.petrucci.c1_change",
    "clefs.petrucci.c2",
    "clefs.petrucci.c2_change",
    "clefs.petrucci.c3",
    "clefs.petrucci.c3_change",
    "clefs.petrucci.c4",
    "clefs.petrucci.c4_change",
    "clefs.petrucci.c5",
    "clefs.petrucci.c5_change",
    "clefs.petrucci.f",
    "clefs.petrucci.f_change",
    "clefs.petrucci.g",
    "clefs.petrucci.g_change",
    "clefs.tab",
    "clefs.tab_change",
    "clefs.vaticana.do",
    "clefs.vaticana.do_change",
    "clefs.vaticana.fa",
    "clefs.vaticana.fa_change",
    "comma",
    "custodes.hufnagel.d0",
    "custodes.hufnagel.d1",
    "custodes.hufnagel.d2",
    "custodes.hufnagel.u0",
    "custodes.hufnagel.u1",
    "custodes.hufnagel.u2",
    "custodes.medicaea.d0",
    "custodes.medicaea.d1",
    "custodes.medicaea.d2",
    "custodes.medicaea.u0",
    "custodes.medicaea.u1",
    "custodes.medicaea.u2",
    "custodes.mensural.d0",
    "custodes.mensural.d1",
    "custodes.mensural.d2",
    "custodes.mensural.u0",
    "custodes.mensural.u1",
    "custodes.mensural.u2",
    "custodes.vaticana.d0",
    "custodes.vaticana.d1",
    "custodes.vaticana.d2",
    "custodes.vaticana.u0",
    "custodes.vaticana.u1",
    "custodes.vaticana.u2",
    "dots.dot",
    "dots.dotkievan",
    "dots.dotvaticana",
    "eight",
    "f",
    "five",
    "flags.d3",
    "flags.d4",
    "flags.d5",
    "flags.d6",
    "flags.d7",
    "flags.dgrace",
    "flags.mensurald03",
    "flags.mensurald04",
    "flags.mensurald05",
    "flags.mensurald06",
    "flags.mensurald13",
    "flags.mensurald14",
    "flags.mensurald15",
    "flags.mensurald16",
    "flags.mensurald23",
    "flags.mensurald24",
    "flags.mensurald25",
    "flags.mensurald26",
    "flags.mensuralu03",
    "flags.mensuralu04",
    "flags.mensuralu05",
    "flags.mensuralu06",
    "flags.mensuralu13",
    "flags.mensuralu14",
    "flags.mensuralu15",
    "flags.mensuralu16",
    "flags.mensuralu23",
    "flags.mensuralu24",
    "flags.mensuralu25",
    "flags.mensuralu26",
    "flags.u3",
    "flags.u4",
    "flags.u5",
    "flags.u6",
    "flags.u7",
    "flags.ugrace",
    "four",
    "hyphen",
    "m",
    "nine",
    "noteheads.d0doFunk",
    "noteheads.d0fa",
    "noteheads.d0faFunk",
    "noteheads.d0faThin",
    "noteheads.d0miFunk",
    "noteheads.d0reFunk",
    "noteheads.d0tiFunk",
    "noteheads.d1do",
    "noteheads.d1doFunk",
    "noteheads.d1doThin",
    "noteheads.d1doWalker",
    "noteheads.d1fa",
    "noteheads.d1faFunk",
    "noteheads.d1faThin",
    "noteheads.d1faWalker",
    "noteheads.d1miFunk",
    "noteheads.d1re",
    "noteheads.d1reFunk",
    "noteheads.d1reThin",
    "noteheads.d1reWalker",
    "noteheads.d1ti",
    "noteheads.d1tiFunk",
    "noteheads.d1tiThin",
    "noteheads.d1tiWalker",
    "noteheads.d1triangle",
    "noteheads.d2do",
    "noteheads.d2doFunk",
    "noteheads.d2doThin",
    "noteheads.d2doWalker",
    "noteheads.d2fa",
    "noteheads.d2faFunk",
    "noteheads.d2faThin",
    "noteheads.d2faWalker",
    "noteheads.d2kievan",
    "noteheads.d2re",
    "noteheads.d2reFunk",
    "noteheads.d2reThin",
    "noteheads.d2reWalker",
    "noteheads.d2ti",
    "noteheads.d2tiFunk",
    "noteheads.d2tiThin",
    "noteheads.d2tiWalker",
    "noteheads.d2triangle",
    "noteheads.d3kievan",
    "noteheads.dM2",
    "noteheads.dM2blackmensural",
    "noteheads.dM2mensural",
    "noteheads.dM2neomensural",
    "noteheads.dM2semimensural",
    "noteheads.dM3blackmensural",
    "noteheads.dM3mensural",
    "noteheads.dM3neomensural",
    "noteheads.dM3semimensural",
    "noteheads.drM2mensural",
    "noteheads.drM2neomensural",
    "noteheads.drM2semimensural",
    "noteheads.drM3mensural",
    "noteheads.drM3neomensural",
    "noteheads.drM3semimensural",
    "noteheads.s0",
    "noteheads.s0blackmensural",
    "noteheads.s0blackpetrucci",
    "noteheads.s0cross",
    "noteheads.s0diamond",
    "noteheads.s0do",
    "noteheads.s0doThin",
    "noteheads.s0doWalker",
    "noteheads.s0faWalker",
    "noteheads.s0harmonic",
    "noteheads.s0kievan",
    "noteheads.s0la",
    "noteheads.s0laFunk",
    "noteheads.s0laThin",
    "noteheads.s0laWalker",
    "noteheads.s0mensural",
    "noteheads.s0mi",
    "noteheads.s0miMirror",
    "noteheads.s0miThin",
    "noteheads.s0miWalker",
    "noteheads.s0neomensural",
    "noteheads.s0petrucci",
    "noteheads.s0re",
    "noteheads.s0reThin",
    "noteheads.s0reWalker",
    "noteheads.s0slash",
    "noteheads.s0sol",
    "noteheads.s0solFunk",
    "noteheads.s0ti",
    "noteheads.s0tiThin",
    "noteheads.s0tiWalker",
    "noteheads.s0triangle",
    "noteheads.s1",
    "noteheads.s1blackpetrucci",
    "noteheads.s1cross",
    "noteheads.s1diamond",
    "noteheads.s1kievan",
    "noteheads.s1la",
    "noteheads.s1laFunk",
    "noteheads.s1laThin",
    "noteheads.s1laWalker",
    "noteheads.s1mensural",
    "noteheads.s1mi",
    "noteheads.s1miMirror",
    "noteheads.s1miThin",
    "noteheads.s1miWalker",
    "noteheads.s1neomensural",
    "noteheads.s1petrucci",
    "noteheads.s1slash",
    "noteheads.s1sol",
    "noteheads.s1solFunk",
    "noteheads.s2",
    "noteheads.s2blackpetrucci",
    "noteheads.s2cross",
    "noteheads.s2diamond",
    "noteheads.s2harmonic",
    "noteheads.s2la",
    "noteheads.s2laFunk",
    "noteheads.s2laThin",
    "noteheads.s2laWalker",
    "noteheads.s2mensural",
    "noteheads.s2mi",
    "noteheads.s2miFunk",
    "noteheads.s2miMirror",
    "noteheads.s2miThin",
    "noteheads.s2miWalker",
    "noteheads.s2neomensural",
    "noteheads.s2petrucci",
    "noteheads.s2slash",
    "noteheads.s2sol",
    "noteheads.s2solFunk",
    "noteheads.s2xcircle",
    "noteheads.sM1",
    "noteheads.sM1blackmensural",
    "noteheads.sM1double",
    "noteheads.sM1kievan",
    "noteheads.sM1mensural",
    "noteheads.sM1neomensural",
    "noteheads.sM1semimensural",
    "noteheads.sM2blackligmensural",
    "noteheads.sM2kievan",
    "noteheads.sM2ligmensural",
    "noteheads.sM2semiligmensural",
    "noteheads.sM3blackligmensural",
    "noteheads.sM3ligmensural",
    "noteheads.sM3semiligmensural",
    "noteheads.shufnagel.lpes",
    "noteheads.shufnagel.punctum",
    "noteheads.shufnagel.virga",
    "noteheads.smedicaea.inclinatum",
    "noteheads.smedicaea.punctum",
    "noteheads.smedicaea.rvirga",
    "noteheads.smedicaea.virga",
    "noteheads.sr1kievan",
    "noteheads.srM1mensural",
    "noteheads.srM1neomensural",
    "noteheads.srM1semimensural",
    "noteheads.srM2ligmensural",
    "noteheads.srM2semiligmensural",
    "noteheads.srM3ligmensural",
    "noteheads.srM3semiligmensural",
    "noteheads.ssolesmes.auct.asc",
    "noteheads.ssolesmes.auct.desc",
    "noteheads.ssolesmes.incl.auctum",
    "noteheads.ssolesmes.incl.parvum",
    "noteheads.ssolesmes.oriscus",
    "noteheads.ssolesmes.stropha",
    "noteheads.ssolesmes.stropha.aucta",
    "noteheads.svaticana.cephalicus",
    "noteheads.svaticana.epiphonus",
    "noteheads.svaticana.inclinatum",
    "noteheads.svaticana.inner.cephalicus",
    "noteheads.svaticana.linea.punctum",
    "noteheads.svaticana.linea.punctum.cavum",
    "noteheads.svaticana.lpes",
    "noteheads.svaticana.plica",
    "noteheads.svaticana.punctum",
    "noteheads.svaticana.punctum.cavum",
    "noteheads.svaticana.quilisma",
    "noteheads.svaticana.reverse.plica",
    "noteheads.svaticana.reverse.vplica",
    "noteheads.svaticana.upes",
    "noteheads.svaticana.vepiphonus",
    "noteheads.svaticana.vlpes",
    "noteheads.svaticana.vplica",
    "noteheads.svaticana.vupes",
    "noteheads.u0doFunk",
    "noteheads.u0fa",
    "noteheads.u0faFunk",
    "noteheads.u0faThin",
    "noteheads.u0miFunk",
    "noteheads.u0reFunk",
    "noteheads.u0tiFunk",
    "noteheads.u1do",
    "noteheads.u1doFunk",
    "noteheads.u1doThin",
    "noteheads.u1doWalker",
    "noteheads.u1fa",
    "noteheads.u1faFunk",
    "noteheads.u1faThin",
    "noteheads.u1faWalker",
    "noteheads.u1miFunk",
    "noteheads.u1re",
    "noteheads.u1reFunk",
    "noteheads.u1reThin",
    "noteheads.u1reWalker",
    "noteheads.u1ti",
    "noteheads.u1tiFunk",
    "noteheads.u1tiThin",
    "noteheads.u1tiWalker",
    "noteheads.u1triangle",
    "noteheads.u2do",
    "noteheads.u2doFunk",
    "noteheads.u2doThin",
    "noteheads.u2doWalker",
    "noteheads.u2fa",
    "noteheads.u2faFunk",
    "noteheads.u2faThin",
    "noteheads.u2faWalker",
    "noteheads.u2kievan",
    "noteheads.u2re",
    "noteheads.u2reFunk",
    "noteheads.u2reThin",
    "noteheads.u2reWalker",
    "noteheads.u2ti",
    "noteheads.u2tiFunk",
    "noteheads.u2tiThin",
    "noteheads.u2tiWalker",
    "noteheads.u2triangle",
    "noteheads.u3kievan",
    "noteheads.uM2",
    "noteheads.uM2blackmensural",
    "noteheads.uM2mensural",
    "noteheads.uM2neomensural",
    "noteheads.uM2semimensural",
    "noteheads.uM3blackmensural",
    "noteheads.uM3mensural",
    "noteheads.uM3neomensural",
    "noteheads.uM3semimensural",
    "noteheads.urM2mensural",
    "noteheads.urM2neomensural",
    "noteheads.urM2semimensural",
    "noteheads.urM3mensural",
    "noteheads.urM3neomensural",
    "noteheads.urM3semimensural",
    "one",
    "p",
    "pedal.*",
    "pedal..",
    "pedal.M",
    "pedal.P",
    "pedal.Ped",
    "pedal.d",
    "pedal.e",
    "period",
    "plus",
    "r",
    "rests.0",
    "rests.0mensural",
    "rests.0neomensural",
    "rests.0o",
    "rests.1",
    "rests.1mensural",
    "rests.1neomensural",
    "rests.1o",
    "rests.2",
    "rests.2classical",
    "rests.2mensural",
    "rests.2neomensural",
    "rests.3",
    "rests.3mensural",
    "rests.3neomensural",
    "rests.4",
    "rests.4mensural",
    "rests.4neomensural",
    "rests.5",
    "rests.6",
    "rests.7",
    "rests.M1",
    "rests.M1mensural",
    "rests.M1neomensural",
    "rests.M1o",
    "rests.M2",
    "rests.M2mensural",
    "rests.M2neomensural",
    "rests.M3",
    "rests.M3mensural",
    "rests.M3neomensural",
    "s",
    "scripts.arpeggio",
    "scripts.arpeggio.arrow.1",
    "scripts.arpeggio.arrow.M1",
    "scripts.augmentum",
    "scripts.barline.kievan",
    "scripts.caesura.curved",
    "scripts.caesura.straight",
    "scripts.circulus",
    "scripts.coda",
    "scripts.daccentus",
    "scripts.dfermata",
    "scripts.dlongfermata",
    "scripts.dmarcato",
    "scripts.downbow",
    "scripts.downmordent",
    "scripts.downprall",
    "scripts.dpedalheel",
    "scripts.dpedaltoe",
    "scripts.dportato",
    "scripts.dsemicirculus",
    "scripts.dshortfermata",
    "scripts.dsignumcongruentiae",
    "scripts.dstaccatissimo",
    "scripts.dverylongfermata",
    "scripts.espr",
    "scripts.flageolet",
    "scripts.halfopen",
    "scripts.halfopenvertical",
    "scripts.ictus",
    "scripts.lcomma",
    "scripts.lineprall",
    "scripts.lvarcomma",
    "scripts.mordent",
    "scripts.open",
    "scripts.prall",
    "scripts.pralldown",
    "scripts.prallmordent",
    "scripts.prallprall",
    "scripts.prallup",
    "scripts.rcomma",
    "scripts.reverseturn",
    "scripts.rvarcomma",
    "scripts.segno",
    "scripts.sforzato",
    "scripts.snappizzicato",
    "scripts.staccato",
    "scripts.stopped",
    "scripts.tenuto",
    "scripts.thumb",
    "scripts.trilelement",
    "scripts.trill",
    "scripts.trill_element",
    "scripts.turn",
    "scripts.uaccentus",
    "scripts.ufermata",
    "scripts.ulongfermata",
    "scripts.umarcato",
    "scripts.upbow",
    "scripts.upedalheel",
    "scripts.upedaltoe",
    "scripts.upmordent",
    "scripts.uportato",
    "scripts.upprall",
    "scripts.usemicirculus",
    "scripts.ushortfermata",
    "scripts.usignumcongruentiae",
    "scripts.ustaccatissimo",
    "scripts.uverylongfermata",
    "scripts.varcoda",
    "scripts.varsegno",
    "seven",
    "six",
    "space",
    "three",
    "ties.lyric.default",
    "ties.lyric.short",
    "timesig.C22",
    "timesig.C44",
    "timesig.mensural22",
    "timesig.mensural24",
    "timesig.mensural32",
    "timesig.mensural34",
    "timesig.mensural44",
    "timesig.mensural48",
    "timesig.mensural64",
    "timesig.mensural68",
    "timesig.mensural68alt",
    "timesig.mensural94",
    "timesig.mensural98",
    "timesig.neomensural22",
    "timesig.neomensural24",
    "timesig.neomensural32",
    "timesig.neomensural34",
    "timesig.neomensural44",
    "timesig.neomensural48",
    "timesig.neomensural64",
    "timesig.neomensural68",
    "timesig.neomensural68alt",
    "timesig.neomensural94",
    "timesig.neomensural98",
    "two",
    "z",
    "zero",
]



########NEW FILE########
__FILENAME__ = _scheme_data
#! python
#generated by makeschemedata.py

version="2.17"

scheme_keywords = [
    '*',
    '+',
    '-',
    '->char-set',
    '/',
    '1+',
    '1-',
    '<',
    '<=',
    '=',
    '==',
    '>',
    '>=',
    'abs',
    'access?',
    'acons',
    'acos',
    'acosh',
    'activate-readline',
    'add-duration',
    'add-duration!',
    'add-hook!',
    'alist->hash-table',
    'alist-cons',
    'alist-copy',
    'alist-delete',
    'alist-delete!',
    'and',
    'and-let*',
    'angle',
    'any',
    'any->c32vector',
    'any->c64vector',
    'any->f32vector',
    'any->f64vector',
    'any->s16vector',
    'any->s32vector',
    'any->s64vector',
    'any->s8vector',
    'any->u16vector',
    'any->u32vector',
    'any->u64vector',
    'any->u8vector',
    'any-bits-set?',
    'append',
    'append!',
    'append-map',
    'append-map!',
    'append-reverse',
    'append-reverse!',
    'apply',
    'apply:nconc2last',
    'apropos-completion-function',
    'arithmetic-shift',
    'array->list',
    'array-contents',
    'array-copy!',
    'array-copy-in-order!',
    'array-dimensions',
    'array-equal?',
    'array-fill!',
    'array-for-each',
    'array-in-bounds?',
    'array-index-map!',
    'array-map!',
    'array-map-in-order!',
    'array-rank',
    'array-ref',
    'array-set!',
    'array-shape',
    'array-type',
    'array?',
    'ash',
    'asin',
    'asinh',
    'assoc',
    'assoc-ref',
    'assoc-remove!',
    'assoc-set!',
    'assq',
    'assq-ref',
    'assq-remove!',
    'assq-set!',
    'assv',
    'assv-ref',
    'assv-remove!',
    'assv-set!',
    'atan',
    'atanh',
    'basename',
    'begin',
    'bit-count',
    'bit-count*',
    'bit-extract',
    'bit-field',
    'bit-invert!',
    'bit-position',
    'bit-set*!',
    'bit-set?',
    'bitvector',
    'bitvector->list',
    'bitvector-fill!',
    'bitvector-length',
    'bitvector-ref',
    'bitvector-set!',
    'bitvector?',
    'bitwise-and',
    'bitwise-if',
    'bitwise-ior',
    'bitwise-merge',
    'bitwise-not',
    'bitwise-xor',
    'boolean?',
    'booleans->integer',
    'break',
    'break!',
    'broadcast-condition-variable',
    'c32vector',
    'c32vector->list',
    'c32vector-length',
    'c32vector-ref',
    'c32vector-set!',
    'c32vector?',
    'c64vector',
    'c64vector->list',
    'c64vector-length',
    'c64vector-ref',
    'c64vector-set!',
    'c64vector?',
    'caaaar',
    'caaadr',
    'caaar',
    'caadar',
    'caaddr',
    'caadr',
    'caar',
    'cadaar',
    'cadadr',
    'cadar',
    'caddar',
    'cadddr',
    'caddr',
    'cadr',
    'call-with-input-file',
    'call-with-input-string',
    'call-with-output-file',
    'call-with-output-string',
    'call-with-values',
    'car',
    'car+cdr',
    'case',
    'case-lambda',
    'catch',
    'cd',
    'cdaaar',
    'cdaadr',
    'cdaar',
    'cdadar',
    'cdaddr',
    'cdadr',
    'cdar',
    'cddaar',
    'cddadr',
    'cddar',
    'cdddar',
    'cddddr',
    'cdddr',
    'cddr',
    'cdr',
    'ceiling',
    'char->integer',
    'char-alphabetic?',
    'char-ci<=?',
    'char-ci<?',
    'char-ci=?',
    'char-ci>=?',
    'char-ci>?',
    'char-downcase',
    'char-is-both?',
    'char-lower-case?',
    'char-numeric?',
    'char-ready?',
    'char-set',
    'char-set->list',
    'char-set->string',
    'char-set-adjoin',
    'char-set-adjoin!',
    'char-set-any',
    'char-set-complement',
    'char-set-complement!',
    'char-set-contains?',
    'char-set-copy',
    'char-set-count',
    'char-set-cursor',
    'char-set-cursor-next',
    'char-set-delete',
    'char-set-delete!',
    'char-set-diff+intersection',
    'char-set-diff+intersection!',
    'char-set-difference',
    'char-set-difference!',
    'char-set-every',
    'char-set-filter',
    'char-set-filter!',
    'char-set-fold',
    'char-set-for-each',
    'char-set-hash',
    'char-set-intersection',
    'char-set-intersection!',
    'char-set-map',
    'char-set-ref',
    'char-set-size',
    'char-set-unfold',
    'char-set-unfold!',
    'char-set-union',
    'char-set-union!',
    'char-set-xor',
    'char-set-xor!',
    'char-set<=',
    'char-set=',
    'char-set?',
    'char-upcase',
    'char-upper-case?',
    'char-whitespace?',
    'char<=?',
    'char<?',
    'char=?',
    'char>=?',
    'char>?',
    'char?',
    'chdir',
    'chmod',
    'chown',
    'chroot',
    'circular-list',
    'circular-list?',
    'close',
    'close-fdes',
    'close-input-port',
    'close-output-port',
    'close-pipe',
    'close-port',
    'closedir',
    'closure?',
    'command-line',
    'complex?',
    'concatenate',
    'concatenate!',
    'cond',
    'cond-expand',
    'condition',
    'condition-has-type?',
    'condition-message',
    'condition-ref',
    'condition-type?',
    'cons',
    'cons*',
    'cons-source',
    'continue',
    'copy-bit',
    'copy-bit-field',
    'copy-file',
    'copy-random-state',
    'copy-time',
    'copy-tree',
    'cos',
    'cosh',
    'count',
    'ctermid',
    'current-date',
    'current-dynamic-state',
    'current-error-port',
    'current-input-port',
    'current-julian-day',
    'current-load-port',
    'current-modified-julian-day',
    'current-module',
    'current-output-port',
    'current-time',
    'cut',
    'cute',
    'date->julian-day',
    'date->modified-julian-day',
    'date->string',
    'date->time-monotonic',
    'date->time-tai',
    'date->time-utc',
    'date-day',
    'date-hour',
    'date-minute',
    'date-month',
    'date-nanosecond',
    'date-second',
    'date-week-day',
    'date-week-number',
    'date-year',
    'date-year-day',
    'date-zone-offset',
    'date?',
    'debug-object?',
    'debug-options-interface',
    'debug-trap',
    'default-duplicate-binding-handler',
    'define',
    'define*',
    'define*-public',
    'define-condition-type',
    'define-macro',
    'define-module',
    'define-public',
    'define-reader-ctor',
    'define-record-type',
    'defined?',
    'defmacro',
    'defmacro*',
    'defmacro*-public',
    'delay',
    'delete',
    'delete!',
    'delete-duplicates',
    'delete-duplicates!',
    'delete-file',
    'delete1!',
    'delq',
    'delq!',
    'delq1!',
    'delv',
    'delv!',
    'delv1!',
    'denominator',
    'deq!',
    'directory-stream?',
    'dirname',
    'display',
    'display-application',
    'display-backtrace',
    'display-error',
    'do',
    'dotted-list?',
    'doubly-weak-hash-table?',
    'down',
    'drain-input',
    'drop',
    'drop-right',
    'drop-right!',
    'drop-while',
    'dup',
    'dup->fdes',
    'dup->inport',
    'dup->outport',
    'dup->port',
    'dup2',
    'duplicate-port',
    'dynamic-args-call',
    'dynamic-call',
    'dynamic-func',
    'dynamic-link',
    'dynamic-object?',
    'dynamic-state?',
    'dynamic-unlink',
    'dynamic-wind',
    'effective-version',
    'eighth',
    'else',
    'enclose-array',
    'end-of-char-set?',
    'enq!',
    'entity?',
    'environ',
    'eof-object?',
    'eq?',
    'equal?',
    'eqv?',
    'error',
    'error?',
    'eval',
    'eval-disable',
    'eval-enable',
    'eval-options',
    'eval-options-interface',
    'eval-set!',
    'eval-string',
    'evaluate',
    'evaluator-traps-interface',
    'even?',
    'every',
    'exact->inexact',
    'exact?',
    'execl',
    'execle',
    'execlp',
    'exp',
    'expect',
    'expect-strings',
    'export',
    'expt',
    'extract-condition',
    'f32vector',
    'f32vector->list',
    'f32vector-length',
    'f32vector-ref',
    'f32vector-set!',
    'f32vector?',
    'f64vector',
    'f64vector->list',
    'f64vector-length',
    'f64vector-ref',
    'f64vector-set!',
    'f64vector?',
    'false-if-exception',
    'fchmod',
    'fchown',
    'fcntl',
    'fdes->inport',
    'fdes->outport',
    'fdes->ports',
    'fdopen',
    'feature?',
    'fflush',
    'fifth',
    'file-exists?',
    'file-port?',
    'filename-completion-function',
    'fileno',
    'filter',
    'filter!',
    'filter-map',
    'find',
    'find-tail',
    'first',
    'first-set-bit',
    'flock',
    'floor',
    'fluid-ref',
    'fluid-set!',
    'fluid?',
    'flush-all-ports',
    'fn',
    'fold',
    'fold-matches',
    'fold-right',
    'for-each',
    'force',
    'force-output',
    'format',
    'fourth',
    'frame',
    'frame-arguments',
    'frame-evaluating-args?',
    'frame-next',
    'frame-number',
    'frame-overflow?',
    'frame-previous',
    'frame-procedure',
    'frame-procedure?',
    'frame-real?',
    'frame-source',
    'frame?',
    'fstat',
    'fsync',
    'ftell',
    'ftruncate',
    'ftw',
    'gcd',
    'generalized-vector->list',
    'generalized-vector-length',
    'generalized-vector-ref',
    'generalized-vector-set!',
    'generalized-vector?',
    'gensym',
    'get-internal-real-time',
    'get-internal-run-time',
    'get-output-string',
    'get-print-state',
    'getcwd',
    'getegid',
    'getenv',
    'geteuid',
    'getgid',
    'getgroups',
    'getpgrp',
    'getpid',
    'getppid',
    'getpriority',
    'getter-with-setter',
    'gettimeofday',
    'getuid',
    'gmtime',
    'hash',
    'hash-by-identity',
    'hash-clear!',
    'hash-create-handle!',
    'hash-fold',
    'hash-for-each',
    'hash-for-each-handle',
    'hash-get-handle',
    'hash-map->list',
    'hash-ref',
    'hash-remove!',
    'hash-set!',
    'hash-table->alist',
    'hash-table-delete!',
    'hash-table-equivalence-function',
    'hash-table-exists?',
    'hash-table-fold',
    'hash-table-hash-function',
    'hash-table-keys',
    'hash-table-ref',
    'hash-table-ref/default',
    'hash-table-set!',
    'hash-table-size',
    'hash-table-update!',
    'hash-table-update!/default',
    'hash-table-values',
    'hash-table-walk',
    'hash-table?',
    'hashq',
    'hashq-create-handle!',
    'hashq-get-handle',
    'hashq-ref',
    'hashq-remove!',
    'hashq-set!',
    'hashv',
    'hashv-create-handle!',
    'hashv-get-handle',
    'hashv-ref',
    'hashv-remove!',
    'hashv-set!',
    'hashx-create-handle!',
    'hashx-get-handle',
    'hashx-ref',
    'hashx-remove!',
    'hashx-set!',
    'hook->list',
    'hook-empty?',
    'hook?',
    'if',
    'imag-part',
    'inet-aton',
    'inet-lnaof',
    'inet-makeaddr',
    'inet-netof',
    'inet-ntoa',
    'inet-ntop',
    'inet-pton',
    'inexact->exact',
    'inexact?',
    'inf',
    'inf?',
    'input-port?',
    'install-trap',
    'integer->char',
    'integer->list',
    'integer-expt',
    'integer-length',
    'integer?',
    'interaction-environment',
    'iota',
    'isatty?',
    'julian-day->date',
    'julian-day->time-monotonic',
    'julian-day->time-tai',
    'julian-day->time-utc',
    'key',
    'keyword->string',
    'keyword->symbol',
    'keyword?',
    'lambda',
    'lambda*',
    'last',
    'last-pair',
    'last-stack-frame',
    'lazy-catch',
    'lchown',
    'lcm',
    'length',
    'length+',
    'let',
    'let*',
    'let*-values',
    'let-keywords',
    'let-keywords*',
    'let-optional',
    'let-optional*',
    'let-values',
    'letpar',
    'letrec',
    'link',
    'list',
    'list->array',
    'list->bitvector',
    'list->c32vector',
    'list->c64vector',
    'list->char-set',
    'list->char-set!',
    'list->f32vector',
    'list->f64vector',
    'list->integer',
    'list->s16vector',
    'list->s32vector',
    'list->s64vector',
    'list->s8vector',
    'list->stream',
    'list->string',
    'list->typed-array',
    'list->u16vector',
    'list->u32vector',
    'list->u64vector',
    'list->u8vector',
    'list->vector',
    'list->weak-vector',
    'list-cdr-ref',
    'list-cdr-set!',
    'list-copy',
    'list-head',
    'list-index',
    'list-matches',
    'list-ref',
    'list-set!',
    'list-tabulate',
    'list-tail',
    'list=',
    'list?',
    'load',
    'load-extension',
    'load-from-path',
    'local-eval',
    'localtime',
    'lock-mutex',
    'log',
    'log10',
    'log2-binary-factors',
    'logand',
    'logbit?',
    'logcount',
    'logior',
    'lognot',
    'logtest',
    'logxor',
    'lset-adjoin',
    'lset-diff+intersection',
    'lset-diff+intersection!',
    'lset-difference',
    'lset-difference!',
    'lset-intersection',
    'lset-intersection!',
    'lset-union',
    'lset-union!',
    'lset-xor',
    'lset-xor!',
    'lset<=',
    'lset=',
    'lstat',
    'macro-name',
    'macro-transformer',
    'macro-type',
    'macro?',
    'magnitude',
    'major-version',
    'make-arbiter',
    'make-array',
    'make-bitvector',
    'make-buffered-input-port',
    'make-c32vector',
    'make-c64vector',
    'make-class-object',
    'make-completion-function',
    'make-compound-condition',
    'make-condition',
    'make-condition-type',
    'make-condition-variable',
    'make-date',
    'make-doubly-weak-hash-table',
    'make-dynamic-state',
    'make-f32vector',
    'make-f64vector',
    'make-fluid',
    'make-guardian',
    'make-hash-table',
    'make-hook',
    'make-line-buffered-input-port',
    'make-list',
    'make-mutex',
    'make-object-property',
    'make-parameter',
    'make-polar',
    'make-procedure-with-setter',
    'make-q',
    'make-record-type',
    'make-rectangular',
    'make-recursive-mutex',
    'make-regexp',
    'make-s16vector',
    'make-s32vector',
    'make-s64vector',
    'make-s8vector',
    'make-shared-array',
    'make-soft-port',
    'make-stack',
    'make-stream',
    'make-string',
    'make-struct',
    'make-struct-layout',
    'make-subclass-object',
    'make-symbol',
    'make-time',
    'make-typed-array',
    'make-u16vector',
    'make-u32vector',
    'make-u64vector',
    'make-u8vector',
    'make-undefined-variable',
    'make-variable',
    'make-vector',
    'make-vtable',
    'make-vtable-vtable',
    'make-weak-key-hash-table',
    'make-weak-value-hash-table',
    'make-weak-vector',
    'malloc-stats',
    'map',
    'map!',
    'map-in-order',
    'match:count',
    'match:end',
    'match:prefix',
    'match:start',
    'match:string',
    'match:substring',
    'match:suffix',
    'max',
    'member',
    'memoized-environment',
    'memoized?',
    'memq',
    'memv',
    'merge',
    'merge!',
    'message-condition?',
    'micro-version',
    'min',
    'minor-version',
    'mkdir',
    'mknod',
    'mkstemp!',
    'mktime',
    'modified-julian-day->date',
    'modified-julian-day->time-monotonic',
    'modified-julian-day->time-tai',
    'modified-julian-day->time-utc',
    'module-use!',
    'modulo',
    'modulo-expt',
    'monitor',
    'move->fdes',
    'n-for-each-par-map',
    'n-par-for-each',
    'n-par-map',
    'nan',
    'nan?',
    'negative?',
    'newline',
    'nftw',
    'nice',
    'nil-car',
    'nil-cdr',
    'nil-cons',
    'nil-eq',
    'ninth',
    'not',
    'not-pair?',
    'null',
    'null-environment',
    'null-list?',
    'null?',
    'number->string',
    'number?',
    'numerator',
    'object->string',
    'object-properties',
    'object-property',
    'odd?',
    'open',
    'open-fdes',
    'open-file',
    'open-input-file',
    'open-input-output-pipe',
    'open-input-pipe',
    'open-input-string',
    'open-output-file',
    'open-output-pipe',
    'open-output-string',
    'open-pipe',
    'open-pipe*',
    'opendir',
    'operator?',
    'option-ref',
    'or',
    'output-port?',
    'pair-fold',
    'pair-fold-right',
    'pair-for-each',
    'pair?',
    'par-for-each',
    'par-map',
    'parallel',
    'parameterize',
    'parse-path',
    'partition',
    'partition!',
    'pclose',
    'peek-char',
    'pipe',
    'popen',
    'port->fdes',
    'port->stream',
    'port-closed?',
    'port-column',
    'port-filename',
    'port-for-each',
    'port-line',
    'port-mode',
    'port-revealed',
    'port-with-print-state',
    'port?',
    'position',
    'positive?',
    'pretty-print',
    'primitive-eval',
    'primitive-exit',
    'primitive-fork',
    'primitive-load',
    'primitive-load-path',
    'primitive-make-property',
    'primitive-move->fdes',
    'primitive-property-del!',
    'primitive-property-ref',
    'primitive-property-set!',
    'print-options-interface',
    'procedure',
    'procedure->macro',
    'procedure->memoizing-macro',
    'procedure->syntax',
    'procedure-documentation',
    'procedure-environment',
    'procedure-name',
    'procedure-properties',
    'procedure-property',
    'procedure-source',
    'procedure-with-setter?',
    'procedure?',
    'program-arguments',
    'promise?',
    'proper-list?',
    'provide',
    'provided?',
    'putenv',
    'pwd',
    'q-empty-check',
    'q-empty?',
    'q-front',
    'q-length',
    'q-pop!',
    'q-push!',
    'q-rear',
    'q-remove!',
    'q?',
    'quasiquote',
    'quit',
    'quote',
    'quotient',
    'random',
    'random:exp',
    'random:hollow-sphere!',
    'random:normal',
    'random:normal-vector!',
    'random:solid-sphere!',
    'random:uniform',
    'rational?',
    'rationalize',
    're-export',
    'read',
    'read-char',
    'read-delimited',
    'read-delimited!',
    'read-disable',
    'read-enable',
    'read-hash-extend',
    'read-line',
    'read-line!',
    'read-options',
    'read-options-interface',
    'read-set!',
    'read-string!/partial',
    'readdir',
    'readline',
    'readline-disable',
    'readline-enable',
    'readline-options',
    'readline-port',
    'readline-set!',
    'readlink',
    'real-part',
    'real?',
    'rec',
    'receive',
    'record-accessor',
    'record-constructor',
    'record-modifier',
    'record-predicate',
    'record-type-descriptor',
    'record-type-fields',
    'record-type-name',
    'record?',
    'redirect-port',
    'reduce',
    'reduce-right',
    'regexp-exec',
    'regexp-match?',
    'regexp-quote',
    'regexp-substitute',
    'regexp-substitute/global',
    'regexp?',
    'release-arbiter',
    'release-port-handle',
    'remainder',
    'remove',
    'remove!',
    'remove-hook!',
    'rename',
    'rename-file',
    'require',
    'require-extension',
    'reset-hook!',
    'resolve-interface',
    'resolve-module',
    'restricted-vector-sort!',
    'reverse',
    'reverse!',
    'reverse-bit-field',
    'reverse-list->string',
    'rewinddir',
    'rmdir',
    'rotate-bit-field',
    'round',
    'run-hook',
    's16vector',
    's16vector->list',
    's16vector-length',
    's16vector-ref',
    's16vector-set!',
    's16vector?',
    's32vector',
    's32vector->list',
    's32vector-length',
    's32vector-ref',
    's32vector-set!',
    's32vector?',
    's64vector',
    's64vector->list',
    's64vector-length',
    's64vector-ref',
    's64vector-set!',
    's64vector?',
    's8vector',
    's8vector->list',
    's8vector-length',
    's8vector-ref',
    's8vector-set!',
    's8vector?',
    'save-module-excursion',
    'scheme-report-environment',
    'scm-error',
    'search-path',
    'second',
    'seed->random-state',
    'seek',
    'select',
    'serious-condition?',
    'set!',
    'set-buffered-input-continuation?!',
    'set-car!',
    'set-cdr!',
    'set-current-dynamic-state',
    'set-current-error-port',
    'set-current-input-port',
    'set-current-module',
    'set-current-output-port',
    'set-object-procedure!',
    'set-object-properties!',
    'set-object-property!',
    'set-port-column!',
    'set-port-filename!',
    'set-port-line!',
    'set-port-revealed!',
    'set-procedure-properties!',
    'set-procedure-property!',
    'set-program-arguments',
    'set-readline-input-port!',
    'set-readline-output-port!',
    'set-readline-prompt!',
    'set-source-properties!',
    'set-source-property!',
    'set-struct-vtable-name!',
    'set-symbol-property!',
    'set-time-nanosecond!',
    'set-time-second!',
    'set-time-type!',
    'set-tm:gmtoff',
    'set-tm:hour',
    'set-tm:isdst',
    'set-tm:mday',
    'set-tm:min',
    'set-tm:mon',
    'set-tm:sec',
    'set-tm:wday',
    'set-tm:yday',
    'set-tm:year',
    'set-tm:zone',
    'set-trace-layout',
    'setegid',
    'setenv',
    'seteuid',
    'setgid',
    'setgroups',
    'setlocale',
    'setpgid',
    'setpriority',
    'setsid',
    'setter',
    'setuid',
    'setvbuf',
    'seventh',
    'shared-array-increments',
    'shared-array-offset',
    'shared-array-root',
    'signal-condition-variable',
    'simple-format',
    'sin',
    'sinh',
    'sixth',
    'sloppy-assoc',
    'sloppy-assq',
    'sloppy-assv',
    'sort',
    'sort!',
    'sort-list',
    'sort-list!',
    'sorted?',
    'source-properties',
    'source-property',
    'span',
    'span!',
    'split-at',
    'split-at!',
    'sqrt',
    'stable-sort',
    'stable-sort!',
    'stack-id',
    'stack-length',
    'stack-ref',
    'stack?',
    'start-stack',
    'stat',
    'stat:atime',
    'stat:blksize',
    'stat:blocks',
    'stat:ctime',
    'stat:dev',
    'stat:gid',
    'stat:ino',
    'stat:mode',
    'stat:mtime',
    'stat:nlink',
    'stat:perms',
    'stat:rdev',
    'stat:size',
    'stat:type',
    'stat:uid',
    'status:exit-val',
    'status:stop-sig',
    'status:term-sig',
    'stream->list',
    'stream->list&amp;length',
    'stream->reversed-list',
    'stream->reversed-list&amp;length',
    'stream->vector',
    'stream-car',
    'stream-cdr',
    'stream-fold',
    'stream-for-each',
    'stream-map',
    'stream-null?',
    'strerror',
    'strftime',
    'string',
    'string->char-set',
    'string->char-set!',
    'string->date',
    'string->keyword',
    'string->list',
    'string->number',
    'string->symbol',
    'string-any',
    'string-append',
    'string-append/shared',
    'string-capitalize',
    'string-capitalize!',
    'string-ci->symbol',
    'string-ci-hash',
    'string-ci<',
    'string-ci<=',
    'string-ci<=?',
    'string-ci<>',
    'string-ci<?',
    'string-ci=',
    'string-ci=?',
    'string-ci>',
    'string-ci>=',
    'string-ci>=?',
    'string-ci>?',
    'string-compare',
    'string-compare-ci',
    'string-concatenate',
    'string-concatenate-reverse',
    'string-concatenate-reverse/shared',
    'string-concatenate/shared',
    'string-contains',
    'string-contains-ci',
    'string-copy',
    'string-copy!',
    'string-count',
    'string-delete',
    'string-downcase',
    'string-downcase!',
    'string-drop',
    'string-drop-right',
    'string-every',
    'string-fill!',
    'string-filter',
    'string-fold',
    'string-fold-right',
    'string-for-each',
    'string-for-each-index',
    'string-hash',
    'string-hash-ci',
    'string-index',
    'string-index-right',
    'string-join',
    'string-length',
    'string-map',
    'string-map!',
    'string-match',
    'string-null?',
    'string-pad',
    'string-pad-right',
    'string-prefix-ci?',
    'string-prefix-length',
    'string-prefix-length-ci',
    'string-prefix?',
    'string-ref',
    'string-replace',
    'string-reverse',
    'string-reverse!',
    'string-rindex',
    'string-set!',
    'string-skip',
    'string-skip-right',
    'string-split',
    'string-suffix-ci?',
    'string-suffix-length',
    'string-suffix-length-ci',
    'string-suffix?',
    'string-tabulate',
    'string-take',
    'string-take-right',
    'string-titlecase',
    'string-titlecase!',
    'string-tokenize',
    'string-trim',
    'string-trim-both',
    'string-trim-right',
    'string-unfold',
    'string-unfold-right',
    'string-upcase',
    'string-upcase!',
    'string-xcopy!',
    'string<',
    'string<=',
    'string<=?',
    'string<>',
    'string<?',
    'string=',
    'string=?',
    'string>',
    'string>=',
    'string>=?',
    'string>?',
    'string?',
    'strptime',
    'struct-ref',
    'struct-set!',
    'struct-vtable',
    'struct-vtable-name',
    'struct-vtable-tag',
    'struct-vtable?',
    'struct?',
    'substring',
    'substring-fill!',
    'substring-move!',
    'substring/copy',
    'substring/read-only',
    'substring/shared',
    'subtract-duration',
    'subtract-duration!',
    'symbol->keyword',
    'symbol->string',
    'symbol-fref',
    'symbol-fset!',
    'symbol-hash',
    'symbol-interned?',
    'symbol-pref',
    'symbol-prefix-proc',
    'symbol-property',
    'symbol-property-remove!',
    'symbol-pset!',
    'symbol?',
    'symlink',
    'sync',
    'sync-q!',
    'system',
    'system*',
    'system-error-errno',
    'take',
    'take!',
    'take-right',
    'take-while',
    'take-while!',
    'tan',
    'tanh',
    'tc:depth',
    'tc:frame',
    'tc:real-depth',
    'tc:return-value',
    'tc:stack',
    'tc:type',
    'tcgetpgrp',
    'tcsetpgrp',
    'tenth',
    'third',
    'throw',
    'thunk?',
    'time-difference',
    'time-difference!',
    'time-monotonic->date',
    'time-monotonic->time-tai',
    'time-monotonic->time-tai!',
    'time-monotonic->time-utc',
    'time-monotonic->time-utc!',
    'time-nanosecond',
    'time-resolution',
    'time-second',
    'time-tai->date',
    'time-tai->julian-day',
    'time-tai->modified-julian-day',
    'time-tai->time-monotonic',
    'time-tai->time-monotonic!',
    'time-tai->time-utc',
    'time-tai->time-utc!',
    'time-type',
    'time-utc->date',
    'time-utc->julian-day',
    'time-utc->modified-julian-day',
    'time-utc->time-monotonic',
    'time-utc->time-monotonic!',
    'time-utc->time-tai',
    'time-utc->time-tai!',
    'time<=?',
    'time<?',
    'time=?',
    'time>=?',
    'time>?',
    'time?',
    'times',
    'tm:gmtoff',
    'tm:hour',
    'tm:isdst',
    'tm:mday',
    'tm:min',
    'tm:mon',
    'tm:sec',
    'tm:wday',
    'tm:yday',
    'tm:year',
    'tm:zone',
    'tmpnam',
    'tms:clock',
    'tms:cstime',
    'tms:cutime',
    'tms:stime',
    'tms:utime',
    'trace',
    'trace-at-exit',
    'trace-port',
    'trace-trap',
    'trace-until-exit',
    'trace/info',
    'trace/pid',
    'trace/real?',
    'trace/source',
    'trace/source-column',
    'trace/source-file-name',
    'trace/source-line',
    'trace/stack',
    'trace/stack-depth',
    'trace/stack-id',
    'trace/stack-real-depth',
    'trace/type',
    'transpose-array',
    'trap-disable',
    'trap-enable',
    'trap-set!',
    'traps',
    'truncate',
    'truncate-file',
    'try-arbiter',
    'try-mutex',
    'ttyname',
    'typed-array?',
    'tzset',
    'u16vector',
    'u16vector->list',
    'u16vector-length',
    'u16vector-ref',
    'u16vector-set!',
    'u16vector?',
    'u32vector',
    'u32vector->list',
    'u32vector-length',
    'u32vector-ref',
    'u32vector-set!',
    'u32vector?',
    'u64vector',
    'u64vector->list',
    'u64vector-length',
    'u64vector-ref',
    'u64vector-set!',
    'u64vector?',
    'u8vector',
    'u8vector->list',
    'u8vector-length',
    'u8vector-ref',
    'u8vector-set!',
    'u8vector?',
    'ucs-range->char-set',
    'ucs-range->char-set!',
    'umask',
    'unfold',
    'unfold-right',
    'uniform-array-read!',
    'uniform-array-write',
    'uniform-vector->list',
    'uniform-vector-length',
    'uniform-vector-read!',
    'uniform-vector-ref',
    'uniform-vector-set!',
    'uniform-vector-write',
    'uniform-vector?',
    'uninstall-trap',
    'unlink',
    'unlock-mutex',
    'unmemoize',
    'unquote',
    'unquote-splicing',
    'unread-char',
    'unread-string',
    'unsetenv',
    'untrace',
    'unzip1',
    'unzip2',
    'unzip3',
    'unzip4',
    'unzip5',
    'up',
    'use-modules',
    'use-syntax',
    'utime',
    'values',
    'variable-bound?',
    'variable-ref',
    'variable-set!',
    'variable?',
    'vector',
    'vector->list',
    'vector->stream',
    'vector-copy',
    'vector-fill!',
    'vector-length',
    'vector-move-left!',
    'vector-move-right!',
    'vector-ref',
    'vector-set!',
    'vector?',
    'version',
    'wait-condition-variable',
    'waitpid',
    'weak-key-hash-table?',
    'weak-value-hash-table?',
    'weak-vector',
    'weak-vector?',
    'while',
    'with-continuation-barrier',
    'with-dynamic-state',
    'with-error-to-file',
    'with-fluid*',
    'with-fluids',
    'with-fluids*',
    'with-input-from-file',
    'with-input-from-string',
    'with-mutex',
    'with-output-to-file',
    'with-output-to-string',
    'with-parameters*',
    'with-readline-completion-function',
    'with-throw-handler',
    'with-traps',
    'write',
    'write-char',
    'write-line',
    'write-string/partial',
    'xcons',
    'xsubstring',
    'zero?',
    'zip',
]

scheme_functions = [
    'accidental-interface::calc-alteration',
    'accidental-interface::glyph-name',
    'add-bar-glyph-print-procedure',
    'add-grace-property',
    'add-music',
    'add-music-fonts',
    'add-new-clef',
    'add-pango-fonts',
    'add-point',
    'add-quotable',
    'add-score',
    'add-stroke-glyph',
    'add-stroke-straight',
    'add-text',
    'adjust-slash-stencil',
    'alist->hash-table',
    'alist<?',
    'all-bar-numbers-visible',
    'all-repeat-counts-visible',
    'allow-volta-hook',
    'alteration->text-accidental-markup',
    'alterations-in-key',
    'ambitus::print',
    'annotate-padding',
    'annotate-spacing-spec',
    'annotate-y-interval',
    'arrow-stencil-maker',
    'attributes',
    'average',
    'backend-testing',
    'banter-chord-names',
    'bar-line::calc-break-visibility',
    'bar-line::calc-glyph-name',
    'bar-line::compound-bar-line',
    'bar-line::widen-bar-extent-on-span',
    'base-length',
    'beam-exceptions',
    'beam::align-with-broken-parts',
    'beam::get-kievan-positions',
    'beam::get-kievan-quantized-positions',
    'beam::place-broken-parts-individually',
    'beam::slope-like-broken-parts',
    'beat-structure',
    'bend::print',
    'binary-search',
    'boolean-or-symbol?',
    'box-grob-stencil',
    'box-stencil',
    'bracketify-stencil',
    'cached-file-contents',
    'calc-harmonic-pitch',
    'calculate-compound-base-beat',
    'calculate-compound-beat-grouping',
    'calculate-compound-measure-length',
    'call-after-session',
    'car<',
    'centered-stencil',
    'chain-grob-member-functions',
    'change-pitches',
    'cheap-list?',
    'check-grob-path',
    'check-quant-callbacks',
    'check-slope-callbacks',
    'circle-stencil',
    'clef-transposition-markup',
    'clef::print-modern-tab-if-set',
    'clip-system-EPSes',
    'collect-book-music-for-book',
    'collect-bookpart-for-book',
    'collect-music-aux',
    'collect-music-for-book',
    'collect-scores-for-book',
    'color?',
    'comment',
    'completize-formats',
    'compose',
    'construct-chord-elements',
    'context-defs-from-music',
    'context-mod-from-music',
    'context-spec-music',
    'convert-to-pdf',
    'convert-to-png',
    'convert-to-ps',
    'coord-rotate',
    'coord-scale',
    'coord-translate',
    'copy-repeat-chord',
    'count-list',
    'coverage:disable',
    'coverage:enable',
    'coverage:show-all',
    'create-glyph-flag',
    'cross-staff-connect',
    'cue-substitute',
    'cyclic-base-value',
    'debugf',
    'decode-byte-string',
    'def-grace-function',
    'default-auto-beam-check',
    'default-dynamic-absolute-volume',
    'default-flag',
    'default-instrument-equalizer',
    'define-bar-line',
    'define-event-function',
    'define-fonts',
    'define-markup-command',
    'define-markup-list-command',
    'define-music-function',
    'define-scheme-function',
    'define-session',
    'define-session-public',
    'define-syntax-function',
    'define-void-function',
    'degrees->radians',
    'descend-to-context',
    'determine-frets',
    'determine-split-list',
    'dir-basename',
    'display-lily-music',
    'display-music',
    'display-scheme-music',
    'dots::calc-dot-count',
    'dots::calc-staff-position',
    'dump-gc-protects',
    'dump-live-object-stats',
    'dump-stencil-as-EPS',
    'dump-stencil-as-EPS-with-bbox',
    'duration->lily-string',
    'duration-dot-factor',
    'duration-length',
    'duration-log-factor',
    'duration-of-note',
    'duration-visual',
    'duration-visual-length',
    'dynamic-text-spanner::before-line-breaking',
    'ec',
    'ellipse-radius',
    'ellipse-stencil',
    'empty-music',
    'entity',
    'eo',
    'eoc',
    'eps-file->stencil',
    'ergonomic-simple-format',
    'eval-carefully',
    'event-cause',
    'event-chord-notes',
    'event-chord-pitches',
    'event-class-cons',
    'extract-music',
    'extract-named-music',
    'extract-typed-music',
    'filtered-map',
    'find-child',
    'find-child-named',
    'find-pitch-entry',
    'fingering::calc-text',
    'first-assoc',
    'first-bar-number-invisible',
    'first-bar-number-invisible-and-no-parenthesized-bar-numbers',
    'first-bar-number-invisible-save-broken-bars',
    'first-member',
    'flatten-alist',
    'flatten-list',
    'fold-some-music',
    'font-name-split',
    'font-name-style',
    'for-some-music',
    'format-bass-figure',
    'format-compound-time',
    'format-mark-alphabet',
    'format-mark-barnumbers',
    'format-mark-box-alphabet',
    'format-mark-box-barnumbers',
    'format-mark-box-letters',
    'format-mark-box-numbers',
    'format-mark-circle-alphabet',
    'format-mark-circle-barnumbers',
    'format-mark-circle-letters',
    'format-mark-circle-numbers',
    'format-mark-letters',
    'format-mark-numbers',
    'format-metronome-markup',
    'fraction->moment',
    'fraction?',
    'fret->pitch',
    'fret-board::calc-stencil',
    'fret-letter-tablature-format',
    'fret-number-tablature-format',
    'fret-number-tablature-format-banjo',
    'fret-parse-terse-definition-string',
    'function-chain',
    'get-chord-shape',
    'get-editor-command',
    'get-woodwind-key-list',
    'glissando::calc-tab-extra-dy',
    'glissando::draw-tab-glissando',
    'grace-spacing::calc-shortest-duration',
    'grob-interpret-markup',
    'grob-list?',
    'grob::has-interface',
    'grob::is-live?',
    'grob::unpure-Y-extent-from-stencil',
    'gui-main',
    'gulp-file',
    'hairpin::calc-grow-direction',
    'hash-table->alist',
    'horizontal-slash-interval',
    'identifiers-doc-string',
    'ignatzek-chord-names',
    'index?',
    'internal-add-text-replacements',
    'interpret-markup-list',
    'interval-bound',
    'interval-center',
    'interval-empty?',
    'interval-index',
    'interval-intersection',
    'interval-length',
    'interval-sane?',
    'interval-scale',
    'interval-union',
    'interval-widen',
    'invalidate-alterations',
    'is-absolute?',
    'jazz-chord-names',
    'key-signature-interface::alteration-positions',
    'laissez-vibrer::print',
    'layout-extract-page-properties',
    'layout-line-thickness',
    'layout-set-absolute-staff-size',
    'layout-set-absolute-staff-size-in-module',
    'layout-set-staff-size',
    'lilypond-all',
    'lilypond-main',
    'lilypond-version',
    'list-insert-separator',
    'list-join',
    'lookup-markup-command',
    'lookup-markup-list-command',
    'ly-getcwd',
    'ly:accidental-interface::height',
    'ly:accidental-interface::horizontal-skylines',
    'ly:accidental-interface::print',
    'ly:accidental-interface::pure-height',
    'ly:accidental-interface::width',
    'ly:accidental-placement::calc-positioning-done',
    'ly:add-context-mod',
    'ly:add-file-name-alist',
    'ly:add-interface',
    'ly:add-listener',
    'ly:add-option',
    'ly:align-interface::align-to-ideal-distances',
    'ly:align-interface::align-to-minimum-distances',
    'ly:alist-ci<?',
    'ly:alist<?',
    'ly:all-grob-interfaces',
    'ly:all-options',
    'ly:all-output-backend-commands',
    'ly:all-stencil-commands',
    'ly:all-stencil-expressions',
    'ly:apply-context-iterator::constructor',
    'ly:arpeggio::brew-chord-bracket',
    'ly:arpeggio::calc-positions',
    'ly:arpeggio::print',
    'ly:arpeggio::pure-height',
    'ly:arpeggio::width',
    'ly:assoc-get',
    'ly:auto-change-iterator::constructor',
    'ly:axis-group-interface::add-element',
    'ly:axis-group-interface::adjacent-pure-heights',
    'ly:axis-group-interface::calc-pure-relevant-grobs',
    'ly:axis-group-interface::calc-pure-staff-staff-spacing',
    'ly:axis-group-interface::calc-pure-y-common',
    'ly:axis-group-interface::calc-skylines',
    'ly:axis-group-interface::calc-staff-staff-spacing',
    'ly:axis-group-interface::calc-x-common',
    'ly:axis-group-interface::calc-y-common',
    'ly:axis-group-interface::combine-skylines',
    'ly:axis-group-interface::cross-staff',
    'ly:axis-group-interface::height',
    'ly:axis-group-interface::print',
    'ly:axis-group-interface::pure-height',
    'ly:axis-group-interface::width',
    'ly:balloon-interface::print',
    'ly:balloon-interface::print-spanner',
    'ly:bar-check-iterator::constructor',
    'ly:bar-line::calc-anchor',
    'ly:bar-line::calc-bar-extent',
    'ly:bar-line::print',
    'ly:basic-progress',
    'ly:beam-score-count',
    'ly:beam::calc-beam-gap',
    'ly:beam::calc-beam-segments',
    'ly:beam::calc-beaming',
    'ly:beam::calc-cross-staff',
    'ly:beam::calc-direction',
    'ly:beam::calc-minimum-length',
    'ly:beam::calc-normal-stems',
    'ly:beam::calc-springs-and-rods',
    'ly:beam::calc-stem-shorten',
    'ly:beam::calc-x-positions',
    'ly:beam::print',
    'ly:beam::quanting',
    'ly:beam::set-stem-lengths',
    'ly:book-add-bookpart!',
    'ly:book-add-score!',
    'ly:book-book-parts',
    'ly:book-header',
    'ly:book-paper',
    'ly:book-process',
    'ly:book-process-to-systems',
    'ly:book-scores',
    'ly:book-set-header!',
    'ly:book?',
    'ly:box?',
    'ly:bp',
    'ly:bracket',
    'ly:break-alignable-interface::self-align-callback',
    'ly:break-aligned-interface::calc-average-anchor',
    'ly:break-aligned-interface::calc-break-visibility',
    'ly:break-aligned-interface::calc-extent-aligned-anchor',
    'ly:break-alignment-interface::calc-positioning-done',
    'ly:breathing-sign::offset-callback',
    'ly:broadcast',
    'ly:camel-case->lisp-identifier',
    'ly:chain-assoc-get',
    'ly:change-iterator::constructor',
    'ly:char-ci<?',
    'ly:char-generic-<?',
    'ly:char<?',
    'ly:check-expected-warnings',
    'ly:chord-name::after-line-breaking',
    'ly:chord-tremolo-iterator::constructor',
    'ly:clef::calc-glyph-name',
    'ly:clef::print',
    'ly:cluster-beacon::height',
    'ly:cluster::calc-cross-staff',
    'ly:cluster::print',
    'ly:cm',
    'ly:command-line-code',
    'ly:command-line-options',
    'ly:connect-dispatchers',
    'ly:context-current-moment',
    'ly:context-def-lookup',
    'ly:context-def-modify',
    'ly:context-def?',
    'ly:context-event-source',
    'ly:context-events-below',
    'ly:context-find',
    'ly:context-grob-definition',
    'ly:context-id',
    'ly:context-mod-apply!',
    'ly:context-mod?',
    'ly:context-name',
    'ly:context-now',
    'ly:context-parent',
    'ly:context-property',
    'ly:context-property-where-defined',
    'ly:context-pushpop-property',
    'ly:context-set-property!',
    'ly:context-specced-music-iterator::constructor',
    'ly:context-unset-property',
    'ly:context?',
    'ly:custos::print',
    'ly:debug',
    'ly:default-scale',
    'ly:dimension?',
    'ly:dir?',
    'ly:dispatcher?',
    'ly:dot-column::calc-positioning-done',
    'ly:dots::print',
    'ly:dummy-input-location',
    'ly:duration->string',
    'ly:duration-dot-count',
    'ly:duration-factor',
    'ly:duration-length',
    'ly:duration-log',
    'ly:duration-scale',
    'ly:duration<?',
    'ly:duration?',
    'ly:effective-prefix',
    'ly:enclosing-bracket::print',
    'ly:enclosing-bracket::width',
    'ly:encode-string-for-pdf',
    'ly:engraver-announce-end-grob',
    'ly:engraver-make-grob',
    'ly:error',
    'ly:eval-simple-closure',
    'ly:event-chord-iterator::constructor',
    'ly:event-deep-copy',
    'ly:event-property',
    'ly:event-set-property!',
    'ly:event?',
    'ly:exit',
    'ly:expand-environment',
    'ly:expect-warning',
    'ly:figured-bass-continuation::center-on-figures',
    'ly:figured-bass-continuation::print',
    'ly:find-file',
    'ly:fingering-column::calc-positioning-done',
    'ly:flag::calc-x-offset',
    'ly:flag::calc-y-offset',
    'ly:flag::glyph-name',
    'ly:flag::print',
    'ly:flag::pure-calc-y-offset',
    'ly:flag::stencil',
    'ly:flag::width',
    'ly:font-config-add-directory',
    'ly:font-config-add-font',
    'ly:font-config-display-fonts',
    'ly:font-config-get-font-file',
    'ly:font-design-size',
    'ly:font-file-name',
    'ly:font-get-glyph',
    'ly:font-glyph-name-to-charcode',
    'ly:font-glyph-name-to-index',
    'ly:font-index-to-charcode',
    'ly:font-magnification',
    'ly:font-metric?',
    'ly:font-name',
    'ly:font-sub-fonts',
    'ly:format',
    'ly:format-output',
    'ly:get-all-function-documentation',
    'ly:get-all-translators',
    'ly:get-context-mods',
    'ly:get-option',
    'ly:get-spacing-spec',
    'ly:get-undead',
    'ly:gettext',
    'ly:grace-iterator::constructor',
    'ly:grace-music::start-callback',
    'ly:grid-line-interface::print',
    'ly:grid-line-interface::width',
    'ly:grob-alist-chain',
    'ly:grob-array->list',
    'ly:grob-array-length',
    'ly:grob-array-ref',
    'ly:grob-array?',
    'ly:grob-basic-properties',
    'ly:grob-chain-callback',
    'ly:grob-common-refpoint',
    'ly:grob-common-refpoint-of-array',
    'ly:grob-default-font',
    'ly:grob-extent',
    'ly:grob-get-vertical-axis-group-index',
    'ly:grob-interfaces',
    'ly:grob-layout',
    'ly:grob-object',
    'ly:grob-original',
    'ly:grob-parent',
    'ly:grob-pq<?',
    'ly:grob-properties',
    'ly:grob-property',
    'ly:grob-property-data',
    'ly:grob-pure-height',
    'ly:grob-pure-property',
    'ly:grob-relative-coordinate',
    'ly:grob-robust-relative-extent',
    'ly:grob-script-priority-less',
    'ly:grob-set-nested-property!',
    'ly:grob-set-object!',
    'ly:grob-set-parent!',
    'ly:grob-set-property!',
    'ly:grob-staff-position',
    'ly:grob-suicide!',
    'ly:grob-system',
    'ly:grob-translate-axis!',
    'ly:grob-vertical<?',
    'ly:grob::horizontal-skylines-from-element-stencils',
    'ly:grob::horizontal-skylines-from-stencil',
    'ly:grob::pure-horizontal-skylines-from-element-stencils',
    'ly:grob::pure-simple-horizontal-skylines-from-extents',
    'ly:grob::pure-simple-vertical-skylines-from-extents',
    'ly:grob::pure-vertical-skylines-from-element-stencils',
    'ly:grob::stencil-height',
    'ly:grob::vertical-skylines-from-element-stencils',
    'ly:grob::vertical-skylines-from-stencil',
    'ly:grob?',
    'ly:gulp-file',
    'ly:hairpin::broken-bound-padding',
    'ly:hairpin::print',
    'ly:hairpin::pure-height',
    'ly:hara-kiri-group-spanner::calc-skylines',
    'ly:hara-kiri-group-spanner::force-hara-kiri-callback',
    'ly:hara-kiri-group-spanner::pure-height',
    'ly:hara-kiri-group-spanner::y-extent',
    'ly:hash-table-keys',
    'ly:horizontal-bracket::print',
    'ly:in-event-class?',
    'ly:inch',
    'ly:inexact->string',
    'ly:input-both-locations',
    'ly:input-file-line-char-column',
    'ly:input-location?',
    'ly:input-message',
    'ly:input-warning',
    'ly:interpret-music-expression',
    'ly:interpret-stencil-expression',
    'ly:intlog2',
    'ly:item-break-dir',
    'ly:item?',
    'ly:iterator?',
    'ly:key-signature-interface::print',
    'ly:kievan-ligature::print',
    'ly:ledger-line-spanner::print',
    'ly:ledger-line-spanner::set-spacing-rods',
    'ly:lexer-keywords',
    'ly:lily-lexer?',
    'ly:lily-parser?',
    'ly:line-spanner::calc-cross-staff',
    'ly:line-spanner::calc-left-bound-info',
    'ly:line-spanner::calc-left-bound-info-and-text',
    'ly:line-spanner::calc-right-bound-info',
    'ly:line-spanner::print',
    'ly:list->offsets',
    'ly:listened-event-class?',
    'ly:listened-event-types',
    'ly:listener?',
    'ly:load',
    'ly:lyric-combine-music-iterator::constructor',
    'ly:lyric-extender::print',
    'ly:lyric-hyphen::print',
    'ly:lyric-hyphen::set-spacing-rods',
    'ly:make-book',
    'ly:make-book-part',
    'ly:make-context-mod',
    'ly:make-dispatcher',
    'ly:make-duration',
    'ly:make-event-class',
    'ly:make-global-context',
    'ly:make-global-translator',
    'ly:make-listener',
    'ly:make-moment',
    'ly:make-music',
    'ly:make-music-function',
    'ly:make-music-relative!',
    'ly:make-output-def',
    'ly:make-page-label-marker',
    'ly:make-page-permission-marker',
    'ly:make-pango-description-string',
    'ly:make-paper-outputter',
    'ly:make-pitch',
    'ly:make-prob',
    'ly:make-scale',
    'ly:make-score',
    'ly:make-simple-closure',
    'ly:make-spring',
    'ly:make-stencil',
    'ly:make-stream-event',
    'ly:make-undead',
    'ly:make-unpure-pure-container',
    'ly:measure-grouping::print',
    'ly:mensural-ligature::brew-ligature-primitive',
    'ly:mensural-ligature::print',
    'ly:message',
    'ly:minimal-breaking',
    'ly:mm',
    'ly:module->alist',
    'ly:module-copy',
    'ly:modules-lookup',
    'ly:moment->string',
    'ly:moment-add',
    'ly:moment-div',
    'ly:moment-grace',
    'ly:moment-grace-denominator',
    'ly:moment-grace-numerator',
    'ly:moment-main',
    'ly:moment-main-denominator',
    'ly:moment-main-numerator',
    'ly:moment-mod',
    'ly:moment-mul',
    'ly:moment-sub',
    'ly:moment<?',
    'ly:moment?',
    'ly:multi-measure-rest::height',
    'ly:multi-measure-rest::percent',
    'ly:multi-measure-rest::print',
    'ly:multi-measure-rest::set-spacing-rods',
    'ly:multi-measure-rest::set-text-rods',
    'ly:music-compress',
    'ly:music-deep-copy',
    'ly:music-duration-compress',
    'ly:music-duration-length',
    'ly:music-function-extract',
    'ly:music-function-signature',
    'ly:music-function?',
    'ly:music-length',
    'ly:music-list?',
    'ly:music-message',
    'ly:music-mutable-properties',
    'ly:music-output?',
    'ly:music-property',
    'ly:music-sequence::cumulative-length-callback',
    'ly:music-sequence::event-chord-length-callback',
    'ly:music-sequence::event-chord-relative-callback',
    'ly:music-sequence::first-start-callback',
    'ly:music-sequence::maximum-length-callback',
    'ly:music-sequence::minimum-start-callback',
    'ly:music-sequence::simultaneous-relative-callback',
    'ly:music-set-property!',
    'ly:music-transpose',
    'ly:music-warning',
    'ly:music-wrapper-iterator::constructor',
    'ly:music-wrapper::length-callback',
    'ly:music-wrapper::start-callback',
    'ly:music?',
    'ly:note-collision-interface::calc-positioning-done',
    'ly:note-column-accidentals',
    'ly:note-column-dot-column',
    'ly:note-head::calc-stem-attachment',
    'ly:note-head::include-ledger-line-height',
    'ly:note-head::print',
    'ly:note-head::stem-attachment',
    'ly:note-head::stem-x-shift',
    'ly:number->string',
    'ly:number-pair->string',
    'ly:one-line-breaking',
    'ly:optimal-breaking',
    'ly:option-usage',
    'ly:otf->cff',
    'ly:otf-font-glyph-info',
    'ly:otf-font-table-data',
    'ly:otf-font?',
    'ly:otf-glyph-count',
    'ly:otf-glyph-list',
    'ly:ottava-bracket::print',
    'ly:output-def-clone',
    'ly:output-def-lookup',
    'ly:output-def-parent',
    'ly:output-def-scope',
    'ly:output-def-set-variable!',
    'ly:output-def?',
    'ly:output-description',
    'ly:output-find-context-def',
    'ly:output-formats',
    'ly:outputter-close',
    'ly:outputter-dump-stencil',
    'ly:outputter-dump-string',
    'ly:outputter-module',
    'ly:outputter-output-scheme',
    'ly:outputter-port',
    'ly:page-marker?',
    'ly:page-turn-breaking',
    'ly:pango-font-physical-fonts',
    'ly:pango-font?',
    'ly:paper-book-header',
    'ly:paper-book-pages',
    'ly:paper-book-paper',
    'ly:paper-book-performances',
    'ly:paper-book-scopes',
    'ly:paper-book-systems',
    'ly:paper-book?',
    'ly:paper-column::before-line-breaking',
    'ly:paper-column::print',
    'ly:paper-fonts',
    'ly:paper-get-font',
    'ly:paper-get-number',
    'ly:paper-outputscale',
    'ly:paper-score-paper-systems',
    'ly:paper-system-minimum-distance',
    'ly:paper-system?',
    'ly:parse-file',
    'ly:parse-string-expression',
    'ly:parsed-undead-list!',
    'ly:parser-clear-error',
    'ly:parser-clone',
    'ly:parser-define!',
    'ly:parser-error',
    'ly:parser-has-error?',
    'ly:parser-include-string',
    'ly:parser-lexer',
    'ly:parser-lookup',
    'ly:parser-output-name',
    'ly:parser-parse-string',
    'ly:parser-set-note-names',
    'ly:part-combine-iterator::constructor',
    'ly:partial-iterator::constructor',
    'ly:percent-repeat-item-interface::beat-slash',
    'ly:percent-repeat-item-interface::double-percent',
    'ly:percent-repeat-iterator::constructor',
    'ly:performance-write',
    'ly:pfb->pfa',
    'ly:piano-pedal-bracket::print',
    'ly:pitch-alteration',
    'ly:pitch-diff',
    'ly:pitch-negate',
    'ly:pitch-notename',
    'ly:pitch-octave',
    'ly:pitch-quartertones',
    'ly:pitch-semitones',
    'ly:pitch-steps',
    'ly:pitch-tones',
    'ly:pitch-transpose',
    'ly:pitch<?',
    'ly:pitch?',
    'ly:pointer-group-interface::add-grob',
    'ly:pop-property-iterator::constructor',
    'ly:position-on-line?',
    'ly:prob-immutable-properties',
    'ly:prob-mutable-properties',
    'ly:prob-property',
    'ly:prob-property?',
    'ly:prob-set-property!',
    'ly:prob-type?',
    'ly:prob?',
    'ly:programming-error',
    'ly:progress',
    'ly:property-iterator::constructor',
    'ly:property-lookup-stats',
    'ly:property-unset-iterator::constructor',
    'ly:protects',
    'ly:pt',
    'ly:pure-from-neighbor-interface::calc-pure-relevant-grobs',
    'ly:push-property-iterator::constructor',
    'ly:quote-iterator::constructor',
    'ly:register-stencil-expression',
    'ly:relative-group-extent',
    'ly:relative-octave-check::relative-callback',
    'ly:relative-octave-music::no-relative-callback',
    'ly:relative-octave-music::relative-callback',
    'ly:repeated-music::first-start',
    'ly:repeated-music::folded-music-length',
    'ly:repeated-music::unfolded-music-length',
    'ly:repeated-music::volta-music-length',
    'ly:reset-all-fonts',
    'ly:rest-collision::calc-positioning-done',
    'ly:rest::calc-cross-staff',
    'ly:rest::height',
    'ly:rest::print',
    'ly:rest::pure-height',
    'ly:rest::width',
    'ly:rest::y-offset-callback',
    'ly:rhythmic-music-iterator::constructor',
    'ly:round-filled-box',
    'ly:round-filled-polygon',
    'ly:run-translator',
    'ly:score-add-output-def!',
    'ly:score-embedded-format',
    'ly:score-error?',
    'ly:score-header',
    'ly:score-music',
    'ly:score-output-defs',
    'ly:score-set-header!',
    'ly:score?',
    'ly:script-column::before-line-breaking',
    'ly:script-column::row-before-line-breaking',
    'ly:script-interface::calc-cross-staff',
    'ly:script-interface::calc-direction',
    'ly:script-interface::calc-positioning-done',
    'ly:script-interface::print',
    'ly:self-alignment-interface::aligned-on-x-parent',
    'ly:self-alignment-interface::centered-on-x-parent',
    'ly:self-alignment-interface::centered-on-y-parent',
    'ly:self-alignment-interface::pure-y-aligned-on-self',
    'ly:self-alignment-interface::x-aligned-on-self',
    'ly:self-alignment-interface::x-centered-on-y-parent',
    'ly:self-alignment-interface::y-aligned-on-self',
    'ly:semi-tie-column::calc-head-direction',
    'ly:semi-tie-column::calc-positioning-done',
    'ly:semi-tie::calc-control-points',
    'ly:separation-item::calc-skylines',
    'ly:sequential-iterator::constructor',
    'ly:set-default-scale',
    'ly:set-grob-modification-callback',
    'ly:set-middle-C!',
    'ly:set-option',
    'ly:set-property-cache-callback',
    'ly:side-position-interface::calc-cross-staff',
    'ly:side-position-interface::move-to-extremal-staff',
    'ly:side-position-interface::pure-y-aligned-side',
    'ly:side-position-interface::x-aligned-side',
    'ly:side-position-interface::y-aligned-side',
    'ly:simple-closure?',
    'ly:simple-music-iterator::constructor',
    'ly:simplify-scheme',
    'ly:simultaneous-music-iterator::constructor',
    'ly:skyline-empty?',
    'ly:skyline-pair::skyline',
    'ly:skyline-pair?',
    'ly:skyline::get-height',
    'ly:skyline::get-max-height-position',
    'ly:skyline::get-touching-point',
    'ly:skyline?',
    'ly:slur-score-count',
    'ly:slur::calc-control-points',
    'ly:slur::calc-cross-staff',
    'ly:slur::calc-direction',
    'ly:slur::height',
    'ly:slur::print',
    'ly:slur::pure-height',
    'ly:slur::vertical-skylines',
    'ly:smob-protects',
    'ly:solve-spring-rod-problem',
    'ly:source-file?',
    'ly:spacing-spanner::calc-common-shortest-duration',
    'ly:spacing-spanner::set-springs',
    'ly:span-bar::before-line-breaking',
    'ly:span-bar::calc-glyph-name',
    'ly:span-bar::print',
    'ly:span-bar::width',
    'ly:spanner-bound',
    'ly:spanner-broken-into',
    'ly:spanner-set-bound!',
    'ly:spanner::calc-normalized-endpoints',
    'ly:spanner::kill-zero-spanned-time',
    'ly:spanner::set-spacing-rods',
    'ly:spanner?',
    'ly:spawn',
    'ly:spring-set-inverse-compress-strength!',
    'ly:spring-set-inverse-stretch-strength!',
    'ly:spring?',
    'ly:staff-symbol-line-thickness',
    'ly:staff-symbol-referencer::callback',
    'ly:staff-symbol-staff-radius',
    'ly:staff-symbol-staff-space',
    'ly:staff-symbol::height',
    'ly:staff-symbol::print',
    'ly:start-environment',
    'ly:stderr-redirect',
    'ly:stem-tremolo::calc-direction',
    'ly:stem-tremolo::calc-slope',
    'ly:stem-tremolo::calc-style',
    'ly:stem-tremolo::calc-width',
    'ly:stem-tremolo::calc-y-offset',
    'ly:stem-tremolo::print',
    'ly:stem-tremolo::pure-calc-y-offset',
    'ly:stem-tremolo::pure-height',
    'ly:stem-tremolo::width',
    'ly:stem::calc-cross-staff',
    'ly:stem::calc-default-direction',
    'ly:stem::calc-direction',
    'ly:stem::calc-length',
    'ly:stem::calc-positioning-done',
    'ly:stem::calc-stem-begin-position',
    'ly:stem::calc-stem-info',
    'ly:stem::height',
    'ly:stem::offset-callback',
    'ly:stem::print',
    'ly:stem::pure-calc-length',
    'ly:stem::pure-calc-stem-begin-position',
    'ly:stem::pure-height',
    'ly:stem::width',
    'ly:stencil-add',
    'ly:stencil-aligned-to',
    'ly:stencil-combine-at-edge',
    'ly:stencil-empty?',
    'ly:stencil-expr',
    'ly:stencil-extent',
    'ly:stencil-fonts',
    'ly:stencil-in-color',
    'ly:stencil-rotate',
    'ly:stencil-rotate-absolute',
    'ly:stencil-scale',
    'ly:stencil-stack',
    'ly:stencil-translate',
    'ly:stencil-translate-axis',
    'ly:stencil?',
    'ly:stream-event?',
    'ly:string-ci<?',
    'ly:string-generic-<?',
    'ly:string-percent-encode',
    'ly:string-substitute',
    'ly:string<?',
    'ly:sustain-pedal::print',
    'ly:symbol-ci<?',
    'ly:symbol<?',
    'ly:system',
    'ly:system-font-load',
    'ly:system-start-delimiter::print',
    'ly:system::calc-pure-height',
    'ly:system::calc-pure-relevant-grobs',
    'ly:system::footnotes-after-line-breaking',
    'ly:system::footnotes-before-line-breaking',
    'ly:system::get-spaceable-staves',
    'ly:system::get-staves',
    'ly:system::get-vertical-alignment',
    'ly:system::height',
    'ly:system::vertical-skyline-elements',
    'ly:text-interface::interpret-markup',
    'ly:text-interface::print',
    'ly:tie-column::before-line-breaking',
    'ly:tie-column::calc-positioning-done',
    'ly:tie::calc-control-points',
    'ly:tie::calc-direction',
    'ly:tie::print',
    'ly:time-signature::print',
    'ly:translate-cpp-warning-scheme',
    'ly:translator-context',
    'ly:translator-description',
    'ly:translator-group?',
    'ly:translator-name',
    'ly:translator?',
    'ly:transpose-key-alist',
    'ly:truncate-list!',
    'ly:ttf->pfa',
    'ly:ttf-ps-name',
    'ly:tuplet-bracket::calc-connect-to-neighbors',
    'ly:tuplet-bracket::calc-cross-staff',
    'ly:tuplet-bracket::calc-direction',
    'ly:tuplet-bracket::calc-positions',
    'ly:tuplet-bracket::calc-x-positions',
    'ly:tuplet-bracket::print',
    'ly:tuplet-iterator::constructor',
    'ly:tuplet-number::calc-cross-staff',
    'ly:tuplet-number::calc-x-offset',
    'ly:tuplet-number::calc-y-offset',
    'ly:tuplet-number::print',
    'ly:undead?',
    'ly:unfolded-repeat-iterator::constructor',
    'ly:unit',
    'ly:unpure-pure-container-pure-part',
    'ly:unpure-pure-container-unpure-part',
    'ly:unpure-pure-container?',
    'ly:usage',
    'ly:vaticana-ligature::brew-ligature-primitive',
    'ly:vaticana-ligature::print',
    'ly:verbose-output?',
    'ly:version',
    'ly:volta-bracket-interface::print',
    'ly:volta-bracket::calc-shorten-pair',
    'ly:volta-repeat-iterator::constructor',
    'ly:warning',
    'ly:warning-located',
    'ly:wide-char->utf-8',
    'lyric-text::print',
    'magnification->font-size',
    'magstep',
    'make-apply-context',
    'make-articulation',
    'make-autochange-music',
    'make-century-schoolbook-tree',
    'make-circle-stencil',
    'make-clef-set',
    'make-connected-path-stencil',
    'make-cue-clef-set',
    'make-cue-clef-unset',
    'make-duration-of-length',
    'make-ellipse-stencil',
    'make-engraver',
    'make-event-chord',
    'make-filled-box-stencil',
    'make-grace-music',
    'make-graceless-rhythmic-location',
    'make-grob-property-override',
    'make-grob-property-revert',
    'make-grob-property-set',
    'make-harmonic',
    'make-line-stencil',
    'make-lyric-event',
    'make-markup',
    'make-modal-inverter',
    'make-modal-transposer',
    'make-multi-measure-rest',
    'make-music',
    'make-non-relative-music',
    'make-oval-stencil',
    'make-pango-font-tree',
    'make-part-combine-music',
    'make-partial-ellipse-stencil',
    'make-property-set',
    'make-property-unset',
    'make-ps-images',
    'make-relative',
    'make-repeat',
    'make-repeated-music',
    'make-rhythmic-location',
    'make-safe-lilypond-module',
    'make-sequential-music',
    'make-setting',
    'make-simultaneous-music',
    'make-skip-music',
    'make-span-event',
    'make-stencil-boxer',
    'make-stencil-circler',
    'make-stream-event',
    'make-type-checker',
    'make-voice-props-override',
    'make-voice-props-revert',
    'make-voice-props-set',
    'map-selected-alist-keys',
    'map-some-music',
    'markup',
    'markup->lily-string',
    'markup->string',
    'markup-command-list?',
    'markup-command-signature-ref',
    'markup-list?',
    'memoize-clef-names',
    'mensural-flag',
    'metronome-markup',
    'midi-program',
    'mmrest-of-length',
    'modern-straight-flag',
    'modified-font-metric-font-scaling',
    'moment->fraction',
    'moment-min',
    'moment-pair?',
    'mtrace:dump-results',
    'mtrace:start-trace',
    'mtrace:stop-trace',
    'music->lily-string',
    'music->make-music',
    'music-clone',
    'music-elements',
    'music-filter',
    'music-has-property?',
    'music-has-type',
    'music-invert',
    'music-is-of-type?',
    'music-map',
    'music-name?',
    'music-property-value?',
    'music-property?',
    'music-separator?',
    'music-to-musicxml',
    'music-to-xml',
    'myd',
    'neo-modern-accidental-rule',
    'no-flag',
    'normal-flag',
    'note-head::brew-ez-stencil',
    'note-head::calc-duration-log',
    'note-head::calc-glyph-name',
    'note-head::calc-kievan-duration-log',
    'note-name->german-markup',
    'note-name->lily-string',
    'note-name->markup',
    'note-names-language',
    'note-to-cluster',
    'notes-to-clusters',
    'number-list?',
    'number-or-grob?',
    'number-or-markup?',
    'number-or-pair?',
    'number-or-string?',
    'number-pair?',
    'numbered-footnotes',
    'object-type',
    'object-type-name',
    'octave->lily-string',
    'offset-add',
    'offset-flip-y',
    'offset-fret',
    'offset-scale',
    'old-straight-flag',
    'only-if-beamed',
    'ordered-cons',
    'output-classic-framework',
    'output-file',
    'output-framework',
    'output-preview-framework',
    'output-scopes',
    'outside-staff::pure-Y-offset',
    'oval-stencil',
    'override-head-style',
    'override-time-signature-setting',
    'page-stencil',
    'pango-pf-file-name',
    'pango-pf-font-name',
    'pango-pf-fontindex',
    'paper-system-annotate',
    'paper-system-annotate-last',
    'paper-system-extent',
    'paper-system-layout',
    'paper-system-staff-extents',
    'paper-system-stencil',
    'paper-system-system-grob',
    'paper-system-title?',
    'parentheses-item::calc-angled-bracket-stencils',
    'parentheses-item::calc-parenthesis-stencils',
    'parentheses-item::print',
    'parenthesize-stencil',
    'parse-terse-string',
    'percussion?',
    'pitch-invert',
    'pitch-of-note',
    'polar->rectangular',
    'postprocess-output',
    'postscript->pdf',
    'postscript->png',
    'prepend-alist-chain',
    'print',
    'print-book-with-defaults',
    'print-book-with-defaults-as-systems',
    'print-circled-text-callback',
    'print-keys',
    'print-keys-verbose',
    'process-music',
    'property-value',
    'ps-embed-cff',
    'ps-font-command',
    'ps-page-count',
    'pure-chain-offset-callback',
    'pure-from-neighbor-interface::account-for-span-bar',
    'pure-from-neighbor-interface::extra-spacing-height',
    'pure-from-neighbor-interface::extra-spacing-height-at-beginning-of-line',
    'pure-from-neighbor-interface::extra-spacing-height-including-staff',
    'pure-from-neighbor-interface::pure-height',
    'ratio->fret',
    'ratio->pitch',
    'read-lily-expression',
    'recording-group-emulate',
    'relevant-book-systems',
    'relevant-dump-systems',
    'remove-grace-property',
    'remove-stencil-warnings',
    'repeat-tie::handle-tab-note-head',
    'retrieve-glyph-flag',
    'retrograde-music',
    'reverse-interval',
    'revert-head-style',
    'revert-time-signature-setting',
    'rgb-color',
    'rhythmic-location->file-string',
    'rhythmic-location->string',
    'rhythmic-location<?',
    'rhythmic-location>?',
    'rhythmic-location?',
    'robust-bar-number-function',
    'rounded-box-stencil',
    'safe-car',
    'safe-last',
    'sanitize-command-option',
    'scale-layout',
    'scheme?',
    'scm->string',
    'scorify-music',
    'script-interface::calc-x-offset',
    'script-or-side-position-cross-staff',
    'search-executable',
    'search-gs',
    'select-head-glyph',
    'semi-tie::calc-cross-staff',
    'sequential-music-to-chord-exceptions',
    'session-initialize',
    'set-accidental-style',
    'set-accidentals-properties',
    'set-default-paper-size',
    'set-global-staff-size',
    'set-paper-dimension-variables',
    'set-paper-size',
    'shift-duration-log',
    'shift-one-duration-log',
    'shift-right-at-line-begin',
    'skip->rest',
    'skip-of-length',
    'skyline-pair-and-non-empty?',
    'skyline-pair::empty?',
    'slur::draw-tab-slur',
    'space-lines',
    'span-bar::compound-bar-line',
    'span-bar::notify-grobs-of-my-existence',
    'split-list-by-separator',
    'stack-lines',
    'stack-stencil-line',
    'stack-stencils',
    'stack-stencils-padding-list',
    'stderr',
    'stem-stub::extra-spacing-height',
    'stem-stub::pure-height',
    'stem-stub::width',
    'stem-tremolo::calc-tab-width',
    'stem::calc-duration-log',
    'stem::kievan-offset-callback',
    'stencil-whiteout',
    'stencil-with-color',
    'straight-flag',
    'string-encode-integer',
    'string-endswith',
    'string-number::calc-text',
    'string-or-music?',
    'string-or-pair?',
    'string-or-symbol?',
    'string-regexp-substitute',
    'string-startswith',
    'stroke-finger::calc-text',
    'style-note-heads',
    'symbol-concatenate',
    'symbol-footnotes',
    'symbol-key<?',
    'symbol-list-or-music?',
    'symbol-list-or-symbol?',
    'symbol-list?',
    'symbol-or-boolean?',
    'symbol<?',
    'symmetric-interval',
    'system-clipped-x-extent',
    'system-start-text::calc-x-offset',
    'system-start-text::calc-y-offset',
    'system-start-text::print',
    'tab-note-head::calc-glyph-name',
    'tab-note-head::print',
    'tab-note-head::whiteout-if-style-set',
    'tablature-position-on-lines',
    'tabvoice::draw-double-stem-for-half-notes',
    'tabvoice::make-double-stem-width-for-half-notes',
    'teaching-accidental-rule',
    'tie::handle-tab-note-head',
    'tuplet-number::calc-denominator-text',
    'tuplet-number::calc-direction',
    'tuplet-number::calc-fraction-text',
    'type-name',
    'ugh-compat-double-plus-new-chord->markup',
    'unfold-repeats',
    'uniq-list',
    'uniqued-alist',
    'vector-for-each',
    'version-not-seen-message',
    'voicify-music',
    'void?',
    'volta-bracket-interface::pure-height',
    'volta-bracket::calc-hook-visibility',
    'warning',
    'write-me',
    'write-performances-midis',
    'write-system-signature',
    'write-system-signatures',
]

scheme_variables = [
    'accidental-interface::height',
    'all-backend-properties',
    'all-event-classes',
    'all-grob-descriptions',
    'all-internal-grob-properties',
    'all-internal-translation-properties',
    'all-invisible',
    'all-music-font-encodings',
    'all-music-properties',
    'all-text-font-encodings',
    'all-translation-properties',
    'all-user-grob-properties',
    'all-user-translation-properties',
    'all-visible',
    'alteration-default-glyph-name-alist',
    'alteration-hufnagel-glyph-name-alist',
    'alteration-kievan-glyph-name-alist',
    'alteration-medicaea-glyph-name-alist',
    'alteration-mensural-glyph-name-alist',
    'alteration-vaticana-glyph-name-alist',
    'arglist',
    'assoc-get',
    'axis-group-interface::height',
    'begin-of-line-invisible',
    'begin-of-line-visible',
    'black',
    'blue',
    'cancellation-glyph-name-alist',
    'center-invisible',
    'center-visible',
    'chain-assoc-get',
    'constante-hairpin',
    'current-outfile-name',
    'cyan',
    'darkblue',
    'darkcyan',
    'darkgreen',
    'darkmagenta',
    'darkred',
    'darkyellow',
    'default-chord-modifier-list',
    'default-language',
    'default-melisma-properties',
    'default-script-alist',
    'default-string-replacement-alist',
    'default-time-signature-settings',
    'dimension-arrows',
    'dynamic-default-volume',
    'empty-interval',
    'empty-markup',
    'empty-stencil',
    'end-of-line-invisible',
    'end-of-line-visible',
    'fancy-format',
    'feta-design-size-mapping',
    'flared-hairpin',
    'green',
    'grey',
    'grob::always-Y-extent-from-stencil',
    'grob::always-horizontal-skylines-from-element-stencils',
    'grob::always-horizontal-skylines-from-stencil',
    'grob::always-vertical-skylines-from-element-stencils',
    'grob::always-vertical-skylines-from-stencil',
    'grob::unpure-horizontal-skylines-from-stencil',
    'grob::unpure-vertical-skylines-from-stencil',
    'guile-predicates',
    'interpret-markup',
    'interval-end',
    'interval-start',
    'language-pitch-names',
    'lily-unit->bigpoint-factor',
    'lily-unit->mm-factor',
    'lilypond-exported-predicates',
    'lilypond-scheme-predicates',
    'magenta',
    'makam-alteration-glyph-name-alist',
    'markup-command-signature',
    'markup-functions-by-category',
    'markup-functions-properties',
    'markup-list-functions',
    'markup?',
    'mtrace:trace-depth',
    'music-descriptions',
    'music-name-to-property-table',
    'paper-alist',
    'paper-variable',
    'pitchnames',
    'point-stencil',
    'previous-pitchnames',
    'pure-from-neighbor-interface::height-if-pure',
    'red',
    'rhythmic-location-bar-number',
    'rhythmic-location-measure-position',
    'self-alignment-interface::y-aligned-on-self',
    'side-position-interface::y-aligned-side',
    'slur::height',
    'standard-alteration-glyph-name-alist',
    'supported-clefs',
    'toplevel-music-functions',
    'type-predicates-doc-string',
    'white',
    'woodwind-instrument-list',
    'yellow',
]

scheme_constants = [
    'CENTER',
    'DOS',
    'DOUBLE-FLAT',
    'DOUBLE-FLAT-QTS',
    'DOUBLE-SHARP',
    'DOUBLE-SHARP-QTS',
    'DOWN',
    'FLAT',
    'FLAT-QTS',
    'INFINITY-INT',
    'LEFT',
    'NATURAL',
    'NATURAL-QTS',
    'PI',
    'PI-OVER-TWO',
    'PLATFORM',
    'RIGHT',
    'SEMI-FLAT',
    'SEMI-FLAT-QTS',
    'SEMI-SHARP',
    'SEMI-SHARP-QTS',
    'SEMI-TONE',
    'SEMI-TONE-QTS',
    'SHARP',
    'SHARP-QTS',
    'START',
    'STOP',
    'THREE-PI-OVER-TWO',
    'THREE-Q-FLAT',
    'THREE-Q-FLAT-QTS',
    'THREE-Q-SHARP',
    'THREE-Q-SHARP-QTS',
    'TWO-PI',
    'UP',
    'X',
    'Y',
    'ZERO-MOMENT',
]


########NEW FILE########
__FILENAME__ = docinfo
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Harvest information from a ly.document.DocumentBase instance.

"""

from __future__ import unicode_literals
from __future__ import absolute_import

import re
import collections
import functools
import itertools

import ly.lex.lilypond
import ly.pitch


def _cache(func):
    """Simple decorator caching the return value of a function."""
    @functools.wraps(func)
    def wrapper(self):
        try:
            return self._cache_[func]
        except AttributeError:
            self._cache_ = {}
        except KeyError:
            pass
        result = self._cache_[func] = func(self)
        return result
    return wrapper


class DocInfo(object):
    """Harvest information from a ly.document.DocumentBase instance.
    
    All tokens are saved in the tokens attribute as a tuple. Newline tokens 
    are added between all lines. All corresponding classes are in the 
    classes attribute as a tuple. This makes quick search and access possible.
    
    The tokens are requested from the document using the 
    tokens_with_position() method, so you can always locate them back in the 
    original document using their pos attribute.
    
    DocInfo does not update when the document changes, you should just 
    instantiate a new one.
    
    """
    def __init__(self, doc):
        """Initialize with ly.document.DocumentBase instance."""
        self._d = doc
        blocks = iter(doc)
        for b in blocks:
            tokens = doc.tokens_with_position(b)
            self.tokens = sum(map(
                lambda b: ((ly.lex.Newline('\n', doc.position(b) - 1),) +
                           doc.tokens_with_position(b)),
                blocks), tokens)
        self.classes = tuple(map(type, self.tokens))
    
    @property
    def document(self):
        return self._d
    
    def range(self, start=0, end=None):
        """Return a new instance of the DocInfo class for the selected range.
        
        Only the tokens completely contained within the range start..end are 
        added to the new instance. This can be used to perform fast searches 
        on a subset of a document.
        
        """
        if start == 0 and end is None:
            return self
        
        lo = 0
        hi = len(self.tokens)
        while lo < hi:
            mid = (lo + hi) // 2
            if start > self.tokens[mid].pos:
                lo = mid + 1
            else:
                hi = mid
        start = lo
        if end is not None:
            lo = 0
            hi = len(self.tokens)
            while lo < hi:
                mid = (lo + hi) // 2
                if end < self.tokens[mid].pos:
                    hi = mid
                else:
                    lo = mid + 1
            end = lo - 1            
        s = slice(start, end)
        n = type(self).__new__(type(self))
        n._d = self._d
        n.tokens = self.tokens[s]
        n.classes = self.classes[s]
        return n
    
    @_cache
    def mode(self):
        """Return the mode, e.g. "lilypond"."""
        return self._d.initial_state().mode()
    
    def find(self, token=None, cls=None, pos=0, endpos=-1):
        """Return the index of the first specified token and/or class after pos.
        
        If token is None, the cls should be specified. If cls is given, the 
        token should be an instance of the specified class. If endpos is 
        given, never searches beyond endpos. Returns -1 if the token is not 
        found.
        
        """
        if token is None:
            try:
                return self.classes.index(cls, pos, endpos)
            except ValueError:
                return -1
        elif cls is None:
            try:
                return self.tokens.index(token, pos, endpos)
            except ValueError:
                return -1
        else:
            while True:
                try:
                    i = self.tokens.index(token, pos, endpos)
                except ValueError:
                    return -1
                if cls == self.classes[i]:
                    return i
                pos = i + 1
    
    def find_all(self, token=None, cls=None, pos=0, endpos=-1):
        """Yield all indices of the first specified token and/or class after pos.
        
        If token is None, the cls should be specified. If cls is given, the 
        token should be an instance of the specified class. If endpos is 
        given, never searches beyond endpos. Returns -1 if the token is not 
        found.
        
        """
        while True:
            i = self.find(token, cls, pos, endpos)
            if i == -1:
                break
            yield i
            pos = i + 1
    
    @_cache
    def version_string(self):
        """Return the version as a string, e.g. "2.19.8".
        
        Looks for the \\version LilyPond command. The string is returned 
        without quotes. Returns None if there was no \\version command found.
        
        """
        i = self.find("\\version", ly.lex.lilypond.Keyword)
        if i != -1:
            tokens = iter(self.tokens[i+1:i+10])
            for t in tokens:
                if not isinstance(t, (ly.lex.Space, ly.lex.Comment)):
                    if t == '"':
                        pred = lambda t: t != '"'
                    else:
                        pred = lambda t: not isinstance(t, (ly.lex.Space, ly.lex.Comment))
                    return ''.join(itertools.takewhile(pred, tokens))

    @_cache
    def version(self):
        """Return the version_string() as a tuple of ints, e.g. (2, 16, 2)."""
        version = self.version_string()
        if version:
            return tuple(map(int, re.findall(r"\d+", version)))
        return ()

    @_cache
    def include_args(self):
        """The list of \\include command arguments."""
        result = []
        for i in self.find_all("\\include", ly.lex.lilypond.Keyword):
            tokens = iter(self.tokens[i+1:i+10])
            for token in tokens:
                if not isinstance(token, (ly.lex.Space, ly.lex.Comment)):
                    if token == '"':
                        result.append(''.join(itertools.takewhile(lambda t: t != '"', tokens)))
                    break
        return result
    
    @_cache
    def scheme_load_args(self):
        """The list of scheme (load) command arguments."""
        result = []
        for i in self.find_all("load", ly.lex.scheme.Keyword):
            tokens = iter(self.tokens[i+1:i+10])
            for token in tokens:
                if not isinstance(token, (ly.lex.Space, ly.lex.Comment)):
                    if token == '"':
                        result.append(''.join(itertools.takewhile(lambda t: t != '"', tokens)))
                    break
        return result
    
    @_cache
    def output_args(self):
        """The list of arguments of constructs defining the name of output documents.
        
        This looks at the \\bookOutputName, \\bookOutputSuffix and define 
        output-suffix commands.
        
        Every argument is a two tuple(type, argument) where type is either 
        "suffix" or "name".
        
        """
        result = []
        for arg_type, cmd, cls in (
                ("suffix", "output-suffix", ly.lex.scheme.Word),
                ("suffix", "\\bookOutputSuffix", ly.lex.lilypond.Command),
                ("name", "\\bookOutputName", ly.lex.lilypond.Command),
                ):
            for i in self.find_all(cmd, cls):
                tokens = iter(self.tokens[i+1:i+6])
                for t in tokens:
                    if t == '"':
                        arg = ''.join(itertools.takewhile(lambda t: t != '"', tokens))
                        result.append((arg_type, arg))
                        break
                    elif isinstance(t, (ly.lex.lilypond.SchemeStart,
                                            ly.lex.Space,
                                            ly.lex.Comment)):
                        continue
                    break
        return result
    
    @_cache
    def definitions(self):
        """The list of LilyPond identifiers the document defines."""
        result = []
        for i in self.find_all(None, ly.lex.lilypond.Name):
            if i == 0 or self.tokens[i-1] == '\n':
                result.append(self.tokens[i])
        return result
    
    @_cache
    def markup_definitions(self):
        """The list of markup command definitions in the document."""
        result = []
        # find bla = \markup { .. }
        for i in self.find_all(None, ly.lex.lilypond.Name):
            if i == 0 or self.tokens[i-1] == '\n':
                for t in self.tokens[i+1:i+6]:
                    if t == "\\markup":
                        result.append(self.tokens[i])
                    elif t == "=" or t.isspace():
                        continue
                    break
        # find #(define-markup-command construction
        for i in self.find_all('define-markup-command', ly.lex.scheme.Word):
            for t in self.tokens[i+1:i+6]:
                if isinstance(t, ly.lex.scheme.Word):
                    result.append(t)
                    break
        result.sort(key=lambda t: t.pos)
        return result

    @_cache
    def language(self):
        """The pitch language, None if not set in the document."""
        languages = ly.pitch.pitchInfo.keys()
        for i in self.find_all("\\language", ly.lex.lilypond.Keyword):
            for t in self.tokens[i+1:i+10]:
                if isinstance(t, ly.lex.Space):
                    continue
                elif t == '"':
                    continue
                if t in languages:
                    return t
        for n in self.include_args():
            lang = n.rsplit('.', 1)[0]
            if lang in languages:
                return lang
    
    @_cache
    def global_staff_size(self):
        """The global-staff-size, if set, else None."""
        i = self.find('set-global-staff-size', ly.lex.scheme.Function)
        if i != -1:
            try:
                return int(self.tokens[i+2])
            except (IndexError, ValueError):
                pass
    
    @_cache
    def token_hash(self):
        """Return an integer hash for all non-whitespace and non-comment tokens.
        
        This hash does not change when only comments or whitespace are changed.
        
        """
        return hash(tuple(t for t in self.tokens
                          if not isinstance(t, (ly.lex.Space, ly.lex.Comment))))
    
    @_cache
    def complete(self):
        """Return whether the document is probably complete and could be compilable."""
        return self._d.state_end(self._d[len(self._d)-1]).depth() == 1
    
    @_cache
    def has_output(self):
        """Return True when the document probably generates output.
        
        I.e. has notes, rests, markup or other output-generating commands.
        
        """
        for t, c in (
                (None, ly.lex.lilypond.MarkupStart),
                (None, ly.lex.lilypond.Note),
                (None, ly.lex.lilypond.Rest),
                ('\\include', ly.lex.lilypond.Keyword),
                (None, ly.lex.lilypond.LyricMode),
            ):
            for i in self.find_all(t, c):
                return True
        return False
    
    def count_tokens(self, cls):
        """Return the number of tokens that are (a subclass) of the specified class.
        
        If you only want the number of instances of the exact class (not a 
        subclass of) you can use info.classes.count(cls), where info is a 
        DocInfo instance.
        
        """
        return sum(map(lambda c: issubclass(c, cls), self.classes), False)

    def counted_tokens(self):
        """Return a dictionary mapping classes to the number of instances of that class."""
        try:
            # only in Python 2.7+
            return collections.Counter(self.classes)
        except AttributeError:
            # for the time being also support Python 2.6
            d = collections.defaultdict(int)
            for c in self.classes:
                d[c] += 1
            return d



########NEW FILE########
__FILENAME__ = document
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
DocumentBase and Document
=========================

Represents a lilypond source document (the text contents).

The Document implementation keeps the document in a (unicode) text string, 
but you can inherit from the DocumentBase class to support other 
representations of the text content.

Modifying is done inside a context (the with statement), e.g.:

d = Document('some string')
with d:
    d[5:5] = 'different '
d.plaintext()  --> 'some different string'

Changes are applied when the context is exited, also the modified part of the
document is re-tokenized. Changes may not overlap.

The tokens(block) method returns a tuple of tokens for the specified block. 
Depending on the implementation, a block describes a line in the LilyPond 
source document. It is not expected to have any methods, except that the 
'==' operator is supported between two blocks, and returns True if both 
refer to the same line of text in the source document.


Cursor
======

Defines a range or position in a Document.


Runner
======

A Runner allows iterating back and forth over the tokens of a document.


Source
======

Iterate over tokens in a (part of a) Document, with or without state.


"""

from __future__ import unicode_literals
from __future__ import absolute_import

import io
import sys
import operator
import collections
import weakref

import ly.lex


class DocumentBase(object):
    """Abstract base class for Document instances.
    
    You should inherit the following methods:
    
    setplaintext
    __len__
    __getitem__
    block
    index
    position
    text
    tokens
    isvalid
    initial_state
    state_end
    apply_changes
    
    You may inherit (e.g. to get speed improvements):
    
    plaintext
    next_block
    previous_block
    blocks_forward
    blocks_backward
    state
    
    You may use the following attributes:
    
    filename (None)   # can represent the filename of the document on disk
    encoding (None)   # can represent the encoding of the document when reading/writing to disk
    
    """
    
    filename = None
    encoding = None
    
    
    def __init__(self):
        """Constructor"""
        self._writing = 0
        self._changes = collections.defaultdict(list)
        # to keep compatible with 2.6 (else we'd use a WeakSet)
        self._cursors = weakref.WeakKeyDictionary()
    
    def __nonzero__(self):
        return True
    
    def __iter__(self):
        """Iter over all blocks."""
        return self.blocks_forward(self[0])
    
    def __len__(self):
        """Return the number of blocks"""
        raise NotImplementedError()
    
    def __getitem__(self, index):
        """Return the block at the specified index."""
        raise NotImplementedError()
        
    def plaintext(self):
        """The document contents as a plain text string."""
        return '\n'.join(map(self.text, self))

    def setplaintext(self, text):
        """Sets the document contents to the text string."""
        raise NotImplementedError()

    def size(self):
        """Return the number of characters in the document."""
        last_block = self[len(self) - 1]
        return self.position(last_block) + len(self.text(last_block))

    def block(self, position):
        """Return the text block at the specified character position.
        
        The text block itself has no methods, but it can be used as an
        argument to other methods of this class.
        
        (Blocks do have to support the '==' operator.)
        
        """
        raise NotImplementedError()
    
    def index(self, block):
        """Return the linenumber of the block (starting with 0)."""
        raise NotImplementedError()
         
    def blocks_forward(self, block):
        """Iter forward starting with the specified block."""
        while self.isvalid(block):
            yield block
            block = self.next_block(block)

    def blocks_backward(self, block):
        """Iter backwards starting with the specified block."""
        while self.isvalid(block):
            yield block
            block = self.previous_block(block)

    def position(self, block):
        """Return the position of the specified block."""
        raise NotImplementedError()

    def text(self, block):
        """Return the text of the specified block."""
        raise NotImplementedError()
    
    def next_block(self, block):
        """Return the next block, which may be invalid."""
        index = self.index(block)
        if index < len(self) - 1:
            return self[index + 1]
    
    def previous_block(self, block):
        """Return the previous block, which may be invalid."""
        index = self.index(block)
        if index > 0:
            return self[index - 1]
    
    def isvalid(self, block):
        """Return True if the block is a valid block."""
        raise NotImplementedError()
    
    def isblank(self, block):
        """Return True if the block is empty or blank."""
        t = self.text(block)
        return not t or t.isspace()

    def __enter__(self):
        """Start the context for modifying the document."""
        self._writing += 1
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Exit the context for modifying."""
        if exc_type is not None:
            # cancel all edits when an exception occurred
            self._writing = 0
            self._changes.clear()
        elif self._writing == 1:
            if self._changes:
                self._changes_list = [(start, end, text)
                    for start, items in sorted(self._changes.items(), reverse=True)
                    for end, text in reversed(sorted(items,
                        key=lambda i: (i[0] is None, i[0])))]
                self._changes.clear()
                self.update_cursors()
                self.apply_changes()
                del self._changes_list
            self._writing = 0
        elif self._writing > 1:
            self._writing -= 1
    
    def _register_cursor(self, cursor):
        """Make a weak reference to the cursor.
        
        This is called by the constructor of the Cursor.
        The Cursor gets updated when the document is changed.
        
        """
        self._cursors[cursor] = True
        
    def check_changes(self):
        """Debugging method that checks for overlapping edits."""
        pos = self.size()
        for start, end, text in self._changes_list:
            if end > pos:
                if len(text) > 12:
                    text = text[:10] + '...'
                raise ValueError("overlapping edit: {0}-{1}: {2}".format(start, end, text))
            pos = start
    
    def update_cursors(self):
        """Updates the position of the registered Cursor instances."""
        for start, end, text in self._changes_list:
            for c in self._cursors:
                if c.start > start:
                    if end is None or end >= c.start:
                        c.start = start
                    else:
                        c.start += start + len(text) - end
                if c.end is not None and c.end >= start:
                    if end is None or end >= c.end:
                        c.end = start + len(text)
                    else:
                        c.end += start + len(text) - end
    
    def apply_changes(self):
        """Apply the changes and update the tokens."""
        raise NotImplementedError()
        
    def tokens(self, block):
        """Return the tuple of tokens of the specified block.
        
        The pos and end attributes of every token point to the position
        of the token in the block. 
        
        """
        raise NotImplementedError()
    
    def tokens_with_position(self, block):
        """Return a tuple of tokens of the specified block.
        
        The pos and end attributes of every token point to the position
        in the Document, instead of to the position in the current block.
        
        This makes it easier to iterate over tokens and change the document.
        
        """
        pos = self.position(block)
        return tuple(type(t)(t, pos + t.pos) for t in self.tokens(block))
        
    def initial_state(self):
        """Return the state at the beginning of the document."""
        raise NotImplementedError()
        
    def state(self, block):
        """Return the state at the start of the specified block."""
        prev = self.previous_block(block)
        if self.isvalid(prev):
            return self.state_end(prev)
        return self.initial_state()
            
    def state_end(self, block):
        """Return the state at the end of the specified block."""
        raise NotImplementedError()
    
    def __setitem__(self, key, text):
        """Change the text pointed to in key (integer or slice).
        
        If start > stop in the slice (and stop is not None), start and stop
        are swapped. (This is different than usual Python behaviour, where
        stop is set to start if it was lower.)
        
        """
        if isinstance(key, slice):
            start = key.start or 0
            end = key.stop
            if end is not None and start > end:
                start, end = end, start
        else:
            start = key
            end = start + 1
        text = text.replace('\r', '')
        if text or start != end:
            self._changes[start].append((end, text))

    def __delitem__(self, key):
        """Remove the range of text."""
        self[key] = ""


class Document(DocumentBase):
    """A plain text LilyPond source document that auto-updates the tokens.
    
    The modified attribute is set to True as soon as the document is changed,
    but the setplaintext() method sets it to False.
    
    """
    modified = False
    
    def __init__(self, text='', mode=None):
        super(Document, self).__init__()
        self._fridge = ly.lex.Fridge()
        self._mode = mode
        self._guessed_mode = None
        self.setplaintext(text)
    
    @classmethod
    def load(cls, filename, encoding='utf-8', mode=None):
        """Load the document from a file, using the specified encoding and mode."""
        with io.open(filename, encoding=encoding) as f:
            doc = cls(f.read(), mode)
        doc.filename = filename
        return doc
    
    def __len__(self):
        """Return the number of blocks"""
        return len(self._blocks)
    
    def __getitem__(self, index):
        """Return the block at the specified index."""
        return self._blocks[index]
    
    def setmode(self, mode):
        """Sets the mode to one of the ly.lex modes.
        
        Use None to auto-determine the mode.
        
        """
        if mode not in ly.lex.modes:
            mode = None
        if mode == self._mode:
            return
        self._mode, old_mode = mode, self._mode
        if not mode:
            self._guessed_mode = ly.lex.guessMode(self.plaintext())
            if self._guessed_mode == old_mode:
                return
        elif not old_mode:
            if mode == self._guessed_mode:
                return
        self._update_all_tokens()
    
    def mode(self):
        """Return the mode (lilypond, html, etc). None means automatic mode."""
        return self._mode
    
    def setplaintext(self, text):
        """Set the text of the document, sets modified to False."""
        text = text.replace('\r', '')
        lines = text.split('\n')
        self._blocks = [_Block(t, n) for n, t in enumerate(lines)]
        pos = 0
        for b in self._blocks:
            b.position = pos
            pos += len(b.text) + 1
        if not self._mode:
            self._guessed_mode = ly.lex.guessMode(text)
        self._update_all_tokens()
        self.modified = False
    
    def _update_all_tokens(self):
        state = self.initial_state()
        for b in self._blocks:
            b.tokens = tuple(state.tokens(b.text))
            b.state = self._fridge.freeze(state)
    
    def initial_state(self):
        """Return the state at the beginning of the document."""
        return ly.lex.state(self._mode or self._guessed_mode)
        
    def state_end(self, block):
        """Return the state at the end of the specified block."""
        return self._fridge.thaw(block.state)
    
    def block(self, position):
        """Return the text block at the specified character position."""
        if 0 <= position <= self._blocks[-1].position + len(self._blocks[-1].text):
            lo = 0
            hi = len(self._blocks)
            while lo < hi:
                mid = (lo + hi) // 2
                if position < self._blocks[mid].position:
                    hi = mid
                else:
                    lo = mid + 1
            return self._blocks[lo-1]
     
    def index(self, block):
        """Return the linenumber of the block (starting with 0)."""
        return block.index

    def position(self, block):
        """Return the position of the specified block."""
        return block.position

    def text(self, block):
        """Return the text of the specified block."""
        return block.text
    
    def isvalid(self, block):
        """Return True if the block is a valid block."""
        return bool(block)
    
    def tokens(self, block):
        """Return the tuple of tokens of the specified block."""
        return block.tokens
    
    def apply_changes(self):
        for start, end, text in self._changes_list:
            s = self.block(start)
            # first remove the old contents
            if end is None:
                # all text to the end should be removed
                s.text = s.text[:start - s.position]
                del self._blocks[s.index+1:]
            else:
                # remove til end position
                e = self.block(end)
                s.text = s.text[:start - s.position] + e.text[end - e.position:]
                del self._blocks[s.index+1:e.index+1]
            # now insert the new stuff
            if text:
                lines = text.split('\n')
                lines[-1] += s.text[start - s.position:]
                s.text = s.text[:start - s.position] + lines[0]
                self._blocks[s.index+1:s.index+1] = map(_Block, lines[1:])
            # make sure this line gets reparsed
            s.tokens = None
        
        # update the position of all the new blocks
        pos = s.position
        for i, b in enumerate(self._blocks[s.index:], s.index):
            b.index = i
            b.position = pos
            pos += len(b.text) + 1
        
        self.modified = True
        
        # if the initial state has changed, reparse everything
        if not self._mode:
            mode = ly.lex.guessMode(self.plaintext())
            if mode != self._guessed_mode:
                self._guessed_mode = mode
                self._update_all_tokens()
                return
        
        # update the tokens starting at block s
        state = self.state(s)
        reparse = False
        for block in self._blocks[s.index:]:
            if reparse or block.tokens is None:
                block.tokens = tuple(state.tokens(block.text))
                frozen = self._fridge.freeze(state)
                reparse = block.state != frozen
                block.state = frozen
            else:
                state = self._fridge.thaw(block.state)


class _Block(object):
    """A line of text.
    
    This class is only used by the Document implementation.
    
    """
    
    position = sys.maxsize  # prevent picking those blocks before updating pos
    state    = None
    tokens   = None
    
    def __init__(self, text="", index=-1):
        self.text = text
        self.index = index


class Cursor(object):
    """Defines a certain range (selection) in a Document.
    
    You may change the start and end attributes yourself. Both must be an 
    integer, end may also be None, denoting the end of the document.
    
    As long as you keep a reference to the Cursor, its positions are updated 
    when the document changes. When text is inserted at the start position, 
    it remains the same. But when text is inserted at the end of a cursor, 
    the end position moves along with the new text. E.g.:
    
    d = Document('hi there, folks!')
    c = Cursor(d, 8, 8)
    with d:
        d[8:8] = 'new text'
    c.start, c.end --> (8, 16)
    
    Many tools in the ly module use this object to describe (part of) a
    document.
    
    """
    def __init__(self, doc, start=0, end=None):
        self._d = doc
        self.start = start
        self.end = end
        doc._register_cursor(self)
    
    @property
    def document(self):
        return self._d
    
    def start_block(self):
        """Return the block the start attribute points at."""
        return self._d.block(self.start)
    
    def end_block(self):
        """Return the block the end attribute points at."""
        if self.end is None:
            return self._d[len(self._d)-1]
        return self._d.block(self.end)
    
    def blocks(self):
        """Iterate over the selected blocks.
        
        If there are multiple blocks and the cursor ends on the first 
        position of the last selected block, that block is not included.
        
        """
        if self.end == self.start:
            yield self.start_block()
        else:
            for b in self._d.blocks_forward(self.start_block()):
                if self.end is not None and self._d.position(b) >= self.end:
                    break
                yield b
    
    def text(self):
        """Convenience method to return the selected text."""
        return self._d.plaintext()[self.start:self.end]
    
    def text_before(self):
        """Return text before the cursor in it's start block."""
        b = self.start_block()
        pos = self.start - self._d.position(b)
        return self._d.text(b)[:pos]
        
    def text_after(self):
        """Return text after the cursor in it's end block."""
        if self.end is None:
            return ""
        b = self.end_block()
        pos = self.end - self._d.position(b)
        return self._d.text(b)[pos:]
        
    def has_selection(self):
        """Return True when there is some text selected."""
        end = self.end
        if end is None:
            end = self._d.size()
        return self.start != end
    
    def select_all(self):
        """Select all text."""
        self.start, self.end = 0, None
    
    def select_end_of_block(self):
        """Move end to the end of the block."""
        if self.end is not None:
            end = self.end_block()
            self.end = self._d.position(end) + len(self._d.text(end))
    
    def select_start_of_block(self):
        """Move start to the start of the block."""
        start = self.start_block()
        self.start = self._d.position(start)
    
    def lstrip(self, chars=None):
        """Move start to the right, like Python's lstrip() string method."""
        if self.has_selection():
            text = self.text()
            self.start += len(text) - len(text.lstrip(chars))
    
    def rstrip(self, chars=None):
        """Move end to the left, like Python's lstrip() string method."""
        if self.has_selection():
            text = self.text()
            end = self._d.size() if self.end is None else self.end
            end -= len(text) - len(text.rstrip(chars))
            if end < self._d.size():
                self.end = end
    
    def strip(self, chars=None):
        """Strip chars from the selection, like Python's strip() method."""
        self.rstrip(chars)
        self.lstrip(chars)


class Runner(object):
    """Iterates back and forth over tokens.
    
    A Runner can stop anywhere and remembers its current token.
    
    """
    def __init__(self, doc, tokens_with_position=False):
        """Create and init with Document.
        
        If tokens_with_position is True, uses the tokens_with_position() 
        method to get the tokens, else (by default), the tokens() method is 
        used.
        
        The Runner is initialized at position 0. Alternatively, you can use 
        the 'at' classmethod to construct a Runner at a specific cursor 
        position.
        
        """
        self._doc = doc
        self._wp = tokens_with_position
        self.move_to_block(doc[0])
    
    @classmethod
    def at(cls, cursor, after_token=False, tokens_with_position=False):
        """Create and init from a Cursor.
        
        The Runner is positioned so that yielding forward starts with the
        first complete token after the cursor's start position.
        
        Set after_token to True if you want to position the cursor after the
        token, so that it gets yielded when you go backward.
        
        If tokens_with_position is True, uses the tokens_with_position() 
        method to get the tokens, else (by default), the tokens() method is 
        used.
        
        """
        runner = cls(cursor.document, tokens_with_position)
        runner.set_position(cursor.start, after_token)
        return runner
    
    @property
    def document(self):
        """Return our Document."""
        return self._doc
    
    def set_position(self, position, after_token=False):
        """Positions the Runner at the specified position.
        
        Set after_token to True if you want to position the cursor after the
        token, so that it gets yielded when you go backward.
        
        """
        block = self._doc.block(position)
        self.move_to_block(block)
        if after_token:
            for t in self.forward_line():
                if self.position() + len(t) >= position:
                    self._index += 1
                    break
        else:
            for t in self.forward_line():
                if self.position() + len(t) > position:
                    self._index -= 1
                    break
        
    def move_to_block(self, block, at_end=False):
        """Positions the Runner at the start of the given text block.
        
        If at_end == True, the iterator is positioned past the end of the block.
        
        """
        if self._doc.isvalid(block):
            self.block = block
            method = self._doc.tokens_with_position if self._wp else self._doc.tokens
            self._tokens = method(block)
            self._index = len(self._tokens) if at_end else -1
            return True
    
    def _newline(self):
        """(Internal) Create a Newline token at the end of the current block."""
        pos = len(self._doc.text(self.block))
        if self._wp:
            pos += self._doc.position(self.block)
        return ly.lex.Newline('\n', pos)
        
    def forward_line(self):
        """Yields tokens in forward direction in the current block."""
        end = len(self._tokens)
        if self._index < end:
            while True:
                self._index += 1
                if self._index == end:
                    break
                yield self._tokens[self._index]
    
    def forward(self):
        """Yields tokens in forward direction across blocks."""
        while True:
            for t in self.forward_line():
                yield t
            newline = self._newline()
            if not self.next_block():
                break
            yield newline

    def backward_line(self):
        """Yields tokens in backward direction in the current block."""
        if self._index >= 0:
            while True:
                self._index -= 1
                if self._index == -1:
                    break
                yield self._tokens[self._index]
    
    def backward(self):
        """Yields tokens in backward direction across blocks."""
        while True:
            for t in self.backward_line():
                yield t
            if not self.previous_block():
                break
            yield self._newline()
    
    def previous_block(self, at_end=True):
        """Go to the previous block, positioning the cursor at the end by default.
        
        Returns False if there was no previous block, else True.
        
        """
        return self.move_to_block(self._doc.previous_block(self.block), at_end)
    
    def next_block(self, at_end=False):
        """Go to the next block, positioning the cursor at the start by default.
        
        Returns False if there was no next block, else True.
        
        """
        return self.move_to_block(self._doc.next_block(self.block), at_end)
    
    def token(self):
        """Re-returns the last yielded token."""
        if self._tokens:
            index = self._index
            if index < 0:
                index = 0
            elif index >= len(self._tokens):
                index = len(self._tokens) - 1
            return self._tokens[index]
        
    def position(self):
        """Returns the position of the current token."""
        if self._tokens:
            pos = self.token().pos
            if not self._wp:
                pos += self._doc.position(self.block)
            return pos
        else:
            return self._d.position(self.block)
    
    def copy(self):
        """Return a new Runner at the current position."""
        obj = type(self)(self._doc, self._wp)
        obj.block = self.block
        obj._tokens = self._tokens
        obj._index = self._index
        return obj


OUTSIDE = -1
PARTIAL = 0
INSIDE  = 1


class Source(object):
    """Helper iterator.
    
    Iterates over the (block, tokens) tuples from a Document (or a part 
    thereof). Stores the current block in the block attribute and the tokens 
    (which also is a generator) in the tokens attribute.
    
    Iterating over the source object itself just yields the tokens, while the
    block attribute contains the current block.
    
    You can also iterate over the tokens attribute, which will yield the
    remaining tokens of the current block and then stop.
    
    If you specify a state, the tokens will update the state. If you specify
    state = True, the state will be taken from the document.
    
    """
    
    def __init__(self, cursor, state=None, partial=INSIDE, tokens_with_position=False):
        """Initialize the iterator.
        
        cursor is a Cursor instance, describing a Document and a selected range
        partial is either OUTSIDE, PARTIAL, or INSIDE:
            OUTSIDE: tokens that touch the selected range are also yielded
            PARTIAL: tokens that overlap the start or end positions are yielded
            INSIDE:  (default) yield only tokens fully contained in the range
        The partial argument only makes sense if start or end are specified.
        
        If tokens_with_position is True, uses the tokens_with_position() 
        method to get the tokens, else (by default), the tokens() method is 
        used.
        
        """
        self._pushback = False
        self._last = None
        self._doc = document = cursor.document
        start_block = document.block(cursor.start)
        self._wp = tokens_with_position
        tokens_method = document.tokens_with_position if tokens_with_position else document.tokens
        
        # start, end predicates
        start_pred, end_pred = {
            OUTSIDE: (
                lambda t: t.end < start_pos,
                lambda t: t.pos > end_pos,
            ),
            PARTIAL: (
                lambda t: t.end <= start_pos,
                lambda t: t.pos >= end_pos,
            ),
            INSIDE: (
                lambda t: t.pos < start_pos,
                lambda t: t.end > end_pos,
            ),
        }[partial]
        
        # if a state is given, use it (True: pick state from doc)
        if state:
            if state is True:
                state = document.state(start_block)
            def token_source(block):
                for t in tokens_method(block):
                    state.follow(t)
                    yield t
        else:
            def token_source(block):
                return iter(tokens_method(block))
        self.state = state
        
        # where to start
        if cursor.start:
            start_pos = cursor.start
            if not tokens_with_position:
                start_pos -= document.position(start_block)
            # token source for first block
            def source_start(block):
                source = token_source(block)
                for t in source:
                    if not start_pred(t):
                        yield t
                        for t in source:
                            yield t
        else:
            source_start = token_source
        
        # where to end
        if cursor.end is not None:
            end_block = cursor.end_block()
            end_pos = cursor.end 
            if not tokens_with_position:
                end_pos -= document.position(end_block)
            def source_end(source):
                for t in source:
                    if end_pred(t):
                        break
                    yield t
        
        # generate the tokens
        def generator():
            source = source_start
            block = start_block
            if cursor.end is not None:
                while block != end_block:
                    yield block, source(block)
                    source = token_source
                    block = document.next_block(block)
                yield block, source_end(source(block))
            else:
                for block in document.blocks_forward(start_block):
                    yield block, source(block)
                    source = token_source
        gen = generator()
        
        if tokens_with_position:
            def newline():
                pos = document.position(self.block) - 1
                return ly.lex.Newline('\n', pos)
        else:
            def newline():
                pos = len(document.text(document.previous_block(self.block)))
                return ly.lex.Newline('\n', pos)
        
        # initialize block and tokens
        for self.block, self.tokens in gen:
            break
        # keep them going after the first line
        def g():
            for t in self.tokens:
                yield t
            for self.block, self.tokens in gen:
                yield newline()
                for t in self.tokens:
                    yield t
        self._gen = g()
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self._pushback:
            self._pushback = False
            return self._last
        i = self._last = next(self._gen)
        return i
    
    next = __next__
    
    def pushback(self, pushback=True):
        """Yields the last yielded token again on the next request.
        
        This can be called multiple times, but only the last token will be 
        yielded again. You can also undo a call to pushback() using 
        pushback(False).
        
        """
        self._pushback = pushback
    
    def token(self):
        """Re-returns the last yielded token."""
        return self._last
    
    @property
    def document(self):
        """Return our Document."""
        return self._doc
    
    def position(self, token):
        """Returns the position of the token in the current block.
        
        If the iterator was instantiated with tokens_with_position == True, 
        this position is the same as the token.pos attribute, and the current
        block does not matter. (In that case you'll probably not use this 
        method.)
        
        """
        pos = token.pos
        if not self._wp:
            pos += self._doc.position(self.block)
        return pos
    
    def until_parser_end(self):
        """Yield the tokens until the current parser is quit.
        
        You can only use this method if you have a State enabled.
        
        """
        depth = self.state.depth()
        for t in self:
            yield t
            if self.state.depth() < depth and not self._pushback:
                break
        
    def consume(self, iterable, position):
        """Consumes iterable (supposed to be reading from us) until position.
        
        Returns the last token if that overlaps position.
        
        """
        if self._doc.position(self.block) < position:
            for t in iterable:
                pos = self.position(t)
                end = pos + len(t)
                if end == position:
                    return
                elif end > position:
                    return t



########NEW FILE########
__FILENAME__ = dom
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
LilyPond DOM

(c) 2008-2011 Wilbert Berendsen
License: GPL.

A simple Document Object Model for LilyPond documents.

The purpose is to easily build a LilyPond document with good syntax,
not to fully understand all features LilyPond supports. (This DOM does
not enforce a legal LilyPond file.)

All elements of a LilyPond document inherit Node.

Note: elements keep a weak reference to their parent.

"""

from __future__ import unicode_literals
from __future__ import absolute_import # prevent picking old stale node.py from package

import fractions
import re

import node

import ly.pitch
import ly.duration


class LyNode(node.WeakNode):
    """
    Base class for LilyPond objects, based on Node,
    which takes care of the tree structure.
    """
    
    ##
    # True if this element is single LilyPond atom, word, note, etc.
    # When it is the only element inside { }, the brackets can be removed.
    isAtom = False
   
    ##
    # The number of newlines this object wants before it.
    before = 0
    
    ##
    # The number of newlines this object wants after it.
    after = 0
    
    def ly(self, printer):
        """
        Returns printable output for this object.
        Can ask printer for certain settings, e.g. pitch language etc.
        """
        return ''

    def concat(self, other):
        """
        Returns a string with newlines to concat this node to another one.
        If zero newlines are requested, an empty string is returned.
        """
        return '\n' * max(self.after, other.before)


##
# Leaf and Container are the two base classes the rest of the LilyPond
# element classes is based on.
# 
class Leaf(LyNode):
    """ A leaf node without children """
    pass


class Container(LyNode):
    """ A node that concatenates its children on output """
    
    ##
    # default character to concatenate children with
    defaultSpace = " "
    
    @property
    def before(self):
        if len(self):
            return self[0].before
        else:
            return 0

    @property
    def after(self):
        if len(self):
            return self[-1].after
        else:
            return 0
            
    def ly(self, printer):
        if len(self) == 0:
            return ''
        else:
            n = self[0]
            res = [n.ly(printer)]
            for m in self[1:]:
                res.append(n.concat(m) or self.defaultSpace)
                res.append(m.ly(printer))
                n = m
            return "".join(res)


##
# Helper classes
#
class Printer(object):
    """
    Performs certain operations on behalf of a LyNode tree,
    like quoting strings or translating pitch names, etc.
    """
    def __init__(self):
        self.typographicalQuotes = True
        self.language = "nederlands"
        self.indentString = '  '
        
    def quoteString(self, text):
        if self.typographicalQuotes:
            text = re.sub(r'"(.*?)"', '\u201C\\1\u201D', text)
            text = re.sub(r"'(.*?)'", '\u2018\\1\u2019', text)
            text = text.replace("'", '\u2018')
        # escape regular double quotes
        text = text.replace('"', '\\"')
        # quote the string
        return '"{0}"'.format(text)

    def indentGen(self, node, startIndent = 0):
        """
        A generator that walks on the output of the given node,
        and returns properly indented LilyPond code.
        """
        d = startIndent
        for t in node.ly(self).splitlines() + [''] * node.after:
            if d and re.match(r'#?}|>|%}', t):
                d -= 1
            yield self.indentString * d + t
            if re.search(r'(\{|<|%{)$', t):
                d += 1

    def indent(self, node):
        """
        Return a formatted printout of node (and its children)
        """
        return '\n'.join(self.indentGen(node))


class Reference(object):
    """
    A simple object that keeps a name, to use as a (context)
    identifier. Set the name attribute to the name you want
    to display, and on all places in the document the name
    will show up.
    """
    def __init__(self, name=""):
        self.name = name
    
    def __unicode__(self):
        return self.name


class Named(object):
    """
    Mixin to print a \\name before the contents of the container.
    unicode() is called on the self.name attribute, so it may also
    be a Reference.
    """
    name = ""
    
    def ly(self, printer):
        return "\\{0} {1}".format(unicode(self.name), super(Named, self).ly(printer))
        
        
class HandleVars(object):
    """
    A powerful mixin class that makes handling unique variable assignments
    inside a Container more easy.
    E.g.:
    >>> h = Header()
    >>> h['composer'] = "Johann Sebastian Bach"
    creates a subnode (by default Assignment) with the name 'composer', and
    that node again gets an autogenerated subnode of type QuotedString (If the
    argument wasn't already a Node).
    """
    childClass = None # To be filled in later

    def ifbasestring(func):
        """
        Ensure that the method is only called for basestring objects.
        Otherwise the same method from the super class is called.
        """
        def newfunc(obj, name, *args):
            if isinstance(name, basestring):
                return func(obj, name, *args)
            else:
                f = getattr(super(HandleVars, obj), func.func_name)
                return f(name, *args)
        return newfunc

    @ifbasestring
    def __getitem__(self, name):
        for node in self.find_children(self.childClass, 1):
            if node.name == name:
                return node

    @ifbasestring
    def __setitem__(self, name, valueObj):
        if not isinstance(valueObj, LyNode):
            valueObj = self.importNode(valueObj)
        assignment = self[name]
        if assignment:
            assignment.setValue(valueObj)
        else:
            self.childClass(name, self, valueObj)

    @ifbasestring
    def __contains__(self, name):
        return bool(self[name])

    @ifbasestring
    def __delitem__(self, name):
        h = self[name]
        if h:
            self.remove(h)

    def importNode(self, obj):
        """
        Try to interpret the object and transform it into a Node object
        of the right species.
        """
        return QuotedString(obj)


class AddDuration(object):
    """ Mixin to add a duration (as child). """
    def ly(self, printer):
        s = super(AddDuration, self).ly(printer)
        dur = self.find_child(Duration, 1)
        if dur:
            s += dur.ly(printer)
        return s


class Block(Container):
    """ 
    A vertical container type that puts everything on a new line.
    """
    defaultSpace = "\n"
    before, after = 1, 1


class Document(Container):
    """ 
    A container type that puts everything on a new line.
    To be used as a full LilyPond document.
    """
    defaultSpace = "\n"
    after = 1


##
# These classes correspond to real LilyPond data.
#
class Text(Leaf):
    """ A leaf node with arbitrary text """
    def __init__(self, text="", parent=None):
        super(Text, self).__init__(parent)
        if not isinstance(text, basestring):
            text = unicode(text)
        self.text = text
    
    def ly(self, printer):
        return self.text


class TextDur(AddDuration, Text):
    """ A text note with an optional duration as child. """
    pass


class Line(Text):
    """ A text node that claims its own line. """
    before, after = 1, 1
    
    
class Comment(Text):
    """ A LilyPond comment at the end of a line """
    after = 1

    def ly(self, printer):
        return re.compile('^', re.M).sub('% ', self.text)


class LineComment(Comment):
    """ A LilyPond comment that takes a full line """
    before = 1
        

class BlockComment(Comment):
    """ A block comment between %{ and %} """
    @property
    def before(self):
        return '\n' in self.text and 1 or 0
    
    @property
    def after(self):
        return '\n' in self.text and 1 or 0
        
    def ly(self, printer):
        text = self.text.replace('%}', '')
        f = "%{{\n{0}\n%}}" if '\n' in text else "%{{ {0} %}}"
        return f.format(text)
            

class QuotedString(Text):
    """ A string that is output inside double quotes. """
    isAtom = True
    def ly(self, printer):
        return printer.quoteString(self.text)
    

class Newline(LyNode):
    """ A newline. """
    after = 1


class BlankLine(Newline):
    """ A blank line. """
    before = 1
        

class Scheme(Text):
    """ A Scheme expression, without the extra # prepended """
    isAtom = True
    
    def ly(self, printer):
        return '#' + self.text


class Version(Line):
    """ a LilyPond version instruction """
    def ly(self, printer):
        return r'\version "{0}"'.format(self.text)


class Include(Line):
    """ a LilyPond \\include statement """
    def ly(self, printer):
        return r'\include "{0}"'.format(self.text)


class Assignment(Container):
    """
    A varname = value construct with it's value as its first child
    The name can be a string or a Reference object: so that everywhere
    where this varname is referenced, the name is the same.
    """
    before, after = 1, 1
    
    def __init__(self, name=None, parent=None, valueObj=None):
        super(Assignment, self).__init__(parent)
        self.name = name
        if valueObj:
            self.append(valueObj)
    
    # Convenience methods:
    def setValue(self, obj):
        if len(self):
            self[0] = obj
        else:
            self.append(obj)

    def value(self):
        if len(self):
            return self[0]

    def ly(self, printer):
        return "{0} = {1}".format(
            unicode(self.name), super(Assignment, self).ly(printer))


HandleVars.childClass = Assignment


class Identifier(Leaf):
    """
    An identifier, prints as \\name.
    Name may be a string or a Reference object.
    """
    isAtom = True
    
    def __init__(self, name=None, parent=None):
        super(Identifier, self).__init__(parent)
        self.name = name
        
    def ly(self, printer):
        return "\\" + unicode(self.name)


class Statement(Named, Container):
    """
    Base class for statements with arguments. The statement is read in the
    name attribute, the arguments are the children.
    """
    before = 0 # do not read property from container
    isAtom = True


class Command(Statement):
    """
    Use this to create a LilyPond command supplying the name (or a Reference)
    when instantiating.
    """
    def __init__(self, name, parent=None):
        super(Command, self).__init__(parent)
        self.name = name

    
class Enclosed(Container):
    """
    Encloses all children between brackets: { ... }
    If may_remove_brackets is True in subclasses, the brackets are
    removed if there is only one child and that child is an atom (i.e.
    a single LilyPond expression.
    """
    may_remove_brackets = False
    pre, post = "{", "}"
    before, after = 0, 0
    isAtom = True
    
    def ly(self, printer):
        if len(self) == 0:
            return " ".join((self.pre, self.post))
        sup = super(Enclosed, self)
        text = sup.ly(printer)
        if self.may_remove_brackets and len(self) == 1 and self[0].isAtom:
            return text
        elif sup.before or sup.after or '\n' in text:
            return "".join((self.pre, "\n" * max(sup.before, 1), text,
                                      "\n" * max(sup.after, 1), self.post))
        else:
            return " ".join((self.pre, text, self.post))


class Seq(Enclosed):
    """ An SequentialMusic expression between { } """
    pre, post = "{", "}"
    

class Sim(Enclosed):
    """ An SimultaneousMusic expression between << >> """
    pre, post = "<<", ">>"


class Seqr(Seq): may_remove_brackets = True
class Simr(Sim): may_remove_brackets = True
    

class SchemeLily(Enclosed):
    """ A LilyPond expression between #{ #} (inside scheme) """
    pre, post = "#{", "#}"


class SchemeList(Enclosed):
    """ A list of items enclosed in parentheses """
    pre, post = "(", ")"
    
    def ly(self, printer):
        return self.pre + super(Enclosed, self).ly(printer) + self.post


class StatementEnclosed(Named, Enclosed):
    """
    Base class for LilyPond commands that have a single bracket-enclosed
    list of arguments.
    """
    may_remove_brackets = True


class CommandEnclosed(StatementEnclosed):
    """
    Use this to print LilyPond commands that have a single 
    bracket-enclosed list of arguments. The command name is supplied to
    the constructor.
    """
    def __init__(self, name, parent=None):
        super(CommandEnclosed, self).__init__(parent)
        self.name = name
        
        
class Section(StatementEnclosed):
    """
    Very much like a Statement. Use as base class for \\book { }, \\score { }
    etc. By default never removes the brackets and always starts on a new line.
    """
    may_remove_brackets = False
    before, after = 1, 1


class Book(Section): name = 'book'
class BookPart(Section): name = 'bookpart'
class Score(Section): name = 'score'
class Paper(HandleVars, Section): name = 'paper'
class Layout(HandleVars, Section): name = 'layout'
class Midi(HandleVars, Section): name = 'midi'
class Header(HandleVars, Section): name = 'header'


class With(HandleVars, Section):
    """ If this item has no children, it prints nothing. """
    name = 'with'
    before, after = 0, 0
    
    def ly(self, printer):
        if len(self):
            return super(With, self).ly(printer)
        else:
            return ''


class ContextName(Text):
    """
    Used to print a context name, like \\Score.
    """
    def ly(self, printer):
        return "\\" + self.text


class Context(HandleVars, Section):
    """
    A \\context section for use inside Layout or Midi sections.
    """
    name = 'context'
    
    def __init__(self, contextName="", parent=None):
        super(Context, self).__init__(parent)
        if contextName:
            ContextName(contextName, self)
            

class ContextType(Container):
    """
    \\new or \\context Staff = 'bla' \\with { } << music >>

    A \\with (With) element is added automatically as the first child as soon
    as you use our convenience methods that manipulate the variables
    in \\with. If the \\with element is empty, it does not print anything.
    You should add one other music object to this.
    """
    before, after = 1, 1
    isAtom = True
    ctype = None
    
    def __init__(self, cid=None, new=True, parent=None):
        super(ContextType, self).__init__(parent)
        self.new = new
        self.cid = cid
        
    def ly(self, printer):
        res = []
        res.append(self.new and "\\new" or "\\context")
        res.append(self.ctype or self.__class__.__name__)
        if self.cid:
            res.append("=")
            res.append(printer.quoteString(unicode(self.cid)))
        res.append(super(ContextType, self).ly(printer))
        return " ".join(res)
        
    def getWith(self):
        """
        Gets the attached with clause. Creates it if not there.
        """
        for node in self:
            if isinstance(node, With):
                return node
        self.insert(0, With())
        return self[0]

    def addInstrumentNameEngraverIfNecessary(self):
        """
        Adds the Instrument_name_engraver to the node if it would need it
        to print instrument names.
        """
        if not isinstance(self,
            (Staff, RhythmicStaff, PianoStaff, Lyrics, FretBoards)):
            Line('\\consists "Instrument_name_engraver"', self.getWith())


class ChoirStaff(ContextType): pass
class ChordNames(ContextType): pass
class CueVoice(ContextType): pass
class Devnull(ContextType): pass
class DrumStaff(ContextType): pass
class DrumVoice(ContextType): pass
class Dynamics(ContextType): pass
class FiguredBass(ContextType): pass
class FretBoards(ContextType): pass
class Global(ContextType): pass
class GrandStaff(ContextType): pass
class GregorianTranscriptionStaff(ContextType): pass
class GregorianTranscriptionVoice(ContextType): pass
class InnerChoirStaff(ContextType): pass
class InnerStaffGroup(ContextType): pass
class Lyrics(ContextType): pass
class MensuralStaff(ContextType): pass
class MensuralVoice(ContextType): pass
class NoteNames(ContextType): pass
class PianoStaff(ContextType): pass
class RhythmicStaff(ContextType): pass
class ScoreContext(ContextType):
    """
    Represents the Score context in LilyPond, but the name would
    collide with the Score class that represents \\score { } constructs.

    Because the latter is used more often, use ScoreContext to get
    \\new Score etc.
    """
    ctype = 'Score'

class Staff(ContextType): pass
class StaffGroup(ContextType): pass
class TabStaff(ContextType): pass
class TabVoice(ContextType): pass
class VaticanaStaff(ContextType): pass
class VaticanaVoice(ContextType): pass
class Voice(ContextType): pass


class UserContext(ContextType):
    """
    Represents a context the user creates.
    e.g. \\new MyStaff = cid << music >>
    """
    def __init__(self, ctype, cid=None, new=True, parent=None):
        super(UserContext, self).__init__(cid, new, parent)
        self.ctype = ctype


class ContextProperty(Leaf):
    """
    A Context.property or Context.layoutObject construct.
    Call e.g. ContextProperty('aDueText', 'Staff') to get 'Staff.aDueText'.
    """
    def __init__(self, prop, context=None, parent=None):
        self.prop = prop
        self.context = context

    def ly(self, printer):
        if self.context:
            # In \lyrics or \lyricmode: put spaces around dot.
            p = self.find_parent(InputMode)
            if p and isinstance(p, LyricMode):
                f = '{0} . {1}'
            else:
                f = '{0}.{1}'
            return f.format(self.context, self.prop)
        else:
            return self.prop


class InputMode(StatementEnclosed):
    """
    The abstract base class for input modes such as lyricmode/lyrics,
    chordmode/chords etc.
    """
    pass


class ChordMode(InputMode): name = 'chordmode'
class InputChords(ChordMode): name = 'chords'
class LyricMode(InputMode): name = 'lyricmode'
class InputLyrics(LyricMode): name = 'lyrics'
class NoteMode(InputMode): name = 'notemode'
class InputNotes(NoteMode): name = 'notes'
class FigureMode(InputMode): name = 'figuremode'
class InputFigures(FigureMode): name = 'figures'
class DrumMode(InputMode): name = 'drummode'
class InputDrums(DrumMode): name = 'drums'


class AddLyrics(InputLyrics): 
    name = 'addlyrics'
    may_remove_brackets = False
    before, after = 1, 1


class LyricsTo(LyricMode):
    name = 'lyricsto'
    
    def __init__(self, cid, parent=None):
        super(LyricsTo, self).__init__(parent)
        self.cid = cid
    
    def ly(self, printer):
        res = ["\\" + self.name]
        res.append(printer.quoteString(unicode(self.cid)))
        res.append(super(Named, self).ly(printer))
        return " ".join(res)
        

class Pitch(Leaf):
    """
    A pitch with octave, note, alter.
    octave is specified by an integer, zero for the octave containing middle C.
    note is a number from 0 to 6, with 0 corresponding to pitch C and 6
    corresponding to pitch B.
    alter is the number of whole tones for alteration (can be int or Fraction)
    """

    def __init__(self, octave=0, note=0, alter=0, parent=None):
        super(Pitch, self).__init__(parent)
        self.octave = octave
        self.note = note
        self.alter = fractions.Fraction(alter)

    def ly(self, printer):
        """
        Print the pitch in the preferred language.
        """
        p = ly.pitch.pitchWriter(printer.language)(self.note, self.alter)
        if self.octave < -1:
            return p + ',' * (-self.octave - 1)
        elif self.octave > -1:
            return p + "'" * (self.octave + 1)
        return p


class Duration(Leaf):
    """
    A duration with duration (in logarithmical form): (-2 ... 8),
    where -2 = \\longa, -1 = \\breve, 0 = 1, 1 = 2, 2 = 4, 3 = 8, 4 = 16, etc,
    dots (number of dots),
    factor (Fraction giving the scaling of the duration).
    """
    def __init__(self, dur, dots=0, factor=1, parent=None):
        super(Duration, self).__init__(parent)
        self.dur = dur # log
        self.dots = dots
        self.factor = fractions.Fraction(factor)

    def ly(self, printer):
        return ly.duration.tostring(self.dur, self.dots, self.factor)


class Chord(Container):
    """
    A chord containing one of more Pitches and optionally one Duration.
    This is a bit of a hack, awaiting real music object support.
    """
    def ly(self, printer):
        pitches = list(self.find_children(Pitch, 1))
        if len(pitches) == 1:
            s = pitches[0].ly(printer)
        else:
            s = "<{0}>".format(' '.join(p.ly(printer) for p in pitches))
        duration = self.find_child(Duration, 1)
        if duration:
            s += duration.ly(printer)
        return s


class Relative(Statement):
    """
    \\relative <pitch> music

    You should add a Pitch (optionally) and another music object,
    e.g. Sim or Seq, etc.
    """
    name = 'relative'


class Transposition(Statement):
    """
    \\transposition <pitch>
    You should add a Pitch.
    """
    name = 'transposition'


class KeySignature(Leaf):
    """
    A key signature expression, like:

    \\key c \\major
    The pitch should be given in the arguments note and alter and is written
    out in the document's language.
    """
    def __init__(self, note=0, alter=0, mode="major", parent=None):
        super(KeySignature, self).__init__(parent)
        self.note = note
        self.alter = fractions.Fraction(alter)
        self.mode = mode

    def ly(self, printer):
        pitch = ly.pitch.pitchWriter(printer.language)(self.note, self.alter)
        return "\\key {0} \\{1}".format(pitch, self.mode)


class TimeSignature(Leaf):
    """
    A time signature, like: \\time 4/4
    """
    def __init__(self, num, beat, parent=None):
        super(TimeSignature, self).__init__(parent)
        self.num = num
        self.beat = beat

    def ly(self, printer):
        return "\\time {0}/{1}".format(self.num, self.beat)


class Partial(Named, Duration):
    """
    \\partial <duration>
    You should add a Duration element
    """
    name = "partial"
    before, after = 1, 1
    
    
class Tempo(Container):
    """
    A tempo setting, like: \\tempo 4 = 100
    May have a child markup or quoted string.
    """
    before, after = 1, 1
    
    def __init__(self, duration, value, parent=None):
        super(Tempo, self).__init__(parent)
        self.duration = duration
        self.value = value
        
    def ly(self, printer):
        result = ['\\tempo']
        if len(self) > 0:
            result.append(super(Tempo, self).ly(printer))
        if self.value:
            result.append("{0}={1}".format(self.duration, self.value))
        return ' '.join(result)
        
        
class Clef(Leaf):
    """
    A clef.
    """
    def __init__(self, clef, parent=None):
        super(Clef, self).__init__(parent)
        self.clef = clef

    def ly(self, printer):
        clef = self.clef if self.clef.isalpha() else '"{0}"'.format(self.clef)
        return "\\clef " + clef


class VoiceSeparator(Leaf):
    """
    A Voice Separator: \\\\
    """
    def ly(self, printer):
        return r'\\'


class Mark(Statement):
    """
    The \\mark command.
    """
    name = 'mark'


class Markup(StatementEnclosed):
    """
    The \\markup command.
    You can add many children, in that case Markup automatically prints
    { and } around them.
    """
    name = 'markup'


class MarkupEnclosed(CommandEnclosed):
    """
    A markup that auto-encloses all its arguments, like 'italic', 'bold'
    etc.  You must supply the name.
    """
    pass


class MarkupCommand(Command):
    """
    A markup command with more or no arguments, that does not auto-enclose
    its arguments. Useful for commands like note-by-number or hspace.

    You must supply the name. Its arguments are its children.
    If one argument can be a markup list, use a Enclosed() construct for that.
    """
    pass




########NEW FILE########
__FILENAME__ = duration
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
LilyPond information and logic concerning durations
"""

from __future__ import unicode_literals


from fractions import Fraction


durations = [
    '\\maxima', '\\longa', '\\breve',
    '1', '2', '4', '8', '16', '32', '64', '128', '256', '512', '1024', '2048'
]


def tostring(dur, dots=0, factor=1):
    """Returns the LilyPond string representation of a given logarithmic duration.
    
    Supports values from -3 upto and including 11.
    -2 = '\\longa', 0  = '1' (whole note), etc.
    
    Adds the number of dots (defaults to 0) and the fraction factor if given.
    
    """
    s = durations[dur + 3] + '.' * dots
    if factor != 1:
        s += '*{0}'.format(factor)
    return s


def base_scaling(tokens):
    """Return (base, scaling) as two Fractions for the list of tokens."""
    base = Fraction(8, 1 << durations.index(tokens[0]))
    scaling = Fraction(1)
    half = base
    for t in tokens[1:]:
        if t == '.':
            half /= 2
            base += half
        elif t.startswith('*'):
            scaling *= Fraction(t[1:])
    return base, scaling


def base_scaling_string(duration):
    """Return (base, scaling) as two Fractions for the specified string."""
    items = duration.split('*')
    dots = items[0].split('.')
    base = Fraction(8, 1 << durations.index(dots[0].strip()))
    scaling = Fraction(1)
    half = base
    for dot in dots[1:]:
        half /= 2
        base += half
    for f in items[1:]:
        scaling *= Fraction(f.strip())
    return base, scaling


def fraction(tokens):
    """Return the duration of the Duration tokens as a Fraction."""
    base, scaling = base_scaling(tokens)
    return base * scaling


def fraction_string(duration):
    """Return the duration of the specified string as a Fraction."""
    base, scaling = base_scaling_string(duration)
    return base * scaling


def format_fraction(value):
    """Format the value as "5/1" etc."""
    if value == 0:
        return "0"
    elif isinstance(value, Fraction):
        return "{0}/{1}".format(value.numerator, value.denominator)
    else:
        return "{0}/1".format(value)



########NEW FILE########
__FILENAME__ = etreeutil
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Utility functions for use with xml.etree.ElementTree.
"""

from __future__ import unicode_literals


def isblank(s):
    """Return True if s is empty or whitespace only."""
    return not s or s.isspace()


def indent(elem, indent_string="  ", level=0):
    """Indent the XML in element.
    
    Text content that is already non-whitespace is not changed.
    
    """
    # based on http://effbot.org/zone/element-lib.htm#prettyprint
    i = "\n" + indent_string * level
    if len(elem):
        if isblank(elem.text):
            elem.text = i + indent_string
        if isblank(elem.tail):
            elem.tail = i
        for elem in elem:
            indent(elem, indent_string, level+1)
        if isblank(elem.tail):
            elem.tail = i
    else:
        if level and isblank(elem.tail):
            elem.tail = i



########NEW FILE########
__FILENAME__ = indent
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Indent and auto-indent.
"""

from __future__ import unicode_literals

import ly.lex.lilypond
import ly.lex.scheme


class Indenter(object):
    
    # variables
    indent_tabs = False     # use tabs for indent
    indent_width = 2        # amount of spaces if indent_tabs == False
    
    def __init__(self):
        pass
    
    def indent(self, cursor, indent_blank_lines=False):
        """Indent all lines in the cursor's range.
        
        If indent_blank_lines is True, the indent of blank lines is made 
        larger if necessary. If False (the default), the indent of blank 
        lines if not changed if it is shorter than it should be.
        
        """
        indents = ['']
        start_block, end_block = cursor.start_block(), cursor.end_block()
        in_range = False
        pline = None
        prev_indent = ''
        with cursor.document as d:
            for b in cursor.document:
                if b == start_block:
                    in_range = True
                
                line = Line(d, b)
                
                # handle indents of prev line
                if pline:
                    if pline.indent != False:
                        prev_indent = pline.indent
                    if pline.indenters:
                        current_indent = indents[-1]
                        for align, indent in pline.indenters:
                            new_indent = current_indent
                            if align:
                                new_indent += ' ' * (align - len(prev_indent))
                            if indent:
                                new_indent += '\t' if self.indent_tabs else ' ' * self.indent_width
                            indents.append(new_indent)
                del indents[max(1, len(indents) - line.dedenters_start):]
                
                # if we may not change the indent just remember the current
                if line.indent is not False:
                    if not in_range:
                        indents[-1] = line.indent
                    elif not indent_blank_lines and line.isblank and indents[-1].startswith(line.indent):
                        pass # don't make shorter indents longer on blank lines
                    elif line.indent != indents[-1]:
                        d[d.position(b):d.position(b)+len(line.indent)] = indents[-1]
                del indents[max(1, len(indents) - line.dedenters_end):]
                
                if b == end_block:
                    break
                
                pline = line
    
    def increase_indent(self, cursor):
        """Manually add indent to all lines of cursor."""
        indent = '\t' if self.indent_tabs else ' ' * self.indent_width
        with cursor.document as d:
            for block in cursor.blocks():
                ins = d.position(block)
                tokens = d.tokens(block)
                if tokens and isinstance(tokens[0], ly.lex.Space):
                    tab_pos = tokens[0].rfind('\t')
                    if tab_pos != -1:
                        ins += tokens[0].pos + tab_pos + 1
                    else:
                        ins += tokens[0].end
                d[ins:ins] = indent
    
    def decrease_indent(self, cursor):
        """Manually remove one level of indent from all lines of cursor."""
        with cursor.document as d:
            for block in cursor.blocks():
                tokens = d.tokens(block)
                if tokens:
                    token = tokens[0]
                    if isinstance(token, ly.lex.Space):
                        space = token
                    else:
                        space = token[0:-len(token.lstrip())]
                    pos = d.position(block)
                    end = pos + len(space)
                    if '\t' in space and space.endswith(' '):
                        # strip alignment
                        del d[pos + space.rfind('\t') + 1 : end]
                    elif space.endswith('\t'):
                        # just strip one tab
                        del d[end - 1]
                    elif space.endswith(' ' * self.indent_width):
                        del d[end - self.indent_width: end]
                    else:
                        del d[pos:end]
    
    def get_indent(self, document, block):
        """Return the indent the block currently has.
        
        Returns False if the block is not indentable, e.g. when it is part of
        a multiline string.
        
        """
        return Line(document, block).indent
    
    def compute_indent(self, document, block):
        """Return the indent the specified block should have.
        
        Returns False if the block is not indentable, e.g. when it is part of
        a multiline string.
        
        This method is used to determine the indent of one line, and just 
        looks to previous lines, copying the indent of the line where the 
        current indent depth starts, and/or adding a level of indent or 
        alignment space.
        
        Use this method only for one line or the first of a group you're 
        indenting.
        
        """
        line = Line(document, block)
        if line.indent is False:
            return False
        depth = line.dedenters_start
        blocks = document.blocks_backward(document.previous_block(block))
        align, indent = None, False
        for b in blocks:
            line = Line(document, b)
            indents = len(line.indenters)
            if 0 <= depth < indents:
                # we found the indent token
                index = indents - depth - 1
                align, indent = line.indenters[index]
                break
            depth -= indents
            depth += line.dedenters_end
            if depth == 0:
                # same indent as this line
                break
            depth += line.dedenters_start
        else:
            return ""
        
        # here we arrive after 'break'
        i = line.indent
        if i == False:
            for b in blocks:
                i = Line(document, b).indent
                if i != False:
                    break
            else:
                i = ""
        if align:
            i += ' ' * (align - len(i))
        if indent:
            i += '\t' if self.indent_tabs else ' ' * self.indent_width
        return i


class Line(object):
    """Brings together all relevant information about a line (block)."""
    def __init__(self, document, block):
        """Initialize with a block (line) of the document.
        
        After init, the following attributes are set:
        
        indent
        
        The indent the current line has. This is a string containing 
        whitespace (i.e. spaces and/or tabs) which can be empty. A special 
        case is False, which means the current line is not indentable, e.g. 
        it is a multiline string and should never be automatically be 
        re-indented.
        
        
        isblank
        
        True if the line is empty or white-space only. It is False when the 
        indent attribute is also False (e.g. when the line is part of a 
        multiline string).
        
        
        dedenters_start
        
        The number of dedent tokens that should cause the indenter to go a 
        level up.
        
        
        dedenters_end
        
        The number of dedent tokens that should cause the next line to go a 
        level up.
        
        
        indenters
        
        A list of tuples (align, indent). Each item corresponds with an 
        indent that starts on the line. The align value (integer) determines 
        the position the next line should be padded to with spaces, 0 or 
        None means no alignment. The indent value (bool) specifies if there 
        should a new indent level be added (a tab or some amount of spaces).
        
        """
        state = document.state(block)
        tokens = document.tokens(block)
        
        # are we in a multi-line string?
        if isinstance(state.parser(), (
            ly.lex.lilypond.ParseString,
            ly.lex.scheme.ParseString,
            )):
            self.indent = False
            self.isblank = False
        # or a multi-line comment?
        elif isinstance(state.parser(), (
            ly.lex.lilypond.ParseBlockComment,
            ly.lex.scheme.ParseBlockComment,
            )):
            # do allow indent the last line of a block comment if it only
            # contains space
            if tokens and isinstance(tokens[0], ly.lex.BlockCommentEnd):
                self.indent = ""
            elif (len(tokens) > 1
                  and isinstance(tokens[0], ly.lex.BlockComment)
                  and isinstance(tokens[1], ly.lex.BlockCommentEnd)
                  and tokens[0].isspace()):
                self.indent = tokens[0]
            else:
                self.indent = False
            self.isblank = False
        elif tokens and isinstance(tokens[0], ly.lex.Space):
            self.indent = tokens[0]
            self.isblank = len(tokens) == 1
        else:
            self.indent = ""
            self.isblank = not tokens

        find_dedenters = True
        self.dedenters_start = 0
        self.dedenters_end = 0
        
        # quickly iter over the tokens, collecting the indent tokens and 
        # possible stuff to align to after the indent tokens
        indenters = []
        for t in tokens:
            if isinstance(t, ly.lex.Indent):
                find_dedenters = False
                if indenters:
                    indenters[-1].append(t)
                indenters.append([t])
            elif isinstance(t, ly.lex.Dedent):
                if find_dedenters and not isinstance(t, ly.lex.scheme.CloseParen):
                    self.dedenters_start += 1
                else:
                    find_dedenters = False
                    if indenters:
                        indenters.pop()
                    else:
                        self.dedenters_end += 1
            elif not isinstance(t, ly.lex.Space):
                find_dedenters = False
                if indenters:
                    indenters[-1].append(t)
        
        # now analyse the indent tokens that are not closed on the same line
        # and determine how the next line should be indented
        self.indenters = []
        for indent in indenters:
            token, rest = indent[0], indent[1:]
            if isinstance(token, ly.lex.scheme.OpenParen):
                if len(rest) > 1 and self.is_alignable_scheme_keyword(rest[0]):
                    align, indent = rest[1].pos, False
                elif len(rest) == 1 and not isinstance(rest[0], ly.lex.Comment):
                    align, indent = rest[0].pos, False
                else:
                    align, indent = token.pos, True
            elif rest and not isinstance(rest[0], ly.lex.Comment):
                align, indent = rest[0].pos, False
            else:
                align, indent = None, True
            self.indenters.append((align, indent))
    
    def is_alignable_scheme_keyword(self, token):
        """Return True if token is an alignable Scheme word like "if", etc."""
        return isinstance(token, ly.lex.scheme.Word) and token in (

            # Scheme commands that can have one argument on the same line and 
            # then want the next arguments on the next lines at the same 
            # position.
            'if', 'and', 'or', 'set!',
            '=', '<', '<=', '>', '>=',
            'eq?', 'eqv?', 'equal?',
            'filter',
        )


########NEW FILE########
__FILENAME__ = docbook
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Parses and tokenizes DocBook input, recognizing LilyPond in DocBook.
"""

from __future__ import unicode_literals

from . import _token
from . import Parser


class ParseDocBook(Parser):
    mode = "docbook"
    items = (
        _token.Space,
    )


########NEW FILE########
__FILENAME__ = html
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Parses and tokenizes HTML input, recognizing LilyPond in HTML.
"""

from __future__ import unicode_literals

from . import _token
from . import Parser, FallthroughParser

from . import lilypond


class Comment(_token.Comment):
    pass


class CommentStart(Comment, _token.BlockCommentStart):
    rx = r"<!--"
    def update_state(self, state):
        state.enter(ParseComment())
        
        
class CommentEnd(Comment, _token.Leaver, _token.BlockCommentEnd):
    rx = r"-->"


class String(_token.String):
    pass


class Tag(_token.Token):
    pass


class TagStart(Tag):
    rx = r"</?\w[-_:\w]*\b"
    def update_state(self, state):
        state.enter(ParseAttr())
        

class TagEnd(Tag, _token.Leaver):
    rx = r"/?>"
    

class AttrName(_token.Token):
    rx = r"\w+([-_:]\w+)?"
    
    
class EqualSign(_token.Token):
    rx = "="
    def update_state(self, state):
        state.enter(ParseValue())


class Value(_token.Leaver):
    rx = r"\w+"
    

class StringDQStart(String, _token.StringStart):
    rx = r'"'
    def update_state(self, state):
        state.enter(ParseStringDQ())


class StringSQStart(String, _token.StringStart):
    rx = r"'"
    def update_state(self, state):
        state.enter(ParseStringSQ())
    

class StringDQEnd(String, _token.StringEnd, _token.Leaver):
    rx = r'"'
    

class StringSQEnd(String, _token.StringEnd, _token.Leaver):
    rx = r"'"


class EntityRef(_token.Character):
    rx = r"\&(#\d+|#[xX][0-9A-Fa-f]+|[A-Za-z_:][\w.:_-]*);"


class LilyPondTag(Tag):
    pass


class LilyPondVersionTag(LilyPondTag):
    rx = r"<lilypondversion/?>"


class LilyPondFileTag(LilyPondTag):
    rx = r"</?lilypondfile\b"
    def update_state(self, state):
        state.enter(ParseLilyPondFileOptions())


class LilyPondFileTagEnd(LilyPondTag, _token.Leaver):
    rx = r"/?>"


class LilyPondInlineTag(LilyPondTag):
    rx = r"<lilypond\b"
    def update_state(self, state):
        state.enter(ParseLilyPondAttr())


class LilyPondCloseTag(LilyPondTag, _token.Leaver):
    rx = r"</lilypond>"
    
    
class LilyPondTagEnd(LilyPondTag):
    rx = r">"
    def update_state(self, state):
        state.replace(ParseLilyPond())


class LilyPondInlineTagEnd(LilyPondTag, _token.Leaver):
    rx = r"/?>"
    

class SemiColon(_token.Token):
    rx = r":"
    def update_state(self, state):
        state.replace(ParseLilyPondInline())



# Parsers:

class ParseHTML(Parser):
    mode = "html"
    items = (
        _token.Space,
        LilyPondVersionTag,
        LilyPondFileTag,
        LilyPondInlineTag,
        CommentStart,
        TagStart,
        EntityRef,
    )


class ParseAttr(Parser):
    items = (
        _token.Space,
        TagEnd,
        AttrName,
        EqualSign,
        StringDQStart,
        StringSQStart,
    )


class ParseStringDQ(Parser):
    default = String
    items = (
        StringDQEnd,
        EntityRef,
    )
    

class ParseStringSQ(Parser):
    default = String
    items = (
        StringSQEnd,
        EntityRef,
    )
    

class ParseComment(Parser):
    default = Comment
    items = (
        CommentEnd,
    )


class ParseValue(FallthroughParser):
    """Finds a value or drops back."""
    items = (
        _token.Space,
        Value,
    )
    def fallthrough(self, state):
        state.leave()


class ParseLilyPondAttr(Parser):
    items = (
        _token.Space,
        AttrName,
        EqualSign,
        StringDQStart,
        StringSQStart,
        LilyPondTagEnd,
        SemiColon,
    )
    

class ParseLilyPondFileOptions(Parser):
    items = (
        _token.Space,
        AttrName,
        EqualSign,
        StringDQStart,
        StringSQStart,
        LilyPondFileTagEnd,
    )


class ParseLilyPond(lilypond.ParseGlobal):
    items = (
        LilyPondCloseTag,
    ) + lilypond.ParseGlobal.items
    

class ParseLilyPondInline(lilypond.ParseMusic):
    items = (
        LilyPondInlineTagEnd,
    ) + lilypond.ParseMusic.items
    


########NEW FILE########
__FILENAME__ = latex
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Parses and tokenizes LaTeX input, recognizing LilyPond in LaTeX.
"""

from __future__ import unicode_literals

from . import _token
from . import Parser


class ParseLaTeX(Parser):
    mode = "latex"
    items = (
        _token.Space,
    )



########NEW FILE########
__FILENAME__ = lilypond
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Parses and tokenizes LilyPond input.
"""

from __future__ import unicode_literals

import itertools

from . import _token
from . import Parser, FallthroughParser


re_articulation = r"[-_^][_.>|!+^-]"
re_dynamic = (
    r"\\[<!>]|"
    r"\\(f{1,5}|p{1,5}"
    r"|mf|mp|fp|spp?|sff?|sfz|rfz"
    r"|cresc|decresc|dim|cr|decr"
    r")(?![A-Za-z])")

re_duration = r"(\\(maxima|longa|breve)\b|(1|2|4|8|16|32|64|128|256|512|1024|2048)(?!\d))"
re_dot = r"\."
re_scaling = r"\*[\t ]*\d+(/\d+)?"

# an identifier allowing letters and single hyphens inbetween
re_identifier = r"[^\W\d_]+(-[^\W\d_]+)*"

# the lookahead pattern for the end of an identifier (ref)
re_identifier_end = r"(?!-?[^\W\d])"


class Identifier(_token.Token):
    """A variable name, like "some-variable"."""
    rx = r"(?<![^\W\d])" + re_identifier + re_identifier_end


class IdentifierRef(_token.Token):
    """A reference to an identifier, e.g. "\some-variable"."""
    rx = r"\\" + re_identifier + re_identifier_end


class Variable(Identifier):
    pass


class UserVariable(Identifier):
    pass


class Value(_token.Item, _token.Numeric):
    pass


class DecimalValue(Value):
    rx = r"-?\d+(\.\d+)?"


class IntegerValue(DecimalValue):
    rx = r"\d+"


class Fraction(Value):
    rx = r"\d+/\d+"
    
    
class Delimiter(_token.Token):
    pass


class DotPath(Delimiter):
    """A dot in dotted path notation."""
    rx = r"\."


class Error(_token.Error):
    pass


class Comment(_token.Comment):
    pass


class BlockCommentStart(Comment, _token.BlockCommentStart):
    rx = r"%{"
    def update_state(self, state):
        state.enter(ParseBlockComment())


class BlockCommentEnd(Comment, _token.BlockCommentEnd, _token.Leaver):
    rx = r"%}"


class BlockComment(Comment, _token.BlockComment):
    pass


class LineComment(Comment, _token.LineComment):
    rx = r"%.*$"
    

class String(_token.String):
    pass


class StringQuotedStart(String, _token.StringStart):
    rx = r'"'
    def update_state(self, state):
        state.enter(ParseString())
        

class StringQuotedEnd(String, _token.StringEnd):
    rx = r'"'
    def update_state(self, state):
        state.leave()
        state.endArgument()


class StringQuoteEscape(_token.Character):
    rx = r'\\[\\"]'


class MusicItem(_token.Token):
    """A note, rest, spacer, \skip or q."""

    
class Skip(MusicItem):
    rx = r"\\skip" + re_identifier_end


class Spacer(MusicItem):
    rx = r"s(?![A-Za-z])"
    
    
class Rest(MusicItem):
    rx = r"[Rr](?![A-Za-z])"
    
    
class Note(MusicItem):
    rx = r"[a-x]+(?![A-Za-z])"


class Q(MusicItem):
    rx = r"q(?![A-Za-z])"


class Octave(_token.Token):
    rx = r",+|'+"


class OctaveCheck(_token.Token):
    rx = r"=(,+|'+)?"


class Accidental(_token.Token):
    pass


class AccidentalReminder(Accidental):
    rx = r"!"


class AccidentalCautionary(Accidental):
    rx = r"\?"


class Duration(_token.Token):
    pass


class Length(Duration):
    rx = re_duration
    def update_state(self, state):
        state.enter(ParseDuration())


class Dot(Duration):
    rx = re_dot
    
    
class Scaling(Duration):
    rx = re_scaling
    
    
class OpenBracket(Delimiter, _token.MatchStart, _token.Indent):
    """An open bracket, does not enter different parser, subclass or reimplement Parser.update_state()."""
    rx = r"\{"
    matchname = "bracket"


class CloseBracket(Delimiter, _token.MatchEnd, _token.Dedent):
    rx = r"\}"
    matchname = "bracket"
    def update_state(self, state):
        state.leave()
        state.endArgument()    
    

class OpenSimultaneous(Delimiter, _token.MatchStart, _token.Indent):
    """An open double French quote, does not enter different parser, subclass or reimplement Parser.update_state()."""
    rx = r"<<"
    matchname = "simultaneous"


class CloseSimultaneous(Delimiter, _token.MatchEnd, _token.Dedent):
    rx = r">>"
    matchname = "simultaneous"
    def update_state(self, state):
        state.leave()
        state.endArgument()
    

class SequentialStart(OpenBracket):
    def update_state(self, state):
        state.enter(ParseMusic())


class SequentialEnd(CloseBracket):
    pass


class SimultaneousStart(OpenSimultaneous):
    def update_state(self, state):
        state.enter(ParseMusic())


class SimultaneousEnd(CloseSimultaneous):
    pass


class PipeSymbol(Delimiter):
    rx = r"\|"


class Articulation(_token.Token):
    """Base class for articulation things."""


class ArticulationCommand(Articulation, IdentifierRef):
    @classmethod
    def test_match(cls, match):
        s = match.group()[1:]
        if '-' not in s:
            from .. import words
            for l in (
                words.articulations,
                words.ornaments,
                words.fermatas,
                words.instrument_scripts,
                words.repeat_scripts,
                words.ancient_scripts,
            ):
                if s in l:
                    return True
        return False
    
    
class Direction(_token.Token):
    rx = r"[-_^]"
    def update_state(self, state):
        state.enter(ParseScriptAbbreviationOrFingering())


class ScriptAbbreviation(Articulation, _token.Leaver):
    rx = r"[+|!>._^-]"


class Fingering(Articulation, _token.Leaver):
    rx = r"\d"


class StringNumber(Articulation):
    rx = r"\\\d+"


class Slur(_token.Token):
    pass


class SlurStart(Slur, _token.MatchStart):
    rx = r"\("
    matchname = "slur"
    

class SlurEnd(Slur, _token.MatchEnd):
    rx = r"\)"
    matchname = "slur"
    

class PhrasingSlurStart(SlurStart):
    rx = r"\\\("
    matchname = "phrasingslur"
    
    
class PhrasingSlurEnd(SlurEnd):
    rx = r"\\\)"
    matchname = "phrasingslur"
    

class Tie(Slur):
    rx = r"~"


class Beam(_token.Token):
    pass


class BeamStart(Beam, _token.MatchStart):
    rx = r"\["
    matchname = "beam"


class BeamEnd(Beam, _token.MatchEnd):
    rx = r"\]"
    matchname = "beam"


class Ligature(_token.Token):
    pass


class LigatureStart(Ligature, _token.MatchStart):
    rx = r"\\\["
    matchname = "ligature"
    
    
class LigatureEnd(Ligature, _token.MatchEnd):
    rx = r"\\\]"
    matchname = "ligature"
    
    
class Tremolo(_token.Token):
    pass


class TremoloColon(Tremolo):
    rx = r":"
    def update_state(self, state):
        state.enter(ParseTremolo())


class TremoloDuration(Tremolo, _token.Leaver):
    rx = r"\b(8|16|32|64|128|256|512|1024|2048)(?!\d)"


class ChordItem(_token.Token):
    """Base class for chordmode items."""


class ChordModifier(ChordItem):
    rx = r"((?<![a-z])|^)(aug|dim|sus|min|maj|m)(?![a-z])"


class ChordSeparator(ChordItem):
    rx = r":|\^|/\+?"


class ChordStepNumber(ChordItem):
    rx = r"\d+[-+]?"


class DotChord(ChordItem):
    rx = r"\."


class VoiceSeparator(Delimiter):
    rx = r"\\\\"
    

class Dynamic(_token.Token):
    rx = re_dynamic


class Command(_token.Item, IdentifierRef):
    @classmethod
    def test_match(cls, match):
        s = match.group()[1:]
        if '-' not in s:
            from .. import words
            return s in words.lilypond_music_commands
        return False
    

class Keyword(_token.Item, IdentifierRef):
    @classmethod
    def test_match(cls, match):
        s = match.group()[1:]
        if '-' not in s:
            from .. import words
            return s in words.lilypond_keywords
        return False


class Specifier(_token.Token):
    # a specifier of a command e.g. the name of clef or repeat style.
    pass


class Score(Keyword):
    rx = r"\\score\b"
    def update_state(self, state):
        state.enter(ExpectScore())
        

class Book(Keyword):
    rx = r"\\book\b"
    def update_state(self, state):
        state.enter(ExpectBook())
        
        
class BookPart(Keyword):
    rx = r"\\bookpart\b"
    def update_state(self, state):
        state.enter(ExpectBookPart())


class Paper(Keyword):
    rx = r"\\paper\b"
    def update_state(self, state):
        state.enter(ExpectPaper())


class Header(Keyword):
    rx = r"\\header\b"
    def update_state(self, state):
        state.enter(ExpectHeader())


class Layout(Keyword):
    rx = r"\\layout\b"
    def update_state(self, state):
        state.enter(ExpectLayout())


class Midi(Keyword):
    rx = r"\\midi\b"
    def update_state(self, state):
        state.enter(ExpectMidi())


class With(Keyword):
    rx = r"\\with\b"
    def update_state(self, state):
        state.enter(ExpectWith())


class LayoutContext(Keyword):
    rx = r"\\context\b"
    def update_state(self, state):
        state.enter(ExpectContext())


class Markup(_token.Item):
    """Base class for all markup commands."""


class MarkupStart(Markup, Command):
    rx = r"\\markup" + re_identifier_end
    def update_state(self, state):
        state.enter(ParseMarkup(1))


class MarkupLines(Markup):
    rx = r"\\markuplines" + re_identifier_end
    def update_state(self, state):
        state.enter(ParseMarkup(1))


class MarkupList(Markup):
    rx = r"\\markuplist" + re_identifier_end
    def update_state(self, state):
        state.enter(ParseMarkup(1))


class MarkupCommand(Markup, IdentifierRef):
    """A markup command."""
    @classmethod
    def test_match(cls, match):
        from .. import words
        return match.group()[1:] in words.markupcommands
    
    def update_state(self, state):
        from .. import words
        command = self[1:]
        if command in words.markupcommands_nargs[0]:
            state.endArgument()
        else:
            for argcount in 2, 3, 4, 5:
                if command in words.markupcommands_nargs[argcount]:
                    break
            else:
                argcount = 1
            state.enter(ParseMarkup(argcount))


class MarkupScore(Markup):
    rx = r"\\score\b"
    def update_state(self, state):
        state.enter(ExpectScore())


class MarkupUserCommand(Markup, IdentifierRef):
    """A user-defined markup (i.e. not in the words markupcommands list)."""
    def update_state(self, state):
        state.endArgument()


class MarkupWord(_token.Item):
    rx = r'[^{}"\\\s#%]+'


class OpenBracketMarkup(OpenBracket):
    def update_state(self, state):
        state.enter(ParseMarkup())


class CloseBracketMarkup(CloseBracket):
    def update_state(self, state):
        # go back to the opening bracket, this is the ParseMarkup
        # parser with the 0 argcount
        while state.parser().argcount > 0:
            state.leave()
        state.leave()
        state.endArgument()    


class Repeat(Command):
    rx = r"\\repeat(?![A-Za-z])"
    def update_state(self, state):
        state.enter(ParseRepeat())
    
    
class RepeatSpecifier(Specifier):
    @_token.patternproperty
    def rx():
        from .. import words
        return r"\b({0})(?![A-Za-z])".format("|".join(words.repeat_types))
    

class RepeatCount(IntegerValue, _token.Leaver):
    pass


class Tempo(Command):
    rx = r"\\tempo\b"
    def update_state(self, state):
        state.enter(ParseTempo())


class TempoSeparator(Delimiter):
    rx = r"[-~](?=\s*\d)"


class Override(Keyword):
    rx = r"\\override\b"
    def update_state(self, state):
        state.enter(ParseOverride())


class Set(Override):
    rx = r"\\set\b"
    def update_state(self, state):
        state.enter(ParseSet())
    

class Revert(Override):
    rx = r"\\revert\b"
    def update_state(self, state):
        state.enter(ParseRevert())
    

class Unset(Keyword):
    rx = r"\\unset\b"
    def update_state(self, state):
        state.enter(ParseUnset())


class Tweak(Keyword):
    rx = r"\\tweak\b"
    def update_state(self, state):
        state.enter(ParseTweak())


class Translator(Command):
    def update_state(self, state):
        state.enter(ParseTranslator())


class New(Translator):
    rx = r"\\new\b"


class Context(Translator):
    rx = r"\\context\b"


class Change(Translator):
    rx = r"\\change\b"


class AccidentalStyle(Command):
    rx = r"\\accidentalStyle\b"
    def update_state(self, state):
        state.enter(ParseAccidentalStyle())


class AccidentalStyleSpecifier(Specifier):
    @_token.patternproperty
    def rx():
        from .. import words
        return r"\b({0})(?!-?\w)".format("|".join(words.accidentalstyles))

        
class AlterBroken(Command):
    rx = r"\\alterBroken\b"
    def update_state(self, state):
        state.enter(ParseAlterBroken())


class Clef(Command):
    rx = r"\\clef\b"
    def update_state(self, state):
        state.enter(ParseClef())


class ClefSpecifier(Specifier):
    @_token.patternproperty
    def rx():
        from .. import words
        return r"\b({0})\b".format("|".join(words.clefs_plain))
    
    def update_state(self, state):
        state.leave()


class PitchCommand(Command):
    rx = r"\\(relative|transpose|transposition|key|octaveCheck)\b"
    def update_state(self, state):
        argcount = 2 if self == '\\transpose' else 1
        state.enter(ParsePitchCommand(argcount))


class KeySignatureMode(Command):
    @_token.patternproperty
    def rx():
        from .. import words
        return r"\\({0})(?![A-Za-z])".format("|".join(words.modes))

    
class Hide(Keyword):
    rx = r"\\hide\b"
    def update_state(self, state):
        state.enter(ParseHideOmit())


class Omit(Keyword):
    rx = r"\\omit\b"
    def update_state(self, state):
        state.enter(ParseHideOmit())


class Unit(Command):
    rx = r"\\(mm|cm|in|pt)\b"
    

class InputMode(Command):
    pass


class LyricMode(InputMode):
    rx = r"\\(lyricmode|((old)?add)?lyrics|lyricsto)\b"
    def update_state(self, state):
        state.enter(ExpectLyricMode())


class Lyric(_token.Item):
    """Base class for Lyric items."""


class LyricText(Lyric):
    rx = r"[^\\\s\d\"]+"


class LyricHyphen(Lyric):
    rx = r"--"
    
    
class LyricExtender(Lyric):
    rx = r"__"
    
    
class LyricSkip(Lyric):
    rx = r"_"
    

class Figure(_token.Token):
    """Base class for Figure items."""


class FigureStart(Figure):
    rx = r"<"
    def update_state(self, state):
        state.enter(ParseFigure())


class FigureEnd(Figure, _token.Leaver):
    rx = r">"


class FigureBracket(Figure):
    rx = r"[][]"


class FigureStep(Figure):
    """A step figure number or the underscore."""
    rx = r"_|\d+"


class FigureAccidental(Figure):
    """A figure accidental."""
    rx = r"[-+!]+"


class FigureModifier(Figure):
    """A figure modifier."""
    rx = r"\\[\\!+]|/"


class NoteMode(InputMode):
    rx = r"\\(notes|notemode)\b"
    def update_state(self, state):
        state.enter(ExpectNoteMode())


class ChordMode(InputMode):
    rx = r"\\(chords|chordmode)\b"
    def update_state(self, state):
        state.enter(ExpectChordMode())


class DrumMode(InputMode):
    rx = r"\\(drums|drummode)\b"
    def update_state(self, state):
        state.enter(ExpectDrumMode())


class FigureMode(InputMode):
    rx = r"\\(figures|figuremode)\b"
    def update_state(self, state):
        state.enter(ExpectFigureMode())


class UserCommand(IdentifierRef):
    pass
    

class SimultaneousOrSequentialCommand(Keyword):
    rx = r"\\(simultaneous|sequential)\b"


class SchemeStart(_token.Item):
    rx = "[#$](?![{}])"
    def update_state(self, state):
        from . import scheme
        state.enter(scheme.ParseScheme(1))


class ContextName(_token.Token):
    @_token.patternproperty
    def rx():
        from .. import words
        return r"\b({0})\b".format("|".join(words.contexts))
    

class BackSlashedContextName(ContextName):
    @_token.patternproperty
    def rx():
        from .. import words
        return r"\\({0})\b".format("|".join(words.contexts))
    
    
class GrobName(_token.Token):
    @_token.patternproperty
    def rx():
        from .. import data
        return r"\b({0})\b".format("|".join(data.grobs()))


class GrobProperty(Variable):
    rx = r"\b([a-z]+|[XY])(-([a-z]+|[XY]))*(?![\w])"


class ContextProperty(Variable):
    @_token.patternproperty
    def rx():
        from .. import data
        return r"\b({0})\b".format("|".join(data.context_properties()))


class PaperVariable(Variable):
    """A variable inside Paper. Always follow this one by UserVariable."""
    @classmethod
    def test_match(cls, match):
        from .. import words
        return match.group() in words.papervariables


class HeaderVariable(Variable):
    """A variable inside Header. Always follow this one by UserVariable."""
    @classmethod
    def test_match(cls, match):
        from .. import words
        return match.group() in words.headervariables


class LayoutVariable(Variable):
    """A variable inside Header. Always follow this one by UserVariable."""
    @classmethod
    def test_match(cls, match):
        from .. import words
        return match.group() in words.layoutvariables


class Chord(_token.Token):
    """Base class for Chord delimiters."""
    pass


class ChordStart(Chord):
    rx = r"<"
    def update_state(self, state):
        state.enter(ParseChord())


class ChordEnd(Chord, _token.Leaver):
    rx = r">"
    

class ErrorInChord(Error):
    rx = "|".join((
        re_articulation, # articulation
        r"<<|>>", # double french quotes
        r"\\[\\\]\[\(\)()]", # slurs beams
        re_duration, # duration
        re_scaling, # scaling
    ))
    

class Name(UserVariable):
    """A variable name without \\ prefix."""
    

class EqualSign(_token.Token):
    rx = r"="
    

# Parsers
class ParseLilyPond(Parser):
    mode = 'lilypond'

# basic stuff that can appear everywhere
space_items = (
    _token.Space,
    BlockCommentStart,
    LineComment,
)    


base_items = space_items + (
    SchemeStart,
    StringQuotedStart,
)


# items that represent commands in both toplevel and music mode
command_items = (
    Repeat,
    PitchCommand,
    Override, Revert,
    Set, Unset,
    Hide, Omit,
    Tweak,
    New, Context, Change,
    With,
    Clef,
    Tempo,
    KeySignatureMode,
    AccidentalStyle,
    AlterBroken,
    SimultaneousOrSequentialCommand,
    ChordMode, DrumMode, FigureMode, LyricMode, NoteMode,
    MarkupStart, MarkupLines, MarkupList,
    ArticulationCommand,
    Keyword,
    Command,
    SimultaneousOrSequentialCommand,
    UserCommand,
)


# items that occur in toplevel, book, bookpart or score
# no Leave-tokens!
toplevel_base_items = base_items + (
    SequentialStart,
    SimultaneousStart,
) + command_items


# items that occur in music expressions
music_items = base_items + (
    Dynamic,
    Skip,
    Spacer,
    Q,
    Rest,
    Note,
    Fraction,
    Length,
    Octave,
    OctaveCheck,
    AccidentalCautionary,
    AccidentalReminder,
    PipeSymbol,
    VoiceSeparator,
    SequentialStart, SequentialEnd,
    SimultaneousStart, SimultaneousEnd,
    ChordStart,
    ContextName,
    GrobName,
    SlurStart, SlurEnd,
    PhrasingSlurStart, PhrasingSlurEnd,
    Tie,
    BeamStart, BeamEnd,
    LigatureStart, LigatureEnd,
    Direction,
    StringNumber,
    IntegerValue,
) + command_items
    

# items that occur inside chords
music_chord_items = (
    ErrorInChord,
    ChordEnd,
) + music_items



class ParseGlobal(ParseLilyPond):
    """Parses LilyPond from the toplevel of a file."""
    items = (
        Book,
        BookPart,
        Score,
        MarkupStart, MarkupLines, MarkupList,
        Paper, Header, Layout,
    ) + toplevel_base_items + (
        Name,
        DotPath,
        EqualSign,
    )
    def update_state(self, state, token):
        if isinstance(token, EqualSign):
            state.enter(ParseGlobalAssignment())


class ParseGlobalAssignment(FallthroughParser, ParseLilyPond):
    items = space_items + (
        Skip,
        Spacer,
        Q,
        Rest,
        Note,
        Length,
        Fraction,
        DecimalValue,
        Direction,
        StringNumber,
        Dynamic,
    )


class ExpectOpenBracket(FallthroughParser, ParseLilyPond):
    """Waits for an OpenBracket and then replaces the parser with the class set in the replace attribute.
    
    Subclass this to set the destination for the OpenBracket.
    
    """
    default = Error
    items = space_items + (
        OpenBracket,
    )
    def update_state(self, state, token):
        if isinstance(token, OpenBracket):
            state.replace(self.replace())
        

class ExpectMusicList(FallthroughParser, ParseLilyPond):
    """Waits for an OpenBracket or << and then replaces the parser with the class set in the replace attribute.
    
    Subclass this to set the destination for the OpenBracket.
    
    """
    items = space_items + (
        OpenBracket,
        OpenSimultaneous,
        SimultaneousOrSequentialCommand,
    )
    def update_state(self, state, token):
        if isinstance(token, (OpenBracket, OpenSimultaneous)):
            state.replace(self.replace())
        

class ParseScore(ParseLilyPond):
    """Parses the expression after \score {, leaving at } """
    items = (
        CloseBracket,
        Header, Layout, Midi, With,
    ) + toplevel_base_items


class ExpectScore(ExpectOpenBracket):
    replace = ParseScore
            

class ParseBook(ParseLilyPond):
    """Parses the expression after \book {, leaving at } """
    items = (
        CloseBracket,
        MarkupStart, MarkupLines, MarkupList,
        BookPart,
        Score,
        Paper, Header, Layout,
    ) + toplevel_base_items



class ExpectBook(ExpectOpenBracket):
    replace = ParseBook


class ParseBookPart(ParseLilyPond):
    """Parses the expression after \bookpart {, leaving at } """
    items = (
        CloseBracket,
        MarkupStart, MarkupLines, MarkupList,
        Score,
        Paper, Header, Layout,
    ) + toplevel_base_items


class ExpectBookPart(ExpectOpenBracket):
    replace = ParseBookPart


class ParsePaper(ParseLilyPond):
    """Parses the expression after \paper {, leaving at } """
    items = base_items + (
        CloseBracket,
        MarkupStart, MarkupLines, MarkupList,
        PaperVariable,
        UserVariable,
        EqualSign,
        DotPath,
        DecimalValue,
        Unit,
    )


class ExpectPaper(ExpectOpenBracket):
    replace = ParsePaper


class ParseHeader(ParseLilyPond):
    """Parses the expression after \header {, leaving at } """
    items = (
        CloseBracket,
        MarkupStart, MarkupLines, MarkupList,
        HeaderVariable,
        UserVariable,
        EqualSign,
        DotPath,
    ) + toplevel_base_items


class ExpectHeader(ExpectOpenBracket):
    replace = ParseHeader
        

class ParseLayout(ParseLilyPond):
    """Parses the expression after \layout {, leaving at } """
    items = base_items + (
        CloseBracket,
        LayoutContext,
        LayoutVariable,
        UserVariable,
        EqualSign,
        DotPath,
        DecimalValue,
        Unit,
        ContextName,
        GrobName,
    ) + command_items


class ExpectLayout(ExpectOpenBracket):
    replace = ParseLayout
        

class ParseMidi(ParseLilyPond):
    """Parses the expression after \midi {, leaving at } """
    items = base_items + (
        CloseBracket,
        LayoutContext,
        LayoutVariable,
        UserVariable,
        EqualSign,
        DotPath,
        DecimalValue,
        Unit,
        ContextName,
        GrobName,
    ) + command_items


class ExpectMidi(ExpectOpenBracket):
    replace = ParseMidi


class ParseWith(ParseLilyPond):
    """Parses the expression after \with {, leaving at } """
    items = (
        CloseBracket,
        ContextName,
        GrobName,
        ContextProperty,
        EqualSign,
        DotPath,
    ) + toplevel_base_items


class ExpectWith(ExpectOpenBracket):
    replace = ParseWith
        

class ParseContext(ParseLilyPond):
    """Parses the expression after (\layout {) \context {, leaving at } """
    items = (
        CloseBracket,
        BackSlashedContextName,
        ContextProperty,
        EqualSign,
        DotPath,
    ) + toplevel_base_items


class ExpectContext(ExpectOpenBracket):
    replace = ParseContext
        

class ParseMusic(ParseLilyPond):
    """Parses LilyPond music expressions."""
    items = music_items + (
        TremoloColon,
    )
    

class ParseChord(ParseMusic):
    """LilyPond inside chords < >"""
    items = music_chord_items


class ParseString(Parser):
    default = String
    items = (
        StringQuotedEnd,
        StringQuoteEscape,
    )
    

class ParseBlockComment(Parser):
    default = BlockComment
    items = (
        BlockCommentEnd,
    )


class ParseMarkup(Parser):
    items =  (
        MarkupScore,
        MarkupCommand,
        MarkupUserCommand,
        OpenBracketMarkup,
        CloseBracketMarkup,
        MarkupWord,
    ) + base_items


class ParseRepeat(FallthroughParser):
    items = space_items + (
        RepeatSpecifier,
        StringQuotedStart,
        RepeatCount,
    )


class ParseTempo(FallthroughParser):
    items = space_items + (
        MarkupStart,
        StringQuotedStart,
        SchemeStart,
        Length,
        EqualSign,
    )
    def update_state(self, state, token):
        if isinstance(token, EqualSign):
            state.replace(ParseTempoAfterEqualSign())


class ParseTempoAfterEqualSign(FallthroughParser):
    items = space_items + (
        IntegerValue,
        TempoSeparator,
    )


class ParseDuration(FallthroughParser):
    items = space_items + (
        Dot,
    )
    def fallthrough(self, state):
        state.replace(ParseDurationScaling())
        
        
class ParseDurationScaling(ParseDuration):
    items = space_items + (
        Scaling,
    )
    def fallthrough(self, state):
        state.leave()


class ParseOverride(ParseLilyPond):
    argcount = 0
    items = (
        ContextName,
        DotPath,
        GrobName,
        GrobProperty,
        EqualSign,
    ) + base_items
    def update_state(self, state, token):
        if isinstance(token, EqualSign):
            state.replace(ParseDecimalValue())


class ParseRevert(FallthroughParser):
    # parse the arguments of \revert
    # allow both the old scheme syntax but also the dotted 2.18+ syntax
    # allow either a dot between the GrobName and the property path or not
    # correctly fall through when one property path has been parsed
    # (uses ParseGrobPropertyPath and ExpectGrobProperty)
    # (When the old scheme syntax is used this parser also falls through,
    # assuming that the previous parser will handle it)
    items = space_items + (
        ContextName,
        DotPath,
        GrobName,
        GrobProperty,
    )
    def update_state(self, state, token):
        if isinstance(token, GrobProperty):
            state.replace(ParseGrobPropertyPath())

    
class ParseGrobPropertyPath(FallthroughParser):
    items = space_items + (
        DotPath,
    )
    def update_state(self, state, token):
        if isinstance(token, DotPath):
            state.enter(ExpectGrobProperty())


class ExpectGrobProperty(FallthroughParser):
    items = space_items + (
        GrobProperty,
    )
    def update_state(self, state, token):
        if isinstance(token, GrobProperty):
            state.leave()


class ParseSet(ParseLilyPond):
    argcount = 0
    items = (
        ContextName,
        DotPath,
        ContextProperty,
        EqualSign,
        Name,
    ) + base_items
    def update_state(self, state, token):
        if isinstance(token, EqualSign):
            state.replace(ParseDecimalValue())

    
class ParseUnset(FallthroughParser):
    items = space_items + (
        ContextName,
        DotPath,
        ContextProperty,
        Name,
    )
    def update_state(self, state, token):
        if isinstance(token, ContextProperty) or token[:1].islower():
            state.leave()


class ParseTweak(FallthroughParser):
    items = space_items + (
        GrobName,
        DotPath,
        GrobProperty,
    )
    def update_state(self, state, token):
        if isinstance(token, GrobProperty):
            state.replace(ParseTweakGrobProperty())


class ParseTweakGrobProperty(FallthroughParser):
    items = space_items + (
        DotPath,
        DecimalValue,
    )
    def update_state(self, state, token):
        if isinstance(token, DotPath):
            state.enter(ExpectGrobProperty())
        elif isinstance(token, DecimalValue):
            state.leave()


class ParseTranslator(FallthroughParser):
    items = space_items + (
        ContextName,
        Name,
    )
    
    def update_state(self, state, token):
        if isinstance(token, (Name, ContextName)):
            state.replace(ExpectTranslatorId())


class ExpectTranslatorId(FallthroughParser):
    items = space_items + (
        EqualSign,
    )
    
    def update_state(self, state, token):
        if token == '=':
            state.replace(ParseTranslatorId())


class ParseTranslatorId(FallthroughParser):
    argcount = 1
    items = space_items + (
        Name,
        StringQuotedStart,
    )
    
    def update_state(self, state, token):
        if isinstance(token, Name):
            state.leave()


class ParseClef(FallthroughParser):
    argcount = 1
    items = space_items + (
        ClefSpecifier,
        StringQuotedStart,
    )


class ParseHideOmit(FallthroughParser):
    items = space_items + (
        ContextName,
        DotPath,
        GrobName,
    )
    def update_state(self, state, token):
        if isinstance(token, GrobName):
            state.leave()


class ParseAccidentalStyle(FallthroughParser):
    items = space_items + (
        ContextName,
        DotPath,
        AccidentalStyleSpecifier,
    )
    def update_state(self, state, token):
        if isinstance(token, AccidentalStyleSpecifier):
            state.leave()


class ParseAlterBroken(FallthroughParser):
    items = space_items + (
        GrobProperty,
    )
    def update_state(self, state, token):
        if isinstance(token, GrobProperty):
            state.replace(ParseGrobPropertyPath())


class ParseScriptAbbreviationOrFingering(FallthroughParser):
    argcount = 1
    items = space_items + (
        ScriptAbbreviation,
        Fingering,
    )


class ParseInputMode(ParseLilyPond):
    """Base class for parser for mode-changing music commands."""
    @classmethod
    def update_state(cls, state, token):
        if isinstance(token, (OpenSimultaneous, OpenBracket)):
            state.enter(cls())
    
    
class ParseLyricMode(ParseInputMode):
    """Parser for \\lyrics, \\lyricmode, \\addlyrics, etc."""
    items = base_items + (
        CloseBracket,
        CloseSimultaneous,
        OpenBracket,
        OpenSimultaneous,
        PipeSymbol,
        LyricHyphen,
        LyricExtender,
        LyricSkip,
        LyricText,
        Dynamic,
        Skip,
        Length,
        MarkupStart, MarkupLines, MarkupList,
    ) + command_items


class ExpectLyricMode(ExpectMusicList):
    replace = ParseLyricMode
    items = space_items + (
        OpenBracket,
        OpenSimultaneous,
        SchemeStart,
        StringQuotedStart,
        Name,
        SimultaneousOrSequentialCommand,
    )


class ParseChordMode(ParseInputMode, ParseMusic):
    """Parser for \\chords and \\chordmode."""
    items = (
        OpenBracket,
        OpenSimultaneous,
    ) + music_items + ( # TODO: specify items exactly, e.g. < > is not allowed
        ChordSeparator,
    )
    def update_state(self, state, token):
        if isinstance(token, ChordSeparator):
            state.enter(ParseChordItems())
        else:
            super(ParseChordMode, self).update_state(state, token)


class ExpectChordMode(ExpectMusicList):
    replace = ParseChordMode
        

class ParseNoteMode(ParseMusic):
    """Parser for \\notes and \\notemode. Same as Music itself."""


class ExpectNoteMode(ExpectMusicList):
    replace = ParseNoteMode
        

class ParseDrumMode(ParseInputMode, ParseMusic):
    """Parser for \\drums and \\drummode."""
    # TODO: implement items (see ParseChordMode)


class ExpectDrumMode(ExpectMusicList):
    replace = ParseDrumMode
        

class ParseFigureMode(ParseInputMode, ParseMusic):
    """Parser for \\figures and \\figuremode."""
    items = base_items + (
        CloseBracket,
        CloseSimultaneous,
        OpenBracket,
        OpenSimultaneous,
        PipeSymbol,
        FigureStart,
        Skip, Spacer, Rest,
        Length,
    ) + command_items


class ParseFigure(Parser):
    """Parse inside < > in figure mode."""
    items = base_items + (
        FigureEnd,
        FigureBracket,
        FigureStep,
        FigureAccidental,
        FigureModifier,
        MarkupStart, MarkupLines, MarkupList,
    )


class ExpectFigureMode(ExpectMusicList):
    replace = ParseFigureMode
        

class ParsePitchCommand(FallthroughParser):
    argcount = 1
    items = space_items + (
        Note,
        Octave,
    )
    def update_state(self, state, token):
        if isinstance(token, Note):
            self.argcount -= 1
        elif isinstance(token, _token.Space) and self.argcount <= 0:
            state.leave()


class ParseTremolo(FallthroughParser):
    items = (TremoloDuration,)


class ParseChordItems(FallthroughParser):
    items = (
        ChordSeparator,
        ChordModifier,
        ChordStepNumber,
        DotChord,
        Note,
    )


class ParseDecimalValue(FallthroughParser):
    """Parses a decimal value without a # before it (if present)."""
    items = space_items + (
        DecimalValue,
    )



########NEW FILE########
__FILENAME__ = scheme
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Parses and tokenizes Scheme input.
"""

from __future__ import unicode_literals

from . import _token
from . import Parser, FallthroughParser


class Scheme(_token.Token):
    """Baseclass for Scheme tokens."""
    pass


class String(_token.String):
    pass


class StringQuotedStart(String, _token.StringStart):
    rx = r'"'
    def update_state(self, state):
        state.enter(ParseString())
        

class StringQuotedEnd(String, _token.StringEnd):
    rx = r'"'
    def update_state(self, state):
        state.leave()
        state.endArgument()
    

class StringQuoteEscape(_token.Character):
    rx = r'\\[\\"]'


class Comment(_token.Comment):
    pass


class LineComment(Comment, _token.LineComment):
    rx = r";.*$"
    

class BlockCommentStart(Comment, _token.BlockCommentStart):
    rx = r"#!"
    def update_state(self, state):
        state.enter(ParseBlockComment())
        

class BlockCommentEnd(Comment, _token.BlockCommentEnd, _token.Leaver):
    rx = "!#"


class BlockComment(Comment, _token.BlockComment):
    pass


class OpenParen(Scheme, _token.MatchStart, _token.Indent):
    rx = r"\("
    matchname = "schemeparen"
    def update_state(self, state):
        state.enter(ParseScheme())


class CloseParen(Scheme, _token.MatchEnd, _token.Dedent):
    rx = r"\)"
    matchname = "schemeparen"
    def update_state(self, state):
        state.leave()
        state.endArgument()
        

class Quote(Scheme):
    rx = r"['`,]"
    
    
class Dot(Scheme):
    rx = r"\.(?!\S)"


class Bool(Scheme, _token.Item):
    rx = r"#[tf]\b"
    
    
class Char(Scheme, _token.Item):
    rx = r"#\\([a-z]+|.)"


class Word(Scheme, _token.Item):
    rx = r'[^()"{}\s]+'


class Keyword(Word):
    @classmethod
    def test_match(cls, match):
        from .. import data
        return match.group() in data.scheme_keywords()


class Function(Word):
    @classmethod
    def test_match(cls, match):
        from .. import data
        return match.group() in data.scheme_functions()


class Variable(Word):
    @classmethod
    def test_match(cls, match):
        from .. import data
        return match.group() in data.scheme_variables()


class Constant(Word):
    @classmethod
    def test_match(cls, match):
        from .. import data
        return match.group() in data.scheme_constants()


class Number(_token.Item, _token.Numeric):
    rx = (r"("
          r"-?\d+|"
          r"#(b[0-1]+|o[0-7]+|x[0-9a-fA-F]+)|"
          r"[-+]inf.0|[-+]?nan.0"
          r")(?=$|[)\s])")


class Fraction(Number):
    rx = r"-?\d+/\d+(?=$|[)\s])"


class Float(Number):
    rx = r"-?((\d+(\.\d*)|\.\d+)(E\d+)?)(?=$|[)\s])"


class LilyPond(_token.Token):
    pass


class LilyPondStart(LilyPond, _token.MatchStart, _token.Indent):
    rx = r"#{"
    matchname = "schemelily"
    def update_state(self, state):
        state.enter(ParseLilyPond())
        

class LilyPondEnd(LilyPond, _token.Leaver, _token.MatchEnd, _token.Dedent):
    rx = r"#}"
    matchname = "schemelily"


# Parsers

class ParseScheme(Parser):
    mode = 'scheme'
    items = (
        _token.Space,
        OpenParen,
        CloseParen,
        LineComment,
        BlockCommentStart,
        LilyPondStart,
        Dot,
        Bool,
        Char,
        Quote,
        Fraction,
        Float,
        Number,
        Constant,
        Keyword,
        Function,
        Variable,
        Word,
        StringQuotedStart,
    )
    

class ParseString(Parser):
    default = String
    items = (
        StringQuotedEnd,
        StringQuoteEscape,
    )
    

class ParseBlockComment(Parser):
    default = BlockComment
    items = (
        BlockCommentEnd,
    )


from . import lilypond

class ParseLilyPond(lilypond.ParseMusic):
    items = (LilyPondEnd,) + lilypond.ParseMusic.items


########NEW FILE########
__FILENAME__ = texinfo
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Parses and tokenizes Texinfo input, recognizing LilyPond in Texinfo.
"""

from __future__ import unicode_literals

from . import _token
from . import Parser, FallthroughParser


class Comment(_token.Comment):
    pass


class LineComment(Comment, _token.LineComment):
    rx = r"@c\b.*$"


class BlockCommentStart(Comment, _token.BlockCommentStart):
    rx = r"@ignore\b"
    def update_state(self, state):
        state.enter(ParseComment())
        
        
class BlockCommentEnd(Comment, _token.Leaver, _token.BlockCommentEnd):
    rx = r"@end\s+ignore\b"


class Attribute(_token.Token):
    pass


class Keyword(_token.Token):
    rx = r"@[a-zA-Z]+"


class Block(_token.Token):
    pass


class BlockStart(Block):
    rx = r"@[a-zA-Z]+\{"
    def update_state(self, state):
        state.enter(ParseBlock())


class BlockEnd(Block, _token.Leaver):
    rx = r"\}"


class EscapeChar(_token.Character):
    rx = r"@[@{}]"
    

class Accent(EscapeChar):
    rx = "@['\"',=^`~](\\{[a-zA-Z]\\}|[a-zA-Z]\\b)"


class Verbatim(_token.Token):
    pass


class VerbatimStart(Keyword):
    rx = r"@verbatim\b"
    def update_state(self, state):
        state.enter(ParseVerbatim())


class VerbatimEnd(Keyword, _token.Leaver):
    rx = r"@end\s+verbatim\b"
    
    
class LilyPondBlockStart(Block):
    rx = r"@lilypond(?=(\[[a-zA-Z,=0-9\\\s]+\])?\{)"
    def update_state(self, state):
        state.enter(ParseLilyPondBlockAttr())


class LilyPondBlockStartBrace(Block):
    rx = r"\{"
    def update_state(self, state):
        state.replace(ParseLilyPondBlock())


class LilyPondBlockEnd(Block, _token.Leaver):
    rx = r"\}"
    
    
class LilyPondEnvStart(Keyword):
    rx = r"@lilypond\b"
    def update_state(self, state):
        state.enter(ParseLilyPondEnvAttr())
    
    
class LilyPondEnvEnd(Keyword, _token.Leaver):
    rx = r"@end\s+lilypond\b"


class LilyPondFileStart(Block):
    rx = r"@lilypondfile\b"
    def update_state(self, state):
        state.enter(ParseLilyPondFile())


class LilyPondFileStartBrace(Block):
    rx = r"\{"
    def update_state(self, state):
        state.replace(ParseBlock())


class LilyPondAttrStart(Attribute):
    rx = r"\["
    def update_state(self, state):
        state.enter(ParseLilyPondAttr())
    
    
class LilyPondAttrEnd(Attribute, _token.Leaver):
    rx = r"\]"


# Parsers:

class ParseTexinfo(Parser):
    mode = "texinfo"
    items = (
        LineComment,
        BlockCommentStart,
        Accent,
        EscapeChar,
        LilyPondBlockStart,
        LilyPondEnvStart,
        LilyPondFileStart,
        BlockStart,
        VerbatimStart,
        Keyword,
    )


class ParseComment(Parser):
    default = Comment
    items = (
        BlockCommentEnd,
    )


class ParseBlock(Parser):
    items = (
        BlockEnd,
        Accent,
        EscapeChar,
        BlockStart,
        Keyword,
    )


class ParseVerbatim(Parser):
    default = Verbatim
    items = (
        VerbatimEnd,
    )


class ParseLilyPondBlockAttr(Parser):
    items = (
        LilyPondAttrStart,
        LilyPondBlockStartBrace,
    )


class ParseLilyPondEnvAttr(FallthroughParser):
    items = (
        LilyPondAttrStart,
    )
    def fallthrough(self, state):
        state.replace(ParseLilyPondEnv())


class ParseLilyPondAttr(Parser):
    default = Attribute
    items = (
        LilyPondAttrEnd,
    )


class ParseLilyPondFile(Parser):
    items = (
        LilyPondAttrStart,
        LilyPondFileStartBrace,
    )


from . import lilypond

class ParseLilyPondBlock(lilypond.ParseGlobal):
    items = (
        LilyPondBlockEnd,
    ) + lilypond.ParseGlobal.items


class ParseLilyPondEnv(lilypond.ParseGlobal):
    items = (
        LilyPondEnvEnd,
    ) + lilypond.ParseGlobal.items
    


########NEW FILE########
__FILENAME__ = _mode
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Registry for the different modes used by the tokenizer.


There are two items in this module:

1. the modes dictionary.

   This maps a mode name to a function returning the base parser class for
   that mode.  (This way the corresponding module only needs to be imported
   when the mode is really needed.)
   
2. the guessMode function.

   This tries to guess the type of the given text and returns a mode name.
   
   
You can easily add more modes in separate modules and mention them here,

Don't use this module directly!  modes and guessMode are imported in the main
tokenize module.

"""

from __future__ import unicode_literals

__all__ = ['modes', 'guessMode']


def _modes():
    """Returns a dictionary mapping a mode name to a function.
    
    The function should return the initial Parser instance for that mode.
    
    """
    
    def lilypond():
        from . import lilypond
        return lilypond.ParseGlobal
    
    def scheme():
        from . import scheme
        return scheme.ParseScheme
        
    def docbook():
        from . import docbook
        return docbook.ParseDocBook
        
    def latex():
        from . import latex
        return latex.ParseLaTeX
        
    def texinfo():
        from . import texinfo
        return texinfo.ParseTexinfo
        
    def html():
        from . import html
        return html.ParseHTML
        
    # more modes can be added here
    return locals()
    

# dictionary mapping mode name to a function returning initial parser instance
# for that mode. Can also be used to test the existence of a mode
modes = _modes()
del _modes


def guessMode(text):
    """Tries to guess the type of the input text, using a quite fast heuristic.
    
    Returns one of the strings also present as key in the modes dictionary.
    
    """
    text = text.lstrip()
    if text.startswith(('%', '\\')):
        if '\\version' in text or '\\relative' in text or '\\score' in text:
            return "lilypond"
        if "\\documentclass" in text or "\\begin{document}" in text:
            return "latex"
        return "lilypond"
    if text.startswith("<<"):
        return "lilypond"
    if text.startswith("<"):
        if 'DOCTYPE book' in text or "<programlisting" in text:
            return "docbook"
        else:
            return "html"
    if text.startswith(("#!", ";", "(")):
        return "scheme"
    if text.startswith('@'):
        return "texinfo"
    return "lilypond"



# dictionary mapping mode name to a default extension for a file of that mode.
extensions = {
    'lilypond': '.ly',
    'html':     '.html',
    'scheme':   '.scm',
    'latex':    '.lytex',
    'texinfo':  '.texi',
    'docbook':  '.docbook',
}


########NEW FILE########
__FILENAME__ = _token
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Token base classes.

Don't use this module directly!
All important classes are imported in the ly.lex namespace.

You can, however, import _token in mode modules that also are in this directory.

This module starts with an underscore so that its name does not interfere with
the mode modules.

"""

from __future__ import unicode_literals


import slexer


class Token(slexer.Token):
    def __repr__(self):
        c = self.__class__
        module = c.__module__.rsplit('.', 1)[-1]
        name = c.__name__
        contents = slexer.Token.__repr__(self)
        where = self.pos
        return '<{0}.{1} {2} at {3}>'.format(module, name, contents, where)


class patternproperty(object):
    """Property that caches the return value of its function and returns that next time.
    
    Use this if the rx attribute (the pattern string to match tokens for) of a Token subclass
    is already costly to create and you want it created lazily (i.e. only when parsing starts):
    
    @patternproperty
    def rx():
        ...complicated function returning the regular expression string...
    
    """
    def __init__(self, func):
        self.func = func
        
    def __get__(self, instance, owner):
        try:
            return self.rx
        except AttributeError:
            self.rx = self.func()
            return self.rx


class Unparsed(Token):
    """Represents an unparsed piece of input text."""


# some token types with special behaviour:
class Item(Token):
    """A token that decreases the argument count of the current parser."""
    def update_state(self, state):
        state.endArgument()


class Leaver(Token):
    """A token that leaves the current parser."""
    def update_state(self, state):
        state.leave()


# some generic types:
class Space(Token):
    """A token containing whitespace."""
    rx = r'\s+'


class Newline(Space):
    """A token that is a single newline."""
    rx = r'\n'


# some base types that should be inherited:
class Comment(Token):
    """Base class for tokens that belong to a comment."""


class LineComment(Comment):
    """Base class for items that are a whole line comment."""
    
    
class BlockComment(Comment):
    """Base class for tokens that belong to a block/multiline comment."""


class BlockCommentStart(BlockComment):
    """Base class for tokens that start a block/multiline comment."""


class BlockCommentEnd(BlockComment):
    """Base class for tokens that end a block/multiline comment."""


class String(Token):
    """Base class for tokens that belong to a quote-delimited string."""
    
    
class StringStart(String):
    """Base class for tokens that start a quote-delimited string."""
    
    
class StringEnd(String):
    """Base class for tokens that end a quote-delimited string."""
    
    
class Character(Token):
    """Base class for tokens that are an (escaped) character."""
    
    
class Numeric(Token):
    """Base class for tokens that are a numerical value."""
    
    
class Error(Token):
    """Base class for tokens that represent erroneous input."""


# some mixin classes that make special handling of tokens possible besides correct parsing:

# MatchEnd and MatchStart can be used by parenthesis/brace matcher.
# the matchname class attribute defines the type, so that it is independent
# of the way other types could be nested.
class MatchStart(object):
    """Mixin class for tokens that have a matching token forward in the text.
    
    The matchname attribute should give a unique name.
    
    """
    matchname = ""


class MatchEnd(object):
    """Mixin class for tokens that have a matching token backward in the text.
    
    The matchname attribute should give a unique name.
    
    """
    matchname = ""


# Indent and Dedent can be used by an (auto) indenter.
class Indent(object):
    """Mixin class for tokens that have the text on the next line indent more."""


class Dedent(object):
    """Mixin class for tokens that have the text on the next line indent less."""



########NEW FILE########
__FILENAME__ = event
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2014 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Translates a music.items.Document tree into lists of events.

"""

from __future__ import unicode_literals


class Events(object):
    """Traverses a music tree and records music events from it."""
    unfold_repeats = False
    
    def read(self, node, time=0, scaling=1):
        """Read events from the node and all its child nodes; return time."""
        return self.traverse(node, time, scaling)
    
    def traverse(self, node, time, scaling):
        """Traverse node and call event handlers; record and return the time."""
        return node.events(self, time, scaling)



########NEW FILE########
__FILENAME__ = items
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2014 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The items a music expression is constructed with in a tree structure.

Whitespace and comments are left out.

All nodes (instances of Item) have a 'position' attribute that indicates 
where the item starts in the source text. Almost all items have the token 
that starts the expression in the 'token' attribute and possibly other 
tokens in the 'tokens' attribute, as a tuple. 

The 'end_position()' method returns the position where the node (including 
its child nodes) ends.


"""

from __future__ import unicode_literals

from fractions import Fraction
import re

import node

from ly import lex
from ly.lex import lilypond
from ly.lex import scheme


class Item(node.WeakNode):
    """Represents any item in the music of a document.
    
    This can be just a token, or an interpreted construct such as a note,
    rest or sequential or simultaneous construct , etc.
    
    Some Item instances just have one responsible token, but others have a
    list or tuple to tokens.
    
    An Item also has a pointer to the Document it originates from.
    
    """
    document = None
    tokens = ()
    token = None
    position = -1

    def __repr__(self):
        s = ' ' + repr(self.token[:]) if self.token else ''
        return '<{0}{1}>'.format(self.__class__.__name__, s)
    
    def end_position(self):
        """Return the end position of this node."""
        def ends():
            if self.tokens:
                yield self.tokens[-1].end
            elif self.token:
                yield self.token.end
            else:
                yield self.position
            if len(self):
                # end pos of the last child
                yield self[-1].end_position()
            # end pos of Item or Token instances in attributes, such as duration etc
            for i in vars(self).values():
                if isinstance(i, Item):
                    yield i.end_position()
                elif isinstance(i, lex.Token):
                    yield i.end
        return max(ends())
    
    def events(self, e, time, scaling):
        """Let the event.Events instance handle the events. Return the time."""
        return time
    
    def length(self):
        """Return the musical duration."""
        return 0
    
    def iter_toplevel_items(self):
        """Yield the toplevel items of our Document node in backward direction.
        
        Iteration starts with the node just before the node "self" is a 
        descendant of.
        
        """
        node = self
        for doc in self.ancestors():
            if isinstance(doc, Document):
                break
            node = doc
        else:
            return
        
        # now, doc is the Document node, and node is the child of the Document
        # node we are a (far) descendant of
        for i in node.backward():
            yield i
        
        # look in parent Document before the place we were included
        while doc.include_node:
            p = doc.include_node.parent()
            if isinstance(p, Document):
                for i in doc.include_node.backward():
                    yield i
                doc = p
            else:
                break
                
    def iter_toplevel_items_include(self):
        """Same as iter_toplevel_items(), but follows \\include commands."""
        def follow(it):
            for i in it:
                if isinstance(i, Include):
                    doc = i.parent().get_included_document_node(i)
                    if doc:
                        for i in follow(doc[::-1]):
                            yield i
                else:
                    yield i
        return follow(self.iter_toplevel_items())
    
    def music_parent(self):
        """Walk up the parent tree until Music is found; return the outermost Music node.
        
        Returns None is the node does not belong to any music expression (e.g.
        a toplevel Markup or Scheme object).
        
        """
        node = self
        mus = isinstance(node, Music)
        for p in self.ancestors():
            pmus = isinstance(p, Music)
            if mus and not pmus:
                return node
            mus = pmus
            node = p
    
    def music_children(self, depth=-1):
        """Yield all the children that are new music expressions
        
        (i.e. that are inside other constructions).
        
        """
        def find(node, depth):
            if depth != 0:
                if isinstance(node, Music):
                    for i in node:
                        for i in find(i, depth-1):
                            yield i
                else:
                    for i in node:
                        if isinstance(i, Music):
                            yield i
                        else:
                            for i in find(i, depth-1):
                                yield i
        return find(self, depth)
    
    def has_output(self, _seen_docs=None):
        """Return True if this node has toplevel music, markup, book etc.
        
        I.e. returns True when LilyPond would likely generate output. Usually
        you'll call this method on a Document, Score, BookPart or Book node.
        
        You should not supply the _seen_docs argument; it is used internally 
        to avoid traversing recursively nested include files.
        
        """
        if _seen_docs is None:
            _seen_docs = set()
        _seen_docs.add(self)
        for n in self:
            if isinstance(n, (Music, Markup)):
                return True
            elif isinstance(n, (Book, BookPart, Score)):
                if n.has_output(_seen_docs):
                    return True
            elif isinstance(n, Include):
                doc = self.toplevel().get_included_document_node(n)
                if doc and doc not in _seen_docs and doc.has_output(_seen_docs):
                    return True


class Document(Item):
    """A toplevel item representing a ly.document.Document."""
    
    def __init__(self, doc):
        super(Document, self).__init__()
        self.document = doc
        self.include_node = None
        self.include_path = []
        self.relative_includes = True
        import ly.document
        c = ly.document.Cursor(doc)
        s = ly.document.Source(c, True, tokens_with_position=True)
        from .read import Reader
        r = Reader(s)
        self.extend(r.read())
    
    def node(self, position, depth=-1):
        """Return the node at or just before the specified position."""
        def bisect(n, depth):
            end = len(n)
            if depth == 0 or end == 0:
                return n
            pos = 0
            while pos < end:
                mid = (pos + end) // 2
                if position < n[mid].position:
                    end = mid
                else:
                    pos = mid + 1
            pos -= 1
            if n[pos].position == position:
                return n[pos]
            elif n[pos].position > position:
                return n
            return bisect(n[pos], depth - 1)
        return bisect(self, depth)
    
    def music_events_til_position(self, position):
        """Return a list of tuples.
        
        Every tuple is a (parent, nodes, scaling). If an empty list is 
        returned, there is no music expression at this position.
        
        """
        node = self.node(position)
        # be nice and allow including an assignment
        if (isinstance(node, Assignment) and node.parent() is self
            and isinstance(node.value(), Music)):
            return [(node, [], 1)]
        
        if isinstance(node.parent(), Chord):
            node = node.parent()
        
        l = []
        mus = isinstance(node, (Music, Durable))
        if mus:
            l.append((node, [], 1))
        for p in node.ancestors():
            pmus = isinstance(p, Music)
            end = node.end_position()
            if pmus:
                if position > end:
                    preceding, s = p.preceding(node.next_sibling())
                    l = [(p, preceding, s)]
                elif position == end:
                    preceding, s = p.preceding(node)
                    l = [(p, preceding + [node], s)]
                else:
                    preceding, s = p.preceding(node)
                    l.append((p, preceding, s))
            elif mus:
                # we are at the musical top
                if position > end:
                    return []
                elif position == end:
                    l = [(p, [node], 1)]
                else:
                    l.append((p, [], 1))
                break
            node = p
            mus = pmus
        l.reverse()
        return l
    
    def time_position(self, position):
        """Return the time position in the music at the specified cursor position.
        
        The value is a fraction. If None is returned, we are not in a music 
        expression.
        
        """
        events = self.music_events_til_position(position)
        if events:
            from . import event
            e = event.Events()
            time = 0
            scaling = 1
            for parent, nodes, s in events:
                scaling *= s
                for n in nodes:
                    time = e.traverse(n, time, scaling)
            return time
    
    def time_length(self, start, end):
        """Return the length of the music between start and end positions.
        
        Returns None if start and end are not in the same expression.
        
        """
        def mk_list(evts):
            """Make a flat list of all the events."""
            l = []
            scaling = 1
            for p, nodes, s in evts:
                scaling *= s
                for n in nodes:
                    l.append((n, scaling))
            return l
        
        if start > end:
            start, end = end, start
        
        start_evts = self.music_events_til_position(start)
        if start_evts:
            end_evts = self.music_events_til_position(end)
            if end_evts and start_evts[0][0] is end_evts[0][0]:
                # yes, we have the same toplevel expression.
                start_evts = mk_list(start_evts)
                end_evts = mk_list(end_evts)
                from . import event
                e = event.Events()
                time = 0
                i = 0
                # traverse the common events only once
                for i, ((evt, s), (end_evt, end_s)) in enumerate(zip(start_evts, end_evts)):
                    if evt is end_evt:
                        time = e.traverse(evt, time, s)
                    else:
                        break
                end_time = time
                # handle the remaining events for the start position
                for evt, s in start_evts[i::]:
                    time = e.traverse(evt, time, s)
                # handle the remaining events for the end position
                for evt, s in end_evts[i::]:
                    end_time = e.traverse(evt, end_time, s)
                return end_time - time
        
    def substitute_for_node(self, node):
        """Returns a node that replaces the specified node (e.g. in music).
        
        For example: a variable reference returns its value.
        Returns nothing if the node is not substitutable.
        Returns the node itself if it was substitutable, but the substitution
        failed.
        
        """
        if isinstance(node, UserCommand):
            value = node.value()
            if value:
                return self.substitute_for_node(value) or value
            return node
        elif isinstance(node, Include):
            return self.get_included_document_node(node) or node
        
        # maybe other substitutions
    
    def iter_music(self, node=None):
        """Iter over the music, following references to other assignments."""
        for n in node or self:
            n = self.substitute_for_node(n) or n
            yield n
            for n in self.iter_music(n):
                yield n
    
    def get_included_document_node(self, node):
        """Return a Document for the Include node."""
        try:
            return node._document
        except AttributeError:
            node._document = None
            filename = node.filename()
            if filename:
                resolved = self.resolve_filename(filename)
                if resolved:
                    docnode = self.get_music(resolved)
                    docnode.include_node = node
                    docnode.include_path = self.include_path
                    node._document = docnode
            return node._document
    
    def resolve_filename(self, filename):
        """Resolve filename against our document and include_path."""
        import os
        if os.path.isabs(filename):
            return filename
        path = list(self.include_path)
        if self.document.filename:
            basedir = os.path.dirname(self.document.filename)
            try:
                path.remove(basedir)
            except ValueError:
                pass
            path.insert(0, basedir)
        for p in path:
            fullpath = os.path.join(p, filename)
            if os.path.exists(fullpath):
                return fullpath
    
    def get_music(self, filename):
        """Return the music Document for the specified filename.
        
        This implementation loads a ly.document.Document using utf-8 
        encoding. Inherit from this class to implement other loading 
        mechanisms or caching.
        
        """
        import ly.document
        return type(self)(ly.document.Document.load(filename))


class Token(Item):
    """Any token that is not otherwise recognized""" 


class Container(Item):
    """An item having a list of child items."""


class Duration(Item):
    """A duration"""
    base_scaling = None, None   # two Fractions
    
    def fraction(self):
        """Returns base and scaling multiplied, as one Fraction."""
        base, scaling = self.base_scaling
        return base * scaling


class Durable(Item):
    """An Item that has a Duration attribute."""
    duration = None
    
    def events(self, e, time, scaling):
        """Let the event.Events instance handle the events. Return the time."""
        if self.duration:
            time += self.duration.fraction() * scaling
        return time
    
    def length(self):
        """Return the duration.
        
        Returns 0 if no duration attribute was set.
        
        """
        return self.duration.fraction() if self.duration else 0
    
    def base_scaling(self):
        """Return the base and scaling fractions (if set, else None)."""
        if self.duration:
            return self.duration.base_scaling


class Chord(Durable, Container):
    pass


class Unpitched(Durable):
    """A "note" without pitch, just a standalone duration."""
    pitch = None


class Note(Durable):
    """A Note that has a ly.pitch.Pitch"""
    pitch = None
    octave_token = None
    accidental_token = None
    octavecheck_token = None


class Skip(Durable):
    pass


class Rest(Durable):
    pass


class Q(Durable):
    pass


class Music(Container):
    """Any music expression, to be inherited of."""
    def events(self, e, time, scaling):
        """Let the event.Events instance handle the events. Return the time."""
        for node in self:
            time = e.traverse(node, time, scaling)
        return time
    
    def length(self):
        """Return the musical duration."""
        from . import event
        return event.Events().read(self)
    
    def preceding(self, node=None):
        """Return a two-tuple (nodes, scaling).
        
        The nodes are the nodes in time before the node (which must be a
        child), and the scaling is the scaling this node applies (normally 1).
        
        If node is None, all nodes that would precede a fictive node at the
        end are returned.
        
        """
        i = self.index(node) if node else None
        return self[:i:], 1


class MusicList(Music):
    """A music expression, either << >> or { }."""
    simultaneous = False
    
    def events(self, e, time, scaling):
        """Let the event.Events instance handle the events. Return the time."""
        if self.simultaneous:
            if len(self):
                time = max(e.traverse(node, time, scaling) for node in self)
        else:
            time = super(MusicList, self).events(e, time, scaling)
        return time

    def preceding(self, node=None):
        """Return a two-tuple (nodes, scaling).
        
        The nodes are the nodes in time before the node (which must be a
        child), and the scaling is the scaling this node applies (normally 1).
        
        If node is None, all nodes that would precede a fictive node at the
        end are returned.
        
        """
        if self.simultaneous:
            return [], 1
        return super(MusicList, self).preceding(node)


class Tag(Music):
    """A \\tag, \\keepWithTag or \\removeWithTag command."""
    
    def events(self, e, time, scaling):
        """Let the event.Events instance handle the events. Return the time."""
        for node in self[-1:]:
            time = e.traverse(node, time, scaling)
        return time
        
    def preceding(self, node=None):
        """Return a two-tuple (nodes, scaling).
        
        The nodes are the nodes in time before the node (which must be a
        child), and the scaling is the scaling this node applies (normally 1).
        
        If node is None, all nodes that would precede a fictive node at the
        end are returned.
        
        """
        return [], 1


class Scaler(Music):
    """A music construct that scales the duration of its contents."""
    scaling = 1
    
    def events(self, e, time, scaling):
        """Let the event.Events instance handle the events. Return the time."""
        return super(Scaler, self).events(e, time, scaling * self.scaling)
    
    def preceding(self, node=None):
        """Return a two-tuple (nodes, scaling).
        
        The nodes are the nodes in time before the node (which must be a
        child), and the scaling is the scaling this node applies.
        
        If node is None, all nodes that would precede a fictive node at the
        end are returned.
        
        """
        i = self.index(node) if node else None
        return self[:i:], self.scaling


class Grace(Music):
    """Music that has grace timing, i.e. 0 as far as computation is concerned."""
    
    def events(self, e, time, scaling):
        """Let the event.Events instance handle the events. Return the time."""
        return super(Grace, self).events(e, time, 0)
    
    def preceding(self, node=None):
        """Return a two-tuple (nodes, scaling).
        
        The nodes are the nodes in time before the node (which must be a
        child), and the scaling is 0 for (because we have grace notes).
        
        If node is None, all nodes that would precede a fictive node at the
        end are returned.
        
        """
        i = self.index(node) if node else None
        return self[:i:], 0


class AfterGrace(Music):
    """The \afterGrace function with its two arguments.
    
    Only the duration of the first is counted.
    
    """


class PartCombine(Music):
    """The \\partcombine command with 2 music arguments."""
    def events(self, e, time, scaling):
        """Let the event.Events instance handle the events. Return the time."""
        if len(self):
            time = max(e.traverse(node, time, scaling) for node in self)
        return time
    
    def preceding(self, node=None):
        """Return a two-tuple (nodes, scaling).
        
        The nodes are the nodes in time before the node (which must be a
        child), and the scaling is the scaling this node applies (normally 1).
        
        If node is None, all nodes that would precede a fictive node at the
        end are returned.
        
        """
        return [], 1


class Relative(Music):
    """A \\relative music expression. Has one or two children (Note, Music)."""
    pass


class Absolute(Music):
    """An \\absolute music expression. Has one child (normally Music)."""
    pass


class Transpose(Music):
    """A \\transpose music expression. Has normally three children (Note, Note, Music)."""


class Repeat(Music):
    """A \\repeat expression."""
    def specifier(self):
        if isinstance(self._specifier, Scheme):
            return self._specifier.get_string()
        elif isinstance(self._specifier, String):
            return self._specifier.value()
        return self._specifier
    
    def repeat_count(self):
        if isinstance(self._repeat_count, Scheme):
            return self._repeat_count.get_int() or 1
        return int(self._repeat_count or '1') or 1

    def events(self, e, time, scaling):
        """Let the event.Events instance handle the events. Return the time."""
        if len(self) and isinstance(self[-1], Alternative):
            alt = self[-1]
            children = self[:-1]
        else:
            alt = None
            children = self[:]
        
        if e.unfold_repeats or self.specifier() != "volta":
            count = self.repeat_count()
            if alt and len(alt):
                alts = list(alt[0])[:count+1]
                alts[0:0] = [alts[0]] * (count - len(alts))
                for a in alts:
                    for n in children:
                        time = e.traverse(n, time, scaling)
                    time = e.traverse(a, time, scaling)
            else:
                for i in range(count):
                    for n in children:
                        time = e.traverse(n, time, scaling)
        else:
            for n in children:
                time = e.traverse(n, time, scaling)
            if alt:
                time = e.traverse(alt, time, scaling)
        return time


class Alternative(Music):
    """An \\alternative expression."""


class InputMode(Music):
    """Base class for inputmode-changing commands."""


class NoteMode(InputMode):
    """A \\notemode or \\notes expression."""


class ChordMode(InputMode):
    """A \\chordmode or \\chords expression."""


class DrumMode(InputMode):
    """A \\drummode or \\drums expression."""


class FigureMode(InputMode):
    """A \\figuremode or \\figures expression."""


class LyricMode(InputMode):
    """A \\lyricmode, \\lyrics or \\addlyrics expression."""


class LyricsTo(InputMode):
    """A \\lyricsto expression."""
    _context_id = None
    
    def context_id(self):
        if isinstance(self._context_id, String):
            return self._context_id.value()
        elif isinstance(self._context_id, Scheme):
            return self._context_id.get_string()
        return self._context_id


class LyricText(Durable):
    """A lyric text (word, markup or string), with a Duration."""


class LyricItem(Item):
    """Another lyric item (skip, extender, hyphen or tie)."""


class ChordSpecifier(Item):
    """Chord specifications after a note in chord mode.
    
    Has children of Note or ChordItem class.
    
    """


class ChordItem(Item):
    """An item inside a ChordSpecifier, e.g. a number or modifier."""


class Tremolo(Item):
    """A tremolo item ":". The duration attribute may be a Duration or None."""
    duration = None


class Translator(Item):
    """Base class for a \\change, \\new, or \\context music expression."""
    _context = None
    _context_id = None
    
    def context(self):
        return self._context
    
    def context_id(self):
        """The context id, if specified after an equal sign."""
        if isinstance(self._context_id, String):
            return self._context_id.value()
        return self._context_id


class Context(Translator, Music):
    """A \\new or \\context music expression."""


class Change(Translator):
    """A \\change music expression."""


class Tempo(Item):
    duration = None
    _text = None
    _tempo = ()
    
    def fraction(self):
        """Return the note value as a fraction given before the equal sign."""
        if self.duration:
            return self.duration.base_scaling[0]
            
    def text(self):
        """Return the text, if set. Can be Markup, Scheme, or String."""
        return self._text
    
    def tempo(self):
        """Return a list of integer values describing the tempo or range."""
        result = []
        for i in self._tempo:
            if isinstance(i, Scheme):
                v = i.get_int()
                if v is not None:
                    result.append(v)
            else:
                result.append(int(i))
        return result


class TimeSignature(Item):
    """A \\time command."""
    _num = 4
    _fraction = Fraction(1, 4)
    _beatstructure = None

    def measure_length(self):
        """The length of one measure in this time signature as a Fraction."""
        return self._num * self._fraction
    
    def numerator(self):
        """The upper number (e.g. for 3/2 it returns 3)."""
        return self._num
    
    def fraction(self):
        """The lower number as a Fraction (e.g. for 3/2 it returns 1/2)."""
        return self._fraction
    
    def beatstructure(self):
        """The scheme expressions denoting the beat structure, if specified."""
        return self._beatstructure


class Partial(Item):
    """A \\partial command."""
    duration = None

    def partial_length(self):
        """Return the duration given as argument as a Fraction."""
        if self.duration:
            base, scaling = self.duration.base_scaling
            return base * scaling


class Clef(Item):
    """A \\clef item."""
    _specifier = None
    
    def specifier(self):
        if isinstance(self._specifier, String):
            return self._specifier.value()
        return self._specifier

        
class KeySignature(Item):
    """A \\key pitch \\mode command."""
    def pitch(self):
        """The ly.pitch.Pitch that denotes the pitch."""
        for i in self.find(Note):
            return i.pitch
    
    def mode(self):
        """The mode, e.g. "major", "minor", etc."""
        for i in self.find(Command):
            return i.token[1:]


class PipeSymbol(Item):
    """A |."""


class VoiceSeparator(Item):
    """A \\\\."""


class Postfix(Item):
    """Any item that is prefixed with a _, - or ^ direction token."""


class Tie(Item):
    """A tie."""


class Slur(Item):
    """A ( or )."""
    event = None


class PhrasingSlur(Item):
    """A \\( or \\)."""
    event = None


class Beam(Item):
    """A [ or ]."""
    event = None


class Dynamic(Item):
    """Any dynamic symbol."""


class Articulation(Item):
    """An articulation, fingering, string number, or other symbol."""


class StringTuning(Item):
    """A \\stringTuning command (with a chord as argument)."""


class Keyword(Item):
    """A LilyPond keyword."""


class Command(Item):
    """A LilyPond command."""


class UserCommand(Music):
    """A user command, most probably referring to music."""
    def name(self):
        """Return the name of this user command (without the \\)."""
        return self.token[1:]
    
    def value(self):
        """Find the value assigned to this variable."""
        for i in self.iter_toplevel_items_include():
            if isinstance(i, Assignment) and i.name() == self.name():
                return i.value()
    
    def events(self, e, time, scaling):
        """Let the event.Events instance handle the events. Return the time."""
        value = self.value()
        if value:
            time = e.traverse(value, time, scaling)
        return time


class Version(Item):
    """A \\version command."""
    def version_string(self):
        """The version as a string."""
        for i in self:
            if isinstance(i, String):
                return i.value()
            elif isinstance(i, Scheme):
                return i.get_string()
        return ''

    def version(self):
        """The version as a tuple of ints."""
        return tuple(map(int, re.findall(r'\d+', self.version_string())))


class Include(Item):
    """An \\include command (not changing the language)."""
    def filename(self):
        """Returns the filename."""
        for i in self:
            if isinstance(i, String):
                return i.value()
            elif isinstance(i, Scheme):
                return i.get_string()


class Language(Item):
    """A command (\\language or certain \\include commands) that changes the pitch language."""
    language = None


class Markup(Item):
    """A command starting markup (\markup, -lines and -list)."""


class MarkupCommand(Item):
    """A markup command, such as \italic etc."""


class MarkupUserCommand(Item):
    """A user-defined markup command"""
    def name(self):
        """Return the name of this user command (without the \\)."""
        return self.token[1:]
    
    def value(self):
        """Find the value assigned to this variable."""
        for i in self.iter_toplevel_items_include():
            if isinstance(i, Assignment) and i.name() == self.name():
                return i.value()
            elif isinstance(i, Scheme):
                for j in i:
                    if isinstance(j, SchemeList):
                        for k in j:
                            if isinstance(k, SchemeItem) and k.token == 'define-markup-command':
                                for l in j[1::]:
                                    if isinstance(l, SchemeList):
                                        for m in l:
                                            if isinstance(m, SchemeItem) and m.token == self.name():
                                                return i
                                            break
                                    break
                            break
                    break


class MarkupScore(Item):
    """A \\score inside Markup."""


class MarkupList(Item):
    """The group of markup items inside { and }. NOTE: *not* a \markuplist."""


class MarkupWord(Item):
    """A MarkupWord token."""


class Assignment(Item):
    """A variable = value construct."""
    def name(self):
        """The variable name."""
        return self.token
    
    def value(self):
        """The assigned value."""
        if len(self):
            return self[-1]


class Book(Container):
    """A \\book { ... } construct."""


class BookPart(Container):
    """A \\bookpart { ... } construct."""


class Score(Container):
    """A \\score { ... } construct."""


class Header(Container):
    """A \\header { ... } construct."""


class Paper(Container):
    """A \\paper { ... } construct."""


class Layout(Container):
    """A \\layout { ... } construct."""


class Midi(Container):
    """A \\midi { ... } construct."""


class LayoutContext(Container):
    """A \\context { ... } construct within Layout or Midi."""


class With(Container):
    """A \\with ... construct."""


class Set(Item):
    """A \\set command."""
    def context(self):
        """The context, if specified."""
        for t in self.tokens:
            if isinstance(t, lilypond.ContextName):
                return t
    
    def property(self):
        """The property."""
        for t in self.tokens:
            if isinstance(t, lilypond.ContextProperty):
                return t
        for t in self.tokens[::-1]:
            if isinstance(t, lilypond.Name):
                return t
        
    def value(self):
        """The value, given as argument. This is simply the child element."""
        for i in self:
            return i


class Unset(Item):
    """An \\unset command."""
    def context(self):
        """The context, if specified."""
        for t in self.tokens:
            if isinstance(t, lilypond.ContextName):
                return t
    
    def property(self):
        """The property."""
        for t in self.tokens:
            if isinstance(t, lilypond.ContextProperty):
                return t
        for t in self.tokens[::-1]:
            if isinstance(t, lilypond.Name):
                return t


class Override(Item):
    """An \\override command."""
    def context(self):
        for i in self:
            if isinstance(i.token, lilypond.ContextName):
                return i.token
    
    def grob(self):
        for i in self:
            if isinstance(i.token, lilypond.GrobName):
                return i.token


class Revert(Item):
    """A \\revert command."""
    def context(self):
        for i in self:
            if isinstance(i.token, lilypond.ContextName):
                return i.token
    
    def grob(self):
        for i in self:
            if isinstance(i.token, lilypond.GrobName):
                return i.token


class Tweak(Item):
    """A \\tweak command."""


class PathItem(Item):
    """An item in the path of an \\override or \\revert command."""


class String(Item):
    """A double-quoted string."""
    
    def value(self):
        return ''.join(
            t[1:] if isinstance(t, lex.Character) and t.startswith('\\') else t
            for t in self.tokens[:-1])


class Number(Item):
    """A numerical value, directly entered."""
    def value(self):
        if isinstance(self.token, lilypond.IntegerValue):
            return int(self.token)
        elif isinstance(self.token, lilypond.DecimalValue):
            return float(self.token)
        elif isinstance(self.token, lilypond.Fraction):
            return Fraction(self.token)
        elif self.token.isdigit():
            return int(self.token)


class Scheme(Item):
    """A Scheme expression inside LilyPond."""
    def get_pair_ints(self):
        """Very basic way to get two integers specified as a pair."""
        result = [int(i.token) for i in self.find(SchemeItem) if i.token.isdigit()]
        if len(result) >= 2:
            return tuple(result[:2])
    
    def get_list_ints(self):
        """A basic way to get a list of integer values."""
        return [int(i.token) for i in self.find(SchemeItem) if i.token.isdigit()]
    
    def get_int(self):
        """A basic way to get one integer value."""
        for i in self.find(SchemeItem):
            if i.token.isdigit():
                return int(i.token)

    def get_string(self):
        """A basic way to get a quoted string value (without the quotes)."""
        return ''.join(i.value() for i in self.find(String))


class SchemeItem(Item):
    """Any scheme token."""


class SchemeList(Container):
    """A ( ... ) expression."""


class SchemeQuote(Item):
    """A ' in scheme."""


class SchemeLily(Container):
    """A music expression inside #{ and #}."""




########NEW FILE########
__FILENAME__ = read
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2014 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The items a music expression is constructed with in a tree structure.

Whitespace and comments are left out.

All nodes (instances of Item) have a 'position' attribute that indicates 
where the item starts in the source text. Almost all items have the token 
that starts the expression in the 'token' attribute and possibly other 
tokens in the 'tokens' attribute, as a tuple. 

The 'end_position()' method returns the position where the node (including 
its child nodes) ends.


"""

from __future__ import unicode_literals

import itertools
from fractions import Fraction

import ly.duration
import ly.pitch

from ly import lex
from ly.lex import lilypond
from ly.lex import scheme

from .items import *


def skip(source, what=(lex.Space, lex.Comment)):
    """Yield tokens from source, skipping items of classes specified in what.
    
    By default, comments and whitespace are skipped.
    
    """
    for t in source:
        if not isinstance(t, what):
            yield t


class dispatcher(object):
    """Decorator creator to dispatch commands, keywords, etc. to a method."""
    def __init__(self):
        self.d = {}
    
    def read_arg(self, a):
        return a
    
    def __call__(self, *args):
        d = self.d
        def wrapper(func):
            for a in args:
                d[a] = func
            doc = "handle " + ", ".join(map(self.read_arg, args))
            func.__doc__ = doc if not func.__doc__ else func.__doc__ + '\n\n' + doc
            return func
        return wrapper
    
    def method(self, token):
        """The registered method to call for the token. May return None."""
        return self.d.get(token)


class dispatcher_class(dispatcher):
    """Decorator creator to dispatch the class of a token to a method."""
    def read_arg(self, a):
        return a.__name__
    
    def method(self, token):
        """The registered method to call for the token's class. May return None."""
        cls = token.__class__
        d = self.d
        try:
            return d[cls]
        except KeyError:
            for c in cls.__mro__[1:]:
                try:
                    meth = d[cls] = d[c]
                except KeyError:
                    if c is not lex.Token:
                        continue
                    meth = d[cls] = None
                return meth


class Reader(object):
    """Reads tokens from a Source and builds a meaningful tree stucture."""
    
    _commands = dispatcher()
    _keywords = dispatcher()
    _tokencls = dispatcher_class()
    _markup = dispatcher_class()
    _scheme = dispatcher_class()
    
    def __init__(self, source):
        """Initialize with a ly.document.Source.
        
        The language is set to "nederlands".
        
        """
        self.source = source
        self.language = "nederlands"
        self.in_chord = False
        self.prev_duration = Fraction(1, 4), 1
    
    def set_language(self, lang):
        """Changes the pitch name language to use.
        
        Called internally when \language or \include tokens are encoutered
        with a valid language name/file.
        
        Sets the language attribute to the language name.
        
        """
        if lang in ly.pitch.pitchInfo:
            self.language = lang
            return True

    def add_duration(self, item, token=None, source=None):
        """Add a duration attribute to the item."""
        source = source or self.source
        d = item.duration = self.factory(Duration, position=0)
        tokens = []
        if not token or isinstance(token, lilypond.Duration):
            if token:
                tokens.append(token)
            for token in source:
                if isinstance(token, lilypond.Duration):
                    if tokens and isinstance(token, lilypond.Length):
                        self.source.pushback()
                        break
                    tokens.append(token)
                elif not isinstance(token, lex.Space):
                    self.source.pushback()
                    break
        if tokens:
            d.tokens = tuple(tokens)
            d.position = tokens[0].pos
            d.base_scaling = self.prev_duration = ly.duration.base_scaling(tokens)
        else:
            d.base_scaling = self.prev_duration
    
    def consume(self, last_token=None):
        """Yield the tokens from our source until a parser is exit.
        
        If last_token is given, it is called with the last token that is read.
        
        """
        t = None
        for t in self.source.until_parser_end():
            yield t
        if last_token and t is not None:
            last_token(t)

    def factory(self, cls, token=None, consume=False, position=None):
        """Create Item instance for token.
        
        If consume is True, consume()s the source into item.tokens.
        If you don't specify a token, you must specify the position (>= 0).
        
        """
        item = cls()
        item.document = self.source.document
        if token:
            item.token = token
            item.position = token.pos
        elif position is None:
            raise ValueError("position must be specified if no token")
        else:
            item.position = position
        if consume:
            item.tokens = tuple(self.consume())
            if not token and item.tokens:
                item.position = item.tokens[0].pos
        return item
    
    def add_bracketed(self, item, source):
        """Append the arguments between brackets to the item.
        
        Returns True if that succeeded, else False.
        
        """
        for t in source:
            if isinstance(t, lilypond.OpenBracket):
                tokens = [t]
                item.extend(self.read(self.consume(tokens.append)))
                item.tokens = tuple(tokens)
                return True
            elif not isinstance(t, lex.Space):
                self.source.pushback()
                break
        return False
        
    def read(self, source=None):
        """Yield Item instances reading from source."""
        source = source or self.source
        for t in skip(source):
            item = self.read_item(t, source)
            if item:
                yield item
    
    def read_item(self, t, source=None):
        """Return one Item that starts with token t. May return None."""
        meth = self._tokencls.method(t)
        if meth:
            return meth(self, t, source or self.source)
    
    @_tokencls(lilypond.SchemeStart)
    @_markup(lilypond.SchemeStart)
    def handle_scheme_start(self, t, source=None):
        return self.read_scheme_item(t)
    
    @_tokencls(lex.StringStart)
    @_markup(lex.StringStart)
    @_scheme(lex.StringStart)
    def handle_string_start(self, t, source=None):
        return self.factory(String, t, True)
    
    @_tokencls(
        lilypond.DecimalValue,
        lilypond.IntegerValue,
        lilypond.Fraction,
    )
    def handle_number_class(self, t, source=None):
        return self.factory(Number, t)
    
    @_tokencls(lilypond.MusicItem)
    def handle_music_item(self, t, source):
        return self.read_music_item(t, source)
    
    @_tokencls(lilypond.Length)
    def handle_length(self, t, source):
        item = self.factory(Unpitched, position=t.pos)
        self.add_duration(item, t, source)
        return item
    
    @_tokencls(lilypond.ChordStart)
    def handle_chord_start(self, t, source):
        if not self.in_chord:
            self.in_chord = True
            chord = self.factory(Chord, t)
            def last(t): chord.tokens += (t,)
            chord.extend(self.read(self.consume(last)))
            self.in_chord = False
            self.add_duration(chord, None, source)
            return chord
    
    @_tokencls(
        lilypond.OpenBracket, lilypond.OpenSimultaneous,
        lilypond.SimultaneousOrSequentialCommand,
    )
    def handle_music_list(self, t, source):
        item, it = self.test_music_list(t)
        if item:
            if it:
                item.extend(self.read(it))
            return item
    
    @_tokencls(lilypond.Command)
    def read_command(self, t, source):
        """Read the rest of a command given in t from the source."""
        meth = self._commands.method(t)
        if meth:
            return meth(self, t, source)
        return self.factory(Command, t)
    
    @_tokencls(lilypond.Keyword)
    def read_keyword(self, t, source):
        """Read the rest of a keyword given in t from the source."""
        meth = self._keywords.method(t)
        if meth:
            return meth(self, t, source)
        return self.factory(Keyword, t)
    
    @_tokencls(lilypond.UserCommand)
    def read_user_command(self, t, source):
        """Read a user command, this can be a variable reference."""
        return self.factory(UserCommand, t)
    
    @_tokencls(lilypond.ChordSeparator)
    def read_chord_specifier(self, t, source=None):
        """Read stuff behind notes in chordmode."""
        item = self.factory(ChordSpecifier, position=t.pos)
        item.append(self.factory(ChordItem, t))
        for t in self.consume():
            if isinstance(t, lilypond.ChordItem):
                item.append(self.factory(ChordItem, t))
            elif isinstance(t, lilypond.Note):
                r = ly.pitch.pitchReader(self.language)(t)
                if r:
                    note = self.factory(Note, t)
                    note.pitch = ly.pitch.Pitch(*r)
                    item.append(note)
        return item
    
    @_tokencls(lilypond.TremoloColon)
    def read_tremolo(self, t, source=None):
        """Read a tremolo."""
        item = self.factory(Tremolo, t)
        for t in self.source:
            if isinstance(t, lilypond.TremoloDuration):
                item.duration = self.factory(Duration, t)
                item.duration.base_scaling = ly.duration.base_scaling_string(t)
            else:
                self.source.pushback()
            break
        return item
    
    @_tokencls(lilypond.Name)
    def handle_name(self, t, source):
        if self.source.state.depth() < 2:
            return self.read_assignment(t)
    
    @_tokencls(
        lilypond.PaperVariable,
        lilypond.LayoutVariable,
        lilypond.HeaderVariable,
        lilypond.UserVariable,
    )
    def handle_variable_assignment(self, t, source):
        item = self.read_assignment(t)
        if item:
            # handle \pt, \in etc.
            for t in skip(self.source):
                if isinstance(t, lilypond.Unit):
                    item.append(self.factory(Command, t))
                else:
                    self.source.pushback()
                break
            return item
    
    _direct_items = {
        lilypond.VoiceSeparator: VoiceSeparator,
        lilypond.PipeSymbol: PipeSymbol,
        lilypond.Dynamic: Dynamic,
        lilypond.Tie: Tie,
    }
    @_tokencls(*_direct_items)
    def handle_direct_items(self, t, source):
        """Tokens that directly translate to an Item."""
        return self.factory(self._direct_items[t.__class__], t)
    
    @_tokencls(lilypond.Direction)
    def handle_direction(self, t, source):
        item = self.factory(Postfix, t)
        item.direction = '_-^'.index(t) - 1
        for t in skip(source):
            if isinstance(t, (
                lex.StringStart,
                lilypond.MarkupStart,
                lilypond.Articulation,
                lilypond.Slur,
                lilypond.Beam,
                lilypond.Dynamic,
                )):
                item.append(self.read_item(t))
            elif isinstance(t, lilypond.Command) and t in ('\\tag'):
                item.append(self.read_item(t))
            elif isinstance(t, lilypond.Keyword) and t in ('\\tweak'):
                item.append(self.read_item(t))
            else:
                self.source.pushback()
            break
        return item
    
    @_tokencls(lilypond.Slur)
    def handle_slurs(self, t, source=None):
        cls = PhrasingSlur if t.startswith('\\') else Slur
        item = self.factory(cls, t)
        item.event = 'start' if t.endswith('(') else 'stop'
        return item
    
    @_tokencls(lilypond.Beam)
    def handle_beam(self, t, source=None):
        item = self.factory(Beam, t)
        item.event = 'start' if t == '[' else 'stop'
        return item
    
    @_tokencls(lilypond.Articulation)
    def handle_beam(self, t, source=None):
        return self.factory(Articulation, t)
    
    def read_assignment(self, t):
        """Read an assignment from the variable name. May return None."""
        item = self.factory(Assignment, t)
        for t in skip(self.source):
            if isinstance(t, (lilypond.Variable, lilypond.UserVariable, lilypond.DotPath)):
                item.append(self.factory(PathItem, t))
            elif isinstance(t, lilypond.EqualSign):
                item.tokens = (t,)
                for i in self.read():
                    item.append(i)
                    break
                return item
            elif isinstance(t, lilypond.SchemeStart):
                # accept only one scheme item, if another one is found,
                # return the first, and discard the Assignment item
                # (should not normally happen)
                for s in item.find(Scheme):
                    self.source.pushback()
                    return s
                item.append(self.read_scheme_item(t))
            else:
                self.source.pushback()
                return
    
    def test_music_list(self, t):
        """Test whether a music list ({ ... }, << ... >>, starts here.
        
        Also handles \\simultaneous { ... } and \\sequential { ... } 
        correctly. These obscure commands are not even highlighted by 
        lex, but they exist in LilyPond... \\\simultaneous { ... } is 
        like << ... >> but \\sequential << ... >> just behaves like << ... >>

        Returns a two-tuple(item; iterable), both may be None. If 
        item is not None, it can be either a UserCommand or a MusicList.  If 
        iterable is None, the item is a UserCommand (namely \\simultaneous 
        or \\sequential, but not followed by a { or <<); else the item is a 
        MusicList, and the iterable should be read fully to get all the 
        tokens inside the MusicList. If item is None, there is no MusicList 
        and no token is read.
        
        This way you can handle the { ... } and << ... >> transparently in every
        input mode.
        
        """
        def make_music_list(t, simultaneous, tokens=()):
            """Make the MusicList item."""
            item = self.factory(MusicList, t)
            item.simultaneous = simultaneous
            item.tokens = tokens
            def last(t): item.tokens += (t,)
            return item, self.consume(last)
            
        if isinstance(t, (lilypond.OpenBracket, lilypond.OpenSimultaneous)):
            return make_music_list(t, t == '<<')
        elif isinstance(t, lilypond.SimultaneousOrSequentialCommand):
            for t1 in skip(self.source):
                if isinstance(t1, (lilypond.OpenBracket, lilypond.OpenSimultaneous)):
                    return make_music_list(t, t == '\\simultaneous' or t1 == '<<', (t1,))
                else:
                    self.source.pushback()
                    return self.factory(Keyword, t), None
        return None, None
                    
    def read_music_item(self, t, source):
        """Read one music item (note, rest, s, \skip, or q) from t and source."""
        item = None
        in_pitch_command = isinstance(self.source.state.parser(), lilypond.ParsePitchCommand)
        if t.__class__ == lilypond.Note:
            r = ly.pitch.pitchReader(self.language)(t)
            if r:
                item = self.factory(Note, t)
                p = item.pitch = ly.pitch.Pitch(*r)
                for t in source:
                    if isinstance(t, lilypond.Octave):
                        p.octave = ly.pitch.octaveToNum(t)
                        item.octave_token = t
                    elif isinstance(t, lilypond.Accidental):
                        item.accidental_token = p.accidental = t
                    elif isinstance(t, lilypond.OctaveCheck):
                        p.octavecheck = ly.pitch.octaveToNum(t)
                        item.octavecheck_token = t
                        break
                    elif not isinstance(t, lex.Space):
                        self.source.pushback()
                        break
        else:
            cls = {
                lilypond.Rest: Rest,
                lilypond.Skip: Skip,
                lilypond.Spacer: Skip,
                lilypond.Q: Q,
            }[t.__class__]
            item = self.factory(cls, t)
        if item:
            if not self.in_chord and not in_pitch_command:
                self.add_duration(item, None, source)
        return item
    
    @_commands('\\relative')
    def handle_relative(self, t, source):
        item = self.factory(Relative, t)
        # get one pitch and exit on a non-comment
        pitch_found = False
        for i in self.read(source):
            item.append(i)
            if not pitch_found and isinstance(i, Note):
                pitch_found = True
                continue
            break
        return item
    
    @_commands('\\absolute')
    def handle_absolute(self, t, source):
        item = self.factory(Absolute, t)
        for i in self.read(source):
            item.append(i)
            break
        return item
    
    @_commands('\\transpose')
    def handle_transpose(self, t, source):
        item = self.factory(Transpose, t)
        # get two pitches
        pitches_found = 0
        for i in self.read(source):
            item.append(i)
            if pitches_found < 2 and isinstance(i, Note):
                pitches_found += 1
                continue
            break
        return item
    
    @_commands('\\clef')
    def handle_clef(self, t, source):
        item = self.factory(Clef, t)
        for t in skip(source):
            if isinstance(t, lilypond.ClefSpecifier):
                item._specifier = t
            elif isinstance(t, lex.StringStart):
                item._specifier = self.factory(String, t, True)
            break
        return item
    
    @_commands('\\key')
    def handle_key(self, t, source):
        item = self.factory(KeySignature, t)
        item.extend(itertools.islice(self.read(source), 2))
        return item
    
    @_commands('\\times', '\\tuplet', '\\scaleDurations')
    def handle_scaler(self, t, source):
        item = self.factory(Scaler, t)
        item.scaling = 1
        if t == '\\scaleDurations':
            for i in self.read(source):
                item.append(i)
                if isinstance(i, Scheme):
                    pair = i.get_pair_ints()
                    if pair:
                        item.scaling = Fraction(*pair)
                break
        elif t == '\\tuplet':
            for t in source:
                if isinstance(t, lilypond.Fraction):
                    item.scaling = 1 / Fraction(t)
                elif isinstance(t, lilypond.Duration):
                    self.add_duration(item, t, source)
                    break
                elif not isinstance(t, lex.Space):
                    self.source.pushback()
                    break
        else: # t == '\\times'
            for t in source:
                if isinstance(t, lilypond.Fraction):
                    item.scaling = Fraction(t)
                    break
                elif not isinstance(t, lex.Space):
                    self.source.pushback()
                    break
        for i in self.read(source):
            item.append(i)
            break
        return item
    
    @_commands('\\tag', '\\keepWithTag', '\\removeWithTag', '\\appendToTag', '\\pushToTag')
    def handle_tag(self, t, source):
        item = self.factory(Tag, t)
        argcount = 3 if t in ('\\appendToTag', '\\pushToTag') else 2
        item.extend(itertools.islice(self.read(), argcount))
        return item
    
    @_commands('\\grace', '\\acciaccatura', '\\appoggiatura', '\\slashedGrace')
    def handle_grace(self, t, source):
        item = self.factory(Grace, t)
        for i in self.read(source):
            item.append(i)
            break
        return item
    
    @_commands('\\afterGrace')
    def handle_after_grace(self, t, source):
        item = self.factory(AfterGrace, t)
        for i in itertools.islice(self.read(source), 2):
            item.append(i)
        # put the grace music in a Grace item
        if len(item) > 1:
            i = self.factory(Grace, position=item[-1].position)
            i.append(item[-1])
            item.append(i)
        return item
    
    @_commands('\\repeat')
    def handle_repeat(self, t, source):
        item = self.factory(Repeat, t)
        item._specifier = None
        item._repeat_count = None
        for t in skip(source):
            if isinstance(t, lilypond.RepeatSpecifier):
                item._specifier = t
            elif not item.specifier and isinstance(t, lex.StringStart):
                item._specifier = self.factory(String, t, True)
            elif isinstance(t, lilypond.RepeatCount):
                item._repeat_count = t
            elif isinstance(t, lilypond.SchemeStart):
                # the specifier or count may be specified using scheme
                s = self.read_scheme_item(t)
                if item._specifier:
                    if item._repeat_count:
                        item.append(s)
                        break
                    item._repeat_count = s
                else:
                    item._specifier = s
            else:
                self.source.pushback()
                for i in self.read(source):
                    item.append(i)
                    break
                for t in skip(source):
                    if t == '\\alternative' and isinstance(t, lilypond.Command):
                        item.append(self.handle_alternative(t, source))
                    else:
                        self.source.pushback()
                    break
                break
        return item
    
    @_commands('\\alternative')
    def handle_alternative(self, t, source):
        item = self.factory(Alternative, t)
        for i in self.read(source):
            item.append(i)
            break
        return item
    
    @_commands('\\tempo')
    def handle_tempo(self, t, source):
        item = self.factory(Tempo, t)
        item._text = None
        item._tempo = []
        source = self.consume()
        equal_sign_seen = False
        for t in source:
            if not equal_sign_seen:
                if not item._text:
                    if isinstance(t, lilypond.SchemeStart):
                        item._text = self.read_scheme_item(t)
                    elif isinstance(t, lex.StringStart):
                        item._text = self.factory(String, t, True)
                    elif isinstance(t, lilypond.Markup):
                        item._text = self.handle_markup(t)
                elif isinstance(t, lilypond.Length):
                    self.add_duration(item, t, source)
                elif isinstance(t, lilypond.EqualSign):
                    equal_sign_seen = True
            elif isinstance(t, lilypond.IntegerValue):
                item._tempo.append(t)
            elif isinstance(t, lilypond.SchemeStart):
                item._tempo.append(self.read_scheme_item(t))
        return item
    
    @_commands('\\time')
    def handle_time(self, t, source):
        item = self.factory(TimeSignature, t)
        for t in skip(source):
            if isinstance(t, lilypond.SchemeStart):
                item._beatstructure = self.read_scheme_item(t)
                continue
            elif isinstance(t, lilypond.Fraction):
                item._num, den = map(int, t.split('/'))
                item._fraction = Fraction(1, den)
            else:
                self.source.pushback()
            break
        return item
    
    @_commands('\\partial')
    def handle_partial(self, t, source):
        item = self.factory(Partial, t)
        self.add_duration(item, None, source)
        return item
    
    @_commands('\\new', '\\context', '\\change')
    def handle_translator(self, t, source):
        cls = Change if t == '\\change' else Context 
        item = self.factory(cls, t)
        isource = self.consume()
        for t in skip(isource):
            if isinstance(t, (lilypond.ContextName, lilypond.Name)):
                item._context = t
                for t in isource:
                    if isinstance(t, lilypond.EqualSign):
                        for t in isource:
                            if isinstance(t, lex.StringStart):
                                item._context_id = self.factory(String, t, True)
                                break
                            elif isinstance(t, lilypond.Name):
                                item._context_id = t
                                break
                            elif not isinstance(t, lex.Space):
                                self.source.pushback()
                                break
                    elif not isinstance(t, lex.Space):
                        self.source.pushback()
                        break
            else:
                self.source.pushback()
            break
        if cls is not Change:
            for i in self.read(source):
                item.append(i)
                if not isinstance(i, With):
                    break
        return item
    
    _inputmode_commands = {
        '\\notemode': NoteMode,
        '\\notes': NoteMode,
        '\\chordmode': ChordMode,
        '\\chords': ChordMode,
        '\\figuremode': FigureMode,
        '\\figures': FigureMode,
        '\\drummode': DrumMode,
        '\\drums': DrumMode,
    }
    @_commands(*_inputmode_commands)
    def handle_inputmode(self, t, source):
        cls = self._inputmode_commands[t]
        item = self.factory(cls, t)
        for i in self.read():
            item.append(i)
            break
        return item
    
    _lyricmode_commands = {
        '\\lyricmode': LyricMode,
        '\\lyrics': LyricMode,
        '\\oldaddlyrics': LyricMode,
        '\\addlyrics': LyricMode,
        '\\lyricsto': LyricsTo,
    }
    @_commands(*_lyricmode_commands)
    def handle_lyricmode(self, t, source):
        cls = self._lyricmode_commands[t]
        item = self.factory(cls, t)
        if cls is LyricsTo:
            for t in skip(source):
                if isinstance(t, lilypond.Name):
                    item._context_id = t
                elif isinstance(t, (lex.String, lilypond.SchemeStart)):
                    item._context_id = self.read_item(t)
                else:
                    self.source.pushback()
                break
        for t in skip(self.consume()):
            i = self.read_lyric_item(t) or self.read_item(t)
            if i:
                item.append(i)
            break
        return item
    
    def read_lyric_item(self, t):
        """Read one lyric item. Returns None for tokens it does not handle."""
        if isinstance(t, (lex.StringStart, lilypond.MarkupStart)):
            item = self.factory(LyricText, position=t.pos)
            item.append(self.read_item(t))
            self.add_duration(item)
            return item
        elif isinstance(t, lilypond.LyricText):
            item = self.factory(LyricText, t)
            self.add_duration(item)
            return item
        elif isinstance(t, lilypond.Lyric):
            return self.factory(LyricItem, t)
        else:
            item, source = self.test_music_list(t)
            if item:
                if source:
                    for t in skip(source):
                        i = self.read_lyric_item(t) or self.read_item(t)
                        if i:
                            item.append(i)
                return item
    
    @_commands('\\stringTuning')
    def handle_string_tuning(self, t, source):
        item = self.factory(StringTuning, t)
        for arg in self.read(source):
            item.append(arg)
            break
        return item
    
    @_commands('\\partcombine')
    def handle_partcombine(self, t, source=None):
        item = self.factory(PartCombine, t)
        item.extend(itertools.islice(self.read(), 2))
        return item
    
    @_keywords('\\language')
    def handle_language(self, t, source):
        item = self.factory(Language, t)
        for name in self.read(source):
            item.append(name)
            if isinstance(name, String):
                value = item.language = name.value()
                if value in ly.pitch.pitchInfo:
                    self.language = value
            break
        return item
    
    @_keywords('\\include')
    def handle_include(self, t, source):
        item = None
        name = None
        for name in self.read(source):
            if isinstance(name, String):
                value = name.value()
                if value.endswith('.ly') and value[:-3] in ly.pitch.pitchInfo:
                    item = self.factory(Language, t)
                    item.language = self.language = value[:-3]
                    item.append(name)
            break
        if not item:
            item = self.factory(Include, t)
            if name:
                item.append(name)
        return item
    
    @_keywords('\\version')
    def handle_version(self, t, source):
        item = self.factory(Version, t)
        for arg in self.read(source):
            item.append(arg)
            break
        return item
    
    _bracketed_keywords = {
        '\\header': Header,
        '\\score': Score,
        '\\bookpart': BookPart,
        '\\book': Book,
        '\\paper': Paper,
        '\\layout': Layout,
        '\\midi': Midi,
        '\\with': With,
        '\\context': LayoutContext,
    }
    @_keywords(*_bracketed_keywords)
    def handle_bracketed(self, t, source):
        cls = self._bracketed_keywords[t]
        item = self.factory(cls, t)
        if not self.add_bracketed(item, source) and t == '\\with':
            # \with also supports one other argument instead of { ... }
            for i in self.read(source):
                item.append(i)
                break
        return item
    
    @_keywords('\\set')
    def handle_set(self, t, source):
        item = self.factory(Set, t)
        tokens = []
        for t in skip(source):
            tokens.append(t)
            if isinstance(t, lilypond.EqualSign):
                item.tokens = tuple(tokens)
                for i in self.read(source):
                    item.append(i)
                    break
                break
        return item
    
    @_keywords('\\unset')
    def handle_unset(self, t, source):
        item = self.factory(Unset, t)
        tokens = []
        for t in skip(self.consume()):
            if type(t) not in lilypond.ParseUnset.items:
                self.source.pushback()
                break
            tokens.append(t)
        item.tokens = tuple(tokens)
        return item
    
    @_keywords('\\override')
    def handle_override(self, t, source):
        item = self.factory(Override, t)
        for t in skip(self.consume()):
            if isinstance(t, (lex.StringStart, lilypond.SchemeStart)):
                item.append(self.read_item(t))
            elif isinstance(t, lilypond.EqualSign):
                item.tokens = (t,)
                for i in self.read():
                    item.append(i)
                    break
                break
            else:
                item.append(self.factory(PathItem, t))
        return item
    
    @_keywords('\\revert')
    def handle_revert(self, t, source):
        item = self.factory(Revert, t)
        t = None
        for t in skip(self.consume()):
            if type(t) in lilypond.ParseRevert.items:
                item.append(self.factory(PathItem, t))
            else:
                break
        if isinstance(t, lilypond.SchemeStart) and not any(
                isinstance(i.token, lilypond.GrobProperty) for i in item):
            item.append(self.read_scheme_item(t))
        else:
            self.source.pushback()
        return item
    
    @_keywords('\\tweak')
    def handle_tweak(self, t, source):
        item = self.factory(Tweak, t)
        t = None
        for t in skip(self.consume()):
            if type(t) in lilypond.ParseTweak.items:
                item.append(self.factory(PathItem, t))
            else:
                self.source.pushback()
                break
        if len(item) == 0 and isinstance(t, lilypond.SchemeStart):
            item.append(self.read_scheme_item(t))
        for i in self.read():
            item.append(i)
            break
        return item
    
    @_commands('\\markup', '\\markuplist', '\\markuplines')
    def handle_markup(self, t, source=None):
        item = self.factory(Markup, t)
        self.add_markup_arguments(item)
        return item
        
    def read_markup(self, t):
        """Read LilyPond markup (recursively)."""
        meth = self._markup.method(t)
        if meth:
            return meth(self, t)
    
    @_markup(lilypond.MarkupScore)
    def handle_markup_score(self, t):
        item = self.factory(MarkupScore, t)
        for t in self.consume():
            if isinstance(t, lilypond.OpenBracket):
                item.tokens = (t,)
                def last(t): item.tokens += (t,)
                item.extend(self.read(self.consume(last)))
                return item
            elif not isinstance(t, lex.Space):
                self.source.pushback()
                break
        return item
    
    @_markup(lilypond.MarkupCommand)
    def handle_markup_command(self, t):
        item = self.factory(MarkupCommand, t)
        self.add_markup_arguments(item)
        return item
    
    @_markup(lilypond.MarkupUserCommand)
    def handle_markup_user_command(self, t):
        item = self.factory(MarkupUserCommand, t)
        return item
    
    @_markup(lilypond.OpenBracketMarkup)
    def handle_markup_open_bracket(self, t):
        item = self.factory(MarkupList, t)
        self.add_markup_arguments(item)
        return item
    
    @_markup(lilypond.MarkupWord)
    def handle_markup_word(self, t):
        return self.factory(MarkupWord, t)
    
    def add_markup_arguments(self, item):
        """Add markup arguments to the item."""
        for t in self.consume():
            i = self.read_markup(t)
            if i:
                item.append(i)
            elif isinstance(item, MarkupList) and isinstance(t, lilypond.CloseBracketMarkup):
                item.tokens = (t,)
        return item
    
    def read_scheme_item(self, t):
        """Reads a Scheme expression (just after the # in LilyPond mode)."""
        item = self.factory(Scheme, t)
        for t in self.consume():
            if not isinstance(t, lex.Space):
                i = self.read_scheme(t)
                if i:
                    item.append(i)
                    break
        return item

    def read_scheme(self, t):
        """Return a Scheme item from the token t."""
        meth = self._scheme.method(t)
        if meth:
            return meth(self, t)
        
    @_scheme(scheme.Quote)
    def handle_scheme_quote(self, t):
        item = self.factory(SchemeQuote, t)
        for t in self.consume():
            if not isinstance(t, lex.Space):
                i = self.read_scheme(t)
                if i:
                    item.append(i)
                    break
        return item
    
    @_scheme(scheme.OpenParen)
    def handle_scheme_open_parenthesis(self, t):
        item = self.factory(SchemeList, t)
        def last(t): item.tokens = (t,)
        for t in self.consume(last):
            if not isinstance(t, lex.Space):
                i = self.read_scheme(t)
                if i:
                    item.append(i)
        return item
    
    @_scheme(
        scheme.Dot,
        scheme.Bool,
        scheme.Char,
        scheme.Word,
        scheme.Number,
        scheme.Fraction,
        scheme.Float,
    )
    def handle_scheme_token(self, t):
        return self.factory(SchemeItem, t)
    
    @_scheme(scheme.LilyPondStart)
    def handle_scheme_lilypond_start(self, t):
        item = self.factory(SchemeLily, t)
        def last(t): item.tokens = (t,)
        item.extend(self.read(self.consume(last)))
        return item



########NEW FILE########
__FILENAME__ = create_musicxml
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Export to Music XML
Uses xml.etree to create the XML document
"""

from __future__ import unicode_literals

import sys
try:
    import xml.etree.cElementTree as etree
except ImportError:
    import xml.etree.ElementTree as etree


import ly.pkginfo


class create_musicXML():
    """ creates the XML-file from the source code according to the Music XML standard """

    def __init__(self):
        """ creates the basic structure of the XML without any music
        TODO:
        set doctype
        """
        self.root = etree.Element("score-partwise", version="3.0")
        self.tree = etree.ElementTree(self.root)
        identification = etree.SubElement(self.root, "identification")
        encoding = etree.SubElement(identification, "encoding")
        software = etree.SubElement(encoding, "software")
        software.text = ly.pkginfo.name + " " + ly.pkginfo.version
        encoding_date = etree.SubElement(encoding, "encoding-date")
        import datetime
        encoding_date.text = str(datetime.date.today())
        self.partlist = etree.SubElement(self.root, "part-list")
        self.part_count = 1

    ##
    # Building the basic Elements
    ##

    def create_part(self, name):
        """ create a new part """
        part = etree.SubElement(self.partlist, "score-part", id="P"+str(self.part_count))
        partname = etree.SubElement(part, "part-name")
        partname.text = name
        self.current_part = etree.SubElement(self.root, "part", id="P"+str(self.part_count))
        self.part_count +=1
        self.bar_nr = 1

    def create_measure(self):
        """ create new measure """
        self.current_bar = etree.SubElement(self.current_part, "measure", number=str(self.bar_nr))
        self.bar_nr +=1

    ##
    # High-level node creation
    ##

    def new_note(self, grace, pitch, base_scaling, voice, durtype, divs, dot, chord):
        """ create all nodes needed for a note. """
        self.create_note()
        if grace[0]:
            self.add_grace(grace[1])
        if chord:
            self.add_chord()
        self.add_pitch(pitch[0], pitch[1], pitch[2])
        if not grace[0]:
            self.add_div_duration(self.count_duration(base_scaling, divs, dot))
        self.add_voice(voice)
        self.add_duration_type(durtype)
        if dot:
            for i in range(dot):
                self.add_dot()
        if pitch[1]:
            self.add_accidental(pitch[1])

    def tuplet_note(self, fraction, base_scaling, ttype, divs):
        """ convert current note to tuplet """
        base = base_scaling[0]
        scaling = base_scaling[1]
        a = divs*4*fraction.denominator
        b = (1/base)*fraction.numerator
        duration = (a/b)*scaling
        self.change_div_duration(duration)
        self.add_time_modify(fraction)
        if ttype:
            self.add_notations()
            self.add_tuplet_type(ttype)

    def tie_note(self, tie_type):
        self.add_tie(tie_type)
        self.add_notations()
        self.add_tied(tie_type)

    def new_rest(self, base_scaling, durtype, divs, pos, dot, voice):
        """ create all nodes needed for a rest. """
        self.create_note()
        self.add_rest(pos)
        self.add_div_duration(self.count_duration(base_scaling, divs, dot))
        self.add_voice(voice)
        if durtype:
            self.add_duration_type(durtype)
        if dot:
            for i in range(dot):
                self.add_dot()

    def new_skip(self, base_scaling, divs):
        base = base_scaling[0]
        scaling = base_scaling[1]
        duration = divs*4*base*scaling
        self.add_skip(duration)

    def new_bar_attr(self, clef, mustime, key, mode, divs):
        """ create all bar attributes set. """
        self.create_bar_attr()
        if divs:
            self.add_divisions(divs)
        if key>=0:
            self.add_key(key, mode)
        if mustime:
            self.add_time(mustime)
        if clef:
            sign, line, octch = clef
            self.add_clef(sign, line, oct_ch=octch)

    def new_backup(self, base_scaling, divs):
        self.add_backup(self.count_duration(base_scaling, divs, 0))

    def create_tempo(self, metronome, sound, dots):
        self.add_direction()
        self.add_metron_dir(metronome[0], metronome[1], dots)
        self.add_sound_dir(sound)

    def create_new_node(self, parentnode, nodename, txt):
        """ The Music XML language is extensive.
        This function can be used to create
        a non basic node not covered elsewhere in this script.
        TODO: add attributes
        """
        new_node = etree.SubElement(parentnode, nodename)
        new_node.text = str(txt)

    ##
    # Help functions
    ##

    def count_duration(self, base_scaling, divs, dot):
        base = base_scaling[0]
        scaling = base_scaling[1]
        if dot:
            import math
            den = int(math.pow(2,dot))
            num = int(math.pow(2,dot+1)-1)
            a = divs*4*num
            b = (1/base)*den
            duration = a/b
        else:
            duration = divs*4*base
        duration = duration * scaling
        return int(duration)


    ##
    # Low-level node creation
    ##

    def create_note(self):
        """ create new note """
        self.current_note = etree.SubElement(self.current_bar, "note")
        self.current_notation = None
        self.current_ornaments = None

    def add_pitch(self, step, alter, octave):
        """ create new pitch """
        pitch = etree.SubElement(self.current_note, "pitch")
        stepnode = etree.SubElement(pitch, "step")
        stepnode.text = str(step)
        if alter:
            altnode = etree.SubElement(pitch, "alter")
            altnode.text = str(alter)
        octnode = etree.SubElement(pitch, "octave")
        octnode.text = str(octave)

    def add_accidental(self, alter):
        """ create accidental """
        acc = etree.SubElement(self.current_note, "accidental")
        if alter == 1:
            acc.text = "sharp"
        elif alter == 2:
            acc.text = "double-sharp"
        elif alter == -1:
            acc.text = "flat"
        elif alter == -2:
            acc.text = "flat-flat"

    def add_rest(self, pos):
        """ create rest """
        restnode = etree.SubElement(self.current_note, "rest")
        if pos:
            step = etree.SubElement(restnode, "display-step")
            octave = etree.SubElement(restnode, "display-octave")
            step.text = str(pos[0])
            octave.text = str(pos[1])

    def add_skip(self, duration, forward=True):
        if forward:
            skip = etree.SubElement(self.current_bar, "forward")
        else:
            skip = etree.SubElement(self.current_bar, "backward")
        dura_node = etree.SubElement(skip, "duration")
        dura_node.text = str(duration)

    def add_div_duration(self, divdur):
        """ create new duration """
        self.duration = etree.SubElement(self.current_note, "duration")
        self.duration.text = str(divdur)

    def change_div_duration(self, newdura):
        """ set new duration when tuplet """
        self.duration.text = str(newdura)

    def add_duration_type(self, durtype):
        """ create new type """
        typenode = etree.SubElement(self.current_note, "type")
        typenode.text = str(durtype)

    def add_dot(self):
        """ create a dot """
        etree.SubElement(self.current_note, "dot")

    def add_tie(self, tie_type):
        """ create node tie (used for sound of tie) """
        etree.SubElement(self.current_note, "tie", type=tie_type)

    def add_grace(self, slash):
        """ create grace node """
        if slash:
            etree.SubElement(self.current_note, "grace", slash="yes")
        else:
            etree.SubElement(self.current_note, "grace")

    def add_notations(self):
        if not self.current_notation:
            self.current_notation = etree.SubElement(self.current_note, "notations")

    def add_tied(self, tie_type):
        """ create node tied (used for notation of tie) """
        etree.SubElement(self.current_notation, "tied", type=tie_type)

    def add_time_modify(self, fraction):
        """ create time modification """
        timemod_node = etree.SubElement(self.current_note, "time-modification")
        actual_notes = etree.SubElement(timemod_node, "actual-notes")
        actual_notes.text = str(fraction.numerator)
        norm_notes = etree.SubElement(timemod_node, "normal-notes")
        norm_notes.text = str(fraction.denominator)

    def add_tuplet_type(self, ttype):
        """ create tuplet with type attribute """
        etree.SubElement(self.current_notation, "tuplet", type=ttype)

    def add_ornaments(self):
        if not self.current_ornaments:
            self.add_notations()
            self.current_ornament = etree.SubElement(self.current_notation, "ornaments")

    def add_tremolo(self, trem_type, lines):
        self.add_ornaments()
        trem_node = etree.SubElement(self.current_ornament, "tremolo", type=trem_type)
        trem_node.text = str(lines)

    def create_bar_attr(self):
        """ create node attributes """
        self.bar_attr = etree.SubElement(self.current_bar, "attributes")

    def add_divisions(self, div):
        division = etree.SubElement(self.bar_attr, "divisions")
        division.text = str(div)

    def add_key(self, key, mode):
        keynode = etree.SubElement(self.bar_attr, "key")
        fifths = etree.SubElement(keynode, "fifths")
        fifths.text = str(key)
        modenode = etree.SubElement(keynode, "mode")
        modenode.text = str(mode)

    def add_time(self, timesign):
        if len(timesign)==3:
            timenode = etree.SubElement(self.bar_attr, "time", symbol=timesign[2])
        else:
            timenode = etree.SubElement(self.bar_attr, "time")
        beatnode = etree.SubElement(timenode, "beats")
        beatnode.text = str(timesign[0])
        typenode = etree.SubElement(timenode, "beat-type")
        typenode.text = str(timesign[1])

    def add_clef(self, sign, line, nr=0, oct_ch=0):
        if nr:
            clefnode = etree.SubElement(self.bar_attr, "clef", number=str(nr))
        else:
            clefnode = etree.SubElement(self.bar_attr, "clef")
        signnode = etree.SubElement(clefnode, "sign")
        signnode.text = str(sign)
        if line:
            linenode = etree.SubElement(clefnode, "line")
            linenode.text = str(line)
        if oct_ch:
            octchnode = etree.SubElement(clefnode, "clef-octave-change")
            octchnode.text = str(oct_ch)

    def add_barline(self, bl_type, repeat=None):
        barnode = etree.SubElement(self.current_bar, "barline", location="right")
        barstyle = etree.SubElement(barnode, "bar-style")
        barstyle.text = bl_type
        if repeat:
            repeatnode = etree.SubElement(barnode, "repeat", direction=repeat)

    def add_backup(self, duration):
        backupnode = etree.SubElement(self.current_bar, "backup")
        durnode = etree.SubElement(backupnode, "duration")
        durnode.text = str(duration)

    def add_voice(self, voice):
        voicenode = etree.SubElement(self.current_note, "voice")
        voicenode.text = str(voice)

    def add_staff(self, staff):
        staffnode = etree.SubElement(self.current_note, "staff")
        staffnode.text = str(staff)

    def add_staves(self, staves):
        stavesnode = etree.SubElement(self.bar_attr, "staves")
        stavesnode.text = str(staves)

    def add_chord(self):
        etree.SubElement(self.current_note, "chord")

    def add_direction(self, pos="above"):
        self.direction = etree.SubElement(self.current_bar, "direction", placement=pos)

    def add_metron_dir(self, unit, beats, dots):
        dirtypenode = etree.SubElement(self.direction, "direction-type")
        metrnode = etree.SubElement(dirtypenode, "metronome")
        bunode = etree.SubElement(metrnode, "beat-unit")
        bunode.text = unit
        if dots:
            for d in range(dots):
                etree.SubElement(metrnode, "beat-unit-dot")
        pmnode = etree.SubElement(metrnode, "per-minute")
        pmnode.text = str(beats)

    def add_sound_dir(self, midi_tempo):
        soundnode = etree.SubElement(self.direction, "sound", tempo=str(midi_tempo))



    ##
    # Create the XML document
    ##

    def musicxml(self, prettyprint=True):
        xml = MusicXML(self.tree)
        if prettyprint:
            xml.indent("  ")
        return xml


class MusicXML(object):
    """Represent a generated MusicXML tree."""
    def __init__(self, tree):
        self.tree = tree
        self.root = tree.getroot()

    def indent(self, indent="  "):
        """ add indent and linebreaks to the created XML tree """
        import ly.etreeutil
        ly.etreeutil.indent(self.root, indent)

    def tostring(self, encoding='UTF-8'):
        """ output etree as a XML document """
        return etree.tostring(self.root, encoding=encoding, method="xml")

    def write(self, file, encoding='UTF-8', doctype=True):
        """ write XML to a file (file obj or filename) """
        if doctype:
            f = open(file,'w')
            f.write(xml_decl_txt+"\n")
            f.write(doctype_txt+"\n")
            self.tree.write(f, encoding=encoding, xml_declaration=False)
        else:
            self.tree.write(file, encoding=encoding, xml_declaration=True, method="xml")

xml_decl_txt = """<?xml version="1.0" encoding="UTF-8"?>"""

doctype_txt = """<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 2.0 Partwise//EN"
                                "http://www.musicxml.org/dtds/partwise.dtd">"""

########NEW FILE########
__FILENAME__ = ly2xml_mediator
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Help class between the ly source parser and the XML creator
"""

from __future__ import unicode_literals

from fractions import Fraction

import ly.duration
import ly.pitch


class mediator():
    """ Help class between the ly source parser and the XML creator """

    def __init__(self):
        """ create global lists """
        self.score = []
        self.sections = []
        """ default and initial values """
        self.current_note = None
        self.divisions = 1
        self.duration = "4"
        self.base_scaling = [Fraction(1, 4), Fraction(1, 1)]
        self.dots = 0
        self.tied = False
        self.voice = 1
        self.current_chord = []
        self.new_chord = True

    def new_section(self, name):
        n = self.get_var_byname(name)
        if n:
            n.name = name+"-old"
        section = score_section(name)
        self.insert_into = section
        self.sections.append(section)
        self.bar = None

    def get_var_byname(self, name):
        for n in self.sections:
            if n.name == name:
                return n

    def new_part(self, piano=False):
        if piano:
            self.part = score_part(2)
        else:
            self.part = score_part()
        self.score.append(self.part)
        self.insert_into = self.part
        self.bar = None

    def new_voice(self, command):
        self.voice = get_voice(command)
        return self.voice

    def merge_variable(self, voice, varname, staff=False, org=None):
        """ Fetches variable as new voice """
        if org:
            merge_org = self.get_var_byname(org)
        else:
            merge_org = self.insert_into
        var = self.get_var_byname(varname)
        var_barlist = self.copy_barlist(var.barlist)
        varlen = len(var_barlist)
        if staff:
            if isinstance(merge_org.barlist[0][0], bar_attr):
                clef_one = merge_org.barlist[0][0].clef
                if clef_one:
                    merge_org.barlist[0][0].multiclef.append(clef_one)
                else:
                    merge_org.barlist[0][0].multiclef.append(['G',2])
                if isinstance(var_barlist[0][0], bar_attr):
                    clef_two = var_barlist[0][0].clef
                    if clef_two:
                        merge_org.barlist[0][0].multiclef.append(clef_two)
                    else:
                        merge_org.barlist[0][0].multiclef.append(['G',2])
                    merge_org.barlist[0][0].clef = 0
            self.set_staff(merge_org.barlist, 1, False)
            self.set_staff(var_barlist, 2)
        if voice>4:
            self.change_voice(var_barlist, voice, plusvoice=True)
        elif voice:
            self.change_voice(var_barlist, voice)
        for i, bar in enumerate(merge_org.barlist):
            if i < varlen:
                if self.check_bar(var_barlist[i]):
                    backup = self.create_backup(bar)
                    merge_org.barlist[i] = bar + [backup] + var_barlist[i]

    def change_voice(self, barlist, newvoice, del_barattr=True, plusvoice=False):
        for bar in barlist:
            orig = list(bar)
            for obj in orig:
                if isinstance(obj, bar_note) or isinstance(obj, bar_rest):
                    if plusvoice:
                        obj.voice += 4
                    else:
                        obj.voice = newvoice
                elif isinstance(obj, bar_attr):
                    if del_barattr:
                        bar.remove(obj)

    def set_staff(self, barlist, staffnr, del_barattr=True):
        for bar in barlist:
            orig= list(bar)
            for obj in orig:
                if isinstance(obj, bar_note) or isinstance(obj, bar_rest):
                    obj.staff = staffnr
                elif isinstance(obj, bar_attr):
                    if del_barattr:
                        bar.remove(obj)

    def create_backup(self, bar):
        b = 0
        s = 1
        for obj in bar:
            if isinstance(obj, bar_note) or isinstance(obj, bar_rest):
                if not obj.chord:
                    if obj.dot:
                        import math
                        den = int(math.pow(2,obj.dot))
                        num = int(math.pow(2,obj.dot+1)-1)
                        b += Fraction(num, den)*obj.duration[0]
                    else:
                        b += obj.duration[0]
                    s *= obj.duration[1]
            elif isinstance(obj, bar_backup):
                self.check_divs(b, s)
                return bar_backup([b,s])
        if b:
            self.check_divs(b, s)
        return bar_backup((b,s))

    def copy_barlist(self, barlist):
        """ Make copy of barlist to preserve original.
            Use before for example changing voice.
        """
        copylist = []
        for bar in barlist:
            copybar = []
            for obj in bar:
                import copy
                try:
                    copybar.append(copy.deepcopy(obj))
                except TypeError:
                    print "Warning element can't be copied!"
            copylist.append(copybar)
        return copylist

    def fetch_variable(self, varname):
        """ Fetches stored data for variable. """
        n = self.get_var_byname(varname)
        if n.barlist:
            if self.check_var(n.barlist):
                if self.insert_into.barlist and not self.check_bar(self.insert_into.barlist[-1]):
                    n.barlist[0] = self.insert_into.barlist[-1] + n.barlist[0]
                    self.insert_into.barlist.pop()
                self.insert_into.barlist.extend(n.barlist)
            elif isinstance(n.barlist[0][0], bar_attr):
                if self.bar is None:
                    self.new_bar()
                self.current_attr = n.barlist[0][0]
                self.bar.append(self.current_attr)

    def check_var(self, barlist):
        """ Check if barlist in variable is suitable for insert.
        For now if variable contains notes full bars are assumed."""
        for bar in barlist:
            for obj in bar:
                if isinstance(obj, bar_note):
                    return True
        return False

    def check_bar(self, bar):
        """ For variable handling.
        Ideally the function should check if the bar is incomplete.
        For now it only checks if the bar contains music. """
        for obj in bar:
            if isinstance(obj, bar_note) or isinstance(obj, bar_rest):
                if not obj.skip:
                    return True
        return False

    def check_score(self):
        """ if no part were created, place first variable as part. """
        if not self.score:
            self.new_part()
            self.part.barlist.extend(self.get_first_var())

    def get_first_var(self):
        for n in self.sections:
            if self.check_var(n.barlist):
                return n.barlist

    def set_first_bar(self, part):
        initime = '4/4'
        iniclef = 'G',2,0
        if not self.check_time(part.barlist[0]):
            try:
                part.barlist[0][0].set_time(initime, False)
            except AttributeError:
                print "Warning can't set initial time sign!"
        if not self.check_clef(part.barlist[0]):
            try:
                part.barlist[0][0].set_clef(iniclef)
            except AttributeError:
                print "Warning can't set initial clef sign!"
        part.barlist[0][0].divs = self.divisions
        if part.staves:
            part.barlist[0][0].staves = part.staves

    def check_time(self, bar):
        """ For now used to check first bar """
        for obj in bar:
            if isinstance(obj, bar_attr):
                if obj.time:
                    return True
            if isinstance(obj, bar_note) or isinstance(obj, bar_rest):
                return False

    def check_clef(self, bar):
        """ For now used to check first bar """
        for obj in bar:
            if isinstance(obj, bar_attr):
                if obj.clef or obj.multiclef:
                    return True
            if isinstance(obj, bar_note) or isinstance(obj, bar_rest):
                return False

    def new_bar(self):
        self.current_attr = bar_attr()
        self.bar = [self.current_attr]
        self.insert_into.barlist.append(self.bar)

    def create_barline(self, bl):
        barline = bar_attr()
        barline.set_barline(bl)
        self.bar.append(barline)
        self.new_bar()

    def new_repeat(self, rep):
        barline = bar_attr()
        barline.set_barline(rep)
        barline.repeat = rep
        if self.bar is None:
            self.new_bar()
        self.bar.append(barline)

    def new_key(self, key_name, mode_command):
        mode = mode_command[1:]
        if self.bar is None:
            self.new_bar()
        self.current_attr.set_key(get_fifths(key_name, mode), mode)

    def new_time(self, fraction, numeric=False):
        if self.bar is None:
            self.new_bar()
        self.current_attr.set_time(fraction, numeric)

    def new_clef(self, clefname):
        self.clef = clefname2clef(clefname)
        if self.bar is None:
            self.new_bar()
        self.current_attr.set_clef(self.clef)

    def set_relative(self, note_name):
        self.current_note = bar_note(note_name, self.base_scaling, self.duration, self.voice)
        self.set_prev_pitch()

    def set_prev_pitch(self):
        p = self.current_note.pitch
        self.prev_pitch = ly.pitch.Pitch(p.note, p.alter, p.octave)

    def new_note(self, note_name, pitch_mode):
        self.current_chord = []
        self.current_note = bar_note(note_name, self.base_scaling, self.duration, self.voice)
        if self.dots:
            self.current_note.dot = self.dots
        if pitch_mode == 'rel':
            self.current_note.set_octave("", True, self.prev_pitch)
        if self.tied:
            self.current_note.set_tie('stop')
            self.tied = False
        if self.bar is None:
            self.new_bar()
        self.bar.append(self.current_note)
        self.current_attr = bar_attr()
        self.set_prev_pitch()

    def create_chord(self, note_name, pitch_mode):
        if self.new_chord:
            self.new_note(note_name, pitch_mode)
            self.current_chord.append(self.current_note)
        else:
            self.current_chord.append(self.new_chordnote(note_name, pitch_mode, len(self.current_chord)))

    def new_chordnote(self, note_name, pitch_mode, chord_len):
        chord_note = bar_note(note_name, self.base_scaling, self.duration, self.voice)
        if self.dots:
            chord_note.dot = self.dots
        if pitch_mode == 'rel':
            chord_note.set_octave("", True, self.current_chord[chord_len-1].pitch)
        chord_note.chord = True
        self.bar.append(chord_note)
        return chord_note

    def new_rest(self, rtype, pos=0):
        self.current_chord = []
        if rtype == 'r':
            self.current_note = bar_rest(self.base_scaling, self.duration, pos, self.voice)
        elif rtype == 'R':
            self.current_note = bar_rest(self.base_scaling, self.duration, pos, self.voice, show_type=False)
        elif rtype == 's':
            self.current_note = bar_rest(self.base_scaling, self.duration, pos, self.voice, skip=True)
        if self.bar is None:
            self.new_bar()
        self.bar.append(self.current_note)
        self.current_attr = bar_attr()

    def note2rest(self):
        """ note used as rest position transformed to rest"""
        temp_note = self.current_note
        self.current_note = bar_rest(temp_note.duration, self.duration, [temp_note.base_note, temp_note.pitch.octave], self.voice)
        self.bar.pop()
        self.bar.append(self.current_note)

    def scale_rest(self, multp, new_bar=False):
        """ create multiple whole bar rests """
        import copy
        bar_copy = copy.deepcopy(self.bar)
        bar_copy[0] = bar_attr()
        for i in range(1, int(multp)):
            self.insert_into.barlist.append(bar_copy)
        if new_bar:
            self.new_bar()

    def new_duration(self, duration):
        base, scaling = ly.duration.base_scaling_string(duration)
        if self.current_chord:
            for c in self.current_chord:
                c.set_duration([base, scaling], duration)
        else:
            self.current_note.set_duration([base, scaling], duration)
        self.duration = duration
        self.base_scaling = [base, scaling]
        self.check_divs(base, scaling, self.current_note.tuplet)
        self.dots = 0

    def scale_duration(self, scale):
        base, scaling = ly.duration.base_scaling_string(self.duration+scale)
        self.current_note.set_duration([base, scaling])
        self.base_scaling = [base, scaling]
        self.check_divs(base, scaling, self.current_note.tuplet)

    def change_to_tuplet(self, fraction, ttype):
        tfraction = Fraction(fraction)
        tfraction = 1/tfraction # delete this row with new tuplet notation
        self.current_note.set_tuplet(tfraction, ttype)

    def new_dot(self):
        self.current_note.add_dot()
        self.dots = self.current_note.dot
        if self.current_chord:
            for c in range(1, len(self.current_chord)):
                self.current_chord[c].add_dot()
        import math
        num = int(math.pow(2,self.dots))
        den = int(math.pow(2,self.dots+1)-1)
        dots = ''
        for i in range(self.dots):
            dots += '.'
        base, scaling = ly.duration.base_scaling_string(self.duration+dots)
        self.check_divs(base, scaling, self.current_note.tuplet)

    def tie_to_next(self):
        if self.current_note.tie == 'stop': # only if previous was tied
            self.current_note.set_tie('continue')
        else:
            self.current_note.set_tie('start')
        self.tied = True

    def new_grace(self, slash):
        self.current_note.set_grace(slash)

    def new_tremolo(self, duration):
        self.current_note.set_tremolo(duration)

    def new_octave(self, octave, relative=False):
        chordlen = len(self.current_chord)
        if chordlen > 1:
            prevp = self.current_chord[chordlen - 2].pitch
            self.current_chord[-1].set_octave(octave, relative, prevp)
        else:
            self.current_note.set_octave(octave, relative, self.prev_pitch)
            self.set_prev_pitch()

    def new_tempo(self, unit, beats, dots):
        tempo = bar_attr()
        tempo.set_tempo(unit, beats, dots)
        if self.bar is None:
            self.new_bar()
        self.bar.append(tempo)

    def new_from_command(self, command):
        #print (command)
        pass

    def set_partname(self, name):
        self.part.name = name

    def check_divs(self, base, scaling, tfraction=0):
        """ The new duration is checked against current divisions """
        divs = self.divisions
        if scaling != 1:
            tfraction = scaling
        if(not tfraction):
            a = 4
            if base:
                b = 1/base
            else:
                b = 1
                print "Warning problem checking duration!"
        else:
            num = tfraction.numerator
            den = tfraction.denominator
            a = 4*den
            b = (1/base)*num
        c = a*divs
        predur, mod = divmod(c,b)
        if mod > 0:
            mult = get_mult(a,b)
            self.divisions = divs*mult


class score_part():
    """ object to keep track of part """
    def __init__(self, staves=0):
        self.name = ''
        self.barlist = []
        self.staves = staves

class score_section():
    """ object to keep track of music section """
    def __init__(self, name):
        self.name = name
        self.barlist = []

class bar_note():
    """ object to keep track of note parameters """
    def __init__(self, note_name, base_scaling, durval, voice):
        plist = notename2step(note_name)
        self.base_note = plist[0]
        self.pitch = ly.pitch.Pitch(plist[2], plist[1], 3)
        self.duration = base_scaling
        self.type = durval2type(durval)
        self.tuplet = 0
        self.dot = 0
        self.tie = 0
        self.grace = [0,0]
        self.tremolo = 0
        self.voice = voice
        self.staff = 0
        self.chord = False
        self.skip = False

    def set_duration(self, base_scaling, durval=0):
        self.duration = base_scaling
        self.dot = 0
        if durval:
            self.type = durval2type(durval)

    def set_octave(self, octmark, relative, prev_pitch):
        self.pitch.octave = ly.pitch.octaveToNum(octmark)
        if relative:
            self.pitch.makeAbsolute(prev_pitch)
        else:
            self.pitch.octave += 3; #adjusting to scientific pitch notation

    def set_tuplet(self, fraction, ttype):
        self.tuplet = fraction
        self.ttype = ttype

    def set_tie(self, tie_type):
        self.tie = tie_type

    def add_dot(self):
        self.dot = self.dot + 1

    def set_grace(self, slash):
        self.grace = [1,slash]

    def set_tremolo(self, duration):
        self.tremolo = dur2lines(duration)

class bar_rest():
    """ object to keep track of different rests and skips """
    def __init__(self, base_scaling, durval, pos, voice, show_type=True, skip=False):
        self.duration = base_scaling
        self.show_type = show_type
        if self.show_type:
            self.type = durval2type(durval)
        else:
            self.type = None
        self.skip = skip
        self.tuplet = 0
        self.dot = 0
        self.pos = pos
        self.voice = voice
        self.staff = 0
        self.chord = False

    def set_duration(self, base_scaling, durval=0, durtype=None):
        self.duration = base_scaling
        if durval:
            if self.show_type:
                self.type = durval2type(durval)
            else:
                self.type = None

    def add_dot(self):
        self.dot = self.dot + 1


class bar_attr():
    """ object that keep track of bar attributes, e.g. time sign, clef, key etc """
    def __init__(self):
        self.key = -1
        self.time = 0
        self.clef = 0
        self.mode = ''
        self.divs = 0
        self.barline = ''
        self.repeat = None
        self.staves = 0
        self.multiclef = []
        self.tempo = None

    def set_key(self, muskey, mode):
        self.key = muskey
        self.mode = mode

    def set_time(self, fraction, numeric):
        mustime = fraction.split('/')
        if not numeric and (fraction == '2/2' or fraction == '4/4'):
            mustime.append('common')
        self.time = mustime

    def set_clef(self, clef):
        self.clef = clef

    def set_barline(self, bl):
        self.barline = convert_barl(bl)

    def set_tempo(self, unit, beats, dots):
        self.tempo = tempo_dir(unit, beats, dots)

    def has_attr(self):
        check = False
        if self.key != -1:
            check = True
        elif self.time != 0:
            check = True
        elif self.clef != 0:
            check = True
        elif self.divs != 0:
            check = True
        return check


class bar_backup():
    """ Object that stores duration for backup """
    def __init__(self, duration):
        self.duration = duration


class tempo_dir():
    """ Object that stores tempo direction information """
    def __init__(self, unit, beats, dots, text=""):
        self.metr = durval2type(unit), beats
        self.text = text
        self.midi = self.set_midi_tempo(unit, beats, dots)
        self.dots = dots

    def set_midi_tempo(self, unit, beats, dots):
        u = Fraction(1,int(unit))
        if dots:
            import math
            den = int(math.pow(2,dots))
            num = int(math.pow(2,dots+1)-1)
            u *= Fraction(num, den)
        mult = 4*u
        return float(Fraction(beats)*mult)



##
# translation functions
##

def get_fifths(key, mode):
    sharpkeys = ['c', 'g', 'd', 'a', 'e', 'b', 'fis', 'cis', 'gis', 'dis', 'ais']
    flatkeys = ['c', 'f', 'bes', 'es', 'as', 'des', 'ges']
    if key in sharpkeys:
        fifths = sharpkeys.index(key)
    elif key in flatkeys:
        fifths = -flatkeys.index(key)
    if mode=='minor':
        return fifths-3
    elif mode=='major':
        return fifths

def clefname2clef(clefname):
    if clefname == "treble" or clefname == "violin" or clefname == "G":
        return 'G',2,0
    elif clefname == "bass" or clefname == "F":
        return 'F',4,0
    elif clefname == "alto" or clefname == "C":
        return 'C',3,0
    elif clefname == "tenor":
        return 'C',4,0
    elif clefname == "treble_8":
        return 'G',2,-1
    elif clefname == "bass_8":
        return 'F',4,-1
    elif clefname == "treble^8":
        return 'G',2,1
    elif clefname == "bass^8":
        return 'F',4,1
    elif clefname == "percussion":
        return 'percussion',0,0
    elif clefname == "tab":
        return 'TAB',5,0
    elif clefname == "soprano":
        return 'C',1,0
    elif clefname == "mezzosoprano":
        return 'C',2,0
    elif clefname == "baritone":
        return 'C',5,0
    elif clefname == "varbaritone":
        return 'F',3,0

def notename2step(note_name):
    alter = 0
    if len(note_name)>1:
        is_sharp = note_name.split('i')
        is_flat = note_name.split('e')
        note_name = note_name[0]
        if len(is_sharp)>1:
            alter = len(is_sharp)-1
        elif len(is_flat)>1:
            alter = -(len(is_flat)-1)
        else:
            alter = -1 #assuming 'as'
    base_list = ['c', 'd', 'e', 'f', 'g', 'a', 'b']
    try:
        note_num = base_list.index(note_name)
    except ValueError:
        print(note_name+" isn't recognised as a supported pitch name.")
        note_num = 0
    return [note_name.upper(), alter, note_num]

def durval2type(durval):
    xml_types = [
        "maxima", "long", "breve", "whole",
        "half", "quarter", "eighth",
        "16th", "32nd", "64th",
        "128th", "256th", "512th", "1024th", "2048th"
    ] # Note: 2048 is supported by ly but not by MusicXML!
    return xml_types[ly.duration.durations.index(durval)]

def dur2lines(dur):
    if dur == "8":
        return 1
    if dur == "16":
        return 2
    if dur == "32":
        return 3

def get_mult(num, den):
    from fractions import Fraction
    simple = Fraction(num, den)
    return simple.denominator

def convert_barl(bl):
    if bl == '|':
        return 'regular'
    elif bl == ':':
        return 'dotted'
    elif bl == 'dashed':
        return bl
    elif bl == '.':
        return 'heavy'
    elif bl == '||':
        return 'light-light'
    elif bl == '.|' or bl == 'forward':
        return 'heavy-light'
    elif bl == '.|.':
        return 'heavy-heavy'
    elif bl == '|.' or bl == 'backward':
        return 'light-heavy'
    elif bl == "'":
        return 'tick'

def get_voice(c):
    voices = ["voiceOne", "voiceTwo", "voiceThree", "voiceFour"]
    return voices.index(c)+1





########NEW FILE########
__FILENAME__ = lymus2musxml
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Export to Music XML.

Using ly.music source to convert to XML.

At the moment the status is test/experimental
and the function is not actual use.

"""

from __future__ import unicode_literals

import documentinfo
import ly.music

from . import create_musicxml
from . import ly2xml_mediator


class parse_source():
    """ creates the XML-file from the source code according to the Music XML standard """

    def __init__(self):
        self.musxml = create_musicxml.create_musicXML()
        self.mediator = ly2xml_mediator.mediator()
        self.prev_command = ''
        self.pitch_mode = 'abs'
        self.varname = ''
        self.can_create_sect = True
        self.tuplet = False
        self.scale = ''
        self.grace_seq = False
        self.new = False
        self.context = False
        self.voicenr = None
        self.voicecontext = False
        self.piano_staff = -1
        self.sim_list = []
        self.seq_list = []
        self.new_context = None
        self.simsectnr = 0
        self.is_chord = False
        self.new_tempo = 0
        self.tempo_dots = 0

    def parse_tree(self, doc):
        mustree = documentinfo.music(doc)
        print(mustree.dump())
        tree_nodes = mustree.iter_music()
        for m in tree_nodes:
            print(m)
            print(m.has_output())

    def musicxml(self, prettyprint=True):
        #self.mediator.check_score()
        self.iterate_mediator()
        xml = self.musxml.musicxml(prettyprint)
        return xml

    ##
    # The different source types from ly.lex.lilypond are here sent to translation.
    ##

    def Name(self, token):
        """ name of variable """
        self.varname = token

    def SimultaneousStart(self, token):
        """ << """
        if self.new_context:
            self.sim_list.append(self.new_context)
            self.new_context = None
        else:
            if not self.simsectnr:
                self.curr_sect = self.mediator.insert_into
            self.simsectnr += 1
            self.varname = "sim-sect-"+str(self.simsectnr)
            self.can_create_sect = True

    def SimultaneousEnd(self, token):
        """ >> """
        if self.sim_list:
            if self.sim_list[-1] == 'pianostaff':
                if self.piano_var:
                    self.mediator.merge_variable(5, self.piano_var, True)
                    self.piano_var = None
            self.sim_list.pop()
        elif self.simsectnr:
            self.mediator.insert_into = self.curr_sect
            self.mediator.fetch_variable("sim-sect-1")
            self.mediator.new_bar()
            self.simsectnr = 0

    def SequentialStart(self, token):
        """ SequentialStart = { """
        if self.prev_command[1:] == 'times':
            self.tuplet = True
            self.ttype = "start"
        elif self.prev_command[1:] == 'grace':
            self.grace_seq = True
        elif self.prev_command == 'repeat':
            self.mediator.new_repeat('forward')
            self.prev_command = ''
            self.seq_list.append('repeat')
        elif self.new_context:
            self.seq_list.append(self.new_context)
            self.new_context = None
        elif self.can_create_sect:
            self.mediator.new_section(self.varname)
            self.can_create_sect = False
            self.varname = ''
            self.prev_command = ''
            self.seq_list.append("section")

    def SequentialEnd(self, token):
        """ SequentialEnd = } """
        if self.tuplet:
            self.mediator.change_to_tuplet(self.fraction, "stop")
            self.tuplet = False
        elif self.grace_seq:
            self.grace_seq = False
        elif self.simsectnr:
            if self.simsectnr>1:
                self.mediator.merge_variable(self.simsectnr,
                "sim-sect-"+str(self.simsectnr), False, "sim-sect-1")
            self.simsectnr += 1
            self.varname = "sim-sect-"+str(self.simsectnr)
            self.can_create_sect = True
            self.seq_list.pop()
        elif self.seq_list:
            if self.seq_list[-1] == 'pianostaff':
                if self.piano_var:
                    self.mediator.merge_variable(5, self.piano_var, True)
                    self.piano_var = None
            elif self.seq_list[-1] == 'section':
                self.can_create_sect = True
            elif self.seq_list[-1] == 'repeat':
                self.mediator.new_repeat('backward')
                self.mediator.new_bar()
            self.seq_list.pop()
        else:
            self.prev_command = ''

    def ChordStart(self, token):
        """ < """
        self.is_chord = True
        self.mediator.new_chord = True

    def ChordEnd(self, token):
        """ > """
        self.is_chord = False

    def Score(self, token):
        self.new_context = "score"

    def New(self, token):
        """ \new """
        self.new = True

    def Context(self, token):
        """ \context """
        self.context = True

    def ContextName(self, token):
        """ Staff, Voice  """
        if token == "Staff":
            if self.new or self.context:
                self.new_context = "staff"
            if self.new and "pianostaff" not in self.get_context():
                self.create_part()
            elif self.piano_staff>=0:
                self.piano_staff += 1
        elif token == "PianoStaff":
            if self.new:
                self.create_part(True)
                self.new_context = "pianostaff"
                self.piano_staff = 0
        elif token == "Voice":
            self.voicecontext = True
        else:
            print token
            self.new_context = token

    def create_part(self, piano=False):
        self.mediator.new_part(piano)
        self.can_create_sect = False
        self.new = False
        self.context = False
        self.voicenr = None

    def ContextProperty(self, token):
        """ instrumentName, midiInstrument, etc """
        self.prev_command = token

    def get_context(self):
        curr_sim = ''
        curr_seq = ''
        if self.sim_list:
            curr_sim = self.sim_list[-1]
        if self.seq_list:
            curr_seq = self.seq_list[-1]
        return curr_sim, curr_seq

    def PipeSymbol(self, token):
        """ PipeSymbol = | """
        self.mediator.new_bar()

    def Clef(self, token):
        """ Clef \clef"""
        self.prev_command = "clef"

    def ClefSpecifier(self, token):
        """ clef name without quotation marks """
        if self.prev_command == 'clef':
            self.mediator.new_clef(token)
            self.prev_command = ''

    def PitchCommand(self, token):
        if token == '\\relative':
            self.pitch_mode = 'rel'
            self.prev_command = token[1:]
        elif token == '\key':
            self.prev_command = "key"

    def Note(self, token):
        """ notename, e.g. c, cis, a bes ... """
        if self.prev_command == "key":
            self.key = token
        elif self.prev_command == "relative":
            self.mediator.set_relative(token)
        elif self.is_chord:
            self.mediator.create_chord(token, self.pitch_mode)
            self.mediator.new_chord = False
        else:
            self.mediator.new_note(token, self.pitch_mode)
            if self.tuplet:
                self.mediator.change_to_tuplet(self.fraction, self.ttype)
                self.ttype = ""
            if self.prev_command[1:] == 'grace':
                self.mediator.new_grace(0)
                if not self.grace_seq:
                    self.prev_command = ''

    def Octave(self, token):
        """ a number of , or ' """
        if self.prev_command == "relative":
            self.mediator.new_octave(token)
            self.prev_command = ''
        else:
            if self.pitch_mode == 'rel':
                self.mediator.new_octave(token, True)
            else:
                self.mediator.new_octave(token)

    def Tempo(self, token):
        """ Tempo direction, e g '4 = 80' """
        self.new_tempo = 1

    def Length(self, token):
        """ note length/duration, e.g. 4, 8, 16 ... """
        if self.new_tempo:
            self.new_tempo = token
        else:
            self.duration = token
            self.mediator.new_duration(token)

    def IntegerValue(self, token):
        """ tempo value """
        if self.new_tempo:
            self.mediator.new_tempo(self.new_tempo, token, self.tempo_dots)
            self.new_tempo = 0
            self.tempo_dots = 0

    def TremoloDuration(self, token):
        """ duration of tremolo notes for tremolo marking """
        self.mediator.new_tremolo(token)

    def Dot(self, token):
        """ dot, . """
        if self.new_tempo:
            self.tempo_dots += 1
        else:
            self.mediator.new_dot()

    def Tie(self, token):
        """ tie ~ """
        self.mediator.tie_to_next()

    def Rest(self, token):
        """ rest, r or R. Note: NOT by command, i.e. \rest """
        if token == 'R':
            self.scale = token
        self.mediator.new_rest(token)

    def Spacer(self, token):
        """ invisible rest/spacer rest (s) """
        self.mediator.new_rest(token)
        self.scale = 's'

    def Skip(self, token):
        """ command \skip """
        self.mediator.new_rest('s')

    def Scaling(self, token):
        """ scaling, e.g. *3 or *2/3"""
        if self.scale == 'R' or self.scale == 's':
            self.mediator.scale_rest(token[1:])
            self.scale = ''
        else:
            self.mediator.scale_duration(token)

    def Fraction(self, token):
        """ fraction, e.g. 3/4
        can be used for time sign or tuplets """
        if self.prev_command == '\\time':
            self.mediator.new_time(token)
            self.prev_command = ''
        elif self.prev_command == '\\numericTimeSignature':
            self.mediator.new_time(token, numeric=True)
            self.prev_command = ''
        else:
            self.fraction = token

    def Keyword(self, token):
        self.prev_command = token

    def Repeat(self, token):
        self.prev_command = "repeat"

    def Command(self, token):
        """ \bar, \rest, \time, etc """
        if token == '\\rest':
            self.mediator.note2rest()
        elif token.find('voice') == 1:
            self.voicenr = self.mediator.new_voice(token[1:])
        elif self.prev_command != '\\numericTimeSignature':
            self.prev_command = token

    def UserCommand(self, token):
        if self.prev_command == 'key':
            self.mediator.new_key(self.key, token)
            self.prev_command = ''
        else:
            if self.voicecontext and self.voicenr>1:
                if self.piano_staff == 2:
                    self.mediator.merge_variable(self.voicenr, token[1:], org=self.piano_var)
                else:
                    self.mediator.merge_variable(self.voicenr, token[1:])
            elif self.piano_staff == 2:
                self.piano_var = token[1:]
                self.piano_staff = -1
            else:
                self.mediator.fetch_variable(token[1:])

    def String(self, token):
        if self.prev_command == 'clef':
            self.mediator.new_clef(token)
            self.prev_command = ''
        elif self.prev_command == '\\bar':
            self.mediator.create_barline(token)
            self.prev_command = ''
        elif self.prev_command == 'instrumentName':
            self.mediator.set_partname(token)
            self.prev_command = ''


    ##
    # The xml-file is built from the mediator objects
    ##

    def iterate_mediator(self):
        """ the mediator lists are looped through and outputed to the xml-file """
        for part in self.mediator.score:
            if part.barlist:
                self.musxml.create_part(part.name)
                self.mediator.set_first_bar(part)
            else:
                print "Warning: empty part: "+part.name
            for bar in part.barlist:
                self.musxml.create_measure()
                for obj in bar:
                    if isinstance(obj, ly2xml_mediator.bar_attr):
                        if obj.has_attr():
                            self.musxml.new_bar_attr(obj.clef, obj.time, obj.key, obj.mode, obj.divs)
                        if obj.repeat:
                            self.musxml.add_barline(obj.barline, obj.repeat)
                        elif obj.barline:
                            self.musxml.add_barline(obj.barline)
                        if obj.staves:
                            self.musxml.add_staves(obj.staves)
                        if obj.multiclef:
                            for i, m in enumerate(obj.multiclef):
                                self.musxml.add_clef(m[0], m[1], i+1)
                        if obj.tempo:
                            self.musxml.create_tempo(obj.tempo.metr, obj.tempo.midi, obj.tempo.dots)
                    elif isinstance(obj, ly2xml_mediator.bar_note):
                        self.musxml.new_note(obj.grace, [obj.base_note, obj.pitch.alter, obj.pitch.octave], obj.duration,
                        obj.voice, obj.type, self.mediator.divisions, obj.dot, obj.chord)
                        if obj.tie:
                            self.musxml.tie_note(obj.tie)
                        if obj.tuplet:
                            self.musxml.tuplet_note(obj.tuplet, obj.duration, obj.ttype, self.mediator.divisions)
                        if obj.tremolo:
                            self.musxml.add_tremolo("single", obj.tremolo)
                        if obj.staff:
                            self.musxml.add_staff(obj.staff)
                    elif isinstance(obj, ly2xml_mediator.bar_rest):
                        if obj.skip:
                            self.musxml.new_skip(obj.duration, self.mediator.divisions)
                        else:
                            self.musxml.new_rest(obj.duration, obj.type, self.mediator.divisions, obj.pos, obj.dot, obj.voice)
                        if obj.staff and not obj.skip:
                            self.musxml.add_staff(obj.staff)
                    elif isinstance(obj, ly2xml_mediator.bar_backup):
                        self.musxml.new_backup(obj.duration, self.mediator.divisions)



########NEW FILE########
__FILENAME__ = source2musxml
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Export to Music XML
Parsing source to convert to XML
"""

from __future__ import unicode_literals

import ly.lex

from . import create_musicxml
from . import ly2xml_mediator


class parse_source():
    """ creates the XML-file from the source code according to the Music XML standard """

    def __init__(self):
        self.musxml = create_musicxml.create_musicXML()
        self.mediator = ly2xml_mediator.mediator()
        self.prev_command = ''
        self.pitch_mode = 'abs'
        self.varname = ''
        self.can_create_sect = True
        self.tuplet = False
        self.scale = ''
        self.grace_seq = False
        self.new = False
        self.context = False
        self.voicenr = None
        self.voicecontext = False
        self.piano_staff = -1
        self.sim_list = []
        self.seq_list = []
        self.new_context = None
        self.simsectnr = 0
        self.is_chord = False
        self.new_tempo = 0
        self.tempo_dots = 0

    def parse_text(self, text, mode=None):
        state = ly.lex.state(mode) if mode else ly.lex.guessState(text)
        self.parse_tokens(state.tokens(text))

    def parse_tokens(self, tokens):
        for t in tokens:
            func_name = t.__class__.__name__ #get instance name
            if func_name != 'Space':
                try:
                    func_call = getattr(self, func_name)
                    func_call(t)
                except AttributeError:
                    # print "Warning: "+func_name+" not implemented!"
                    pass

    def musicxml(self, prettyprint=True):
        self.mediator.check_score()
        self.iterate_mediator()
        xml = self.musxml.musicxml(prettyprint)
        return xml

    ##
    # The different source types from ly.lex.lilypond are here sent to translation.
    ##

    def Name(self, token):
        """ name of variable """
        self.varname = token

    def SimultaneousStart(self, token):
        """ << """
        if self.new_context:
            self.sim_list.append(self.new_context)
            self.new_context = None
        else:
            if not self.simsectnr:
                self.curr_sect = self.mediator.insert_into
            self.simsectnr += 1
            self.varname = "sim-sect-"+str(self.simsectnr)
            self.can_create_sect = True

    def SimultaneousEnd(self, token):
        """ >> """
        if self.sim_list:
            if self.sim_list[-1] == 'pianostaff':
                if self.piano_var:
                    self.mediator.merge_variable(5, self.piano_var, True)
                    self.piano_var = None
            self.sim_list.pop()
        elif self.simsectnr:
            self.mediator.insert_into = self.curr_sect
            self.mediator.fetch_variable("sim-sect-1")
            self.mediator.new_bar()
            self.simsectnr = 0

    def SequentialStart(self, token):
        """ SequentialStart = { """
        if self.prev_command[1:] == 'times':
            self.tuplet = True
            self.ttype = "start"
        elif self.prev_command[1:] == 'grace':
            self.grace_seq = True
        elif self.prev_command == 'repeat':
            self.mediator.new_repeat('forward')
            self.prev_command = ''
            self.seq_list.append('repeat')
        elif self.new_context:
            self.seq_list.append(self.new_context)
            self.new_context = None
        elif self.can_create_sect:
            self.mediator.new_section(self.varname)
            self.can_create_sect = False
            self.varname = ''
            self.prev_command = ''
            self.seq_list.append("section")

    def SequentialEnd(self, token):
        """ SequentialEnd = } """
        if self.tuplet:
            self.mediator.change_to_tuplet(self.fraction, "stop")
            self.tuplet = False
        elif self.grace_seq:
            self.grace_seq = False
        elif self.simsectnr:
            if self.simsectnr>1:
                self.mediator.merge_variable(self.simsectnr,
                "sim-sect-"+str(self.simsectnr), False, "sim-sect-1")
            self.simsectnr += 1
            self.varname = "sim-sect-"+str(self.simsectnr)
            self.can_create_sect = True
            self.seq_list.pop()
        elif self.seq_list:
            if self.seq_list[-1] == 'pianostaff':
                if self.piano_var:
                    self.mediator.merge_variable(5, self.piano_var, True)
                    self.piano_var = None
            elif self.seq_list[-1] == 'section':
                self.can_create_sect = True
            elif self.seq_list[-1] == 'repeat':
                self.mediator.new_repeat('backward')
                self.mediator.new_bar()
            self.seq_list.pop()
        else:
            self.prev_command = ''

    def ChordStart(self, token):
        """ < """
        self.is_chord = True
        self.mediator.new_chord = True

    def ChordEnd(self, token):
        """ > """
        self.is_chord = False

    def Score(self, token):
        self.new_context = "score"

    def New(self, token):
        """ \new """
        self.new = True

    def Context(self, token):
        """ \context """
        self.context = True

    def ContextName(self, token):
        """ Staff, Voice  """
        if token == "Staff":
            if self.new or self.context:
                self.new_context = "staff"
            if self.new and "pianostaff" not in self.get_context():
                self.create_part()
            elif self.piano_staff>=0:
                self.piano_staff += 1
        elif token == "PianoStaff":
            if self.new:
                self.create_part(True)
                self.new_context = "pianostaff"
                self.piano_staff = 0
        elif token == "Voice":
            self.voicecontext = True
        else:
            print token
            self.new_context = token

    def create_part(self, piano=False):
        self.mediator.new_part(piano)
        self.can_create_sect = False
        self.new = False
        self.context = False
        self.voicenr = None

    def ContextProperty(self, token):
        """ instrumentName, midiInstrument, etc """
        self.prev_command = token

    def get_context(self):
        curr_sim = ''
        curr_seq = ''
        if self.sim_list:
            curr_sim = self.sim_list[-1]
        if self.seq_list:
            curr_seq = self.seq_list[-1]
        return curr_sim, curr_seq

    def PipeSymbol(self, token):
        """ PipeSymbol = | """
        self.mediator.new_bar()

    def Clef(self, token):
        """ Clef \clef"""
        self.prev_command = "clef"

    def ClefSpecifier(self, token):
        """ clef name without quotation marks """
        if self.prev_command == 'clef':
            self.mediator.new_clef(token)
            self.prev_command = ''

    def PitchCommand(self, token):
        if token == '\\relative':
            self.pitch_mode = 'rel'
            self.prev_command = token[1:]
        elif token == '\key':
            self.prev_command = "key"

    def Note(self, token):
        """ notename, e.g. c, cis, a bes ... """
        if self.prev_command == "key":
            self.key = token
        elif self.prev_command == "relative":
            self.mediator.set_relative(token)
        elif self.is_chord:
            self.mediator.create_chord(token, self.pitch_mode)
            self.mediator.new_chord = False
        else:
            self.mediator.new_note(token, self.pitch_mode)
            if self.tuplet:
                self.mediator.change_to_tuplet(self.fraction, self.ttype)
                self.ttype = ""
            if self.prev_command[1:] == 'grace':
                self.mediator.new_grace(0)
                if not self.grace_seq:
                    self.prev_command = ''

    def Octave(self, token):
        """ a number of , or ' """
        if self.prev_command == "relative":
            self.mediator.new_octave(token)
            self.prev_command = ''
        else:
            if self.pitch_mode == 'rel':
                self.mediator.new_octave(token, True)
            else:
                self.mediator.new_octave(token)

    def Tempo(self, token):
        """ Tempo direction, e g '4 = 80' """
        self.new_tempo = 1

    def Length(self, token):
        """ note length/duration, e.g. 4, 8, 16 ... """
        if self.new_tempo:
            self.new_tempo = token
        else:
            self.duration = token
            self.mediator.new_duration(token)

    def IntegerValue(self, token):
        """ tempo value """
        if self.new_tempo:
            self.mediator.new_tempo(self.new_tempo, token, self.tempo_dots)
            self.new_tempo = 0
            self.tempo_dots = 0

    def TremoloDuration(self, token):
        """ duration of tremolo notes for tremolo marking """
        self.mediator.new_tremolo(token)

    def Dot(self, token):
        """ dot, . """
        if self.new_tempo:
            self.tempo_dots += 1
        else:
            self.mediator.new_dot()

    def Tie(self, token):
        """ tie ~ """
        self.mediator.tie_to_next()

    def Rest(self, token):
        """ rest, r or R. Note: NOT by command, i.e. \rest """
        if token == 'R':
            self.scale = token
        self.mediator.new_rest(token)

    def Spacer(self, token):
        """ invisible rest/spacer rest (s) """
        self.mediator.new_rest(token)
        self.scale = 's'

    def Skip(self, token):
        """ command \skip """
        self.mediator.new_rest('s')

    def Scaling(self, token):
        """ scaling, e.g. *3 or *2/3"""
        if self.scale == 'R' or self.scale == 's':
            self.mediator.scale_rest(token[1:])
            self.scale = ''
        else:
            self.mediator.scale_duration(token)

    def Fraction(self, token):
        """ fraction, e.g. 3/4
        can be used for time sign or tuplets """
        if self.prev_command == '\\time':
            self.mediator.new_time(token)
            self.prev_command = ''
        elif self.prev_command == '\\numericTimeSignature':
            self.mediator.new_time(token, numeric=True)
            self.prev_command = ''
        else:
            self.fraction = token

    def Keyword(self, token):
        self.prev_command = token

    def Repeat(self, token):
        self.prev_command = "repeat"

    def KeySignatureMode(self, token):
        """ \minor, \major etc """
        if self.prev_command == 'key':
            self.mediator.new_key(self.key, token)
            self.prev_command = ''

    def Command(self, token):
        """ \bar, \rest, \time, etc """
        if token == '\\rest':
            self.mediator.note2rest()
        elif token.find('voice') == 1:
            self.voicenr = self.mediator.new_voice(token[1:])
        elif self.prev_command != '\\numericTimeSignature':
            self.prev_command = token

    def UserCommand(self, token):
        if self.voicecontext and self.voicenr>1:
            if self.piano_staff == 2:
                self.mediator.merge_variable(self.voicenr, token[1:], org=self.piano_var)
            else:
                self.mediator.merge_variable(self.voicenr, token[1:])
        elif self.piano_staff == 2:
            self.piano_var = token[1:]
            self.piano_staff = -1
        else:
            self.mediator.fetch_variable(token[1:])

    def String(self, token):
        if self.prev_command == 'clef':
            self.mediator.new_clef(token)
            self.prev_command = ''
        elif self.prev_command == '\\bar':
            self.mediator.create_barline(token)
            self.prev_command = ''
        elif self.prev_command == 'instrumentName':
            self.mediator.set_partname(token)
            self.prev_command = ''


    ##
    # The xml-file is built from the mediator objects
    ##

    def iterate_mediator(self):
        """ the mediator lists are looped through and outputed to the xml-file """
        for part in self.mediator.score:
            if part.barlist:
                self.musxml.create_part(part.name)
                self.mediator.set_first_bar(part)
            else:
                print "Warning: empty part: "+part.name
            for bar in part.barlist:
                self.musxml.create_measure()
                for obj in bar:
                    if isinstance(obj, ly2xml_mediator.bar_attr):
                        if obj.has_attr():
                            self.musxml.new_bar_attr(obj.clef, obj.time, obj.key, obj.mode, obj.divs)
                        if obj.repeat:
                            self.musxml.add_barline(obj.barline, obj.repeat)
                        elif obj.barline:
                            self.musxml.add_barline(obj.barline)
                        if obj.staves:
                            self.musxml.add_staves(obj.staves)
                        if obj.multiclef:
                            for i, m in enumerate(obj.multiclef):
                                self.musxml.add_clef(m[0], m[1], i+1)
                        if obj.tempo:
                            self.musxml.create_tempo(obj.tempo.metr, obj.tempo.midi, obj.tempo.dots)
                    elif isinstance(obj, ly2xml_mediator.bar_note):
                        self.musxml.new_note(obj.grace, [obj.base_note, obj.pitch.alter, obj.pitch.octave], obj.duration,
                        obj.voice, obj.type, self.mediator.divisions, obj.dot, obj.chord)
                        if obj.tie:
                            self.musxml.tie_note(obj.tie)
                        if obj.tuplet:
                            self.musxml.tuplet_note(obj.tuplet, obj.duration, obj.ttype, self.mediator.divisions)
                        if obj.tremolo:
                            self.musxml.add_tremolo("single", obj.tremolo)
                        if obj.staff:
                            self.musxml.add_staff(obj.staff)
                    elif isinstance(obj, ly2xml_mediator.bar_rest):
                        if obj.skip:
                            self.musxml.new_skip(obj.duration, self.mediator.divisions)
                        else:
                            self.musxml.new_rest(obj.duration, obj.type, self.mediator.divisions, obj.pos, obj.dot, obj.voice)
                        if obj.staff and not obj.skip:
                            self.musxml.add_staff(obj.staff)
                    elif isinstance(obj, ly2xml_mediator.bar_backup):
                        self.musxml.new_backup(obj.duration, self.mediator.divisions)



########NEW FILE########
__FILENAME__ = abs2rel
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Convert absolute music to relative music.
"""

from __future__ import unicode_literals

import itertools

import ly.lex.lilypond


def abs2rel(cursor):
    """Converts pitches from absolute to relative."""
    start = cursor.start
    cursor.start = 0
    
    source = ly.document.Source(cursor, True, tokens_with_position=True)

    pitches = ly.pitch.PitchIterator(source)
    psource = pitches.pitches()
    
    if start > 0:
        # consume tokens before the selection, following the language
        t = source.consume(pitches.tokens(), start)
        if t:
            psource = itertools.chain((t,), psource)
    
    # this class dispatches the tokens. we can't use a generator function
    # as that doesn't like to be called again while there is already a body
    # running.
    class gen(object):
        def __iter__(self):
            return self
        
        def __next__(self):
            t = next(psource)
            while isinstance(t, (ly.lex.Space, ly.lex.Comment)):
                t = next(psource)
            if t == '\\relative' and isinstance(t, ly.lex.lilypond.Command):
                relative()
                t = next(psource)
            elif isinstance(t, ly.lex.lilypond.ChordMode):
                consume() # do not change chords
                t = next(psource)
            elif isinstance(t, ly.lex.lilypond.MarkupScore):
                consume()
                t = next(psource)
            return t
        
        next = __next__
            
    tsource = gen()

    def getpitches(iterable):
        """Consumes iterable but only yields Pitch instances."""
        for p in iterable:
            if isinstance(p, ly.pitch.Pitch):
                yield p

    def context():
        """Consume tokens till the level drops (we exit a construct)."""
        depth = source.state.depth()
        for t in tsource:
            yield t
            if source.state.depth() < depth:
                return
    
    def consume():
        """Consume tokens from context() returning the last token, if any."""
        t = None
        for t in context():
            pass
        return t
    
    def relative():
        """Consume the whole \relative expression without doing anything. """
        # skip pitch argument
        t = next(tsource)
        if isinstance(t, ly.pitch.Pitch):
            t = next(tsource)
        
        while True:
            # eat stuff like \new Staff == "bla" \new Voice \notes etc.
            if isinstance(source.state.parser(), ly.lex.lilypond.ParseTranslator):
                t = consume()
            elif isinstance(t, ly.lex.lilypond.NoteMode):
                t = next(tsource)
            else:
                break
        
        if t in ('{', '<<', '<'):
            consume()
    
    # Do it!
    with cursor.document as document:
        for t in tsource:
            if t in ('{', '<<'):
                # Ok, parse current expression.
                pos = t.pos     # where to insert the \relative command
                lastPitch = None
                chord = None
                for t in context():
                    # skip commands with pitches that do not count
                    if isinstance(t, ly.lex.lilypond.PitchCommand):
                        consume()
                    elif isinstance(t, ly.lex.lilypond.ChordStart):
                        # Handle chord
                        chord = []
                    elif isinstance(t, ly.lex.lilypond.ChordEnd):
                        if chord:
                            lastPitch = chord[0]
                        chord = None
                    elif isinstance(t, ly.pitch.Pitch):
                        # Handle pitch
                        if lastPitch is None:
                            lastPitch = ly.pitch.Pitch.c1()
                            lastPitch.octave = t.octave
                            if t.note > 3:
                                lastPitch.octave += 1
                            document[pos:pos] = "\\relative {0} ".format(
                                    lastPitch.output(pitches.language))
                        p = t.copy()
                        t.makeRelative(lastPitch)
                        pitches.write(t)
                        lastPitch = p
                        # remember the first pitch of a chord
                        if chord == []:
                            chord.append(p)



########NEW FILE########
__FILENAME__ = rel2abs
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Convert relative music to absolute music.
"""

from __future__ import unicode_literals

import itertools

import ly.lex.lilypond


def rel2abs(cursor):
    """Converts pitches from relative to absolute."""
    start = cursor.start
    cursor.start = 0
    
    source = ly.document.Source(cursor, True, tokens_with_position=True)

    pitches = ly.pitch.PitchIterator(source)
    psource = pitches.pitches()
    
    if start > 0:
        # consume tokens before the selection, following the language
        t = source.consume(pitches.tokens(), start)
        if t:
            psource = itertools.chain((t,), psource)
    
    # this class dispatches the tokens. we can't use a generator function
    # as that doesn't like to be called again while there is already a body
    # running.
    class gen(object):
        def __iter__(self):
            return self
        
        def __next__(self):
            t = next(psource)
            while isinstance(t, (ly.lex.Space, ly.lex.Comment)):
                t = next(psource)
            if t == '\\relative' and isinstance(t, ly.lex.lilypond.Command):
                relative(t)
                t = next(psource)
            elif isinstance(t, ly.lex.lilypond.MarkupScore):
                consume()
                t = next(psource)
            return t
        
        next = __next__
            
    tsource = gen()
    
    def makeAbsolute(p, lastPitch):
        """Makes pitch absolute (honoring and removing possible octaveCheck)."""
        if p.octavecheck is not None:
            p.octave = p.octavecheck
            p.octavecheck = None
        else:
            p.makeAbsolute(lastPitch)
        pitches.write(p)
    
    def getpitches(iterable):
        """Consumes iterable but only yields Pitch instances."""
        for p in iterable:
            if isinstance(p, ly.pitch.Pitch):
                yield p

    def context():
        """Consume tokens till the level drops (we exit a construct)."""
        depth = source.state.depth()
        for t in tsource:
            yield t
            if source.state.depth() < depth:
                return
    
    def consume():
        """Consume tokens from context() returning the last token, if any."""
        t = None
        for t in context():
            pass
        return t
    
    def relative(t):
        pos = t.pos
        lastPitch = None
        
        t = next(tsource)
        if isinstance(t, ly.pitch.Pitch):
            lastPitch = t
            t = next(tsource)
        else:
            lastPitch = ly.pitch.Pitch.c1()
        
        # remove the \relative <pitch> tokens
        del document[pos:t.pos]
        
        while True:
            # eat stuff like \new Staff == "bla" \new Voice \notes etc.
            if isinstance(source.state.parser(), ly.lex.lilypond.ParseTranslator):
                t = consume()
            elif isinstance(t, (ly.lex.lilypond.ChordMode, ly.lex.lilypond.NoteMode)):
                t = next(tsource)
            else:
                break
        
        # now convert the relative expression to absolute
        if t in ('{', '<<'):
            # Handle full music expression { ... } or << ... >>
            for t in context():
                # skip commands with pitches that do not count
                if isinstance(t, ly.lex.lilypond.PitchCommand):
                    if t == '\\octaveCheck':
                        pos = t.pos
                        for p in getpitches(context()):
                            # remove the \octaveCheck
                            lastPitch = p
                            end = (p.accidental_token or p.octave_token or p.note_token).end
                            del document[pos:end]
                            break
                    else:
                        consume()
                elif isinstance(t, ly.lex.lilypond.ChordStart):
                    # handle chord
                    chord = [lastPitch]
                    for p in getpitches(context()):
                        makeAbsolute(p, chord[-1])
                        chord.append(p)
                    lastPitch = chord[:2][-1] # same or first
                elif isinstance(t, ly.pitch.Pitch):
                    makeAbsolute(t, lastPitch)
                    lastPitch = t
        elif isinstance(t, ly.lex.lilypond.ChordStart):
            # Handle just one chord
            for p in getpitches(context()):
                makeAbsolute(p, lastPitch)
                lastPitch = p
        elif isinstance(t, ly.pitch.Pitch):
            # Handle just one pitch
            makeAbsolute(t, lastPitch)
    
    # Do it!
    with cursor.document as document:
        for t in tsource:
            pass



########NEW FILE########
__FILENAME__ = translate
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Translating the language of pitch names
"""

from __future__ import unicode_literals

import ly.document
import ly.pitch


def translate(cursor, language):
    """Changes the language of the pitch names.
    
    May raise ly.pitch.PitchNameNotAvailable if the current pitch language
    has no quarter tones.
    
    Returns True if there also was a \language or \include language command 
    that was changed. If not and the cursor specified only a part of the 
    document, you could warn the user that a langauge or include command 
    should be added to the document. Or you could call insert_language to 
    add a language command to the top of the document.
    
    """
    start = cursor.start
    cursor.start = 0
    
    source = ly.document.Source(cursor, tokens_with_position=True)

    pitches = ly.pitch.PitchIterator(source)
    tokens = pitches.tokens()
    writer = ly.pitch.pitchWriter(language)
    
    if start > 0:
        # consume tokens before the selection, following the language
        source.consume(tokens, start)
        cursor.start = start
    
    changed = False # track change of \language or \include language command
    with cursor.document as d:
        for t in tokens:
            if isinstance(t, ly.lex.lilypond.Note):
                # translate the pitch name
                p = pitches.read(t)
                if p:
                    n = writer(*p)
                    if n != t:
                        d[t.pos:t.end] = n
            elif isinstance(t, ly.pitch.LanguageName):
                if t != language:
                    # change the language name in a command
                    d[t.pos:t.end] = language
                changed = True
    return changed


def insert_language(document, language, version=None):
    """Inserts a language command in the document.
    
    The command is inserted at the top or just below the version line.
    
    If the LilyPond version specified < (2, 13, 38), the \\include command 
    is used, otherwise the newer \\language command.
    
    """
    # maybe TODO: determine version automatically from document
    if version and version < (2, 13, 38):
        text = '\\include "{0}.ly"\n'
    else:
        text = '\\language "{0}"\n'
    text = text.format(language)
    # insert language command on top of file, but below version
    with document:
        for b in document:
            if '\\version' not in document.tokens(b):
                pos = document.position(b)
                document[pos:pos] = text
                break
        else:
            pos = document.size()
            document[pos:pos] = '\n\n' + text



########NEW FILE########
__FILENAME__ = transpose
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Transposing music.
"""

from __future__ import unicode_literals

from fractions import Fraction

import ly.lex.lilypond


class Transposer(object):
    """Transpose pitches.
    
    Instantiate with a from- and to-Pitch, and optionally a scale.
    The scale is a list with the pitch height of the unaltered step (0 .. 6).
    The default scale is the normal scale: C, D, E, F, G, A, B.
    
    """
    scale = (0, 1, 2, Fraction(5, 2), Fraction(7, 2), Fraction(9, 2), Fraction(11, 2))
        
    def __init__(self, fromPitch, toPitch, scale = None):
        if scale is not None:
            self.scale = scale
        
        # the number of octaves we need to transpose
        self.octave = toPitch.octave - fromPitch.octave
        
        # the number of base note steps (c->d == 1, e->f == 1, etc.)
        self.steps = toPitch.note - fromPitch.note
        
        # the number (fraction) of real whole steps
        self.alter = (self.scale[toPitch.note] + toPitch.alter -
                      self.scale[fromPitch.note] - fromPitch.alter)
                  
    def transpose(self, pitch):
        doct, note = divmod(pitch.note + self.steps, 7)
        pitch.alter += self.alter - doct * 6 - self.scale[note] + self.scale[pitch.note]
        pitch.octave += self.octave + doct
        pitch.note = note
        # change the step if alterations fall outside -1 .. 1
        while pitch.alter > 1:
            doct, note = divmod(pitch.note + 1, 7)
            pitch.alter -= doct * 6 + self.scale[note] - self.scale[pitch.note]
            pitch.octave += doct
            pitch.note = note
        while pitch.alter < -1:
            doct, note = divmod(pitch.note - 1, 7)
            pitch.alter += doct * -6 + self.scale[pitch.note] - self.scale[note]
            pitch.octave += doct
            pitch.note = note


class ModalTransposer(object):
    """Transpose pitches by number of steps within a given scale.
    
    Instantiate with the number of steps (+/-) in the scale to transpose by, and a mode index.
    The mode index is the index of the major scale in the circle of fifths (C Major = 0).
    """        
    def __init__(self, numSteps = 1, scaleIndex = 0):
        self.numSteps = numSteps
        self.notes = [0, 1, 2, 3, 4, 5, 6]
        self.alter = [-0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5]
        # Initialize to Db, then update to desired mode
        
        for i in range(0, scaleIndex):
            keyNameIndex = ((i+1)*4)%len(self.notes)
            accidentalIndex = (keyNameIndex-1)%len(self.notes)
            self.alter[accidentalIndex] += .5
            
    @staticmethod
    def getKeyIndex(text):
        """Get the index of the key in the circle of fifths.
        
        'Cb' returns 0, 'C' returns 7, 'B#' returns 14.
        """
        circleOfFifths = ['Cb','Gb','Db','Ab','Eb','Bb','F','C','G','D','A','E','B','F#','C#']
        return circleOfFifths.index(text.capitalize())
                  
    def transpose(self, pitch):
        # Look for an exact match: otherwise,
        # look for the letter name and save the accidental
        for i in range(len(self.notes)):
            if pitch.note == self.notes[i] and \
               pitch.alter == self.alter:
                    fromScaleDeg = i
                    accidental = 0
                    break;
        else:
            fromScaleDeg = self.notes.index(pitch.note)
            accidental = pitch.alter - self.alter[fromScaleDeg]
        
        toOctaveMod, toScaleDeg = divmod(fromScaleDeg + self.numSteps, 7)
        pitch.note = self.notes[toScaleDeg]
        pitch.alter = self.alter[toScaleDeg] + accidental
        pitch.octave += toOctaveMod


def transpose(cursor, transposer):
    """Transpose pitches using the specified transposer."""
    start = cursor.start
    cursor.start = 0
    
    source = ly.document.Source(cursor, True, tokens_with_position=True)

    pitches = ly.pitch.PitchIterator(source)
    psource = pitches.pitches()

    class gen(object):
        def __iter__(self):
            return self
        
        def __next__(self):
            while True:
                t = next(psource)
                if isinstance(t, (ly.lex.Space, ly.lex.Comment)):
                    continue
                # Handle stuff that's the same in relative and absolute here
                if t == "\\relative":
                    relative()
                elif isinstance(t, ly.lex.lilypond.MarkupScore):
                    absolute(context())
                elif isinstance(t, ly.lex.lilypond.ChordMode):
                    chordmode()
                elif isinstance(t, ly.lex.lilypond.PitchCommand):
                    if t == "\\transposition":
                        next(psource) # skip pitch
                    elif t == "\\transpose":
                        for p in getpitches(context()):
                            transpose(p)
                    elif t == "\\key":
                        for p in getpitches(context()):
                            transpose(p, 0)
                    else:
                        return t
                else:
                    return t
        
        next = __next__
    
    tsource = gen()
    
    def in_selection(p):
        """Return True if the pitch or token p may be replaced, i.e. was selected."""
        return start == 0 or pitches.position(p) >= start
    
    def getpitches(iterable):
        """Consumes iterable but only yields Pitch instances."""
        for p in iterable:
            if isinstance(p, ly.pitch.Pitch):
                yield p

    def context():
        """Consume tokens till the level drops (we exit a construct)."""
        depth = source.state.depth()
        for t in tsource:
            yield t
            if source.state.depth() < depth:
                return
    
    def consume():
        """Consume tokens from context() returning the last token, if any."""
        t = None
        for t in context():
            pass
        return t
        
    def transpose(p, resetOctave = None):
        """Transpose absolute pitch, using octave if given."""
        transposer.transpose(p)
        if resetOctave is not None:
            p.octave = resetOctave
        if in_selection(p):
            pitches.write(p)

    def chordmode():
        """Called inside \\chordmode or \\chords."""
        for p in getpitches(context()):
            transpose(p, 0)
            
    def absolute(tokens):
        """Called when outside a possible \\relative environment."""
        for p in getpitches(tokens):
            transpose(p)
    
    def relative():
        """Called when \\relative is encountered."""
        def transposeRelative(p, lastPitch):
            """Transposes a relative pitch; returns the pitch in absolute form."""
            # absolute pitch determined from untransposed pitch of lastPitch
            p.makeAbsolute(lastPitch)
            if not in_selection(p):
                return p
            # we may change this pitch. Make it relative against the
            # transposed lastPitch.
            try:
                last = lastPitch.transposed
            except AttributeError:
                last = lastPitch
            # transpose a copy and store that in the transposed
            # attribute of lastPitch. Next time that is used for
            # making the next pitch relative correctly.
            newLastPitch = p.copy()
            transposer.transpose(p)
            newLastPitch.transposed = p.copy()
            if p.octavecheck is not None:
                p.octavecheck = p.octave
            p.makeRelative(last)
            if relPitch:
                # we are allowed to change the pitch after the
                # \relative command. lastPitch contains this pitch.
                lastPitch.octave += p.octave
                p.octave = 0
                pitches.write(lastPitch)
                del relPitch[:]
            pitches.write(p)
            return newLastPitch

        lastPitch = None
        relPitch = [] # we use a list so it can be changed from inside functions
        
        # find the pitch after the \relative command
        t = next(tsource)
        if isinstance(t, ly.pitch.Pitch):
            lastPitch = t
            if in_selection(t):
                relPitch.append(lastPitch)
            t = next(tsource)
        else:
            lastPitch = ly.pitch.Pitch.c1()
        
        while True:
            # eat stuff like \new Staff == "bla" \new Voice \notes etc.
            if isinstance(source.state.parser(), ly.lex.lilypond.ParseTranslator):
                t = consume()
            elif isinstance(t, ly.lex.lilypond.NoteMode):
                t = next(tsource)
            else:
                break
        
        # now transpose the relative expression
        if t in ('{', '<<'):
            # Handle full music expression { ... } or << ... >>
            for t in context():
                if t == '\\octaveCheck':
                    for p in getpitches(context()):
                        lastPitch = p.copy()
                        del relPitch[:]
                        if in_selection(p):
                            transposer.transpose(p)
                            lastPitch.transposed = p
                            pitches.write(p)
                elif isinstance(t, ly.lex.lilypond.ChordStart):
                    chord = [lastPitch]
                    for p in getpitches(context()):
                        chord.append(transposeRelative(p, chord[-1]))
                    lastPitch = chord[:2][-1] # same or first
                elif isinstance(t, ly.pitch.Pitch):
                    lastPitch = transposeRelative(t, lastPitch)
        elif isinstance(t, ly.lex.lilypond.ChordStart):
            # Handle just one chord
            for p in getpitches(context()):
                lastPitch = transposeRelative(p, lastPitch)
        elif isinstance(t, ly.pitch.Pitch):
            # Handle just one pitch
            transposeRelative(token, lastPitch)

    # Do it!
    with cursor.document as document:
        absolute(tsource)


########NEW FILE########
__FILENAME__ = pkginfo
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2014 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Information about the LY package.

"""

from __future__ import unicode_literals

name = "python-ly"
version = "0.4"
description = "Tool and library for manipulating LilyPond files"
long_description = \
    "The python-ly package provides a Python library and a commandline tool " \
    "that can be used to parse and manipulate LilyPond source files."
maintainer = "Wilbert Berendsen"
maintainer_email = "info@frescobaldi.org"
url = "http://www.frescobaldi.org/"
license = "GPL"


########NEW FILE########
__FILENAME__ = reformat
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Formatting tools to improve the readability of a ly.document.Document without
changing the semantic meaning of the LilyPond source.

Basically the tools only change whitespace to make the source-code more 
readable.

See also ly.indent.

"""

from __future__ import unicode_literals

import ly.indent
import ly.lex


def break_indenters(cursor):
    """Add newlines around indent and dedent tokens where needed.
    
    If there is stuff after a { or << (that's not closed on the same line) 
    it is put on a new line, and if there if stuff before a } or >>, the } 
    or >> is put on a new line.
    
    It is necessary to run the indenter again over the same part of the 
    document, as it will look garbled with the added newlines.
    
    """
    with cursor.document as d:
        for b in cursor.blocks():
            denters = []
            tokens = d.tokens(b)
            nonspace_index = -1
            for i, t in enumerate(tokens):
                if isinstance(t, ly.lex.Indent) and t in ('{', '<<'):
                    denters.append(i)
                elif isinstance(t, ly.lex.Dedent) and t in ('}', '>>'):
                    if denters:
                        denters.pop()
                    elif nonspace_index != -1:
                        # add newline before t
                        pos = d.position(b) + t.pos
                        d[pos:pos] = '\n'
                if not isinstance(t, ly.lex.Space):
                    nonspace_index = i
            for i in denters:
                if i < nonspace_index:
                    # add newline after tokens[i]
                    pos = d.position(b) + tokens[i].end
                    d[pos:pos] = '\n'


def move_long_comments(cursor):
    """Move line comments with more than 2 comment characters to column 0."""
    with cursor.document as d:
        for b in cursor.blocks():
            tokens = d.tokens(b)
            if (len(tokens) == 2
                and isinstance(tokens[0], ly.lex.Space)
                and isinstance(tokens[1], (
                    ly.lex.lilypond.LineComment,
                    ly.lex.scheme.LineComment))
                and tokens[1][:3] in ('%%%', ';;;')):
                del d[d.position(b):d.position(b) + tokens[1].pos]


def remove_trailing_whitespace(cursor):
    """Removes whitespace from all lines in the cursor's range."""
    with cursor.document as d:
        for b in cursor.blocks():
            tokens = d.tokens(b)
            if tokens:
                t = tokens[-1]
                end = d.position(b) + t.end
                if isinstance(t, ly.lex.Space):
                    del d[end-len(t):end]
                elif not isinstance(t, ly.lex.String):
                    offset = len(t) - len(t.rstrip())
                    if offset:
                        del d[end-offset:end]


def reformat(cursor, indenter):
    """A do-it-all function improving the LilyPond source formatting."""
    break_indenters(cursor)
    indenter.indent(cursor)
    move_long_comments(cursor)
    remove_trailing_whitespace(cursor)




########NEW FILE########
__FILENAME__ = rhythm
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Implementation of the tools to edit durations of selected music.

Durations are represented simply by lists of ly.lex.lilypond.Duration tokens.

All functions except a ly.document.Cursor with the selected range.

"""

from __future__ import unicode_literals

import itertools

import ly.document
import ly.lex.lilypond


durations = ['\\maxima', '\\longa', '\\breve',
    '1', '2', '4', '8', '16', '32', '64', '128', '256', '512', '1024', '2048']


def remove_dups(iterable):
    """Change reoccurring strings to '' in iterable."""
    old = None
    for i in iterable:
        yield '' if i == old else i
        old = i


def music_tokens(source, command=False, chord=False):
    """Yield lists of tokens describing rests, skips or pitches.
    
    source is a ly.document.Source instance following the state.
    
    The following keyword arguments can be used:
    - command: whether to allow pitches in \relative, \transpose, etc.
    - chord: whether to allow pitches inside chords.
    
    """
    skip_parsers = ()
    if not command:
        skip_parsers += (ly.lex.lilypond.ParsePitchCommand,)
    if not chord:
        skip_parsers += (ly.lex.lilypond.ParseChord,)

    for token in source:
        if isinstance(source.state.parser(), skip_parsers):
            continue
        while isinstance(token, _start):
            l = [token]
            for token in source:
                if isinstance(token, ly.lex.Space):
                    continue
                if not isinstance(token, _stay):
                    yield l
                    break
                l.append(token)
            else:
                yield l
                break
    
    
_start = (
    ly.lex.lilypond.Rest,
    ly.lex.lilypond.Skip,
    ly.lex.lilypond.Note,
    ly.lex.lilypond.ChordEnd,
    ly.lex.lilypond.Octave,
    ly.lex.lilypond.Accidental,
    ly.lex.lilypond.OctaveCheck,
    ly.lex.lilypond.Duration,
)

_stay = _start[4:]


def duration_tokens(source, *classes):
    """Yield lists of tokens where tokens in list are instance of *classes."""
    for tokens in music_tokens(source):
        yield [token for token in tokens if isinstance(token, classes)]

def duration_tokens_pos(source, *classes):
    """Yield tuples(pos, list of tokens) where tokens in list are instance of *classes.
    
    The list of tokens can be empty, the pos points to where a duration could be
    inserted.
    
    """
    for tokens in music_tokens(source):
        dur_tokens = [token for token in tokens if isinstance(token, classes)]
        pos = dur_tokens[0].pos if dur_tokens else tokens[-1].end
        yield pos, dur_tokens

def preceding_duration(cursor):
    """Return a preceding duration before the cursor, or an empty list."""
    tokens = ly.document.Runner.at(cursor).backward()
    for t in tokens:
        if isinstance(t, ly.lex.lilypond.Duration):
            l = [t]
            for t in tokens:
                if isinstance(t, ly.lex.lilypond.Duration):
                    l.append(t)
                elif not isinstance(t, ly.lex.Space):
                    break
            l.reverse()
            return l
    return []

def rhythm_double(cursor):
    """Doubles all duration values."""
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    with cursor.document as d:
        for tokens in duration_tokens(source, ly.lex.lilypond.Length):
            for token in tokens:
                try:
                    i = durations.index(token)
                except ValueError:
                    continue
                if i > 0:
                    d[token.pos:token.end] = durations[i - 1]

def rhythm_halve(cursor):
    """Halves all duration values."""
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    with cursor.document as d:
        for tokens in duration_tokens(source, ly.lex.lilypond.Length):
            for token in tokens:
                try:
                    i = durations.index(token)
                except ValueError:
                    continue
                if i < len(durations) - 1:
                    d[token.pos:token.end] = durations[i + 1]

def rhythm_dot(cursor):
    """Add a dot to all durations."""
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    with cursor.document as d:
        for tokens in duration_tokens(source, ly.lex.lilypond.Length):
            for token in tokens:
                d[token.end:token.end] = "."

def rhythm_undot(cursor):
    """Remove one dot from all durations."""
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    with cursor.document as d:
        for tokens in duration_tokens(source, ly.lex.lilypond.Dot):
            if tokens:
                del d[tokens[0].pos:tokens[0].end]

def rhythm_remove_scaling(cursor):
    """Remove the scaling (*3, *1/3) from all durations."""
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    with cursor.document as d:
        for tokens in duration_tokens(source, ly.lex.lilypond.Scaling):
            for token in tokens:
                del d[token.pos:token.end]
            
def rhythm_remove_fraction_scaling(cursor):
    """Remove the scaling containing fractions (*1/3) from all durations."""
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    with cursor.document as d:
        for tokens in duration_tokens(source, ly.lex.lilypond.Scaling):
            for token in tokens:
                if '/' in token:
                    del d[token.pos:token.end]

def rhythm_remove(cursor):
    """Remove all durations."""
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    with cursor.document as d:
        for tokens in duration_tokens(source, ly.lex.lilypond.Duration):
            if tokens:
                del d[tokens[0].pos:tokens[-1].end]

def rhythm_implicit(cursor):
    """Remove reoccurring durations."""
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    dtokens = duration_tokens(source, ly.lex.lilypond.Duration)
    for tokens in dtokens:
        break
    else:
        return
    prev = tokens or preceding_duration(cursor)
    with cursor.document as d:
        for tokens in dtokens:
            if tokens:
                if tokens == prev:
                    del d[tokens[0].pos:tokens[-1].end]
                prev = tokens

def rhythm_implicit_per_line(cursor):
    """Remove reoccurring durations, but always write one on a new line."""
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    dtokens = duration_tokens_pos(source, ly.lex.lilypond.Duration)
    for pos, tokens in dtokens:
        break
    else:
        return
    previous_block = source.block
    prev = tokens or preceding_duration(cursor)
    with cursor.document as d:
        for pos, tokens in dtokens:
            block = d.block(pos)
            if block != previous_block:
                if not tokens:
                    d[pos:pos] = ''.join(prev)
                else:
                    prev = tokens
                previous_block = block
            elif tokens:
                if tokens == prev:
                    del d[tokens[0].pos:tokens[-1].end]
                prev = tokens

def rhythm_explicit(cursor):
    """Make all durations explicit."""
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    dtokens = duration_tokens_pos(source, ly.lex.lilypond.Duration)
    for pos, tokens in dtokens:
        break
    else:
        return
    prev = tokens or preceding_duration(cursor)
    with cursor.document as d:
        for pos, tokens in dtokens:
            if tokens:
                prev = tokens
            else:
                d[pos:pos] = ''.join(prev)

def rhythm_overwrite(cursor, durations):
    """Apply a list of durations to the cursor's range.
    
    The durations list looks like ["4", "8", "", "16.",] etc.
    
    """
    durations_source = remove_dups(itertools.cycle(durations))
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    with cursor.document as d:
        for pos, tokens in duration_tokens_pos(source, ly.lex.lilypond.Duration):
            end = tokens[-1].end if tokens else pos
            d[pos:end] = next(durations_source)

def rhythm_extract(cursor):
    """Return a list of the durations from the cursor's range."""
    source = ly.document.Source(cursor, True)
    durations = list(duration_tokens(source, ly.lex.lilypond.Duration))
    # if the first duration was not given, find it
    if durations and not durations[0]:
        durations[0] = preceding_duration(cursor) or ['4']
    return ["".join(tokens) for tokens in durations]


########NEW FILE########
__FILENAME__ = util
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Utility functions.
"""

from __future__ import unicode_literals

import string


_nums = (
    '', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight',
    'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen',
    'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen')

_tens = (
    'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty',
    'Ninety')

def int2text(number):
    """Converts an integer to the English language name of that integer.
    
    E.g. converts 1 to "One". Supports numbers 0 to 999999.
    This can be used in LilyPond identifiers (that do not support digits).
    
    """
    result = []
    if number >= 1000:
        hundreds, number = divmod(number, 1000)
        result.append(int2text(hundreds) + "Thousand")
    if number >= 100:
        tens, number = divmod(number, 100)
        result.append(_nums[tens] + "Hundred")
    if number < 20:
        result.append(_nums[number])
    else:
        tens, number = divmod(number, 10)
        result.append(_tens[tens-2] + _nums[number])
    text = "".join(result)
    return text or 'Zero'


# Thanks: http://billmill.org/python_roman.html
_roman_numerals = (("M", 1000), ("CM", 900), ("D", 500), ("CD", 400),
("C", 100),("XC", 90),("L", 50),("XL", 40), ("X", 10), ("IX", 9), ("V", 5),
("IV", 4), ("I", 1))

def int2roman(n):
    if n < 1:
        raise ValueError('Roman numerals must be positive integers, got %s' % n)
    roman = []
    for ltr, num in _roman_numerals:
        k, n = divmod(n, num)
        roman.append(ltr * k)
    return "".join(roman)


def int2letter(number, chars=string.ascii_uppercase):
    """Converts an integer to one or more letters.
    
    E.g. 1 -> A, 2 -> B, ... 26 -> Z, 27 -> AA, etc.
    Zero returns the empty string.
    
    chars is the string to pick characters from, defaulting to
    string.ascii_uppercase.
    
    """
    mod = len(chars)
    result = []
    while number > 0:
        number, c = divmod(number - 1, mod)
        result.append(c)
    return "".join(chars[c] for c in reversed(result))


def mkid(*args):
    """Makes a lower-camel-case identifier of the strings in args.
    
    All strings are concatenated with the first character of every string
    uppercased, except for the first character, which is lowercased.
    
    Examples:
    mkid("Violin") ==> "violin"
    mkid("soprano", "verse") ==> "sopranoVerse"
    mkid("scoreOne", "choirII") ==> "scoreOneChoirII"
    
    """
    result = []
    for a in args[:1]:
        result.append(a[:1].lower())
        result.append(a[1:])
    for a in args[1:]:
        result.append(a[:1].upper())
        result.append(a[1:])
    return "".join(result)



########NEW FILE########
__FILENAME__ = words
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
LilyPond reserved words for auto completion and highlighting.
"""

from __future__ import unicode_literals


lilypond_keywords = (
    'accepts',
    'alias',
    'consists',
    'defaultchild',
    'denies',
    #'description',
    #'grobdescriptions',
    'hide', # since 2.18
    'include',
    #'invalid',
    'language',
    'name',
    #'objectid',
    'omit', # since 2.18
    'once',
    'set',
    'unset',
    'override',
    'revert',
    'remove',
    'temporary', # since 2.18
    #'sequential',
    #'simultaneous',
    #'type',
    'undo', # since 2.18 (not mentioned in the command index)
    'version',
    'score',
    'book',
    'bookpart',
    'header',
    'paper',
    'midi',
    'layout',
    'with',
    'context',
)


lilypond_music_commands = (
    'absolute', # since 2.18
    'acciaccatura',
    'accidentalStyle', # since 2.16
    'addChordShape', # since 2.16
    'addInstrumentDefinition',
    'addlyrics',
    'addQuote',
    'afterGrace',
    #'afterGraceFraction', # this is a parser variabl
    'aikenHeads',
    'aikenHeadsMinor',
    'allowPageTurn',
    'alterBroken', # since 2.18 (?)
    'alternative',
    #'AncientRemoveEmptyStaffContext',
    'appendToTag', # since 2.16
    'applyContext',
    'applyMusic',
    'applyOutput',
    'appoggiatura',
    'arpeggio',
    'arpeggioArrowDown',
    'arpeggioArrowUp',
    'arpeggioBracket',
    'arpeggioNormal',
    'arpeggioParenthesis',
    'ascendens',
    'auctum',
    'augmentum',
    'autoAccidentals',
    'autoBeamOff',
    'autoBeamOn',
    'autochange',
    'balloonGrobText',
    'balloonLengthOff',
    'balloonLengthOn',
    'balloonText',
    'bar',
    'barNumberCheck',
    'bassFigureExtendersOff',
    'bassFigureExtendersOn',
    'bassFigureStaffAlignmentDown',
    'bassFigureStaffAlignmentNeutral',
    'bassFigureStaffAlignmentUp',
    'bendAfter',
    'blackTriangleMarkup',
    'bookOutputName',
    'bookOutputSuffix',
    'bracketCloseSymbol',
    'bracketOpenSymbol',
    'break',
    'breathe',
    'breve',
    'cadenzaOff',
    'cadenzaOn',
    'caesura',
    'cavum',
    'change',
    'chordmode',
    #'chordNameSeparator',
    #'chordPrefixSpacer',
    #'chordRootNamer',
    'chordRepeats', # since 2.16
    'chords',
    'clef',
    'cm',
    'compoundMeter', # since 2.16
    'compressFullBarRests',
    'context',
    'cr',
    'cresc',
    'crescHairpin',
    'crescTextCresc',
    'crossStaff', # since 2.16
    'cueClef',  # since 2.16
    'cueClefUnset',  # since 2.16
    'cueDuring',
    'cueDuringWithClef',  # since 2.16
    'dashBar',
    'dashDash',
    'dashDot',
    'dashHat',
    'dashLarger',
    'dashPlus',
    'dashUnderscore',
    'deadNote',  # since 2.16
    'decr',
    'default',
    'defaultNoteHeads',  # since 2.16
    'defaultTimeSignature',
    'defineBarLine', # since 2.18
    'deminutum',
    'denies',
    'descendens',
    'dim',
    'dimHairpin',
    'dimTextDecr',
    'dimTextDecresc',
    'dimTextDim',
    'displayLilyMusic',
    'displayMusic',
    'divisioMaior',
    'divisioMaxima',
    'divisioMinima',
    'dotsDown',
    'dotsNeutral',
    'dotsUp',
    'drummode',
    'drumPitchTable',
    'drums',
    'dynamicDown',
    'dynamicNeutral',
    'dynamicUp',
    'easyHeadsOff',
    'easyHeadsOn',
    'endcr',
    'endcresc',
    'enddecr',
    'enddim',
    'endincipit',
    'endSpanners',
    'episemFinis',
    'episemInitium',
    'escapedBiggerSymbol',
    'escapedExclamationSymbol',
    'escapedParenthesisCloseSymbol',
    'escapedParenthesisOpenSymbol',
    'escapedSmallerSymbol',
    'expandFullBarRests',
    'f',
    'featherDurations',
    'fermataMarkup',
    'ff',
    'fff',
    'ffff',
    'fffff',
    'figuremode',
    'figures',
    'finalis',
    'fingeringOrientations',
    'flexa',
    'fp',
    'frenchChords',
    'fullJazzExceptions',
    'funkHeads',
    'funkHeadsMinor',
    'fz',
    'germanChords',
    'glissando',
    'grace',
    'graceSettings',
    'harmonic',
    'hideNotes',
    'hideStaffSwitch',
    'huge',
    'ignatzekExceptionMusic',
    'ignatzekExceptions',
    'iij',
    'IIJ',
    'ij',
    'IJ',
    'improvisationOff',
    'improvisationOn',
    'in',
    'inclinatum',
    'includePageLayoutFile',
    'indent',
    'instrumentSwitch',
    'instrumentTransposition',
    'interscoreline',
    'italianChords',
    'keepWithTag',
    'key',
    'killCues',
    'label',
    'laissezVibrer',
    'large',
    'ligature',
    'linea',
    'longa',
    'lyricmode',
    'lyrics',
    'lyricsto',
    'maininput',
    'majorSevenSymbol',
    'makeClusters',
    'mark',
    'markLengthOff', # since 2.18
    'markLengthOn',  # since 2.18
    'markup',
    'markuplines', # deprecated, till 2.14
    'markuplist', # from 2.16
    'maxima',
    'melisma',
    'melismaEnd',
    'mergeDifferentlyDottedOff',
    'mergeDifferentlyDottedOn',
    'mergeDifferentlyHeadedOff',
    'mergeDifferentlyHeadedOn',
    'mf',
    'mm',
    'mp',
    'musicMap',
    'neumeDemoLayout',
    'new',
    'newSpacingSection',
    'noBeam',
    'noBreak',
    'noPageBreak',
    'noPageTurn',
    'normalsize',
    'notemode',
    'numericTimeSignature',
    'octaveCheck',
    'oldaddlyrics',
    'oneVoice',
    'oriscus',
    'ottava',
    'override',
    'overrideProperty',
    'overrideTimeSignatureSettings',  # since 2.16
    'p',
    'pageBreak',
    'pageTurn',
    'palmMute',  # since 2.16
    'palmMuteOn',  # since 2.16
    'parallelMusic',
    'parenthesisCloseSymbol',
    'parenthesisOpenSymbol',
    'parenthesize',
    'partcombine',
    'partCombineListener',
    'partial',
    'partialJazzExceptions',
    'partialJazzMusic',
    'pes',
    'phrasingSlurDashed',
    'phrasingSlurDotted',
    'phrasingSlurDown',
    'phrasingSlurNeutral',
    'phrasingSlurSolid',
    'phrasingSlurUp',
    'pipeSymbol',
    'pitchedTrill',
    'pointAndClickOff',
    'pointAndClickOn',
    'pp',
    'ppp',
    'pppp',
    'ppppp',
    'predefinedFretboardsOff',
    'predefinedFretboardsOn',
    'pt',
    'pushToTag', # since 2.16
    'quilisma',
    'quoteDuring',
    'relative',
    'RemoveEmptyRhythmicStaffContext',
    'RemoveEmptyStaffContext',
    'removeWithTag',
    'repeat',
    'repeatTie',
    'resetRelativeOctave',
    'responsum',
    'rest',
    'revert',
    'rfz',
    'rightHandFinger',
    'sacredHarpHeads',
    'sacredHarpHeadsMinor',
    'scaleDurations',
    'scoreTweak',
    'semiGermanChords',
    'set',
    'sf',
    'sff',
    'sfp',
    'sfz',
    'shape', # since 2.16
    'shiftDurations',
    'shiftOff',
    'shiftOn',
    'shiftOnn',
    'shiftOnnn',
    'showStaffSwitch',
    'single', # since 2.18
    'skip',
    'skipTypesetting',
    'slurDashed',
    'slurDotted',
    'slurDown',
    'slurNeutral',
    'slurSolid',
    'slurUp',
    'small',
    'sostenutoOff',
    'sostenutoOn',
    'southernHarmonyHeads',
    'southernHarmonyHeadsMinor',
    'sp',
    'spacingTweaks',
    'spp',
    'startAcciaccaturaMusic',
    'startAppoggiaturaMusic',
    'startGraceMusic',
    'startGroup',
    'startStaff',
    'startTextSpan',
    'startTrillSpan',
    'stemDown',
    'stemNeutral',
    'stemUp',
    'stopAcciaccaturaMusic',
    'stopAppoggiaturaMusic',
    'stopGraceMusic',
    'stopGroup',
    'stopStaff',
    'stopTextSpan',
    'stopTrillSpan',
    'stringTuning', # since 2.16
    'strokeFingerOrientations',
    'stropha',
    'sustainOff',
    'sustainOn',
    'tabFullNotation',
    'tag',
    'teeny',
    'tempo',
    'tempoWholesPerMinute',
    'textLengthOff',
    'textLengthOn',
    'textSpannerDown',
    'textSpannerNeutral',
    'textSpannerUp',
    'tieDashed',
    'tieDotted',
    'tieDown',
    'tieNeutral',
    'tieSolid',
    'tieUp',
    'tildeSymbol',
    'time',
    'times',
    'timing',
    'tiny',
    'tocItem', # since ?
    'transpose',
    'transposedCueDuring',
    'transposition',
    'treCorde',
    'tuplet', # since 2.18
    'tupletDown',
    'tupletNeutral',
    'tupletUp',
    'tweak',
    'unaCorda',
    'unfoldRepeats',
    'unHideNotes',
    'unit',
    'unset',
    'versus',
    'virga',
    'virgula',
    'voiceFour',
    'voiceFourStyle',
    'voiceNeutralStyle',
    'voiceOne',
    'voiceOneStyle',
    'voiceThree',
    'voiceThreeStyle',
    'voiceTwo',
    'voiceTwoStyle',
    'walkerHeads',
    'walkerHeadsMinor',
    'whiteTriangleMarkup',
    'withMusicProperty',
)


articulations = (
    'accent',
    'espressivo',
    'marcato',
    'portato',
    'staccatissimo',
    'staccato',
    'tenuto',
)


ornaments = (
    'prall',
    'mordent',
    'prallmordent',
    'turn',
    'upprall',
    'downprall',
    'upmordent',
    'downmordent',
    'lineprall',
    'prallprall',
    'pralldown',
    'prallup',
    'reverseturn',
    'trill',
)
   

fermatas = (
    'shortfermata',
    'fermata',
    'longfermata',
    'verylongfermata',
)


instrument_scripts = (
    'upbow',
    'downbow',
    'flageolet',
    'thumb',
    'snappizzicato',
    'open',
    'halfopen',
    'stopped',
    'lheel',
    'rheel',
    'ltoe',
    'rtoe',
)


repeat_scripts = (
    'segno',
    'coda',
    'varcoda',
)


ancient_scripts = (
    'ictus',
    'accentus',
    'circulus',
    'semicirculus',
    'signumcongruentiae',
)


modes = (
    'major',     
    'minor',     
    'ionian',    
    'dorian',    
    'phrygian',  
    'lydian',    
    'mixolydian',
    'aeolian',   
    'locrian',   
)


markupcommands_nargs = (
# no arguments
(
    'doubleflat',
    'doublesharp',
    'eyeglasses',
    'flat',
    'natural',
    'null',
    'semiflat',
    'semisharp',
    'sesquiflat',
    'sesquisharp',
    'sharp',
    'strut',
    'table-of-contents'
),
# one argument
(
    'backslashed-digit',
    'bold',
    'box',
    'bracket',
    'caps',
    'center-align',
    'center-column',
    'char',
    'circle',
    'column',
    'concat',
    'dir-column',
    'draw-dashed-line', # since 2.18
    'draw-dotted-line', # since 2.18
    'draw-line',
    'dynamic',
    'fill-line',
    'finger',
    'fontCaps',
    'fret-diagram',
    'fret-diagram-terse',
    'fret-diagram-verbose',
    'fromproperty',
    'harp-pedal',
    'hbracket',
    'hspace',
    'huge',
    'italic',
    'justify',
    'justify-field',
    'justify-string',
    'large',
    'larger',
    'left-align',
    'left-brace',
    'left-column',
    'line',
    'lookup',
    'markalphabet',
    'markletter',
    'medium',
    'musicglyph',
    'normalsize',
    'normal-size-sub',
    'normal-size-super',
    'normal-text',
    'number',
    'oval', # since 2.18
    'postscript',
    'right-align',
    'right-brace',
    'right-column',
    'roman',
    'rounded-box',
    'sans',
    'score',
    'simple',
    'slashed-digit',
    'small',
    'smallCaps',
    'smaller',
    'stencil',
    'sub',
    'super',
    'teeny',
    'text',
    'tied-lyric',
    'tiny',
    'transparent',
    'triangle',
    'typewriter',
    'underline',
    'upright',
    'vcenter',
    'vspace',
    'verbatim-file',
    'whiteout',
    'wordwrap',
    'wordwrap-field',
    'wordwrap-string',
),
# two arguments
(
    'abs-fontsize',
    'auto-footnote', # since 2.16
    'combine',
    'customTabClef',
    'fontsize',
    'footnote',
    'fraction',
    'halign',
    'hcenter-in',
    'lower',
    'magnify',
    'note',
    'on-the-fly',
    'override',
    'pad-around',
    'pad-markup',
    'pad-x',
    'page-link',
    'path',     # added in LP 2.13.31
    'raise',
    'rotate',
    'scale',
    'translate',
    'translate-scaled',
    'with-color',
    'with-link',
    'with-url',
    'woodwind-diagram',
),
# three arguments
(
    'arrow-head',
    'beam',
    'draw-circle',
    'eps-file',
    'filled-box',
    'general-align',
    'note-by-number',
    'pad-to-box',
    'page-ref',
    'with-dimensions',
),
# four arguments
(
    'pattern',
    'put-adjacent',
),
# five arguments,
(
    'fill-with-pattern',
),
)


markupcommands = sum(markupcommands_nargs, ())


markuplistcommands = (
    'column-lines',
    'justified-lines',
    'override-lines',
    'wordwrap-internal',
    'wordwrap-lines',
    'wordwrap-string-internal',
)


contexts = (
    'ChoirStaff',
    'ChordNames',
    'CueVoice',
    'Devnull',
    'DrumStaff',
    'DrumVoice',
    'Dynamics',
    'FiguredBass',
    'FretBoards',
    'Global',
    'GrandStaff',
    'GregorianTranscriptionStaff',
    'GregorianTranscriptionVoice',
    'KievanStaff', # since 2.16
    'KievanVoice', # since 2.16
    'Lyrics',
    'MensuralStaff',
    'MensuralVoice',
    'NoteNames',
    'NullVoice',     # since 2.18
    'PetrucciStaff', # since 2.16
    'PetrucciVoice', # since 2.16
    'PianoStaff',
    'RhythmicStaff',
    'Score',
    'Staff',
    'StaffGroup',
    'TabStaff',
    'TabVoice',
    'Timing',
    'VaticanaStaff',
    'VaticanaVoice',
    'Voice',
)


midi_instruments = (
    # (1-8 piano)
    'acoustic grand',
    'bright acoustic',
    'electric grand',
    'honky-tonk',
    'electric piano 1',
    'electric piano 2',
    'harpsichord',
    'clav',
    # (9-16 chrom percussion)
    'celesta',
    'glockenspiel',
    'music box',
    'vibraphone',
    'marimba',
    'xylophone',
    'tubular bells',
    'dulcimer',
    # (17-24 organ)
    'drawbar organ',
    'percussive organ',
    'rock organ',
    'church organ',
    'reed organ',
    'accordion',
    'harmonica',
    'concertina',
    # (25-32 guitar)
    'acoustic guitar (nylon)',
    'acoustic guitar (steel)',
    'electric guitar (jazz)',
    'electric guitar (clean)',
    'electric guitar (muted)',
    'overdriven guitar',
    'distorted guitar',
    'guitar harmonics',
    # (33-40 bass)
    'acoustic bass',
    'electric bass (finger)',
    'electric bass (pick)',
    'fretless bass',
    'slap bass 1',
    'slap bass 2',
    'synth bass 1',
    'synth bass 2',
    # (41-48 strings)
    'violin',
    'viola',
    'cello',
    'contrabass',
    'tremolo strings',
    'pizzicato strings',
    'orchestral harp', # till LilyPond 2.12 was this erroneously called: 'orchestral strings'
    'timpani',
    # (49-56 ensemble)
    'string ensemble 1',
    'string ensemble 2',
    'synthstrings 1',
    'synthstrings 2',
    'choir aahs',
    'voice oohs',
    'synth voice',
    'orchestra hit',
    # (57-64 brass)
    'trumpet',
    'trombone',
    'tuba',
    'muted trumpet',
    'french horn',
    'brass section',
    'synthbrass 1',
    'synthbrass 2',
    # (65-72 reed)
    'soprano sax',
    'alto sax',
    'tenor sax',
    'baritone sax',
    'oboe',
    'english horn',
    'bassoon',
    'clarinet',
    # (73-80 pipe)
    'piccolo',
    'flute',
    'recorder',
    'pan flute',
    'blown bottle',
    'shakuhachi',
    'whistle',
    'ocarina',
    # (81-88 synth lead)
    'lead 1 (square)',
    'lead 2 (sawtooth)',
    'lead 3 (calliope)',
    'lead 4 (chiff)',
    'lead 5 (charang)',
    'lead 6 (voice)',
    'lead 7 (fifths)',
    'lead 8 (bass+lead)',
    # (89-96 synth pad)
    'pad 1 (new age)',
    'pad 2 (warm)',
    'pad 3 (polysynth)',
    'pad 4 (choir)',
    'pad 5 (bowed)',
    'pad 6 (metallic)',
    'pad 7 (halo)',
    'pad 8 (sweep)',
    # (97-104 synth effects)
    'fx 1 (rain)',
    'fx 2 (soundtrack)',
    'fx 3 (crystal)',
    'fx 4 (atmosphere)',
    'fx 5 (brightness)',
    'fx 6 (goblins)',
    'fx 7 (echoes)',
    'fx 8 (sci-fi)',
    # (105-112 ethnic)
    'sitar',
    'banjo',
    'shamisen',
    'koto',
    'kalimba',
    'bagpipe',
    'fiddle',
    'shanai',
    # (113-120 percussive)
    'tinkle bell',
    'agogo',
    'steel drums',
    'woodblock',
    'taiko drum',
    'melodic tom',
    'synth drum',
    'reverse cymbal',
    # (121-128 sound effects)
    'guitar fret noise',
    'breath noise',
    'seashore',
    'bird tweet',
    'telephone ring',
    'helicopter',
    'applause',
    'gunshot',
    # (channel 10 drum-kits - subtract 32768 to get program no.)
    'standard kit',
    'standard drums',
    'drums',
    'room kit',
    'room drums',
    'power kit',
    'power drums',
    'rock drums',
    'electronic kit',
    'electronic drums',
    'tr-808 kit',
    'tr-808 drums',
    'jazz kit',
    'jazz drums',
    'brush kit',
    'brush drums',
    'orchestra kit',
    'orchestra drums',
    'classical drums',
    'sfx kit',
    'sfx drums',
    'mt-32 kit',
    'mt-32 drums',
    'cm-64 kit',
    'cm-64 drums',
)


#scheme_functions = (
#    'set-accidental-style',
#    'set-global-staff-size',
#    'set-octavation',
#    'set-paper-size',
#    'define-public',
#    'define-music-function',
#    'define-markup-command',
#    'empty-stencil',
#    'markup',
#    'number?',
#    'string?',
#    'pair?',
#    'ly:duration?',
#    'ly:grob?',
#    'ly:make-moment',
#    'ly:make-pitch',
#    'ly:music?',
#    'ly:moment?',
#    'ly:format',
#    'markup?',
#    'interpret-markup',
#    'make-line-markup',
#    'make-center-markup',
#    'make-column-markup',
#    'make-musicglyph-markup',
#    'color?',
#    'rgb-color',
#    'x11-color',
#)


scheme_values = (
    'UP',
    'DOWN',
    'LEFT',
    'RIGHT',
    'CENTER',
    'minimum-distance',
    'basic-distance',
    'padding',
    'stretchability',
)


headervariables = (
    'dedication',
    'title',
    'subtitle',
    'subsubtitle',
    'poet',
    'composer',
    'meter',
    'opus',
    'arranger',
    'instrument',
    'piece',
    'breakbefore',
    'copyright',
    'tagline',
    'mutopiatitle',
    'mutopiacomposer',
    'mutopiapoet',
    'mutopiaopus',
    'mutopiainstrument',
    'date',
    'enteredby',
    'source',
    'style',
    'maintainer',
    'maintainerEmail',
    'maintainerWeb',
    'moreInfo',
    'lastupdated',
    'texidoc',
    'footer',
)
    

papervariables = (
    # fixed vertical
    'paper-height',
    'top-margin',
    'bottom-margin',
    'ragged-bottom',
    'ragged-last-bottom',
    
    # horizontal
    'paper-width',
    'line-width',
    'left-margin',
    'right-margin',
    'check-consistency',
    'ragged-right',
    'ragged-last',
    'two-sided',
    'inner-margin',
    'outer-margin',
    'binding-offset',
    'horizontal-shift',
    'indent',
    'short-indent',
    
    # flex vertical
    'markup-system-spacing', # the distance between a (title or top-level) markup and the system that follows it.
    'score-markup-spacing',  # the distance between the last system of a score and the (title or top-level) markup that follows it.
    'score-system-spacing',  # the distance between the last system of a score and the first system of the score that follows it, when no (title or top-level) markup exists between them.
    'system-system-spacing', # the distance between two systems in the same score.
    'markup-markup-spacing', # the distance between two (title or top-level) markups.
    'last-bottom-spacing',   # the distance from the last system or top-level markup on a page to the bottom of the printable area (i.e. the top of the bottom margin).
    'top-system-spacing',    # the distance from the top of the printable area (i.e. the bottom of the top margin) to the first system on a page, when there is no (title or top-level) markup between the two.
    'top-markup-spacing',    # the distance from the top of the printable area (i.e. the bottom of the top margin) to the first (title or top-level) markup on a page, when there is no system between the two.
    
    # line breaking
    'max-systems-per-page',
    'min-systems-per-page',
    'system-count',
    'systems-per-page',

    # page breaking
    'blank-after-score-page-force',  # The penalty for having a blank page after the end of one score and before the next. By default, this is smaller than blank-page-force, so that we prefer blank pages after scores to blank pages within a score.
    'blank-last-page-force',         # The penalty for ending the score on an odd-numbered page.
    'blank-page-force',              # The penalty for having a blank page in the middle of a score. This is not used by ly:optimal-breaking since it will never consider blank pages in the middle of a score.
    'page-breaking',                 # The page-breaking algorithm to use. Choices are ly:minimal-breaking, ly:page-turn-breaking, and ly:optimal-breaking.
    'page-breaking-system-system-spacing', # Tricks the page breaker into thinking that system-system-spacing is set to something different than it really is. For example, if page-breaking-system-system-spacing #'padding is set to something substantially larger than system-system-spacing #'padding, then the page-breaker will put fewer systems on each page. Default: unset.
    'page-count',                    # The number of pages to be used for a score, unset by default.
    
    # page numbering
    'auto-first-page-number',
    'first-page-number',
    'print-first-page-number',
    'print-page-number',
    
    # misc
    'page-spacing-weight',
    'print-all-headers',
    'system-separator-markup',
    
    # debugging
    'annotate-spacing',
    
    # different markups
    'bookTitleMarkup',
    'evenFooterMarkup',
    'evenHeaderMarkup',
    'oddFooterMarkup',
    'oddHeaderMarkup',
    'scoreTitleMarkup',
    'tocItemMarkup',
    'tocTitleMarkup',
    
    # fonts
    'fonts',
    
    # undocumented?
    #'blank-after-score-page-force',
    #'force-assignment',
    #'input-encoding',
    #'output-scale',
)


layoutvariables = (
    'indent',
    'short-indent',
    'system-count',
    'line-width',
    'ragged-right',
    'ragged-last',
)


midivariables = (
)


repeat_types = (
    'unfold',
    'percent',
    'volta',
    'tremolo',
)


accidentalstyles = (
    'default',
    'voice',
    'modern',
    'modern-cautionary',
    'modern-voice',
    'modern-voice-cautionary',
    'piano',
    'piano-cautionary',
    'neo-modern',
    'neo-modern-cautionary',
    'neo-modern-voice',
    'neo-modern-voice-cautionary',
    'dodecaphonic',
    'teaching',
    'no-reset',
    'forget',
)


clefs_plain = (
    'treble',
    'violin',
    'G',
    'alto',
    'C',
    'tenor',
    'bass',
    'subbass',
    'F',
    'french',
    'mezzosoprano',
    'soprano',
    'varbaritone',
    'baritone',
    'percussion',
    'tab',
)
    

clefs = clefs_plain + (
    'treble_8',
    'bass_8',
)


break_visibility = (
    'all-invisible',
    'begin-of-line-visible',
    'end-of-line-visible',
    'all-visible',
    'begin-of-line-invisible',
    'end-of-line-invisible',
    'center-invisible',
)


mark_formatters = (
    'format-mark-alphabet',
    'format-mark-barnumbers',
    'format-mark-letters',
    'format-mark-numbers',
    'format-mark-box-alphabet',
    'format-mark-box-barnumbers',
    'format-mark-box-letters',
    'format-mark-box-numbers',
    'format-mark-circle-alphabet',
    'format-mark-circle-barnumbers',
    'format-mark-circle-letters',
    'format-mark-circle-numbers',
)



########NEW FILE########
__FILENAME__ = lydocinfo
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Harvest information from a ly.document.DocumentBase instance.

This extends the ly.docinfo.DocInfo class with some behaviour specific to 
Frescobaldi, such as variables.

With this module, information extracted from tokenized LilyPond source is 
available to both text documents on disk and loaded Frescobaldi documents.

"""

from __future__ import unicode_literals
from __future__ import absolute_import

import re

import ly.docinfo


class DocInfo(ly.docinfo.DocInfo):
    """Add Frescobaldi-specific stuff to ly.docinfo.DocInfo."""
    
    def __init__(self, doc, variables):
        """Initialize with ly.document instance and variables dictionary."""
        super(DocInfo, self).__init__(doc)
        self.variables = variables
    
    @ly.docinfo._cache
    def version_string(self):
        """Return the version, but also looks in the variables and comments."""
        version = super(DocInfo, self).version_string()
        if version:
            return version
        version = self.variables.get("version")
        if version:
            return version
        # parse whole document for non-lilypond comments
        m = re.search(r'\\version\s*"(\d+\.\d+(\.\d+)*)"', self.document.plaintext())
        if m:
            return m.group(1)



########NEW FILE########
__FILENAME__ = lydocument
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Document

Provides a ly.document.Document api for a QTextDocument (or: more specifically
a Frescobaldi document.Document).

This can be used to perform operations from the ly module on a loaded
Frescobaldi document.

You don't need to save a Document instance. Just create it and use it, then 
discard it.

"""

from __future__ import unicode_literals
from __future__ import absolute_import

from PyQt4.QtGui import QTextCursor

import ly.document
import tokeniter
import highlighter


def cursor(cursor, select_all=False):
    """Return a Cursor for the specified QTextCursor.
    
    The ly Cursor is instantiated with a Document proxying for the
    original cursors document.
    
    So you can call all operations in the ly module and they will work on a
    Frescobaldi document (which is a subclass of QTextDocument).
    
    If select_all is True, the ly Cursor selects the whole document if the 
    original cursor has no selection.
    
    """
    if not select_all or cursor.hasSelection():
        start, end = cursor.selectionStart(), cursor.selectionEnd()
    else:
        start, end = 0, None
    return Cursor(Document(cursor.document()), start, end)
    

class Cursor(ly.document.Cursor):
    """A ly.document.Cursor with an extra cursor() method."""
    def cursor(self):
        """Return a QTextCursor with the same selection."""
        c = QTextCursor(self.document.document)
        c.movePosition(QTextCursor.End) if self.end is None else c.setPosition(self.end)
        c.setPosition(self.start, QTextCursor.KeepAnchor)
        return c


class Document(ly.document.DocumentBase):
    """Document proxies a loaded Frescobaldi document (QTextDocument).
    
    This is used to let the tools in the ly module operate on Frescobaldi
    documents.
    
    Creating a Document is very fast, you do not need to save it. When 
    applying the changes, Document starts an editblock, so that the 
    operations appears as one undo-item.
    
    It is recommended to not nest calls to QTextCursor.beginEditBlock(), as 
    the highlighter is not called to update the tokens until the last 
    endEditBlock() is called.
    
    Therefore Document provides a simple mechanism for combining several 
    change operations via the combine_undo attribute.
    
    If combine_undo is None (the default), the first time changes are applied
    QTextCursor.beginEditBlock() will be called, but subsequent times 
    QTextCursor.joinPreviousEditBlock() will be used. So the highlighter 
    updates the tokens between the operations, but they will appear as one 
    undo-item.
    
    If you want to combine the very first operation already with an earlier 
    change, set combine_undo to True before the changes are applied (e.g. 
    before entering or exiting the context).
    
    If you do not want to combine operations into a single undo-item at all,
    set combine_undo to False.
    
    (Of course you can nest calls to QTextCursor.beginEditBlock(), but in 
    that case the tokens will not be updated between your operations. If 
    your operations do not depend on the tokens, it is no problem 
    whatsoever. The tokens *are* updated after the last call to 
    QTextCursor.endEditBlock().)
    
    """
    
    def __init__(self, document):
        self._d = document
        super(Document, self).__init__()
        self.combine_undo = None
    
    def __len__(self):
        """Return the number of blocks"""
        return self._d.blockCount()
    
    def __getitem__(self, index):
        """Return the block at the specified index."""
        return self._d.findBlockByNumber(index)
        
    @property
    def document(self):
        """Return the QTextDocument we were instantiated with."""
        return self._d
    
    @property
    def filename(self):
        """Return the document's local filename, if any."""
        return self.document.url().toLocalFile()
    
    def plaintext(self):
        """The document contents as a plain text string."""
        return self._d.toPlainText()

    def setplaintext(self, text):
        """Sets the document contents to the text string."""
        self._d.setPlainText(text)

    def size(self):
        """Return the number of characters in the document."""
        return self._d.characterCount()

    def block(self, position):
        """Return the text block at the specified character position.
        
        The text block itself has no methods, but it can be used as an
        argument to other methods of this class.
        
        (Blocks do have to support the '==' operator.)
        
        """
        return self._d.findBlock(position)
    
    def index(self, block):
        """Return the linenumber of the block (starting with 0)."""
        return block.blockNumber()
         
    def position(self, block):
        """Return the position of the specified block."""
        return block.position()

    def text(self, block):
        """Return the text of the specified block."""
        return block.text()
    
    def next_block(self, block):
        """Return the next block, which may be invalid."""
        return block.next()
    
    def previous_block(self, block):
        """Return the previous block, which may be invalid."""
        return block.previous()
    
    def isvalid(self, block):
        """Return True if the block is a valid block."""
        return block.isValid()
    
    def apply_changes(self):
        """Apply the changes and update the tokens."""
        c = QTextCursor(self._d)
        # record a sensible position for undo
        c.setPosition(self._changes_list[-1][0])
        c.joinPreviousEditBlock() if self.combine_undo else c.beginEditBlock()
        try:
            for start, end, text in self._changes_list:
                c.movePosition(QTextCursor.End) if end is None else c.setPosition(end)
                c.setPosition(start, QTextCursor.KeepAnchor)
                c.insertText(text)
        finally:
            c.endEditBlock()
            if self.combine_undo is None:
                self.combine_undo = True
        
    def tokens(self, block):
        """Return the tuple of tokens of the specified block."""
        return tokeniter.tokens(block)
        
    def initial_state(self):
        """Return the state at the beginning of the document."""
        return highlighter.highlighter(self._d).initialState()
        
    def state(self, block):
        """Return the state at the start of the specified block."""
        return tokeniter.state(block)
            
    def state_end(self, block):
        """Return the state at the end of the specified block."""
        return tokeniter.state_end(block)


class Runner(ly.document.Runner):
    """A Runner that adds a cursor() method, returning a QTextCursor."""
    def cursor(self, start=0, end=None):
        """Returns a QTextCursor for the last token.
        
        If start is given the cursor will start at position start in the token
        (from the beginning of the token). Start defaults to 0.
        If end is given, the cursor will end at that position in the token (from
        the beginning of the token). End defaults to the length of the token.
        
        """
        if end is None:
            end = len(self.token())
        c = QTextCursor(self.document.document)
        c.setPosition(self.position() + start)
        c.setPosition(self.position() + end, QTextCursor.KeepAnchor)
        return c


class Source(ly.document.Source):
    """A Source that adds a cursor() method, returning a QTextCursor."""
    def cursor(self, token, start=0, end=None):
        """Returns a QTextCursor for the specified token.
        
        If start is given the cursor will start at position start in the token
        (from the beginning of the token). Start defaults to 0.
        If end is given, the cursor will end at that position in the token (from
        the beginning of the token). End defaults to the length of the token.
        
        """
        if end is None:
            end = len(token)
        c = QTextCursor(self.document.document)
        pos = self.position(token)
        c.setPosition(pos + start)
        c.setPosition(pos + end, QTextCursor.KeepAnchor)
        return c



########NEW FILE########
__FILENAME__ = lyrics
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Commands for manipulating Lyrics.
"""

from __future__ import unicode_literals

import re

from PyQt4.QtCore import Qt
from PyQt4.QtGui import QAction, QApplication, QKeySequence, QTextCursor

import ly.lex.lilypond
import actioncollection
import actioncollectionmanager
import plugin
import cursortools
import lydocument


# regexp to match a lyric word
_word_re = re.compile(r"[^\W0-9_]+", re.UNICODE)


def lyrics(mainwindow):
    return Lyrics.instance(mainwindow)
    

class Lyrics(plugin.MainWindowPlugin):
    def __init__(self, mainwindow):
        ac = self.actionCollection = Actions()
        actioncollectionmanager.manager(mainwindow).addActionCollection(ac)
        ac.lyrics_hyphenate.triggered.connect(self.hyphenate)
        ac.lyrics_dehyphenate.triggered.connect(self.dehyphenate)
        ac.lyrics_copy_dehyphenated.triggered.connect(self.copy_dehyphenated)
        mainwindow.selectionStateChanged.connect(self.updateSelection)
        self.updateSelection(mainwindow.hasSelection())
        
    def updateSelection(self, selection):
        self.actionCollection.lyrics_dehyphenate.setEnabled(selection)
        self.actionCollection.lyrics_copy_dehyphenated.setEnabled(selection)
    
    def hyphenate(self):
        """Hyphenates selected Lyrics text."""
        view = self.mainwindow().currentView()
        cursor = view.textCursor()
        found = []
        c = lydocument.cursor(cursor, select_all=True)
        # find text to hyphenate
        source = lydocument.Source(c)
        for token in source:
            if isinstance(token, ly.lex.lilypond.LyricText):
                # a word found
                pos = source.position(token)
                for m in _word_re.finditer(token):
                    found.append((pos + m.start(), pos + m.end(), m.group()))
        if not found and cursor.hasSelection():
            # no tokens were found, then tokenize the text again as if in lyricmode
            start = cursor.selectionStart()
            state = ly.lex.State(ly.lex.lilypond.ParseLyricMode)
            for token in state.tokens(cursor.selection().toPlainText()):
                if isinstance(token, ly.lex.lilypond.LyricText):
                    # a word found
                    pos = start + token.pos
                    for m in _word_re.finditer(token):
                        found.append((pos + m.start(), pos + m.end(), m.group()))
        if not found and cursor.hasSelection():
            # still not succeeded, then try flat text
            for m in _word_re.finditer(cursor.selection().toPlainText()):
                found.append((start + m.start(), start + m.end(), m.group()))
        if found:
            import hyphendialog
            h = hyphendialog.HyphenDialog(self.mainwindow()).hyphenator()
            if h:
                with c.document as d:
                    for start, end, word in found:
                        hyph_word = h.inserted(word, ' -- ')
                        if word != hyph_word:
                            d[start:end] = hyph_word
            
    def dehyphenate(self):
        """De-hyphenates selected Lyrics text."""
        view = self.mainwindow().currentView()
        cursor = view.textCursor()
        text = cursor.selection().toPlainText()
        if ' --' in text:
            with cursortools.keep_selection(cursor, view):
                cursor.insertText(removehyphens(text))
            
    def copy_dehyphenated(self):
        """Copies selected lyrics text to the clipboard with hyphenation removed."""
        text = self.mainwindow().textCursor().selection().toPlainText()
        QApplication.clipboard().setText(removehyphens(text))


class Actions(actioncollection.ActionCollection):
    name = "lyrics"
    
    def createActions(self, parent=None):
        
        self.lyrics_hyphenate = QAction(parent)
        self.lyrics_dehyphenate = QAction(parent)
        self.lyrics_copy_dehyphenated = QAction(parent)
        
        self.lyrics_hyphenate.setShortcut(QKeySequence(Qt.CTRL + Qt.Key_L))
        
    def translateUI(self):
        self.lyrics_hyphenate.setText(_("&Hyphenate Lyrics Text..."))
        self.lyrics_dehyphenate.setText(_("&Remove hyphenation"))
        self.lyrics_copy_dehyphenated.setText(_("&Copy Lyrics with hyphenation removed"))


def removehyphens(text):
    """Removes hyphens and extenders from text."""
    text = re.sub(r"[ \t]*--[ \t]*|__[ \t]*|_[ \t]+(_[ \t]+)*", '', text)
    return text.replace('_', ' ').replace('~', ' ')



########NEW FILE########
__FILENAME__ = file_open_eventhandler
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
This handles the QEvent::FileOpen event type sent to the QApplication when
a file is clicked in the file manager.

Currently this makes only sense on Mac OS X.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QEvent, QObject
from PyQt4.QtGui import QApplication

import app


def openUrl(url):
    """Open Url.
    
    If there is an active MainWindow, the document is made the current
    document in that window. If there is no MainWindow at all, it is
    created.
    
    """
    if not app.windows:
        import mainwindow
        mainwindow.MainWindow().show()
    win = QApplication.activeWindow()
    if win not in app.windows:
        win = app.windows[0]
    doc = win.openUrl(url)
    if doc:
        win.setCurrentDocument(doc)


class FileOpenEventHandler(QObject):
    def eventFilter(self, obj, ev):
        if ev.type() == QEvent.FileOpen:
            openUrl(ev.url())
            return True
        return False


handler = FileOpenEventHandler()
app.qApp.installEventFilter(handler)



########NEW FILE########
__FILENAME__ = globalmenu
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The global menubar on Mac OS X.

This menubar is only created when there is no MainWindow. As soon a MainWindow
is created, this global menubar is deleted, and Mac OS X will use the menubar
from the MainWindow.

"""

from __future__ import unicode_literals

import sys
import os

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import util
import qutil
import icons
import info

from . import use_osx_menu_roles


def setup():
    """Create the global menu bar, and switch to no-session."""
    global _menubar
    _menubar = menubar()
    import sessions
    sessions.setCurrentSession(None)

@app.mainwindowCreated.connect
def delete():
    """Delete the global menu bar."""
    global _menubar
    _menubar.deleteLater()
    _menubar = None

def menubar():
    """Return a newly created parent-less menu bar that's used when there is no main window."""
    m = QMenuBar()
    m.addMenu(menu_file(m))
    m.addMenu(menu_edit(m))
    m.addMenu(menu_window(m))
    m.addMenu(menu_sessions(m))
    m.addMenu(menu_help(m))
    return m

def menu_file(parent):
    m = QMenu(parent)
    m.setTitle(_("menu title", "&File"))
    m.addAction(icons.get('document-new'), _("action: new document", "&New"), file_new)
    m.addMenu(menu_file_new_from_template(m))
    m.addAction(icons.get('tools-score-wizard'), _("New Score with &Wizard..."), file_new_with_wizard)
    m.addSeparator()
    m.addAction(icons.get('document-open'), _("&Open..."), file_open)
    m.addMenu(menu_file_open_recent(m))
    m.addSeparator()
    m.addMenu(menu_file_import(m))
    m.addSeparator()
    role = QAction.QuitRole if use_osx_menu_roles() else QAction.NoRole
    m.addAction(icons.get('application-exit'), _("&Quit"), app.qApp.quit).setMenuRole(role)
    return m

def menu_file_new_from_template(parent):
    m = QMenu(parent)
    m.setTitle(_("New from &Template"))
    m.triggered.connect(slot_file_new_from_template_action)
    from snippet import model, actions, snippets
    groups = {}
    for name in sorted(model.model().names()):
        variables = snippets.get(name).variables
        group = variables.get('template')
        if group:
            action = actions.action(name, m)
            if action:
                groups.setdefault(group, []).append(action)
    for group in sorted(groups):
        for action in groups[group]:
            m.addAction(action)
        m.addSeparator()
    qutil.addAccelerators(m.actions())
    return m

def menu_file_open_recent(parent):
    m = QMenu(parent)
    m.setTitle(_("Open &Recent"))
    m.triggered.connect(slot_file_open_recent_action)
    import recentfiles
    for url in recentfiles.urls():
        f = url.toLocalFile()
        dirname, basename = os.path.split(f)
        text = "{0}  ({1})".format(basename, util.homify(dirname))
        m.addAction(text).url = url
    qutil.addAccelerators(m.actions())
    return m

def menu_file_import(parent):
    m = QMenu(parent)
    m.setTitle(_("submenu title", "&Import"))
    m.addAction(_("Import MusicXML..."), file_import_musicxml)
    return m
    
def menu_edit(parent):
    m = QMenu(parent)
    m.setTitle(_("menu title", "&Edit"))
    role = QAction.PreferencesRole if use_osx_menu_roles() else QAction.NoRole
    m.addAction(icons.get('preferences-system'), _("Pr&eferences..."), edit_preferences).setMenuRole(role)
    return m

def menu_window(parent):
    m = QMenu(parent)
    m.setTitle(_('menu title', '&Window'))
    m.addAction(icons.get('window-new'), _("New &Window"), file_new)
    return m

def menu_sessions(parent):
    m = QMenu(parent)
    m.setTitle(_('menu title', '&Session'))
    m.triggered.connect(slot_session_action)
    import sessions
    for name in sessions.sessionNames():
        a = m.addAction(name.replace('&', '&&'))
        a.setObjectName(name)
    qutil.addAccelerators(m.actions())
    return m    
    
def menu_help(parent):
    m = QMenu(parent)
    m.setTitle(_('menu title', '&Help'))
    role = QAction.AboutRole if use_osx_menu_roles() else QAction.NoRole
    m.addAction(icons.get('help-about'), _("&About {appname}...").format(appname=info.appname), help_about).setMenuRole(role)
    return m

def mainwindow():
    """Create, show() and return a new MainWindow."""
    import mainwindow
    w = mainwindow.MainWindow()
    w.show()
    return w

def file_new():
    mainwindow().newDocument()

def file_new_with_wizard():
    w = mainwindow()
    w.newDocument()
    import scorewiz
    scorewiz.ScoreWizard.instance(w).showInsertDialog()

def file_open():
    filetypes = app.filetypes('.ly')
    caption = app.caption(_("dialog title", "Open File"))
    directory = app.basedir()
    files = QFileDialog.getOpenFileNames(None, caption, directory, filetypes)
    if files:
        w = mainwindow()
        docs = [w.openUrl(QUrl.fromLocalFile(f)) for f in files]
        if docs:
            w.setCurrentDocument(docs[-1])

def slot_file_new_from_template_action(action):
    name = action.objectName()
    d = app.openUrl(QUrl())
    win = mainwindow()
    win.setCurrentDocument(d)
    from snippet import insert, snippets
    view = win.currentView()
    view.setFocus()
    insert.insert(name, view)
    d.setUndoRedoEnabled(False)
    d.setUndoRedoEnabled(True) # d.clearUndoRedoStacks() only in Qt >= 4.7
    d.setModified(False)
    if 'template-run' in snippets.get(name).variables:
        import engrave
        engrave.engraver(win).engrave('preview', d)

def slot_file_open_recent_action(action):
    url = action.url
    w = mainwindow()
    w.setCurrentDocument(w.openUrl(url))

def file_import_musicxml():
    w = mainwindow()
    w.newDocument()
    import file_import
    file_import.FileImport.instance(w).importMusicXML()

def edit_preferences():
    import preferences
    # TODO: make it possible to run Preferences without a Main Window.
    # Currently the Keyboard Shortcuts section needs the mainwindow to get
    # the current shortcuts.
    w = mainwindow()
    w.newDocument()
    preferences.PreferencesDialog(w).exec_()

def slot_session_action(action):
    name = action.objectName()
    import sessions
    doc = sessions.loadSession(name) or app.openUrl(QUrl())
    w = mainwindow()
    w.setCurrentDocument(doc)

def help_about():
    import about
    about.AboutDialog(None).exec_()



########NEW FILE########
__FILENAME__ = icon_drag_eventhandler
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
This handles the QEvent::IconDrag event type sent to the mainwindow when
the window icon is Command-clicked or dragged.

Currently this makes only sense on Mac OS X.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QEvent, QMimeData, QObject, QPoint, Qt
from PyQt4.QtGui import QApplication, QDrag, QStyle

import app


class IconDragEventHandler(QObject):
    """Event handler to handle window icon events on Mac OS X."""
    def eventFilter(self, mainwin, ev):
        if ev.type() != QEvent.IconDrag:
            return False
        if not mainwin.isActiveWindow():
            return False
        ev.accept()
        modifiers = QApplication.keyboardModifiers()
        if modifiers == Qt.NoModifier:
            self.startDrag(mainwin, ev)
        elif modifiers == Qt.ControlModifier:
            self.commandClick(mainwin, ev)
        else:
            ev.ignore()
        return True

    def startDrag(self, mainwin, ev):
        d = mainwin.currentDocument()
        if not d:
            return
        url = d.url()
        if url.isEmpty():
            return
        drag = QDrag(mainwin)
        data = QMimeData()
        data.setUrls([url])
        drag.setMimeData(data)
        pixmap = mainwin.style().standardPixmap(QStyle.SP_FileIcon, 0, mainwin)
        hotspot = QPoint(pixmap.width() - 5, 5)
        drag.setPixmap(pixmap)
        drag.setHotSpot(hotspot)
        drag.start(Qt.LinkAction | Qt.CopyAction)

    def commandClick(self, mainwin, ev):
        """Called on Command-click the window icon (Mac OS X)."""
        pass


handler = IconDragEventHandler()

@app.mainwindowCreated.connect
def windowCreated(window):
    window.installEventFilter(handler)



########NEW FILE########
__FILENAME__ = main
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Entry point of Frescobaldi.
"""

from __future__ import unicode_literals

import sip
sip.setapi("QString", 2)
sip.setapi("QVariant", 2)

import os
import re
import sys

from PyQt4.QtCore import QSettings, QTimer, QUrl
from PyQt4.QtGui import QApplication, QTextCursor

from . import toplevel  # Find all modules and packages as toplevel
import info             # Information about our application
import app              # Construct QApplication
import install          # Update QSettings structure etc. if needed
import guistyle         # Setup GUI style
import po.setup         # Setup language
import remote           # IPC with other Frescobaldi instances


def parse_commandline():
    """Parses the command line; returns options and filenames.
    
    If --version, --help or invalid options were given, the application will
    exit.
    
    """
    import optparse
    optparse._ = _ # let optparse use our translations
    parser = optparse.OptionParser(
        usage = _("{appname} [options] file ...").format(appname=info.name),
        version = "{0} {1}".format(info.appname, info.version),
        description = _("A LilyPond Music Editor"))
    parser.add_option('-e', '--encoding', metavar=_("ENC"),
        help=_("Encoding to use"))
    parser.add_option('-l', '--line', type="int", metavar=_("NUM"),
        help=_("Line number to go to, starting at 1"))
    parser.add_option('-c', '--column', type="int", metavar=_("NUM"),
        help=_("Column to go to, starting at 0"), default=0)
    parser.add_option('--start', metavar=_("NAME"),
        help=_("Session to start ('{none}' for empty session)").format(none="-"),
        dest="session")
    parser.add_option('--list-sessions', action="store_true", default=False,
        help=_("List the session names and exit"))
    parser.add_option('-n', '--new', action="store_true", default=False,
        help=_("Always start a new instance"))
    
    # Make sure debugger options are recognized as valid. These are passed automatically
    # from PyDev in Eclipse to the inferior process.
    if "pydevd" in sys.modules:
        parser.add_option('-v', '--vm_type')
        parser.add_option('-a', '--client')
        parser.add_option('-p', '--port')
        parser.add_option('-f', '--file')
        parser.add_option('-o', '--output')



    args = QApplication.arguments()
    if os.name == 'nt' and args and 'python' in os.path.basename(args[0]).lower():
        args = args[2:]
    else:
        args = args[1:]
    options, files = parser.parse_args(args)
    return options, files


def url(arg):
    """Converts a filename-like argument to a QUrl."""
    if re.match(r'^(https?|s?ftp)://', arg):
        return QUrl(arg)
    elif arg.startswith('file://'):
        return QUrl.fromLocalFile(os.path.abspath(arg[7:]))
    elif arg.startswith('file:'):
        return QUrl.fromLocalFile(os.path.abspath(arg[5:]))
    else:
        return QUrl.fromLocalFile(os.path.abspath(arg))


def main():
    """Main function."""
    options, files = parse_commandline()
    
    if options.list_sessions:
        import sessions
        for name in sessions.sessionNames():
            sys.stdout.write(name + '\n')
        sys.exit(0)
        
    urls = list(map(url, files))
    
    if not app.qApp.isSessionRestored():
        if not options.new and remote.enabled():
            api = remote.get()
            if api:
                api.command_line(options, urls)
                api.close()
                sys.exit(0)
    
        if QSettings().value("splash_screen", True, bool):
            import splashscreen
            splashscreen.show()

    # application icon
    import icons
    QApplication.setWindowIcon(icons.get("frescobaldi"))
    
    QTimer.singleShot(0, remote.setup)  # Start listening for IPC
    
    import mainwindow       # contains MainWindow class
    import session          # Initialize QSessionManager support
    import sessions         # Initialize our own named session support

    # boot Frescobaldi-specific stuff that should be running on startup
    import viewhighlighter  # highlight arbitrary ranges in text
    import progress         # creates progress bar in view space
    import musicpos         # shows music time in statusbar
    import autocomplete     # auto-complete input
    import wordboundary     # better wordboundary behaviour for the editor
    
    if sys.platform.startswith('darwin'):
        import macosx.setup
    
    if app.qApp.isSessionRestored():
        # Restore session, we are started by the session manager
        session.restoreSession()
        return

    # load specified session?
    doc = None
    if options.session and options.session != "-":
        doc = sessions.loadSession(options.session)
    
    # Just create one MainWindow
    win = mainwindow.MainWindow()
    win.show()
    
    # load documents given as arguments
    for u in urls:
        doc = win.openUrl(u, options.encoding)
    
    # were documents loaded?
    if not doc:
        if app.documents:
            doc = app.documents[-1]
        elif not options.session:
            # no docs, load default session
            doc = sessions.loadDefaultSession()
    
    if doc:
        win.setCurrentDocument(doc)
    else:
        win.cleanStart()
    
    if urls and options.line is not None:
        # set the last loaded document active and apply navigation if requested
        pos = doc.findBlockByNumber(options.line - 1).position() + options.column
        cursor = QTextCursor(doc)
        cursor.setPosition(pos)
        win.currentView().setTextCursor(cursor)
        win.currentView().centerCursor()


main()

sys.displayhook = app.displayhook

########NEW FILE########
__FILENAME__ = mainwindow
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Frescobaldi Main Window.
"""

from __future__ import unicode_literals

import itertools
import os
import sys
import weakref

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import backup
import info
import icons
import actioncollection
import actioncollectionmanager
import menu
import tabbar
import document
import view
import viewmanager
import highlighter
import historymanager
import recentfiles
import sessions.manager
import util
import qutil
import helpers
import panelmanager
import engrave
import scorewiz
import externalchanges
import browseriface
import vcs


class MainWindow(QMainWindow):
    
    # emitted when the MainWindow will close
    aboutToClose = pyqtSignal()
    
    # only emitted when this is the last MainWindow to close
    aboutToCloseLast = pyqtSignal()
    
    # both signals emit (current, previous)
    currentDocumentChanged = pyqtSignal(document.Document, document.Document)
    currentViewChanged = pyqtSignal(view.View, view.View)
    
    # emitted when whether there is a selection changes
    selectionStateChanged = pyqtSignal(bool)
    
    def __init__(self, other=None):
        """Creates a new MainWindow.
        
        It adds itself to app.windows to keep a reference.
        It shares the documents list with all other MainWindows. It copies
        some info (like the currently active document) from the 'other' window,
        if given.
        
        """
        QMainWindow.__init__(self)
        self.setAttribute(Qt.WA_DeleteOnClose)
        
        # this could be made configurable
        self.setCorner(Qt.TopLeftCorner, Qt.LeftDockWidgetArea)
        self.setCorner(Qt.BottomLeftCorner, Qt.LeftDockWidgetArea)
        self.setCorner(Qt.TopRightCorner, Qt.RightDockWidgetArea)
        self.setCorner(Qt.BottomRightCorner, Qt.RightDockWidgetArea)
        
        self._currentDocument = None
        self._currentView = lambda: None
        self._selectedState = None
        
        # find an unused objectName
        names = set(win.objectName() for win in app.windows)
        for num in itertools.count(1):
            name = "MainWindow{0}".format(num)
            if name not in names:
                self.setObjectName(name)
                break
        
        app.windows.append(self)
        
        mainwidget = QWidget()
        self.setCentralWidget(mainwidget)
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        mainwidget.setLayout(layout)
        self.tabBar = tabbar.TabBar(self)
        self.viewManager = viewmanager.ViewManager(self)
        layout.addWidget(self.tabBar)
        layout.addWidget(self.viewManager)

        self.createActions()
        self.createMenus()
        self.createToolBars()
        
        app.translateUI(self)
        app.sessionChanged.connect(self.updateWindowTitle)
        
        self.readSettings()
        
        self.historyManager = historymanager.HistoryManager(self, other.historyManager if other else None)
        self.viewManager.viewChanged.connect(self.slotViewChanged)
        self.tabBar.currentDocumentChanged.connect(self.setCurrentDocument)
        self.setAcceptDrops(True)
        
        # keep track of all ActionCollections for the keyboard settings dialog
        actioncollectionmanager.manager(self).addActionCollection(self.actionCollection)
        actioncollectionmanager.manager(self).addActionCollection(self.viewManager.actionCollection)
        
        if other:
            self.setCurrentDocument(other.currentDocument())
        self.updateWindowTitle()
        app.mainwindowCreated(self)
        
    def documents(self):
        """Returns the list of documents in the order of the TabBar."""
        return self.tabBar.documents()
        
    def currentView(self):
        """Returns the current View or None."""
        return self._currentView()
    
    def currentDocument(self):
        """Returns the current Document or None."""
        return self._currentDocument
        
    def setCurrentDocument(self, doc, findOpenView=None):
        """Set the current document.
        
        The findOpenView argument makes sense when the user has split the
        editor view in more than one.  If findOpenView == True and one of the
        views has the document, that view is focused. If findOpenView == False,
        the currently focused view is changed to the document. If findOpenView
        is None, the users setting is read.
        
        """
        if findOpenView is None:
            findOpenView = QSettings().value("mainwindow/find_open_view", True, bool)
        self.viewManager.setCurrentDocument(doc, findOpenView)
    
    def hasSelection(self):
        """Returns whether there is a selection."""
        return self.textCursor().hasSelection() if self.currentView() else False
            
    def textCursor(self):
        """Returns the QTextCursor of the current View.
        
        Raises an error if there is not yet a view.
        
        """
        return self.currentView().textCursor()
        
    def setTextCursor(self, cursor, findOpenView=None):
        """Switch to the cursor's document() and set that cursor on its View.
        
        For the findOpenView argument, see setCurrentDocument().
        
        """
        self.setCurrentDocument(cursor.document(), findOpenView)
        self.currentView().setTextCursor(cursor)
    
    def slotViewChanged(self, view):
        curv = self._currentView()
        if curv:
            if curv is view:
                return
            curv.copyAvailable.disconnect(self.updateSelection)
            curv.selectionChanged.disconnect(self.updateSelection)
        view.copyAvailable.connect(self.updateSelection)
        view.selectionChanged.connect(self.updateSelection)
        self._currentView = weakref.ref(view)
        
        doc = view.document()
        curd, self._currentDocument = self._currentDocument, doc
        if curd is not doc:
            if curd:
                curd.undoAvailable.disconnect(self.updateDocActions)
                curd.redoAvailable.disconnect(self.updateDocActions)
                curd.modificationChanged.disconnect(self.updateWindowTitle)
                curd.urlChanged.disconnect(self.updateWindowTitle)
                curd.loaded.disconnect(self.updateDocActions)
            doc.undoAvailable.connect(self.updateDocActions)
            doc.redoAvailable.connect(self.updateDocActions)
            doc.modificationChanged.connect(self.updateWindowTitle)
            doc.urlChanged.connect(self.updateWindowTitle)
            doc.loaded.connect(self.updateDocActions)
            self.updateDocActions()
            self.updateWindowTitle()
        self.updateSelection()
        self.updateActions()
        self.currentViewChanged.emit(view, curv)
        if curd is not doc:
            self.currentDocumentChanged.emit(doc, curd)
    
    def updateSelection(self):
        selection = self.textCursor().hasSelection()
        if selection != self._selectedState:
            self._selectedState = selection
            self.selectionStateChanged.emit(selection)
            ac = self.actionCollection
            ac.edit_copy.setEnabled(selection)
            ac.edit_copy_colored_html.setEnabled(selection)
            ac.edit_cut.setEnabled(selection)
            ac.edit_select_none.setEnabled(selection)
    
    def updateActions(self):
        view = self.currentView()
        action = self.actionCollection.view_wrap_lines
        action.setChecked(view.lineWrapMode() == QPlainTextEdit.WidgetWidth)
        
    def updateDocActions(self):
        doc = self.currentDocument()
        ac = self.actionCollection
        ac.edit_undo.setEnabled(doc.isUndoAvailable())
        ac.edit_redo.setEnabled(doc.isRedoAvailable())
        
    def updateWindowTitle(self):
        doc = self.currentDocument()
        name = []
        if sessions.currentSession():
            name.append(sessions.currentSession() + ':')
        if doc:
            if doc.url().isEmpty():
                name.append(doc.documentName())
            elif doc.url().toLocalFile():
                name.append(util.homify(doc.url().toLocalFile()))
            else:
                name.append(doc.url().toString())
            if doc.isModified():
                # L10N: state of document in window titlebar
                name.append(_("[modified]"))
        
        window_title = app.caption(" ".join(name))
        
        if vcs.app_is_git_controlled():
            window_title += " " + vcs.app_active_branch_window_title()
        
        self.setWindowTitle(window_title)
    
    def dropEvent(self, ev):
        if not ev.source() and ev.mimeData().hasUrls():
            ev.accept()
            docs = [self.openUrl(url) for url in ev.mimeData().urls()]
            if docs:
                self.setCurrentDocument(docs[-1])
        
    def dragEnterEvent(self, ev):
        if not ev.source() and ev.mimeData().hasUrls():
            ev.accept()
        
    def closeEvent(self, ev):
        lastWindow = len(app.windows) == 1
        if not lastWindow or self.queryClose():
            self.aboutToClose.emit()
            if lastWindow:
                self.writeSettings()
                self.aboutToCloseLast.emit()
            app.windows.remove(self)
            app.mainwindowClosed(self)
            ev.accept()
        else:
            ev.ignore()

    def queryClose(self):
        """Tries to close all documents, returns True if succeeded."""
        for doc in self.historyManager.documents():
            if not self.queryCloseDocument(doc):
                return False
        sessions.manager.get(self).saveCurrentSessionIfDesired()
        for doc in self.historyManager.documents()[::-1]:
            doc.close()
        return True

    def queryCloseDocument(self, doc):
        """Returns whether a document can be closed.
        
        If modified, asks the user. The document is not closed.
        """
        if not doc.isModified():
            return True
        self.setCurrentDocument(doc, findOpenView=True)
        res = QMessageBox.warning(self, _("dialog title", "Close Document"),
            _("The document \"{name}\" has been modified.\n"
            "Do you want to save your changes or discard them?").format(name=doc.documentName()),
            QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel)
        if res == QMessageBox.Save:
            return self.saveDocument(doc)
        else:
            return res == QMessageBox.Discard
        
    def createPopupMenu(self):
        """ Adds an entry to the popup menu to show/hide the tab bar. """
        menu = QMainWindow.createPopupMenu(self)
        menu.addSeparator()
        a = menu.addAction(_("Tab Bar"))
        a.setCheckable(True)
        a.setChecked(self.tabBar.isVisible())
        a.toggled.connect(self.tabBar.setVisible)
        return menu
        
    def readSettings(self):
        """ Read a few settings from the application global config. """
        settings = QSettings()
        settings.beginGroup('mainwindow')
        defaultSize = QApplication.desktop().screen().size() * 2 / 3
        self.resize(settings.value("size", defaultSize, QSize))
        self.restoreState(settings.value('state', QByteArray(), QByteArray))
        self.tabBar.setVisible(settings.value('tabbar', True, bool))
        if os.name != "posix" and settings.value('maximized', False, bool):
            self.showMaximized()
        
    def writeSettings(self):
        """ Write a few settings to the application global config. """
        settings = QSettings()
        settings.beginGroup('mainwindow')
        if not self.isFullScreen():
            settings.setValue("size", self.size())
        settings.setValue('state', self.saveState())
        settings.setValue('tabbar', self.tabBar.isVisible())
        settings.setValue('maximized', self.isMaximized())
    
    def readSessionSettings(self, settings):
        """Restore ourselves from session manager settings.
        
        These methods store much more information than the readSettings and
        writeSettings methods. This method tries to restore window size and
        position. Also the objectName() is set, so that the window manager can
        preserve stacking order, etc.
        
        """
        name = settings.value('name', '', type(""))
        if name:
            self.setObjectName(name)
        self.restoreGeometry(settings.value('geometry', QByteArray(), QByteArray))
        self.restoreState(settings.value('state', QByteArray(), QByteArray))
        
    def writeSessionSettings(self, settings):
        """Write our state to the session manager settings.
        
        See readSessionSettings().
        
        """
        settings.setValue('name', self.objectName())
        settings.setValue('geometry', self.saveGeometry())
        settings.setValue('state', self.saveState())

    def openUrl(self, url, encoding=None):
        """Same as app.openUrl but with some error checking and recent files."""
        if not url.toLocalFile():
            # we only support local files
            QMessageBox.warning(self, app.caption(_("Warning")),
                _("Can't load non-local document:\n\n{url}").format(
                    url=url.toString()))
        else:
            recentfiles.add(url)
        return app.openUrl(url, encoding)
    
    def currentDirectory(self):
        """Returns the current directory of the current document.
        
        If the document has no filename yet, returns the configured default
        directory, or the user's home directory.
        Is that is not set as well, returns the current directory
        of the application.
        
        """
        import resultfiles
        return (resultfiles.results(self.currentDocument()).currentDirectory()
                or app.basedir() or QDir.homePath() or os.getcwdu())
    
    def cleanStart(self):
        """Called when the previous action left no document open.
        
        Currently simply calls newDocument().
        
        """
        self.newDocument()
    
    ##
    # Implementations of menu actions
    ##
    
    def newDocument(self):
        """ Creates a new, empty document. """
        d = document.Document()
        self.setCurrentDocument(d)
        s = QSettings()
        ndoc = s.value("new_document", "empty", type(""))
        template = s.value("new_document_template", "", type(""))
        if ndoc == "template" and template:
            from snippet import snippets, insert
            if snippets.text(template):
                insert.insert(template, self.currentView())
                d.setUndoRedoEnabled(False)
                d.setUndoRedoEnabled(True) # d.clearUndoRedoStacks() only in Qt >= 4.7
                d.setModified(False)
        elif ndoc == "version":
            import lilypondinfo
            d.setPlainText('\\version "{0}"\n\n'.format(lilypondinfo.preferred().versionString()))
            d.setModified(False)
    
    def openDocument(self):
        """ Displays an open dialog to open one or more documents. """
        ext = os.path.splitext(self.currentDocument().url().path())[1]
        filetypes = app.filetypes(ext)
        caption = app.caption(_("dialog title", "Open File"))
        directory = os.path.dirname(self.currentDocument().url().toLocalFile()) or app.basedir()
        files = QFileDialog.getOpenFileNames(self, caption, directory, filetypes)
        docs = [self.openUrl(QUrl.fromLocalFile(f)) for f in files]
        if docs:
            self.setCurrentDocument(docs[-1])
        
    def saveDocument(self, doc):
        """ Saves the document, asking for a name if necessary.
        
        Returns True if saving succeeded.
        
        """
        if doc.url().isEmpty():
            return self.saveDocumentAs(doc)
        filename = dest = doc.url().toLocalFile()
        if not filename:
            dest = doc.url().toString()
        if not util.iswritable(filename):
            QMessageBox.warning(self, app.caption(_("Error")),
                _("Can't write to destination:\n\n{url}").format(url=dest))
            return False
        if QSettings().value("strip_trailing_whitespace", False, bool):
            import reformat
            reformat.remove_trailing_whitespace(QTextCursor(doc))
        b = backup.backup(filename)
        success = doc.save()
        if not success:
            QMessageBox.warning(self, app.caption(_("Error")),
                _("Can't write to destination:\n\n{url}").format(url=filename))
        elif b:
            backup.removeBackup(filename)
        return success
            
    def saveDocumentAs(self, doc):
        """ Saves the document, always asking for a name.
        
        Returns True if saving succeeded.
        
        """
        filename = doc.url().toLocalFile()
        if filename:
            filetypes = app.filetypes(os.path.splitext(filename)[1])
        else:
            filename = app.basedir() # default directory to save to
            import documentinfo
            import ly.lex
            filetypes = app.filetypes(ly.lex.extensions[documentinfo.mode(doc)])
        caption = app.caption(_("dialog title", "Save File"))
        filename = QFileDialog.getSaveFileName(self, caption, filename, filetypes)
        if not filename:
            return False # cancelled
        if not util.iswritable(filename):
            QMessageBox.warning(self, app.caption(_("Error")),
                _("Can't write to destination:\n\n{url}").format(url=filename))
            return False
        url = QUrl.fromLocalFile(filename)
        doc.setUrl(url)
        recentfiles.add(url)
        return self.saveDocument(doc)
        
    def closeDocument(self, doc):
        """ Closes the document, asking for saving if modified.
        
        Returns True if closing succeeded.
        
        """
        close = self.queryCloseDocument(doc)
        if close:
            doc.close()
            # keep one document
            if not app.documents:
                self.cleanStart()
        return close
        
    def saveCurrentDocument(self):
        return self.saveDocument(self.currentDocument())
    
    def saveCurrentDocumentAs(self):
        return self.saveDocumentAs(self.currentDocument())
    
    def saveCopyAs(self):
        import ly.lex
        doc = self.currentDocument()
        if not self.currentView().textCursor().hasSelection():
            import documentinfo
            mode = documentinfo.mode(doc)
            data = doc.encodedText()
            caption = app.caption(_("dialog title", "Save Copy"))
        else:
            import fileinfo
            text = self.currentView().textCursor().selection().toPlainText()
            mode = fileinfo.textmode(text)
            data = util.encode(text)
            caption = app.caption(_("dialog title", "Save Selection"))
        filetypes = app.filetypes(ly.lex.extensions[mode])
        dirname = os.path.dirname(doc.url().toLocalFile()) or app.basedir()
        filename = QFileDialog.getSaveFileName(self, caption, dirname, filetypes)
        if not filename:
            return # cancelled
        try:
            with open(filename, "w") as f:
                f.write(data)
        except (IOError, OSError) as err:
            QMessageBox.warning(self, app.caption(_("Error")),
                _("Can't write to destination:\n\n{url}\n\n{error}").format(
                    url=filename, error=err.strerror))
    
    def closeCurrentDocument(self):
        return self.closeDocument(self.currentDocument())
    
    def reloadCurrentDocument(self):
        """Reload the current document again from disk.
        
        This action can be undone.
        
        """
        d = self.currentDocument()
        if d.load(True) is False:
            QMessageBox.warning(self, app.caption(_("Reload")),
              _("Could not reload the document:\n\n{url}").format(
                url = d.url().toString()))
    
    def reloadAllDocuments(self):
        """Reloads all documents."""
        success = []
        for d in self.historyManager.documents():
            success.append(d.load(True))
        if False in success:
            if True in success:
                msg = _("Some documents could not be reloaded.")
            else:
                msg = _("No document could be reloaded.")
            QMessageBox.warning(self, app.caption(_("Reload")), msg)
    
    def saveAllDocuments(self):
        """ Saves all documents.
        
        Returns True if all documents were saved.
        If one document failed or was cancelled the whole operation is cancelled
        and this function returns False.
        
        """
        cur = self.currentDocument()
        for doc in self.historyManager.documents():
            if doc.isModified():
                if doc.url().isEmpty():
                    self.setCurrentDocument(doc, findOpenView=True)
                    res = self.saveDocumentAs(doc)
                else:
                    res = self.saveDocument(doc)
                if not res:
                    return False
        self.setCurrentDocument(cur, findOpenView=True)
        return True
                    
    def closeOtherDocuments(self):
        """ Closes all documents that are not the current document.
        
        Returns True if all documents were closed.
        
        """
        cur = self.currentDocument()
        docs = self.historyManager.documents()[1:]
        for doc in docs:
            if not self.queryCloseDocument(doc):
                self.setCurrentDocument(cur, findOpenView=True)
                return False
        for doc in docs:
            doc.close()
        return True
    
    def closeAllDocuments(self):
        """Closes all documents and keep one new, empty document."""
        sessions.manager.get(self).saveCurrentSessionIfDesired()
        if self.queryClose():
            sessions.setCurrentSession(None)
            self.cleanStart()
    
    def quit(self):
        """Closes all MainWindows."""
        for window in app.windows[:]: # copy
            if window is not self:
                window.close()
        self.close()
        app.qApp.quit()
    
    def restart(self):
        """Closes all MainWindows and restart Frescobaldi."""
        self.quit()
        app.restart()
    
    def insertFromFile(self):
        ext = os.path.splitext(self.currentDocument().url().path())[1]
        filetypes = app.filetypes(ext)
        caption = app.caption(_("dialog title", "Insert From File"))
        directory = os.path.dirname(self.currentDocument().url().toLocalFile()) or app.basedir()
        filename = QFileDialog.getOpenFileName(self, caption, directory, filetypes)
        if filename:
            try:
                data = open(filename).read()
            except (IOError, OSError) as err:
                QMessageBox.warning(self, app.caption(_("Error")),
                    _("Can't read from source:\n\n{url}\n\n{error}").format(
                        url=filename, error=err.strerror))
            else:
                text = util.decode(data)
                self.currentView().textCursor().insertText(text)
        
    def openCurrentDirectory(self):
        helpers.openUrl(QUrl.fromLocalFile(self.currentDirectory()), "directory")
    
    def openCommandPrompt(self):
        helpers.openUrl(QUrl.fromLocalFile(self.currentDirectory()), "shell")
    
    def printSource(self):
        cursor = self.textCursor()
        printer = QPrinter()
        dlg = QPrintDialog(printer, self)
        dlg.setWindowTitle(app.caption(_("dialog title", "Print Source")))
        options = QAbstractPrintDialog.PrintToFile | QAbstractPrintDialog.PrintShowPageSize
        if cursor.hasSelection():
            options |= QAbstractPrintDialog.PrintSelection
        dlg.setOptions(options)
        if dlg.exec_():
            if dlg.printRange() != QAbstractPrintDialog.Selection:
                cursor.clearSelection()
            number_lines = QSettings().value("source_export/number_lines", False, bool)
            doc = highlighter.html_copy(cursor, 'printer', number_lines)
            doc.setMetaInformation(QTextDocument.DocumentTitle, self.currentDocument().url().toString())
            font = doc.defaultFont()
            font.setPointSizeF(font.pointSizeF() * 0.8)
            doc.setDefaultFont(font)
            doc.print_(printer)
    
    def exportColoredHtml(self):
        doc = self.currentDocument()
        name, ext = os.path.splitext(os.path.basename(doc.url().path()))
        if name:
            if ext.lower() == ".html":
                name += "_html"
            name += ".html"
        dir = os.path.dirname(doc.url().toLocalFile())
        if dir:
            name = os.path.join(dir, name)
        filename = QFileDialog.getSaveFileName(self, app.caption(_("Export as HTML")),
            name, "{0} (*.html)".format("HTML Files"))
        if not filename:
            return #cancelled
        number_lines = QSettings().value("source_export/number_lines", False, bool)
        inline_style = QSettings().value("source_export/inline_export", False, bool)
        import highlight2html
        html = highlight2html.html_document(doc, inline=inline_style, number_lines=number_lines)
        try:
            with open(filename, "wb") as f:
                f.write(html.encode('utf-8'))
        except (IOError, OSError) as err:
            QMessageBox.warning(self, app.caption(_("Error")),
                _("Can't write to destination:\n\n{url}\n\n{error}").format(url=filename, error=err))
        
    def undo(self):
        self.currentView().undo()
        
    def redo(self):
        self.currentView().redo()
    
    def cut(self):
        self.currentView().cut()
        
    def copy(self):
        self.currentView().copy()
        
    def paste(self):
        self.currentView().paste()
        
    def copyColoredHtml(self):
        cursor = self.textCursor()
        if not cursor.hasSelection():
            return
        number_lines = QSettings().value("source_export/number_lines", False, bool)
        inline_style = QSettings().value("source_export/inline_copy", True, bool)
        as_plain_text = QSettings().value("source_export/copy_html_as_plain_text", False, bool)
        document_body_only = QSettings().value("source_export/copy_document_body_only", False, bool)
        import highlight2html
        html = highlight2html.html_inline(cursor, inline=inline_style, number_lines=number_lines,
            full_html=not document_body_only)
        data = QMimeData()
        data.setText(html) if as_plain_text else data.setHtml(html)
        QApplication.clipboard().setMimeData(data)
        
    def selectNone(self):
        cursor = self.currentView().textCursor()
        cursor.clearSelection()
        self.currentView().setTextCursor(cursor)
    
    def selectAll(self):
        self.currentView().selectAll()
        
    def selectBlock(self):
        import lydocument
        import ly.cursortools
        cursor = lydocument.cursor(self.textCursor())
        if ly.cursortools.select_block(cursor):
            self.currentView().setTextCursor(cursor.cursor())
        
    def find(self):
        import search
        search.Search.instance(self).find()
        
    def replace(self):
        import search
        search.Search.instance(self).replace()
        
    def showPreferences(self):
        import preferences
        dlg = preferences.PreferencesDialog(self)
        dlg.exec_()
        dlg.deleteLater()
    
    def toggleFullScreen(self, enabled):
        if enabled:
            self._maximized = self.isMaximized()
            self.showFullScreen()
        else:
            self.showNormal()
            if self._maximized:
                self.showMaximized()
    
    def newWindow(self):
        """Opens a new MainWindow."""
        self.writeSettings()
        MainWindow(self).show()

    def toggleWrapLines(self, enable):
        """Called when the user toggles View->Line Wrap"""
        wrap = QPlainTextEdit.WidgetWidth if enable else QPlainTextEdit.NoWrap
        self.currentView().setLineWrapMode(wrap)
    
    def scrollUp(self):
        """Scroll up without moving the cursor"""
        sb = self.currentView().verticalScrollBar()
        sb.setValue(sb.value() - 1 if sb.value() else 0)
        
    def scrollDown(self):
        """Scroll down without moving the cursor"""
        sb = self.currentView().verticalScrollBar()
        sb.setValue(sb.value() + 1)
        
    def selectFullLinesUp(self):
        """Select lines upwards, selecting full lines."""
        self.selectFullLines(QTextCursor.Up)
        
    def selectFullLinesDown(self):
        """Select lines downwards, selecting full lines."""
        self.selectFullLines(QTextCursor.Down)
        
    def selectFullLines(self, direction):
        """Select full lines in the direction QTextCursor.Up or Down."""
        view = self.currentView()
        cur = view.textCursor()
        position = cur.position()
        cur.setPosition(cur.anchor())
        cur.movePosition(QTextCursor.StartOfLine)
        cur.setPosition(position, QTextCursor.KeepAnchor)
        cur.movePosition(direction, QTextCursor.KeepAnchor)
        cur.movePosition(QTextCursor.StartOfLine, QTextCursor.KeepAnchor)
        view.setTextCursor(cur)
    
    def showManual(self):
        """Shows the user guide, called when user presses F1."""
        import userguide
        userguide.show()
    
    def showAbout(self):
        """Shows about dialog."""
        import about
        about.AboutDialog(self).exec_()
    
    def reportBug(self):
        """Opens e-mail composer to send a bug or feature report."""
        import bugreport
        bugreport.email('', _(
            "Please describe the issue or feature request.\n"
            "Provide as much information as possible.\n\n\n"))
    
    def createActions(self):
        self.actionCollection = ac = ActionCollection()
        
        # recent files
        self.menu_recent_files = m = QMenu()
        ac.file_open_recent.setMenu(m)
        m.aboutToShow.connect(self.populateRecentFilesMenu)
        m.triggered.connect(self.slotRecentFilesAction)
        
        # connections
        ac.file_quit.triggered.connect(self.quit, Qt.QueuedConnection)
        ac.file_restart.triggered.connect(self.restart, Qt.QueuedConnection)
        ac.file_new.triggered.connect(self.newDocument)
        ac.file_open.triggered.connect(self.openDocument)
        ac.file_insert_file.triggered.connect(self.insertFromFile)
        ac.file_open_current_directory.triggered.connect(self.openCurrentDirectory)
        ac.file_open_command_prompt.triggered.connect(self.openCommandPrompt)
        ac.file_save.triggered.connect(self.saveCurrentDocument)
        ac.file_save_as.triggered.connect(self.saveCurrentDocumentAs)
        ac.file_save_copy_as.triggered.connect(self.saveCopyAs)
        ac.file_save_all.triggered.connect(self.saveAllDocuments)
        ac.file_reload.triggered.connect(self.reloadCurrentDocument)
        ac.file_reload_all.triggered.connect(self.reloadAllDocuments)
        ac.file_external_changes.triggered.connect(externalchanges.displayChangedDocuments)
        ac.file_print_source.triggered.connect(self.printSource)
        ac.file_close.triggered.connect(self.closeCurrentDocument)
        ac.file_close_other.triggered.connect(self.closeOtherDocuments)
        ac.file_close_all.triggered.connect(self.closeAllDocuments)
        ac.export_colored_html.triggered.connect(self.exportColoredHtml)
        ac.edit_undo.triggered.connect(self.undo)
        ac.edit_redo.triggered.connect(self.redo)
        ac.edit_cut.triggered.connect(self.cut)
        ac.edit_copy.triggered.connect(self.copy)
        ac.edit_paste.triggered.connect(self.paste)
        ac.edit_copy_colored_html.triggered.connect(self.copyColoredHtml)
        ac.edit_select_all.triggered.connect(self.selectAll)
        ac.edit_select_none.triggered.connect(self.selectNone)
        ac.edit_select_current_toplevel.triggered.connect(self.selectBlock)
        ac.edit_select_full_lines_up.triggered.connect(self.selectFullLinesUp)
        ac.edit_select_full_lines_down.triggered.connect(self.selectFullLinesDown)
        ac.edit_find.triggered.connect(self.find)
        ac.edit_replace.triggered.connect(self.replace)
        ac.edit_preferences.triggered.connect(self.showPreferences)
        ac.view_next_document.triggered.connect(self.tabBar.nextDocument)
        ac.view_previous_document.triggered.connect(self.tabBar.previousDocument)
        ac.view_wrap_lines.triggered.connect(self.toggleWrapLines)
        ac.view_scroll_up.triggered.connect(self.scrollUp)
        ac.view_scroll_down.triggered.connect(self.scrollDown)
        ac.window_new.triggered.connect(self.newWindow)
        ac.window_fullscreen.toggled.connect(self.toggleFullScreen)
        ac.help_manual.triggered.connect(self.showManual)
        ac.help_about.triggered.connect(self.showAbout)
        ac.help_bugreport.triggered.connect(self.reportBug)
        
    def populateRecentFilesMenu(self):
        self.menu_recent_files.clear()
        for url in recentfiles.urls():
            f = url.toLocalFile()
            dirname, basename = os.path.split(f)
            text = "{0}  ({1})".format(basename, util.homify(dirname))
            self.menu_recent_files.addAction(text).url = url
        qutil.addAccelerators(self.menu_recent_files.actions())
    
    def slotRecentFilesAction(self, action):
        """Called when a recent files menu action is triggered."""
        doc = self.openUrl(action.url)
        self.setCurrentDocument(doc)
        
    def createMenus(self):
        menu.createMenus(self)
        # actions that are not in menus
        ac = self.actionCollection
        self.addAction(ac.view_scroll_up)
        self.addAction(ac.view_scroll_down)
        self.addAction(ac.edit_select_full_lines_up)
        self.addAction(ac.edit_select_full_lines_down)
        
    def createToolBars(self):
        ac = self.actionCollection
        self.toolbar_main = t = self.addToolBar('')
        t.setObjectName('toolbar_main')
        t.addAction(ac.file_new)
        t.addAction(ac.file_open)
        t.addAction(ac.file_save)
        t.addAction(ac.file_save_as)
        t.addAction(ac.file_close)
        t.addSeparator()
        t.addAction(browseriface.get(self).actionCollection.go_back)
        t.addAction(browseriface.get(self).actionCollection.go_forward)
        t.addSeparator()
        t.addAction(ac.edit_undo)
        t.addAction(ac.edit_redo)
        t.addSeparator()
        t.addAction(scorewiz.ScoreWizard.instance(self).actionCollection.scorewiz)
        t.addAction(engrave.engraver(self).actionCollection.engrave_runner)
        
        self.toolbar_music = t = self.addToolBar('')
        t.setObjectName('toolbar_music')
        ma = panelmanager.manager(self).musicview.actionCollection
        t.addAction(ma.music_document_select)
        t.addAction(ma.music_print)
        t.addSeparator()
        t.addAction(ma.music_zoom_in)
        t.addAction(ma.music_zoom_combo)
        t.addAction(ma.music_zoom_out)
        t.addSeparator()
        t.addAction(ma.music_prev_page)
        t.addAction(ma.music_pager)
        t.addAction(ma.music_next_page)
        
    def translateUI(self):
        self.toolbar_main.setWindowTitle(_("Main Toolbar"))
        self.toolbar_music.setWindowTitle(_("Music View Toolbar"))


class ActionCollection(actioncollection.ActionCollection):
    name = "main"
    def createActions(self, parent=None):
        self.file_new = QAction(parent)
        self.file_open = QAction(parent)
        self.file_open_recent = QAction(parent)
        self.file_insert_file = QAction(parent)
        self.file_open_current_directory = QAction(parent)
        self.file_open_command_prompt = QAction(parent)
        self.file_save = QAction(parent)
        self.file_save_as = QAction(parent)
        self.file_save_copy_as = QAction(parent)
        self.file_save_all = QAction(parent)
        self.file_reload = QAction(parent)
        self.file_reload_all = QAction(parent)
        self.file_external_changes = QAction(parent)
        self.file_print_source = QAction(parent)
        self.file_close = QAction(parent)
        self.file_close_other = QAction(parent)
        self.file_close_all = QAction(parent)
        self.file_quit = QAction(parent)
        self.file_restart = QAction(parent)
        
        self.export_colored_html = QAction(parent)
        
        self.edit_undo = QAction(parent)
        self.edit_redo = QAction(parent)
        self.edit_cut = QAction(parent)
        self.edit_copy = QAction(parent)
        self.edit_copy_colored_html = QAction(parent)
        self.edit_paste = QAction(parent)
        self.edit_select_all = QAction(parent)
        self.edit_select_current_toplevel = QAction(parent)
        self.edit_select_none = QAction(parent)
        self.edit_select_full_lines_up = QAction(parent)
        self.edit_select_full_lines_down = QAction(parent)
        self.edit_find = QAction(parent)
        self.edit_find_next = QAction(parent)
        self.edit_find_previous = QAction(parent)
        self.edit_replace = QAction(parent)
        self.edit_preferences = QAction(parent)
        
        self.view_next_document = QAction(parent)
        self.view_previous_document = QAction(parent)
        self.view_wrap_lines = QAction(parent, checkable=True)
        self.view_scroll_up = QAction(parent)
        self.view_scroll_down = QAction(parent)
        
        self.window_new = QAction(parent)
        self.window_fullscreen = QAction(parent)
        self.window_fullscreen.setCheckable(True)
        
        self.help_manual = QAction(parent)
        self.help_whatsthis = QWhatsThis.createAction(parent)
        self.help_about = QAction(parent)
        self.help_bugreport = QAction(parent)
        
        # icons
        self.file_new.setIcon(icons.get('document-new'))
        self.file_open.setIcon(icons.get('document-open'))
        self.file_open_recent.setIcon(icons.get('document-open-recent'))
        self.file_open_current_directory.setIcon(icons.get('folder-open'))
        self.file_open_command_prompt.setIcon(icons.get('utilities-terminal'))
        self.file_save.setIcon(icons.get('document-save'))
        self.file_save_as.setIcon(icons.get('document-save-as'))
        self.file_save_copy_as.setIcon(icons.get('document-save-as'))
        self.file_save_all.setIcon(icons.get('document-save-all'))
        self.file_reload.setIcon(icons.get('reload'))
        self.file_reload_all.setIcon(icons.get('reload-all'))
        self.file_print_source.setIcon(icons.get('document-print'))
        self.file_close.setIcon(icons.get('document-close'))
        self.file_quit.setIcon(icons.get('application-exit'))
        
        self.edit_undo.setIcon(icons.get('edit-undo'))
        self.edit_redo.setIcon(icons.get('edit-redo'))
        self.edit_cut.setIcon(icons.get('edit-cut'))
        self.edit_copy.setIcon(icons.get('edit-copy'))
        self.edit_paste.setIcon(icons.get('edit-paste'))
        self.edit_select_all.setIcon(icons.get('edit-select-all'))
        self.edit_select_current_toplevel.setIcon(icons.get('edit-select'))
        self.edit_find.setIcon(icons.get('edit-find'))
        self.edit_find_next.setIcon(icons.get('go-down-search'))
        self.edit_find_previous.setIcon(icons.get('go-up-search'))
        self.edit_replace.setIcon(icons.get('edit-find-replace'))
        self.edit_preferences.setIcon(icons.get('preferences-system'))
        
        self.view_next_document.setIcon(icons.get('go-next'))
        self.view_previous_document.setIcon(icons.get('go-previous'))
        
        self.window_new.setIcon(icons.get('window-new'))
        self.window_fullscreen.setIcon(icons.get('view-fullscreen'))
        
        self.help_manual.setIcon(icons.get('help-contents'))
        self.help_whatsthis.setIcon(icons.get('help-contextual'))
        self.help_bugreport.setIcon(icons.get('tools-report-bug'))
        self.help_about.setIcon(icons.get('help-about'))
        
        # shortcuts
        self.file_new.setShortcuts(QKeySequence.New)
        self.file_open.setShortcuts(QKeySequence.Open)
        self.file_save.setShortcuts(QKeySequence.Save)
        self.file_save_as.setShortcuts(QKeySequence.SaveAs)
        self.file_close.setShortcuts(QKeySequence.Close)
        self.file_quit.setShortcuts(QKeySequence.Quit)
        
        self.edit_undo.setShortcuts(QKeySequence.Undo)
        self.edit_redo.setShortcuts(QKeySequence.Redo)
        self.edit_cut.setShortcuts(QKeySequence.Cut)
        self.edit_copy.setShortcuts(QKeySequence.Copy)
        self.edit_paste.setShortcuts(QKeySequence.Paste)
        self.edit_select_all.setShortcuts(QKeySequence.SelectAll)
        self.edit_select_current_toplevel.setShortcut(QKeySequence(Qt.SHIFT+Qt.CTRL+Qt.Key_B))
        self.edit_select_none.setShortcut(QKeySequence(Qt.SHIFT + Qt.CTRL + Qt.Key_A))
        self.edit_select_full_lines_up.setShortcut(QKeySequence(Qt.SHIFT + Qt.CTRL + Qt.Key_Up))
        self.edit_select_full_lines_down.setShortcut(QKeySequence(Qt.SHIFT + Qt.CTRL + Qt.Key_Down))
        self.edit_find.setShortcuts(QKeySequence.Find)
        self.edit_find_next.setShortcuts(QKeySequence.FindNext)
        self.edit_find_previous.setShortcuts(QKeySequence.FindPrevious)
        self.edit_replace.setShortcuts(QKeySequence.Replace)
        self.edit_preferences.setShortcuts(QKeySequence.Preferences)
        
        self.view_next_document.setShortcuts(QKeySequence.Forward)
        self.view_previous_document.setShortcuts(QKeySequence.Back)
        self.view_scroll_up.setShortcut(Qt.CTRL + Qt.Key_Up)
        self.view_scroll_down.setShortcut(Qt.CTRL + Qt.Key_Down)
        
        self.window_fullscreen.setShortcuts([QKeySequence(Qt.CTRL + Qt.SHIFT + Qt.Key_F), QKeySequence(Qt.Key_F11)])
        
        self.help_manual.setShortcuts(QKeySequence.HelpContents)
        
        # Mac OS X-specific roles?
        if sys.platform.startswith('darwin'):
            import macosx
            if macosx.use_osx_menu_roles():
                self.file_quit.setMenuRole(QAction.QuitRole)
                self.edit_preferences.setMenuRole(QAction.PreferencesRole)
                self.help_about.setMenuRole(QAction.AboutRole)
            else:
                self.file_quit.setMenuRole(QAction.NoRole)
                self.edit_preferences.setMenuRole(QAction.NoRole)
                self.help_about.setMenuRole(QAction.NoRole)
        
    def translateUI(self):
        self.file_new.setText(_("action: new document", "&New"))
        self.file_open.setText(_("&Open..."))
        self.file_open_recent.setText(_("Open &Recent"))
        self.file_insert_file.setText(_("Insert from &File..."))
        self.file_open_current_directory.setText(_("Open Current Directory"))
        self.file_open_command_prompt.setText(_("Open Command Prompt"))
        self.file_save.setText(_("&Save"))
        self.file_save_as.setText(_("Save &As..."))
        self.file_save_copy_as.setText(_("Save Copy or Selection As..."))
        self.file_save_all.setText(_("Save All"))
        self.file_reload.setText(_("Re&load"))
        self.file_reload_all.setText(_("Reload All"))
        self.file_external_changes.setText(_("Check for External Changes..."))
        self.file_external_changes.setToolTip(_(
            "Opens a window to check whether open documents were changed or "
            "deleted by other programs."))
        self.file_print_source.setText(_("Print Source..."))
        self.file_close.setText(_("&Close"))
        self.file_close_other.setText(_("Close Other Documents"))
        self.file_close_all.setText(_("Close All Documents"))
        self.file_close_all.setToolTip(_("Closes all documents and leaves the current session."))
        self.file_quit.setText(_("&Quit"))
        self.file_restart.setText(_("Restart {appname}").format(appname=info.appname))
        
        self.export_colored_html.setText(_("Export Source as Colored &HTML..."))
        
        self.edit_undo.setText(_("&Undo"))
        self.edit_redo.setText(_("Re&do"))
        self.edit_cut.setText(_("Cu&t"))
        self.edit_copy.setText(_("&Copy"))
        self.edit_copy_colored_html.setText(_("Copy as Colored &HTML"))
        self.edit_paste.setText(_("&Paste"))
        self.edit_select_all.setText(_("Select &All"))
        self.edit_select_current_toplevel.setText(_("Select &Block"))
        self.edit_select_none.setText(_("Select &None"))
        self.edit_select_full_lines_up.setText(_("Select Whole Lines Up"))
        self.edit_select_full_lines_down.setText(_("Select Whole Lines Down"))
        self.edit_find.setText(_("&Find..."))
        self.edit_find_next.setText(_("Find Ne&xt"))
        self.edit_find_previous.setText(_("Find Pre&vious"))
        self.edit_replace.setText(_("&Replace..."))
        self.edit_preferences.setText(_("Pr&eferences..."))
        
        self.view_next_document.setText(_("&Next Document"))
        self.view_previous_document.setText(_("&Previous Document"))
        self.view_wrap_lines.setText(_("Wrap &Lines"))
        self.view_scroll_up.setText(_("Scroll Up"))
        self.view_scroll_down.setText(_("Scroll Down"))
        
        self.window_new.setText(_("New &Window"))
        self.window_fullscreen.setText(_("&Fullscreen"))
        
        self.help_manual.setText(_("&User Guide"))
        self.help_whatsthis.setText(_("&What's This?"))
        self.help_bugreport.setText(_("Report a &Bug..."))
        self.help_about.setText(_("&About {appname}...").format(appname=info.appname))
        


########NEW FILE########
__FILENAME__ = matcher
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Highlights matching tokens such as { and }, << and >> etc.
"""

from __future__ import unicode_literals

import weakref

from PyQt4.QtGui import QAction

import app
import plugin
import ly.lex
import lydocument
import viewhighlighter
import actioncollection
import actioncollectionmanager


class AbstractMatcher(object):
    def __init__(self, view=None):
        """Initialize with an optional View. (Does not keep a reference.)"""
        self._view = lambda: None
        if view:
            self.setView(view)
        app.settingsChanged.connect(self.updateSettings)
        self.updateSettings()

    def updateSettings(self):
        from PyQt4.QtCore import QSettings
        s = QSettings()
        s.beginGroup("editor_highlighting")
        self._match_duration = s.value("match", 1, int) * 1000

    def setView(self, view):
        """Set the current View (to monitor for cursor position changes)."""
        old = self._view()
        if old:
            old.cursorPositionChanged.disconnect(self.showMatches)
        if view:
            self._view = weakref.ref(view)
            view.cursorPositionChanged.connect(self.showMatches)
        else:
            self._view = lambda: None
    
    def view(self):
        """Return the current View."""
        return self._view()
    
    def highlighter(self):
        """Implement to return an ArbitraryHighlighter for the current View."""
        pass
    
    def showMatches(self):
        """Highlights matching tokens if the view's cursor is at such a token."""
        cursors = matches(self.view().textCursor(), self.view())
        if cursors:
            self.highlighter().highlight("match", cursors, 2, self._match_duration)
        else:
            self.highlighter().clear("match")


class Matcher(AbstractMatcher, plugin.MainWindowPlugin):
    """One Matcher automatically handling the current View."""
    def __init__(self, mainwindow):
        super(Matcher, self).__init__()
        ac = self.actionCollection = Actions()
        actioncollectionmanager.manager(mainwindow).addActionCollection(ac)
        ac.view_matching_pair.triggered.connect(self.moveto_match)
        ac.view_matching_pair_select.triggered.connect(self.select_match)
        mainwindow.currentViewChanged.connect(self.setView)

        view = mainwindow.currentView()
        if view:
            self.setView(view)
        
    def highlighter(self):
        return viewhighlighter.highlighter(self.view())

    def moveto_match(self):
        """Jump to the matching token."""
        self.goto_match(False)
        
    def select_match(self):
        """Select from the current to the matching token."""
        self.goto_match(True)
        
    def goto_match(self, select=False):
        """Jump to the matching token, selecting the text if select is True."""
        cursor = self.view().textCursor()
        cursors = matches(cursor)
        if len(cursors) < 2:
            return
        if select:
            if cursors[0] < cursors[1]:
                anchor, pos = cursors[0].selectionStart(), cursors[1].selectionEnd()
            else:
                anchor, pos = cursors[0].selectionEnd(), cursors[1].selectionStart()
            cursor.setPosition(anchor)
            cursor.setPosition(pos, cursor.KeepAnchor)
        else:
            cursor.setPosition(cursors[1].selectionStart())
        self.view().setTextCursor(cursor)


class Actions(actioncollection.ActionCollection):
    name = "matchingpair"
    def createActions(self, parent):
        self.view_matching_pair = QAction(parent)
        self.view_matching_pair_select = QAction(parent)
    
    def translateUI(self):
        self.view_matching_pair.setText(_("Matching Pai&r"))
        self.view_matching_pair_select.setText(_("&Select Matching Pair"))


def matches(cursor, view=None):
    """Return a list of zero to two cursors specifing matching tokens.
    
    If the list is empty, the cursor was not at a MatchStart/MatchEnd token,
    if the list only contains one cursor the matching token could not be found,
    if the list contains two cursors, the first is the token the cursor was at,
    and the second is the matching token.
    
    If view is given, only the visible part of the document is searched.
    
    """
    block = cursor.block()
    column = cursor.position() - block.position()
    tokens = lydocument.Runner(lydocument.Document(cursor.document()))
    tokens.move_to_block(block)
    
    if view is not None:
        first_block = view.firstVisibleBlock()
        bottom = view.contentOffset().y() + view.viewport().height()
        pred_forward = lambda: view.blockBoundingGeometry(tokens.block).top() <= bottom
        pred_backward = lambda: tokens.block >= first_block
    else:
        pred_forward = lambda: True
        pred_backward = lambda: True
    
    source = None
    for token in tokens.forward_line():
        if token.pos <= column <= token.end:
            if isinstance(token, ly.lex.MatchStart):
                match, other = ly.lex.MatchStart, ly.lex.MatchEnd
                def source_gen():
                    while pred_forward():
                        for t in tokens.forward_line():
                            yield t
                        if not tokens.next_block():
                            break
                source = source_gen()
                break
            elif isinstance(token, ly.lex.MatchEnd):
                match, other = ly.lex.MatchEnd, ly.lex.MatchStart
                def source_gen():
                    while pred_backward():
                        for t in tokens.backward_line():
                            yield t
                        if not tokens.previous_block():
                            break
                source = source_gen()
                break
        elif token.pos > column:
            break
    cursors = []
    if source:
        # we've found a matcher item
        cursors.append(tokens.cursor())
        nest = 0
        for token2 in source:
            if isinstance(token2, other) and token2.matchname == token.matchname:
                if nest == 0:
                    # we've found the matching item!
                    cursors.append(tokens.cursor())
                    break
                else:
                    nest -= 1
            elif isinstance(token2, match) and token2.matchname == token.matchname:
                nest += 1
    return cursors



app.mainwindowCreated.connect(Matcher.instance)


########NEW FILE########
__FILENAME__ = menu
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Frescobaldi main menu.
"""

from __future__ import unicode_literals

try:
    import builtins # py3
except ImportError:
    import __builtin__ as builtins # py2

from PyQt4.QtGui import QMenu

import app
import icons
import bookmarkmanager
import documentactions
import documentmenu
import sessions.menu
import pitch
import rhythm
import lyrics
import panelmanager
import engrave.result_menu
import snippet.menu
import scorewiz
import autocomplete
import sidebar
import matcher
import file_import
import file_export
import browseriface
import vcs


# postpone translation
_ = lambda *args: lambda: builtins._(*args)


def createMenus(mainwindow):
    """Adds all the menus to the mainwindow's menubar."""
    m = mainwindow.menuBar()
    
    m.addMenu(menu_file(mainwindow))
    m.addMenu(menu_edit(mainwindow))
    m.addMenu(menu_view(mainwindow))
    m.addMenu(menu_music(mainwindow))
    m.addMenu(menu_insert(mainwindow))
    m.addMenu(menu_lilypond(mainwindow))
    m.addMenu(menu_tools(mainwindow))
    m.addMenu(menu_document(mainwindow))
    m.addMenu(menu_window(mainwindow))
    m.addMenu(menu_session(mainwindow))
    if vcs.app_is_git_controlled():
        from vcs.menu import GitMenu
        m.addMenu(GitMenu(mainwindow))
    m.addMenu(menu_help(mainwindow))


class Menu(QMenu):
    """A QMenu that auto-translates its title by calling a lambda function."""
    def __init__(self, title_func, parent=None):
        """title_func should return the title for the menu when called."""
        super(Menu, self).__init__(parent)
        self.title_func = title_func
        app.translateUI(self)
    
    def translateUI(self):
        self.setTitle(self.title_func())


def menu_file(mainwindow):
    m = Menu(_("menu title", "&File"), mainwindow)
    ac = mainwindow.actionCollection
    
    m.addAction(ac.file_new)
    m.addAction(scorewiz.ScoreWizard.instance(mainwindow).actionCollection.scorewiz)
    m.addMenu(snippet.menu.TemplateMenu(mainwindow))
    m.addSeparator()
    m.addAction(ac.file_open)
    m.addAction(ac.file_open_recent)
    m.addAction(ac.file_insert_file)
    m.addSeparator()
    m.addAction(ac.file_save)
    m.addAction(ac.file_save_as)
    m.addAction(ac.file_save_copy_as)
    m.addAction(panelmanager.manager(mainwindow).snippettool.actionCollection.file_save_as_template)
    m.addAction(ac.file_save_all)
    m.addSeparator()
    m.addAction(ac.file_reload)
    m.addAction(ac.file_reload_all)
    m.addAction(ac.file_external_changes)
    m.addSeparator()
    m.addMenu(menu_file_import(mainwindow))
    m.addMenu(menu_file_export(mainwindow))
    m.addSeparator()
    m.addAction(panelmanager.manager(mainwindow).musicview.actionCollection.music_print)
    m.addAction(ac.file_print_source)
    m.addSeparator()
    m.addAction(ac.file_close)
    m.addAction(ac.file_close_other)
    m.addAction(ac.file_close_all)
    m.addSeparator()
    m.addAction(ac.file_quit)
    if vcs.app_is_git_controlled():
        m.addAction(ac.file_restart)
    return m


def menu_file_import(mainwindow):
    m = Menu(_("submenu title", "&Import"), mainwindow)
    ac = file_import.FileImport.instance(mainwindow).actionCollection
    
    m.addAction(ac.import_musicxml)
    return m


def menu_file_export(mainwindow):
    m = Menu(_("submenu title", "&Export"), mainwindow)
    ac = mainwindow.actionCollection
    acfe = file_export.FileExport.instance(mainwindow).actionCollection
    
    m.addAction(acfe.export_audio)
    if vcs.app_is_git_controlled():
        m.addAction(acfe.export_musicxml)
    m.addAction(ac.export_colored_html)
    return m
    

def menu_edit(mainwindow):
    m = Menu(_("menu title", "&Edit"), mainwindow)
    ac = mainwindow.actionCollection

    m.addAction(ac.edit_undo)
    m.addAction(ac.edit_redo)
    m.addSeparator()
    m.addAction(documentactions.get(mainwindow).actionCollection.edit_cut_assign)
    m.addAction(ac.edit_cut)
    m.addAction(ac.edit_copy)
    m.addAction(panelmanager.manager(mainwindow).snippettool.actionCollection.copy_to_snippet)
    m.addAction(ac.edit_copy_colored_html)
    m.addAction(ac.edit_paste)
    m.addSeparator()
    m.addAction(ac.edit_select_all)
    m.addAction(ac.edit_select_current_toplevel)
    m.addAction(ac.edit_select_none)
    m.addSeparator()
    m.addAction(ac.edit_find)
    m.addAction(ac.edit_find_next)
    m.addAction(ac.edit_find_previous)
    m.addAction(ac.edit_replace)
    m.addSeparator()
    m.addAction(ac.edit_preferences)
    return m    


def menu_view(mainwindow):
    m = Menu(_("menu title", "&View"), mainwindow)
    ac = mainwindow.actionCollection
    
    m.addAction(ac.view_next_document)
    m.addAction(ac.view_previous_document)
    m.addSeparator()
    m.addAction(ac.view_wrap_lines)
    m.addAction(documentactions.get(mainwindow).actionCollection.view_highlighting)
    m.addAction(sidebar.SideBarManager.instance(mainwindow).actionCollection.view_linenumbers)
    m.addMenu(menu_view_folding(mainwindow))
    m.addSeparator()
    m.addAction(documentactions.get(mainwindow).actionCollection.view_goto_file_or_definition)
    ac = browseriface.get(mainwindow).actionCollection
    m.addAction(ac.go_back)
    m.addAction(ac.go_forward)
    m.addSeparator()
    ac = matcher.Matcher.instance(mainwindow).actionCollection
    m.addAction(ac.view_matching_pair)
    m.addAction(ac.view_matching_pair_select)
    m.addSeparator()
    ac = bookmarkmanager.BookmarkManager.instance(mainwindow).actionCollection
    m.addAction(ac.view_bookmark)
    m.addAction(ac.view_next_mark)
    m.addAction(ac.view_previous_mark)
    m.addAction(ac.view_clear_error_marks)
    m.addAction(ac.view_clear_all_marks)
    m.addSeparator()
    ac = panelmanager.manager(mainwindow).logtool.actionCollection
    m.addAction(ac.log_next_error)
    m.addAction(ac.log_previous_error)
    return m


def menu_view_folding(mainwindow):
    m = Menu(_("submenu title", "&Folding"), mainwindow)
    ac = sidebar.SideBarManager.instance(mainwindow).actionCollection
    
    m.addAction(ac.folding_enable)
    m.addSeparator()
    m.addAction(ac.folding_fold_current)
    m.addAction(ac.folding_fold_top)
    m.addAction(ac.folding_unfold_current)
    m.addSeparator()
    m.addAction(ac.folding_fold_all)
    m.addAction(ac.folding_unfold_all)
    return m


def menu_music(mainwindow):
    m = Menu(_("menu title", "&Music"), mainwindow)
    ac = panelmanager.manager(mainwindow).musicview.actionCollection
    
    m.addAction(ac.music_reload)
    m.addSeparator()
    m.addAction(ac.music_zoom_in)
    m.addAction(ac.music_zoom_out)
    m.addAction(ac.music_zoom_original)
    m.addSeparator()
    m.addAction(ac.music_fit_width)
    m.addAction(ac.music_fit_height)
    m.addAction(ac.music_fit_both)
    m.addSeparator()
    m.addAction(ac.music_copy_image)
    m.addSeparator()
    m.addAction(ac.music_jump_to_cursor)
    m.addAction(ac.music_sync_cursor)
    m.addSeparator()
    m.addAction(ac.music_maximize)
    return m


def menu_insert(mainwindow):
    return snippet.menu.InsertMenu(mainwindow)


def menu_lilypond(mainwindow):
    m = Menu(_("menu title", "&LilyPond"), mainwindow)
    ac = engrave.engraver(mainwindow).actionCollection
    
    m.addAction(ac.engrave_sticky)
    m.addAction(ac.engrave_autocompile)
    m.addSeparator()
    m.addAction(ac.engrave_preview)
    m.addAction(ac.engrave_publish)
    m.addAction(ac.engrave_debug)
    m.addAction(ac.engrave_custom)
    m.addAction(ac.engrave_abort)
    m.addSeparator()
    m.addMenu(menu_lilypond_generated_files(mainwindow))
    m.addSeparator()
    m.addAction(ac.engrave_show_available_fonts)
    return m


def menu_lilypond_generated_files(mainwindow):
    return engrave.result_menu.Menu(mainwindow)


def menu_tools(mainwindow):
    m = Menu(_('menu title', '&Tools'), mainwindow)
    
    ac = documentactions.get(mainwindow).actionCollection
    m.addAction(ac.tools_indent_auto)
    m.addAction(ac.tools_indent_indent)
    m.addAction(ac.tools_reformat)
    m.addAction(ac.tools_remove_trailing_whitespace)
    m.addSeparator()
    ac = autocomplete.CompleterManager.instance(mainwindow).actionCollection
    m.addAction(ac.autocomplete)
    m.addAction(ac.popup_completions)
    m.addSeparator()
    m.addMenu(menu_tools_pitch(mainwindow))
    m.addMenu(menu_tools_rhythm(mainwindow))
    m.addMenu(menu_tools_lyrics(mainwindow))
    m.addMenu(menu_tools_quick_remove(mainwindow))
    m.addSeparator()
    ac = documentactions.get(mainwindow).actionCollection
    m.addAction(ac.tools_convert_ly)
    m.addAction(mainwindow.actionCollection.file_open_current_directory)
    m.addAction(mainwindow.actionCollection.file_open_command_prompt)
    m.addSeparator()
    panelmanager.manager(mainwindow).addActionsToMenu(m)
    return m


def menu_tools_lyrics(mainwindow):
    m = Menu(_('submenu title', "&Lyrics"), mainwindow)
    m.setIcon(icons.get('audio-input-microphone'))
    ac = lyrics.lyrics(mainwindow).actionCollection

    m.addAction(ac.lyrics_hyphenate)
    m.addAction(ac.lyrics_dehyphenate)
    m.addSeparator()
    m.addAction(ac.lyrics_copy_dehyphenated)
    return m


def menu_tools_pitch(mainwindow):
    m = Menu(_('submenu title', "&Pitch"), mainwindow)
    m.setIcon(icons.get('tools-pitch'))
    ac = pitch.Pitch.instance(mainwindow).actionCollection
    
    m.addAction(ac.pitch_language)
    m.addSeparator()
    m.addAction(ac.pitch_rel2abs)
    m.addAction(ac.pitch_abs2rel)
    m.addSeparator()
    m.addAction(ac.pitch_transpose)
    m.addAction(ac.pitch_modal_transpose)
    return m


def menu_tools_rhythm(mainwindow):
    m = Menu(_('submenu title', "&Rhythm"), mainwindow)
    m.setIcon(icons.get('tools-rhythm'))
    ac = rhythm.Rhythm.instance(mainwindow).actionCollection
    
    m.addAction(ac.rhythm_double)
    m.addAction(ac.rhythm_halve)
    m.addSeparator()
    m.addAction(ac.rhythm_dot)
    m.addAction(ac.rhythm_undot)
    m.addSeparator()
    m.addAction(ac.rhythm_remove_scaling)
    m.addAction(ac.rhythm_remove_fraction_scaling)
    m.addAction(ac.rhythm_remove)
    m.addSeparator()
    m.addAction(ac.rhythm_implicit)
    m.addAction(ac.rhythm_implicit_per_line)
    m.addAction(ac.rhythm_explicit)
    m.addSeparator()
    m.addAction(ac.rhythm_apply)
    m.addAction(ac.rhythm_copy)
    m.addAction(ac.rhythm_paste)
    return m


def menu_tools_quick_remove(mainwindow):
    m = Menu(_('submenu title', "&Quick Remove"), mainwindow)
    m.setIcon(icons.get('edit-clear'))
    ac = documentactions.DocumentActions.instance(mainwindow).actionCollection
    
    m.addAction(ac.tools_quick_remove_articulations)
    m.addAction(ac.tools_quick_remove_ornaments)
    m.addAction(ac.tools_quick_remove_instrument_scripts)
    m.addAction(ac.tools_quick_remove_slurs)
    m.addAction(ac.tools_quick_remove_dynamics)
    m.addAction(ac.tools_quick_remove_markup)
    return m


def menu_document(mainwindow):
    return documentmenu.DocumentMenu(mainwindow)


def menu_window(mainwindow):
    m = Menu(_('menu title', '&Window'), mainwindow)
    ac = mainwindow.viewManager.actionCollection
    m.addAction(mainwindow.actionCollection.window_new)
    m.addSeparator()
    m.addAction(ac.window_split_horizontal)
    m.addAction(ac.window_split_vertical)
    m.addAction(ac.window_close_view)
    m.addAction(ac.window_close_others)
    m.addAction(ac.window_next_view)
    m.addAction(ac.window_previous_view)
    m.addSeparator()
    m.addAction(mainwindow.actionCollection.window_fullscreen)
    return m


def menu_session(mainwindow):
    return sessions.menu.SessionMenu(mainwindow)


def menu_help(mainwindow):
    m = Menu(_('menu title', '&Help'), mainwindow)
    ac = mainwindow.actionCollection
    m.addAction(ac.help_manual)
    m.addAction(ac.help_whatsthis)
    m.addSeparator()
    m.addAction(panelmanager.manager(mainwindow).docbrowser.actionCollection.help_lilypond_doc)
    m.addAction(panelmanager.manager(mainwindow).docbrowser.actionCollection.help_lilypond_context)
    m.addSeparator()
    m.addAction(ac.help_bugreport)
    m.addSeparator()
    m.addAction(ac.help_about)
    return m



########NEW FILE########
__FILENAME__ = metainfo
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Store meta information about documents.
"""

from __future__ import unicode_literals

import time

from PyQt4.QtCore import QSettings, QUrl

import app
import plugin


__all__ = ["info", "define"]


# This dictionary store the default values: "name": [default, readfunc]
_defaults = {}


def info(document):
    """Returns a MetaInfo object for the Document."""
    return MetaInfo.instance(document)


def define(name, default, readfunc=None):
    """Define a variable and its default value to be stored in the metainfo.
    
    Should be defined before it is requested or set.
    If readfunc is not given it defaults to a suitable function for bool or int types.
    
    """
    if readfunc is None:
        if isinstance(default, bool):
            if default:
                readfunc = lambda v: v not in ('false', False)
            else:
                readfunc = lambda v: v not in ('true', True)
        elif isinstance(default, int):
            readfunc = int
        else:
            readfunc = lambda v: v
    _defaults[name] = [default, readfunc]
    
    # read this value for already loaded metainfo items
    for minfo in MetaInfo.instances():
        minfo.loadValue(name)


class MetaInfo(plugin.DocumentPlugin):
    """Stores meta-information for a Document."""
    def __init__(self, document):
        self.load()
        document.loaded.connect(self.load, -999) # before all others
        document.closed.connect(self.save,  999) # after all others
        
    def settingsGroup(self):
        url = self.document().url()
        if not url.isEmpty():
            s = app.settings('metainfo')
            s.beginGroup(url.toString().replace('\\', '_').replace('/', '_'))
            return s
        
    def load(self):
        s = self.settingsGroup()
        for name in _defaults:
            self.loadValue(name, s)
        
    def loadValue(self, name, settings=None):
        s = settings or self.settingsGroup()
        default, readfunc = _defaults[name]
        if s and QSettings().value("metainfo", True, bool):
            self.__dict__[name] = readfunc(s.value(name, default))
        else:
            self.__dict__[name] = default

    def save(self):
        s = self.settingsGroup()
        if s:
            s.setValue("time", time.time())
            for name in _defaults:
                value = self.__dict__[name]
                s.remove(name) if value == _defaults[name][0] else s.setValue(name, value)
            

@app.aboutToQuit.connect
def prune():
    """Prune old info."""
    s = app.settings('metainfo')
    month_ago = time.time() - 31 * 24 * 3600
    for key in s.childGroups():
        if s.value(key + "/time", 0.0, float) < month_ago:
            s.remove(key)


########NEW FILE########
__FILENAME__ = event
#! python

# Python midifile package -- parse, load and play MIDI files.
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
midifile.event -- simple Event namedtuple types and a default parsing handler.
"""

from __future__ import unicode_literals

import collections


MetaEvent = collections.namedtuple('MetaEvent', 'type data')
SysExEvent = collections.namedtuple('SysExEvent', 'type data')
NoteEvent = collections.namedtuple('NoteEvent', 'type channel note value')
ControllerEvent = collections.namedtuple('ControllerEvent', 'channel number value')
ProgramChangeEvent = collections.namedtuple('ProgramChangeEvent', 'channel number')
ChannelAfterTouchEvent = collections.namedtuple('ChannelAfterTouchEvent', 'channel value')
PitchBendEvent = collections.namedtuple('PitchBendEvent', 'channel value')


class EventFactory(object):
    """Factory for parsed MIDI events.
    
    The default 'methods' create namedtuple objects.
    You can override one or more of those names to return other objects.
    
    """
    note_event = NoteEvent
    controller_event = ControllerEvent
    programchange_event = ProgramChangeEvent
    channelaftertouch_event = ChannelAfterTouchEvent
    pitchbend_event = PitchBendEvent
    sysex_event = SysExEvent
    meta_event = MetaEvent


# MIDI message constants
MIDI_CTL_MSB_MAIN_VOLUME = 0x07
MIDI_CTL_ALL_SOUNDS_OFF = 0x78
MIDI_CTL_RESET_CONTROLLERS = 0x79
MIDI_CTL_ALL_NOTES_OFF  = 0x7B


########NEW FILE########
__FILENAME__ = output
#! python

# Python midifile package -- parse, load and play MIDI files.
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Writes MIDI events to a MIDI output.
"""

from __future__ import unicode_literals

import contextlib

from . import event


class Output(object):
    """Abstract base class for a MIDI output.
    
    Inherit to implement the actual writing to MIDI ports.
    The midiplayer.Player calls midi_event and all_notes_off.
    
    """
    
    def midi_event(self, midi):
        """Handles a list or dict of MIDI events from a Song (midisong.py)."""
        if isinstance(midi, dict):
            # dict mapping track to events?
            midi = sum(map(midi.get, sorted(midi)), [])
        self.send_events(midi)
    
    def reset(self):
        """Restores the MIDI output to an initial state.
        
        Sets the program to 0, the volume to 90 and sends reset_controllers
        messages to all channels.
        
        """
        self.reset_controllers()
        self.set_main_volume(90)
        self.set_program_change(0)
    
    def set_main_volume(self, volume, channel=-1):
        channels = range(16) if channel == -1 else (channel,)
        with self.sender() as send:
            for c in channels:
                send(event.ControllerEvent(c, event.MIDI_CTL_MSB_MAIN_VOLUME, volume))
    
    def set_program_change(self, program, channel=-1):
        channels = range(16) if channel == -1 else (channel,)
        with self.sender() as send:
            for c in channels:
                send(event.ProgramChangeEvent(c, program))
        
    def reset_controllers(self, channel=-1):
        """Sends an all_notes_off message to a channel.
        
        If the channel is -1 (the default), sends the message to all channels.
        
        """
        channels = range(16) if channel == -1 else (channel,)
        with self.sender() as send:
            for c in channels:
                send(event.ControllerEvent(c, event.MIDI_CTL_RESET_CONTROLLERS, 0))
        
    def all_sounds_off(self, channel=-1):
        """Sends an all_notes_off message to a channel.
        
        If the channel is -1 (the default), sends the message to all channels.
        
        """
        channels = range(16) if channel == -1 else (channel,)
        with self.sender() as send:
            for c in channels:
                send(event.ControllerEvent(c, event.MIDI_CTL_ALL_NOTES_OFF, 0))
                send(event.ControllerEvent(c, event.MIDI_CTL_ALL_SOUNDS_OFF, 0))
        
    def send_events(self, events):
        """Writes the list of events to the output port.
        
        Each event is one of the event types in event.py
        Implement to do the actual writing.
        
        """
        pass
    
    @contextlib.contextmanager
    def sender(self):
        """Returns a context manager to call for each event to send.
        
        When the context manager exits, the events are sent using the
        send_events() method.
        
        """
        l = []
        yield l.append
        if l:
            self.send_events(l)


class PortMidiOutput(Output):
    """Writes events to a PortMIDI Output instance.
    
    The PortMIDI Output instance should be in the output attribute.
    
    """
    output = None
    
    def send_events(self, events):
        """Writes the list of events to the PortMIDI output port."""
        l = []
        for e in events:
            m = self.convert_event(e)
            if m:
                l.append([m, 0])
        while len(l) > 1024:
            self.output.write(l[:1024])
            l = l[1024:]
        if l:
            self.output.write(l)
    
    def convert_event(self, e):
        """Returns a list of integers representing a MIDI message from event."""
        t = type(e)
        if t is event.NoteEvent:
            return self.convert_note_event(e)
        elif t is event.PitchBendEvent:
            return self.convert_pitchbend_event(e)
        elif t is event.ProgramChangeEvent:
            return self.convert_programchange_event(e)
        elif t is event.ControllerEvent:
            return self.convert_controller_event(e)
    
    def convert_note_event(self, e):
        return [e.type * 16 + e.channel, e.note, e.value]

    def convert_programchange_event(self, e):
        return [0xC0 + e.channel, e.number]

    def convert_controller_event(self, e):
        return [0xB0 + e.channel, e.number, e.value]

    def convert_pitchbend_event(self, e):
        return [0xE0 + e.channel, e.value & 0x7F, e.value >> 7]




########NEW FILE########
__FILENAME__ = parser
#! python

# Python midifile package -- parse, load and play MIDI files.
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
midifile.parser -- parses MIDI file data.

This is a simple module that can parse data from a MIDI file and
its tracks.

A basic event factory returns the MIDI events as simple named tuples,
but you can subclass the event factory for more sophisticated behaviour.

Runs with Python 2.6, 2.7.
For Python 3 you can remove the ord() calls.

"""

from __future__ import unicode_literals

import struct

from . import event

unpack_midi_header = struct.Struct(b'>hhh').unpack
unpack_int = struct.Struct(b'>i').unpack


def get_chunks(s):
    """Splits a MIDI file bytes string into chunks.
    
    Yields (b'Name', b'data') tuples.
    
    """
    pos = 0
    while pos < len(s):
        name = s[pos:pos+4]
        size, = unpack_int(s[pos+4:pos+8])
        yield name, s[pos+8:pos+8+size]
        pos += size + 8

    
def parse_midi_data(s):
    """Parses MIDI file data from the bytes string s.
    
    Returns a three tuple (format_type, time_division, tracks).
    Every track is an unparsed bytes string.
    
    May raise ValueError or IndexError in case of invalid MIDI data.
    
    """
    chunks = get_chunks(s)
    for name, data in chunks:
        if name == b'MThd':
            fmt, ntracks, division = unpack_midi_header(data[:6])
            tracks = [data for name, data in chunks if name == b'MTrk']
            return fmt, division, tracks
        break
    raise ValueError("invalid midi data")


def read_var_len(s, pos):
    """Reads variable-length integer from s starting on pos.
    
    Returns the value and the new position.
    
    """
    value = 0
    while True:
        i = ord(s[pos])
        pos += 1
        value = value * 128 + (i & 0x7F)
        if not i & 0x80:
            return value, pos


def parse_midi_events(s, factory=None):
    """Parses the bytes string s (typically a track) for MIDI events.
    
    If factory is given, it should be an EventFactory instance that
    returns objects describing the event.
    
    Yields two-tuples (delta, event).
    
    Raises ValueError or IndexError on invalid MIDI data.
    
    """
    if factory is None:
        factory = event.EventFactory()
        
    running_status = None
    
    pos = 0
    while pos < len(s):
        
        delta, pos = read_var_len(s, pos)
        
        status = ord(s[pos])
        if status & 0x80:
            running_status = status
            pos += 1
        elif not running_status:
            raise ValueError("invalid running status")
        else:
            status = running_status
        
        ev_type = status >> 4
        channel = status & 0x0F
        
        if ev_type <= 0x0A:
            # note on, off or aftertouch
            note = ord(s[pos])
            value = ord(s[pos+1])
            pos += 2
            ev = factory.note_event(ev_type, channel, note, value)
        elif ev_type >= 0x0F:
            running_status = None
            if status == 0xFF:
                # meta event
                meta_type = ord(s[pos])
                meta_size, pos = read_var_len(s, pos+1)
                meta_data = s[pos:pos+meta_size]
                pos += meta_size
                ev = factory.meta_event(meta_type, meta_data)
            else:
                # some sort of sysex
                sysex_size, pos = read_var_len(s, pos)
                sysex_data = s[pos:pos+sysex_size]
                pos += sysex_size
                ev = factory.sysex_event(status, sysex_data)
        elif ev_type == 0x0E:
            # Pitch Bend
            value = ord(s[pos]) + ord(s[pos+1]) * 128
            pos += 2
            ev = factory.pitchbend_event(channel, value)
        elif ev_type == 0xD:
            # Channel AfterTouch
            value = ord(s[pos])
            pos += 1
            ev = factory.channelaftertouch_event(channel, value)
        elif ev_type == 0xB:
            # Controller
            number = ord(s[pos])
            value = ord(s[pos+1])
            pos += 2
            ev = factory.controller_event(channel, number, value)
        else: # ev_type == 0xC
            # Program Change
            number = ord(s[pos])
            pos += 1
            ev = factory.programchange_event(channel, number)
        yield delta, ev


def time_events(track, time=0):
    """Yields two-tuples (time, event).
    
    The track is the generator returned by parse_midi_events,
    the time is accumulated from the given starting time (defaulting to 0).
    
    """
    for delta, ev in track:
        time += delta
        yield time, ev


def time_events_grouped(track, time=0):
    """Yields two-tuples (time, event_list).
    
    Every event_list is a Python list of all events happening on that time.
    The track is the generator returned by parse_midi_events,
    the time is accumulated from the given starting time (defaulting to 0).
    
    """
    evs = []
    for delta, ev in track:
        if delta:
            if evs:
                yield time, evs
                evs = []
            time += delta
        evs.append(ev)
    if evs:
        yield time, evs



if __name__ == '__main__':
    """Test specified MIDI files."""
    import sys
    files = sys.argv[1:]
    for f in files:
        s = open(f, 'rb').read()
        ftm, div, tracks = parse_midi_data(s)
        try:
            for t in tracks:
                list(parse_midi_events(t))
        except Exception as e:
            print('error in:', f)
            print(e)




########NEW FILE########
__FILENAME__ = player
#! python

# Python midifile package -- parse, load and play MIDI files.
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A MIDI Player.
"""

from __future__ import unicode_literals

import collections
import time
import threading

from . import song


class Player(object):
    """The base class for a MIDI player.
    
    Use set_output() to set a MIDI output instance (see output.py).
    You can override: timer_midi_time(), timer_start() and timer_stop()
    to use another timing source than the Python threading.Timer instances.
    
    """
    def __init__(self):
        self._song = None
        self._events = []
        self._position = 0
        self._offset = 0
        self._sync_time = 0
        self._playing = False
        self._tempo_factor = 1.0
        self._output = None
        self._last_exception = None
    
    def set_output(self, output):
        """Sets an Output instance that handles the MIDI events.
        
        Use None to disable all output.
        
        """
        self._output = output
    
    def output(self):
        """Returns the currently set Output instance."""
        return self._output
        
    def load(self, filename, time=1000, beat=True):
        """Convenience function, loads a MIDI file.
        
        See set_song() for the other arguments.
        
        """
        self.set_song(song.load(filename), time, beat)
    
    def set_song(self, song, time=1000, beat=True):
        """Loads the specified Song (see song.py).
        
        If time is not None, it specifies at which interval (in msec) the
        time() method will be called. Default: 1000.
        If beat is True (default), the beat() method will be called on every
        beat.
        
        """
        playing = self._playing
        if playing:
            self.timer_stop_playing()
        self._song = song
        self._events = make_event_list(song, time, beat)
        self._position = 0
        self._offset = 0
        if playing:
            self.timer_start_playing()
    
    def song(self):
        """Returns the current Song."""
        return self._song
    
    def clear(self):
        """Unloads a loaded Song."""
        if self._playing:
            self.stop()
        self._song = None
        self._events = []
        self._position = 0
        self._offset = 0
        
    def total_time(self):
        """Returns the length in msec of the current song."""
        if self._events:
            return self._events[-1][0]
        return 0
    
    def current_time(self):
        """Returns the current time position."""
        if self._position >= len(self._events):
            time = self.total_time()
        else:
            time = self._events[self._position][0]
        if self._playing:
            return time - self.timer_offset()
        return time - self._offset
    
    def start(self):
        """Starts playing."""
        if self.has_events():
            self.timer_start_playing()
        
    def stop(self):
        """Stops playing."""
        self.timer_stop_playing()
    
    def is_playing(self):
        """Returns True if the player is playing, else False."""
        return self._playing
    
    def set_tempo_factor(self, factor):
        """Sets the tempo factor as a floating point value (1.0 is normal)."""
        self._tempo_factor = float(factor)
    
    def tempo_factor(self):
        """Returns the tempo factor (by default: 1.0)."""
        return self._tempo_factor
    
    def seek(self, time):
        """Goes to the specified time (in msec)."""
        pos = 0
        offset = 0
        if time:
            # bisect our way in the events list.
            end = len(self._events)
            while pos < end:
                mid = (pos + end) // 2
                if time > self._events[mid][0]:
                    pos = mid + 1
                else:
                    end = mid
            if pos < len(self._events):
                offset = self._events[pos][0] - time
        self.set_position(pos, offset)
    
    def seek_measure(self, measnum, beat=1):
        """Goes to the specified measure and beat (beat defaults to 1).
        
        Returns whether the measure position could be found (True or False).        
        
        """
        result = False
        for i, (t, e) in enumerate(self._events):
            if e.beat:
                if e.beat[0] == measnum:
                    position = i
                    result = True
                    if e.beat[1] >= beat:
                        break
                if e.beat[0] > measnum:
                    break
        if result:
            self.set_position(position)
            return True
        return False
        
    def set_position(self, position, offset=0):
        """(Private) Goes to the specified position in the internal events list.
        
        This method is called by seek() and seek_measure().
        
        """
        old, self._position = self._position, position
        if old != self._position:
            self.position_event(old, self._position)
        if self._playing:
            self.timer_stop()
            self.timer_schedule(offset, False)
        else:
            self._offset = offset
        
    def has_events(self):
        """Returns True if there are events left to play."""
        return bool(self._events) and self._position < len(self._events)
        
    def next_event(self):
        """(Private) Handles the current event and advances to the next.
        
        Returns the time in ms (not adjusted by tempo factor!) before
        next_event should be called again.
        
        If there is no event to handle anymore, returns 0.
        If this event was the last, calls finish() and returns 0.
        
        """
        if self.has_events():
            time, event = self._events[self._position]
            self.handle_event(time, event)
            self._position += 1
            if self._position < len(self._events):
                return self._events[self._position][0] - time
        return 0
    
    def handle_event(self, time, event):
        """(Private) Called for every event."""
        if event.midi:
            self.midi_event(event.midi)
        if event.time:
            self.time_event(time)
        if event.beat:
            self.beat_event(*event.beat)
        if event.user is not None:
            self.user_event(event.user)
    
    def midi_event(self, midi):
        """(Private) Plays the specified MIDI events.
        
        The format depends on the way MIDI events are stored in the Song.
        
        """
        if self._output:
            try:
                self._output.midi_event(midi)
            except BaseException as e:
                self.exception_event(e)
    
    def time_event(self, msec):
        """(Private) Called on every time update."""
    
    def user_event(self, obj):
        """(Private) Called when there is a user event."""
    
    def beat_event(self, measnum, beat, num, den):
        """(Private) Called on every beat."""
    
    def start_event(self):
        """Called when playback is started."""
    
    def stop_event(self):
        """Called when playback is stopped by the user."""
        if self._output:
            self._output.all_sounds_off()
        
    def finish_event(self):
        """Called when a song reaches the end by itself."""
    
    def position_event(self, old, new):
        """Called when the user seeks and the position changes.
        
        This means MIDI events are skipped and it might be necessary to 
        issue an all notes off command to the MIDI output, or to perform
        program changes.
        
        The default implementation issues an all_notes_off if the
        player is playing.
        
        """
        if self._playing and self._output:
            self._output.all_sounds_off()
    
    def exception_event(self, exception):
        """Called when an exception occurs while writing to a MIDI output.
        
        The default implementation stores the exception in self._last_exception
        and sets the output to None.
        
        """
        self._last_exception = exception
        self.set_output(None)
        
    def timer_midi_time(self):
        """Should return a continuing time value in msec, used while playing.
        
        The default implementation returns the time in msec from the Python
        time module.
        
        """
        return int(time.time() * 1000)
    
    def timer_schedule(self, delay, sync=True):
        """Schedules the upcoming event.
        
        If sync is False, don't look at the previous synchronisation time.
        
        """
        msec = delay / self._tempo_factor
        if sync:
            self._sync_time += msec
            msec = self._sync_time - self.timer_midi_time()
        else:
            self._sync_time = self.timer_midi_time() + msec
        self.timer_start(max(0, msec))
    
    def timer_start(self, msec):
        """Starts the timer to fire once, the specified msec from now."""
        self._timer = None
        self._timer = threading.Timer(msec / 1000.0, self.timer_timeout)
        self._timer.start()

    def timer_stop(self):
        """Stops the timer."""
        if self._timer:
            self._timer.cancel()
            self._timer = None

    def timer_offset(self):
        """Returns the time before the next event.
        
        This value is only useful while playing.
        
        """
        return int((self._sync_time - self.timer_midi_time()) * self._tempo_factor)
    
    def timer_start_playing(self):
        """Starts playing by starting the timer for the first upcoming event."""
        reset = self.current_time() == 0
        self._playing = True
        self.start_event()
        if reset and self._output:
            try:
                self._output.reset()
            except BaseException as e:
                self.exception_event(e)
        self.timer_schedule(self._offset, False)
    
    def timer_timeout(self):
        """Called when the timer times out.
        
        Handles an event and schedules the next.
        If the end of a song is reached, calls finish_event()
        
        """
        offset = self.next_event()
        if offset:
            self.timer_schedule(offset)
        else:
            self._offset = 0
            self._playing = False
            self.finish_event()
    
    def timer_stop_playing(self):
        self.timer_stop()
        self._offset = self.timer_offset()
        self._playing = False
        self.stop_event()


class Event(object):
    """Any event (MIDI, Time and/or Beat).
    
    Has three attributes that determine what the Player does:
    
    time: if True, time_event() is caled with the current music time.
    beat: None or (measnum, beat, num, den), then beat_event() is called.
    midi: If not None, midi_event() is called with the midi.
    user: Any object, if not None, user_event() is called with the object.
    
    """
    __slots__ = ['midi', 'time', 'beat', 'user']
    def __init__(self):
        self.midi = None
        self.time = None
        self.beat = None
        self.user = None

    def __repr__(self):
        l = []
        if self.time:
            l.append('time')
        if self.beat:
            l.append('beat({0}:{1})'.format(self.beat[0], self.beat[1]))
        if self.midi:
            l.append('midi')
        if self.user:
            l.append('user')
        return '<Event ' + ', '.join(l) + '>'


def make_event_list(song, time=None, beat=None):
    """Returns a list of all the events in Song.
    
    Each item is a two-tuple(time, Event).
    
    If time is given, a time event is generated every that many microseconds
    If beat is True, beat events are generated as well.
    MIDI events are always created.
    
    """
    d = collections.defaultdict(Event)
    
    for t, evs in song.music:
        d[t].midi = evs
    
    if time:
        for t in range(0, song.length+1, time):
            d[t].time = True
    
    if beat:
        for i in song.beats:
            d[i[0]].beat = i[1:]
    
    return [(t, d[t]) for t in sorted(d)]



########NEW FILE########
__FILENAME__ = song
#! python

# Python midifile package -- parse, load and play MIDI files.
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
midifile.song -- structures MIDI file data as a song.
"""

from __future__ import unicode_literals

import collections

from . import event
from . import parser


def load(filename):
    """Convenience function to instantiate a Song from a filename.
    
    If the filename is a type 2 MIDI file, just returns the first track.
    
    """
    fmt, div, tracks = parser.parse_midi_data(open(filename, 'rb').read())
    if fmt == 2:
        tracks = tracks[:1]
    return Song(div, tracks)


def events_dict(tracks):
    """Returns all events from the track grouped per and mapped to time-step.
    
    every time step has a dictionary with the events per track at that time.
    
    """
    d = collections.defaultdict(dict)
    for n, track in enumerate(tracks):
        for time, evs in parser.time_events_grouped(
                parser.parse_midi_events(track)):
            d[time][n] = evs
    return d


def events_dict_together(tracks):
    """Returns all events from the track grouped per and mapped to time-step.
    
    every time step has a list with all the events at that time.
    
    """
    d = collections.defaultdict(list)
    for track in tracks:
        for time, evs in parser.time_events_grouped(
                parser.parse_midi_events(track)):
            d[time].extend(evs)
    return d


def is_tempo(e):
    """Returns True if the event is a Set Tempo Meta-event."""
    return isinstance(e, event.MetaEvent) and e.type == 0x51


def get_tempo(e):
    """Returns the tempo from the Set Tempo Meta-event."""
    return ord(e.data[0])*65536 + ord(e.data[1])*256 + ord(e.data[2])


def is_time_signature(e):
    """Returns True if the event is a Set Time Signature Meta-event."""
    return isinstance(e, event.MetaEvent) and e.type == 0x58


def get_time_signature(e):
    """Returns the num, den, clocks, num_32s from the Time Signature event."""
    return map(ord, e.data)


def smpte_division(div):
    """Converts a MIDI header division from a SMPTE type, if necessary."""
    if div & 0x8000:
        frames = 256 - (div >> 8)
        resolution = div & 0xFF
        div = frames * resolution
    return div


def events_iter(d):
    """Return an iterator function over the events in one value of dict d.
    
    The values in d can be dicts (per-track) or lists (single track).
    Returns None if the events dictionary is empty.
    
    """
    for k in d:
        return iter_events_dict if isinstance(d[k], dict) else iter


def iter_events_dict(evs):
    """Iter over the (per-track) dictionary's events."""
    for k in sorted(evs):
        for e in evs[k]:
            yield e


class TempoMap(object):
    """Converts midi time to real time in microseconds."""
    def __init__(self, d, division):
        """Initialize our tempo map based on events d and division."""
        # are the events one list (single-track) or a dict (per-track)?
        self.division = smpte_division(division)
        self.times = times = []
        events = events_iter(d)
        if events:
            for midi_time, evs in sorted(d.items()):
                for e in events(evs):
                    if is_tempo(e):
                        times.append((midi_time, get_tempo(e)))
                        break
        if not times or times[0][0] != 0:
            times.insert(0, (0, 500000))
        
    def real_time(self, midi_time):
        """Returns the real time in microseconds for the given MIDI time."""
        real_time = 0
        times = self.times
        for i in range(1, len(times)):
            if times[i][0] >= midi_time:
                real_time += (midi_time - times[i-1][0]) * times[i-1][1]
                break
            real_time += (times[i][0] - times[i-1][0]) * times[i-1][1]
        else:
            real_time += (midi_time - times[-1][0]) * times[-1][1]
        return real_time // self.division
    
    def msec(self, midi_time):
        """Returns the real time in milliseconds."""
        return self.real_time(midi_time) // 1000


def beats(d, division):
    """Yields tuples for every beat in the events dictionary d.
    
    Each tuple is:
        (midi_time, beat_num, beat_total, denumerator)
    
    With this you can easily add measure numbers and find measure positions
    in the MIDI.
    
    """
    events = events_iter(d)
    if not events:
        return
    time_sigs = []
    times = sorted(d)
    for midi_time in times:
        for e in events(d[midi_time]):
            if is_time_signature(e):
                time_sigs.append((midi_time, get_time_signature(e)))
    if not time_sigs or time_sigs[0][0] != 0:
        # default time signature at start
        time_sigs.insert(0, (0, (4, 4, 24, 8)))
    
    # now yield a tuple for every beat
    time = 0
    sigs_index = 0
    while time <= times[-1]:
        
        if sigs_index < len(time_sigs) and time >= time_sigs[sigs_index][0]:
            # new time signature
            time, (num, den, clocks, n32s) = time_sigs[sigs_index]
            step = (4 * division) / (2 ** den)
            beat = 1
            sigs_index += 1
            
        yield time, beat, num, den
        time += step
        beat = beat % num + 1


class Song(object):
    """A loaded MIDI file.
    
    The following instance attributes are set on init:
    
    division: the division set in the MIDI header
    ntracks: the number of tracks
    events: a dict mapping MIDI times to a dict with per-track lists of events.
    tempo_map: TempoMap instance that computes real time from MIDI time.
    length: the length in milliseconds of the song (same as the time of the last
            event).
    
    beats: a list of tuples(msec, measnum, beat, num, den) for every beat
    music: a list of tuples(msec, d) where d is a dict mapping tracknr to events
    
    """
    def __init__(self, division, tracks):
        """Initialize the Song with the given division and track chunks."""
        self.division = division
        self.ntracks = len(tracks)
        self.events = events_dict(tracks)
        self.tempo_map = t = TempoMap(self.events, division)
        self.length = t.msec(max(self.events))

        self.beats = b = []
        measnum = 0
        for midi_time, beat, num, den in beats(self.events, division):
            if beat == 1:
                measnum += 1
            b.append((t.msec(midi_time), measnum, beat, num, den))
        self.music = [(t.msec(midi_time), evs)
                      for midi_time, evs in sorted(self.events.items())]

    def beat(self, time):
        """Returns (time, measnum, beat, num, den) for the beat at time."""
        if not self.beats:
            return (0, 0, 0, 4, 2)
        pos = 0
        if time:
            # bisect our way in the beats list.
            end = len(self.beats)
            while pos < end:
                mid = (pos + end) // 2
                if time > self.beats[mid][0]:
                    pos = mid + 1
                else:
                    end = mid
        return self.beats[min(pos, len(self.beats) - 1)]



########NEW FILE########
__FILENAME__ = midihub
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Place where MIDI is handled, output, input, signals, etc.

The MIDI support in Frescobaldi is optional (i.e. if PortMidi is not found, the
relevant functions should simply be disabled (with a message that PortMidi is
not available)).

This module uses the portmidi interface that is capable of using PortMIDI in
different ways (via a Python extension module or by embedding the PortMIDI
C library directly).

The available() method returns True if portmidi is available, False if not.

Inside Frescobaldi, interact with this module to get input and outputs etcetera,
not with portmidi directly.

"""

import portmidi
import signals


portmidi.init()


aboutToRestart = signals.Signal()       # emitted before re-init PortMIDI
settingsChanged = signals.Signal()      # emitted when ports are changed, etc


def available():
    """Returns True if portmidi is available, False if not."""
    return portmidi.available()

def restart():
    """Restarts PortMIDI."""
    aboutToRestart()
    portmidi.quit()
    portmidi.init()
    settingsChanged()
    
def refresh_ports():
    """Refreshes the port list."""
    restart()

def get_count():
    """Returns the number of available PortMIDI ports, or 0 if no PortMIDI."""
    return portmidi.get_count() if available() else 0

def device_infos():
    """Yields the device info for all PortMIDI devices."""
    for n in range(get_count()):
        yield portmidi.get_device_info(n)

def output_ports():
    """Returns a list of all the output port names."""
    names = []
    if available():
        for i in device_infos():
            if i.isoutput:
                names.append(i.name)
    return names

def input_ports():
    """Returns a list of all the output port names."""
    names = []
    if available():
        for i in device_infos():
            if i.isinput:
                names.append(i.name)
    return names

def default_output():
    """Returns a probably suitable default MIDI output port name."""
    names = []
    if available():
        for i in device_infos():
            if i.isoutput:
                names.append(i.name)
                if 'through' not in i.name.lower():
                    return i.name
    return names[0] if names else ""

def default_input():
    """Returns a probably suitable default MIDI output port name."""
    names = []
    if available():
        for i in device_infos():
            if i.isinput:
                names.append(i.name)
                if 'through' not in i.name.lower():
                    return i.name
    return names[0] if names else ""

def output_by_name(name):
    """Returns a portmidi.Output instance for name."""
    for n in range(get_count()):
        i = portmidi.get_device_info(n)
        if i.isoutput and i.name.startswith(name) and not i.isopen:
            return portmidi.Output(n)

def input_by_name(name):
    """Returns a portmidi.Output instance for name."""
    for n in range(get_count()):
        i = portmidi.get_device_info(n)
        if i.isinput and i.name.startswith(name) and not i.isopen:
            return portmidi.Input(n)

# allow the MIDI player to run on python time if portmidi is not available:
if available():
    time = portmidi.time
else:
    from time import time as time_
    def time():
        """Returns a time value in msec."""
        return int(time_() * 1000)



########NEW FILE########
__FILENAME__ = elements
"""
Elements that can bei inserted by MIDI events
"""

import ly.pitch


class Note:
    def __init__(self, midinote, notemapping):
        # get correct note 0...11 = c...b
        # and octave corresponding to octave modifiers ',' & '''
        self._midinote = midinote
        self._octave, self._note = divmod(midinote, 12)
        self._octave -= 4
        self._pitch = ly.pitch.Pitch(notemapping[self._note][0], notemapping[self._note][1], self._octave)
    
    def output(self, language='nederlands'):
        return self._pitch.output(language)
    
    def midinote(self):
        return self._midinote


class Chord(object):
    def __init__(self):
        self._notes = list()
        
    def add(self, note):
        self._notes.append(note)
    
    def output(self, language='nederlands'):
        if len(self._notes) == 1:    # only one note, no chord
            return self._notes[0].output(language)
        else:    # so we have a chord, print <chord>
            sortednotes = sorted(self._notes, key=lambda note: note.midinote())
            chord = ''
            for n in sortednotes:
                chord += n.output(language) + ' '
            return '<' + chord[:-1] + '>'    # strip last space


class NoteMappings:
    def to_sharp(self, note, alteration):
        if alteration==0.5:
            return (note, alteration)
        return (note-1 if note > 0 else 6, 0.5)

    def to_flat(self, note, alteration):
        if alteration==-0.5:
            return (note, alteration)
        return (note+1 if note <6 else 0, -0.5)

    def __init__(self):
        self.key_order_sharp = [6, 1, 8, 3, 10, 5, 0]
        self.key_order_flat = [10, 3, 8, 1, 6, 11, 4]

        self.sharps = [(0, 0),    # c
                       (0, 0.5),  # cis
                       (1, 0),    # d
                       (1, 0.5),  # dis
                       (2, 0),    # e
                       (3, 0),    # f
                       (3, 0.5),  # fis
                       (4, 0),    # g
                       (4, 0.5),  # gis
                       (5, 0),    # a
                       (5, 0.5),  # ais
                       (6, 0)]    # b

        self.flats = [(0, 0),     # c
                      (1, -0.5),  # des
                      (1, 0),     # d
                      (2, -0.5),  # es
                      (2, 0),     # e
                      (3, 0),     # f
                      (4, -0.5),  # ges
                      (4, 0),     # g
                      (5, -0.5),  # aes
                      (5, 0),     # a
                      (6, -0.5),  # bes
                      (6, 0)]     # b
        # Construct all possible mappings using some replacement logic

        self.sharp_mappings = []
        self.flat_mappings = []
        for i in xrange(len(self.key_order_flat)-1, -1, -1):
            flatmap = list(self.flats) # copy existing list
            sharpmap = list(self.sharps) # copy existing list
            for k in self.key_order_flat[:i+1]:
                flatmap[k] = self.to_flat(*flatmap[k])
                sharpmap[k] = self.to_flat(*sharpmap[k])
            self.flat_mappings.append(flatmap)
            self.sharp_mappings.append(sharpmap)
    
        self.sharp_mappings.append(self.sharps) # Append C major signature -> no key alteration
        self.flat_mappings.append(self.flats) # Append C major signature -> no key alteration

        for i in xrange(len(self.key_order_sharp)):
            flatmap = list(self.flats) # copy existing list
            sharpmap = list(self.sharps) # copy existing list
            for k in self.key_order_sharp[:i+1]:
                flatmap[k] = self.to_sharp(*flatmap[k])
                sharpmap[k] = self.to_sharp(*sharpmap[k])
            self.flat_mappings.append(flatmap)
            self.sharp_mappings.append(sharpmap)

class NoteMapping:
    mappings = NoteMappings()

    def __init__(self, keysignature, sharps=True):
        if sharps:
            self.mapping = NoteMapping.mappings.sharp_mappings[keysignature]
        else:
            self.mapping = NoteMapping.mappings.flat_mappings[keysignature]

    def __len__(self):
        return len(self.mapping)

    def __getitem__(self, index):
        return self.mapping[index]

########NEW FILE########
__FILENAME__ = tool
"""
MIDI input dock
"""

from __future__ import unicode_literals

from PyQt4.QtCore import Qt
from PyQt4.QtGui import QAction, QKeySequence

import actioncollection
import actioncollectionmanager
import icons
import panel


class MidiInputTool(panel.Panel):
    """Midi Tool."""
    def __init__(self, mainwindow):
        super(MidiInputTool, self).__init__(mainwindow)
        self.hide()
        self.toggleViewAction().setShortcut(QKeySequence("Meta+Alt+R"))
        ac = self.actionCollection = Actions()
        ac.capture_start.triggered.connect(self.slotStartCapturing)
        ac.capture_stop.triggered.connect(self.slotStopCapturing)
        actioncollectionmanager.manager(mainwindow).addActionCollection(ac)
        mainwindow.addDockWidget(Qt.BottomDockWidgetArea, self)
    
    def translateUI(self):
        self.setWindowTitle(_("MIDI Input"))
        self.toggleViewAction().setText(_("MIDI I&nput"))
    
    def slotStartCapturing(self):
        self.widget().startcapturing()
    
    def slotStopCapturing(self):
        self.widget().stopcapturing()
    
    def createWidget(self):
        from . import widget
        return widget.Widget(self)

class Actions(actioncollection.ActionCollection):
    name = "midiinputtool"
    def createActions(self, parent=None):
        self.capture_start = QAction(parent)
        self.capture_stop = QAction(parent)
        
        self.capture_start.setIcon(icons.get('media-record'))
        self.capture_stop.setIcon(icons.get('process-stop'))
        
    def translateUI(self):
        self.capture_start.setText(_("midi input", "Start capturing"))
        self.capture_start.setToolTip(_("midi input", "Start MIDI capturing"))
        self.capture_stop.setText(_("midi input", "Stop capturing"))
        self.capture_stop.setToolTip(_("midi input", "Stop MIDI capturing"))

########NEW FILE########
__FILENAME__ = widget
"""
MIDI input controls
"""

from __future__ import unicode_literals

import weakref

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app

import midiinput


class Widget(QWidget):
    def __init__(self, dockwidget):
        super(Widget, self).__init__(dockwidget)
        self._document = None
        self._midiin = midiinput.MidiIn(self)
        self._dockwidget = weakref.ref(dockwidget)
        
        signals = list()
        
        self._labelmidichannel = QLabel()
        self._midichannel = QComboBox()
        signals.append(self._midichannel.currentIndexChanged)
        
        self._labelkeysignature = QLabel()
        self._keysignature = QComboBox()
        signals.append(self._keysignature.currentIndexChanged)
        
        self._labelaccidentals = QLabel()
        self._accidentalssharps = QRadioButton()
        signals.append(self._accidentalssharps.clicked)
        self._accidentalsflats = QRadioButton()
        signals.append(self._accidentalsflats.clicked)
        self._groupaccidentals = QGroupBox()
        self._groupaccidentals.setFlat(True)
        hbox = QHBoxLayout()
        self._groupaccidentals.setLayout(hbox)
        hbox.addWidget(self._accidentalssharps)
        hbox.addWidget(self._accidentalsflats)
        self._accidentalssharps.setChecked(True)
        
        self._labelchordmode = QLabel()
        self._chordmode = QCheckBox()
        signals.append(self._chordmode.clicked)
        
        self._labeldamper = QLabel()
        self._damper = QComboBox()
        
        self._labelsostenuto = QLabel()
        self._sostenuto = QComboBox()
        
        self._labelsoft = QLabel()
        self._soft = QComboBox()
        
        ac = self.parentWidget().actionCollection
        self._capture = QToolButton()
        self._capture.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        self._capture.setDefaultAction(ac.capture_start)
        
        self._notemode = QLabel()
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        grid = QGridLayout(spacing=0)
        layout.addLayout(grid)
               
        grid.addWidget(self._labelmidichannel, 0, 0)
        grid.addWidget(self._midichannel, 0, 1)
        grid.addWidget(self._labelkeysignature, 1, 0)
        grid.addWidget(self._keysignature, 1, 1)
        grid.addWidget(self._labelaccidentals, 2, 0)
        grid.addWidget(self._groupaccidentals, 2, 1)
        grid.addWidget(self._labelchordmode, 3, 0)
        grid.addWidget(self._chordmode, 3, 1)
        grid.addWidget(self._labeldamper, 4, 0)
        grid.addWidget(self._damper, 4, 1)
        grid.addWidget(self._labelsostenuto, 5, 0)
        grid.addWidget(self._sostenuto, 5, 1)
        grid.addWidget(self._labelsoft, 6, 0)
        grid.addWidget(self._soft, 6, 1)
        
        hbox = QHBoxLayout()
        layout.addLayout(hbox)
        hbox.addWidget(self._capture)
        hbox.addStretch()
        hbox.addWidget(self._notemode)
        self._notemode.setText('absolute')
        
        app.translateUI(self)
        
        self.loadsettings()
        for s in signals:
            s.connect(self.savesettings)
    
    def mainwindow(self):
        return self._dockwidget().mainwindow()
    
    def channel(self):
        return self._midichannel.currentIndex()
    
    def keysignature(self):
        return self._keysignature.currentIndex()
    
    def accidentals(self):
        if self._accidentalsflats.isChecked():
            return 'flats'
        else:
            return 'sharps'
    
    def chordmode(self):
        return self._chordmode.isChecked()
    
    def startcapturing(self):
        self._midiin.capture()
        ac = self.parentWidget().actionCollection
        while self._capture.actions():    # remove all old actions
            self._capture.removeAction(self._capture.actions()[0])
        self._capture.setDefaultAction(ac.capture_stop)
    
    def stopcapturing(self):
        self._midiin.capturestop()
        ac = self.parentWidget().actionCollection
        while self._capture.actions():    # remove all old actions
            self._capture.removeAction(self._capture.actions()[0])
        self._capture.setDefaultAction(ac.capture_start)
    
    def savesettings(self):
        s = QSettings()
        s.beginGroup("midiinputdock")
        s.setValue("midichannel", self._midichannel.currentIndex())
        s.setValue("keysignature", self._keysignature.currentIndex())
        if self._accidentalsflats.isChecked():
            s.setValue("accidentals", 'flats')
        else:
            s.setValue("accidentals", 'sharps')
        s.setValue("chordmode", self._chordmode.isChecked())
    
    def loadsettings(self):
        s = QSettings()
        s.beginGroup("midiinputdock")
        self._midichannel.setCurrentIndex(s.value("midichannel", 0, int))
        self._keysignature.setCurrentIndex(s.value("keysignature", 7, int))
        if s.value("accidentals", 'sharps', str) == 'flats':
            self._accidentalsflats.setChecked(True)
        else:
            self._accidentalssharps.setChecked(True)
        self._chordmode.setChecked(s.value("chordmode", False, bool))

    def translateUI(self):
        self._labelmidichannel.setText(_("MIDI channel"))
        self._midichannel.addItems([_("all")]+[str(i) for i in range(1,17)])
        self._labelkeysignature.setText(_("Key signature"))
        self._keysignature.addItems([
            _("C flat major (7 flats)"),
            _("G flat major (6 flats)"),
            _("D flat major (5 flats)"),
            _("A flat major (4 flats)"),
            _("E flat major (3 flats)"),
            _("B flat major (2 flats)"),
            _("F major (1 flat)"),
            _("no key"),
            _("G major (1 sharp)"),
            _("D major (2 sharps)"),
            _("A major (3 sharps)"),
            _("E major (4 sharps)"),
            _("B major (5 sharps)"),
            _("F sharp major (6 sharps)"),
            _("C sharp major (7 sharps)")
            ])
        self._keysignature.setCurrentIndex(7)
        self._labelaccidentals.setText(_("Accidentals"))
        self._accidentalssharps.setText(_("sharps"))
        self._accidentalsflats.setText(_("flats"))
        self._labelchordmode.setText(_("Chord mode"))
        self._chordmode.setToolTip(_(
            "Enter simultaneously played notes as chords. "
            "See \"What's This\" for more information."))
        self._chordmode.setWhatsThis(_(
            "Notes which are played simultaneously are written "
            "as chords. As a consequence they are not written "
            "before the last key is lifted. Of course single "
            "can also be entered."))
        self._labeldamper.setText(_("Damper pedal"))
        self._labelsostenuto.setText(_("Sostenuto pedal"))
        self._labelsoft.setText(_("Soft pedal"))

########NEW FILE########
__FILENAME__ = midifiles
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Handles MIDI files.
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import Qt

import icons
import plugin
import signals
import jobmanager
import resultfiles
import listmodel
import midifile.song


class MidiFiles(plugin.DocumentPlugin):
    def __init__(self, document):
        self._files = None
        self.current = 0
        document.loaded.connect(self.invalidate, -100)
        jobmanager.manager(document).finished.connect(self.invalidate, -100)
    
    def invalidate(self):
        self._files = None
        
    def update(self):
        files = resultfiles.results(self.document()).files('.mid*')
        self._files = files
        self._songs = [None] * len(files)
        if files and self.current >= len(files):
            self.current = len(files) - 1
        return bool(files)
    
    def __nonzero__(self):
        return bool(self._files)
    
    def song(self, index):
        if self._files is None:
            self.update()
        song = self._songs[index]
        if not song:
            song = self._songs[index] = midifile.song.load(self._files[index])
        return song
    
    def model(self):
        """Returns a model for a combobox."""
        if self._files is None:
            self.update()
        m = listmodel.ListModel(self._files,
            display = os.path.basename, icon = icons.file_type)
        m.setRoleFunction(Qt.UserRole, lambda f: f)
        return m



########NEW FILE########
__FILENAME__ = output
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Handles output to MIDI ports.
"""

from __future__ import unicode_literals


import midifile.output


class Output(midifile.output.PortMidiOutput):
    """Handles the output, e.g. for a MIDI player."""
    def __init__(self, output):
        self.output = output








########NEW FILE########
__FILENAME__ = player
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The MIDI player for Frescobaldi.
"""

from __future__ import unicode_literals

from midifile.event import ControllerEvent, ProgramChangeEvent
import qmidi.player
import midihub


def event_filter(midi_event):
    """If this function returns True, the MIDI event is sent while seeking."""
    return isinstance(midi_event, (ControllerEvent, ProgramChangeEvent))


class Player(qmidi.player.Player):
    """This Player uses the time from midihub."""
    def timer_midi_time(self):
        return midihub.time()

    def position_event(self, old, new):
        """Called when seeking. Performs program changes."""
        super(Player, self).position_event(old, new)
        output = self.output()
        if not output:
            return
        if new > old:
            evs = self._events[old:new]
        else:
            evs = self._events[:new]
            output.reset()
        for time, e in evs:
            if e.midi:
                if isinstance(e.midi, dict):
                    # dict mapping track to events?
                    midi = sum(map(e.midi.get, sorted(e.midi)), [])
                else:
                    midi = e.midi
                # no note events of course
                midi = [mev for mev in midi if event_filter(mev)]
                if midi:
                    output.send_events(midi)



########NEW FILE########
__FILENAME__ = widget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The MIDI tool widget.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import css
import qutil
import midihub
import widgets.drag

from . import midifiles
from . import output
from . import player


class Widget(QWidget):
    def __init__(self, dockwidget):
        super(Widget, self).__init__(dockwidget)
        self._document = None
        self._fileSelector = QComboBox(editable=True, insertPolicy=QComboBox.NoInsert)
        widgets.drag.ComboDrag(self._fileSelector).role = Qt.UserRole
        self._fileSelector.lineEdit().setReadOnly(True)
        self._fileSelector.lineEdit().setFocusPolicy(Qt.NoFocus)
        self._stopButton = QToolButton()
        self._playButton = QToolButton()
        self._timeSlider = QSlider(Qt.Horizontal, tracking=False,
            singleStep=500, pageStep=5000, invertedControls=True)
        self._display = Display()
        self._tempoFactor = QSlider(Qt.Vertical, minimum=-50, maximum=50,
            singleStep=1, pageStep=5)
        
        grid = QGridLayout(spacing=0)
        self.setLayout(grid)
        
        grid.addWidget(self._fileSelector, 0, 0, 1, 3)
        grid.addWidget(self._stopButton, 1, 0)
        grid.addWidget(self._playButton, 1, 1)
        grid.addWidget(self._timeSlider, 1, 2)
        grid.addWidget(self._display, 2, 0, 1, 3)
        grid.addWidget(self._tempoFactor, 0, 3, 3, 1)
        
        # size policy of combo
        p = self._fileSelector.sizePolicy()
        p.setHorizontalPolicy(QSizePolicy.Ignored)
        self._fileSelector.setSizePolicy(p)
        
        # size policy of combo popup
        p = self._fileSelector.view().sizePolicy()
        p.setHorizontalPolicy(QSizePolicy.MinimumExpanding)
        self._fileSelector.view().setSizePolicy(p)

        self._player = player.Player()
        self._outputCloseTimer = QTimer(interval=60000, singleShot=True,
            timeout=self.closeOutput)
        self._timeSliderTicker = QTimer(interval=200, timeout=self.updateTimeSlider)
        self._fileSelector.activated[int].connect(self.slotFileSelected)
        self._tempoFactor.valueChanged.connect(self.slotTempoChanged)
        self._timeSlider.valueChanged.connect(self.slotTimeSliderChanged)
        self._timeSlider.sliderMoved.connect(self.slotTimeSliderMoved)
        self._player.beat.connect(self.updateDisplayBeat)
        self._player.time.connect(self.updateDisplayTime)
        self._player.stateChanged.connect(self.slotPlayerStateChanged)
        self.slotPlayerStateChanged(False)
        dockwidget.mainwindow().currentDocumentChanged.connect(self.loadResults)
        app.documentLoaded.connect(self.slotUpdatedFiles)
        app.jobFinished.connect(self.slotUpdatedFiles)
        app.aboutToQuit.connect(self.stop)
        midihub.aboutToRestart.connect(self.slotAboutToRestart)
        midihub.settingsChanged.connect(self.clearMidiSettings, -100)
        midihub.settingsChanged.connect(self.readMidiSettings)
        app.documentClosed.connect(self.slotDocumentClosed)
        app.translateUI(self)
        self.readMidiSettings()
        d = dockwidget.mainwindow().currentDocument()
        if d:
            self.loadResults(d)

    def translateUI(self):
        self._tempoFactor.setToolTip(_("Tempo"))
    
    def slotAboutToRestart(self):
        self.stop()
        self._player.set_output(None)
    
    def clearMidiSettings(self):
        """Called first when settings are changed."""
        self.stop()
        self._outputCloseTimer.stop()
        self._player.set_output(None)
        
    def readMidiSettings(self):
        """Called after clearMidiSettings(), and on first init."""
        pass
            
    def openOutput(self):
        """Called when playing starts. Ensures an output port is opened."""
        self._outputCloseTimer.stop()
        if not self._player.output():
            p = QSettings().value("midi/player/output_port", midihub.default_output(), type(""))
            o = midihub.output_by_name(p)
            if o:
                self._player.set_output(output.Output(o))
    
    def closeOutput(self):
        """Called when the output close timer fires. Closes the output."""
        self._player.set_output(None)
        
    def slotPlayerStateChanged(self, playing):
        ac = self.parentWidget().actionCollection
        # setDefaultAction also adds the action
        for b in self._stopButton, self._playButton:
            while b.actions():
                b.removeAction(b.actions()[0])
        if playing:
            self._timeSliderTicker.start()
            self._stopButton.setDefaultAction(ac.midi_stop)
            self._playButton.setDefaultAction(ac.midi_pause)
        else:
            self._timeSliderTicker.stop()
            self.updateTimeSlider()
            self._stopButton.setDefaultAction(ac.midi_restart)
            self._playButton.setDefaultAction(ac.midi_play)
            # close the output if the preference is set
            if QSettings().value("midi/close_outputs", False, bool):
                self._outputCloseTimer.start()
        
    def play(self):
        """Starts the MIDI player, opening an output if necessary."""
        if not self._player.is_playing() and not self._player.has_events():
            self.restart()
        self.openOutput()
        if not self._player.output():
            self._display.statusMessage(_("No output found!"))
        self._player.start()
    
    def stop(self):
        """Stops the MIDI player."""
        self._player.stop()
    
    def restart(self):
        """Restarts the MIDI player.
        
        If another file is in the file selector, or the file was updated,
        the new file is loaded.
        
        """
        self._player.seek(0)
        self.updateTimeSlider()
        self._display.reset()
        if self._document:
            files = midifiles.MidiFiles.instance(self._document)
            index = self._fileSelector.currentIndex()
            if files and (files.song(index) is not self._player.song()):
                self.loadSong(index)
        
    def slotTempoChanged(self, value):
        """Called when the user drags the tempo."""
        # convert -50 to 50 to 0.5 to 2.0
        factor = 2 ** (value / 50.0)
        self._player.set_tempo_factor(factor)
        self._display.setTempo("{0}%".format(int(factor * 100)))
    
    def slotTimeSliderChanged(self, value):
        self._player.seek(value)
        self._display.setTime(value)
        if self._player.song():
            self._display.setBeat(*self._player.song().beat(value)[1:])
    
    def slotTimeSliderMoved(self, value):
        self._display.setTime(value)
        if self._player.song():
            self._display.setBeat(*self._player.song().beat(value)[1:])
    
    def updateTimeSlider(self):
        if not self._timeSlider.isSliderDown():
            with qutil.signalsBlocked(self._timeSlider):
                self._timeSlider.setMaximum(self._player.total_time())
                self._timeSlider.setValue(self._player.current_time())

    def updateDisplayBeat(self, measnum, beat, num, den):
        if not self._timeSlider.isSliderDown():
            self._display.setBeat(measnum, beat, num, den)
    
    def updateDisplayTime(self, time):
        if not self._timeSlider.isSliderDown():
            self._display.setTime(time)
    
    def slotUpdatedFiles(self, document):
        """Called when there are new MIDI files."""
        if document == self.parentWidget().mainwindow().currentDocument():
            self.loadResults(document)
    
    def loadResults(self, document):
        self._document = document
        files = midifiles.MidiFiles.instance(document)
        self._fileSelector.setModel(files.model())
        if files:
            self._fileSelector.setCurrentIndex(files.current)
            if not self._player.is_playing():
                self.loadSong(files.current)
    
    def loadSong(self, index):
        files = midifiles.MidiFiles.instance(self._document)
        self._player.set_song(files.song(index))
        m, s = divmod(self._player.total_time() / 1000, 60)
        name = self._fileSelector.currentText()
        self.updateTimeSlider()
        self._display.reset()
        self._display.statusMessage(
            _("midi lcd screen", "LOADED"), name,
            _("midi lcd screen", "TOTAL"), "{0}:{1:02}".format(m, s))
    
    def slotFileSelected(self, index):
        if self._document:
            self._player.stop()
            files = midifiles.MidiFiles.instance(self._document)
            if files:
                files.current = index
                self.restart()
    
    def slotDocumentClosed(self, document):
        if document == self._document:
            self._document = None
            self._fileSelector.clear()
            self._player.stop()
            self._player.clear()
            self.updateTimeSlider()
            self._display.reset()


class Display(QLabel):
    """Maintains values in the LCD display."""
    def __init__(self):
        QLabel.__init__(self, wordWrap=True)
        self.setSizePolicy(QSizePolicy(QSizePolicy.Ignored, QSizePolicy.Preferred))
        self.setStyleSheet(css.lcd_screen)
        self._tempoTimer = QTimer(interval=1500, singleShot=True,
            timeout=self.setTempo)
        self._statusTimer = QTimer(interval=2000, singleShot=True,
            timeout=self.statusMessage)
        self._tempo = None
        self._status = None
        self.reset()
        app.translateUI(self)
    
    def reset(self):
        """Sets everything to 0."""
        self._time = 0
        self._beat = 0, 0, 0, 0
        self.updateDisplay()
        
    def translateUI(self):
        self.updateDisplay()
    
    def setTime(self, time):
        self._time = time
        self.updateDisplay()
    
    def setBeat(self, measnum, beat, num, den):
        self._beat = measnum, beat, num, den
        self.updateDisplay()
    
    def setTempo(self, text=None):
        self._tempo = text
        if text:
            self._tempoTimer.start()
        self.updateDisplay()
    
    def statusMessage(self, *msg):
        """Status message can be multiple arguments (1 to 4)."""
        self._status = msg
        if msg:
            self._statusTimer.start()
        self.updateDisplay()
        
    def updateDisplay(self):
        minutes, seconds = divmod(self._time / 1000, 60)
        
        time_spec = "{0}:{1:02}".format(minutes, seconds)
        if self._status:
            items = self._status
            if len(items) == 1:
                self.setText(_lcd_status_one.format("&nbsp;", items[0]))
            elif len(items) == 2:
                self.setText(_lcd_status_one.format(*items))
            elif len(items) == 3:
                self.setText(_lcd_status_two.format(
                    items[0], items[1], "&nbsp;", items[2]))
            elif len(items) == 4:
                self.setText(_lcd_status_two.format(*items))
        elif self._tempo:
            self.setText(_lcd_text.format(
                _("midi lcd screen", "TIME"),
                _("midi lcd screen", "TEMPO"),
                time_spec,
                self._tempo,
            ))
        else:
            measnum, beat, num, den = self._beat
            beat_spec = "{0}.{1:2}".format(measnum, beat)
            time_sig = "&nbsp;{0}/{1}".format(num, 2 ** den) if num else ""
            self.setText(_lcd_text.format(
                _("midi lcd screen", "TIME"),
                _("midi lcd screen", "BEAT") + time_sig,
                time_spec,
                beat_spec,
            ))



_lcd_text = """\
<table width=100% border=0 cellspacing=0>
<tr>
<td width=50% align=right style="font-size:8px;">{0}</td>
<td width=50% align=right style="font-size:8px;">{1}</td>
</tr>
<tr>
<td width=50% align=right><h2>{2}</h2></td>
<td width=50% align=right><h2>{3}</h2></td>
</tr>
</table>"""

_lcd_status_one = """\
<table width=100% border=0 cellspacing=0>
<tr>
<td align=left style="font-size:8px;">{0}</td>
</tr>
<tr>
<td align=left><h2>{1}</h2></td>
</tr>
</table>"""

_lcd_status_two = """\
<table width=100% border=0 cellspacing=0>
<tr>
<td align=left style="font-size:8px;">{0}</td>
<td align=right style="font-size:8px;">{2}</td>
</tr>
<tr>
<td align=left><h2>{1}</h2></td>
<td align=right><h2>{3}</h2></td>
</tr>
</table>"""


########NEW FILE########
__FILENAME__ = music
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2014 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Frescobaldi's extensions of ly.music.
"""

from __future__ import unicode_literals


import ly.music.items
import fileinfo


class Document(ly.music.items.Document):
    """music.Document type that caches music trees using fileinfo."""
    def get_included_document_node(self, node):
        """Return a Document for the Include node."""
        filename = node.filename()
        if filename:
            resolved = self.resolve_filename(filename)
            if resolved:
                d = fileinfo.music(resolved)
                d.include_node = node
                d.include_path = self.include_path
                return d



########NEW FILE########
__FILENAME__ = musicpos
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Shows the time position of the text cursor in the music.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QTimer
from PyQt4.QtGui import QLabel

import weakref

import app
import plugin
import cursortools


class MusicPosition(plugin.ViewSpacePlugin):
    def __init__(self, space):
        self._timer = QTimer(singleShot=True, timeout=self.slotTimeout)
        self._waittimer = QTimer(singleShot=True, timeout=self.slotTimeout)
        self._label = QLabel()
        space.status.layout().insertWidget(1, self._label)
        self._view = lambda: None
        space.viewChanged.connect(self.slotViewChanged)
        view = space.activeView()
        if view:
            self.slotViewChanged(view)
        app.translateUI(self)
    
    def translateUI(self):
        text = _("Pos: {pos}").format(pos="999/16")
        pos_width = self._label.fontMetrics().width(text)
        text = _("Length: {length}").format(length="999/16")
        len_width = self._label.fontMetrics().width(text)
        self._label.setMinimumWidth(max(pos_width, len_width))
    
    def slotViewChanged(self, view):
        old = self._view()
        if old:
            self.disconnectView(old)
        self._view = weakref.ref(view)
        self.connectView(view)
        self.startTimer()
    
    def connectView(self, view):
        view.cursorPositionChanged.connect(self.startTimer)
        view.document().contentsChanged.connect(self.startWaitTimer)
        
    def disconnectView(self, view):
        view.cursorPositionChanged.disconnect(self.startTimer)
        view.document().contentsChanged.disconnect(self.startWaitTimer)
    
    def startWaitTimer(self):
        """Called when the document changes, waits longer to prevent stutter."""
        self._waittimer.start(900)
        self._timer.stop()
        
    def startTimer(self):
        """Called when the cursor moves."""
        if not self._waittimer.isActive():
            self._timer.start(100)
    
    def slotTimeout(self):
        """Called when one of the timers fires."""
        view = self._view()
        if view:
            d = view.document()
            c = view.textCursor()
            import documentinfo
            m = documentinfo.music(d)
            import ly.duration
            if c.hasSelection():
                cursortools.strip_selection(c)
                length = m.time_length(c.selectionStart(), c.selectionEnd())
                text = _("Length: {length}").format(
                    length=ly.duration.format_fraction(length)) if length is not None else ''
            else:
                pos = m.time_position(c.position())
                text = _("Pos: {pos}").format(
                    pos=ly.duration.format_fraction(pos)) if pos is not None else ''
            self._label.setText(text)


app.viewSpaceCreated.connect(MusicPosition.instance)


########NEW FILE########
__FILENAME__ = musicpreview
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A widget and dialog to show an output preview of a LilyPond document.
"""

from __future__ import unicode_literals


import os
import glob
import shutil

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import ly.document
import ly.docinfo

import app
import icons
import job
import log
import util
import qutil
import lilypondinfo
import popplerview
import popplertools
import widgets.progressbar


class MusicPreviewJob(job.Job):
    def __init__(self, text, title=None):
        super(MusicPreviewJob, self).__init__()
        self.directory = util.tempdir()
        self.document = os.path.join(self.directory, 'document.ly')
        with open(self.document, 'w') as f:
            f.write(text.encode('utf-8'))
            
        info = lilypondinfo.preferred()
        if QSettings().value("lilypond_settings/autoversion", True, bool):
            version = ly.docinfo.DocInfo(ly.document.Document(text, 'lilypond')).version()
            if version:
                info = lilypondinfo.suitable(version)
        
        lilypond = info.abscommand() or info.command
        self.command = [lilypond, '-dno-point-and-click', '--pdf', self.document]
        if title:
            self.setTitle(title)
    
    def resultfiles(self):
        return glob.glob(os.path.join(self.directory, '*.pdf'))
        
    def cleanup(self):
        shutil.rmtree(self.directory, ignore_errors=True)


class MusicPreviewWidget(QWidget):
    def __init__(self, parent=None):
        super(MusicPreviewWidget, self).__init__(parent)
        self._lastbuildtime = 10.0
        self._running = None
        self._current = None
        
        self._chooserLabel = QLabel()
        self._chooser = QComboBox(self, activated=self.selectDocument)
        self._log = log.Log()
        self._view = popplerview.View()
        self._progress = widgets.progressbar.TimedProgressBar()
        
        self._stack = QStackedLayout()
        self._top = QWidget()
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        layout.addWidget(self._top)
        layout.addLayout(self._stack)
        layout.addWidget(self._progress)
        
        top = QHBoxLayout()
        top.setContentsMargins(0, 0, 0, 0)
        top.setSpacing(2)
        self._top.setLayout(top)
        top.addWidget(self._chooserLabel)
        top.addWidget(self._chooser)
        top.addStretch(1)
        
        self._stack.addWidget(self._log)
        self._stack.addWidget(self._view)
        
        self._top.hide()
        app.aboutToQuit.connect(self.cleanup)
        app.translateUI(self)
    
    def translateUI(self):
        self._chooserLabel.setText(_("Document:"))
        
    def preview(self, text, title=None):
        """Runs LilyPond on the given text and shows the resulting PDF."""
        j = self._running = MusicPreviewJob(text, title)
        j.done.connect(self._done)
        self._log.clear()
        self._log.connectJob(j)
        j.start()
        self._progress.start(self._lastbuildtime)
    
    def _done(self, success):
        self._progress.stop(False)
        pdfs = self._running.resultfiles()
        self.setDocuments(pdfs)
        if not pdfs:
            self._stack.setCurrentWidget(self._log)
            return
        self._lastbuildtime = self._running.elapsed()
        self._stack.setCurrentWidget(self._view)
        if self._current:
            self._current.cleanup()
        self._current = self._running # keep the tempdir
        self._running = None
        
    def setDocuments(self, pdfs):
        """Loads the given PDF path names in the UI."""
        self._documents = [popplertools.Document(name) for name in pdfs]
        self._chooser.clear()
        self._chooser.addItems([d.name() for d in self._documents])
        self._top.setVisible(len(self._documents) > 1)
        if pdfs:
            self._chooser.setCurrentIndex(0)
            self.selectDocument(0)
        else:
            self._view.clear()

    def selectDocument(self, index):
        doc = self._documents[index].document()
        if doc:
            self._view.load(doc)

    def cleanup(self):
        if self._running:
            self._running.abort()
            self._running.cleanup()
            self._running = None
        if self._current:
            self._current.cleanup()
            self._current = None
        self._stack.setCurrentWidget(self._log)
        self._top.hide()
        self._view.clear()
    
    def print_(self):
        """Prints the currently displayed document."""
        if self._documents:
            doc = self._documents[self._chooser.currentIndex()]
            import popplerprint
            popplerprint.printDocument(doc, self)


class MusicPreviewDialog(QDialog):
    def __init__(self, parent=None):
        super(MusicPreviewDialog, self).__init__(parent)
        layout = QVBoxLayout()
        self.setLayout(layout)
        self._widget = MusicPreviewWidget()
        layout.addWidget(self._widget)
        layout.addWidget(widgets.Separator())
        b = QDialogButtonBox()
        layout.addWidget(b)
        b.addButton(QDialogButtonBox.Close)
        b.rejected.connect(self.accept)
        self._printButton = b.addButton('', QDialogButtonBox.ActionRole)
        self._printButton.setIcon(icons.get("document-print"))
        self._printButton.clicked.connect(self._widget.print_)
        self._printButton.hide()
        qutil.saveDialogSize(self, "musicpreview/dialog/size", QSize(500, 350))
        app.translateUI(self)
    
    def translateUI(self):
        self._printButton.setText(_("&Print"))
        self.setWindowTitle(app.caption(_("Music Preview")))
        
    def preview(self, text, title=None):
        self._widget.preview(text, title)

    def cleanup(self):
        self._widget.cleanup()

    def setEnablePrintButton(self, enable):
        """Enables or disables the print button."""
        self._printButton.setVisible(enable)



########NEW FILE########
__FILENAME__ = contextmenu
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The PDF preview panel context menu.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *


import icons


def show(position, panel, link, cursor):
    """Shows a context menu.
    
    position: The global position to pop up
    panel: The music view panel, giving access to mainwindow and view widget
    link: a popplerqt4 LinkBrowse instance or None
    cursor: a QTextCursor instance or None
    
    """
    m = QMenu(panel)
    
    # selection? -> Copy
    if panel.widget().view.surface().hasSelection():
        m.addAction(panel.actionCollection.music_copy_image)
    
    if cursor:
        a = m.addAction(icons.get("document-edit"), _("Edit in Place"))
        @a.triggered.connect
        def edit():
            from . import editinplace
            editinplace.edit(panel.widget(), cursor, position)
    elif link:
        a = m.addAction(icons.get("window-new"), _("Open Link in &New Window"))
        @a.triggered.connect
        def open_in_browser():
            import helpers
            helpers.openUrl(QUrl(link.url()))
        
        a = m.addAction(icons.get("edit-copy"), _("Copy &Link"))
        @a.triggered.connect
        def copy_link():
            QApplication.clipboard().setText(link.url())

    # no actions yet? insert Fit Width/Height
    if not m.actions():
        m.addAction(panel.actionCollection.music_fit_width)
        m.addAction(panel.actionCollection.music_fit_height)
        m.addAction(panel.actionCollection.music_zoom_original)
        m.addSeparator()
        m.addAction(panel.actionCollection.music_sync_cursor)
    
    # help
    m.addSeparator()
    a = m.addAction(icons.get("help-contents"), _("Help"))
    @a.triggered.connect
    def help():
        import userguide
        userguide.show("musicview")
    
    # show it!
    if m.actions():
        m.exec_(position)
    m.deleteLater()




########NEW FILE########
__FILENAME__ = documents
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Code to load and manage PDF documents to view.
"""

from __future__ import unicode_literals


import os
import weakref

from PyQt4.QtCore import QByteArray, QSettings

try:
    import popplerqt4
except ImportError:
    popplerqt4 = None

import app
import plugin
import resultfiles
import signals
import popplertools


_cache = weakref.WeakValueDictionary()


# This signal gets emitted when a finished Job has created new PDF document(s).
documentUpdated = signals.Signal() # Document


@app.jobFinished.connect
def _on_job_finished(document, job):
    if group(document).update():
        documentUpdated(document, job)


def group(document):
    """Returns a DocumentGroup instance for the given text document."""
    return DocumentGroup.instance(document)


def load(filename):
    """Returns a Poppler.Document for the given filename, caching it (weakly).
    
    Returns None if the document failed to load.
    
    """
    mtime = os.path.getmtime(filename)
    key = (mtime, filename)
    
    try:
        return _cache[key]
    except KeyError:
        with open(filename, 'rb') as f:
            data = QByteArray(f.read())
        doc = popplerqt4.Poppler.Document.loadFromData(data)
        if doc:
            _cache[key] = doc
        return doc or None


def filename(poppler_document):
    """Returns the filename for the document if it was loaded via our cache."""
    for (mtime, filename), doc in _cache.items():
        if doc == poppler_document:
            return filename


class Document(popplertools.Document):
    """Represents a (lazily) loaded PDF document."""
    updated = True
    
    def load(self):
        return load(self.filename())
        
    if popplerqt4 is None:
        def document(self):
            """Returns None because popplerqt4 is not available."""
            return None


class DocumentGroup(plugin.DocumentPlugin):
    """Represents a group of PDF documents, created by the text document it belongs to.
    
    Multiple MusicView instances can use this group, they can store the positions
    of the Documents in the viewer themselves via a weak-key dictionary on the Document
    instances returned by documents(). On update() these Document instances will be reused.
    
    The global documentUpdated(Document) signal will be emitted when the global
    app.jobFinished() signal causes a reload of documents in a group.
    
    """
    def __init__(self, document):
        self._documents = None
        document.loaded.connect(self.update, -100)
        
    def documents(self):
        """Returns the list of PDF Document objects created by our text document."""
        # If the list is asked for the very first time, update
        if self._documents is None:
            self._documents = []
            self.update()
        return self._documents[:]
    
    def update(self, newer=None):
        """Queries the resultfiles of this text document for PDF files and loads them.
        
        Returns True if new documents were loaded.
        If newer is True, only PDF files newer than the source document are returned.
        If newer is False, all PDF files are returned.
        If newer is None (default), the setting from the configuration is used.
        
        """
        if newer is None:
            newer = QSettings().value("musicview/newer_files_only", True, bool)
        
        results = resultfiles.results(self.document())
        files = results.files(".pdf", newer)
        if files:
            # reuse the older Document objects, they will probably be displaying
            # (about) the same documents, and so the viewer will remember their position.
            def docs():
                # yield existing docs and then new ones
                if self._documents:
                    for d in self._documents:
                        yield d
                while True:
                    yield Document()
            documents = []
            for filename, doc in zip(files, docs()):
                doc.setFilename(filename)
                doc.updated = newer or results.is_newer(filename)
                documents.append(doc)
            self._documents = documents
            return True



########NEW FILE########
__FILENAME__ = editinplace
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Music View's Edit in Place dialog.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import actioncollectionmanager
import autocomplete.analyzer
import autocomplete.completer
import cursordiff
import cursortools
import userguide
import highlighter
import homekey
import indent
import matcher
import metainfo
import qutil
import textformats
import tokeniter
import widgets.dialog

from . import tooltip


def edit(parent, cursor, position=None):
    dlg = Dialog(parent)
    dlg.finished.connect(dlg.deleteLater)
    dlg.edit(cursor)
    dlg.popup(position)


class Dialog(widgets.dialog.Dialog):
    """Dialog containing a short text edit field to edit one line."""
    def __init__(self, parent=None):
        super(Dialog, self).__init__(parent)
        self._document = None
        self.messageLabel().setWordWrap(True)
        self.document = d = QTextDocument()
        d.setDocumentLayout(QPlainTextDocumentLayout(d))
        self.highlighter = highlighter.highlighter(d)
        self.view = View(d)
        self.matcher = Matcher(self.view)
        self.completer = Completer(self.view)
        self.setMainWidget(self.view)
        userguide.addButton(self.buttonBox(), "musicview_editinplace")
        # action for completion popup
        self._showPopupAction = QAction(None, triggered=self.slotCompletionPopup)
        self.addAction(self._showPopupAction)
        # make Ctrl+Return accept the dialog
        self.button("ok").setShortcut(QKeySequence("Ctrl+Return"))
        qutil.saveDialogSize(self, "musicview/editinplace/dialog/size")
        
        self.accepted.connect(self.save)
        app.translateUI(self)
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
        
    def translateUI(self):
        self.setWindowTitle(app.caption(_("Edit in Place")))
        self.updateMessage()
    
    def readSettings(self):
        self._showPopupAction.setShortcut(
            actioncollectionmanager.action("autocomplete", "popup_completions").shortcut())
        
    def edit(self, cursor):
        """Edit the block at the specified QTextCursor."""
        if self._document:
            self._document.closed.disconnect(self.reject)
        self._document = cursor.document()
        self._document.closed.connect(self.reject)
        
        # dont change the cursor
        c = self._range = QTextCursor(cursor)
        cursorpos = c.position() - c.block().position()
        cursortools.strip_indent(c)
        indentpos = c.position() - c.block().position()
        c.movePosition(QTextCursor.EndOfBlock, QTextCursor.KeepAnchor)
        self.view.setPlainText(c.selection().toPlainText())
        
        self.highlighter.setInitialState(tokeniter.state(cursortools.block(cursor)))
        self.highlighter.setHighlighting(metainfo.info(cursor.document()).highlighting)
        self.highlighter.rehighlight()
        
        # let autocomplete query the real document as if we're at the start
        # of the current block
        self.completer.document_cursor = QTextCursor(cursor.block())
        self.completer.autoComplete = QSettings().value(
                        "autocomplete", True) not in ('false', False)
        
        cursor = self.view.textCursor()
        cursor.setPosition(max(0, cursorpos-indentpos))
        self.view.setTextCursor(cursor)
        
        self.updateMessage()
        
    def popup(self, position):
        """Show the dialog at the specified global QPoint."""
        geom = self.geometry()
        geom.moveCenter(position)
        if position.y() <= geom.height() + 60:
            geom.moveTop(position.y() + 60)
        else:
            geom.moveBottom(position.y() - 60)
        self.setGeometry(geom)
        self.view.setFocus()
        self.show()
    
    def save(self):
        """Called to perform the edits in the document."""
        cursor = QTextCursor(self._range)
        start = cursor.selectionStart()
        # use cursordiff; dont destroy point and click positions
        cursordiff.insert_text(cursor, self.view.toPlainText())
        cursor.setPosition(start, QTextCursor.KeepAnchor)
        with cursortools.compress_undo(cursor, True):
            # re-indent the inserted line(s)
            indent.re_indent(cursor)
        
    def updateMessage(self):
        """Called when a new cursor is set to edit, updates the message text."""
        if self._document:
            self.setMessage(
              _("Editing line {linenum} of \"{document}\" ({variable})").format(
                linenum = self._range.block().blockNumber() + 1,
                document = self._document.documentName(),
                variable = tooltip.get_definition(self._range) or _("<unknown>"),
            ))
        else:
            self.setMessage("<no document set>") # should never appear
    
    def slotCompletionPopup(self):
        self.completer.showCompletionPopup()


class View(QPlainTextEdit):
    """The text edit in the "Edit in Place" dialog."""
    def __init__(self, document):
        super(View, self).__init__()
        self.setDocument(document)
        self.setLineWrapMode(QPlainTextEdit.NoWrap)
        self.setCursorWidth(2)
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
    
    def readSettings(self):
        data = textformats.formatData('editor')
        self.setFont(data.font)
        self.setPalette(data.palette())
    
    def sizeHint(self):
        metrics = self.fontMetrics()
        return QSize(80 * metrics.width(" "),3 * metrics.height())
    
    def event(self, ev):
        """Reimplemented to avoid typing the line separator."""
        if ev == QKeySequence.InsertLineSeparator:
            return False
        return super(View, self).event(ev)


class Matcher(matcher.AbstractMatcher):
    """Looks for matches if the cursor moves."""
    def __init__(self, view):
        super(Matcher, self).__init__(view)
        self._highlighter = MatchHighlighter(view)
    
    def highlighter(self):
        return self._highlighter


class MatchHighlighter(widgets.arbitraryhighlighter.ArbitraryHighlighter):
    """Highlights the matches like { } or << >>."""
    def __init__(self, edit):
        super(MatchHighlighter, self).__init__(edit)
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
    
    def readSettings(self):
        self._baseColors = textformats.formatData('editor').baseColors
        self.reload()
    
    def textFormat(self, name):
        f = QTextCharFormat()
        f.setBackground(self._baseColors[name])
        return f


class Completer(autocomplete.completer.Completer):
    """A Completer providing completions for the Edit in Place popup.
    
    It can request information from the document specified by the
    document_cursor which can be set as an instance attribute.
    
    """
    document_cursor = None
    def __init__(self, view):
        super(Completer, self).__init__()
        self.setWidget(view)
    
    def analyzer(self):
        return Analyzer(self.document_cursor)


class Analyzer(autocomplete.analyzer.Analyzer):
    """An Analyzer looking at the line of text in the Edit in Place popup.
    
    It takes the document_cursor attribute on init from the Completer,
    so that the document the Edit in Place popup belongs to can be queried
    for information like defined variables, etc.
    
    """
    def __init__(self, cursor):
        self._document_cursor = cursor
    
    def document_cursor(self):
        """Reimplemented to return the cursor of the real document."""
        return self._document_cursor




########NEW FILE########
__FILENAME__ = image
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Dialog to copy contents from PDF to a raster image.
"""

from __future__ import unicode_literals

import collections
import os
import tempfile

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import util
import qutil
import icons
import qpopplerview
import widgets.imageviewer
import widgets.colorbutton
import widgets.drag

try:
    import popplerqt4
except ImportError:
    popplerqt4 = None

from . import documents


def copy(musicviewpanel):
    """Shows the dialog."""
    view = musicviewpanel.widget().view
    selection = view.surface().selection()
    
    # get the largest page part that is in the selection
    pages = list(view.surface().pageLayout().pagesAt(selection))
    if not pages:
        return
        
    def key(page):
        size = page.rect().intersected(selection).size()
        return size.width() + size.height()
    page = max(pages, key = key)
    dlg = Dialog(musicviewpanel)
    dlg.show()
    dlg.setPage(page, selection)
    dlg.finished.connect(dlg.deleteLater)



class Dialog(QDialog):
    def __init__(self, parent=None):
        super(Dialog, self).__init__(parent)
        self._filename = None
        self._page = None
        self._rect = None
        self.imageViewer = widgets.imageviewer.ImageViewer()
        self.dpiLabel = QLabel()
        self.dpiCombo = QComboBox(insertPolicy=QComboBox.NoInsert, editable=True)
        self.dpiCombo.lineEdit().setCompleter(None)
        self.dpiCombo.setValidator(QDoubleValidator(10.0, 1200.0, 4, self.dpiCombo))
        self.dpiCombo.addItems([format(i) for i in 72, 100, 200, 300, 600, 1200])
        
        self.colorButton = widgets.colorbutton.ColorButton()
        self.colorButton.setColor(QColor(Qt.white))
        self.crop = QCheckBox()
        self.antialias = QCheckBox(checked=True)
        self.dragfile = QPushButton(icons.get("image-x-generic"), None, None)
        self.fileDragger = FileDragger(self.dragfile)
        self.buttons = QDialogButtonBox(QDialogButtonBox.Close)
        self.copyButton = self.buttons.addButton('', QDialogButtonBox.ApplyRole)
        self.copyButton.setIcon(icons.get('edit-copy'))
        self.saveButton = self.buttons.addButton('', QDialogButtonBox.ApplyRole)
        self.saveButton.setIcon(icons.get('document-save'))
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        layout.addWidget(self.imageViewer)
        
        controls = QHBoxLayout()
        layout.addLayout(controls)
        controls.addWidget(self.dpiLabel)
        controls.addWidget(self.dpiCombo)
        controls.addWidget(self.colorButton)
        controls.addWidget(self.crop)
        controls.addWidget(self.antialias)
        controls.addStretch()
        controls.addWidget(self.dragfile)
        layout.addWidget(widgets.Separator())
        layout.addWidget(self.buttons)

        app.translateUI(self)
        self.readSettings()
        self.finished.connect(self.writeSettings)
        self.dpiCombo.editTextChanged.connect(self.drawImage)
        self.colorButton.colorChanged.connect(self.drawImage)
        self.antialias.toggled.connect(self.drawImage)
        self.crop.toggled.connect(self.cropImage)
        self.buttons.rejected.connect(self.reject)
        self.copyButton.clicked.connect(self.copyToClipboard)
        self.saveButton.clicked.connect(self.saveAs)
        qutil.saveDialogSize(self, "copy_image/dialog/size", QSize(480, 320))
    
    def translateUI(self):
        self.setCaption()
        self.dpiLabel.setText(_("DPI:"))
        self.colorButton.setToolTip(_("Paper Color"))
        self.crop.setText(_("Auto-crop"))
        self.antialias.setText(_("Antialias"))
        self.dragfile.setText(_("Drag"))
        self.dragfile.setToolTip(_("Drag the image as a PNG file."))
        self.copyButton.setText(_("&Copy to Clipboard"))
        self.saveButton.setText(_("&Save As..."))
        self.imageViewer.setWhatsThis(_(
            #xgettext:no-python-format
            "<p>\n"
            "Clicking toggles the display between 100% size and window size. "
            "Drag to copy the image to another application. "
            "Drag with Ctrl (or {command}) to scroll a large image.\n"
            "</p>\n"
            "<p>\n"
            "You can also drag the small picture icon in the bottom right, "
            "which drags the actual file on disk, e.g. to an e-mail message.\n"
            "</p>").format(command="\u2318"))
        
    def readSettings(self):
        s = QSettings()
        s.beginGroup('copy_image')
        self.dpiCombo.setEditText(s.value("dpi", "100", type("")))
        self.colorButton.setColor(s.value("papercolor", QColor(Qt.white), QColor))
        self.crop.setChecked(s.value("autocrop", False, bool))
        self.antialias.setChecked(s.value("antialias", True, bool))
    
    def writeSettings(self):
        s = QSettings()
        s.beginGroup('copy_image')
        s.setValue("dpi", self.dpiCombo.currentText())
        s.setValue("papercolor", self.colorButton.color())
        s.setValue("autocrop", self.crop.isChecked())
        s.setValue("antialias", self.antialias.isChecked())
    
    def setCaption(self):
        if self._filename:
            filename = os.path.basename(self._filename)
        else:
            filename = _("<unknown>")
        title = _("Image from {filename}").format(filename = filename)
        self.setWindowTitle(app.caption(title))
        
    def setPage(self, page, rect):
        self._page = page
        self._rect = rect
        self._filename = documents.filename(page.document())
        self.fileDragger.basename = os.path.splitext(os.path.basename(self._filename))[0]
        self.setCaption()
        self.drawImage()

    def drawImage(self):
        dpi = float(self.dpiCombo.currentText() or '100')
        dpi = max(dpi, self.dpiCombo.validator().bottom())
        dpi = min(dpi, self.dpiCombo.validator().top())
        options = qpopplerview.RenderOptions()
        options.setPaperColor(self.colorButton.color())
        if self.antialias.isChecked():
            if popplerqt4:
                options.setRenderHint(
                    popplerqt4.Poppler.Document.Antialiasing |
                    popplerqt4.Poppler.Document.TextAntialiasing)
        else:
            options.setRenderHint(0)
        self._image = self._page.image(self._rect, dpi, dpi, options)
        self.cropImage()
    
    def cropImage(self):
        image = self._image
        if self.crop.isChecked():
            image = image.copy(autoCropRect(image))
        self.imageViewer.setImage(image)
        self.fileDragger.setImage(image)
    
    def copyToClipboard(self):
        QApplication.clipboard().setImage(self.imageViewer.image())

    def saveAs(self):
        if self._filename and not self.imageViewer.image().isNull():
            filename = os.path.splitext(self._filename)[0] + ".png"
        else:
            filename = 'image.png'
        filename = QFileDialog.getSaveFileName(self,
            _("Save Image As"), filename)
        if filename:
            if not self.imageViewer.image().save(filename):
                QMessageBox.critical(self, _("Error"), _(
                    "Could not save the image."))
            else:
                self.fileDragger.currentFile = filename


class FileDragger(widgets.drag.FileDragger):
    """Creates an image file on the fly as soon as a drag is started."""
    image = None
    basename = None
    currentFile = None
    
    def setImage(self, image):
        self.image = image
        self.currentFile = None
        
    def filename(self):
        if self.currentFile:
            return self.currentFile
        elif not self.image:
            return
        # save the image as a PNG file
        d = util.tempdir()
        basename = self.basename or 'image'
        basename += '.png'
        filename = os.path.join(d, basename)
        self.image.save(filename)
        self.currentFile = filename
        return filename


def autoCropRect(image):
    """Returns a QRect specifying the contents of the QImage.
    
    Edges of the image are trimmed if they have the same color.
    
    """
    # pick the color at most of the corners
    colors = collections.defaultdict(int)
    w, h = image.width(), image.height()
    for x, y in (0, 0), (w - 1, 0), (w - 1, h - 1), (0, h - 1):
        colors[image.pixel(x, y)] += 1
    most = max(colors, key=colors.get)
    # let Qt do the masking work
    mask = image.createMaskFromColor(most)
    return QRegion(QBitmap.fromImage(mask)).boundingRect()



########NEW FILE########
__FILENAME__ = pointandclick
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Handles Point and Click.
"""

from __future__ import unicode_literals
from __future__ import absolute_import

import re
import os
import sys
import weakref

import qpopplerview

import util
import textedit
import pointandclick


# cache point and click handlers for poppler documents
_cache = weakref.WeakKeyDictionary()


def links(document):
    try:
        return _cache[document]
    except KeyError:
        l = _cache[document] = Links()
        with l:
            import popplerqt4
            with qpopplerview.lock(document):
                for num in range(document.numPages()):
                    page = document.page(num)
                    for link in page.links():
                        if isinstance(link, popplerqt4.Poppler.LinkBrowse):
                            t = textedit.link(link.url())
                            if t:
                                l.add_link(t.filename, t.line, t.column, (num, link.linkArea()))
        return l


class Links(pointandclick.Links):
    """Stores all the links of a Poppler document sorted by URL and text position.
    
    Only textedit:// urls are stored.
    
    """
    def cursor(self, link, load=False):
        """Returns the destination of a link as a QTextCursor of the destination document.
        
        If load (defaulting to False) is True, the document is loaded if it is not yet loaded.
        Returns None if the url was not valid or the document could not be loaded.
        
        """
        import popplerqt4
        if not isinstance(link, popplerqt4.Poppler.LinkBrowse) or not link.url():
            return
        t = textedit.link(link.url())
        if t:
            return super(Links, self).cursor(t.filename, t.line, t.column, load)


positions = pointandclick.positions



########NEW FILE########
__FILENAME__ = tooltip
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Generate meaningful tooltips for cursor positions.
"""

from __future__ import unicode_literals

import tokeniter
import ly.lex.lilypond


def text(cursor):
    filename = cursor.document().documentName()
    line = cursor.blockNumber() + 1
    column = cursor.position() - cursor.block().position()
    text = "{0} ({1}:{2})".format(filename, line, column)
    definition = get_definition(cursor)
    if definition:
        text += '\n' + definition
    time_pos = time_position(cursor)
    if time_pos:
        text += '\n' + _("Position: {pos}").format(pos=time_pos)
    return text

def get_definition(cursor):
    block = cursor.block()
    while block.isValid():
        state = tokeniter.state(block)
        if isinstance(state.parser(), ly.lex.lilypond.ParseGlobal):
            for t in tokeniter.tokens(block)[:2]:
                if type(t) is ly.lex.lilypond.Name:
                    return t[:]
                elif isinstance(t, ly.lex.lilypond.Keyword) and t == '\\score':
                    return '\\score'
        block = block.previous()

def time_position(cursor):
    import documentinfo
    pos = documentinfo.music(cursor.document()).time_position(cursor.position())
    if pos is not None:
        import ly.duration
        return ly.duration.format_fraction(pos)



########NEW FILE########
__FILENAME__ = widget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The PDF preview panel widget.
"""

from __future__ import unicode_literals

import itertools
import os
import weakref

from PyQt4.QtCore import *
from PyQt4.QtGui import *

try:
    import popplerqt4
except ImportError:
    pass

import qpopplerview
import popplerview

import app
import icons
import helpers
import textedit
import textformats
import lydocument
import viewhighlighter
import ly.lex.lilypond

from . import pointandclick


class MusicView(QWidget):
    """Widget containing the qpopplerview.View."""
    
    zoomChanged = pyqtSignal(int, float) # mode, scale
    
    def __init__(self, dockwidget):
        """Creates the Music View for the dockwidget."""
        super(MusicView, self).__init__(dockwidget)
        
        self._positions = weakref.WeakKeyDictionary()
        self._currentDocument = None
        self._links = None
        self._clicking_link = False
        
        self._highlightFormat = QTextCharFormat()
        self._highlightMusicFormat = Highlighter()
        self._highlightRange = None
        self._highlightTimer = QTimer(singleShot=True, interval= 250, timeout=self.updateHighlighting)
        self._highlightRemoveTimer = QTimer(singleShot=True, timeout=self.clearHighlighting)
        
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)
        
        self.view = popplerview.View(self)
        layout.addWidget(self.view)
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
        self.view.setViewMode(qpopplerview.FitWidth)
        self.view.surface().linkClicked.connect(self.slotLinkClicked)
        self.view.surface().linkHovered.connect(self.slotLinkHovered)
        self.view.surface().linkLeft.connect(self.slotLinkLeft)
        self.view.surface().setShowUrlTips(False)
        self.view.surface().linkHelpRequested.connect(self.slotLinkHelpRequested)
        
        self.view.viewModeChanged.connect(self.updateZoomInfo)
        self.view.surface().pageLayout().scaleChanged.connect(self.updateZoomInfo)
        self.view.setContextMenuPolicy(Qt.CustomContextMenu)
        self.view.customContextMenuRequested.connect(self.showContextMenu)
        
        # react if cursor of current text document moves
        dockwidget.mainwindow().currentViewChanged.connect(self.slotCurrentViewChanged)
        view = dockwidget.mainwindow().currentView()
        if view:
            self.slotCurrentViewChanged(view)
    
    def sizeHint(self):
        """Returns the initial size the PDF (Music) View prefers."""
        return self.parent().mainwindow().size() / 2
    
    def updateZoomInfo(self):
        """Called when zoom and viewmode of the qpopplerview change, emit zoomChanged."""
        self.zoomChanged.emit(self.view.viewMode(), self.view.surface().pageLayout().scale())
    
    def openDocument(self, doc):
        """Opens a documents.Document instance."""
        self.clear()
        self._currentDocument = doc
        document = doc.document()
        if document:
            self._links = pointandclick.links(document)
            self.view.load(document)
            position = self._positions.get(doc, (0, 0, 0))
            self.view.setPosition(position, True)

    def clear(self):
        """Empties the view."""
        cur = self._currentDocument
        if cur:
            self._positions[cur] = self.view.position()
        self._currentDocument = None
        self._links = None
        self._highlightRange = None
        self._highlightTimer.stop()
        self.view.clear()
        
    def readSettings(self):
        """Reads the settings from the user's preferences."""
        # background and highlight colors of music view
        colors = textformats.formatData('editor').baseColors
        self._highlightMusicFormat.setColor(colors['musichighlight'])
        color = colors['selectionbackground']
        color.setAlpha(128)
        self._highlightFormat.setBackground(color)

    def slotLinkClicked(self, ev, page, link):
        """Called when the use clicks a link.
        
        If the links is a textedit link, opens the document and puts the cursor there.
        Otherwise, call the helpers module to open the destination.
        
        """
        if ev.button() == Qt.RightButton:
            return
        cursor = self._links.cursor(link, True)
        if cursor:
            if ev.modifiers() & Qt.ShiftModifier:
                from . import editinplace
                editinplace.edit(self, cursor, ev.globalPos())
            else:
                mainwindow = self.parent().mainwindow()
                self._clicking_link = True
                mainwindow.setTextCursor(cursor, findOpenView=True)
                self._clicking_link = False
                import widgets.blink
                widgets.blink.Blinker.blink_cursor(mainwindow.currentView())
                mainwindow.activateWindow()
                mainwindow.currentView().setFocus()
        elif (isinstance(link, popplerqt4.Poppler.LinkBrowse)
              and not link.url().startswith('textedit:')):
            helpers.openUrl(QUrl(link.url()))

    def slotLinkHovered(self, page, link):
        """Called when the mouse hovers a link.
        
        If the links points to the current editor document, the token(s) it points
        at are highlighted using a transparent selection color.
        
        The highlight shows for a few seconds but disappears when the mouse moves
        off the link or when the link is clicked.
        
        """
        self.view.surface().highlight(self._highlightMusicFormat,
            [(page, link.linkArea().normalized())], 2000)
        self._highlightRange = None
        cursor = self._links.cursor(link)
        if not cursor or cursor.document() != self.parent().mainwindow().currentDocument():
            return
        
        # highlight token(s) at this cursor
        cursors = pointandclick.positions(cursor)
        if cursors:
            view = self.parent().mainwindow().currentView()
            viewhighlighter.highlighter(view).highlight(self._highlightFormat, cursors, 2, 5000)
    
    def slotLinkLeft(self):
        """Called when the mouse moves off a previously highlighted link."""
        self.clearHighlighting()
        view = self.parent().mainwindow().currentView()
        viewhighlighter.highlighter(view).clear(self._highlightFormat)

    def slotLinkHelpRequested(self, pos, page, link):
        """Called when a ToolTip wants to appear above the hovered link."""
        if isinstance(link, popplerqt4.Poppler.LinkBrowse):
            cursor = self._links.cursor(link)
            if cursor:
                from . import tooltip
                text = tooltip.text(cursor)
            elif link.url():
                l = textedit.link(link.url())
                if l:
                    text = "{0} ({1}:{2})".format(os.path.basename(l.filename), l.line, l.column)
                else:
                    text = link.url()
            QToolTip.showText(pos, text, self.view.surface(), page.linkRect(link.linkArea()))

    def slotCurrentViewChanged(self, view, old=None):
        self.view.surface().clearHighlight(self._highlightMusicFormat)
        if old:
            old.cursorPositionChanged.disconnect(self.slotCursorPositionChanged)
        view.cursorPositionChanged.connect(self.slotCursorPositionChanged)
    
    def slotCursorPositionChanged(self):
        """Called when the user moves the text cursor."""
        if not self.isVisible() or not self._links:
            return # not visible of no PDF in the viewer
        
        view = self.parent().mainwindow().currentView()
        links = self._links.boundLinks(view.document())
        if not links:
            return # the PDF contains no references to the current text document
        
        s = links.indices(view.textCursor())
        if s is False:
            self.clearHighlighting()
        elif s:
            # move if sync is enabled and the cursor did not move as a result of
            # clicking a link
            if (not self._clicking_link
                and self.parent().actionCollection.music_sync_cursor.isChecked()):
                rect = self.destinationsRect(links.destinations()[s])
                center = rect.center()
                self.view.ensureVisible(center.x(), center.y(), 50+rect.width()/2, 50+rect.height()/2)
            
            # perform highlighting after move has been started. This is to ensure that if kinetic scrolling is
            # is enabled its speed is already set so that we can adjust the highlight timer.
            self.highlight(links.destinations(), s)


    def highlight(self, destinations, slice, msec=None):
        """(Internal) Highlights the from the specified destinations the specified slice."""
        count = slice.stop - slice.start
        if msec is None:
            # RC: increased timer to give some time to the kinetic scrolling to complete.
            kineticTimeLeft = 0
            if self.view.kineticScrollingEnabled():
                kineticTimeLeft = 20*self.view.kineticTicksLeft() 
            msec = 5000 if count > 1 else 2000 # show selections longer
            msec += kineticTimeLeft
        self._highlightRemoveTimer.start(msec)
        if self._highlightRange == slice:
            return # don't redraw if same
        self._highlightRange = slice
        self._destinations = destinations[slice]
        if count > 100:
            self._highlightTimer.start()
        else:
            self._highlightTimer.stop()
            self.updateHighlighting()
    
    def updateHighlighting(self):
        """Really orders the view's surface to draw the highlighting."""
        layout = self.view.surface().pageLayout()
        areas = [(layout[pageNum], rect)
                    for dest in self._destinations
                    for pageNum, rect in dest]
        self.view.surface().highlight(self._highlightMusicFormat, areas)
    
    def clearHighlighting(self):
        """Called on timeout of the _highlightRemoveTimer."""
        self._highlightRange = None
        self.view.surface().clearHighlight(self._highlightMusicFormat)

    def showCurrentLinks(self):
        """Scrolls the view if necessary to show objects at current text cursor."""
        if not self._links:
            return # no PDF in viewer
            
        view = self.parent().mainwindow().currentView()
        links = self._links.boundLinks(view.document())
        if not links:
            return # the PDF contains no references to the current text document
        
        s = links.indices(view.textCursor())
        if not s:
            return
        self.view.center(self.destinationsRect(links.destinations()[s]).center())
        self.highlight(links.destinations(), s, 10000)
    
    def destinationsRect(self, destinations):
        """Return the rectangle containing all destinations."""
        layout = self.view.surface().pageLayout()
        rect = QRect()
        for dest in destinations:
            for pageNum, r in dest:
                rect = rect.united(layout[pageNum].linkRect(r.normalized()))
        # not larger than viewport
        rect.setSize(rect.size().boundedTo(self.view.viewport().size()))
        return rect
    
    def showContextMenu(self):
        """Called when the user right-clicks or presses the context menu key."""
        pos = self.view.mapToGlobal(QPoint(0, 0))
        link, cursor = None, None
        # mouse inside view?
        if self.view.mapFromGlobal(QCursor.pos()) in self.view.viewport().rect():
            pos = QCursor.pos()
            pos_in_surface = self.view.surface().mapFromGlobal(pos)
            page, link = self.view.surface().pageLayout().linkAt(pos_in_surface)
            if link:
                cursor = self._links.cursor(link, True)
        from . import contextmenu
        contextmenu.show(pos, self.parent(), link, cursor)


class Highlighter(qpopplerview.Highlighter):
    """Simple version of qpopplerview.Highlighter that has the color settable.
    
    You must set a color before using the Highlighter.
    
    """
    def setColor(self, color):
        """Sets the color to use to draw highlighting rectangles."""
        self._color = color
    
    def color(self):
        """Returns the color set using the setColor method."""
        return self._color



########NEW FILE########
__FILENAME__ = networkaccessmanager
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A QNetworkAccessManager subclass with easy registration of custom url schemes.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QThread, QTimer, QUrl
from PyQt4.QtNetwork import QNetworkAccessManager, QNetworkReply, QNetworkRequest


class NetworkAccessManager(QNetworkAccessManager):
    """A QNetworkAccessManager subclass with easy registration of custom url schemes.
    
    Use the registerHandler() method to add custom scheme handlers.
    The registerHtmlHandler() method is used to add a simple callable as handler that
    gets a QUrl and should return the HTML as a normal string.
    
    The headers instance attribute is a dictionary (empty by default) containing
    extra headers (as key, value) that are added to outgoing requests.
    
    """
    
    def __init__(self, parent=None):
        QNetworkAccessManager.__init__(self, parent)
        self._dispatcher = {}
        self.headers = {}
        
    def createRequest(self, operation, request, data):
        try:
            requestFunc = self._dispatcher[request.url().scheme()]
        except KeyError:
            self.addHeadersToRequest(request)
            return QNetworkAccessManager.createRequest(self, operation, request, data)
        return requestFunc(self, operation, request, data)
    
    def addHeadersToRequest(self, request):
        """Called on outgoing requests and should add raw headers to the request.
        
        The default implementation of this method simply adds all the headers in the
        headers instance attribute.
        
        """
        for name, value in self.headers.items():
            request.setRawHeader(name, value)
    
    def registerHandler(self, scheme, handler):
        """Registers a handler for the given scheme.
        
        The handler is called with four arguments (manager, operation, request,
        data), just like the QNetworkAccessManager.createRequest method, and
        should return a QNetworkReply instance.
        
        """
        self._dispatcher[scheme] = handler
        
    def registerHtmlHandler(self, scheme, handler, threaded=False, encoding="UTF-8"):
        """Registers a simple callable as the handler for the given scheme.
        
        The handler only gets a GET URL (QUrl) and should return a HTML string.
        If threaded is True, the handler is called in a background thread.
        The encoding defaults to UTF-8 and is used for encoding the HTML returned
        by then handler and also set in the Content-Type header.
        
        """
        cls = ThreadedHtmlReply if threaded else HtmlReply
        def createRequest(mgr, operation, request, data):
            return cls(mgr, request.url(), handler, encoding)
        self._dispatcher[scheme] = createRequest

    def unregisterHandler(self, scheme):
        """Removes the special handling for the given scheme."""
        try:
            del self._dispatcher[scheme]
        except KeyError:
            pass


class HtmlReplyBase(QNetworkReply):
    """Abstract base class for a QNetworkReply that represents a generated HTML string."""
    def __init__(self, manager, url, handler, encoding="UTF-8"):
        QNetworkReply.__init__(self, manager)
        self.setUrl(url)
        self._handler = handler
        self._encoding = encoding
    
    def callHandler(self):
        self._content = self._handler(self.url()).encode(self._encoding)
        
    def outputReady(self):
        self._offset = 0
        self.setHeader(QNetworkRequest.ContentTypeHeader, "text/html; charset={0}".format(self._encoding))
        self.setHeader(QNetworkRequest.ContentLengthHeader, len(self._content))
        self.open(QNetworkReply.ReadOnly | QNetworkReply.Unbuffered)
    
    def emitSignals(self):
        self.readyRead.emit()
        self.finished.emit()
    
    def abort(self):
        pass
    
    def bytesAvailable(self):
        return len(self._content) - self._offset
    
    def isSequential(self):
        return True
    
    def readData(self, maxSize):
        if self._offset < len(self._content):
            end = min(self._offset + maxSize, len(self._content))
            data = self._content[self._offset:end]
            self._offset = end
            return data


class HtmlReply(HtmlReplyBase):
    """QNetworkReply that generates a HTML string by calling handler(url).encode(encoding)."""
    def __init__(self, manager, url, handler, encoding="UTF-8"):
        HtmlReplyBase.__init__(self, manager, url, handler, encoding)
        self.callHandler()
        self.outputReady()
        QTimer.singleShot(0, self.emitSignals)


class ThreadedHtmlReply(HtmlReplyBase):
    """HtmlReply that calls handler(url) in a background thread."""
    def __init__(self, manager, url, handler, encoding="UTF-8"):
        HtmlReplyBase.__init__(self, manager, url, handler, encoding)
        self._thread = Thread(self.callHandler)
        self._thread.finished.connect(self.threadFinished)
        self._thread.start()
    
    def threadFinished(self):
        self.outputReady()
        self.emitSignals()


class Thread(QThread):
    """QThread that runs a single callable."""
    def __init__(self, func):
        QThread.__init__(self)
        self._func = func
    
    def run(self):
        self._func()



########NEW FILE########
__FILENAME__ = node
# node.py -- Node is a list-like type to build tree structures with
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""

The Node class.

(c) 2008-2011 Wilbert Berendsen
License: GPL.

This module contains the Node class that can be used as a simple DOM (Document
Object Model) for building a tree structure.

A Node has children with list-like access methods and keeps also a reference to
its parent. A Node can have one parent; appending a Node to another Node causes
it to be removed from its parent node (if any).

To iterate over the children of a Node:

    for n in node:
        do_something(n)

To get the list of children of a Node:

    children = list(node)

Of course you can get the children directly using:

    child = node[3]

You should inherit from Node to make meaningful tree node types, e.g. to add
custom attributes or multiple sub-types.

A WeakNode class is provided as well, which uses a weak reference to the parent,
so that no cyclic references are created which might improve garbage collection.

"""

import weakref


class Node(object):
    """A list-like class to build tree structures with."""
    __slots__ = ('__weakref__', '_parent', '_children')
    
    def __init__(self, parent=None):
        self._parent = None
        self._children = []
        if parent:
            parent.append(self)

    def _own(self, node):
        """(Internal) Remove node from its parent if any and make us parent."""
        parent = node.parent()
        if parent:
            parent.remove(node)
        node._set_parent(self)
    
    def _set_parent(self, node):
        """(Internal) Set the Node (or None) as our parent."""
        self._parent = node
        
    def parent(self):
        """The parent, or None if the node has no parent."""
        return self._parent

    def index(self, node):
        """Return the index of the given child node."""
        return self._children.index(node)

    def append(self, node):
        """Append a node to the current node.
        
        It will be reparented, that means it will be removed from it's former
        parent if it had one.
        
        """
        self._own(node)
        self._children.append(node)
        
    def extend(self, iterable):
        """Append every Node from iterable."""
        for node in iterable:
            self.append(node)
        
    def insert(self, index, node):
        """Insert a node at the specified index."""
        self._own(node)
        self._children.insert(index, node)
        
    def insert_before(self, other, node):
        """Insert a node before the other node."""
        i = self.index(other)
        self._own(node)
        self._children.insert(i, node)
        
    def remove(self, node):
        """Remove the given child node."""
        self._children.remove(node)
        node._set_parent(None)

    def __nonzero__(self):
        """We are always true."""
        return True
    
    __bool__ = __nonzero__
    
    def __len__(self):
        """Return the number of children."""
        return len(self._children)

    def __getitem__(self, k):
        """Return child at index or children at slice."""
        return self._children[k]

    def __setitem__(self, k, obj):
        """Set child at index or children at slice."""
        old = self._children[k]
        if isinstance(k, slice):
            if k.step:
                # extended slice, number of items must be same
                self._children[k] = obj
                # if this succeeded it's OK
                new = self._children[k]
            else:
                new = tuple(obj)
                self._children[k] = new
            for node in old:
                node._set_parent(None)
            for node in new:
                self._own(node)
        else:
            old._set_parent(None)
            self._children[k] = obj
            self._own(obj)

    def __delitem__(self, k):
        """Delete child at index or children at slice."""
        if isinstance(k, slice):
            for node in self._children[k]:
                node._set_parent(None)
        else:
            self._children[k]._set_parent(None)
        del self._children[k]

    def __contains__(self, node):
        """Return True if the node is our child."""
        return node in self._children

    def clear(self):
        """Remove all children."""
        del self[:]

    def unlink(self):
        """Remove all children and unlink() them as well."""
        for node in self:
            node.unlink()
        del self._children[:]
    
    def replace(self, old, new):
        """Replace a child node with another node."""
        i = self.index(old)
        self[i] = new

    def sort(self, key=None, reverse=False):
        """Sorts the children, optionally using the key function.
        
        Using a key function is recommended, or you must add comparison methods
        to your Node subclass.
        
        """
        self._children.sort(key, reverse=reverse)
        
    def copy(self):
        """Return a deep copy of the node and its children """
        obj = self.__class__.__new__(self.__class__)
        obj._parent = None
        obj._children = []
        self._copy_attrs(obj)
        for n in self:
            obj.append(n.copy())
        return obj
    
    def _copy_attrs(self, node):
        """Called by copy(); copy attributes not starting with '_'."""
        for name, value in vars(self).items():
            name.startswith("_") or setattr(node, name, value)
            
    def ancestors(self):
        """Climb the tree up over the parents."""
        node = self.parent()
        while node:
            yield node
            node = node.parent()

    def previous_sibling(self):
        """Return the sibling object just before us in our parents list.
        
        Returns None if this is the first child, or if we have no parent.
        
        """
        for i in self.backward():
            return i

    def next_sibling(self):
        """Return the sibling object just after us in our parents list.
        
        Returns None if this is the last child, or if we have no parent.
        
        """
        for i in self.forward():
            return i

    def backward(self):
        """Iterate (backwards) over the preceding siblings."""
        parent = self.parent()
        if parent:
            i = parent.index(self)
            return iter(parent[i-1::-1])

    def forward(self):
        """Iterate over the following siblings."""
        parent = self.parent()
        if parent:
            i = parent.index(self)
            return iter(parent[i+1::])

    def is_descendant_of(self, parent):
        """Return True if self is a descendant of parent, else False."""
        for n in self.ancestors():
            if n is parent:
                return True
        return False

    def toplevel(self):
        """Return the toplevel parent Node of this node."""
        node = self
        parent = self.parent()
        while parent:
            node = parent
            parent = node.parent()
        return node
    
    def descendants(self, depth = -1):
        """Yield all the descendants, in tree order. Same as iter_depth()."""
        return self.iter_depth(depth)
    
    def iter_depth(self, depth = -1):
        """Iterate over all the children, and their children, etc.
        
        Set depth to restrict the search to a certain depth, -1 is unrestricted.
        
        """
        if depth != 0:
            for i in self:
                yield i
                for j in i.iter_depth(depth - 1):
                    yield j
                
    def iter_rings(self, depth = -1):
        """Iterate over the children in rings, depth last.
        
        This method returns the closest descendants first.
        Set depth to restrict the search to a certain depth, -1 is unrestricted.
        
        """
        children = list(self)
        while children and depth:
            depth -= 1
            newchildren = []
            for i in children:
                yield i
                newchildren.extend(i)
            children = newchildren

    def find(self, cls, depth = -1):
        """Yield all descendants if they are an instance of cls.
        
        cls may also be a tuple of classes. This method uses iter_depth().
        
        """
        for node in self.iter_depth(depth):
            if isinstance(node, cls):
                yield node
        
    def find_children(self, cls, depth = -1):
        """Yield all descendants if they are an instance of cls.
        
        cls may also be a tuple of classes. This method uses iter_rings().
        
        """
        for node in self.iter_rings(depth):
            if isinstance(node, cls):
                yield node

    def find_child(self, cls, depth = -1):
        """Return the first descendant that's an instance of cls.
        
        cls may also be a tuple of classes. This method uses iter_rings().
        
        """
        for node in self.iter_rings(depth):
            if isinstance(node, cls):
                return node
    
    def find_parent(self, cls):
        """Find an ancestor that's an instance of the given class.
        
        cls may also be a tuple of classes.
        
        """
        for node in self.ancestors():
            if isinstance(node, cls):
                return node
    
    def dump(self):
        """Return a string representation of the tree."""
        def line(obj, indent):
            yield indent * "  " + repr(obj)
            for c in obj:
                for l in line(c, indent + 1):
                    yield l
        return '\n'.join(line(self, 0))



class WeakNode(Node):
    """A Node type using a weak reference to the parent."""
    __slots__ = ()
    def _set_parent(self, node):
        self._parent = None if node is None else weakref.ref(node)
    
    def parent(self):
        """The parent, or None if the node has no parent."""
        if self._parent is not None:
            return self._parent()



########NEW FILE########
__FILENAME__ = defineoffset
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Finds out which type of LilyPond object the offset will be applied to
using ly.music, stores this data and creates and inserts an override command.
"""

from __future__ import unicode_literals

from PyQt4 import QtGui

import documentinfo
import lydocument
import reformat


class DefineOffset():

    def __init__(self, doc):
        self.doc = doc
        self.docinfo = documentinfo.music(doc)
        self.node = None
        self.lilyObject = None
        self.lilyContext = ""
        self.pos = 0
        
    def getCurrentLilyObject(self, cursor):
        """ Use cursor from textedit link to get type of object being edited."""        
        lycursor = lydocument.cursor(cursor)
        self.pos = lycursor.start        
        node = self.docinfo.node(self.pos)
        self.node = node
        child = self.docinfo.iter_music(node)
        for c in child:
            name = c.__class__.__name__ #get instance name
            return self.item2object(name)
        name = node.__class__.__name__
        return self.item2object(name)
        
    def item2object(self, item):
        """ Translate item type into name of 
        LilyPond object.
        """
        item2objectDict = {
            "String": { "GrobType": "TextScript" }, 
            "Markup": { "GrobType": "TextScript" },
            "Tempo": { "GrobType": "MetronomeMark",
                       "Context" : "Score" }, 
            "Articulation": { "GrobType": "Script" }
            }
        try:
            obj = item2objectDict[item]
        except KeyError:
            obj = { "GrobType": "still testing!" }
        self.lilyObject = obj["GrobType"]
        if "Context" in obj:
            self.lilyContext = obj["Context"]
        return obj["GrobType"]
        
    def insertOverride(self, x, y):
        """ Insert the override command. """
        doc = lydocument.Document(self.doc)
        block = doc.block(self.pos)
        p = block.position()
        cursor = QtGui.QTextCursor(self.doc)
        cursor.setPosition(p)
        cursor.beginEditBlock()
        cursor.insertText(self.createOffsetOverride(x, y))
        cursor.insertBlock()
        cursor.endEditBlock()
        reformat.reformat(cursor)
        
    def createOffsetOverride(self, x, y):
        """ Create the override command.
        Can this be created as a node?
        """
        objToOverride = self.lilyContext
        if len(objToOverride) > 0:
            objToOverride += "."
        objToOverride += self.lilyObject
        return "\once \override " + objToOverride + ".extra-offset = #'(" + str(x) + " . " + str(y) + ")"

########NEW FILE########
__FILENAME__ = widget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
An Object Editor widget.
"""

from __future__ import unicode_literals

import sys

from PyQt4 import QtCore
from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import objecteditor

from . import defineoffset


class Widget(QWidget):
    
# I think we will work with individual editor objects for different types of objects.
# Each one will be shown/hidden on demand, i.e. when an element is activated
# through the SVG view, the music view or the cursor in the source.
# Each editor object handles its own connections to signals.
# (PS: The object editor will also work with the source code directly,
# i.e. independently of graphical SVG editing.)

    def __init__(self, tool):
        super(Widget, self).__init__(tool)
        self.mainwindow = tool.mainwindow()
        self.define = None
        
        import panelmanager
        self.svgview = panelmanager.manager(tool.mainwindow()).svgview.widget().view
        
        layout = QVBoxLayout(spacing=1)
        self.setLayout(layout)
        
        self.elemLabel = QLabel()
        
        self.XOffsetBox = QDoubleSpinBox()
        self.XOffsetBox.setRange(-99,99)
        self.XOffsetBox.setSingleStep(0.1)
        self.XOffsetLabel = l = QLabel()
        l.setBuddy(self.XOffsetBox)
 
        self.YOffsetBox = QDoubleSpinBox()
        self.YOffsetBox.setRange(-99,99)
        self.YOffsetBox.setSingleStep(0.1)
        self.YOffsetLabel = l = QLabel()
        l.setBuddy(self.YOffsetBox)
        
        self.insertButton = QPushButton("insert offset in source", self)
        self.insertButton.clicked.connect(self.callInsert)
        
        layout.addWidget(self.elemLabel)
        layout.addWidget(self.XOffsetBox)
        layout.addWidget(self.XOffsetLabel)
        layout.addWidget(self.YOffsetBox)
        layout.addWidget(self.YOffsetLabel)
        layout.addWidget(self.insertButton)
        
        layout.addStretch(1)

        app.translateUI(self)
        self.loadSettings()
        
        self.connectSlots()
    
    def connectSlots(self):
        # On creation we connect to all available signals
        self.connectToSvgView()
    
    def connectToSvgView(self):
        """Register with signals emitted by the
           SVG viewer for processing graphical editing.
        """
        self.svgview.objectStartDragging.connect(self.startDragging)
        self.svgview.objectDragging.connect(self.Dragging)
        self.svgview.objectDragged.connect(self.Dragged)
        self.svgview.cursor.connect(self.setObjectFromCursor)
        
    def disconnectFromSvgView(self):
        """Do not process graphical edits when the
           Object Editor isn't visible."""
        self.svgview.objectStartDragging.disconnect()
        self.svgview.objectDragging.disconnect()
        self.svgview.objectDragged.disconnect()
        self.svgview.cursor.disconnect()
        
    def translateUI(self):
        self.XOffsetLabel.setText(_("X Offset"))
        self.XOffsetBox.setToolTip(_("Display the X Offset"))
        self.YOffsetLabel.setText(_("Y Offset"))
        self.YOffsetBox.setToolTip(_("Display the Y Offset"))
        self.insertButton.setEnabled(False)

    def hideEvent(self, event):
        """Disconnect from all graphical editing signals
           when the panel isn't visible
        """
        self.disconnectFromSvgView()
        event.accept()
    
    def showEvent(self, event):
        """Connect to the graphical editing signals
           when the panel becomes visible
        """
        self.connectToSvgView()
        event.accept()
        
    def callInsert(self):
        """ Insert the override command in the source."""
        if self.define:
            self.define.insertOverride(self.XOffsetBox.value(), self.YOffsetBox.value())		
    
    @QtCore.pyqtSlot(float, float)
    def setOffset(self, x, y):
        """Display the updated offset."""
        self.XOffsetBox.setValue(x)
        self.YOffsetBox.setValue(y)
    
    @QtCore.pyqtSlot(float, float)
    def startDragging(self, x, y):
        """Set the value of the offset externally."""
        # temporary debug output
        #print "Start dragging with offset", x, y
        self.setOffset(x, y)
        
    @QtCore.pyqtSlot(float, float)
    def Dragging(self, x, y):
        """Set the value of the offset externally."""
        # temporary debug output
        # print "Dragging with offset", x, y
        self.setOffset(x, y)
        
    @QtCore.pyqtSlot(float, float)
    def Dragged(self, x, y):
        """Set the value of the offset externally."""
        # temporary debug output
        #print "Dragged to", x, y
        self.setOffset(x, y)
        
    @QtCore.pyqtSlot(QTextCursor)
    def setObjectFromCursor(self, cursor):
        """Set selected element."""
        self.define = defineoffset.DefineOffset(self.mainwindow.currentDocument())
        self.elemLabel.setText(self.define.getCurrentLilyObject(cursor))
        self.insertButton.setEnabled(True)

    def loadSettings(self):
        """Called on construction. Load settings and set checkboxes state."""
        s = QSettings()
        s.beginGroup('object_editor')
        
    def saveSettings(self):
        """Called on close. Save settings and checkboxes state."""
        s = QSettings()
        s.beginGroup('object_editor')


########NEW FILE########
__FILENAME__ = open_file_at_cursor
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Opens a file the current textcursor points at (or has selected).
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import QUrl

import documentinfo
import browseriface


def filenames_at_cursor(cursor, existing=True):
    """Return a list of filenames at the cursor.
    
    If existing is False, also names are returned that do not exist on disk.
    
    """
    # take either the selection or the include-args found by lydocinfo
    start = cursor.document().findBlock(cursor.selectionStart()).position()
    end = cursor.selectionEnd()
    if not cursor.hasSelection():
        end = start + len(cursor.block().text()) + 1
    dinfo = documentinfo.info(cursor.document())
    i = dinfo.lydocinfo().range(start, end)
    fnames = i.include_args() or i.scheme_load_args()
    if not fnames and cursor.hasSelection():
        fnames = [cursor.selection().toPlainText()]
    
    # determine search path: doc dir and other include path names
    filename = cursor.document().url().toLocalFile()
    directory = os.path.dirname(filename)
    if filename:
        path = [directory]
    else:
        path = []
    path.extend(dinfo.includepath())
    
    # find all docs, trying all include paths
    filenames = []
    for f in fnames:
        for p in path:
            name = os.path.normpath(os.path.join(p, f))
            if os.access(name, os.R_OK):
                filenames.append(name)
                break
        else:
            if not existing:
                name = os.path.normpath(os.path.join(directory, f))
                filenames.append(name)
    return filenames

def open_file_at_cursor(mainwindow, cursor=None):
    """Open the filename(s) mentioned at the mainwindow's text cursor.
    
    Return True if there were one or more filenames that were opened.
    
    """
    if cursor is None:
        cursor = mainwindow.textCursor()
    d = None
    for name in filenames_at_cursor(cursor):
        d = mainwindow.openUrl(QUrl.fromLocalFile(name))
    if d:
        browseriface.get(mainwindow).setCurrentDocument(d, True)
        return True


########NEW FILE########
__FILENAME__ = widget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The document outline tool widget.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QEvent, QTimer
from PyQt4.QtGui import QBrush, QFont, QTextCursor, QTreeWidget, QTreeWidgetItem

import app
import qutil
import cursortools
import tokeniter
import documentstructure


class Widget(QTreeWidget):
    def __init__(self, tool):
        super(Widget, self).__init__(tool,
            headerHidden=True)
        self._timer = QTimer(singleShot=True, timeout=self.updateView)
        tool.mainwindow().currentDocumentChanged.connect(self.slotCurrentDocumentChanged)
        self.itemClicked.connect(self.slotItemClicked)
        self.itemActivated.connect(self.slotItemClicked)
        self.itemCollapsed.connect(self.slotItemCollapsed)
        self.itemExpanded.connect(self.slotItemExpanded)
        app.settingsChanged.connect(self.updateView)
        doc = tool.mainwindow().currentDocument()
        if doc:
            self.slotCurrentDocumentChanged(doc)
    
    def slotCurrentDocumentChanged(self, doc, old=None):
        """Called whenever the mainwindow changes the current document."""
        if old:
            old.contentsChange.disconnect(self.slotContentsChange)
        if doc:
            doc.contentsChange.connect(self.slotContentsChange)
            self._timer.start(100)
            
    def slotContentsChange(self, position, added, removed):
        """Updates the view on contents change."""
        if added + removed > 1000:
            self._timer.start(100)
        else:
            self._timer.start(2000)
        
    def updateView(self):
        """Recreate the items in the view."""
        with qutil.signalsBlocked(self):
            self.clear()
            doc = self.parent().mainwindow().currentDocument()
            if not doc:
                return
            view_cursor_position = self.parent().mainwindow().textCursor().position()
            structure = documentstructure.DocumentStructure.instance(doc)
            last_item = None
            current_item = None
            last_block = None
            for i in structure.outline():
                position = i.start()
                block = doc.findBlock(position)
                depth = tokeniter.state(block).depth()
                if block == last_block:
                    parent = last_item
                elif last_block is None or depth == 1:
                    # a toplevel item anyway
                    parent = self
                else:
                    while last_item and depth <= last_item.depth:
                        last_item = last_item.parent()
                    if not last_item:
                        parent = self
                    else:
                        # the item could belong to a parent item, but see if they
                        # really are in the same (toplevel) state
                        b = last_block.next()
                        while b < block:
                            depth2 = tokeniter.state(b).depth()
                            if depth2 == 1:
                                parent = self
                                break
                            while last_item and depth2 <= last_item.depth:
                                last_item = last_item.parent()
                            if not last_item:
                                parent = self
                                break
                            b = b.next()
                        else:
                            parent = last_item
                
                item = last_item = QTreeWidgetItem(parent)
                
                # set item text and display style bold if 'title' was used
                for name, text in i.groupdict().items():
                    if text:
                        if name.startswith('title'):
                            font = item.font(0)
                            font.setWeight(QFont.Bold)
                            item.setFont(0, font)
                            break
                        elif name.startswith('alert'):
                            color = item.foreground(0).color()
                            color = qutil.addcolor(color, 128, 0, 0)
                            item.setForeground(0, QBrush(color))
                            font = item.font(0)
                            font.setStyle(QFont.StyleItalic)
                            item.setFont(0, font)
                        elif name.startswith('text'):
                            break
                else:
                    text = i.group()
                item.setText(0, text)
                
                # remember whether is was collapsed by the user
                try:
                    collapsed = block.userData().collapsed
                except AttributeError:
                    collapsed = False
                item.setExpanded(not collapsed)
                item.depth = depth
                item.position = position
                last_block = block
                # scroll to the item at the view's cursor later
                if position <= view_cursor_position:
                    current_item = item
            if current_item:
                self.scrollToItem(current_item)
    
    def cursorForItem(self, item):
        """Returns a cursor for the specified item.
        
        This method (as all others) assume that the item refers to the current
        Document.
        
        """
        doc = self.parent().mainwindow().currentDocument()
        cursor = QTextCursor(doc)
        cursor.setPosition(item.position)
        return cursor
        
    def slotItemClicked(self, item):
        """Called when the user clicks an item."""
        cursor = self.cursorForItem(item)
        cursor.movePosition(cursor.StartOfBlock)
        import browseriface
        browseriface.get(self.parent().mainwindow()).setTextCursor(cursor)
        view = self.parent().mainwindow().currentView()
        view.centerCursor()
        view.setFocus()

    def slotItemCollapsed(self, item):
        """Called when the user collapses an item."""
        block = self.cursorForItem(item).block()
        cursortools.data(block).collapsed = True
    
    def slotItemExpanded(self, item):
        """Called when the user expands an item."""
        block = self.cursorForItem(item).block()
        cursortools.data(block).collapsed = False

    def event(self, ev):
        """Reimplemented to show custom tool tips."""
        if ev.type() == QEvent.ToolTip:
            i = self.indexAt(ev.pos() - self.viewport().pos())
            item = self.itemFromIndex(i)
            if item:
                self.showToolTip(item)
                return True
        return super(Widget, self).event(ev)

    def showToolTip(self, item):
        """Called when a tool tip for the specified item needs to be shown."""
        import documenttooltip
        documenttooltip.show(self.cursorForItem(item))



########NEW FILE########
__FILENAME__ = panel
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Base class for the Panels (QDockWidgets).

A Panel is instantiated on startup of Frescobaldi, but the loading of the
actual widget's module is deferred until the panel is actually shown.

In the panelmanager module, the Panels are instantiated.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import Qt
from PyQt4.QtGui import QDockWidget, QLabel

import app


class Panel(QDockWidget):
    """Base class for Panels.
    
    You should implement __init__(), createWidget() and translateUI().
    
    This QDockWidget subclass implements lazy loading of the panel's widget.
    When one of sizeHint() or showEvent() is called for the first time, the
    widget is created by calling createWidget().
    
    """
    def __init__(self, mainwindow):
        """Implement this method to add yourself to the mainwindow.
        
        First call this super method as it calls the Qt constructor.
        
        """
        super(Panel, self).__init__(mainwindow)
        self.setObjectName(self.__class__.__name__.lower())
        app.translateUI(self)
    
    def mainwindow(self):
        """Returns the MainWindow."""
        return self.parentWidget()
        
    def sizeHint(self):
        """Re-implemented to force creation of our widget."""
        self.widget()
        return super(Panel, self).sizeHint()
    
    def widget(self):
        """Ensures that our widget() is created and returns it."""
        w = super(Panel, self).widget()
        if not w:
            w = self.createWidget()
            self.setWidget(w)
        return w
    
    def showEvent(self, ev):
        """Re-implemented to force creation of widget."""
        self.widget()
        
    def createWidget(self):
        """Implement this to return the widget for this tool."""
        return QLabel("<test>", self)
        
    def activate(self):
        """Really shows the dock widget, even if tabified or floating."""
        self.show()
        if self.mainwindow().tabifiedDockWidgets(self) or self.isFloating():
            self.raise_()
    
    def maximize(self):
        """Show the dockwidget floating and maximized."""
        self.setFloating(True)
        self.showMaximized()
    
    def translateUI(self):
        """Implement to set a title for the widget and its toggleViewAction."""
        raise NotImplementedError(
            "Please implement this method to at least set a title "
            "for the dockwidget and its toggleViewAction().")



########NEW FILE########
__FILENAME__ = panelmanager
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages the Panels (Tools).
"""

from __future__ import unicode_literals

import sys

import actioncollection
import actioncollectionmanager
import plugin


def manager(mainwindow):
    return PanelManager.instance(mainwindow)
    

class PanelManager(plugin.MainWindowPlugin):
    def __init__(self, mainwindow):
        """Instantiate the Panel Manager.
        
        In this method you should also load the modules that implement
        panel tools.
        
        """
        self._panels = []
        
        # add the the panel stubs here
        self.loadPanel("quickinsert.QuickInsertPanel")
        self.loadPanel("musicview.MusicViewPanel")
        self.loadPanel("svgview.SvgViewPanel")
        self.loadPanel("logtool.LogTool")
        self.loadPanel("docbrowser.HelpBrowser")
        self.loadPanel("snippet.tool.SnippetTool")
        self.loadPanel("miditool.MidiTool")
        self.loadPanel("midiinput.tool.MidiInputTool")
        self.loadPanel("charmap.CharMap")
        self.loadPanel("doclist.DocumentList")
        self.loadPanel("outline.OutlinePanel")
        self.loadPanel("layoutcontrol.LayoutControlOptions")
        # The Object editor is highly experimental and should be
        # commented out for stable releases.
        self.loadPanel("objecteditor.ObjectEditor")
        
        self.createActions()
        
        # make some default arrangements
        mainwindow.tabifyDockWidget(self.musicview, self.docbrowser)
        mainwindow.tabifyDockWidget(self.musicview, self.svgview)
    
    def loadPanel(self, name):
        """Loads the named Panel.
        
        The name consists of a module name and the class name of the Panel
        subclass to instantiate.
        
        The instance is saved in an attribute 'name', with dots and the class
        name removed. So if you call self.loadTool("foo.bar.FooBar"), you can
        find the instantiated FooBar panel in the 'foobar' attribute.
        
        """
        module_name, class_name = name.rsplit('.', 1)
        __import__(module_name)
        module = sys.modules[module_name]
        attribute_name = module_name.replace('.', '')
        cls = vars(module)[class_name]
        panel = cls(self.mainwindow())
        self._panels.append((attribute_name, panel))
        setattr(self, attribute_name, panel)

    def createActions(self):
        self.actionCollection = Actions(self)
        actioncollectionmanager.manager(self.mainwindow()).addActionCollection(self.actionCollection)

    def addActionsToMenu(self, menu):
        """Adds all toggleViewActions to the given menu."""
        for name, panel in self._panels:
            menu.addAction(panel.toggleViewAction())

    def panels_at(self, area):
        """Return the list of panels at the specified Qt.DockWidgetArea.
        
        Each entry is the (name, panel) tuple. Floating or hidden panels are
        not returned, but tabbed panels are.
        
        """
        result = []
        for name, panel in self._panels:
            if (self.mainwindow().dockWidgetArea(panel) == area
                and not panel.isFloating()
                and (panel.isVisible() or self.mainwindow().tabifiedDockWidgets(panel))):
                result.append((name, panel))
        return result


class Actions(actioncollection.ActionCollection):
    """Manages the keyboard shortcuts to hide/show the plugins."""
    name = "panels"
    
    def createActions(self, manager):
        # add the actions for the plugins
        for name, panel in manager._panels:
            setattr(self, 'panel_' + name, panel.toggleViewAction())



########NEW FILE########
__FILENAME__ = percentcoding
#! python
# percentcoding -- simple pure python percent encoding and decoding
#
# This module is in the public domain

import sys


if sys.version_info[0] < 3:
    
    # Python 2
    def encode(s):
        """Convert any non-alfanumeric in s to the '%HH' representation.
        
        The argument must be a byte string. A byte string is also returned.
        
        """
        result = bytearray()
        for c in s:
            o = ord(c)
            if 48 <= o <= 57 or 65 <= o <= 90 or 79 <= o <= 122 or c in b'._-':
                result.append(o)
            else:
                result.extend(b'%{0:02X}'.format(o))
        return bytes(result)

    def decode(s):
        """Percent-decodes all %HH sequences in the specified bytes string."""
        l = s.split(b'%')
        res = [l[0]]
        for i in l[1:]:
            res.append(chr(int(i[:2], 16)))
            res.append(i[2:])
        return b''.join(res)


else:

    # Python 3
    def encode(s):
        """Convert any non-alfanumeric in s to the '%HH' representation.
        
        The argument must be a byte string. A byte string is also returned.
        
        """
        result = bytearray()
        for c in s:
            if 48 <= c <= 57 or 65 <= c <= 90 or 79 <= c <= 122 or c in b'._-':
                result.append(c)
            else:
                result.extend(b'%{0:02X}'.format(c))
        return bytes(result)

    def decode(s):
        """Percent-decodes all %HH sequences in the specified bytes string."""
        l = s.split(b'%')
        res = bytearray(l[0])
        for i in l[1:]:
            res.append(int(i[:2], 16))
            res.extend(i[2:])
        return bytes(res)


########NEW FILE########
__FILENAME__ = pitch
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Various tools to edit pitch of selected music.

All use the tools in ly.pitch.

"""

from __future__ import unicode_literals

import re

from PyQt4.QtGui import QMessageBox

import app
import icons
import qutil
import lydocument
import documentinfo
import lilypondinfo
import inputdialog
import ly.pitch.translate
import ly.pitch.transpose
import ly.pitch.rel2abs
import ly.pitch.abs2rel


def changeLanguage(cursor, language):
    """Changes the language of the pitch names."""
    c = lydocument.cursor(cursor, select_all=True)
    try:
        with qutil.busyCursor():
            changed = ly.pitch.translate.translate(c, language)
    except ly.pitch.PitchNameNotAvailable:
        QMessageBox.critical(None, app.caption(_("Pitch Name Language")), _(
            "Can't perform the requested translation.\n\n"
            "The music contains quarter-tone alterations, but "
            "those are not available in the pitch language \"{name}\"."
            ).format(name=language))
        return
    if changed:
        return
    if not cursor.hasSelection():
        # there was no selection and no language command, so insert one
        version = (documentinfo.docinfo(cursor.document()).version()
                   or lilypondinfo.preferred().version())
        ly.pitch.translate.insert_language(c.document, language, version)
        return
    # there was a selection but no command, user must insert manually.
    QMessageBox.information(None, app.caption(_("Pitch Name Language")),
        '<p>{0}</p>'
        '<p><code>\\include "{1}.ly"</code> {2}</p>'
        '<p><code>\\language "{1}"</code> {3}</p>'.format(
            _("The pitch language of the selected text has been "
                "updated, but you need to manually add the following "
                "command to your document:"),
            language,
            _("(for LilyPond below 2.14), or"),
            _("(for LilyPond 2.14 and higher.)")))


def rel2abs(cursor):
    """Converts pitches from relative to absolute."""
    with qutil.busyCursor():
        c = lydocument.cursor(cursor, select_all=True)
        ly.pitch.rel2abs.rel2abs(c)


def abs2rel(cursor):
    """Converts pitches from absolute to relative."""
    with qutil.busyCursor():
        c = lydocument.cursor(cursor, select_all=True)
        ly.pitch.abs2rel.abs2rel(c)


def getTransposer(document, mainwindow):
    """Show a dialog and return the desired transposer.
    
    Returns None if the dialog was cancelled.
    
    """
    language = documentinfo.docinfo(document).language() or 'nederlands'
    
    def readpitches(text):
        """Reads pitches from text."""
        result = []
        for pitch, octave in re.findall(r"([a-z]+)([,']*)", text):
            r = ly.pitch.pitchReader(language)(pitch)
            if r:
                result.append(ly.pitch.Pitch(*r, octave=ly.pitch.octaveToNum(octave)))
        return result
    
    def validate(text):
        """Returns whether the text contains exactly two pitches."""
        return len(readpitches(text)) == 2
    
    text = inputdialog.getText(mainwindow, _("Transpose"), _(
        "Please enter two absolute pitches, separated by a space, "
        "using the pitch name language \"{language}\"."
        ).format(language=language), icon = icons.get('tools-transpose'),
        help = "transpose", validate = validate)
    
    if text:
        return ly.pitch.transpose.Transposer(*readpitches(text))


def getModalTransposer(document, mainwindow):
    """Show a dialog and return the desired modal transposer.
    
    Returns None if the dialog was cancelled.
    
    """
    language = documentinfo.docinfo(document).language() or 'nederlands'
    
    def readpitches(text):
        """Reads pitches from text."""
        result = []
        for pitch, octave in re.findall(r"([a-z]+)([,']*)", text):
            r = ly.pitch.pitchReader(language)(pitch)
            if r:
                result.append(ly.pitch.Pitch(*r, octave=ly.pitch.octaveToNum(octave)))
        return result
    
    def validate(text):
        """Returns whether the text is an integer followed by the name of a key."""
        words = text.split()
        if len(words) != 2:
            return False
        try:
            steps = int(words[0])
            keyIndex = ly.pitch.transpose.ModalTransposer.getKeyIndex(words[1])
            return True
        except ValueError:
            return False
    
    text = inputdialog.getText(mainwindow, _("Transpose"), _(
        "Please enter the number of steps to alter by, followed by a key signature. (i.e. \"5 F\")"
        ), icon = icons.get('tools-transpose'),
        help = "modal_transpose", validate = validate)
    if text:
        words = text.split()
        return ly.pitch.transpose.ModalTransposer(int(words[0]), ly.pitch.transpose.ModalTransposer.getKeyIndex(words[1]))

    
def transpose(cursor, transposer, mainwindow=None):
    """Transpose pitches using the specified transposer."""
    c = lydocument.cursor(cursor, select_all=True)
    try:
        with qutil.busyCursor():
            ly.pitch.transpose.transpose(c, transposer)
    except ly.pitch.PitchNameNotAvailable as e:
        QMessageBox.critical(mainwindow, app.caption(_("Transpose")), _(
            "Can't perform the requested transposition.\n\n"
            "The transposed music would contain quarter-tone alterations "
            "that are not available in the pitch language \"{language}\"."
            ).format(language = e.language))



########NEW FILE########
__FILENAME__ = plugin
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Simple internal plugin api.

A Plugin is like an extension of the object it is used for. You would
normally subclass it to do useful things. It is created by calling the
instance(obj) method and lives as long as the object lives. When calling
instance(obj) again, the same Plugin instance is returned.

The Plugin instance keeps a weak reference to its object in the _parent
attribute. The object is unchanged, it knows nothing about the plugin.

There are three often used Plugin classes defined here:
MainWindowPlugin (for MainWindow instances), DocumentPlugin (for Document instances)
and ViewSpacePlugin (for ViewSpace instances).

Also the Attributes class is defined here, which is a simple class without methods
but with special instance attribute handling:
- when setting attributes on an instance, weak references are used when possible
- when requesting unexisting attributes, None is returned
- deleting an attribute does not fail if it doesn't exist.

You can use this class to store information to associate objects with each other,
but without keeping references to them.

Finally there is an AttributePlugin class, combining the Attributes and Plugin classes.

"""

from __future__ import unicode_literals

import weakref

_instances = weakref.WeakKeyDictionary()


class Plugin(object):
    """Base class for plugins.
    
    A Plugin is coupled to another object and is automatically garbage collected
    as soon as the other object disappears.
    
    Use the instance() class method to get/create the Plugin instance for an object.
    
    Implement the __init__() method if you want to do some setup.
    
    The instances() class method returns all living instances of this plugin type.
    
    """
    def __init__(self, obj):
        """Implement this method to setup the plugin instance."""
        pass
    
    @classmethod
    def instance(cls, obj):
        """Returns the instance of this plugin type for this object.
        
        The plugin instance is created if it did not exist.
        
        """
        try:
            return _instances[cls][obj]
        except KeyError:
            instances = _instances.setdefault(cls, weakref.WeakKeyDictionary())
            result = instances[obj] = cls.__new__(cls, obj)
            result._parent = weakref.ref(obj)
            result.__init__(obj)
        return result
    
    @classmethod
    def instances(cls):
        """Iterates over all living instances of this plugin."""
        try:
            return _instances[cls].values()
        except KeyError:
            return ()


class Attributes(object):
    """Manages attributes.
    
    The attributes can be set simply as instance attributes.
    
    If an attribute is set, it is stored as a weak reference when possible
    If an attribute is requested but not set or its value does not exist anymore,
    None is returned.
    Deleting an attribute does not fail if it doesn't exist.
    
    """
    def __init__(self):
        self._attrs = {}
        
    def __getattr__(self, name):
        val = self._attrs.get(name)
        if isinstance(val, weakref.ref):
            return val()
        else:
            return val
    
    def __setattr__(self, name, value):
        if name.startswith('_'):
            object.__setattr__(self, name, value)
        else:
            try:
                value = weakref.ref(value)
            except TypeError:
                pass
            self._attrs[name] = value

    def __delattr__(self, name):
        try:
            del self._attrs[name]
        except KeyError:
            pass


class AttributePlugin(Plugin, Attributes):
    """Base class for a Plugin managing attributes for any object."""
    def __init__(self, obj):
        """Implement this method to setup the plugin instance.
        
        For this class (AttributePlugin) you must also call this constructor if you reimplement it.
        
        """
        Attributes.__init__(self)
    

class DocumentPlugin(Plugin):
    """Base class for plugins that live besides a Document."""
    def document(self):
        """Returns the Document this plugin is used for."""
        return self._parent()


class MainWindowPlugin(Plugin):
    """Base class for plugins that live besides a MainWindow."""
    def mainwindow(self):
        """Returns the MainWindow this plugin is used for."""
        return self._parent()


class ViewSpacePlugin(Plugin):
    """Base class for plugins that live besides a ViewSpace."""
    def viewSpace(self):
        """Returns the ViewSpace this plugin is used for."""
        return self._parent()


class ViewPlugin(Plugin):
    """Base class for plugins that live besides a View."""
    def view(self):
        """Returns the View this plugin is used for."""
        return self._parent()



########NEW FILE########
__FILENAME__ = md2pot
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Creates translatable strings for the Frescobaldi User Manual.

Writes a POT file.

"""

from __future__ import unicode_literals

import sys
import textwrap

import simplemarkdown
import userguide.read 


class Parser(userguide.read.Parser):
    def __init__(self, output_file=None):
        super(Parser, self).__init__()
        w = self.wrapper = textwrap.TextWrapper()
        w.break_long_words = False
        w.break_on_hyphens = False
        w.initial_indent = ''
        w.subsequent_indent = ''
        self._output_lines = []
        self.f = output_file
    
    def make_translation_strings(self, filename):
        self._curfilename = filename
        self.parse(userguide.read.document(filename)[0], lineno=1)

    def translate(self, s):
        self.f.write('#: {0}:{1}\n'.format(self._curfilename, self.lineno))
        # is there markdown formatting in the string?
        formatting = False
        for c in '[]', '**', '``':
            for t, t2 in simplemarkdown.iter_split2(s, *c):
                formatting = bool(t2)
                break
            if formatting:
                self.f.write('#. NOTE: markdown formatting\n')
                break
        s = s.replace('\\', '\\\\').replace('"', '\\"')
        lines = self.wrapper.wrap(s)
        if len(lines) > 1:
            self.f.write('msgid ""\n')
            for l in lines[:-1]:
                self.f.write(('"' + l + ' "\n').encode('utf8'))
            self.f.write(('"' + lines[-1] + '"\n').encode('utf8'))
        else:
            self.f.write(('msgid "' + lines[0] + '"\n').encode('utf8'))
        self.f.write('msgstr ""\n\n')


def md2pot(filename, md_files):
    with open(filename, 'w') as f:
        p = Parser(f)
        for name in md_files:
            p.make_translation_strings(name)

if __name__ == '__main__':
    md2pot('/dev/stdout', sys.argv[1:])


########NEW FILE########
__FILENAME__ = messages
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Dummy file containing messages that are part of some Python modules or Qt and used in our application.
"""

from __future__ import unicode_literals

# Python, optparse:
_("Usage")
_("Usage: %s\n")
_("show this help message and exit")
_("show program's version number and exit")
# L10N: Command line options
_("Options")


# Qt
_("CloseButton", "Close Tab")
_("QDialogButtonBox", "Apply")
_("QDialogButtonBox", "&Cancel")
_("QDialogButtonBox", "Cancel")
_("QDialogButtonBox", "Close")
_("QDialogButtonBox", "Close without Saving")
_("QDialogButtonBox", "Discard")
_("QDialogButtonBox", "Help")
_("QDialogButtonBox", "&OK")
_("QDialogButtonBox", "OK")
_("QDialogButtonBox", "Open")
_("QDialogButtonBox", "Reset")
_("QDialogButtonBox", "&Save")
_("QDialogButtonBox", "Save")
_("QDialog", "What's This?")
_("QFileDialog", "All Files (*)")
_("QFileDialog", "Back")
_("QFileDialog", "Change to detail view mode")
_("QFileDialog", "Change to list view mode")
_("QFileDialog", "Create a New Folder")
_("QFileDialog", "Create New Folder")
_("QFileDialog", "&Delete")
_("QFileDialog", "Detail View")
_("QFileDialog", "Drive")
_("QFileDialog", "File")
_("QFileDialog", "File &name:")
_("QFileDialog", "Files of type:")
_("QFileDialog", "Find Directory")
_("QFileDialog", "Folder")
_("QFileDialog", "Forward")
_("QFileDialog", "Go back")
_("QFileDialog", "Go forward")
_("QFileDialog", "Go to the parent directory")
_("QFileDialog", "List View")
_("QFileDialog", "Look in:")
_("QFileDialog", "&New Folder")
_("QFileDialog", "&Open")
_("QFileDialog", "Parent Directory")
_("QFileDialog", "Remove")
_("QFileDialog", "&Rename")
_("QFileDialog", "Show ")
_("QFileDialog", "Show &hidden files")
_("QFileSystemModel", "%1 bytes")
_("QFileSystemModel", "%1 KB")
_("QFileSystemModel", "Computer")
_("QFileSystemModel", "Date Modified")
_("QFileSystemModel", "Name")
_("QFileSystemModel", "Size")
_("QFileSystemModel", "Type")
_("QFontDatabase", "Black")
_("QFontDatabase", "Bold")
_("QFontDatabase", "Demi Bold")
_("QFontDatabase", "Light")
_("QFontDatabase", "Oblique")
_("QInputContext", "XIM")
_("QLocalSocket", "%1: Invalid name")
_("QMultiInputContext", "Select IM")
_("QScrollBar", "Bottom")
_("QScrollBar", "Left edge")
_("QScrollBar", "Page down")
_("QScrollBar", "Page left")
_("QScrollBar", "Page right")
_("QScrollBar", "Page up")
_("QScrollBar", "Right edge")
_("QScrollBar", "Scroll down")
_("QScrollBar", "Scroll here")
_("QScrollBar", "Scroll left")
_("QScrollBar", "Scroll right")
_("QScrollBar", "Scroll up")
_("QScrollBar", "Top")
_("QShortcut", "+")
_("QShortcut", "Add Favorite")
_("QShortcut", "Adjust Brightness")
_("QShortcut", "Alt")
_("QShortcut", "Application Left")
_("QShortcut", "Application Right")
_("QShortcut", "Audio Cycle Track")
_("QShortcut", "Audio Forward")
_("QShortcut", "Audio Random Play")
_("QShortcut", "Audio Repeat")
_("QShortcut", "Audio Rewind")
_("QShortcut", "Away")
_("QShortcut", "Back")
_("QShortcut", "Back Forward")
_("QShortcut", "Backspace")
_("QShortcut", "Backtab")
_("QShortcut", "Bass Boost")
_("QShortcut", "Bass Down")
_("QShortcut", "Bass Up")
_("QShortcut", "Battery")
_("QShortcut", "Browser")
_("QShortcut", "Caps Lock")
_("QShortcut", "CapsLock")
_("QShortcut", "Clear")
_("QShortcut", "Clear Grab")
_("QShortcut", "Close")
_("QShortcut", "Copy")
_("QShortcut", "Ctrl")
_("QShortcut", "Cut")
_("QShortcut", "Del")
_("QShortcut", "Delete")
_("QShortcut", "Display")
_("QShortcut", "Documents")
_("QShortcut", "Down")
_("QShortcut", "Eject")
_("QShortcut", "End")
_("QShortcut", "Enter")
_("QShortcut", "Esc")
_("QShortcut", "F%1")
_("QShortcut", "Forward")
_("QShortcut", "Go")
_("QShortcut", "Help")
_("QShortcut", "History")
_("QShortcut", "Home Page")
_("QShortcut", "Ins")
_("QShortcut", "Insert")
_("QShortcut", "Left")
_("QShortcut", "Media Next")
_("QShortcut", "Media Pause")
_("QShortcut", "Media Play")
_("QShortcut", "Media Previous")
_("QShortcut", "Media Record")
_("QShortcut", "Media Stop")
_("QShortcut", "Menu")
_("QShortcut", "Meta")
_("QShortcut", "Music")
_("QShortcut", "News")
_("QShortcut", "Number Lock")
_("QShortcut", "Num Lock")
_("QShortcut", "NumLock")
_("QShortcut", "Open URL")
_("QShortcut", "Option")
_("QShortcut", "Page Down")
_("QShortcut", "Page Up")
_("QShortcut", "Paste")
_("QShortcut", "Pause")
_("QShortcut", "PgDown")
_("QShortcut", "PgUp")
_("QShortcut", "Refresh")
_("QShortcut", "Reload")
_("QShortcut", "Return")
_("QShortcut", "Right")
_("QShortcut", "Save")
_("QShortcut", "Scroll Lock")
_("QShortcut", "ScrollLock")
_("QShortcut", "Search")
_("QShortcut", "Select")
_("QShortcut", "Send")
_("QShortcut", "Shift")
_("QShortcut", "Space")
_("QShortcut", "Spellchecker")
_("QShortcut", "Split Screen")
_("QShortcut", "Spreadsheet")
_("QShortcut", "Standby")
_("QShortcut", "Stop")
_("QShortcut", "Subtitle")
_("QShortcut", "Support")
_("QShortcut", "Suspend")
_("QShortcut", "SysReq")
_("QShortcut", "Tab")
_("QShortcut", "Task Panel")
_("QShortcut", "Terminal")
_("QShortcut", "Time")
_("QShortcut", "Toggle Media Play/Pause")
_("QShortcut", "Tools")
_("QShortcut", "Top Menu")
_("QShortcut", "Treble Down")
_("QShortcut", "Treble Up")
_("QShortcut", "Up")
_("QShortcut", "Video")
_("QShortcut", "View")
_("QShortcut", "Volume Down")
_("QShortcut", "Volume Mute")
_("QShortcut", "Volume Up")
_("QShortcut", "Zoom In")
_("QShortcut", "Zoom Out")
_("QWhatsThisAction", "What's This?")

########NEW FILE########
__FILENAME__ = mofile
"""
This module contains a loader for MO files, written in 2011 by Wilbert Berendsen.

The module is heavily inspired by the Python gettext library, but allows for reading
all contents of a MO file, also the msgid2's, which are not needed for translating
but are useful e.g. when checking messages and translations for wrong Python
variable fields. Also the msgctxt is supported (the *pgettext methods).

The module provides a MoFile class, representing a MO file.

MoFile(filename)          reads the messages from the given filename,
MoFile.fromData(buffer)   reads the messages from the given bytes-string,
MoFile.fromStream(stream) reads the messages from the given stream.

The four methods 'gettext', 'pgettext', 'ngettext', 'npgettext' are like the
ones in the GNU Gettext library. If a message can't be found the fallback (settable
with the set_fallback() method is consulted. By default a NullMoFile() is used
that returns the messages untranslated. All messages are returned as unicode
strings.

The *lgettext methods are not provided but a wrapper class could easily be
created to return encoded messages.

Besides the MoFile and NullMoFile classes, the module provides some functions
that iterate over the contents of a MO file in different ways.

There are no functions to locate MO files, or to install a MoFile object
as a global translator. You can do this easily yourself e.g.:

import __builtin__
__builtin__._ = lambda *args: translation[len(args)](*args)

mo_instance = MoFile('/path/to/file.mo')

translation = [
    None,
    mo_instance.gettext,
    mo_instance.pgettext,
    mo_instance.ngettext,
    mo_instance.npgettext,
]

This way, the _( ... ) function can be called with one to four arguments, and
calls the correct method to return a translated message.

"""

__all__ = [
    'NullMoFile', 'MoFile',
    'parse_mo', 'parse_mo_split', 'parse_mo_decode',
    'parse_header', 'parse_plural_expr',
]

import re
from struct import unpack

LE_MAGIC = 0x950412de
BE_MAGIC = 0xde120495


class NullMoFile(object):
    """Empty "mo file", returning messages untranslated."""
    def gettext(self, message):
        return message
    
    def ngettext(self, message, message_plural, n):
        return message if n == 1 else message_plural
    
    def pgettext(self, context, message):
        return message
    
    def npgettext(self, context, message, message_plural, n):
        return message if n == 1 else message_plural

    def fallback(self):
        return None


class MoFile(NullMoFile):
    """Represents a MO translation file and provides methods to translate messages."""
    @classmethod
    def fromData(cls, buf):
        """Constructs the MoFile object, reading the messages from a bytes buffer."""
        obj = cls.__new__(cls)
        obj._load(buf)
        return obj
        
    @classmethod
    def fromStream(cls, stream):
        """Constructs the MoFile object, reading the messages from an open stream."""
        return cls.fromData(stream.read())

    def __init__(self, filename):
        """The default constructor reads the messages from the given filename."""
        with open(filename, 'rb') as f:
            self._load(f.read())
    
    def _load(self, buf):
        catalog = {}
        context_catalog = {}
        charset = 'UTF-8'
        self._plural = lambda n: int(n != 1)
        self._info = {}
        for context, msgs, tmsgs in parse_mo_split(buf):
            if msgs[0] == '':
                # header
                info = parse_header(tmsgs[0])
                try:
                    charset = info.get('content-type', '').split('charset=')[1]
                except IndexError:
                    pass
                try:
                    plural = info.get('plural-forms', '').split(';')[1].split('plural=')[1]
                except IndexError:
                    pass
                else:
                    f = parse_plural_expr(plural)
                    if f:
                        self._plural = f
                # store as well
                self._info = dict((k, v.decode(charset)) for k, v in info.items())
            else:
                # decode
                d = context_catalog.setdefault(context.decode(charset), {}) if context else catalog
                msgid1 = msgs[0].decode(charset)
                if len(msgs) > 1:
                    # plural
                    for i, t in enumerate(tmsgs):
                        d[(msgid1, i)] = t.decode(charset)
                else:
                    # singular
                    d[msgid1] = tmsgs[0].decode(charset)
        self._catalog = catalog
        self._context_catalog = context_catalog
        self._fallback = NullMoFile()
        
    def set_fallback(self, fallback):
        """Sets a fallback class to return translations for messages not in this MO file.
        
        If fallback is None, AttributeError is raised when translations are not found.
        By default, fallback is set to a NullMoFile instance that returns the message
        untranslated.
        
        """
        self._fallback = fallback
    
    def fallback(self):
        """Returns the fallback MoFile or NullMoFile object or None.
        
        The fallback is called when a message is not found in our own catalog.
        By default, fallback is set to a NullMoFile instance that returns the message
        untranslated.
        
        """
        return self._fallback
    
    def info(self):
        """Returns the header (catalog description) from the MO-file as a dictionary.
        
        The keys are the header names in lower case, the values unicode strings.
        
        """
        return self._info
    
    def gettext(self, message):
        """Returns the translation of the message."""
        try:
            return self._catalog[message]
        except KeyError:
            return self._fallback.gettext(message)
    
    def ngettext(self, message, message_plural, n):
        """Returns the correct translation (singular or plural) depending on n."""
        try:
            return self._catalog[(message, self._plural(n))]
        except KeyError:
            return self._fallback.ngettext(message, message_plural, n)
    
    def pgettext(self, context, message):
        """Returns the translation of the message in the given context."""
        try:
            return self._context_catalog[context][message]
        except KeyError:
            return self._fallback.pgettext(context, message)
    
    def npgettext(self, context, message, message_plural, n):
        """Returns the correct translation (singular or plural) depending on n, in the given context."""
        try:
            return self._context_catalog[context][(message, self._plural(n))]
        except KeyError:
            return self._fallback.npgettext(context, message, message_plural, n)
    

def parse_mo(buf):
    """Parses the given buffer (a bytes instance) as a MO file.
    
    Yields raw message/translation pairs, not decoded or handled in any other way.
    
    """
    # are we LE or BE?
    magic = unpack('<I', buf[:4])[0]
    if magic == LE_MAGIC:
        version, msgcount, masteridx, transidx = unpack('<4I', buf[4:20])
        ii = '<II'
    elif magic == BE_MAGIC:
        version, msgcount, masteridx, transidx = unpack('>4I', buf[4:20])
        ii = '>II'
    else:
        raise IOError(0, 'Invalid MO data')
    
    buflen = len(buf)
    
    # read the MO buffer and store all data
    for i in range(msgcount):
        mlen, moff = unpack(ii, buf[masteridx:masteridx+8])
        mend = moff + mlen
        tlen, toff = unpack(ii, buf[transidx:transidx+8])
        tend = toff + tlen
        if mend < buflen and tend < buflen:
            msg = buf[moff:mend]
            tmsg = buf[toff:tend]
        else:
            raise IOError(0, 'Corrupt MO data')
        
        yield msg, tmsg
        
        masteridx += 8
        transidx += 8


def parse_header(data):
    """Parses the "header" (the msgstr of the first, empty, msgid) and returns it as a dict.
    
    The names are made lower-case.
    
    """
    info = {}
    lastkey = key = None
    for line in data.splitlines():
        line = line.strip()
        if line:
            if ':' in line:
                key, val = line.split(':', 1)
                key = key.strip().lower()
                val = val.strip()
                info[key] = val
                lastkey = key
            elif lastkey:
                info[lastkey] += b'\n' + line
    return info


def parse_mo_split(buf):
    """Parses the mo file and splits up all messages/translation pairs.
    
    Yields a three-tuple everytime: (context, messages, translations)
    
    where context is None or bytes, and messages and translations are both lists
    of undecoded bytes objects.
    
    """
    for msg, tmsg in parse_mo(buf):
        try:
            context, msg = msg.split(b'\x04')
        except ValueError:
            context = None
        yield context, msg.split(b'\x00'), tmsg.split(b'\x00')


def parse_mo_decode(buf, default_charset="UTF-8"):
    """Parses and splits, returns three-tuples like parse_mo_split but decoded to unicode."""
    charset = default_charset
    for context, msgs, tmsgs in parse_mo_split(buf):
        if msgs[0] == '':
            info = parse_header(tmsgs[0])
            try:
                charset = info.get('content-type', '').split('charset=')[1]
            except IndexError:
                pass
        yield (context.decode(charset) if context else None,
               [msg.decode(charset) for msg in msgs],
               [tmsg.decode(charset) for tmsg in tmsgs])



expr_re = re.compile(r"\d+|>>|<<|[<>!=]=|&&|\|\||[-+*/%^&<>?:|!()n]")


def parse_plural_expr(text):
    """Parses an expression such as the 'plural=<expression>' found in PO/MO files.
    
    Returns a lambda function taking the 'n' argument and returning the plural number.
    Returns None if the expression could not be parsed.
    
    """
    source = iter(expr_re.findall(text))
    
    def _expr():
        result = []
        for token in source:
            if token == '?':
                result.insert(0, 'if')
                result[0:0] = _expr()
                result.append('else')
                result.extend(_expr())
            elif token == ':':
                return result
            elif token == '&&':
                result.append('and')
            elif token == '||':
                result.append('or')
            elif token == '!':
                result.append('not')
            else:
                result.append(token)
                if token == '(':
                    result.extend(_expr())
                elif token == ')':
                    return result
        return result
    
    py_expression = ' '.join(_expr())
    if py_expression:
        code = "lambda n: int({0})".format(py_expression)
        try:
            compiled_code = compile(code, '<plural_expression>', 'eval')
        except Exception:
            return
        return eval(compiled_code, {}, {})


########NEW FILE########
__FILENAME__ = molint
#! python

"""
This script reads a MO file and checks that translated messages do not use named
string formatting fields that do not appear in the original messages.

This would cause keyword errors when the format method is called on a translated
string.
"""

from __future__ import unicode_literals

import string
import sys

import mofile

_parse = string.Formatter().parse

def fields(text):
    """Returns the format field names in text as a set().
    
    If the text contains erroneous formatting delimiters, ValueError is raised.
    
    """
    return set(i[1] for i in _parse(text) if i[1])


def molint(filename):
    """Checks filename for superfluous fields in the translated messages.
    
    Returns True if there are no errors, otherwise prints messages to stderr
    and returns False.
    
    """
    correct = True
    for context, messages, translations in mofile.parse_mo_decode(open(filename, 'rb').read()):

        # collect fields in messages
        s = set()
        for m in messages:
            try:
                s |= fields(m)
            except ValueError:
                pass
        
        if not s:
            continue
        
        # collect superfluous fields in translations
        errors = []
        for t in translations:
            try:
                superfluous = fields(t) - s
            except ValueError:
                errors.append((t, "Erroneous format string"))
            else:
                if superfluous:
                    errors.append((t, "Field{0} {1} not in message".format(
                        's' if len(superfluous) > 1 else '',
                        ', '.join('{{{0}}}'.format(name) for name in superfluous))))
        
        # write out errors if any
        if errors:
            correct = False
            sys.stderr.write(
                "\n{0}: Translation contains errors!\n"
                "  Message{1}:\n".format(filename, '' if len(messages) == 1 else "s"))
            for m in messages:
                sys.stderr.write("    {0}\n".format(m))
            
            sys.stderr.write("  Offending translation{0}:\n".format('' if len(errors) == 1 else "s"))
            
            for t, errmsg in errors:
                sys.stderr.write("    {0}:\n      {1}\n".format(errmsg, t))
    
    return correct


if __name__ == '__main__':
    filenames = sys.argv[1:]
    if not filenames:
        sys.stderr.write(
            "usage: python molint.py <mofiles> ...\n"
            "\n"
            "checks the given MO files if the translations contain erroneous\n"
            "embedded variable names.\n"
        )
        sys.exit(2)

    errorfiles = []
    for filename in filenames:
        if not molint(filename):
            errorfiles.append(filename)

    if errorfiles:
        sys.stderr.write("\nFiles containing errors: {0}\n".format(", ".join(errorfiles)))

    sys.exit(1 if errorfiles else 0)

########NEW FILE########
__FILENAME__ = qtranslator
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Translation of some parts of Qt (like dialog buttons) via our PO files.

The strings that are needed are in the qtmessages.py file in this directory.

"""


from PyQt4.QtCore import QCoreApplication, QTranslator

import app


_translator = None

class Translator(QTranslator):
    """Subclass of QTranslator that gets its messages via the _() function."""
    def translate(self, context, sourceText, disambiguation=""):
        #_debug(context, sourceText)
        return _(context, sourceText)


def installTranslator():
    """Install a QTranslator so Qt's own texts are also translated."""
    global _translator
    if _translator is not None:
        QCoreApplication.removeTranslator(_translator)
    _translator = Translator()
    QCoreApplication.installTranslator(_translator)

# just install again on change, so the widgets get a LanguageChange event
app.languageChanged.connect(installTranslator)
installTranslator()


# DEBUG: show translatable Qt messages once
_debugmessages = set()
def _debug(context, sourceText):
    l = len(_debugmessages)
    _debugmessages.add((context, sourceText))
    if len(_debugmessages) > l:
        print('_' + repr((context, sourceText)))


########NEW FILE########
__FILENAME__ = update-pot
#! python

# This small script creates a POT file for the translations by extracting all messages
# from Python source files.

# Usage:
# python update-pot.py


import glob
import os
import subprocess
import sys

sys.path.insert(0, "..")
import info
import md2pot

# 1. create a temp POT file for the messages, harvested from the source code
command = [
    'xgettext',
    '--language=python',
    '--output=temp1.pot',
    '--package-name={0}'.format(info.name),
    '--package-version={0}'.format(info.version),
    '--msgid-bugs-address={0}'.format(info.maintainer_email),
    '--keyword',                # empty the default keyword list
    '--keyword=_:1c,2,3,4t',    # context, message, plural, count
    '--keyword=_:1,2,3t',       # message, plural, count
    '--keyword=_:1c,2,2t',      # context, message
    '--keyword=_:1,1t',         # message
    '--add-comments=L10N',
]

for root, dirs, files in sorted(os.walk('..')):
    for f in sorted(files):
        if f.endswith('.py') and f[0] != '.':
            command.append(os.path.join(root, f))

result = subprocess.call(command)

# 2. create a temp POT file for the user guide
md2pot.md2pot('temp2.pot', glob.glob('../userguide/*.md'))

# 3. uniq that one
subprocess.call('msguniq -t UTF-8 -o temp3.pot temp2.pot'.split())

# 4. merge the two
subprocess.call('msgcat temp1.pot temp3.pot -o {0}.pot'.format(info.name).split())

# 5. remove the unneeded temp files
os.remove('temp1.pot')
os.remove('temp2.pot')
os.remove('temp3.pot')



########NEW FILE########
__FILENAME__ = pointandclick
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Generic Point and Click handling.
"""

from __future__ import unicode_literals

import os
import collections

from PyQt4.QtCore import QUrl
from PyQt4.QtGui import QTextCursor

import app
import util
import scratchdir
import ly.lex.lilypond
import ly.document
import lydocument


class Links(object):
    """Stores point and click links grouped by filename."""
    def __init__(self):
        self._links = collections.defaultdict(lambda: collections.defaultdict(list))
        self._docs = {}
       
    def add_link(self, filename, line, column, destination):
        """Add a link.
        
        filename, line and column, describe the position in the source file.
        
        destination can be any object that describes where the link points to.
        
        """
        self._links[filename][(line, column)].append(destination)
    
    def finish(self):
        """Call this when you are done with adding links.
        
        This method tries to bind() already loaded documents and starts
        monitoring document open/close events.
        
        You can also use the links as a context manager and then add links.
        On exit, finish() is automatically called.
        
        """
        for filename in self._links:
            for d in app.documents:
                s = scratchdir.scratchdir(d)
                if (s.directory() and util.equal_paths(filename, s.path())
                    or d.url().toLocalFile() == filename):
                    self.bind(filename, d)
        app.documentLoaded.connect(self.slotDocumentLoaded)
        app.documentClosed.connect(self.slotDocumentClosed)
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        self.finish()
    
    def bind(self, filename, doc):
        """Binds the given filename to the given document.
        
        When the document disappears, the binding is removed automatically.
        While a document is bound, textedit links are stored as QTextCursors,
        so they keep their position even if the user changes the document.
        
        """
        if filename not in self._docs:
            self._docs[filename] = BoundLinks(doc, self._links[filename])
    
    def slotDocumentLoaded(self, doc):
        """Called when a new document is loaded, it maybe possible to bind to it."""
        filename = doc.url().toLocalFile()
        if filename in self._links:
            self.bind(filename, doc)
    
    def slotDocumentClosed(self, doc):
        """Called when a document is closed, removes the bound links."""
        for filename, b in self._docs.items():
            if b.document == doc:
                break
        else:
            return
        del self._docs[filename]
    
    def cursor(self, filename, line, column, load=False):
        """Returns the destination of a link as a QTextCursor of the destination document.
        
        If load (defaulting to False) is True, the document is loaded if it is not yet loaded.
        Returns None if the document could not be loaded.
        
        """
        bound = self._docs.get(filename)
        if bound:
            return bound.cursor(line, column)
        elif load and os.path.isfile(filename):
            # this also calls bind(), via app.documentLoaded
            app.openUrl(QUrl.fromLocalFile(filename))
            bound = self._docs.get(filename)
            if bound:
                return bound.cursor(line, column)
    
    def boundLinks(self, doc):
        """Returns the Bound links object for the given text document."""
        for b in self._docs.values():
            if b.document == doc:
                return b


class BoundLinks(object):
    """Stores links as QTextCursors for a document."""
    def __init__(self, doc, links):
        """Creates QTextCursor instances for every link, keeps a reference to the document."""
        self.document = doc
        # make a sorted list of cursors with their [destination, ...] destinations list
        self._cursor_dict = d = {}              # mapping from (line, col) to QTextCursor
        self._cursors = cursors = []            # sorted list of the cursors
        self._destinations = destinations = []  # corresponding list of destinations
        for pos, dest in sorted(links.items()):
            line, column = pos
            b = doc.findBlockByNumber(line - 1)
            if b.isValid():
                c = d[pos] = QTextCursor(doc)
                c.setPosition(b.position() + column)
                cursors.append(c)
                destinations.append(dest)
        
    def cursor(self, line, column):
        """Returns the QTextCursor for the give line/col."""
        return self._cursor_dict.get((line, column))
    
    def cursors(self):
        """Return the list of cursors, sorted on cursor position."""
        return self._cursors
        
    def destinations(self):
        """Return the list of destination lists.
        
        Each destination corresponds with the cursor at the same index in
        the cursors() list. Each destination is a list of destination items
        that were originally added using Links.add_link, because many
        point-and-click objects can point to the same place in the text
        document.
        
        """
        return self._destinations
    
    def indices(self, cursor):
        """Return a Python slice object or None or False.
        
        If a slice, it specifies the range of destinations (in the destinations() list)
        that the given QTextCursor points to. The cursor must of course belong to our document.
        
        If None or False, it means that there is no object in the cursors neighbourhood.
        If False, it means that it is e.g. preferred to clear earlier highlighted objects.
        
        This method performs quite a bit trickery: it also returns the destination when a cursor
        points to the _ending_ point of a slur, beam or phrasing slur.
        
        """
        cursors = self._cursors
        
        def findlink(pos):
            # binary search in list of cursors
            lo, hi = 0, len(cursors)
            while lo < hi:
                mid = (lo + hi) // 2
                if pos < cursors[mid].position():
                    hi = mid
                else:
                    lo = mid + 1
            return lo - 1
        
        if cursor.hasSelection():
            end = findlink(cursor.selectionEnd() - 1)
            if end >= 0:
                start = findlink(cursor.selectionStart())
                if start < 0 or cursors[start].position() < cursor.selectionStart():
                    start += 1
                if start <= end:
                    return slice(start, end+1)
            return False
            
        index = findlink(cursor.position())
        if index < 0:
            return # before all other links
        
        cur2 = cursors[index]
        if cur2.position() < cursor.position():
            # is the cursor at an ending token like a slur end?
            prevcol = -1
            if cur2.block() == cursor.block():
                prevcol = cur2.position() - cur2.block().position()
            col = cursor.position() - cursor.block().position()
            found = False
            tokens = ly.document.Runner(lydocument.Document(cursor.document()))
            tokens.move_to_block(cursor.block(), True)
            for token in tokens.backward_line():
                if token.pos <= prevcol:
                    break
                elif token.pos <= col:
                    if isinstance(token, ly.lex.MatchEnd) and token.matchname in (
                            'slur', 'phrasingslur', 'beam'):
                        # YES! now go backwards to find the opening token
                        nest = 1
                        name = token.matchname
                        for token in tokens.backward():
                            if isinstance(token, ly.lex.MatchStart) and token.matchname == name:
                                nest -= 1
                                if nest == 0:
                                    found = True
                                    break
                            elif isinstance(token, ly.lex.MatchEnd) and token.matchname == name:
                                nest += 1
                        break
            if found:
                index = findlink(tokens.block.position() + token.pos)
                if index < 0 or cursors[index].block() != tokens.block:
                    return
            elif cur2.block() != cursor.block():
                return False
        # highlight it!
        return slice(index, index+1)


def positions(cursor):
    """Return a list of QTextCursors describing the grob the cursor points at.
    
    When the cursor point at e.g. a slur, the returned cursors describe both
    ends of the slur.
    
    The returned list may contain zero to two cursors.
    
    """
    c = lydocument.cursor(cursor)
    c.end = None
    source = lydocument.Source(c, True)
    for token in source.tokens:
        break
    else:
        return []
    
    cur = source.cursor(token, end=0)
    cursors = [cur]
    
    # some heuristic to find the relevant range(s) the linked grob represents
    if isinstance(token, ly.lex.lilypond.Direction):
        # a _, - or ^ is found; find the next token
        for token in source:
            if not isinstance(token, (ly.lex.Space, ly.lex.Comment)):
                break
    end = token.end + source.block.position()
    if token == '\\markup':
        # find the end of the markup expression
        depth = source.state.depth()
        for token in source:
            if source.state.depth() < depth:
                end = token.end + source.block.position()
                break
    elif token == '"':
        # find the end of the string
        for token in source:
            if isinstance(token, ly.lex.StringEnd):
                end = token.end + source.block.position()
                break
    elif isinstance(token, ly.lex.MatchStart):
        # find the end of slur, beam. ligature, phrasing slur, etc.
        name = token.matchname
        nest = 1
        for token in source:
            if isinstance(token, ly.lex.MatchEnd) and token.matchname == name:
                nest -= 1
                if nest == 0:
                    cursors.append(source.cursor(token))
                    break
            elif isinstance(token, ly.lex.MatchStart) and token.matchname == name:
                nest += 1
                
    cur.setPosition(end, QTextCursor.KeepAnchor)
    return cursors


########NEW FILE########
__FILENAME__ = popplerdummy
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A dummy surface only showing a "could not load popplerqt4 module" message.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QLabel, QLayout, QVBoxLayout

import qpopplerview
import app


class Surface(qpopplerview.Surface):
    def __init__(self, view):
        super(Surface, self).__init__(view)
        self._msg = QLabel(openExternalLinks = True)
        layout = QVBoxLayout(sizeConstraint = QLayout.SetFixedSize)
        self.setLayout(layout)
        layout.addWidget(self._msg)
        app.translateUI(self)
    
    def translateUI(self):
        self._msg.setText(_("Could not load the {name} module.").format(
            name = '<a href="https://github.com/wbsoft/python-poppler-qt4">popplerqt4</a>'))
    
    def paintEvent(self, ev):
        super(qpopplerview.Surface, self).paintEvent(ev)



########NEW FILE########
__FILENAME__ = popplerprint
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Prints a PDF (or Poppler) document.

On Mac OS X and Linux, the document is just sent to lpr
(via a dialog).

On Windows, another command can be configured or bitmaps of the poppler document
can be printed.
"""

from __future__ import unicode_literals


import os
import sys
import subprocess

from PyQt4.QtCore import pyqtSignal, QSettings, QTemporaryFile, Qt, QThread
from PyQt4.QtGui import QMessageBox, QPrinter, QPrintDialog, QProgressDialog

import app
import helpers
import fileprinter
import qpopplerview.printer


def print_(doc, filename=None, widget=None):
    """Prints the popplerqt4.Poppler.Document.
    
    The filename is used in the dialog and print job name.
    If the filename is not given, it defaults to a translation of "PDF Document".
    The widget is a widget to use as parent for the print dialog etc.
    
    """
    # Decide how we will print.
    # on Windows and Mac OS X a print command must be specified, otherwise
    # we'll use raster printing
    s = QSettings()
    s.beginGroup("helper_applications")
    cmd = s.value("printcommand", "", type(""))
    use_dialog = s.value("printcommand/dialog", False, bool)
    resolution = s.value("printcommand/dpi", 300, int)
    linux_lpr = False
    
    if os.name != 'nt' and not sys.platform.startswith('darwin'):
        # we're probably on Linux
        if not cmd:
            cmd = fileprinter.lprCommand()
            if cmd:
                linux_lpr = True
        elif cmd.split('/')[-1] in fileprinter.lpr_commands:
            linux_lpr = True

    print_file = filename
    title = os.path.basename(filename) if filename else _("PDF Document")
    printer = QPrinter()
    printer.setDocName(title)
    printer.setPrintRange(QPrinter.AllPages)
    
    if linux_lpr or use_dialog or not cmd:
        dlg = QPrintDialog(printer, widget)
        dlg.setMinMax(1, doc.numPages())
        dlg.setOption(QPrintDialog.PrintToFile, False)
        dlg.setWindowTitle(app.caption(_("Print {filename}").format(filename=title)))
        
        result = dlg.exec_()
        if widget:
            dlg.deleteLater() # because it has a parent
        if not result:
            return # cancelled
    
    if linux_lpr or '$ps' in cmd:
        # make a PostScript file with the desired paper size
        ps = QTemporaryFile()
        if ps.open() and qpopplerview.printer.psfile(doc, printer, ps):
            ps.close()
            print_file = ps.fileName()
    elif cmd:
        if printer.printRange() != QPrinter.AllPages:
            cmd = None # we can't cut out pages from a PDF file
        elif '$pdf' not in cmd:
            cmd += ' $pdf'
    
    command = []
    if linux_lpr:
        # let all converted pages print
        printer.setPrintRange(QPrinter.AllPages)
        command = fileprinter.printCommand(cmd, printer, ps.fileName())
    elif cmd and print_file:
        for arg in helpers.shell_split(cmd):
            if arg in ('$ps', '$pdf'):
                command.append(print_file)
            else:
                arg = arg.replace('$printer', printer.printerName())
                command.append(arg)
    if command:
        if subprocess.call(command):
            QMessageBox.warning(widget, _("Printing Error"),
                _("Could not send the document to the printer."))
        return
    else:
        # Fall back printing of rendered raster images.
        # It is unsure if the Poppler ArthurBackend ever will be ready for
        # good rendering directly to a painter, so we'll fall back to using
        # raster images.
        
        p = Printer()
        p.setDocument(doc)
        p.setPrinter(printer)
        p.setResolution(resolution)
        
        d = QProgressDialog()
        d.setModal(True)
        d.setMinimumDuration(0)
        d.setRange(0, len(p.pageList()) + 1)
        d.canceled.connect(p.abort)
        
        def progress(num, total, page):
            d.setValue(num)
            d.setLabelText(_("Printing page {page} ({num} of {total})...").format(
                page=page, num=num, total=total))
                
        def finished():
            p.deleteLater()
            d.deleteLater()
            d.hide()
            if not p.success and not p.aborted():
                QMessageBox.warning(widget, _("Printing Error"),
                    _("Could not send the document to the printer."))
            
        p.finished.connect(finished)
        p.printing.connect(progress)
        p.start()


class Printer(QThread, qpopplerview.printer.Printer):
    """Simple wrapper that prints the raster images in a background thread."""
    printing = pyqtSignal(int, int, int)
    
    def __init__(self, parent=None):
        QThread.__init__(self, parent)
        qpopplerview.printer.Printer.__init__(self)
        self.success = None
        
    def run(self):
        self.success = self.print_()
        
    def progress(self, num, total, page):
        self.printing.emit(num, total, page)


def printDocument(document, widget=None):
    """Prints the document described by the popplertools.Document.
    
    The widget is a widget to use as parent for the print dialog etc.
    
    """
    print_(document.document(), document.filename(), widget)



########NEW FILE########
__FILENAME__ = popplertools
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Some useful tools dealing with popplerqt4 (PDF) documents.
"""

import os


class Document(object):
    """Represents a (lazily) loaded PDF document."""
    def __init__(self, filename=''):
        self._filename = filename
        self._document = None
        self._dirty = True
        
    def filename(self):
        """Returns the filename, set on init or via setFilename()."""
        return self._filename
    
    def setFilename(self, filename):
        """Sets a filename.
        
        The document will be reloaded next time it is requested.
        
        """
        self._filename = filename
        self._dirty = True
            
    def name(self):
        """Returns the filename without path."""
        return os.path.basename(self._filename)
        
    def document(self):
        """Returns the PDF document the filename points to, reloading if the filename was set.
        
        Can return None, in case the document failed to load.
        
        """
        if self._dirty:
            self._document = self.load()
            self._dirty = False
        return self._document

    def load(self):
        """Should load and return the popplerqt4 Document for our filename."""
        try:
            import popplerqt4
        except ImportError:
            return
        return popplerqt4.Poppler.Document.load(self._filename)



########NEW FILE########
__FILENAME__ = popplerview
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A slightly customized subclass of qpopplerview.View.

This is used throughout Frescobaldi, to obey color settings etc.

"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSettings

import app
import textformats
import qpopplerview


# global setup of background color
def _setbackground():
    colors = textformats.formatData('editor').baseColors
    qpopplerview.cache.options().setPaperColor(colors['paper'])
    qpopplerview.cache.clear()

app.settingsChanged.connect(_setbackground, -1)
_setbackground()


# make small sizes smoother
qpopplerview.cache.options().setOversampleThreshold(96)


class View(qpopplerview.View):
    def __init__(self, parent=None):
        super(View, self).__init__(parent)
        try:
            import popplerqt4
        except ImportError:
            # surface with a "could not load popplerqt4" message
            import popplerdummy
            self.setSurface(popplerdummy.Surface(self))
        self.surface().pageLayout().setDPI(self.physicalDpiX(), self.physicalDpiY())
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
    
    def readSettings(self):
        kineticScrollingActive = QSettings().value("musicview/kinetic_scrolling", True, bool)
        scrollbarsVisible = QSettings().value("musicview/show_scrollbars", True, bool)
        self.setKineticScrolling(kineticScrollingActive)
        self.setScrollbarsVisible(scrollbarsVisible)
        self.redraw() # because of possibly changed background color
        # magnifier size and scale
        s = MagnifierSettings.load()
        self.surface().magnifier().resize(s.size, s.size)
        self.surface().magnifier().setScale(s.scale / 100.0)


class MagnifierSettings(object):
    """Manages settings for the MusicView Magnifier."""
    sizeRange = (200, 800)
    scaleRange = (150, 500)
    
    def __init__(self, size=300, scale=300):
        self.size = size
        self.scale = scale

    @classmethod
    def load(cls):
        """Returns a loaded Magnifier settings instance."""
        self = cls()
        s = QSettings()
        s.beginGroup("musicview/magnifier")
        try:
            self.size = int(s.value("size", self.size))
        except ValueError:
            pass
        try:
            self.scale = int(s.value("scale", self.scale))
        except ValueError:
            pass
        
        self.size = bound(self.size, *cls.sizeRange)
        self.scale = bound(self.scale, *cls.scaleRange)
        return self

    def save(self):
        """Stores the settings."""
        s = QSettings()
        s.beginGroup("musicview/magnifier")
        s.setValue("size", self.size)
        s.setValue("scale", self.scale)


def bound(value, start, end):
    """Clips value so it falls in the int range defined by start and end."""
    return max(start, min(end, value))



########NEW FILE########
__FILENAME__ = ctypes_pypm
#! python
# This module provides the same api via ctypes as John Harrison's pyrex-based
# PortMIDI binding. 
# Don't use this module directly but via the toplevel API of this package.
# Copyright (c) 2011 - 2014 by Wilbert Berendsen, placed in the public domain.

from ctypes import byref, create_string_buffer

from .pm_ctypes import (
    libpm, libpt,
    pmHostError, PmEvent,
    PmTimeProcPtr, NullTimeProcPtr,
    PortMidiStreamPtr,
)

from . import MidiException


__all__ = [
    'TRUE',
    'FALSE',
    'Initialize',
    'Terminate',
    'CountDevices',
    'GetDeviceInfo',
    'GetDefaultInputDeviceID',
    'GetDefaultOutputDeviceID',
    'GetErrorText',
    'Time',
    'Input',
    'Output',
]


FALSE = 0
TRUE = 1


def Initialize():
    libpm.Pm_Initialize()
    # equiv to TIME_START: start timer w/ ms accuracy
    libpt.Pt_Start(1, NullTimeProcPtr, None)


def Terminate():
    libpm.Pm_Terminate()


def GetDeviceInfo(device_id):
    info_ptr = libpm.Pm_GetDeviceInfo(device_id)
    if info_ptr:
        info = info_ptr.contents
        return (
            info.interf,
            info.name,
            bool(info.input),
            bool(info.output),
            bool(info.opened),
        )


CountDevices = libpm.Pm_CountDevices
GetDefaultInputDeviceID = libpm.Pm_GetDefaultInputDeviceID
GetDefaultOutputDeviceID = libpm.Pm_GetDefaultOutputDeviceID
GetErrorText = libpm.Pm_GetErrorText
Time = libpt.Pt_Time


class Output(object):
    buffer_size = 1024
    def __init__(self, device_id, latency=0):
        self.device_id = device_id
        self.latency = latency
        self._midi_stream = PortMidiStreamPtr()
        self._open = False
        self._open_device()

    def _open_device(self):
        err = libpm.Pm_OpenOutput(byref(self._midi_stream), self.device_id,
            None, 0, NullTimeProcPtr, None, self.latency)
        _check_error(err)
        self._open = True

    def Close(self):
        if self._open and GetDeviceInfo(self.device_id)[4]:
            err = libpm.Pm_Abort(self._midi_stream)
            _check_error(err)
            err = libpm.Pm_Close(self._midi_stream)
            _check_error(err)
            self._open = False
    
    __del__ = Close

    def Write(self, data):
        bufsize = self.buffer_size

        if len(data) > bufsize:
            raise ValueError("too much data for buffer")

        BufferType = PmEvent * bufsize
        buf = BufferType()

        for i, event in enumerate(data):
            msg, buf[i].timestamp = event
            if len(msg) > 4 or len(msg) < 1:
                raise ValueError("invalid message size")
            message = 0
            for j, byte in enumerate(msg):
                message += ((byte & 0xFF) << (8*j))
            buf[i].message = message
        err = libpm.Pm_Write(self._midi_stream, buf, len(data))
        _check_error(err)

    def WriteShort(self, status, data1=0, data2=0):
        buf = PmEvent()
        buf.timestamp = libpt.Pt_Time()
        buf.message = (((data2 << 16) & 0xFF0000) |
            ((data1 << 8) & 0xFF00) | (status & 0xFF))
        err = libpm.Pm_Write(self._midi_stream, buf, 1)
        _check_error(err)

    def WriteSysEx(self, timestamp, msg):
        """msg may be a tuple or list of ints, or a bytes string."""
        if isinstance(msg, (tuple, list)):
            msg = array.array('B', msg).tostring()
        cur_time = Time()
        err = libpm.Pm_WriteSysEx(self._midi_stream, timestamp, msg)
        _check_error(err)
        while Time() == cur_time:
            pass


class Input(object):
    def __init__(self, device_id, bufsize=1024):
        self.device_id = device_id
        self.buffer_size = bufsize
        self._midi_stream = PortMidiStreamPtr()
        self._open = False
        self._open_device()

    def _open_device(self):
        err = libpm.Pm_OpenInput(byref(self._midi_stream), self.device_id,
            None, 100, NullTimeProcPtr, None)
        _check_error(err)
        self._open = True

    def Close(self):
        """Closes a midi stream, flushing any pending buffers."""
        if self._open and GetDeviceInfo(self.device_id)[4]:
            err = libpm.Pm_Abort(self._midi_stream)
            _check_error(err)
            err = libpm.Pm_Close(self._midi_stream)
            _check_error(err)
            self._opened = False
        
    __del__ = Close

    def Poll(self):
        return libpm.Pm_Poll(self._midi_stream)

    def Read(self, length):
        bufsize = self.buffer_size
        BufferType = PmEvent * bufsize
        buf = BufferType()

        if not 1 <= length <= bufsize:
            raise ValueError("invalid length")
        num_events = libpm.Pm_Read(self._midi_stream, buf, length)
        _check_error(num_events)

        data = []
        for i in range(num_events):
            ev = buf[i]
            msg = ev.message
            msg = (msg & 255, (msg>>8) & 255, (msg>>16) & 255, (msg>>24) & 255)
            data.append((msg, ev.timestamp))
        return data


def _check_error(err_no):
    if err_no < 0:
        if err_no == pmHostError:
            err_msg = create_string_buffer('\000' * 256)
            libpm.Pm_GetHostErrorText(err_msg, 256)
            err_msg = err_msg.value
        else:
            err_msg = libpm.Pm_GetErrorText(err_no)
        raise MidiException(
            "PortMIDI-ctypes error [{0}]: {1}".format(err_no, err_msg))



########NEW FILE########
__FILENAME__ = pm_ctypes
# This script embeds the PortMidi Portable MIDI library via ctypes.
# It is based on Grant Yoshida's 2007 version with some updates from
# Christopher Arndt from 2009 with some bugs fixed and restructured a bit.

from __future__ import unicode_literals

import os
import sys

from ctypes import (CDLL, CFUNCTYPE, POINTER, Structure, byref, c_char_p,
    c_int32, c_uint, c_void_p, cast, create_string_buffer)

# the basename of the portmidi/porttime libraries on different platforms
_PM_DLL = dict(
    win32 = 'libportmidi-0',
    linux2 = 'portmidi',
    darwin = 'portmidi'
)
_PT_DLL = dict(
    win32 = 'libporttime-0',
    linux2 = 'porttime',
    darwin = 'porttime'
)

if sys.platform.startswith('win'):
    # ctypes.util.find_library() does not implement the full Windows DLL search
    # order, so we have to provide it ourselves, so that the PortMidi DLL can
    # be found. See the docstring of the find_library() function for more
    # information.

    from ctypes import windll, c_wchar_p, create_unicode_buffer

    def get_system_directory():
        """Return the path of the Windos system directory as a unicode string."""
        try:
            windll.kernel32.GetSystemDirectoryW.argtypes = [c_wchar_p, c_uint]
            windll.kernel32.GetSystemDirectoryW.restype = c_uint
        except AttributeError:
            return None
        else:
            path = create_unicode_buffer(256)
            plen = windll.kernel32.GetSystemDirectoryW(path, 256)
            return plen and path.value or None

    def get_windows_directory():
        """Return the path of the Windos directory as a unicode string."""
        try:
            windll.kernel32.GetWindowsDirectoryW.argtypes = [c_wchar_p, c_uint]
            windll.kernel32.GetWindowsDirectoryW.restype = c_uint
        except AttributeError:
            return None
        else:
            path = create_unicode_buffer(256)
            plen = windll.kernel32.GetWindowsDirectoryW(path, 256)
            return plen and path.value or None

    def find_library(name, prepend_paths=None):
        """Find and return the path of the given DLL using the DLL search order.

        'name' should be the basename of the DLL with or without the '.dll'
        extension. If 'prepend_paths' is specified, it should be a list of
        directories to be searched before the default ones.

        The default search order searches these directories:

        - The directory from where the application (i.e. the main Python script)
          is loaded
        - The Windows system directory (e.g. C:\Windows\System32)
        - The Windows 16-bit system directory (e.g. C:\Windows\System)
        - The Windows directory (e.g. C:\Windows)
        - The current directory
        - Any directory named on the PATH environment variable

        """
        windir = get_windows_directory()
        search_paths = (prepend_paths or []) + [
            os.path.dirname(sys.argv[0]),
            get_system_directory(),
            os.path.join(windir, 'System'),
            windir,
            os.curdir
        ] + [p for p in os.environ['PATH'].split(os.pathsep) if p]
        for directory in search_paths:
            fname = os.path.join(directory, name)
            if os.path.exists(fname):
                return fname
            if fname.lower().endswith(".dll"):
                continue
            fname = fname + ".dll"
            if os.path.exists(fname):
                return fname
        return None

    dll_name = find_library(_PM_DLL['win32'], [os.path.dirname(__file__)])
else:
    from ctypes.util import find_library
    dll_name = find_library(_PM_DLL.get(sys.platform, 'portmidi'))
if dll_name is None:
    raise ImportError("Couldn't find the PortMidi library.")

libpm = CDLL(dll_name)
# portmidi mightbe linked against porttime but not actually export its symbols
# so we might need to load the porttime lib dynamically as well.
try:
    libpm.Pt_Time
except AttributeError:
    libpt = CDLL(find_library(_PT_DLL.get(sys.platform, 'porttime')))
else:
    libpt = libpm


# portmidi.h

PmError = c_int32
# PmError enum
pmNoError = 0
pmHostError = -10000
pmInvalidDeviceId = -9999
pmInsufficientMemory = -9998
pmBufferTooSmall = -9997
pmBufferOverflow = -9996
pmBadPtr = -9995
pmBadData = -9994
pmInternalError = -9993
pmBufferMaxSize = -9992

libpm.Pm_Initialize.restype = PmError
libpm.Pm_Terminate.restype = PmError

PmDeviceID = c_int32

PortMidiStreamPtr = c_void_p
PmStreamPtr = PortMidiStreamPtr
PortMidiStreamPtrPtr = POINTER(PortMidiStreamPtr)

libpm.Pm_HasHostError.restype = c_int32
libpm.Pm_HasHostError.argtypes = [PortMidiStreamPtr]

libpm.Pm_GetErrorText.restype = c_char_p
libpm.Pm_GetErrorText.argtypes = [PmError]

libpm.Pm_GetHostErrorText.argtypes = [c_char_p, c_uint]

pmNoDevice = -1

class PmDeviceInfo(Structure):
    _fields_ = [("structVersion", c_int32),
                ("interf", c_char_p),
                ("name", c_char_p),
                ("input", c_int32),
                ("output", c_int32),
                ("opened", c_int32)]

PmDeviceInfoPtr = POINTER(PmDeviceInfo)

libpm.Pm_CountDevices.restype = c_int32
libpm.Pm_GetDefaultOutputDeviceID.restype = PmDeviceID
libpm.Pm_GetDefaultInputDeviceID.restype = PmDeviceID

PmTimestamp = c_int32
PmTimeProcPtr = CFUNCTYPE(PmTimestamp, c_void_p)
NullTimeProcPtr = cast(None, PmTimeProcPtr)

# PmBefore is not defined

libpm.Pm_GetDeviceInfo.argtypes = [PmDeviceID]
libpm.Pm_GetDeviceInfo.restype = PmDeviceInfoPtr

libpm.Pm_OpenInput.restype = PmError
libpm.Pm_OpenInput.argtypes = [PortMidiStreamPtrPtr,
                             PmDeviceID,
                             c_void_p,
                             c_int32,
                             PmTimeProcPtr,
                             c_void_p]

libpm.Pm_OpenOutput.restype = PmError
libpm.Pm_OpenOutput.argtypes = [PortMidiStreamPtrPtr,
                             PmDeviceID,
                             c_void_p,
                             c_int32,
                             PmTimeProcPtr,
                             c_void_p,
                             c_int32]

libpm.Pm_SetFilter.restype = PmError
libpm.Pm_SetFilter.argtypes = [PortMidiStreamPtr, c_int32]

libpm.Pm_SetChannelMask.restype = PmError
libpm.Pm_SetChannelMask.argtypes = [PortMidiStreamPtr, c_int32]

libpm.Pm_Abort.restype = PmError
libpm.Pm_Abort.argtypes = [PortMidiStreamPtr]

libpm.Pm_Close.restype = PmError
libpm.Pm_Close.argtypes = [PortMidiStreamPtr]

PmMessage = c_int32

class PmEvent(Structure):
    _fields_ = [("message", PmMessage),
                ("timestamp", PmTimestamp)]

PmEventPtr = POINTER(PmEvent)

libpm.Pm_Read.restype = PmError
libpm.Pm_Read.argtypes = [PortMidiStreamPtr, PmEventPtr, c_int32]

libpm.Pm_Poll.restype = PmError
libpm.Pm_Poll.argtypes = [PortMidiStreamPtr]

libpm.Pm_Write.restype = PmError
libpm.Pm_Write.argtypes = [PortMidiStreamPtr, PmEventPtr, c_int32]

libpm.Pm_WriteShort.restype = PmError
libpm.Pm_WriteShort.argtypes = [PortMidiStreamPtr, PmTimestamp, c_int32]

libpm.Pm_WriteSysEx.restype = PmError
libpm.Pm_WriteSysEx.argtypes = [PortMidiStreamPtr, PmTimestamp, c_char_p]

# porttime.h

# PtError enum
PtError = c_int32
ptNoError = 0
ptHostError = -10000
ptAlreadyStarted = -9999
ptAlreadyStopped = -9998
ptInsufficientMemory = -9997

PtTimestamp = c_int32
PtCallback = CFUNCTYPE(PmTimestamp, c_void_p)

libpt.Pt_Start.restype = PtError
libpt.Pt_Start.argtypes = [c_int32, PtCallback, c_void_p]

libpt.Pt_Stop.restype = PtError
libpt.Pt_Started.restype = c_int32
libpt.Pt_Time.restype = PtTimestamp


########NEW FILE########
__FILENAME__ = documentation
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Documentation preferences.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSettings, Qt
from PyQt4.QtGui import (QComboBox, QCompleter, QFontComboBox,
    QGridLayout, QLabel, QSpinBox, QVBoxLayout)

import app
import qutil
import icons
import preferences
import widgets.listedit
import widgets.dialog
import lilydoc
import userguide
import language_names


class Documentation(preferences.GroupsPage):
    def __init__(self, dialog):
        super(Documentation, self).__init__(dialog)

        layout = QVBoxLayout()
        self.setLayout(layout)
        
        layout.addWidget(Paths(self))
        layout.addWidget(Browser(self))
        layout.addStretch(1)


class Paths(preferences.Group):
    def __init__(self, page):
        super(Paths, self).__init__(page)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.paths = LilyDocPathsList()
        self.paths.changed.connect(self.changed)
        layout.addWidget(self.paths)
        
        app.translateUI(self)
    
    def translateUI(self):
        self.setTitle(_("Paths to LilyPond Documentation"))
        self.paths.setToolTip(_(
            "Add paths or URLs. See \"What's This\" for more information."))
        self.paths.setWhatsThis(userguide.html("prefs_lilydoc"))
    
    def loadSettings(self):
        try:
            paths = QSettings().value("documentation/paths", [], type(""))
        except TypeError:
            paths = []
        self.paths.setValue(paths)
        
    def saveSettings(self):
        s = QSettings()
        s.beginGroup("documentation")
        paths = self.paths.value()
        if paths:
            s.setValue("paths", paths)
        else:
            s.remove("paths")


class Browser(preferences.Group):
    def __init__(self, page):
        super(Browser, self).__init__(page)
        
        layout = QGridLayout()
        self.setLayout(layout)
        
        self.languagesLabel = QLabel()
        self.languages = QComboBox(currentIndexChanged=self.changed)
        layout.addWidget(self.languagesLabel, 0, 0)
        layout.addWidget(self.languages, 0, 1)
        
        items = ['', '']
        items.extend(language_names.languageName(l, l) for l in lilydoc.translations)
        self.languages.addItems(items)
        
        self.fontLabel = QLabel()
        self.fontChooser = QFontComboBox(currentFontChanged=self.changed)
        self.fontSize = QSpinBox(valueChanged=self.changed)
        self.fontSize.setRange(6, 32)
        self.fontSize.setSingleStep(1)
        
        layout.addWidget(self.fontLabel, 1, 0)
        layout.addWidget(self.fontChooser, 1, 1)
        layout.addWidget(self.fontSize, 1, 2)
        
        app.translateUI(self)
    
    def translateUI(self):
        self.setTitle(_("Documentation Browser"))
        self.languagesLabel.setText(_("Preferred Language:"))
        self.languages.setItemText(0, _("Default"))
        self.languages.setItemText(1, _("English (untranslated)"))
        self.fontLabel.setText(_("Font:"))
        
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("documentation")
        lang = s.value("language", "default", type(""))
        if lang in lilydoc.translations:
            i = lilydoc.translations.index(lang) + 2
        elif lang == "C":
            i = 1
        else:
            i = 0
        self.languages.setCurrentIndex(i)
        
        font = self.font()
        family = s.value("fontfamily", "", type(""))
        if family:
            font.setFamily(family)
        size = s.value("fontsize", 16, int)
        with qutil.signalsBlocked(self.fontChooser, self.fontSize):
            self.fontChooser.setCurrentFont(font)
            self.fontSize.setValue(size)

    def saveSettings(self):
        s = QSettings()
        s.beginGroup("documentation")
        langs = ['default', 'C'] + lilydoc.translations
        s.setValue("language", langs[self.languages.currentIndex()])
        s.setValue("fontfamily", self.fontChooser.currentFont().family())
        s.setValue("fontsize", self.fontSize.value())


class LilyDocPathsList(widgets.listedit.ListEdit):
    def openEditor(self, item):
        
        dlg = widgets.dialog.Dialog(self,
            _("Please enter a local path or a URL:"),
            app.caption("LilyPond Documentation"),
            icon = icons.get('lilypond-run'))
        urlreq = widgets.urlrequester.UrlRequester()
        urlreq.lineEdit.setCompleter(QCompleter([
            "http://lilypond.org/doc/v2.12/",
            "http://lilypond.org/doc/stable/",
            "http://lilypond.org/doc/latest/",
            ], urlreq.lineEdit))
        dlg.setMainWidget(urlreq)
        urlreq.setPath(item.text())
        urlreq.setMinimumWidth(320)
        urlreq.lineEdit.setFocus()
        if dlg.exec_():
            item.setText(urlreq.path())
            return True
        return False



########NEW FILE########
__FILENAME__ = editor
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Helper application preferences.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSettings
from PyQt4.QtGui import (
    QCheckBox, QComboBox, QFileDialog, QGridLayout, QLabel, QSpinBox, 
    QVBoxLayout, QWidget)

import app
import util
import qutil
import icons
import preferences
import widgets.urlrequester


class Editor(preferences.GroupsPage):
    def __init__(self, dialog):
        super(Editor, self).__init__(dialog)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        layout.addWidget(ViewSettings(self))
        layout.addWidget(Highlighting(self))
        layout.addWidget(Indenting(self))
        layout.addWidget(SourceExport(self))
        layout.addStretch()


class ViewSettings(preferences.Group):
    def __init__(self, page):
        super(ViewSettings, self).__init__(page)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.wrapLines = QCheckBox(toggled=self.changed)
        
        layout.addWidget(self.wrapLines)
        app.translateUI(self)
    
    def translateUI(self):
        self.setTitle(_("View Preferences"))
        self.wrapLines.setText(_("Wrap long lines by default"))
        self.wrapLines.setToolTip('<qt>' + _(
            "If enabled, lines that don't fit in the editor width are wrapped "
            "by default. "
            "Note: when the document is displayed by multiple views, they all "
            "share the same line wrapping width, which might look strange."))

    def loadSettings(self):
        s = QSettings()
        s.beginGroup("view_preferences")
        self.wrapLines.setChecked(s.value("wrap_lines", False, bool))
    
    def saveSettings(self):
        s = QSettings()
        s.beginGroup("view_preferences")
        s.setValue("wrap_lines", self.wrapLines.isChecked())


class Highlighting(preferences.Group):
    def __init__(self, page):
        super(Highlighting, self).__init__(page)
        
        layout = QGridLayout(spacing=1)
        self.setLayout(layout)
        
        self.messageLabel = QLabel(wordWrap=True)
        layout.addWidget(self.messageLabel, 0, 0, 1, 2)
        self.labels = {}
        self.entries = {}
        for row, (name, title, default) in enumerate(self.items(), 1):
            self.labels[name] = l = QLabel()
            self.entries[name] = e = QSpinBox()
            e.setRange(0, 60)
            e.valueChanged.connect(page.changed)
            layout.addWidget(l, row, 0)
            layout.addWidget(e, row, 1)
            
        app.translateUI(self)
    
    def items(self):
        """
        Yields (name, title, default) tuples for every setting in this group.
        Default is understood in seconds.
        """
        yield "match", _("Matching Item:"), 1
        
    def translateUI(self):
        self.setTitle(_("Highlighting Options"))
        self.messageLabel.setText(_(
            "Below you can define how long "
            "\"matching\" items like matching brackets or the items "
            "linked through Point-and-Click are highlighted."))
        # L10N: abbreviation for "n seconds" in spinbox, n >= 1, no plural forms
        prefix, suffix = _("{num} sec").split("{num}")
        for name, title, default in self.items():
            self.entries[name].setSpecialValueText(_("Infinite"))
            self.entries[name].setPrefix(prefix)
            self.entries[name].setSuffix(suffix)
            self.labels[name].setText(title)
    
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("editor_highlighting")
        for name, title, default in self.items():
            self.entries[name].setValue(s.value(name, default, int))
    
    def saveSettings(self):
        s= QSettings()
        s.beginGroup("editor_highlighting")
        for name, title, default in self.items():
            s.setValue(name, self.entries[name].value())


class Indenting(preferences.Group):
    def __init__(self, page):
        super(Indenting, self).__init__(page)
        
        layout = QGridLayout(spacing=1)
        self.setLayout(layout)
        
        self.tabwidthBox = QSpinBox(minimum=1, maximum=99)
        self.tabwidthLabel = l = QLabel()
        l.setBuddy(self.tabwidthBox)
        
        self.nspacesBox = QSpinBox(minimum=0, maximum=99)
        self.nspacesLabel = l = QLabel()
        l.setBuddy(self.nspacesBox)
        
        self.dspacesBox = QSpinBox(minimum=0, maximum=99)
        self.dspacesLabel = l = QLabel()
        l.setBuddy(self.dspacesBox)
        
        layout.addWidget(self.tabwidthLabel, 0, 0)
        layout.addWidget(self.tabwidthBox, 0, 1)
        layout.addWidget(self.nspacesLabel, 1, 0)
        layout.addWidget(self.nspacesBox, 1, 1)
        layout.addWidget(self.dspacesLabel, 2, 0)
        layout.addWidget(self.dspacesBox, 2, 1)
        
        self.tabwidthBox.valueChanged.connect(page.changed)
        self.nspacesBox.valueChanged.connect(page.changed)
        self.dspacesBox.valueChanged.connect(page.changed)
        self.translateUI()
        
    def translateUI(self):
        self.setTitle(_("Indenting Preferences"))
        self.tabwidthLabel.setText(_("Visible Tab Width:"))
        self.tabwidthBox.setToolTip(_(
            "The visible width of a Tab character in the editor."))
        self.nspacesLabel.setText(_("Indent text with:"))
        self.nspacesBox.setToolTip(_(
            "How many spaces to use for indenting one level.\n"
            "Move to zero to use a Tab character for indenting."))
        self.nspacesBox.setSpecialValueText(_("Tab"))
        self.dspacesLabel.setText(_("Tab ouside indent inserts:"))
        self.dspacesBox.setToolTip(_(
            "How many spaces to insert when Tab is pressed outside the indent, "
            "elsewhere in the document.\n"
            "Move to zero to insert a literal Tab character in this case."))
        self.nspacesBox.setSpecialValueText(_("Tab"))
        self.dspacesBox.setSpecialValueText(_("Tab"))
        # L10N: abbreviation for "n spaces" in spinbox, n >= 1, no plural forms
        prefix, suffix = _("{num} spaces").split("{num}")
        self.nspacesBox.setPrefix(prefix)
        self.nspacesBox.setSuffix(suffix)
        self.dspacesBox.setPrefix(prefix)
        self.dspacesBox.setSuffix(suffix)

    def loadSettings(self):
        s = QSettings()
        s.beginGroup("indent")
        self.tabwidthBox.setValue(s.value("tab_width", 8, int))
        self.nspacesBox.setValue(s.value("indent_spaces", 2, int))
        self.dspacesBox.setValue(s.value("document_spaces", 8, int))
    
    def saveSettings(self):
        s = QSettings()
        s.beginGroup("indent")
        s.setValue("tab_width", self.tabwidthBox.value())
        s.setValue("indent_spaces", self.nspacesBox.value())
        s.setValue("document_spaces", self.dspacesBox.value())


class SourceExport(preferences.Group):
    def __init__(self, page):
        super(SourceExport, self).__init__(page)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.numberLines = QCheckBox(toggled=self.changed)
        self.inlineStyleCopy = QCheckBox(toggled=self.changed)
        self.copyHtmlAsPlainText = QCheckBox(toggled=self.changed)
        self.inlineStyleExport = QCheckBox(toggled=self.changed)
        self.copyDocumentBodyOnly = QCheckBox(toggled=self.changed)

        layout.addWidget(self.numberLines)
        layout.addWidget(self.inlineStyleCopy)
        layout.addWidget(self.inlineStyleExport)
        layout.addWidget(self.copyHtmlAsPlainText)
        layout.addWidget(self.copyDocumentBodyOnly)

        app.translateUI(self)
    
    def translateUI(self):
        self.setTitle(_("Source Export Preferences"))
        self.numberLines.setText(_("Show line numbers"))
        self.numberLines.setToolTip('<qt>' + _(
            "If enabled, line numbers are shown in exported HTML or printed "
            "source."))
        self.inlineStyleCopy.setText(_("Use inline style when copying colored HTML"))
        self.inlineStyleCopy.setToolTip('<qt>' + _(
            "If enabled, inline style attributes are used when copying "
            "colored HTML to the clipboard. "
            "Otherwise, a CSS stylesheet is embedded."))
        
        self.inlineStyleExport.setText(_("Use inline style when exporting colored HTML"))
        self.inlineStyleExport.setToolTip('<qt>' + _(
            "If enabled, inline style attributes are used when exporing "
            "colored HTML to a file. "
            "Otherwise, a CSS stylesheet is embedded."))
        self.copyHtmlAsPlainText.setText(_("Copy HTML as plain text"))
        self.copyHtmlAsPlainText.setToolTip('<qt>' + _(
            "If enabled, HTML is copied to the clipboard as plain text. "
            "Use this when you want to type HTML formatted code in a "
            "plain text editing environment."))
        self.copyDocumentBodyOnly.setText(_("Copy <pre> element only"))
        self.copyDocumentBodyOnly.setToolTip('<qt>' + _(
            "If enabled, only the HTML contents, wrapped in a PRE tag, will be "
            "copied to the clipboard instead of a full HTML document with a "
            "header section. "
            "May be used in conjunction with the plain text option, with the "
            "inline style option turned off, to copy highlighted code in a "
            "text editor when an external style sheet is already available."))

    def loadSettings(self):
        s = QSettings()
        s.beginGroup("source_export")
        self.numberLines.setChecked(s.value("number_lines", False, bool))
        self.inlineStyleCopy.setChecked(s.value("inline_copy", True, bool))
        self.inlineStyleExport.setChecked(s.value("inline_export", False, bool))
        self.copyHtmlAsPlainText.setChecked(s.value("copy_html_as_plain_text", False, bool))
        self.copyDocumentBodyOnly.setChecked(s.value("copy_document_body_only", False, bool))

    def saveSettings(self):
        s = QSettings()
        s.beginGroup("source_export")
        s.setValue("number_lines", self.numberLines.isChecked())
        s.setValue("inline_copy", self.inlineStyleCopy.isChecked())
        s.setValue("inline_export", self.inlineStyleExport.isChecked())
        s.setValue("copy_html_as_plain_text", self.copyHtmlAsPlainText.isChecked())
        s.setValue("copy_document_body_only", self.copyDocumentBodyOnly.isChecked())



########NEW FILE########
__FILENAME__ = fontscolors
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Fonts and Colors preferences page.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import icons
import preferences
import textformats
import qutil
import ly.colorize

from widgets import ClearButton
from widgets.schemeselector import SchemeSelector
from widgets.colorbutton import ColorButton


class FontsColors(preferences.Page):
    def __init__(self, dialog):
        super(FontsColors, self).__init__(dialog)

        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)
        
        self.scheme = SchemeSelector(self)
        layout.addWidget(self.scheme)
        
        self.printScheme = QCheckBox()
        layout.addWidget(self.printScheme)
        
        hbox = QHBoxLayout()
        self.tree = QTreeWidget(self)
        self.tree.setHeaderHidden(True)
        self.tree.setAnimated(True)
        self.stack = QStackedWidget(self)
        hbox.addWidget(self.tree)
        hbox.addWidget(self.stack)
        layout.addLayout(hbox)
        
        hbox = QHBoxLayout()
        self.fontLabel = QLabel()
        self.fontChooser = QFontComboBox()
        self.fontSize = QDoubleSpinBox()
        self.fontSize.setRange(6.0, 32.0)
        self.fontSize.setSingleStep(0.5)
        self.fontSize.setDecimals(1)
        hbox.addWidget(self.fontLabel)
        hbox.addWidget(self.fontChooser, 1)
        hbox.addWidget(self.fontSize)
        layout.addLayout(hbox)
        
        # add the items to our list
        self.baseColorsItem = i = QTreeWidgetItem()
        self.tree.addTopLevelItem(i)
        self.defaultStylesItem = i = QTreeWidgetItem()
        self.tree.addTopLevelItem(i)
        
        self.defaultStyles = {}
        for name in textformats.defaultStyles:
            self.defaultStyles[name] = i = QTreeWidgetItem()
            self.defaultStylesItem.addChild(i)
            i.name = name
        self.defaultStylesItem.setExpanded(True)
        
        self.allStyles = {}
        for group, styles in ly.colorize.default_mapping():
            i = QTreeWidgetItem()
            children = {}
            self.allStyles[group] = (i, children)
            self.tree.addTopLevelItem(i)
            i.group = group
            for name, base, clss in styles:
                j = QTreeWidgetItem()
                j.name = name
                j.base = base
                i.addChild(j)
                children[name] = j
        
        self.baseColorsWidget = BaseColors(self)
        self.customAttributesWidget = CustomAttributes(self)
        self.emptyWidget = QWidget(self)
        self.stack.addWidget(self.baseColorsWidget)
        self.stack.addWidget(self.customAttributesWidget)
        self.stack.addWidget(self.emptyWidget)
        
        self.tree.currentItemChanged.connect(self.currentItemChanged)
        self.tree.setCurrentItem(self.baseColorsItem)
        self.scheme.currentChanged.connect(self.currentSchemeChanged)
        self.scheme.changed.connect(self.changed)
        self.baseColorsWidget.changed.connect(self.baseColorsChanged)
        self.customAttributesWidget.changed.connect(self.customAttributesChanged)
        self.fontChooser.currentFontChanged.connect(self.fontChanged)
        self.fontSize.valueChanged.connect(self.fontChanged)
        self.printScheme.clicked.connect(self.printSchemeChanged)
        
        app.translateUI(self)
        
    def translateUI(self):
        self.printScheme.setText(_("Use this scheme for printing"))
        self.fontLabel.setText(_("Font:"))
        self.baseColorsItem.setText(0, _("Base Colors"))
        self.defaultStylesItem.setText(0, _("Default Styles"))
        
        self.defaultStyleNames = defaultStyleNames()
        self.allStyleNames = allStyleNames()
        
        for name in textformats.defaultStyles:
            self.defaultStyles[name].setText(0, self.defaultStyleNames[name])
        for group, styles in ly.colorize.default_mapping():
            self.allStyles[group][0].setText(0, self.allStyleNames[group][0])
            for name, base, clss in styles:
                self.allStyles[group][1][name].setText(0, self.allStyleNames[group][1][name])
            
    def currentItemChanged(self, item, previous):
        if item is self.baseColorsItem:
            self.stack.setCurrentWidget(self.baseColorsWidget)
        elif not item.parent():
            self.stack.setCurrentWidget(self.emptyWidget)
        else:
            data = self.data[self.scheme.currentScheme()]
            w = self.customAttributesWidget
            self.stack.setCurrentWidget(w)
            toptext = None
            if item.parent() is self.defaultStylesItem:
                # default style
                w.setTitle(item.text(0))
                w.setTristate(False)
                w.setTextFormat(data.defaultStyles[item.name])
            else:
                # specific style of specific group
                group, name = item.parent().group, item.name
                w.setTitle("{0}: {1}".format(item.parent().text(0), item.text(0)))
                inherit = item.base
                if inherit:
                    toptext = _("(Inherits: {name})").format(name=self.defaultStyleNames[inherit])
                w.setTristate(bool(inherit))
                w.setTextFormat(data.allStyles[group][name])
            w.setTopText(toptext)
    
    def currentSchemeChanged(self):
        scheme = self.scheme.currentScheme()
        if scheme not in self.data:
            self.data[scheme] = textformats.TextFormatData(scheme)
        self.updateDisplay()
        if self.tree.currentItem():
            self.currentItemChanged(self.tree.currentItem(), None)
        with qutil.signalsBlocked(self.printScheme):
            self.printScheme.setChecked(scheme == self._printScheme)
    
    def fontChanged(self):
        data = self.data[self.scheme.currentScheme()]
        data.font = self.fontChooser.currentFont()
        data.font.setPointSizeF(self.fontSize.value())
        self.updateDisplay()
        self.changed.emit()
    
    def printSchemeChanged(self):
        if self.printScheme.isChecked():
            self._printScheme = self.scheme.currentScheme()
        else:
            self._printScheme = None
        self.changed.emit()
    
    def addSchemeData(self, scheme, tfd):
        self.data[scheme] = tfd
        
    def currentSchemeData(self):
        return self.data[self.scheme.currentScheme()]
        
    def updateDisplay(self):
        data = self.data[self.scheme.currentScheme()]
        
        with qutil.signalsBlocked(self.fontChooser, self.fontSize):
            self.fontChooser.setCurrentFont(data.font)
            self.fontSize.setValue(data.font.pointSizeF())
        
        with qutil.signalsBlocked(self):
            # update base colors
            for name in textformats.baseColors:
                self.baseColorsWidget.color[name].setColor(data.baseColors[name])
        
        # update base colors for whole treewidget
        p = QApplication.palette()
        p.setColor(QPalette.Base, data.baseColors['background'])
        p.setColor(QPalette.Text, data.baseColors['text'])
        p.setColor(QPalette.Highlight, data.baseColors['selectionbackground'])
        p.setColor(QPalette.HighlightedText, data.baseColors['selectiontext'])
        self.tree.setPalette(p)
        
        def setItemTextFormat(item, f):
            font = QFont(data.font)
            if f.hasProperty(QTextFormat.ForegroundBrush):
                item.setForeground(0, f.foreground().color())
            else:
                item.setForeground(0, data.baseColors['text'])
            if f.hasProperty(QTextFormat.BackgroundBrush):
                item.setBackground(0, f.background().color())
            else:
                item.setBackground(0, QBrush())
            font.setWeight(f.fontWeight())
            font.setItalic(f.fontItalic())
            font.setUnderline(f.fontUnderline())
            item.setFont(0, font)
            
        # update looks of default styles
        for name in textformats.defaultStyles:
            setItemTextFormat(self.defaultStyles[name], data.defaultStyles[name])
        
        # update looks of all the specific styles
        for group, styles in ly.colorize.default_mapping():
            children = self.allStyles[group][1]
            for name, inherit, clss in styles:
                f = QTextCharFormat(data.defaultStyles[inherit]) if inherit else QTextCharFormat()
                f.merge(data.allStyles[group][name])
                setItemTextFormat(children[name], f)
        
    def baseColorsChanged(self, name):
        # keep data up to date with base colors
        data = self.data[self.scheme.currentScheme()]
        data.baseColors[name] = self.baseColorsWidget.color[name].color()
        self.updateDisplay()
        self.changed.emit()
    
    def customAttributesChanged(self):
        item = self.tree.currentItem()
        if not item or not item.parent():
            return
        data = self.data[self.scheme.currentScheme()]
        if item.parent() is self.defaultStylesItem:
            # a default style has been changed
            data.defaultStyles[item.name] = self.customAttributesWidget.textFormat()
        else:
            # a specific style has been changed
            group, name = item.parent().group, item.name
            data.allStyles[group][name] = self.customAttributesWidget.textFormat()
        self.updateDisplay()
        self.changed.emit()
        
    def import_(self, filename):
        from . import import_export
        import_export.importTheme(filename, self, self.scheme)
        
    def export(self, name, filename):
        from . import import_export
        try:
            import_export.exportTheme(self, name, filename)
        except (IOError, OSError) as e:
            QMessageBox.critical(self, _("Error"), _(
                "Can't write to destination:\n\n{url}\n\n{error}").format(
                url=filename, error=e.strerror))
    
    def loadSettings(self):
        self.data = {} # holds all data with scheme as key
        self._printScheme = QSettings().value("printer_scheme", "default", type(""))
        self.scheme.loadSettings("editor_scheme", "editor_schemes")
        
    def saveSettings(self):
        self.scheme.saveSettings("editor_scheme", "editor_schemes", "fontscolors")
        for scheme in self.scheme.schemes():
            if scheme in self.data:
                self.data[scheme].save(scheme)
        if self._printScheme:
            QSettings().setValue("printer_scheme", self._printScheme)
        else:
            QSettings().remove("printer_scheme")


class BaseColors(QGroupBox):
    
    changed = pyqtSignal(unicode)
    
    def __init__(self, parent=None):
        super(BaseColors, self).__init__(parent)
        
        grid = QGridLayout()
        grid.setSpacing(1)
        self.setLayout(grid)
        
        self.color = {}
        self.labels = {}
        for name in textformats.baseColors:
            c = self.color[name] = ColorButton(self)
            c.colorChanged.connect((lambda name: lambda: self.changed.emit(name))(name))
            l = self.labels[name] = QLabel()
            l.setBuddy(c)
            row = grid.rowCount()
            grid.addWidget(l, row, 0)
            grid.addWidget(c, row, 1)
        
        grid.setRowStretch(grid.rowCount(), 2)
        app.translateUI(self)
        
    def translateUI(self):
        self.setTitle(_("Base Colors"))
        names = baseColorNames()
        for name in textformats.baseColors:
            self.labels[name].setText(names[name])
        

class CustomAttributes(QGroupBox):
    
    changed = pyqtSignal()
    
    def __init__(self, parent=None):
        super(CustomAttributes, self).__init__(parent)
        grid = QGridLayout()
        self.setLayout(grid)
        
        self.toplabel = QLabel()
        self.toplabel.setEnabled(False)
        self.toplabel.setAlignment(Qt.AlignCenter)
        grid.addWidget(self.toplabel, 0, 0, 1, 3)
        
        self.textColor = ColorButton()
        l = self.textLabel = QLabel()
        l.setBuddy(self.textColor)
        grid.addWidget(l, 1, 0)
        grid.addWidget(self.textColor, 1, 1)
        c = ClearButton(iconSize=QSize(16, 16))
        c.clicked.connect(self.textColor.clear)
        grid.addWidget(c, 1, 2)
        
        self.backgroundColor = ColorButton()
        l = self.backgroundLabel = QLabel()
        l.setBuddy(self.backgroundColor)
        grid.addWidget(l, 2, 0)
        grid.addWidget(self.backgroundColor, 2, 1)
        c = ClearButton(iconSize=QSize(16, 16))
        c.clicked.connect(self.backgroundColor.clear)
        grid.addWidget(c, 2, 2)
        
        self.bold = QCheckBox()
        self.italic = QCheckBox()
        self.underline = QCheckBox()
        grid.addWidget(self.bold, 3, 0)
        grid.addWidget(self.italic, 4, 0)
        grid.addWidget(self.underline, 5, 0)
        
        self.underlineColor = ColorButton()
        grid.addWidget(self.underlineColor, 5, 1)
        c = ClearButton(iconSize=QSize(16, 16))
        c.clicked.connect(self.underlineColor.clear)
        grid.addWidget(c, 5, 2)
        grid.setRowStretch(6, 2)
        
        self.textColor.colorChanged.connect(self.changed)
        self.backgroundColor.colorChanged.connect(self.changed)
        self.underlineColor.colorChanged.connect(self.changed)
        self.bold.stateChanged.connect(self.changed)
        self.italic.stateChanged.connect(self.changed)
        self.underline.stateChanged.connect(self.changed)
        
        app.translateUI(self)
        
    def translateUI(self):
        self.textLabel.setText(_("Text"))
        self.backgroundLabel.setText(_("Background"))
        self.bold.setText(_("Bold"))
        self.italic.setText(_("Italic"))
        self.underline.setText(_("Underline"))
    
    def setTopText(self, text):
        self.toplabel.setText(text)
        
    def setTristate(self, enable):
        self._tristate = enable
        self.bold.setTristate(enable)
        self.italic.setTristate(enable)
        self.underline.setTristate(enable)
    
    def textFormat(self):
        """Returns our settings as a QTextCharFormat object."""
        f = QTextCharFormat()
        if self._tristate:
            value = lambda checkbox: [False, None, True][checkbox.checkState()]
        else:
            value = lambda checkbox: checkbox.isChecked()
        res = value(self.bold)
        if res is not None:
            f.setFontWeight(QFont.Bold if res else QFont.Normal)
        res = value(self.italic)
        if res is not None:
            f.setFontItalic(res)
        res = value(self.underline)
        if res is not None:
            f.setFontUnderline(res)
        if self.textColor.color().isValid():
            f.setForeground(self.textColor.color())
        if self.backgroundColor.color().isValid():
            f.setBackground(self.backgroundColor.color())
        if self.underlineColor.color().isValid():
            f.setUnderlineColor(self.underlineColor.color())
        return f

    def setTextFormat(self, f):
        """Sets our widget to the QTextCharFormat settings."""
        block = self.blockSignals(True)
        absent = Qt.PartiallyChecked if self._tristate else Qt.Unchecked
        if f.hasProperty(QTextFormat.FontWeight):
            self.bold.setChecked(f.fontWeight() >= QFont.Bold)
        else:
            self.bold.setCheckState(absent)
        if f.hasProperty(QTextFormat.FontItalic):
            self.italic.setChecked(f.fontItalic())
        else:
            self.italic.setCheckState(absent)
        if f.hasProperty(QTextFormat.TextUnderlineStyle):
            self.underline.setChecked(f.fontUnderline())
        else:
            self.underline.setCheckState(absent)
        
        if f.hasProperty(QTextFormat.ForegroundBrush):
            self.textColor.setColor(f.foreground().color())
        else:
            self.textColor.setColor(QColor())
        if f.hasProperty(QTextFormat.BackgroundBrush):
            self.backgroundColor.setColor(f.background().color())
        else:
            self.backgroundColor.setColor(QColor())
        if f.hasProperty(QTextFormat.TextUnderlineColor):
            self.underlineColor.setColor(f.underlineColor())
        else:
            self.underlineColor.setColor(QColor())
        self.blockSignals(block)



def baseColorNames():
    return {
        # L10N: color of Text
        'text':                _("Text"),
        # L10N: color of Background
        'background':          _("Background"),
        # L10N: color of Selected Text
        'selectiontext':       _("Selected Text"),
        # L10N: color of Selection Background
        'selectionbackground': _("Selection Background"),
        # L10N: color of Current Line
        'current':             _("Current Line"),
        # L10N: color of Marked Line (bookmark)
        'mark':                _("Marked Line"),
        # L10N: color of line with Error
        'error':               _("Error Line"),
        # L10N: color of highlighted search result
        'search':              _("Search Result"),
        # L10N: color of characters that match (e.g. braces, parentheses)
        'match':               _("Matching Character"),
        # L10N: color of paper in music preview
        'paper':               _("Preview Background"),
        # L10N: color of objects highlighting in preview
        'musichighlight':      _("Preview Highlight"),
    }


def defaultStyleNames():
    return {
        # L10N: a basic type of input in the editor
        'keyword':  _("Keyword"),
        # L10N: a basic type of input in the editor
        'function': _("Function"),
        # L10N: a basic type of input in the editor
        'variable': _("Variable"),
        # L10N: a basic type of input in the editor
        'value':    _("Value"),
        # L10N: a basic type of input in the editor
        'string':   _("String"),
        # L10N: a basic type of input in the editor
        'escape':   _("Escape"), # TODO: better translatable name
        # L10N: a basic type of input in the editor
        'comment':  _("Comment"),
        # L10N: a basic type of input in the editor
        'error':    _("Error"),
    }


def allStyleNames():
    return {
        'lilypond': (_("LilyPond"), {
            'pitch':        _("Pitch"),
            'octave':       _("Octave"),
            'duration':     _("Duration"),
            'accidental':   _("Accidental"),
            'octavecheck':  _("Octave Check"),
            'fingering':    _("Fingering"),
                              # L10N: For String instruments like Guitar
            'stringnumber': _("String Number"),
            'slur':         _("Slur"),
            'dynamic':      _("Dynamic"),
            'articulation': _("Articulation"),
            'chord':        _("Chord"),
            'beam':         _("Beam"),
            'check':        _("Check"),
            'repeat':       _("Repeat"),
            'keyword':      _("Keyword"),
            'command':      _("Command"),
            'specifier':    _("Specifier"),
            'usercommand':  _("User Command"),
            'markup':       _("Markup"),
            'lyricmode':    _("Lyric Mode"),
            'lyrictext':    _("Lyric Text"),
            'delimiter':    _("Delimiter"),
            'figbass':      _("Figured Bass"),
            'figbstep':     _("Figured Bass Step"),
            'figbmodif':    _("Figured Bass Modifier"),
            'context':      _("Context"),
            'grob':         _("Layout Object"),
            'property':     _("Property"),
            'variable':     _("Variable"),
            'uservariable': _("User Variable"),
            'value':        _("Value"),
            'string':       _("String"),
            'stringescape': _("Escaped Character"),
            'comment':      _("Comment"),
            'error':        _("Error"),
        }),
        'html': (_("HTML"), {
            'tag':          _("Tag"),
            'lilypondtag':  _("LilyPond Tag"),
            'attribute':    _("Attribute"),
            'value':        _("Value"),
            'entityref':    _("Entity Reference"),
            'comment':      _("Comment"),
            'string':       _("String"),
        }),
        'scheme': (_("Scheme"), {
            'scheme':       _("Scheme"),
            'number':       _("Number"),
            'lilypond':     _("LilyPond Environment"),
            'string':       _("String"),
            'comment':      _("Comment"),
            'keyword':      _("Keyword"),
            'function':     _("Function"),
            'variable':     _("Variable"),
            'constant':     _("Constant"),
            'symbol':       _("Symbol"),
            'delimiter':  _("Delimiter"),
        }),
        'texinfo': (_("Texinfo"), {
            'keyword':      _("Keyword"),
            'block':        _("Block"),
            'escapechar':   _("Escaped Character"),
            'attribute':    _("Attribute"),
            'verbatim':     _("Verbatim"),
            'comment':      _("Comment"),
        }),

    }


########NEW FILE########
__FILENAME__ = general
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Keyboard shortcuts settings page.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import info
import icons
import preferences
import sessions
import util
import po
import remote
import language_names

from widgets.urlrequester import UrlRequester


class GeneralPrefs(preferences.ScrolledGroupsPage):
    def __init__(self, dialog):
        super(GeneralPrefs, self).__init__(dialog)

        layout = QVBoxLayout()
        self.scrolledWidget.setLayout(layout)
        
        layout.addWidget(General(self))
        layout.addWidget(SavingDocument(self))
        layout.addWidget(NewDocument(self))
        layout.addWidget(StartSession(self))


class General(preferences.Group):
    def __init__(self, page):
        super(General, self).__init__(page)
        
        grid = QGridLayout()
        self.setLayout(grid)
        
        self.langLabel = QLabel()
        self.lang = QComboBox(currentIndexChanged=self.changed)
        grid.addWidget(self.langLabel, 0, 0)
        grid.addWidget(self.lang, 0, 1)
        
        self.styleLabel = QLabel()
        self.styleCombo = QComboBox(currentIndexChanged=self.changed)
        grid.addWidget(self.styleLabel, 1, 0)
        grid.addWidget(self.styleCombo, 1, 1)
        
        self.systemIcons = QCheckBox(toggled=self.changed)
        grid.addWidget(self.systemIcons, 2, 0, 1, 3)
        self.splashScreen = QCheckBox(toggled=self.changed)
        grid.addWidget(self.splashScreen, 3, 0, 1, 3)
        self.allowRemote = QCheckBox(toggled=self.changed)
        grid.addWidget(self.allowRemote, 4, 0, 1, 3)
        
        grid.setColumnStretch(2, 1)
        
        # fill in the language combo
        self._langs = ["C", ""]
        self.lang.addItems(('', ''))
        langnames = [(language_names.languageName(lang, lang), lang) for lang in po.available()]
        langnames.sort()
        for name, lang in langnames:
            self._langs.append(lang)
            self.lang.addItem(name)
        
        # fill in style combo
        self.styleCombo.addItem('')
        self.styleCombo.addItems(QStyleFactory.keys())
        
        app.translateUI(self)
    
    def loadSettings(self):
        s = QSettings()
        lang = s.value("language", "", type(""))
        try:
            index = self._langs.index(lang)
        except ValueError:
            index = 1
        self.lang.setCurrentIndex(index)
        style = s.value("guistyle", "", type("")).lower()
        styles = [name.lower() for name in QStyleFactory.keys()]
        try:
            index = styles.index(style) + 1
        except ValueError:
            index = 0
        self.styleCombo.setCurrentIndex(index)
        self.systemIcons.setChecked(s.value("system_icons", True, bool))
        self.splashScreen.setChecked(s.value("splash_screen", True, bool))
        self.allowRemote.setChecked(remote.enabled())
    
    def saveSettings(self):
        s = QSettings()
        s.setValue("language", self._langs[self.lang.currentIndex()])
        s.setValue("system_icons", self.systemIcons.isChecked())
        s.setValue("splash_screen", self.splashScreen.isChecked())
        s.setValue("allow_remote", self.allowRemote.isChecked())
        if self.styleCombo.currentIndex() == 0:
            s.remove("guistyle")
        else:
            s.setValue("guistyle", self.styleCombo.currentText())
        
    def translateUI(self):
        self.setTitle(_("General Preferences"))
        self.langLabel.setText(_("Language:"))
        self.lang.setItemText(0, _("No Translation"))
        self.lang.setItemText(1, _("System Default Language (if available)"))
        self.styleLabel.setText(_("Style:"))
        self.styleCombo.setItemText(0, _("Default"))
        self.systemIcons.setText(_("Use System Icons"))
        self.systemIcons.setToolTip(_(
            "If checked, icons of the desktop icon theme "
            "will be used instead of the bundled icons.\n"
            "This setting takes effect on the next start of {appname}.").format(appname=info.appname))
        self.splashScreen.setText(_("Show Splash Screen on Startup"))
        self.allowRemote.setText(_("Open Files in Running Instance"))
        self.allowRemote.setToolTip(_(
            "If checked, files will be opened in a running Frescobaldi "
            "application if available, instead of starting a new instance."))


class StartSession(preferences.Group):
    def __init__(self, page):
        super(StartSession, self).__init__(page)
        
        grid = QGridLayout()
        self.setLayout(grid)
        
        def changed():
            self.changed.emit()
            self.combo.setEnabled(self.custom.isChecked())
        
        self.none = QRadioButton(toggled=changed)
        self.lastused = QRadioButton(toggled=changed)
        self.custom = QRadioButton(toggled=changed)
        self.combo = QComboBox(currentIndexChanged=changed)
        
        grid.addWidget(self.none, 0, 0, 1, 2)
        grid.addWidget(self.lastused, 1, 0, 1, 2)
        grid.addWidget(self.custom, 2, 0, 1, 1)
        grid.addWidget(self.combo, 2, 1, 1, 1)

        app.translateUI(self)
        
    def translateUI(self):
        self.setTitle(_("Session to load if Frescobaldi is started without arguments"))
        self.none.setText(_("Start with no session"))
        self.lastused.setText(_("Start with last used session"))
        self.custom.setText(_("Start with session:"))
        
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("session")
        startup = s.value("startup", "none", type(""))
        if startup ==  "lastused":
            self.lastused.setChecked(True)
        elif startup == "custom":
            self.custom.setChecked(True)
        else:
            self.none.setChecked(True)
        sessionNames = sessions.sessionNames()
        self.combo.clear()
        self.combo.addItems(sessionNames)
        custom = s.value("custom", "", type(""))
        if custom in sessionNames:
            self.combo.setCurrentIndex(sessionNames.index(custom))

    def saveSettings(self):
        s = QSettings()
        s.beginGroup("session")
        s.setValue("custom", self.combo.currentText())
        if self.custom.isChecked():
            startup = "custom"
        elif self.lastused.isChecked():
            startup = "lastused"
        else:
            startup = "none"
        s.setValue("startup", startup)


class SavingDocument(preferences.Group):
    def __init__(self, page):
        super(SavingDocument, self).__init__(page)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.stripwsp = QCheckBox(toggled=self.changed)
        self.backup = QCheckBox(toggled=self.changed)
        self.metainfo = QCheckBox(toggled=self.changed)
        layout.addWidget(self.stripwsp)
        layout.addWidget(self.backup)
        layout.addWidget(self.metainfo)
        
        hbox = QHBoxLayout()
        layout.addLayout(hbox)
        
        self.basedirLabel = l = QLabel()
        self.basedir = UrlRequester()
        hbox.addWidget(self.basedirLabel)
        hbox.addWidget(self.basedir)
        self.basedir.changed.connect(self.changed)
        app.translateUI(self)
        
    def translateUI(self):
        self.setTitle(_("When saving documents"))
        self.stripwsp.setText(_("Strip trailing whitespace"))
        self.stripwsp.setToolTip(_(
            "If checked, Frescobaldi will remove unnecessary whitespace at the "
            "end of lines (but not inside multi-line strings)."))
        self.backup.setText(_("Keep backup copy"))
        self.backup.setToolTip(_(
            "Frescobaldi always backups a file before overwriting it "
            "with a new version.\n"
            "If checked those backup copies are retained."))
        self.metainfo.setText(_("Remember cursor position, bookmarks, etc."))
        self.basedirLabel.setText(_("Default directory:"))
        self.basedirLabel.setToolTip(_("The default folder for your LilyPond documents (optional)."))
        
    def loadSettings(self):
        s = QSettings()
        self.stripwsp.setChecked(s.value("strip_trailing_whitespace", False, bool))
        self.backup.setChecked(s.value("backup_keep", False, bool))
        self.metainfo.setChecked(s.value("metainfo", True, bool))
        self.basedir.setPath(s.value("basedir", "", type("")))
        
    def saveSettings(self):
        s = QSettings()
        s.setValue("strip_trailing_whitespace", self.stripwsp.isChecked())
        s.setValue("backup_keep", self.backup.isChecked())
        s.setValue("metainfo", self.metainfo.isChecked())
        s.setValue("basedir", self.basedir.path())


class NewDocument(preferences.Group):
    def __init__(self, page):
        super(NewDocument, self).__init__(page)
        
        grid = QGridLayout()
        self.setLayout(grid)
        
        def changed():
            self.changed.emit()
            self.combo.setEnabled(self.template.isChecked())
        
        self.emptyDocument = QRadioButton(toggled=changed)
        self.lilyVersion = QRadioButton(toggled=changed)
        self.template = QRadioButton(toggled=changed)
        self.combo = QComboBox(currentIndexChanged=changed)
        
        grid.addWidget(self.emptyDocument, 0, 0, 1, 2)
        grid.addWidget(self.lilyVersion, 1, 0, 1, 2)
        grid.addWidget(self.template, 2, 0, 1, 1)
        grid.addWidget(self.combo, 2, 1, 1, 1)
        self.loadCombo()
        app.translateUI(self)
        
    def translateUI(self):
        self.setTitle(_("When creating new documents"))
        self.emptyDocument.setText(_("Create an empty document"))
        self.lilyVersion.setText(_("Create a document that contains the LilyPond version statement"))
        self.template.setText(_("Create a document from a template:"))
        from snippet import snippets
        for i, name in enumerate(self._names):
            self.combo.setItemText(i, snippets.title(name))
    
    def loadCombo(self):
        from snippet import snippets
        self._names = [name for name in snippets.names()
                        if snippets.get(name).variables.get('template')]
        self.combo.clear()
        self.combo.addItems([''] * len(self._names))
        
    def loadSettings(self):
        s = QSettings()
        ndoc = s.value("new_document", "empty", type(""))
        template = s.value("new_document_template", "", type(""))
        if template in self._names:
            self.combo.setCurrentIndex(self._names.index(template))
        if ndoc == "template":
            self.template.setChecked(True)
        elif ndoc == "version":
            self.lilyVersion.setChecked(True)
        else:
            self.emptyDocument.setChecked(True)

    def saveSettings(self):
        s = QSettings()
        if self._names and self.template.isChecked():
            s.setValue("new_document", "template")
            s.setValue("new_document_template", self._names[self.combo.currentIndex()])
        elif self.lilyVersion.isChecked():
            s.setValue("new_document", "version")
        else:
            s.setValue("new_document", "empty")


########NEW FILE########
__FILENAME__ = helpers
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Helper application preferences.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSettings
from PyQt4.QtGui import (
    QCheckBox, QComboBox, QFileDialog, QGridLayout, QLabel, QVBoxLayout,
    QWidget)

import app
import util
import qutil
import icons
import preferences
import widgets.urlrequester


class Helpers(preferences.ScrolledGroupsPage):
    def __init__(self, dialog):
        super(Helpers, self).__init__(dialog)
        
        layout = QVBoxLayout()
        self.scrolledWidget.setLayout(layout)
        
        layout.addWidget(Apps(self))
        layout.addWidget(Printing(self))


class Apps(preferences.Group):
    def __init__(self, page):
        super(Apps, self).__init__(page)
        
        layout = QGridLayout(spacing=1)
        self.setLayout(layout)
        
        self.messageLabel = QLabel(wordWrap=True)
        layout.addWidget(self.messageLabel, 0, 0, 1, 2)
        self.labels = {}
        self.entries = {}
        for row, (name, title) in enumerate(self.items(), 1):
            self.labels[name] = l = QLabel()
            self.entries[name] = e = widgets.urlrequester.UrlRequester()
            e.setFileMode(QFileDialog.ExistingFile)
            e.changed.connect(page.changed)
            layout.addWidget(l, row, 0)
            layout.addWidget(e, row, 1)
            
        app.translateUI(self)
    
    def items(self):
        """Yields (name, title) tuples for every setting in this group."""
        yield "pdf", _("PDF:")
        yield "midi", _("MIDI:")
        yield "svg", _("SVG:")
        yield "image", _("Image:")
        yield "browser", _("Browser:")
        yield "email", _("E-Mail:")
        yield "directory", _("File Manager:")
        yield "shell", _("Shell:")
        yield "git", _("Git:")
        
    def translateUI(self):
        self.setTitle(_("Helper Applications"))
        self.messageLabel.setText(_(
            "Below you can enter commands to open different file types. "
            "<code>$f</code> is replaced with the filename, "
            "<code>$u</code> with the URL. "
            "Leave a field empty to use the operating system default "
            "application."))
        for name, title in self.items():
            self.labels[name].setText(title)
        self.entries["email"].setToolTip(_(
            "Command that should accept a mailto: URL."))
        self.entries["shell"].setToolTip(_(
            "Command to open a Terminal or Command window."))
        self.entries["git"].setToolTip(_(
            "Command (base) to run Git versioning actions."))
    
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("helper_applications")
        for name, title in self.items():
            self.entries[name].setPath(s.value(name, "", type("")))
    
    def saveSettings(self):
        s= QSettings()
        s.beginGroup("helper_applications")
        for name, title in self.items():
            s.setValue(name, self.entries[name].path())


class Printing(preferences.Group):
    def __init__(self, page):
        super(Printing, self).__init__(page)
        
        layout = QGridLayout(spacing=1)
        self.setLayout(layout)
        
        self.messageLabel = QLabel(wordWrap=True)
        self.printCommandLabel = QLabel()
        self.printCommand = widgets.urlrequester.UrlRequester()
        self.printCommand.setFileMode(QFileDialog.ExistingFile)
        self.printCommand.changed.connect(page.changed)
        self.printDialogCheck = QCheckBox(toggled=page.changed)
        self.resolutionLabel = QLabel()
        self.resolution = QComboBox(editable=True, editTextChanged=page.changed)
        self.resolution.addItems("300 600 1200".split())
        self.resolution.lineEdit().setInputMask("9000")

        layout.addWidget(self.messageLabel, 0, 0, 1, 2)
        layout.addWidget(self.printCommandLabel, 1, 0)
        layout.addWidget(self.printCommand, 1, 1)
        layout.addWidget(self.printDialogCheck, 2, 0, 1, 2)
        layout.addWidget(self.resolutionLabel, 3, 0)
        layout.addWidget(self.resolution, 3, 1)
        
        app.translateUI(self)
    
    def translateUI(self):
        self.setTitle(_("Printing Music"))
        self.messageLabel.setText(_(
            "Here you can enter a command to print a PDF or PostScript file. "
            "See the Help page for more information about printing music."))
        self.printCommandLabel.setText(_("Printing command:"))
        self.printCommand.setToolTip('<qt>' + _(
            "The printing command is used to print a PostScript or PDF file. "
            "On Linux you don't need this, but on Windows and Mac OS X you can "
            "provide a command to avoid that PDF documents are being printed "
            "using raster images, which is less optimal.\n"
            "<code>$pdf</code> gets replaced with the PDF filename, or alternatively, "
            "<code>$ps</code> is replaced with the PostScript filename. "
            "<code>$printer</code> is replaced with the printer's name to use."))
        self.printDialogCheck.setText(_("Use Frescobaldi's print dialog"))
        self.printDialogCheck.setToolTip('<qt>' + _(
            "If enabled, Frescobaldi will show the print dialog and create a "
            "PDF or PostScript document containing only the selected pages "
            "to print. Otherwise, the command is called directly and is expected "
            "to show a print dialog itself."))
        self.resolutionLabel.setText(_("Resolution:"))
        self.resolution.setToolTip(_(
            "Set the resolution if Frescobaldi prints using raster images."))
    
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("helper_applications")
        self.printCommand.setPath(s.value("printcommand", "", type("")))
        self.printDialogCheck.setChecked(s.value("printcommand/dialog", False, bool))
        with qutil.signalsBlocked(self.resolution):
            self.resolution.setEditText(format(s.value("printcommand/dpi", 300, int)))
    
    def saveSettings(self):
        s= QSettings()
        s.beginGroup("helper_applications")
        s.setValue("printcommand", self.printCommand.path())
        s.setValue("printcommand/dialog", self.printDialogCheck.isChecked())
        s.setValue("printcommand/dpi", int(self.resolution.currentText()))



########NEW FILE########
__FILENAME__ = import_export
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A widget that provides a scheme selector, with New and Remove buttons.
"""

from __future__ import unicode_literals

try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET

from PyQt4.QtGui import (QTextFormat, QMessageBox, QColor, QTextCharFormat,
                         QFont, QFontDatabase, QKeySequence)

import os
import info
import textformats
import app

def exportTheme(widget, schemeName, filename):
    """Saves the colors theme to a file."""
    tfd = widget.currentSchemeData()
    root = ET.Element('frescobaldi-theme')
    root.set('name', schemeName)
    comment = ET.Comment(_comment.format(info=info))
    root.append(comment)
    d = ET.ElementTree(root)
    
    font = tfd.font
    fontfamily = font.family()
    fontsize = str(font.pointSizeF())
    fontElt = ET.Element('font', {'fontFamily': fontfamily, 'fontSize': fontsize})
    root.append(fontElt)
    
    baseColors = ET.Element('baseColors')
    for name, color in tfd.baseColors.items():
        elt = ET.Element(name)
        elt.set('color', color.name())
        baseColors.append(elt)
    
    defaultStyles = ET.Element('defaultStyles')
    for name, fmt in tfd.defaultStyles.items():
        elt = styleToElt(fmt, name)
        if elt is not None:
            defaultStyles.append(elt)
        
    allStyles = ET.Element('allStyles')
    for name, styles in tfd.allStyles.items():
        subElt = ET.Element(name)
        for name, fmt in styles.items():
            elt = styleToElt(fmt, name)
            if elt is not None:
                subElt.append(elt)
        if list(subElt):
            allStyles.append(subElt)
    root.append(baseColors)
    root.append(defaultStyles)
    root.append(allStyles)
    
    indentXml(root)
    d.write(filename, 'UTF-8')

    
def importTheme(filename, widget, schemeWidget):
    """Loads the colors theme from a file"""
    try:
        d = ET.parse(filename)
        root = d.getroot()
        if root.tag != 'frescobaldi-theme':
            raise ValueError(_("No theme found."))
    except Exception as e:
        QMessageBox.critical(widget, app.caption(_("Error")),
        _("Can't read from source:\n\n{url}\n\n{error}").format(
            url=filename, error=e))
        return
    
    schemeWidget.scheme.blockSignals(True)
    key = schemeWidget.addScheme(root.get('name'))
    schemeWidget.scheme.blockSignals(False)
    tfd = textformats.TextFormatData(key)
    
    fontElt = root.find('font')
    
    defaultfont = "Lucida Console" if os.name == "nt" else "monospace"
    if fontElt.get('fontFamily') in QFontDatabase().families():
        fontFamily = fontElt.get('fontFamily')
    else:
        fontFamily = defaultfont
    font = QFont(fontFamily)
    font.setPointSizeF(float(fontElt.get('fontSize')))
    tfd.font = font

    for elt in root.find('baseColors'):
        tfd.baseColors[elt.tag] = QColor(elt.get('color'))
    
    for elt in root.find('defaultStyles'):
        tfd.defaultStyles[elt.tag] = eltToStyle(elt)
    
    for style in root.find('allStyles'):
        if not style in tfd.allStyles:
            tfd.allStyles[style] = {}
        for elt in style:
            tfd.allStyles[style.tag][elt.tag] = eltToStyle(elt)
            
    widget.addSchemeData(key, tfd)
    schemeWidget.disableDefault(False)
    schemeWidget.currentChanged.emit()
    schemeWidget.changed.emit()
   

def exportShortcut(widget, scheme, schemeName, filename):
    """Saves shortcuts to a file."""
    lst = {}
    for item in widget.items():
        col = item.collection.name
        if not col in lst:
            lst[col] = {}
        if not item.isDefault(scheme):
            lst[col][item.name] = item.shortcuts(scheme)
        
    root = ET.Element('frescobaldi-shortcut')
    root.set('name', schemeName)
    comment = ET.Comment(_comment.format(info=info))
    root.append(comment)
    d = ET.ElementTree(root)
    
    for col, shortcuts in lst.items():
        if not shortcuts:
            continue
        colElt = ET.Element('collection')
        colElt.set('name', col)
        root.append(colElt)
        for name, shortList in shortcuts.items():
            nameElt = ET.Element('name')
            nameElt.set('name', name)
            colElt.append(nameElt)
            for seq in shortList:
                shortcutElt = ET.Element('shortcut')
                shortcutElt.text = seq.toString()
                nameElt.append(shortcutElt)
                
    indentXml(root)
    d.write(filename, 'UTF-8')
    


def importShortcut(filename, widget, schemeWidget):
    """Loads shortcuts from a file"""
    try:
        d = ET.parse(filename)
        root = d.getroot()
        if root.tag != 'frescobaldi-shortcut':
            raise ValueError(_("No shortcuts found."))
    except Exception as e:
        QMessageBox.critical(widget, app.caption(_("Error")),
        _("Can't read from source:\n\n{url}\n\n{error}").format(
            url=filename, error=e))
        return
    
    schemeWidget.scheme.blockSignals(True)
    scheme = schemeWidget.addScheme(root.get('name'))
    schemeWidget.scheme.blockSignals(False)
    
    for col in root.findall('collection'):
        for name in col.findall('name'):
            shortcuts = [QKeySequence.fromString(shortcut.text) for shortcut in name.findall('shortcut')]
            item = widget.item(col.attrib['name'], name.attrib['name'])
            if item:
                item.setShortcuts(shortcuts, scheme)
            
    schemeWidget.disableDefault(False)
    schemeWidget.currentChanged.emit()
    schemeWidget.changed.emit()
    
    
def styleToElt(fmt, name):
    elt = ET.Element(name)
    if fmt.hasProperty(QTextFormat.FontWeight):
        elt.set('bold', str(fmt.fontWeight() >= 70))
    if fmt.hasProperty(QTextFormat.FontItalic):
        elt.set('italic', str(fmt.fontItalic()))
    if fmt.hasProperty(QTextFormat.TextUnderlineStyle):
        elt.set('underline', str(fmt.fontUnderline()))
    if fmt.hasProperty(QTextFormat.ForegroundBrush):
        elt.set('textColor', fmt.foreground().color().name())
    if fmt.hasProperty(QTextFormat.BackgroundBrush):
        elt.set('backgroundColor', fmt.background().color().name())
    if fmt.hasProperty(QTextFormat.TextUnderlineColor):
        elt.set('underlineColor', fmt.underlineColor().name())
    
    return elt if elt.attrib else None



def toBool(val):
    return {'True': True, 'False': False}[val]

def eltToStyle(elt):
    fmt = QTextCharFormat()
    if elt.get('bold'):
        fmt.setFontWeight(QFont.Bold if toBool(elt.get('bold')) else QFont.Normal)
    if elt.get('italic'):
        fmt.setFontItalic(toBool(elt.get('italic')))
    if elt.get('underline'):
        fmt.setFontUnderline(toBool(elt.get('underline')))
    if elt.get('textColor'):
        fmt.setForeground(QColor(elt.get('textColor')))
    if elt.get('backgroundColor'):
        fmt.setBackground(QColor(elt.get('backgroundColor')))
    if elt.get('underlineColor'):
        fmt.setUnderlineColor(QColor(elt.get('underlineColor')))
        
    return fmt
        
def indentXml(elem, level=0, tab=2):
    i = "\n" + level*" "*tab
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + " "*tab
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            indentXml(elem, level+1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i
            
              
_comment = """
  Created by {info.appname} {info.version}.
"""  
########NEW FILE########
__FILENAME__ = lilypond
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
LilyPond preferences page
"""

from __future__ import unicode_literals

import os
import sys

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import userguide
import util
import icons
import preferences
import lilypondinfo
import widgets.listedit
import widgets.urlrequester


def settings():
    s = QSettings()
    s.beginGroup("lilypond_settings")
    return s


class LilyPondPrefs(preferences.ScrolledGroupsPage):
    def __init__(self, dialog):
        super(LilyPondPrefs, self).__init__(dialog)

        layout = QVBoxLayout()
        self.scrolledWidget.setLayout(layout)

        layout.addWidget(Versions(self))
        layout.addWidget(Target(self))
        layout.addWidget(Running(self))


class Versions(preferences.Group):
    def __init__(self, page):
        super(Versions, self).__init__(page)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.instances = InfoList(self)
        self.instances.changed.connect(self.changed)
        self.instances.defaultButton.clicked.connect(self.defaultButtonClicked)
        layout.addWidget(self.instances)
        self.auto = QCheckBox(clicked=self.changed)
        layout.addWidget(self.auto)
        app.translateUI(self)
        userguide.openWhatsThis(self)
    
    def defaultButtonClicked(self):
        self._defaultCommand = self.instances.listBox.currentItem()._info.command
        for item in self.instances.items():
            item.display()
        self.changed.emit()
            
    def translateUI(self):
        self.setTitle(_("LilyPond versions to use"))
        self.auto.setText(_("Automatically choose LilyPond version from document"))
        self.auto.setToolTip(_(
            "If checked, the document's version determines the LilyPond version to use.\n"
            "See \"What's This\" for more information."))
        self.auto.setWhatsThis(userguide.html("prefs_lilypond_autoversion") +
            _("See also {link}.").format(link=userguide.link("prefs_lilypond")))

    def loadSettings(self):
        s = settings()
        default = lilypondinfo.default()
        self._defaultCommand = s.value("default", default.command, type(""))
        self.auto.setChecked(s.value("autoversion", False, bool))
        infos = sorted(lilypondinfo.infos(), key=lambda i: i.version())
        if not infos:
            infos = [default]
        items = [InfoItem(info) for info in infos]
        self.instances.setItems(items)
        for item in items:
            if item._info.command == self._defaultCommand:
                self.instances.setCurrentItem(item)
                break
        
    def saveSettings(self):
        infos = [item._info for item in self.instances.items()]
        if infos:
            for info in infos:
                if info.command == self._defaultCommand:
                    break
            else:
                self._defaultCommand = infos[0].command
        else:
            infos = [lilypondinfo.default()]
            self._defaultCommand = infos[0].command
        s = settings()
        s.setValue("default", self._defaultCommand)
        s.setValue("autoversion", self.auto.isChecked())
        lilypondinfo.setinfos(infos)
        lilypondinfo.saveinfos()


class InfoList(widgets.listedit.ListEdit):
    def __init__(self, group):
        self.defaultButton = QPushButton()
        super(InfoList, self).__init__(group)
        self.layout().addWidget(self.defaultButton, 3, 1)
        self.layout().addWidget(self.listBox, 0, 0, 5, 1)
        self.listBox.itemSelectionChanged.connect(self._selectionChanged)
        
    def _selectionChanged(self):
        self.defaultButton.setEnabled(bool(self.listBox.currentItem()))
        
    def translateUI(self):
        super(InfoList, self).translateUI()
        self.defaultButton.setText(_("Set as &Default"))
    
    def infoDialog(self):
        try:
            return self._infoDialog
        except AttributeError:
            self._infoDialog = InfoDialog(self)
            return self._infoDialog

    def createItem(self):
        return InfoItem(lilypondinfo.LilyPondInfo("lilypond"))
    
    def openEditor(self, item):
        dlg = self.infoDialog()
        dlg.loadInfo(item._info)
        dlg.lilypond.lineEdit.setFocus()
        was_default = item._info.command == self.parentWidget()._defaultCommand
        if dlg.exec_():
            item._info = dlg.newInfo()
            if was_default:
                self.parentWidget()._defaultCommand = item._info.command
            return True
        return False

    def itemChanged(self, item):
        item.display()
        self.setCurrentItem(item)
        

class InfoItem(QListWidgetItem):
    def __init__(self, info):
        super(InfoItem, self).__init__()
        self._info = info
    
    def display(self):
        text = self._info.prettyName()
        if self._info.version():
            self.setIcon(icons.get("lilypond-run"))
        else:
            self.setIcon(icons.get("dialog-error"))
        if self._info.command == self.listWidget().parentWidget().parentWidget()._defaultCommand:
            text += " [{0}]".format(_("default"))
        self.setText(text)


class InfoDialog(QDialog):
    def __init__(self, parent):
        super(InfoDialog, self).__init__(parent)
        self.setWindowModality(Qt.WindowModal)
        
        layout = QVBoxLayout()
        layout.setSpacing(10)
        self.setLayout(layout)
        grid = QGridLayout()
        grid.setSpacing(4)
        layout.addLayout(grid)
        
        self.lilyname = QLineEdit()
        self.lilynameLabel = l = QLabel()
        l.setBuddy(self.lilyname)
        grid.addWidget(l, 0, 0)
        grid.addWidget(self.lilyname, 0, 1)
        
        self.lilypond = widgets.urlrequester.UrlRequester()
        self.lilypond.setFileMode(QFileDialog.ExistingFile)
        self.lilypondLabel = l = QLabel()
        l.setBuddy(self.lilypond)
        grid.addWidget(l, 1, 0, 1, 2)
        grid.addWidget(self.lilypond, 2, 0, 1, 2)
        
        self.convert_ly = QLineEdit()
        self.convert_lyLabel = l = QLabel()
        l.setBuddy(self.convert_ly)
        grid.addWidget(l, 3, 0)
        grid.addWidget(self.convert_ly, 3, 1)
        
        self.lilypond_book = QLineEdit()
        self.lilypond_bookLabel = l = QLabel()
        l.setBuddy(self.lilypond_book)
        grid.addWidget(l, 4, 0)
        grid.addWidget(self.lilypond_book, 4, 1)
        
        self.auto = QCheckBox()
        grid.addWidget(self.auto, 5, 1)
        
        layout.addWidget(widgets.Separator())
        b = self.buttons = QDialogButtonBox(self)
        layout.addWidget(b)
        
        b.setStandardButtons(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        b.accepted.connect(self.accept)
        b.rejected.connect(self.reject)
        userguide.addButton(b, "prefs_lilypond")
        app.translateUI(self)
        
    def translateUI(self):
        self.setWindowTitle(app.caption(_("LilyPond")))
        self.lilynameLabel.setText(_("Label:"))
        self.lilynameLabel.setToolTip(_("How this version of LilyPond will be displayed."))
        self.lilypondLabel.setText(_("LilyPond Command:"))
        self.lilypond.lineEdit.setToolTip(_("Name or full path of the LilyPond program."))
        self.convert_lyLabel.setText(_("Convert-ly:"))
        self.lilypond_bookLabel.setText(_("LilyPond-book:"))
        self.auto.setText(_("Include in automatic version selection"))
        
    def loadInfo(self, info):
        """Takes over settings for the dialog from the LilyPondInfo object."""
        self.lilyname.setText(info.name)
        self.lilypond.setPath(info.command)
        self.convert_ly.setText(info.convert_ly)
        self.lilypond_book.setText(info.lilypond_book)
        self.auto.setChecked(info.auto)

    def newInfo(self):
        """Returns a new LilyPondInfo instance for our settings."""
        if sys.platform.startswith('darwin') and self.lilypond.path().endswith('.app'):
            info = lilypondinfo.LilyPondInfo(
                self.lilypond.path() + '/Contents/Resources/bin/lilypond')
        else:
            info = lilypondinfo.LilyPondInfo(self.lilypond.path())
        if self.lilyname.text() and not self.lilyname.text().isspace():
            info.name = self.lilyname.text()
        info.auto = self.auto.isChecked()
        info.convert_ly = self.convert_ly.text()
        info.lilypond_book = self.lilypond_book.text()
        return info


class Running(preferences.Group):
    def __init__(self, page):
        super(Running, self).__init__(page)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.saveDocument = QCheckBox(clicked=self.changed)
        self.deleteFiles = QCheckBox(clicked=self.changed)
        self.noTranslation = QCheckBox(clicked=self.changed)
        self.includeLabel = QLabel()
        self.include = widgets.listedit.FilePathEdit()
        self.include.listBox.setDragDropMode(QAbstractItemView.InternalMove)
        self.include.changed.connect(self.changed)
        layout.addWidget(self.saveDocument)
        layout.addWidget(self.deleteFiles)
        layout.addWidget(self.noTranslation)
        layout.addWidget(self.includeLabel)
        layout.addWidget(self.include)
        app.translateUI(self)
        
    def translateUI(self):
        self.setTitle(_("Running LilyPond"))
        self.saveDocument.setText(_("Save document if possible"))
        self.saveDocument.setToolTip(_(
            "If checked, the document is saved when it is local and modified.\n"
            "Otherwise a temporary file is used to run LilyPond."))
        self.deleteFiles.setText(_("Delete intermediate output files"))
        self.deleteFiles.setToolTip(_(
            "If checked, LilyPond will delete intermediate PostScript files."))
        self.noTranslation.setText(_("Run LilyPond with English messages"))
        self.noTranslation.setToolTip(_(
            "If checked, LilyPond's output messages will be in English.\n"
            "This can be useful for bug reports."))
        self.includeLabel.setText(_("LilyPond include path:"))
    
    def loadSettings(self):
        s = settings()
        self.saveDocument.setChecked(s.value("save_on_run", False, bool))
        self.deleteFiles.setChecked(s.value("delete_intermediate_files", True, bool))
        self.noTranslation.setChecked(s.value("no_translation", False, bool))
        try:
            include_path = s.value("include_path", [], type(""))
        except TypeError:
            include_path = []
        self.include.setValue(include_path)
        
    def saveSettings(self):
        s = settings()
        s.setValue("save_on_run", self.saveDocument.isChecked())
        s.setValue("delete_intermediate_files", self.deleteFiles.isChecked())
        s.setValue("no_translation", self.noTranslation.isChecked())
        s.setValue("include_path", self.include.value())


class Target(preferences.Group):
    def __init__(self, page):
        super(Target, self).__init__(page)
        
        layout = QHBoxLayout()
        self.setLayout(layout)
        
        self.targetPDF = QRadioButton(toggled=page.changed)
        self.targetSVG = QRadioButton(toggled=page.changed)
        
        layout.addWidget(self.targetPDF)
        layout.addWidget(self.targetSVG)
        layout.addStretch()
        app.translateUI(self)
        
    def translateUI(self):
        self.setTitle(_("Default output format"))
        self.targetPDF.setText(_("PDF"))
        self.targetPDF.setToolTip(_(
            "Create PDF (Portable Document Format) documents by default."))
        self.targetSVG.setText(_("SVG"))
        self.targetSVG.setToolTip(_(
            "Create SVG (Scalable Vector Graphics) documents by default."))
    
    def loadSettings(self):
        s = settings()
        target = s.value("default_output_target", "pdf", type(""))
        if target == "svg":
            self.targetSVG.setChecked(True)
            self.targetPDF.setChecked(False)
        else:
            self.targetSVG.setChecked(False)
            self.targetPDF.setChecked(True)
        
    def saveSettings(self):
        s = settings()
        if self.targetSVG.isChecked():
            target = "svg"
        else:
            target = "pdf"
        s.setValue("default_output_target", target)



########NEW FILE########
__FILENAME__ = midi
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
MIDI preferences.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *


import app
import qutil
import icons
import preferences
import midihub
import listmodel


class MidiPrefs(preferences.GroupsPage):
    def __init__(self, dialog):
        super(MidiPrefs, self).__init__(dialog)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        layout.addWidget(MidiPorts(self))
        layout.addWidget(Prefs(self))
        layout.addStretch(0)
    
    def saveSettings(self):
        super(MidiPrefs, self).saveSettings()
        midihub.settingsChanged()


class MidiPorts(preferences.Group):
    def __init__(self, page):
        super(MidiPorts, self).__init__(page)
        
        self._portsMessage = QLabel(wordWrap=True)
        self._playerLabel = QLabel()
        self._playerPort = QComboBox(editable=True,
            editTextChanged=self.changed, insertPolicy=QComboBox.NoInsert)
        self._inputLabel = QLabel()
        self._inputPort = QComboBox(editable=True,
            editTextChanged=self.changed, insertPolicy=QComboBox.NoInsert)
        
        self._reloadMidi = QPushButton(icon=icons.get('view-refresh'))
        self._reloadMidi.clicked.connect(self.refreshMidiPorts)
        
        grid = QGridLayout()
        self.setLayout(grid)
        grid.addWidget(self._portsMessage, 0, 0, 1, 3)
        grid.addWidget(self._playerLabel, 1, 0)
        grid.addWidget(self._playerPort, 1, 1, 1, 2)
        grid.addWidget(self._inputLabel, 2, 0)
        grid.addWidget(self._inputPort, 2, 1, 1, 2)
        grid.addWidget(self._reloadMidi, 3, 2)
        
        app.translateUI(self)
        self.loadMidiPorts()
    
    def translateUI(self):
        self.setTitle(_("MIDI Ports"))
        self._portsMessage.setText(_(
            "Note: There are no MIDI output ports available on your system. "
            "To use MIDI, please check if PortMIDI is installed on your system "
            "and that a MIDI synthesizer is available or connected."))
        self._playerLabel.setText(_("Player output:"))
        self._playerPort.setToolTip(_(
            "The MIDI port to play music to. "
            "See \"What's This\" for more information."))
        self._playerPort.setWhatsThis(_(
            "<p>"
            "This dropdown menu lists the available MIDI output ports on your system. "
            "You can select one, or just type part of a name. "
            "In that case, the first available port name that starts with the "
            "specified characters is used."
            "</p>\n<p>"
            "Click the button to refresh the list, e.g. when you connect a "
            "MIDI device or start a software synthesizer."
            "</p>"))
        self._inputLabel.setText(_("Input port:"))
        self._inputPort.setToolTip(_(
            "The MIDI port to get input from to write notes  "
            "See \"What's This\" for more information."))
        self._inputPort.setWhatsThis(_(
            "<p>"
            "This dropdown menu lists the available MIDI input ports on your system. "
            "You can select one, or just type part of a name. "
            "In that case, the first available port name that starts with the "
            "specified characters is used."
            "</p>\n<p>"
            "Click the button to refresh the list, e.g. when you connect a "
            "MIDI device or start a software synthesizer."
            "</p>"))
        self._reloadMidi.setText(_("Refresh MIDI ports"))

    def loadMidiPorts(self):
        output_ports = midihub.output_ports()
        self._playerPort.setModel(listmodel.ListModel(output_ports))
        input_ports = midihub.input_ports()
        self._inputPort.setModel(listmodel.ListModel(input_ports))
        self._portsMessage.setVisible((not output_ports) and (not input_ports))

    def refreshMidiPorts(self):
        midihub.refresh_ports()
        with qutil.signalsBlocked(self):
            self.loadMidiPorts()
            self.loadSettings()

    def loadSettings(self):
        output_port = midihub.default_output()
        input_port = midihub.default_input()
        s = QSettings()
        s.beginGroup("midi")
        self._playerPort.setEditText(s.value("player/output_port", output_port, type("")))
        self._inputPort.setEditText(s.value("midi/input_port", input_port, type("")))
        
    def saveSettings(self):
        s = QSettings()
        s.beginGroup("midi")
        s.setValue("player/output_port", self._playerPort.currentText())
        s.setValue("midi/input_port", self._inputPort.currentText())


class Prefs(preferences.Group):
    def __init__(self, page):
        super(Prefs, self).__init__(page)
        
        self._closeOutputs = QCheckBox(clicked=self.changed)
        self._pollingLabel = QLabel()
        self._pollingTime = QSpinBox()
        self._pollingTime.setRange(0, 1000)
        self._pollingTime.setSuffix(" ms")
        self._pollingTime.valueChanged.connect(self.changed)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        layout.addWidget(self._closeOutputs)
        app.translateUI(self)
        
        hbox = QHBoxLayout()
        layout.addLayout(hbox)
        
        hbox.addWidget(self._pollingLabel)
        hbox.addWidget(self._pollingTime)
    
    def translateUI(self):
        self.setTitle(_("Preferences"))
        self._closeOutputs.setText(_("Close unused MIDI output"))
        self._closeOutputs.setToolTip(_(
            "Closes unused MIDI ports after one minute. "
            "See \"What's This\" for more information."))
        self._closeOutputs.setWhatsThis(_(
            "<p>If checked, Frescobaldi will close MIDI output ports that are not "
            "used for one minute.</p>\n"
            "<p>This could free up system resources that a software MIDI synthesizer "
            "might be using, thus saving battery power.</p>\n"
            "<p>A side effect is that if you pause a MIDI file for a long time "
            "the instruments are reset to the default piano (instrument 0). "
            "In that case, playing the file from the beginning sets up the "
            "instruments again.</p>\n"))
        self._pollingLabel.setText(_("Polling time for input:"))
        self._pollingTime.setToolTip(_(
            "Polling time for MIDI input. "
            "See \"What's This\" for more information."))
        self._pollingTime.setWhatsThis(_(
            "Sets the time between the polling of the MIDI input port in milliseconds. "
            "Small values lead to faster recognition of incoming MIDI events, but stress "
            "the CPU. 10 ms should be a goot value."))

    def loadSettings(self):
        s = QSettings()
        self._closeOutputs.setChecked(
            s.value("midi/close_outputs", False, bool))
        self._pollingTime.setValue(
            s.value("midi/polling_time", 10, int))
    
    def saveSettings(self):
        s = QSettings()
        s.setValue("midi/close_outputs", self._closeOutputs.isChecked())
        s.setValue("midi/polling_time", self._pollingTime.value())

########NEW FILE########
__FILENAME__ = paths
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Paths preferences page
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import widgets.listedit
import preferences


class Paths(preferences.GroupsPage):
    def __init__(self, dialog):
        super(Paths, self).__init__(dialog)

        layout = QVBoxLayout()
        self.setLayout(layout)
        
        layout.addWidget(HyphenPaths(self))
        layout.addStretch(1)


class HyphenPaths(preferences.Group):
    def __init__(self, page):
        super(HyphenPaths, self).__init__(page)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.listedit = widgets.listedit.FilePathEdit()
        self.listedit.changed.connect(self.changed)
        layout.addWidget(self.listedit)
        
        app.translateUI(self)
        
    def translateUI(self):
        self.setTitle(_("Folders containing hyphenation dictionaries"))
        
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("hyphenation")
        try:
            paths = s.value("paths", [], type(""))
        except TypeError:
            paths = []
        self.listedit.setValue(paths)
        
    def saveSettings(self):
        s = QSettings()
        s.beginGroup("hyphenation")
        paths = self.listedit.value()
        if paths:
            s.setValue("paths", paths)
        else:
            s.remove("paths")



########NEW FILE########
__FILENAME__ = shortcuts
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Keyboard shortcuts settings page.
"""

from __future__ import unicode_literals

import itertools

from PyQt4.QtCore import QSettings, Qt
from PyQt4.QtGui import (
    QAction, QKeySequence, QMessageBox, QPushButton, QTreeWidget,
    QTreeWidgetItem, QVBoxLayout)

import app
import actioncollectionmanager
import icons
import qutil
import preferences

from widgets.shortcuteditdialog import ShortcutEditDialog
from widgets.schemeselector import SchemeSelector

_lastaction = '' # last selected action name (saved during running but not on exit)


class Shortcuts(preferences.Page):
    def __init__(self, dialog):
        super(Shortcuts, self).__init__(dialog)
        
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)
        
        self.scheme = SchemeSelector(self)
        layout.addWidget(self.scheme)
        self.tree = QTreeWidget(self)
        self.tree.setHeaderLabels([_("Command"), _("Shortcut")])
        self.tree.setRootIsDecorated(False)
        self.tree.setColumnCount(2)
        self.tree.setAllColumnsShowFocus(True)
        self.tree.setAnimated(True)
        layout.addWidget(self.tree)
        
        self.edit = QPushButton(icons.get("preferences-desktop-keyboard-shortcuts"), '')
        layout.addWidget(self.edit)
        
        # signals
        self.scheme.currentChanged.connect(self.slotSchemeChanged)
        self.scheme.changed.connect(self.changed)
        self.tree.currentItemChanged.connect(self.slotCurrentItemChanged)
        self.tree.itemDoubleClicked.connect(self.editCurrentItem)
        self.edit.clicked.connect(self.editCurrentItem)
        
        # make a dict of all actions with the actions as key and the names as
        # value, with the collection prepended (for loading/saving)
        win = dialog.parent()
        allactions = {}
        for collection in actioncollectionmanager.manager(win).actionCollections():
            for name, action in collection.actions().items():
                allactions[action] = (collection, name)
        
        # keep a list of actions not in the menu structure
        left = allactions.keys()
        
        def add_actions(menuitem, actions):
            """Add actions to a QTreeWidgetItem."""
            for a in actions:
                if a.menu():
                    item = build_menu_item(a)
                    if item.childCount():
                        menuitem.addChild(item)
                elif a in left:
                    left.remove(a)
                    menuitem.addChild(ShortcutItem(a, *allactions[a]))
            menuitem.setFlags(Qt.ItemIsEnabled) # disable selection
            
        def build_menu_item(action):
            """Return a QTreeWidgetItem with children for all the actions in the submenu."""
            menuitem = QTreeWidgetItem()
            text = qutil.removeAccelerator(action.text())
            menuitem.setText(0, _("Menu {name}").format(name=text))
            add_actions(menuitem, action.menu().actions())
            return menuitem
        
        # present the actions nicely ordered as in the menus
        for a in win.menuBar().actions():
            menuitem = build_menu_item(a)
            if menuitem.childCount():
                self.tree.addTopLevelItem(menuitem)
        
        # sort leftover actions
        left.sort(key=lambda i: i.text())
        
        # show actions that are left, grouped by collection
        titlegroups = {}
        for a in left[:]: # copy
            collection, name = allactions[a]
            if collection.title():
                titlegroups.setdefault(collection.title(), []).append(a)
                left.remove(a)
        for title in sorted(titlegroups):
            item = QTreeWidgetItem(["{0}:".format(title)])
            for a in titlegroups[title]:
                item.addChild(ShortcutItem(a, *allactions[a]))
            self.tree.addTopLevelItem(item)
            item.setFlags(Qt.ItemIsEnabled) # disable selection
            
        # show other actions that were not in the menus
        item = QTreeWidgetItem([_("Other commands:")])
        for a in left:
            if a.text() and not a.menu():
                item.addChild(ShortcutItem(a, *allactions[a]))
        if item.childCount():
            self.tree.addTopLevelItem(item)
            item.setFlags(Qt.ItemIsEnabled) # disable selection
        
        self.tree.expandAll()
        
        item = self.tree.topLevelItem(0).child(0)
        if _lastaction:
            # find the previously selected item
            for i in self.items():
                if i.name == _lastaction:
                    item = i
                    break
        self.tree.setCurrentItem(item)
        self.tree.resizeColumnToContents(0)
        
    def items(self):
        """Yield all the items in the actions tree."""
        def children(item):
            for i in range(item.childCount()):
                c = item.child(i)
                if c.childCount():
                    for c1 in children(c):
                        yield c1
                else:
                    yield c
        for c in children(self.tree.invisibleRootItem()):
            yield c
    
    def item(self, collection, name):
        for item in self.items():
            if item.collection.name == collection and item.name == name:
                return item
             
    def saveSettings(self):
        self.scheme.saveSettings("shortcut_scheme", "shortcut_schemes", "shortcuts")
        for item in self.items():
            for scheme in self.scheme.schemes():
                item.save(scheme)
            item.clearSettings()
            item.switchScheme(self.scheme.currentScheme())
        
    def loadSettings(self):
        self.scheme.loadSettings("shortcut_scheme", "shortcut_schemes")
        # clear the settings in all the items
        for item in self.items():
            item.clearSettings()
            item.switchScheme(self.scheme.currentScheme())
        
    def slotSchemeChanged(self):
        """Called when the Scheme combobox is changed by the user."""
        for item in self.items():
            item.switchScheme(self.scheme.currentScheme())
        
    def slotCurrentItemChanged(self, item):
        if isinstance(item, ShortcutItem):
            self.edit.setText(
                _("&Edit Shortcut for \"{name}\"").format(name=item.text(0)))
            self.edit.setEnabled(True)
            global _lastaction
            _lastaction = item.name
        else:
            self.edit.setText(_("(no shortcut)"))
            self.edit.setEnabled(False)
        
    def import_(self, filename):
        from . import import_export
        import_export.importShortcut(filename, self, self.scheme)
        
    def export(self, name, filename):
        from . import import_export
        try:
            import_export.exportShortcut(self, self.scheme.currentScheme(), name, filename)
        except (IOError, OSError) as e:
            QMessageBox.critical(self, _("Error"), _(
                "Can't write to destination:\n\n{url}\n\n{error}").format(
                url=filename, error=e.strerror))
    
    def findShortcutConflict(self, shortcut):
        """Find the possible shortcut conflict and return the conflict name."""
        if shortcut:
            item = self.tree.currentItem()
            if not isinstance(item, ShortcutItem):
                return None
            scheme = self.scheme.currentScheme()
            for i in self.items():
                a = i.action(scheme)
                if i != item and a.shortcuts():
                    for s1 in a.shortcuts():
                        if s1.matches(shortcut) or shortcut.matches(s1):
                            return qutil.removeAccelerator(a.text())
        return None           
    
    def editCurrentItem(self):
        item = self.tree.currentItem()
        if not isinstance(item, ShortcutItem):
            return

        dlg = ShortcutEditDialog(self, self.findShortcutConflict)
        scheme = self.scheme.currentScheme()
        action = item.action(scheme)
        default = item.defaultShortcuts() or None
        if dlg.editAction(action, default):
            shortcuts = action.shortcuts()
            # check for conflicts
            conflicting = []
            for i in self.items():
                if i is not item:
                    for s1, s2 in itertools.product(i.shortcuts(scheme), shortcuts):
                        if s1.matches(s2) or s2.matches(s1):
                            conflicting.append(i)
            if conflicting:
                for i in conflicting:
                    l = i.shortcuts(scheme)
                    for s1 in list(l): # copy
                        for s2 in shortcuts:
                            if s1.matches(s2) or s2.matches(s1):
                                l.remove(s1)
                    i.setShortcuts(l, scheme)
                
            # store the shortcut
            item.setShortcuts(shortcuts, scheme)
            self.changed.emit()

        
class ShortcutItem(QTreeWidgetItem):
    def __init__(self, action, collection, name):
        QTreeWidgetItem.__init__(self)
        self.collection = collection
        self.name = name
        self.setIcon(0, action.icon())
        self.setText(0, qutil.removeAccelerator(action.text()))
        self._shortcuts = {}
        
    def clearSettings(self):
        self._shortcuts.clear()
    
    def action(self, scheme):
        """Returns a new QAction that represents our item.
        
        The action contains the text, icon and current shortcut.
        
        """
        action = QAction(self.icon(0), self.text(0).replace('&', '&&'), None)
        action.setShortcuts(self._shortcuts[scheme][0])
        return action
    
    def shortcuts(self, scheme):
        """Returns the list of shortcuts currently set for scheme."""
        return list(self._shortcuts[scheme][0])
    
    def isDefault(self, scheme):
        return self._shortcuts[scheme][1]
    
    def setShortcuts(self, shortcuts, scheme):
        default = shortcuts == self.defaultShortcuts()
        self._shortcuts[scheme] = (shortcuts, default)
        self.display(scheme)
        
    def defaultShortcuts(self):
        """Returns a (possibly empty) list of QKeySequence objects.
        
        The list represents the default shortcut for this item, if any.
        
        """
        return self.collection.defaults().get(self.name, [])
        
    def switchScheme(self, scheme):
        if scheme not in self._shortcuts:
            s = QSettings()
            key = "shortcuts/{0}/{1}/{2}".format(scheme, self.collection.name, self.name)
            if s.contains(key):
                try:
                    shortcuts = s.value(key, [], QKeySequence)
                except TypeError:
                    # PyQt4 raises TypeError when an empty list was stored
                    shortcuts = []
                self._shortcuts[scheme] = (shortcuts, False)
            else:
                # default
                self._shortcuts[scheme] = (self.defaultShortcuts(), True)
        self.display(scheme)
    
    def save(self, scheme):
        try:
            shortcuts, default = self._shortcuts[scheme]
        except KeyError:
            return
        s =QSettings()
        key = "shortcuts/{0}/{1}/{2}".format(scheme, self.collection.name, self.name)
        if default:
            s.remove(key)
        else:
            s.setValue(key, shortcuts)
            
    def display(self, scheme):
        text = ''
        shortcuts, default = self._shortcuts[scheme]
        if shortcuts:
            text = shortcuts[0].toString(QKeySequence.NativeText)
            if len(shortcuts) > 1:
                text += "..."
            if default:
                text += "  " + _("(default)")
        self.setText(1, text)
        
        


########NEW FILE########
__FILENAME__ = tools
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Per-tool preferences.
"""

from __future__ import unicode_literals

import re

from PyQt4.QtCore import QSettings, Qt
from PyQt4.QtGui import (
    QAbstractItemView, QCheckBox, QDoubleSpinBox, QFont, QFontComboBox,
    QGridLayout, QHBoxLayout, QLabel, QPushButton, QSlider, QSpinBox,
    QVBoxLayout, QWidget)

import app
import userguide
import qutil
import preferences
import popplerview
import widgets.dialog
import widgets.listedit
import documentstructure


class Tools(preferences.ScrolledGroupsPage):
    def __init__(self, dialog):
        super(Tools, self).__init__(dialog)

        layout = QVBoxLayout()
        self.scrolledWidget.setLayout(layout)
        
        layout.addWidget(LogTool(self))
        layout.addWidget(MusicView(self))
        layout.addWidget(CharMap(self))
        layout.addWidget(DocumentList(self))
        layout.addWidget(Outline(self))
        layout.addStretch(1)
            

class LogTool(preferences.Group):
    def __init__(self, page):
        super(LogTool, self).__init__(page)
        
        layout = QVBoxLayout()
        self.setLayout(layout)

        self.fontLabel = QLabel()
        self.fontChooser = QFontComboBox(currentFontChanged=self.changed)
        self.fontSize = QDoubleSpinBox(valueChanged=self.changed)
        self.fontSize.setRange(6.0, 32.0)
        self.fontSize.setSingleStep(0.5)
        self.fontSize.setDecimals(1)

        box = QHBoxLayout()
        box.addWidget(self.fontLabel)
        box.addWidget(self.fontChooser, 1)
        box.addWidget(self.fontSize)
        layout.addLayout(box)
        
        self.showlog = QCheckBox(toggled=self.changed)
        layout.addWidget(self.showlog)
        
        self.rawview = QCheckBox(toggled=self.changed)
        layout.addWidget(self.rawview)
        
        self.hideauto = QCheckBox(toggled=self.changed)
        layout.addWidget(self.hideauto)
        
        app.translateUI(self)
        
    def translateUI(self):
        self.setTitle(_("LilyPond Log"))
        self.fontLabel.setText(_("Font:"))
        self.showlog.setText(_("Show log when a job is started"))
        self.rawview.setText(_("Display plain log output"))
        self.rawview.setToolTip(_(
            "If checked, Frescobaldi will not shorten filenames in the log output."""))
        self.hideauto.setText(_("Hide automatic engraving jobs"))
        self.hideauto.setToolTip(_(
            "If checked, Frescobaldi will not show the log for automatically\n"
            "started engraving jobs (LilyPond->Auto-engrave)."))
    
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("log")
        font = QFont(s.value("fontfamily", "monospace", type("")))
        font.setPointSizeF(s.value("fontsize", 9.0, float))
        with qutil.signalsBlocked(self.fontChooser, self.fontSize):
            self.fontChooser.setCurrentFont(font)
            self.fontSize.setValue(font.pointSizeF())
        self.showlog.setChecked(s.value("show_on_start", True, bool))
        self.rawview.setChecked(s.value("rawview", True, bool))
        self.hideauto.setChecked(s.value("hide_auto_engrave", False, bool))

    def saveSettings(self):
        s = QSettings()
        s.beginGroup("log")
        s.setValue("fontfamily", self.fontChooser.currentFont().family())
        s.setValue("fontsize", self.fontSize.value())
        s.setValue("show_on_start", self.showlog.isChecked())
        s.setValue("rawview", self.rawview.isChecked())
        s.setValue("hide_auto_engrave", self.hideauto.isChecked())


class MusicView(preferences.Group):
    def __init__(self, page):
        super(MusicView, self).__init__(page)
        
        layout = QGridLayout()
        self.setLayout(layout)
        
        self.newerFilesOnly = QCheckBox(toggled=self.changed)
        layout.addWidget(self.newerFilesOnly, 0, 0, 1, 3)
        
        self.magnifierSizeLabel = QLabel()
        self.magnifierSizeSlider = QSlider(Qt.Horizontal, valueChanged=self.changed)
        self.magnifierSizeSlider.setSingleStep(50)
        self.magnifierSizeSlider.setRange(*popplerview.MagnifierSettings.sizeRange)
        self.magnifierSizeSpinBox = QSpinBox()
        self.magnifierSizeSpinBox.setRange(*popplerview.MagnifierSettings.sizeRange)
        self.magnifierSizeSpinBox.valueChanged.connect(self.magnifierSizeSlider.setValue)
        self.magnifierSizeSlider.valueChanged.connect(self.magnifierSizeSpinBox.setValue)
        layout.addWidget(self.magnifierSizeLabel, 1, 0)
        layout.addWidget(self.magnifierSizeSlider, 1, 1)
        layout.addWidget(self.magnifierSizeSpinBox, 1, 2)
        
        self.magnifierScaleLabel = QLabel()
        self.magnifierScaleSlider = QSlider(Qt.Horizontal, valueChanged=self.changed)
        self.magnifierScaleSlider.setSingleStep(50)
        self.magnifierScaleSlider.setRange(*popplerview.MagnifierSettings.scaleRange)
        self.magnifierScaleSpinBox = QSpinBox()
        self.magnifierScaleSpinBox.setRange(*popplerview.MagnifierSettings.scaleRange)
        self.magnifierScaleSpinBox.valueChanged.connect(self.magnifierScaleSlider.setValue)
        self.magnifierScaleSlider.valueChanged.connect(self.magnifierScaleSpinBox.setValue)
        layout.addWidget(self.magnifierScaleLabel, 2, 0)
        layout.addWidget(self.magnifierScaleSlider, 2, 1)
        layout.addWidget(self.magnifierScaleSpinBox, 2, 2)
        
        self.enableKineticScrolling = QCheckBox(toggled=self.changed)
        layout.addWidget(self.enableKineticScrolling)
        self.showScrollbars = QCheckBox(toggled=self.changed)
        layout.addWidget(self.showScrollbars)
        app.translateUI(self)
        
    def translateUI(self):
        self.setTitle(_("Music View"))
        self.newerFilesOnly.setText(_("Only load updated PDF documents"))
        self.newerFilesOnly.setToolTip(_(
            "If checked, Frescobaldi will not open PDF documents that are not\n"
            "up-to-date (i.e. the source file has been modified later)."))
        self.magnifierSizeLabel.setText(_("Magnifier Size:"))
        self.magnifierSizeLabel.setToolTip(_(
            "Size of the magnifier glass (Ctrl+Click in the Music View)."))
        # L10N: as in "400 pixels", appended after number in spinbox, note the leading space
        self.magnifierSizeSpinBox.setSuffix(_(" pixels"))
        self.magnifierScaleLabel.setText(_("Magnifier Scale:"))
        self.magnifierScaleLabel.setToolTip(_(
            "Magnification of the magnifier."))
        self.magnifierScaleSpinBox.setSuffix(_("percent unit sign", "%"))
        # L10N: "Kinetic Scrolling" is a checkbox label, as in "Enable Kinetic Scrolling"
        self.enableKineticScrolling.setText(_("Kinetic Scrolling"))
        self.showScrollbars.setText(_("Show Scrollbars"))
            
    def loadSettings(self):
        s = popplerview.MagnifierSettings.load()
        self.magnifierSizeSlider.setValue(s.size)
        self.magnifierScaleSlider.setValue(s.scale)
        
        s = QSettings()
        s.beginGroup("musicview")
        newerFilesOnly = s.value("newer_files_only", True, bool)
        self.newerFilesOnly.setChecked(newerFilesOnly)
        kineticScrollingActive = s.value("kinetic_scrolling", True, bool)
        self.enableKineticScrolling.setChecked(kineticScrollingActive)
        showScrollbars = s.value("show_scrollbars", True, bool)
        self.showScrollbars.setChecked(showScrollbars)
    
    def saveSettings(self):
        s = popplerview.MagnifierSettings()
        s.size = self.magnifierSizeSlider.value()
        s.scale = self.magnifierScaleSlider.value()
        s.save()

        s = QSettings()
        s.beginGroup("musicview")
        s.setValue("newer_files_only", self.newerFilesOnly.isChecked())
        s.setValue("kinetic_scrolling", self.enableKineticScrolling.isChecked())
        s.setValue("show_scrollbars", self.showScrollbars.isChecked())


class CharMap(preferences.Group):
    def __init__(self, page):
        super(CharMap, self).__init__(page)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.fontLabel = QLabel()
        self.fontChooser = QFontComboBox(currentFontChanged=self.changed)
        self.fontSize = QDoubleSpinBox(valueChanged=self.changed)
        self.fontSize.setRange(6.0, 32.0)
        self.fontSize.setSingleStep(0.5)
        self.fontSize.setDecimals(1)
        
        box = QHBoxLayout()
        box.addWidget(self.fontLabel)
        box.addWidget(self.fontChooser, 1)
        box.addWidget(self.fontSize)
        layout.addLayout(box)
        app.translateUI(self)
        
    def translateUI(self):
        self.setTitle(_("Special Characters"))
        self.fontLabel.setText(_("Font:"))
    
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("charmaptool")
        font = self.font()
        family = s.value("fontfamily", "", type(""))
        if family:
            font.setFamily(family)
        font.setPointSizeF(s.value("fontsize", font.pointSizeF(), float))
        with qutil.signalsBlocked(self.fontChooser, self.fontSize):
            self.fontChooser.setCurrentFont(font)
            self.fontSize.setValue(font.pointSizeF())

    def saveSettings(self):
        s = QSettings()
        s.beginGroup("charmaptool")
        s.setValue("fontfamily", self.fontChooser.currentFont().family())
        s.setValue("fontsize", self.fontSize.value())


class DocumentList(preferences.Group):
    def __init__(self, page):
        super(DocumentList, self).__init__(page)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        self.groupCheck = QCheckBox(toggled=self.changed)
        layout.addWidget(self.groupCheck)
        app.translateUI(self)
        
    def translateUI(self):
        self.setTitle(_("Documents"))
        self.groupCheck.setText(_("Group documents by directory"))
    
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("document_list")
        self.groupCheck.setChecked(s.value("group_by_folder", False, bool))

    def saveSettings(self):
        s = QSettings()
        s.beginGroup("document_list")
        s.setValue("group_by_folder", self.groupCheck.isChecked())


class Outline(preferences.Group):
    def __init__(self, page):
        super(Outline, self).__init__(page)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        self.label = QLabel()
        self.patternList = OutlinePatterns()
        self.patternList.listBox.setDragDropMode(QAbstractItemView.InternalMove)
        self.defaultButton = QPushButton(clicked=self.reloadDefaults)
        self.patternList.layout().addWidget(self.defaultButton, 3, 1)
        self.patternList.layout().addWidget(self.patternList.listBox, 0, 0, 5, 1)
        self.patternList.changed.connect(self.changed)
        layout.addWidget(self.label)
        layout.addWidget(self.patternList)
        app.translateUI(self)
    
    def translateUI(self):
        self.setTitle(_("Outline"))
        self.defaultButton.setText(_("Default"))
        self.defaultButton.setToolTip(_("Restores the built-in outline patterns."))
        self.label.setText(_("Patterns to match in text that are shown in outline:"))
    
    def reloadDefaults(self):
        self.patternList.setValue(documentstructure.default_outline_patterns)
    
    def loadSettings(self):
        s = QSettings()
        s.beginGroup("documentstructure")
        try:
            patterns = s.value("outline_patterns", documentstructure.default_outline_patterns, type(""))
        except TypeError:
            patterns = []
        self.patternList.setValue(patterns)
    
    def saveSettings(self):
        s = QSettings()
        s.beginGroup("documentstructure")
        if self.patternList.value() != documentstructure.default_outline_patterns:
            s.setValue("outline_patterns", self.patternList.value())
        else:
            s.remove("outline_patterns")


class OutlinePatterns(widgets.listedit.ListEdit):
    def openEditor(self, item):
        dlg = widgets.dialog.TextDialog(None,
            _("Enter a regular expression to match:"),
            app.caption("Outline"))
        userguide.addButton(dlg.buttonBox(), "outline_configure")
        dlg.setValidateFunction(is_regex)
        dlg.setText(item.text())
        if dlg.exec_():
            item.setText(dlg.text())
            return True
        return False

            
def is_regex(text):
    """Return True if text is a valid regular expression."""
    try:
        re.compile(text, re.M)
    except re.error:
        return False
    return True



########NEW FILE########
__FILENAME__ = process
# process.py -- A very simple wrapper around QProcess
#
# Copyright (c) 2012 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A very simple wrapper around QProcess, and a scheduler to enable running
one process at a time.
"""

__all__ = ['Process', 'Scheduler']

from PyQt4.QtCore import QObject, QProcess, pyqtSignal


class Process(QObject):
    """A very simple wrapper to run a QProcess.
    
    Initialize the process with the command line (as a list) to run.
    Then (or later) call start() to run it. At that moment the 'process'
    attribute is available, which contains the QProcess instance managing
    the process.
    
    The done() signal is emitted with a boolean success value. In slots
    connected (synchroneously) the process attribute is still avalable.
    
    """
    
    done = pyqtSignal(bool)
    
    def __init__(self, command):
        """Sets up the command to run."""
        QObject.__init__(self)
        self.command = command
    
    def start(self):
        """Really starts a QProcess, executing the command line."""
        self.setup()
        self.process.start(self.command[0], self.command[1:])
    
    def setup(self):
        """Called on start(), sets up the QProcess in the process attribute."""
        self.process = p = QProcess()
        p.finished.connect(self._finished)
        p.error.connect(self._error)
        
    def _finished(self, exitCode):
        self._done(exitCode == 0)
    
    def _error(self):
        self._done(False)
    
    def _done(self, success):
        self.done.emit(success)
        self.cleanup()
    
    def cleanup(self):
        """Deletes the process."""
        self.process.deleteLater()
        del self.process


class Scheduler(object):
    """A very simple scheduler that runs one Process at a time.
    
    You can use this to run e.g. commandline tools asynchronuously and you
    don't want to have them running at the same time.
    
    """
    def __init__(self):
        self._schedule = []
    
    def add(self, process):
        """Adds the process to run."""
        process.done.connect(self._done)
        self._schedule.append(process)
        if len(self._schedule) == 1:
            self._schedule[0].start()
    
    def remove(self, process):
        """Removes the process from the schedule.
        
        This only works if the process has not been started yet.
        
        """
        if process in self._schedule[1:]:
            self._schedule.remove(process)
            process.done.disconnect(self._done)
    
    def _done(self):
        del self._schedule[0]
        if self._schedule:
            self._schedule[0].start()



########NEW FILE########
__FILENAME__ = progress
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages the progress bar in the status bar of ViewSpaces.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import Qt, QTimeLine, QTimer
from PyQt4.QtGui import QProgressBar

import app
import plugin
import jobmanager
import jobattributes
import metainfo
import widgets.progressbar

metainfo.define('buildtime', 0.0, float)


class ProgressBar(plugin.ViewSpacePlugin):
    """A Simple progress bar to show a Job is running."""
    def __init__(self, viewSpace):
        bar = self._bar = widgets.progressbar.TimedProgressBar()
        viewSpace.status.layout().addWidget(bar, 1, Qt.AlignCenter)
        bar.hide()
        viewSpace.viewChanged.connect(self.viewChanged)
        app.jobStarted.connect(self.jobStarted)
        app.jobFinished.connect(self.jobFinished)
        
    def viewChanged(self, view):
        self.showProgress(view.document())
    
    def showProgress(self, document):
        job = jobmanager.job(document)
        if job and job.isRunning():
            buildtime = metainfo.info(document).buildtime
            if not buildtime:
                buildtime = 3.0 + document.blockCount() / 20 # very arbitrary estimate...
            self._bar.start(buildtime, job.elapsed())
            if jobattributes.get(job).hidden:
                self._bar.setEnabled(False)
                self._bar.setMaximumHeight(8)
                self._bar.setTextVisible(False)
            else:
                self._bar.setEnabled(True)
                self._bar.setMaximumHeight(14)
                self._bar.setTextVisible(True)
        else:
            self._bar.stop(False)
    
    def jobStarted(self, document, job):
        if document == self.viewSpace().document():
            self.showProgress(document)
    
    def jobFinished(self, document, job, success):
        if document == self.viewSpace().document():
            self._bar.stop(success and not jobattributes.get(job).hidden)
            if success:
                metainfo.info(document).buildtime = job.elapsed()


app.viewSpaceCreated.connect(ProgressBar.instance)

########NEW FILE########
__FILENAME__ = player
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A MIDI player for PyQt4.
"""


from __future__ import unicode_literals


from PyQt4.QtCore import pyqtSignal, Qt, QThread, QTimer

import midifile.player


class Player(QThread, midifile.player.Player):
    """An implementation of midifile.player.Player using a QThread and QTimer.
    
    emit signals:
    
    stateChanged(playing):
        True or False if playing state changes
        
    time(msec):
        The playing time, emit by default every 1000ms
        
    beat(measnum, beat, num, den):
        the measure number, beat number, time signature numerator and denom.,
        where 0 = whole note, 1 = half note, 2 = quarter note, etc.
    
    user(object):
        any user object that might be added to an event
    
    """
    stateChanged = pyqtSignal(bool)
    time = pyqtSignal(int)
    beat = pyqtSignal(int, int, int, int)
    user = pyqtSignal(object)
    
    def __init__(self, parent=None):
        QThread.__init__(self, parent)
        midifile.player.Player.__init__(self)
        self._timer = None
    
    def run(self):
        self._timer = QTimer(singleShot=True)
        self._timer.timeout.connect(self.timer_timeout, Qt.DirectConnection)
        self.timer_start_playing()
        self.stateChanged.emit(True)
        if self.exec_():
            self.timer_stop_playing()
        self._timer = None
        self.stateChanged.emit(False)
    
    def start(self):
        if self.has_events():
            QThread.start(self)
    
    def stop(self):
        if self.isRunning():
            self.exit(1)
            self.wait()
    
    def timer_start(self, msec):
        """Starts the timer to fire once, the specified msec from now."""
        self._timer.start(int(msec))
    
    def timer_stop(self):
        self._timer.stop()

    def finish_event(self):
        midifile.player.Player.finish_event(self)
        self.exit(0)

    def time_event(self, time):
        self.time.emit(time)
    
    def beat_event(self, measnum, beat, num, den):
        self.beat.emit(measnum, beat, num, den)
    
    def user_event(self, obj):
        self.user.emit(obj)



########NEW FILE########
__FILENAME__ = cache
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
Caching of generated images.
"""

import time
import weakref

try:
    import popplerqt4
except ImportError:
    from . import popplerqt4_dummy as popplerqt4

from PyQt4.QtCore import Qt, QThread

from . import render
from . import rectangles
from .locking import lock

__all__ = ['maxsize', 'setmaxsize', 'image', 'generate', 'clear', 'links', 'options']


_cache = weakref.WeakKeyDictionary()
_schedulers = weakref.WeakKeyDictionary()
_options = weakref.WeakKeyDictionary()
_links = weakref.WeakKeyDictionary()


# cache size
_maxsize = 104857600 # 100M
_currentsize = 0

_globaloptions = None


def setmaxsize(maxsize):
    """Sets the maximum cache size in Megabytes."""
    global _maxsize
    _maxsize = maxsize * 1048576
    purge()
    

def maxsize():
    """Returns the maximum cache size in Megabytes."""
    return _maxsize / 1048576


def clear(document=None):
    """Clears the whole cache or the cache for the given Poppler.Document."""
    if document:
        try:
            del _cache[document]
        except KeyError:
            pass
    else:
        _cache.clear()
        global _currentsize
        _currentsize = 0


def image(page, exact=True):
    """Returns a rendered image for given Page if in cache.
    
    If exact is True (default), the function returns None if the exact size was
    not in the cache. If exact is False, the function may return a temporary
    rendering of the page scaled from a different size, if that was available.
    
    """
    document = page.document()
    pageKey = (page.pageNumber(), page.rotation())
    sizeKey = (page.width(), page.height())
    
    if exact:
        try:
            entry = _cache[document][pageKey][sizeKey]
        except KeyError:
            return
        else:
            entry[1] = time.time()
            return entry[0]
    try:
        sizes = _cache[document][pageKey].keys()
    except KeyError:
        return
    # find the closest size (assuming aspect ratio has not changed)
    if sizes:
        sizes.sort(key=lambda s: abs(1 - s[0] / float(page.width())))
        return _cache[document][pageKey][sizes[0]][0]


def generate(page):
    """Schedule an image to be generated for the cache."""
    # Poppler-Qt4 crashes when different pages from a Document are rendered at the same time,
    # so we schedule them to be run in sequence.
    document = page.document()
    try:
        scheduler = _schedulers[document]
    except KeyError:
        scheduler = _schedulers[document] = Scheduler()
    scheduler.schedulejob(page)


def add(image, document, pageNumber, rotation, width, height):
    """(Internal) Adds an image to the cache."""
    pageKey = (pageNumber, rotation)
    sizeKey = (width, height)
    _cache.setdefault(document, {}).setdefault(pageKey, {})[sizeKey] = [image, time.time()]
    
    # maintain cache size
    global _maxsize, _currentsize
    _currentsize += image.byteCount()
    if _currentsize > _maxsize:
        purge()


def purge():
    """Removes old images from the cache to limit the space used.
    
    (Not necessary to call, as the cache will monitor its size automatically.)
    
    """
    # make a list of the images, sorted on time, newest first
    images = iter(sorted((
        (time, document, pageKey, sizeKey, image.byteCount())
            for document, pageKeys in _cache.items()
            for pageKey, sizeKeys in pageKeys.items()
            for sizeKey, (image, time) in sizeKeys.items()),
                reverse=True))

    # sum the size of the newest images
    global _maxsize, _currentsize
    byteCount = 0
    for item in images:
        byteCount += item[4]
        if byteCount > _maxsize:
            break
    _currentsize = byteCount
    # delete the other images
    for time, document, pageKey, sizeKey, byteCount in images:
        del _cache[document][pageKey][sizeKey]


def links(page):
    """Returns a position-searchable list of the links in the page."""
    document, pageNumber = page.document(), page.pageNumber()
    try:
        return _links[document][pageNumber]
    except KeyError:
        with lock(document):
            links = rectangles.Rectangles(document.page(pageNumber).links(),
                                        lambda link: link.linkArea().normalized().getCoords())
        _links.setdefault(document, {})[pageNumber] = links
        return links


def options(document=None):
    """Returns a RenderOptions object for a document or the global one if no document is given."""
    global _globaloptions, _options
    if document:
        try:
            return _options[document]
        except KeyError:
            result = _options[document] = render.RenderOptions()
            return result
    if not _globaloptions:
        _globaloptions = render.RenderOptions()
        # enable antialiasing by default
        _globaloptions.setRenderHint(popplerqt4.Poppler.Document.Antialiasing |
                                     popplerqt4.Poppler.Document.TextAntialiasing)
    return _globaloptions


def setoptions(options, document=None):
    """Sets a RenderOptions instance for the given document or as the global one if no document is given.
    
    Use None for the options to unset (delete) the options.
    
    """
    global _globaloptions, _options
    if not document:
        _globaloptions = options
    elif options:
        _options[document] = options
    else:
        try:
            del _options[document]
        except KeyError:
            pass


class Scheduler(object):
    """Manages running rendering jobs in sequence for a Document."""
    def __init__(self):
        self._schedule = []     # order
        self._jobs = {}         # jobs on key
        self._waiting = weakref.WeakKeyDictionary()      # jobs on page
        self._running = None
        
    def schedulejob(self, page):
        """Creates or retriggers an existing Job.
        
        If a Job was already scheduled for the page, it is canceled.
        The page's update() method will be called when the Job has completed.
        
        """
        # uniquely identify the image to be generated
        key = (page.pageNumber(), page.rotation(), page.width(), page.height())
        try:
            job = self._jobs[key]
        except KeyError:
            job = self._jobs[key] = Job(page)
            job.key = key
        else:
            self._schedule.remove(job)
        self._schedule.append(job)
        self._waiting[page] = job
        self.checkStart()
        
    def checkStart(self):
        """Starts a job if none is running and at least one is waiting."""
        while self._schedule and not self._running:
            job = self._schedule[-1]
            document = job.document()
            if document and job in self._waiting.values():
                self._running = Runner(self, document, job)
                break
            else:
                self.done(job)
            
    def done(self, job):
        """Called when the job has completed."""
        del self._jobs[job.key]
        self._schedule.remove(job)
        self._running = None
        for page in list(self._waiting):
            if self._waiting[page] is job:
                page.update()
                del self._waiting[page]


class Job(object):
    """Simply contains data needed to create an image later."""
    def __init__(self, page):
        self.document = weakref.ref(page.document())
        self.pageNumber = page.pageNumber()
        self.rotation = page.rotation()
        self.width = page.width()
        self.height = page.height()


class Runner(QThread):
    """Immediately runs a Job in a background thread."""
    def __init__(self, scheduler, document, job):
        super(Runner, self).__init__()
        self.scheduler = scheduler
        self.job = job
        self.document = document # keep reference now so that it does not die during this thread
        self.finished.connect(self.slotFinished)
        self.start()
        
    def run(self):
        """Main method of this thread, called by Qt on start()."""
        page = self.document.page(self.job.pageNumber)
        pageSize = page.pageSize()
        if self.job.rotation & 1:
            pageSize.transpose()
        xres = 72.0 * self.job.width / pageSize.width()
        yres = 72.0 * self.job.height / pageSize.height()
        threshold = options().oversampleThreshold() or options(self.document).oversampleThreshold()
        multiplier = 2 if xres < threshold else 1
        with lock(self.document):
            options().write(self.document)
            options(self.document).write(self.document)
            self.image = page.renderToImage(xres * multiplier, yres * multiplier, 0, 0, self.job.width * multiplier, self.job.height * multiplier, self.job.rotation)
        if multiplier == 2:
            self.image = self.image.scaledToWidth(self.job.width, Qt.SmoothTransformation)
        
    def slotFinished(self):
        """Called when the thread has completed."""
        add(self.image, self.document, self.job.pageNumber, self.job.rotation, self.job.width, self.job.height)
        self.scheduler.done(self.job)
        self.scheduler.checkStart()


########NEW FILE########
__FILENAME__ = highlight
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
Highlight rectangular areas inside a Surface.
"""

from PyQt4.QtGui import QApplication, QPainter, QPen


class Highlighter(object):
    """A Highlighter can draw rectangles to highlight e.g. links in a Poppler.Document.
    
    An instance represents a certain type of highlighting, e.g. of a particular style.
    The paintRects() method is called with a list of rectangles that need to be drawn.
    
    To implement different highlighting behaviour just inherit paintRects().
    The default implementation of paintRects() uses the color() method to get the
    color to use and the lineWidth (default: 2) and radius (default: 3) class attributes.
    
    lineWidth specifies the thickness in pixels of the border drawn,
    radius specifies the distance in pixels the border is drawn (by default with rounded corners)
    around the area to be highlighted.
    
    """
    
    lineWidth = 2
    radius = 3
    
    def color(self):
        """The default paintRects() method uses this method to return the color to use.
        
        By default the application's palette highlight color is returned.
        
        """
        return QApplication.palette().highlight().color()
    
    def paintRects(self, painter, rects):
        """Override this method to implement different drawing behaviour."""
        pen = QPen(self.color())
        pen.setWidth(self.lineWidth)
        painter.setPen(pen)
        painter.setRenderHint(QPainter.Antialiasing, True)
        rad = self.radius
        for r in rects:
            r.adjust(-rad, -rad, rad, rad)
            painter.drawRoundedRect(r, rad, rad)


########NEW FILE########
__FILENAME__ = kineticscrollarea
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
KineticScrollArea widget to provide kinetic scrolling moves.
"""


from PyQt4.QtCore import QPoint, QBasicTimer, QEvent, Qt, pyqtSignal
from PyQt4.QtGui import QScrollArea, QApplication, QCursor, QMouseEvent

from math import sqrt
import copy



# most used keyboard modifiers
_SCAM = (Qt.SHIFT | Qt.CTRL | Qt.ALT | Qt.META)

def deaccelerate(speed, a=1, maxVal=64):
    x = qBound(-maxVal, speed.x(), maxVal)
    y = qBound(-maxVal, speed.y(), maxVal)
    if x > 0:
        x = max(0, x - a)
    elif x < 0:
        x = min(0, x + a)
    if y > 0:
        y = max(0, y - a)
    elif y < 0:
        y = min(0, y + a)
    return QPoint(x, y)


def qBound(minVal, current, maxVal):
    return max(min(current, maxVal), minVal)
    
# Centralize data for kinetic scrolling
class KineticData:
    
    Steady = 0
    Pressed = 1
    ManualScroll = 2
    AutoScroll = 3
    Stop = 4
    
    def __init__(self):
        self._state = KineticData.Steady
        self._pressPos = QPoint(0, 0)
        self._offset = QPoint(0, 0)
        self._dragPos = QPoint(0, 0)
        self._speed = QPoint(0, 0)
        self._maxSpeed = 64
        self._ignored = []
        self._ticker = QBasicTimer()
    
    def ignoreEvent(self, ev):
        found = False
        ignored = []
        for event in self._ignored:
            if event == ev:
                found = True
            else:
                ignored.append(event)
        if found :
            self._ignored = ignored
            
        return found

import array

class KineticScrollArea(QScrollArea):

    # signal emitted when kinetic scrolling starts/stops, to make it possible
    # to shut down some event listeners until we're done.
    kineticScrollingActive = pyqtSignal(bool)
    cursorNeedUpdate = pyqtSignal(QPoint)
        
    def __init__(self, parent=None):
        super(KineticScrollArea, self).__init__(parent)
              
        # kinetic scrolling
        self._kineticScrollingEnabled = False
        self._scrollFuncIndex = 0
        
        # Functions pointers, index 0 -> kinetic, index 1 -> classic.
        self._scrollBy = [
            self.kineticScrollBy,
            self.fastScrollBy
        ]
        self._center = [
            self.kineticCenter,
            self.fastCenter
        ]
        self._ensureVisible = [
            self.kineticEnsureVisible,
            super(KineticScrollArea, self).ensureVisible
        ]

        self._scrollbarsVisible = True
        self._kineticData=KineticData()
        
        self._dragging = False


    def setScrollbarsVisible(self, enabled):
        """Sets the scrollbars visibility status."""
        self._scrollbarsVisible = enabled
        
        if enabled:
            self.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            self.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        else:
            self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    
    def scrollbarsVisible(self):
        """Returns the current scrollbars visibility status"""
        
        return self._scrollbarsVisible
            
    def setKineticScrolling(self, enabled):
        """Sets whether kinetic scrolling is enabled or not."""
        
        self._kineticScrollingEnabled = enabled
        if enabled:
            self._scrollFuncIndex = 0
        else:
            self._scrollFuncIndex = 1
    
    def kineticScrollingEnabled(self):
        """Returns whether kinetic scrolling is enabled."""
        
        return self._kineticScrollingEnabled

    def kineticIsIdle(self):
        return self._kineticData._state == KineticData.Steady
    
    def scrollOffset(self):
        """Get the current scroll position."""
        
        x = self.horizontalScrollBar().value()
        y = self.verticalScrollBar().value()
        return QPoint(x, y)
            
            
    def setScrollOffset(self, p):
        """Set the current scroll position. Returns true if at last one of (x,y) was really modified."""
        start_p = self.scrollOffset()
        
        self.horizontalScrollBar().setValue(p.x())
        self.verticalScrollBar().setValue(p.y())
        # return true if at least one coordinate specified was respected and requested move was not 0.
        end_p = self.scrollOffset()
        return (start_p.x() != p.x() and end_p.x() == p.x()) or (start_p.y() != p.y() and end_p.y() == p.y())
    
    def fastScrollBy(self, diff):
        """Immediately Scrolls by the distance given in the QPoint diff."""
        v = self.verticalScrollBar()
        h = self.horizontalScrollBar()
        v.setValue(v.value() + diff.y())
        h.setValue(h.value() + diff.x())

    def kineticScrollBy(self, diff):
        """Kinetically Scrolls by the distance given in the QPoint diff."""          
        v = self.verticalScrollBar()
        h = self.horizontalScrollBar()
        self.kineticMove(h.value(), v.value(), h.value()+diff.x(), v.value()+diff.y())

    def scrollBy(self, diff):
        """Scrolls by the distance given in the QPoint diff.
        Scrolling will either be immediate or kinetic.
        """
        self._scrollBy[self._scrollFuncIndex](diff) 
    
    def fastCenter(self, point):
        """Immediately center the view on the givent QPoint"""
        
        diff = point - self.viewport().rect().center() + self.widget().pos()
        self.fastScrollBy(diff)
    
    def kineticCenter(self, point):
        """Kinetically center the view on the givent QPoint"""

        size = self.widget().viewportRect().size()
        self.kineticEnsureVisible( point.x(), point.y(), size.width()/2, size.height()/2)
    
    def center(self, point, overrideKinetic=False):
        """Centers the given QPoint of the widget.
        Centering will either be immediate or kinetic."""
        self._center[self._scrollFuncIndex](point)

    def kineticMove(self, oldx, oldy, newx, newy ):
        """Start a kinetic move from (oldx, oldy) to (newx, newy)"""
        if newx == oldx and newy == oldy:
            return
        
        speed = QPoint(0,0)
        # solve speed*(speed+1)/2 = delta to ensure 1+2+3+...+speed is as close as possible under delta..
        speed.setX((sqrt(1+8*abs(newx-oldx))-1)/2)
        speed.setY((sqrt(1+8*abs(newy-oldy))-1)/2)
        
        # compute the amount of displacement still needed because we're dealing with integer values.
        diff = QPoint(0,0)
        diff.setX(-abs(newx-oldx) + speed.x()*(speed.x()+1)/2)
        diff.setY(-abs(newy-oldy) + speed.y()*(speed.y()+1)/2)

        # Since this function is called for exact moves (not free scrolling)
        # limit the kinetic time to 2 seconds, which means 100 ticks, 5050 pixels.
        if speed.y() > 100:
            speed.setY(100)
            diff.setY(-abs(newy-oldy) + 5050)
            
        # Although it is less likely to go beyond that limit for horizontal scrolling,
        # do it for x as well.
        if speed.x() > 100:
            speed.setX(100)
            diff.setX(-abs(newx-oldx) + 5050)
        
        # move left or right, up or down
        if newx > oldx :
            speed.setX(-speed.x())
            diff.setX(-diff.x())
        if newy > oldy :
            speed.setY(-speed.y())
            diff.setY(-diff.y())
        
        # move immediately by the step that cannot be handled by kinetic scrolling.
        # By construction that step is smaller that the initial speed value.
        self.fastScrollBy(diff)
        
        self.kineticStart(speed)

    def kineticAddDelta(self, delta, orientation=Qt.Vertical):
        """Add a kinetic delta to an already started kinetic move."""
        if orientation == Qt.Vertical:
            s = self._kineticData._speed.y()
        else:
            s = self._kineticData._speed.x()
        
        # Get the remaining scroll amount.
        currentSpeed = abs( s )
        leftToScroll = (currentSpeed+1)*currentSpeed / 2 ;
        if s < 0:
            leftToScroll *= -1
        leftToScroll += delta
        
        s = (sqrt(1+8*abs(leftToScroll))-1)/2
        if leftToScroll < 0:
            s = -s
        
        if orientation == Qt.Vertical:
            speed = QPoint(self._kineticData._speed.x(), s)
        else:
            speed = QPoint(s, self._kineticData._speed.y())
            
        self.kineticStart(speed)
            
    def kineticStart(self, speed):
        """Start kinetic scrolling with a givent speed. Speed will be decremented periodically
        until scrolling halts."""
        # Setup the kinetic displacement speed, removing the speed limit imposed on
        # interactive scrolling.
        self._kineticData._speed = speed
        # speed limit is one above speed, to make sure there will be none.
        self._kineticData._maxSpeed = max(abs(speed.x()), abs(speed.y())) + 1
        
        # Set kinetic state to AutoScroll, the reference position to the current view center,
        # and fire the timer.
        self._kineticData._state = KineticData.AutoScroll
        self._kineticData._dragPos = self.pos()
        if not self._kineticData._ticker.isActive():
            self._kineticData._ticker.start(20, self)
            self.kineticScrollingActive.emit(True)
   
    def kineticTicksLeft(self):
        """Return the number of ticks left on the kinetic counter."""
        if( self._kineticData._state == KineticData.AutoScroll
            or self._kineticData._state == KineticData.ManualScroll ):
            return max( abs(self._kineticData._speed.x()), abs(self._kineticData._speed.y()) )
        
        return 0
    
    def kineticEnsureVisible(self, x, y, xm, ym):
        """Ensure a given point is visible, with a margin, by starting the appropriate kinetic scrolling."""
        # Replicate the logic in ScrollArea::ensureVisible to compute the
        # scrollbar displacements, per Qt sources.
        oldx = self.horizontalScrollBar().value()
        oldy = self.verticalScrollBar().value()

        newx = oldx
        if x-xm < oldx :
            newx = max(0, x - xm)
        elif x > oldx + self.viewport().width() - xm:
            newx = min(x - self.viewport().width() + xm, self.verticalScrollBar().maximum())
           
        newy = oldy 
        if y-ym < oldy :
            newy = max(0, y - ym)
        elif y > oldy + self.viewport().height() - ym:
            newy = min(y - self.viewport().height() + ym, self.verticalScrollBar().maximum())
            
        self.kineticMove(oldx, oldy, newx, newy)
    
    def ensureVisible(self, x, y, xm=50, ym=50):     
        """
        Reimplement ensureVisible to call the kinetic scroller timer if kinetic scrolling is enabled.
        """
        
        self._ensureVisible[self._scrollFuncIndex](x, y, xm, ym)

    def wheelEvent(self, ev):
        """Kinetic wheel movements, if enabled."""
        if self._kineticScrollingEnabled:
            self.kineticAddDelta(ev.delta(), ev.orientation())
        else:
            super(KineticScrollArea, self).wheelEvent(ev)

    def keyPressEvent(self, ev):
        """Kinetic cursor movements, if enabled."""
        if self._kineticScrollingEnabled:
            if ev.key() == Qt.Key_PageDown:
                self.kineticAddDelta(-self.verticalScrollBar().pageStep())
                return;
            elif ev.key() == Qt.Key_PageUp:
                self.kineticAddDelta(self.verticalScrollBar().pageStep())
                return;
            elif ev.key() == Qt.Key_Down:
                self.kineticAddDelta(-self.verticalScrollBar().singleStep())
                return;
            elif ev.key() == Qt.Key_Up:
                self.kineticAddDelta(self.verticalScrollBar().singleStep())
                return;
            elif ev.key() == Qt.Key_Home:
                self.kineticMove(0, self.verticalScrollBar().value(), 0, 0)
                return;
            elif ev.key() == Qt.Key_End:
                self.kineticMove(0, self.verticalScrollBar().value(), 0, self.verticalScrollBar().maximum())
                return;
        else:
            # Home/End are not handled by default.
            if ev.key() == Qt.Key_Home:
                self.setScrollOffset(QPoint(0,0))
                return;
            elif ev.key() == Qt.Key_End:
                self.setScrollOffset(QPoint(self.horizontalScrollBar().maximum(), self.verticalScrollBar().maximum()))
                return;

        super(KineticScrollArea, self).keyPressEvent(ev)

    def mousePressEvent(self, ev):
        """Handle mouse press for dragging start/stop."""
        if ev.button() == Qt.LeftButton:
            self._dragPos = ev.globalPos()
            
            if self._kineticScrollingEnabled:
                # kinetic scrolling
                if self._kineticData.ignoreEvent(ev):
                    return
                
                if self._kineticData._state == KineticData.Steady or self._kineticData._state == KineticData.Stop:
                    self._dragging = True
                    self._kineticData._state = KineticData.Pressed
                    self._kineticData._pressPos = copy.copy(ev.pos())
                    self._kineticData._offset = self.scrollOffset()
                    self._kineticData._maxSpeed = 64 #limit speed.
                    
                elif self._kineticData._state == KineticData.AutoScroll:
                    self._dragging = True
                    self._kineticData._state = KineticData.Stop
                    self._kineticData._speed = QPoint(0,0)
            else:
                self._dragging = True
        
        super(KineticScrollArea, self).mousePressEvent(ev)

    
    def mouseReleaseEvent(self, ev):
        """Handle mouse release events for kinetic dragging end/auto mode."""
        if self._dragging:
            self._dragging = False
            self.unsetCursor()
            if self._kineticScrollingEnabled:
                # kinetic scrolling
                if self._kineticData.ignoreEvent(ev):
                    return
                
                if self._kineticData._state == KineticData.Pressed:
                    self._kineticData._state = KineticData.Steady
                    event1 = QMouseEvent(QEvent.MouseButtonPress,
                                         self._kineticData._pressPos, Qt.LeftButton,
                                         Qt.LeftButton, Qt.NoModifier)
                    event2 = QMouseEvent(ev)
                    self._kineticData._ignored.append(event1)
                    self._kineticData._ignored.append(event2)
                    QApplication.postEvent(self, event1)
                    QApplication.postEvent(self, event2)
                    
                elif self._kineticData._state == KineticData.ManualScroll:
                    self._kineticData._state = KineticData.AutoScroll
    
                elif self._kineticData._state == KineticData.AutoScroll:
                    self._kineticData._state = KineticData.Stop
                    self._kineticData._speed = QPoint(0, 0)
                    
                elif self._kineticData._state == KineticData.Stop:
                    self._kineticData._state = KineticData.Steady

        if self._kineticData._state == KineticData.Steady:
            self.cursorNeedUpdate.emit(ev.globalPos())
        
        super(KineticScrollArea, self).mouseReleaseEvent(ev)
        
    def mouseMoveEvent(self, ev):
        """Handle mouse move events for kinetic dragging timer firing.
        Notifies cursor needs update if no kinetic move is active.
        """
        if self._dragging:
            self.setCursor(Qt.SizeAllCursor)

            if self._kineticScrollingEnabled:
                # kinetic scrolling
                if self._kineticData.ignoreEvent(ev):
                    return
                
                if self._kineticData._state == KineticData.Pressed:
                    self._kineticData._state = KineticData.ManualScroll
                    self._kineticData._dragPos = QCursor.pos()
                    if not self._kineticData._ticker.isActive():
                        self._kineticData._ticker.start(20, self)
                        self.kineticScrollingActive.emit(True)
                        
                elif self._kineticData._state == KineticData.ManualScroll:
                    diff = self._dragPos - ev.globalPos()
                    self._dragPos = ev.globalPos()
                    self.fastScrollBy(diff) 
                    
                elif self._kineticData._state == KineticData.Stop:
                    self._kineticData._state = KineticData.ManualScroll
                    self._kineticData._dragPos = QCursor.pos()
                    if not self._kineticData._ticker.isActive():
                        self._kineticData._ticker.start(20, self)
                        self.kineticScrollingActive.emit(True)
            
            else:
                diff = self._dragPos - ev.globalPos()
                self._dragPos = ev.globalPos()
                self.fastScrollBy(diff)
        
        super(KineticScrollArea, self).mouseMoveEvent(ev)
        
        if self.kineticIsIdle():
            self.cursorNeedUpdate.emit(ev.globalPos())

    def moveEvent(self, ev):
        """Move event handler. Passes the event to the base class and notify the cursor needs update."""
        super(KineticScrollArea, self).moveEvent(ev)

        if self.kineticIsIdle():
            self.cursorNeedUpdate.emit(QCursor.pos())

    def timerEvent(self, event):
        """Handle events sent by the kinetic timer to decrease progressively
           the scrolling speed, eventually halting it.
        """
        count = 0
        if self._kineticData._state == KineticData.ManualScroll:
            count += 1
            cursorPos = QCursor.pos()
            self._kineticData._speed = cursorPos - self._kineticData._dragPos
            self._kineticData._dragPos = cursorPos    
        elif self._kineticData._state == KineticData.AutoScroll:
            count += 1
            p = self.scrollOffset()

            if self._kineticData._speed == QPoint(0, 0) or not self.setScrollOffset(p - self._kineticData._speed):
                self._kineticData._state = KineticData.Steady
                # reset speed to 0, as wheel scrolling accumulates speed instead of setting it to a fixed value.
                self._kineticData._speed = QPoint(0,0)
                # reset count to 0 to stop iterating.
                count = 0
                
            self._kineticData._speed = deaccelerate(self._kineticData._speed, 1, self._kineticData._maxSpeed)
    
        if count == 0:
            self._kineticData._ticker.stop()
            self.kineticScrollingActive.emit(False)
    
        super(KineticScrollArea, self).timerEvent(event);

########NEW FILE########
__FILENAME__ = layout
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
Manages and positions a group of Page instances.
"""

import weakref

from PyQt4.QtCore import QObject, QPoint, QRect, QSize, Qt, pyqtSignal

from . import page
from . import (
    # viewModes:
    FixedScale,
    FitWidth,
    FitHeight,
    FitBoth,
)


class AbstractLayout(QObject):
    """Manages page.Page instances with a list-like api.
    
    You can iterate over the layout itself, which yields all Page instances.
    You can also iterate over pages(), which only yields the Page instances
    that are visible().
    
    """
    
    redraw = pyqtSignal(QRect)
    changed = pyqtSignal()
    scaleChanged = pyqtSignal(float)
    
    def __init__(self):
        super(AbstractLayout, self).__init__()
        self._pages = []
        self._size = QSize()
        self._margin = 4
        self._spacing = 8
        self._scale = 1.0
        self._scaleChanged = False
        self._dpi = (72, 72)
        
    def own(self, page):
        """(Internal) Makes the page have ourselves as layout."""
        if page.layout():
            page.layout().remove(page)
        page._layout = weakref.ref(self)
        page.computeSize()
    
    def disown(self, page):
        """(Internal) Removes ourselves as owner of the page."""
        page._layout = lambda: None
        
    def append(self, page):
        self.own(page)
        self._pages.append(page)
        
    def insert(self, position, page):
        self.own(page)
        self._pages.insert(position, page)
    
    def extend(self, pages):
        for page in pages:
            self.append(page)
            
    def remove(self, page):
        self._pages.remove(page)
        self.disown(page)
    
    def pop(self, index=None):
        page = self._pages.pop(index)
        self.disown(page)
        return page
    
    def clear(self):
        del self[:]
    
    def count(self):
        return len(self._pages)
        
    def __len__(self):
        return len(self._pages)
    
    def __nonzero__(self):
        return True
    
    def __contains__(self, page):
        return page in self._pages
    
    def __getitem__(self, item):
        return self._pages[item]
        
    def __delitem__(self, item):
        if isinstance(item, slice):
            for page in self._pages[item]:
                self.disown(page)
        else:
            self.disown(self._pages[item])
        del self._pages[item]
    
    def __setitem__(self, item, new):
        if isinstance(item, slice):
            old = self._pages[item]
            self._pages[item] = new
            for page in self._pages[item]:
                self.own(page)
            for page in old:
                self.disown(page)
        else:
            self.disown(self._pages[item])
            self._pages[item] = new
            self.own(new)
    
    def index(self, page):
        """Returns the index at which the given Page can be found in our Layout."""
        return self._pages.index(page)
        
    def setSize(self, size):
        """Sets our size. Mainly done after layouting."""
        self._size = size
        
    def size(self):
        """Returns our size as QSize()."""
        return self._size
    
    def width(self):
        """Returns our width."""
        return self._size.width()
    
    def height(self):
        """Returns our height."""
        return self._size.height()
    
    def setDPI(self, xdpi, ydpi=None):
        """Sets our DPI in X and Y direction. If Y isn't given, uses the X value."""
        self._dpi = xdpi, ydpi or xdpi
        for page in self:
            page.computeSize()
    
    def dpi(self):
        """Returns our DPI as a tuple(XDPI, YDPI)."""
        return self._dpi
        
    def scale(self):
        """Returns the scale (1.0 == 100%)."""
        return self._scale
    
    def setScale(self, scale):
        """Sets the scale (1.0 == 100%) of all our Pages."""
        if scale != self._scale:
            self._scale = scale
            for page in self:
                page.setScale(scale)
            self._scaleChanged = True
    
    def setPageWidth(self, width, sameScale=True):
        """Sets the width of all pages.
        
        If sameScale is True (default), the largest page will be scaled to the given
        width (minus margin).  All pages will then be scaled to that scale.
        If sameScale is False all pages will be scaled individually to the same width.
        
        """
        if sameScale and any(self.pages()):
            self.setScale(self.widest().scaleForWidth(width))
        else:
            for page in self:
                page.setWidth(width)
    
    def setPageHeight(self, height, sameScale=True):
        """Sets the height of all pages.
        
        If sameScale is True (default), the largest page will be scaled to the given
        height (minus margin).  All pages will then be scaled to that scale.
        If sameScale is False all pages will be scaled individually to the same height.
        
        """
        if sameScale and any(self.pages()):
            self.setScale(self.heighest().scaleForWidth(height))
        else:
            for page in self:
                page.setHeight(height)
            
    def setMargin(self, margin):
        """Sets the margin around the pages in pixels."""
        self._margin = margin
        
    def margin(self):
        """Returns the margin around the pages in pixels."""
        return self._margin
        
    def setSpacing(self, spacing):
        """Sets the space between the pages in pixels."""
        self._spacing = spacing
        
    def spacing(self):
        """Returns the space between the pages in pixels."""
        return self._spacing
        
    def fit(self, size, mode):
        """Fits the layout in the given ViewMode."""
        if mode and any(self.pages()):
            scales = []
            if mode & FitWidth:
                scales.append(self.widest().scaleForWidth(size.width() - self.margin() * 2))
            if mode & FitHeight:
                scales.append(self.heighest().scaleForHeight(size.height() - self.margin() * 2))
            self.setScale(min(scales))
        
    def update(self):
        """Performs the layouting (positions the Pages and adjusts our size)."""
        self.reLayout()
        if self._scaleChanged:
            self.scaleChanged.emit(self._scale)
            self._scaleChanged = False
        self.changed.emit()
        
    def reLayout(self):
        """This is called by update().
        
        You must implement this method to position the Pages and adjust our size.
        See Layout for a possible implementation.
        
        """
        pass
    
    def updatePage(self, page):
        """Called by the Page when an image has been generated."""
        self.redraw.emit(page.rect())
        
    def page(self, document, pageNumber):
        """Returns the page (visible or not) from a Poppler.Document with page number.
        
        Returns None if that page is not available.
        
        """
        # Specific layouts may use faster algorithms to find the page.
        try:
            page = self[pageNumber]
        except IndexError:
            pass
        else:
            if page.document() == document:
                return page
        for page in self:
            if page.document() == document and page.pageNumber() == pageNumber:
                return page
    
    def pages(self):
        """Yields our pages that are visible()."""
        for page in self:
            if page.visible():
                yield page
        
    def pageAt(self, point):
        """Returns the page that contains the given QPoint."""
        # Specific layouts may use faster algorithms to find the page.
        for page in self.pages():
            if page.rect().contains(point):
                return page
    
    def pagesAt(self, rect):
        """Yields the pages touched by the given QRect."""
        # Specific layouts may use faster algorithms to find the pages.
        for page in self.pages():
            if page.rect().intersects(rect):
                yield page
        
    def linkAt(self, point):
        """Returns (page, link) if pos points to a Poppler.Link in a Page, else (None, None)."""
        page = self.pageAt(point)
        if page:
            links = page.linksAt(point)
            if links:
                return page, links[0]
        return None, None
        
    def widest(self):
        """Returns the widest visible page (in its natural page size)."""
        pages = list(self.pages())
        if pages:
            return max(pages, key = lambda p: p.pageSize().width())
            
    def heighest(self):
        """Returns the heighest visible page (in its natural page size)."""
        pages = list(self.pages())
        if pages:
            return max(pages, key = lambda p: p.pageSize().height())
    
    def maxWidth(self):
        """Returns the width of the widest visible page."""
        page = self.widest()
        return page.width() if page else 0
        
    def maxHeight(self):
        """Returns the height of the heighest visible page."""
        page = self.heighest()
        return page.height() if page else 0
        
    def load(self, document):
        """Convenience mehod to load all the pages of the given Poppler.Document using page.Page()."""
        self.clear()
        for num in range(document.numPages()):
            p = page.Page(document, num)
            p.setScale(self._scale)
            self.append(p)


class Layout(AbstractLayout):
    """A basic layout that shows pages from right to left or top to bottom."""
    def __init__(self):
        super(Layout, self).__init__()
        self._orientation = Qt.Vertical
        
    def setOrientation(self, orientation):
        """Sets our orientation to either Qt.Vertical or Qt.Horizontal."""
        self._orientation = orientation
        
    def orientation(self):
        """Returns our orientation (either Qt.Vertical or Qt.Horizontal)."""
        return self._orientation
    
    def reLayout(self):
        """Orders our pages."""
        if self._orientation == Qt.Vertical:
            width = self.maxWidth() + self._margin * 2
            top = self._margin
            for page in self.pages():
                page.setPos(QPoint((width - page.width()) / 2, top))
                top += page.height() + self._spacing
            top += self._margin - self._spacing
            self.setSize(QSize(width, top))
        else:
            height = self.maxHeight() + self._margin * 2
            left = self._margin
            for page in self.pages():
                page.setPos(QPoint(left, (height - page.height()) / 2))
                left += page.width() + self._spacing
            left += self._margin - self._spacing
            self.setSize(QSize(left, height))
            


########NEW FILE########
__FILENAME__ = locking
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
Manages locking access (across threads) to Poppler.Document instances.
"""

import threading
import weakref

_locks = weakref.WeakKeyDictionary()
_lock = threading.RLock()


def lock(document):
    """Returns a threading.RLock instance for the given Poppler.Document.
    
    Use:
    
    with lock(document):
        do_something
        
    """
    with _lock:
        try:
            return _locks[document]
        except KeyError:
            res = _locks[document] = threading.RLock()
        return res


########NEW FILE########
__FILENAME__ = magnifier
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
The Magnifier magnifies a part of the displayed Poppler document.
"""

import weakref

from PyQt4.QtCore import QPoint, QRect
from PyQt4.QtGui import QPainter, QRegion, QWidget

from . import cache


class Magnifier(QWidget):
    """A Magnifier is added to a Surface with surface.setMagnifier().
    
    It is shown when a mouse button is pressed together with a modifier
    (by default Ctrl, see surface.py).
    
    Its size can be changed with resize() and the scale (defaulting to 4.0)
    with setScale().
    
    """
    def __init__(self, parent = None):
        super(Magnifier, self).__init__(parent)
        self._page= None
        self.setScale(4.0)
        self.resize(250, 250)
        self.hide()
        
    def moveCenter(self, pos):
        """Called by the surface, centers the widget on the given QPoint."""
        r = self.geometry()
        r.moveCenter(pos)
        self.setGeometry(r)
    
    def setScale(self, scale):
        """Sets the scale, relative to the 100% size of a Page.
        
        Uses the dpi() from the layout (pageLayout()) of the surface.
        
        """
        self._scale = scale
        self.update()
    
    def scale(self):
        """Returns the scale, defaulting to 4.0 (=400%)."""
        return self._scale
    
    def resizeEvent(self, ev):
        """Called on resize, sets our circular mask."""
        self.setMask(QRegion(self.rect(), QRegion.Ellipse))
        
    def paintEvent(self, ev):
        """Called when paint is needed, finds out which page to magnify."""
        layout = self.parent().pageLayout()
        pos = self.geometry().center()
        page = layout.pageAt(pos)
        if not page:
            return
        pagePos = pos - page.pos()
        
        newPage = Page(page, self._scale)
        if newPage != self._page:
            if self._page:
                self._page.magnifier = None
            self._page = newPage
            self._page.magnifier = self
        
        relx = pagePos.x() / float(page.width())
        rely = pagePos.y() / float(page.height())
        
        image = cache.image(self._page)
        img_rect = QRect(self.rect())
        if not image:
            cache.generate(self._page)
            image = cache.image(self._page, False)
            if image:
                img_rect.setWidth(self.width() * image.width() / self._page.width())
                img_rect.setHeight(self.height() * image.height() / self._page.height())
        if image:
            img_rect.moveCenter(QPoint(relx * image.width(), rely * image.height()))
            QPainter(self).drawImage(self.rect(), image, img_rect)


class Page(object):
    """A data structure describing a Page like page.Page.
    
    Has the methods the cache needs to create, store and find images
    for our magnifier.
    
    """
    def __init__(self, page, scale):
        """Creates Page, based on the page.Page object and the scale."""
        dpix, dpiy = page.layout().dpi()
        size = page.pageSize()
        self._document = weakref.ref(page.document())
        self._pageNumber = page.pageNumber()
        self._width = size.width() * dpix * scale / 72.0
        self._height = size.height() * dpiy * scale / 72.0
        self._rotation = page.rotation()
        self.magnifier = None
        
    def __eq__(self, other):
        return (
            self._document() == other._document() and
            self._pageNumber == other._pageNumber and
            self._width == other._width and
            self._height == other._height and
            self._rotation == other._rotation
        )

    def document(self):
        return self._document()
    
    def pageNumber(self):
        return self._pageNumber
    
    def width(self):
        return self._width
    
    def height(self):
        return self._height
    
    def rotation(self):
        return self._rotation
    
    def update(self):
        if self.magnifier:
            self.magnifier.update()


########NEW FILE########
__FILENAME__ = page
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
A Page is resposible for drawing a page of a Poppler document
inside a layout.
"""

try:
    import popplerqt4
except ImportError:
    from . import popplerqt4_dummy as popplerqt4

from PyQt4.QtCore import QRect, QRectF, QSize

from . import cache
from .locking import lock


class Page(object):
    """Represents a page from a Poppler.Document.
    
    It maintains its own size and can draw itself using the cache.
    It also can maintain a list of links and return links at certain
    points or rectangles.
    
    The visible attribute (setVisible and visible) defaults to True but
    can be set to False to hide the page from a Surface (this is done by
    the Layout).
    
    """
    def __init__(self, document, pageNumber):
        self._document = document
        self._pageNumber = pageNumber
        self._pageSize = document.page(pageNumber).pageSize()
        self._rotation = popplerqt4.Poppler.Page.Rotate0
        self._rect = QRect()
        self._scale = 1.0
        self._visible = True
        self._layout = lambda: None
        self._waiting = True # whether image still needs to be generated
        
    def document(self):
        """Returns the document."""
        return self._document
        
    def pageNumber(self):
        """Returns the page number."""
        return self._pageNumber
    
    def pageSize(self):
        """The page size in points (1/72 inch), taking rotation into account."""
        return self._pageSize
        
    def layout(self):
        """Returns the Layout if we are part of one."""
        return self._layout()
    
    def visible(self):
        """Returns True if this page is visible (will be displayed)."""
        return self._visible
        
    def setVisible(self, visible):
        """Sets whether  this page is visible (will be displayed)."""
        self._visible = visible
        
    def rect(self):
        """Returns our QRect(), with position and size."""
        return self._rect
    
    def size(self):
        """Returns our size."""
        return self._rect.size()
    
    def height(self):
        """Returns our height."""
        return self._rect.height()
        
    def width(self):
        """Returns our width."""
        return self._rect.width()
        
    def pos(self):
        """Returns our position."""
        return self._rect.topLeft()
    
    def setPos(self, point):
        """Sets our position (affects the Layout)."""
        self._rect.moveTopLeft(point)
    
    def setRotation(self, rotation):
        """Sets our Poppler.Page.Rotation."""
        old, self._rotation = self._rotation, rotation
        if (old ^ rotation) & 1:
            self._pageSize.transpose()
            self.computeSize()
    
    def rotation(self):
        """Returns our rotation."""
        return self._rotation
    
    def computeSize(self):
        """Recomputes our size."""
        xdpi, ydpi = self.layout().dpi() if self.layout() else (72.0, 72.0)
        x = round(self._pageSize.width() * xdpi / 72.0 * self._scale)
        y = round(self._pageSize.height() * ydpi / 72.0 * self._scale)
        self._rect.setSize(QSize(x, y))
        
    def setScale(self, scale):
        """Changes the display scale."""
        self._scale = scale
        self.computeSize()
        
    def scale(self):
        """Returns our display scale."""
        return self._scale
    
    def scaleForWidth(self, width):
        """Returns the scale we need to display ourselves at the given width."""
        if self.layout():
            return width * 72.0 / self.layout().dpi()[0] / self._pageSize.width()
        else:
            return float(width) / self._pageSize.width()
        
    def scaleForHeight(self, height):
        """Returns the scale we need to display ourselves at the given height."""
        if self.layout():
            return height * 72.0 / self.layout().dpi()[1] / self._pageSize.height()
        else:
            return float(height) / self._pageSize.height()
        
    def setWidth(self, width):
        """Change our scale to force our width to the given value."""
        self.setScale(self.scaleForWidth(width))

    def setHeight(self, height):
        """Change our scale to force our height to the given value."""
        self.setScale(self.scaleForHeight(height))
        
    def image(self):
        """Render the page as an image or our size. Return a QImage."""
        d = self._document
        w, h, r = self.width(), self.height(), self.rotation()
        page = d.page(self._pageNumber)
        pageSize = page.pageSize()
        if r & 1:
            pageSize.transpose()
        xres = 72.0 * w / pageSize.width()
        yres = 72.0 * h / pageSize.height()
        threshold = cache.options().oversampleThreshold() or cache.options(d).oversampleThreshold()
        multiplier = 2 if xres < threshold else 1
        with lock(d):
            cache.options().write(d)
            cache.options(d).write(d)
            image = page.renderToImage(xres * multiplier, yres * multiplier, 0, 0, w * multiplier, h * multiplier, r)
        if multiplier == 2:
            image = image.scaledToWidth(w, Qt.SmoothTransformation)
        return image
    
    def paint(self, painter, rect):
        update_rect = rect & self.rect()
        if not update_rect:
            return
        image_rect = QRect(update_rect.topLeft() - self.rect().topLeft(), update_rect.size())
        image = cache.image(self)
        self._waiting = not image
        if image:
            painter.drawImage(update_rect, image, image_rect)
        else:
            # schedule an image to be generated, if done our update() method is called
            cache.generate(self)
            # find suitable image to be scaled from other size
            image = cache.image(self, False)
            if image:
                hscale = float(image.width()) / self.width()
                vscale = float(image.height()) / self.height()
                image_rect = QRectF(image_rect.x() * hscale, image_rect.y() * vscale,
                                    image_rect.width() * hscale, image_rect.height() * vscale)
                painter.drawImage(QRectF(update_rect), image, image_rect)
            else:
                # draw blank paper, using the background color of the cache rendering (if set)
                # or from the document itself.
                color = (cache.options(self.document()).paperColor()
                         or cache.options().paperColor() or self.document().paperColor())
                painter.fillRect(update_rect, color)

    def update(self):
        """Called when an image is drawn."""
        # only redraw when we were waiting for a correctly sized image.
        if self._waiting and self.layout():
            self.layout().updatePage(self)
    
    def repaint(self):
        """Call this to force a repaint (e.g. when the rendering options are changed)."""
        self._waiting = True
        cache.generate(self)
    
    def image(self, rect, xdpi=72.0, ydpi=None, options=None):
        """Returns a QImage of the specified rectangle (relative to our layout).
        
        xdpi defaults to 72.0 and ydpi defaults to xdpi.
        options may be a render.RenderOptions instance that will set some document
        rendering options just before rendering the image.
        """
        rect = rect.normalized().intersected(self.rect())
        if not rect:
            return
        rect.translate(-self.pos())
        if ydpi is None:
            ydpi = xdpi
        hscale = (xdpi * self.pageSize().width()) / (72.0 * self.width())
        vscale = (ydpi * self.pageSize().height()) / (72.0 * self.height())
        x = rect.x() * hscale
        y = rect.y() * vscale
        w = rect.width() * hscale
        h = rect.height() * vscale
        with lock(self.document()):
            options and options.write(self.document())
            page = self.document().page(self._pageNumber)
            image = page.renderToImage(xdpi, ydpi, x, y, w, h, self._rotation)
        image.setDotsPerMeterX(int(xdpi * 39.37))
        image.setDotsPerMeterY(int(ydpi * 39.37))
        return image
    
    def linksAt(self, point):
        """Returns a list() of zero or more links touched by point (relative to surface).
        
        The list is sorted with the smallest rectangle first.
        
        """
        # Poppler.Link objects have their linkArea() ranging in width and height
        # from 0.0 to 1.0, so divide by resp. height and width of the Page.
        point = point - self.pos()
        x = float(point.x()) / self.width()
        y = float(point.y()) / self.height()
        # rotate
        if self._rotation:
            if self._rotation == popplerqt4.Poppler.Page.Rotate90:
                x, y = y, 1-x
            elif self._rotation == popplerqt4.Poppler.Page.Rotate180:
                x, y = 1-x, 1-y
            else: # 270
                x, y = 1-y, x
        return list(sorted(cache.links(self).at(x, y), key=lambda link: link.linkArea().width()))
        
    def linksIn(self, rect):
        """Returns an unordered set() of links enclosed in rectangle (relative to surface)."""
        rect = rect.normalized()
        rect.translate(-self.pos())
        left   = float(rect.left())   / self.width()
        top    = float(rect.top())    / self.height()
        right  = float(rect.right())  / self.width()
        bottom = float(rect.bottom()) / self.height()
        # rotate
        if self._rotation:
            if self._rotation == popplerqt4.Poppler.Page.Rotate90:
                left, top, right, bottom = top, 1-right, bottom, 1-left
            elif self._rotation == popplerqt4.Poppler.Page.Rotate180:
                left, top, right, bottom = 1-right, 1-bottom, 1-left, 1-top
            else: # 270
                left, top, right, bottom = 1-bottom, left, 1-top, right
        return cache.links(self).inside(left, top, right, bottom)

    def linkRect(self, linkarea):
        """Returns a QRect encompassing the linkArea (of a link) in coordinates of our rect()."""
        left, top, right, bottom = linkarea.normalized().getCoords()
        # rotate
        if self._rotation:
            if self._rotation == popplerqt4.Poppler.Page.Rotate90:
                left, top, right, bottom = 1-bottom, left, 1-top, right
            elif self._rotation == popplerqt4.Poppler.Page.Rotate180:
                left, top, right, bottom = 1-right, 1-bottom, 1-left, 1-top
            else: # 270
                left, top, right, bottom = top, 1-right, bottom, 1-left
        rect = QRect()
        rect.setCoords(left * self.width(), top * self.height(), right * self.width(), bottom * self.height())
        rect.translate(self.pos())
        return rect
        
    def text(self, rect):
        """Returns text inside rectangle (relative to surface)."""
        rect = rect.normalized()
        rect.translate(-self.pos())
        w, h = self.pageSize().width(), self.pageSize().height()
        left   = float(rect.left())   / self.width()  * w
        top    = float(rect.top())    / self.height() * h
        right  = float(rect.right())  / self.width()  * w
        bottom = float(rect.bottom()) / self.height() * h
        if self._rotation:
            if self._rotation == popplerqt4.Poppler.Page.Rotate90:
                left, top, right, bottom = top, w-right, bottom, w-left
            elif self._rotation == popplerqt4.Poppler.Page.Rotate180:
                left, top, right, bottom = w-right, h-bottom, w-left, h-top
            else: # 270
                left, top, right, bottom = h-bottom, left, h-top, right
        rect = QRectF()
        rect.setCoords(left, top, right, bottom)
        with lock(self.document()):
            page = self.document().page(self._pageNumber)
            return page.text(rect)
        
    def searchRect(self, rectF):
        """Returns a QRect encompassing the given rect (in points) to our position, size and rotation."""
        rect = rectF.normalized()
        left, top, right, bottom = rect.getCoords()
        w, h = self.pageSize().width(), self.pageSize().height()
        hscale = self.width()  / float(w)
        vscale = self.height() / float(h)
        if self._rotation:
            if self._rotation == popplerqt4.Poppler.Page.Rotate90:
                left, top, right, bottom = w-bottom, left, w-top, right
            elif self._rotation == popplerqt4.Poppler.Page.Rotate180:
                left, top, right, bottom = w-right, h-bottom, w-left, h-top
            else: # 270
                left, top, right, bottom = top, h-right, bottom, h-left
        rect = QRect()
        rect.setCoords(left * hscale, top * vscale, right * hscale, bottom * vscale)
        return rect
        

########NEW FILE########
__FILENAME__ = pager
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
Provides an interface for paging in a View by page number.
"""


from PyQt4.QtCore import pyqtSignal, QEvent, QTimer, QObject


class Pager(QObject):
    """Provides an interface for paging in a View by page number.
    
    Pages are numbered starting with 1 in this api!
    
    """
    currentPageChanged = pyqtSignal(int)
    pageCountChanged = pyqtSignal(int)
    
    def __init__(self, view):
        """Initializes the Pager with the View.
        
        Also connects with the Surface of the View and its Layout,
        so don't interchange them after initializing the Pager.
        
        """
        super(Pager, self).__init__(view)
        self._currentPage = 0
        self._pageCount = 0
        self._blockLevel = 0
        self._updateTimer = QTimer(
            singleShot=True, interval=100, timeout=self._updatePageNumber)
        
        # connect
        view.installEventFilter(self)
        view.surface().installEventFilter(self)
        view.surface().pageLayout().changed.connect(self._layoutChanged)
        
        # Connect to the kineticScrollingEnabled signal to avoid uneeded updates.
        view.kineticScrollingActive.connect(self.blockListening)
        
    def currentPage(self):
        """Returns the current page number (0 if there are no pages)."""
        return self._currentPage
        
    def setCurrentPage(self, num):
        """Shows the specified page number."""
        changed, self._currentPage = self._currentPage != num, num
        self.blockListening(True)
        self.view().gotoPageNumber(num - 1)
        self.blockListening(False)
        if changed:
            self.currentPageChanged.emit(self._currentPage)
        
    def pageCount(self):
        """Returns the number of pages."""
        return self._pageCount
    
    def view(self):
        return self.parent()
    
    def _layoutChanged(self):
        """Called internally whenever the layout is updated."""
        layout = self.view().surface().pageLayout()
        self._pageCount, old = len(layout), self._pageCount
        if old != self._pageCount:
            self.pageCountChanged.emit(self._pageCount)
        self._updatePageNumber()
    
    def _updatePageNumber(self):
        """Called internally on layout change or view resize or surface move."""
        self._currentPage, old = self.view().currentPageNumber() + 1, self._currentPage
        if self._currentPage == 0 and self._pageCount > 0:
            # the view may not be initialized
            self._currentPage = 1
        if old != self._currentPage:
            self.currentPageChanged.emit(self._currentPage)

    def blockListening(self, block):
        """Block/unblock listening to event, used to avoid multiple updates when we know lots
        of events are going to be sent to the pager.
        
        Blocking can be nested, only the outmost unblock will really unblock the event processing."""
        if block:
            self._blockLevel += 1
        else:
            self._blockLevel -= 1
        
        if self._blockLevel == 0:
            self._updatePageNumber()

    def eventFilter(self, obj, ev):
        if (self._blockLevel == 0 and
            ((ev.type() == QEvent.Resize and obj is self.view())
             or (ev.type() == QEvent.Move and obj is self.view().surface()))
            and not self._updateTimer.isActive()):
            self._updateTimer.start()
        return False



########NEW FILE########
__FILENAME__ = popplerqt4_dummy
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
A dummy module containing a few of the definitions in popplerqt4.

This is imported if the real popplerqt4 is not available and makes it
possible to import qpopplerview, although it can't do anything useful.

It only contains class definitions that define a namespace, enums or other
constants. Classes can't be instantiated and have no member functions.

"""


__all__ = ["Poppler"]


class _noinst(object):
    """A class that can't be instantiated."""
    def __new__(cls, *args, **kwargs):
        raise TypeError, "can't instantiate %s" % cls.__name__
        

class Poppler(_noinst):
    class Document(_noinst):
        def load(filename): pass
        def loadFromData(data): pass
        class RenderHint(int): pass
        Antialiasing = RenderHint(1)
        TextAntialiasing = RenderHint(2)
        TextHinting = RenderHint(4)
        
    class Page(_noinst):
        class Orientation(int): pass
        Landscape = Orientation(0)
        Portrait = Orientation(1)
        Seascape = Orientation(2)
        UpsideDown = Orientation(3)
        
        class PageAction(int): pass
        Opening = PageAction(0)
        Closing = PageAction(1)
        
        class PainterFlag(int): pass
        DontSaveAndRestore = PainterFlag(1)
        
        class Rotation(int): pass
        Rotate0 = Rotation(0)
        Rotate90 = Rotation(1)
        Rotate180 = Rotation(2)
        Rotate270 = Rotation(3)
        
        class SearchDirection(int): pass
        NextResult = SearchDirection(0)
        PreviousResult = SearchDirection(1)
        
        class SearchMode(int): pass
        CaseSensitive = SearchMode(0)
        CaseInsensitive = SearchMode(1)
        
        class TextLayout(int): pass
        PhysicalLayout = TextLayout(0)
        RawOrderLayout = TextLayout(1)
        
        
    class LinkDestination(_noinst): pass
    
    class Link(_noinst): pass
    class LinkAction(Link): pass
    class LinkAnnotation(Link):pass
    class LinkBrowse(Link): pass
    class LinkExecute(Link): pass
    class LinkGoto(Link): pass
    class LinkJavaScript(Link): pass
    class LinkSound(Link): pass



########NEW FILE########
__FILENAME__ = printer
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
Printing functionality.
"""

from PyQt4.QtCore import QFile, QIODevice, Qt
from PyQt4.QtGui import QColor, QPainter, QPrinter

from .locking import lock
from . import render


def psfile(doc, printer, output, pageList=None, margins=(0, 0, 0, 0)):
    """Writes a PostScript rendering of a Poppler::Document to the output.
    
    doc: a Poppler::Document instance
    printer: a QPrinter instance from which the papersize is read
    output: a filename or opened QIODevice (will not be closed)
    pageList: a list of page numbers. By default the pagerange is read
        from the QPrinter instance. Page numbers start with 1.
    margins: a sequence of four values describing the margins (left, top, right,
        bottom) in Point (1/72 inch), all defaulting to 0.
    
    Returns True on success, False on error.
    
    """
    if pageList is None:
        if (printer.printRange() == QPrinter.AllPages
            or (printer.fromPage() == 0 and printer.toPage() == 0)):
            pageList = list(range(1, doc.numPages() + 1))
        else:
            pageList = list(range(max(printer.fromPage(), 1), min(printer.toPage(), doc.numPages()) + 1))
    else:
        for num in pageList:
            if num < 1 or num > doc.numPages():
                raise ValueError, "invalid page number: {0}".format(num)
    
    ps = doc.psConverter()
    ps.setPageList(pageList)
        
    if isinstance(output, QIODevice):
        ps.setOutputDevice(output)
    else:
        ps.setOutputFileName(output)
    
    paperSize = printer.paperSize(QPrinter.Point)
    ps.setPaperHeight(paperSize.height())
    ps.setPaperWidth(paperSize.width())
    
    left, top, right, bottom = margins
    ps.setLeftMargin(left)
    ps.setTopMargin(top)
    ps.setRightMargin(right)
    ps.setBottomMargin(bottom)
    
    with lock(doc):
        return ps.convert()


class Printer(object):
    """Prints a Poppler.Document to a QPrinter.
    
    This is currently done using raster images at (by default) 300 DPI,
    because the Arthur backend of Poppler (that can render to a painter)
    does not work correctly in all cases and is not well supported by
    the Poppler developers at this time.
    
    """
    def __init__(self):
        self._stop = False
        self._resolution = 300
        self._document = None
        self._printer = None
        opts = render.RenderOptions()
        opts.setRenderHint(0)
        opts.setPaperColor(QColor(Qt.white))
        self.setRenderOptions(opts)
        
    def setDocument(self, document):
        """Sets the Poppler.Document to print (mandatory)."""
        self._document = document
        
    def document(self):
        """Returns the previously set Poppler.Document."""
        return self._document
        
    def setPrinter(self, printer):
        """Sets the QPrinter to print to (mandatory)."""
        self._printer = printer
        
    def printer(self):
        """Returns the previously set QPrinter."""
        return self._printer
    
    def setResolution(self, dpi):
        """Sets the resolution in dots per inch."""
        self._resolution = dpi
    
    def resolution(self):
        """Returns the resolution in dots per inch."""
        return self._resolution
    
    def setRenderOptions(self, options):
        """Sets the render options (see render.py)."""
        self._renderoptions = options
    
    def renderOptions(self):
        """Returns the render options (see render.py).
        
        By default, all antialiasing is off and the papercolor is white.
        
        """
        return self._renderoptions
        
    def pageList(self):
        """Should return a list of desired page numbers (starting with 1).
        
        The default implementation reads the pages from the QPrinter.
        
        """
        p = self.printer()
        if (p.printRange() == QPrinter.AllPages
            or (p.fromPage() == 0 and p.toPage() == 0)):
            pages = range(1, self.document().numPages() + 1)
        else:
            pages = range(max(p.fromPage(), 1), min(p.toPage(), self.document().numPages()) + 1)
        return list(pages)
    
    def print_(self):
        """Prints the document."""
        self._stop = False
        resolution = self.resolution()
        p = self.printer()
        p.setFullPage(True)
        p.setResolution(resolution)
        
        center = p.paperRect().center()
        painter = QPainter(p)
        
        pages  = self.pageList()
        if p.pageOrder() != QPrinter.FirstPageFirst:
            pages.reverse()

        total = len(pages)
        
        opts = self.renderOptions()
        document = self.document()
        
        for num, pageNum in enumerate(pages, 1):
            if self._stop:
                return p.abort()
            self.progress(num, total, pageNum)
            if num > 1:
                p.newPage()
            with lock(document):
                opts.write(document)
                page = document.page(pageNum - 1)
                img = page.renderToImage(resolution, resolution)
            rect = img.rect()
            rect.moveCenter(center)
            painter.drawImage(rect, img)
        
        return painter.end()
        
    def abort(self):
        """Instructs the printer to cancel the job."""
        self._stop = True

    def aborted(self):
        """Returns whether abort() was called."""
        return self._stop
        
    def progress(self, num, total, pageNumber):
        """Called when printing a page.
        
        num: counts the pages (starts with 1)
        total: the total number of pages
        pageNumber: the page number in the document (starts also with 1)
        
        The default implementation does nothing.
        
        """
        pass



########NEW FILE########
__FILENAME__ = rectangles
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
Manages lists of rectangular objects and quickly finds them.
"""

import bisect


Left   = 0
Top    = 1
Right  = 2
Bottom = 3


class Rectangles(object):
    """
    Manages a list of rectangular objects and quickly finds objects at
    some point, in some rectangle or intersecting some rectangle.
    
    The implementation uses four lists of the objects sorted on either
    coordinate, so retrieval is fast.
    
    Bulk adding is done in the constructor or via the bulk_add() method (which
    clears the indexes, that are recreated on first search).  Single objects
    can be added and deleted, keeping the indexes, but that's slower.
    
    """
    _func = lambda obj: obj.rect().normalized().getCoords()
    
    def __init__(self, objects=None, func=None):
        """Initializes the Rectangles object.
        
        objects should be an iterable of rectangular objects.
        
        function(obj) should return a four-tuple (left, top, right, bottom)
        of the coordinates of the rectangle.  The coordinates should be normalized,
        i.e. top <= bottom and left <= right.
        
        The default function is: lambda obj: obj.rect().normalized().getCoords()
        
        """
        self._items = {} # maps object to the result of func(object)
        self._index = {} # maps side to indices, objects (index=coordinate of that side)
        if func:
            self._func = func
        if objects:
            self.bulk_add(objects)
    
    def add(self, obj):
        """Adds an object to our list. Keeps the index intact."""
        if obj in self._items:
            return
        self._items[obj] = coords = self._func(obj)
        for side, (indices, objects) in self._index.items():
            i = bisect.bisect_left(indices, coords[side])
            indices.insert(i, coords[side])
            objects.insert(i, obj)
    
    def bulk_add(self, objects):
        """Adds many new items to the index using the function given in the constructor.
        
        After this, the index is cleared and recreated on the first search operation.
        
        """
        self._items.update((obj, self._func(obj)) for obj in objects)
        self._index.clear()
        
    def remove(self, obj):
        """Removes an object from our list. Keeps the index intact."""
        del self._items[obj]
        for indices, objects in self._index.values():
            i = objects.index(obj)
            del objects[i]
            del indices[i]
            
    def clear(self):
        """Empties the list of items."""
        self._items.clear()
        self._index.clear()
        
    def at(self, x, y):
        """Returns a set() of objects that are touched by the given point."""
        return self._test(
            (self._smaller, Top, y),
            (self._larger, Bottom, y),
            (self._smaller, Left, x),
            (self._larger, Right, x))
         
    def inside(self, left, top, right, bottom):
        """Returns a set() of objects that are fully in the given rectangle."""
        return self._test(
            (self._larger, Top, top),
            (self._smaller, Bottom, bottom),
            (self._larger, Left, left),
            (self._smaller, Right, right))
    
    def intersecting(self, left, top, right, bottom):
        """Returns a set() of objects intersecting the given rectangle."""
        return self._test(
            (self._smaller, Top, bottom),
            (self._larger, Bottom, top),
            (self._smaller, Left, right),
            (self._larger, Right, left))

    def closest(self, obj, side):
        """Returns the object closest to the given one, going to the given side."""
        coords = self._items[obj]
        pos = coords[side^2]
        lat = (coords[side^1|2] - coords[side^1&2]) / 2.0
        direction = -1 if side < Right else 1
        indices, objects = self._sorted(side^2)
        i = objects.index(obj)
        mindist = indices[-1]
        result = []
        for other in objects[i+direction::direction]:
            coords = self._items[other]
            pos1 = coords[side^2]
            d = abs(pos1 - pos)
            if d > mindist:
                break
            lat1 = (coords[side^1|2] - coords[side^1&2]) / 2.0
            dlat = abs(lat1 - lat)
            if dlat < d:
                dist = dlat + d  # manhattan dist
                result.append((other, dist))
                mindist = min(mindist, dist)
        if result:
            result.sort(key=lambda r: r[1])
            return result[0][0]

    def __len__(self):
        return len(self._items)
        
    def __contains__(self, obj):
        return obj in self._items
        
    def __nonzero__(self):
        return bool(self._items)
        
    # private helper methods
    def _test(self, *tests):
        """Performs tests and returns objects that fulfill all of them.
        
        Every test should be a three tuple(method, side, value).
        Method is either self._smaller or self._larger.
        Returns a (possibly empty) set.
        
        """
        result = None
        for meth, side, value in tests:
            objects = meth(side, value)
            if not result:
                result = set(objects)
            else:
                result &= set(objects)
            if not result:
                break
        return result
    
    def _smaller(self, side, value):
        """Returns objects for side below value."""
        indices, objects = self._sorted(side)
        i = bisect.bisect_right(indices, value)
        return objects[:i]

    def _larger(self, side, value):
        """Returns objects for side above value."""
        indices, objects = self._sorted(side)
        i = bisect.bisect_left(indices, value)
        return objects[i:]
        
    def _sorted(self, side):
        """Returns a two-tuple (indices, objects) sorted on index for the given side.""" 
        try:
            return self._index[side]
        except KeyError:
            if self._items:
                objects = [(coords[side], obj) for obj, coords in self._items.items()]
                objects.sort()
                result = tuple(map(list, zip(*objects)))
            else:
                result = [], []
            self._index[side] = result
            return result
            


########NEW FILE########
__FILENAME__ = render
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
Rendering Poppler (PDF) documents helper stuff.
"""


class RenderOptions(object):
    """Manages rendering options."""
    def __init__(self):
        self._renderHint = None
        self._paperColor = None
        self._oversampleThreshold = 0
    
    def read(self, document):
        """Reads rendering options from the given Poppler.Document."""
        self._renderHint = document.renderHints()
        self._paperColor = document.paperColor()
        
    def write(self, document):
        """Writes our rendering options to the given Poppler.Document."""
        if self._renderHint is not None:
            document.setRenderHint(int(document.renderHints()), False)
            document.setRenderHint(self._renderHint)
        
        if self._paperColor is not None:
            document.setPaperColor(self._paperColor)
        
    def setRenderHint(self, hint):
        """Sets the Poppler.Document.RenderHints. Use None to unset."""
        self._renderHint = hint
    
    def renderHint(self):
        """Returns the currently set RenderHint(s)."""
        return self._renderHint
        
    def setPaperColor(self, color):
        """Sets the paper color for rendering. Use None to unset."""
        self._paperColor = color
        
    def paperColor(self):
        """Returns the currently set paper color."""
        return self._paperColor
    
    def setOversampleThreshold(self, value):
        """Sets the oversample threshold resolution.
        
        Below this resolution, the image will be rendered in double size
        and scaled down, to provide a smoother image. Otherwise, the horizontal
        lines may appear too thick.
        
        The default value is 0, meaning no oversampling.
        
        """
        self._oversampleThreshold = value
        
    def oversampleThreshold(self):
        """Return the current oversample threshold resolution."""
        return self._oversampleThreshold



########NEW FILE########
__FILENAME__ = surface
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
Surface is the widget everything is drawn on.
"""

import itertools
import weakref

from PyQt4.QtCore import QEvent, QPoint, QRect, QSize, Qt, QTimer, pyqtSignal
from PyQt4.QtGui import (
    QApplication, QContextMenuEvent, QCursor, QPainter, QPalette,
    QRegion, QRubberBand, QToolTip, QWidget, QColor, QBrush, QPen)

try:
    import popplerqt4
except ImportError:
    from . import popplerqt4_dummy as popplerqt4

from . import layout
from . import page
from . import highlight
from . import magnifier

# most used keyboard modifiers
_SCAM = (Qt.SHIFT | Qt.CTRL | Qt.ALT | Qt.META)

# dragging/moving selection:
_OUTSIDE = 0
_LEFT    = 1
_TOP     = 2
_RIGHT   = 4
_BOTTOM  = 8
_INSIDE  = 15

class CustomRubberBand(QWidget):
    """Reimplement QRubberband from scratch, to avoid styling issues."""
    def __init__(self, parent):
        super(CustomRubberBand, self).__init__(parent)
        self.setMouseTracking(True)

    def paintEvent(self, ev):
        color = self.palette().color(QPalette.Highlight)
        painter = QPainter(self)

        # Filled rectangle.
        painter.setClipRect(self.rect())
        color.setAlpha(50)
        painter.fillRect(self.rect().adjusted(2,2,-2,-2), color)

        # Thin rectangle outside.
        color.setAlpha(150)
        painter.setPen(color)
        painter.drawRect(self.rect().adjusted(0,0,-1,-1))

        # Pseudo-handles at the corners and sides
        color.setAlpha(100)
        pen = QPen(color)
        pen.setWidth(8)
        painter.setPen(pen)
        painter.setBackgroundMode(Qt.OpaqueMode)
        # Clip at 4 corners
        region = QRegion(QRect(0,0,20,20))
        region += QRect(self.rect().width()-20, 0, 20, 20)
        region += QRect(self.rect().width()-20, self.rect().height()-20, 20, 20)
        region += QRect(0, self.rect().height()-20, 20, 20)
        # Clip middles
        region += QRect(0, self.rect().height()/2-10, self.rect().width(), 20)
        region += QRect(self.rect().width()/2-10, 0, 20, self.rect().height())
        
        # Draw thicker rectangles, clipped at corners and sides.
        painter.setClipRegion(region)
        painter.drawRect(self.rect())
 
class Surface(QWidget):
    
    rightClicked = pyqtSignal(QPoint)
    linkClicked = pyqtSignal(QEvent, page.Page, popplerqt4.Poppler.Link)
    linkHovered = pyqtSignal(page.Page, popplerqt4.Poppler.Link)
    linkLeft = pyqtSignal()
    linkHelpRequested = pyqtSignal(QPoint, page.Page, popplerqt4.Poppler.Link)    
    selectionChanged = pyqtSignal(QRect)
    
    def __init__(self, view):
        super(Surface, self).__init__(view)
        self.setBackgroundRole(QPalette.Dark)
        self._view = weakref.ref(view)
        self._currentLinkId = None
        self._selecting = False
        self._magnifying = False
        self._magnifier = None
        self.setMagnifier(magnifier.Magnifier())
        self.setMagnifierModifiers(Qt.CTRL)
        self._selection = QRect()
        self._rubberBand = CustomRubberBand(self)
        self._scrolling = False
        self._scrollTimer = QTimer(interval=100, timeout=self._scrollTimeout)
        self._pageLayout = None
        self._highlights = weakref.WeakKeyDictionary()
        self.setPageLayout(layout.Layout())
        self.setContextMenuPolicy(Qt.PreventContextMenu)
        self.setLinksEnabled(True)
        self.setSelectionEnabled(True)
        self.setShowUrlTips(True)
        
        self.view().cursorNeedUpdate.connect(self.updateCursor)
 
    def pageLayout(self):
        return self._pageLayout
        
    def setPageLayout(self, layout):
        old, self._pageLayout = self._pageLayout, layout
        if old:
            old.redraw.disconnect(self.redraw)
            old.changed.disconnect(self.updateLayout)
        layout.redraw.connect(self.redraw)
        layout.changed.connect(self.updateLayout)
    
    def view(self):
        """Returns our associated View."""
        return self._view()
    
    def viewportRect(self):
        """Returns the rectangle of us that is visible in the View."""
        return self.view().viewport().rect().translated(-self.pos())
        
    def setSelectionEnabled(self, enabled):
        """Enables or disables selecting rectangular regions."""
        self._selectionEnabled = enabled
        if not enabled:
            self.clearSelection()
            self._rubberBand.hide()
            self._selecting = False
    
    def selectionEnabled(self):
        """Returns True if selecting rectangular regions is enabled."""
        return self._selectionEnabled
        
    def setLinksEnabled(self, enabled):
        """Enables or disables the handling of Poppler.Links in the pages."""
        self._linksEnabled = enabled
    
    def linksEnabled(self):
        """Returns True if the handling of Poppler.Links in the pages is enabled."""
        return self._linksEnabled
    
    def setShowUrlTips(self, enabled):
        """Enables or disables showing the URL in a tooltip when hovering a link.
        
        (Of course also setLinksEnabled(True) if you want this.)
        
        """
        self._showUrlTips = enabled
        
    def showUrlTips(self):
        """Returns True if URLs are shown in a tooltip when hovering a link."""
        return self._showUrlTips
        
    def setMagnifier(self, magnifier):
        """Sets the Magnifier to use (or None to disable the magnifier).
        
        The Surface takes ownership of the Magnifier.
        
        """
        if self._magnifier:
            self._magnifier.setParent(None)
        magnifier.setParent(self)
        self._magnifier = magnifier
    
    def magnifier(self):
        """Returns the currently set magnifier."""
        return self._magnifier
    
    def setMagnifierModifiers(self, modifiers):
        """Sets the modifiers (e.g. Qt.CTRL) to show the magnifier.
        
        Use None to show the magnifier always (instead of dragging).
        
        """
        self._magnifierModifiers = modifiers
    
    def magnifierModifiers(self):
        """Returns the currently set keyboard modifiers (e.g. Qt.CTRL) to show the magnifier."""
        return self._magnifierModifiers
        
    def hasSelection(self):
        """Returns True if there is a selection."""
        return bool(self._selection)
        
    def setSelection(self, rect):
        """Sets the selection rectangle."""
        rect = rect.normalized()
        old, self._selection = self._selection, rect
        self._rubberBand.setGeometry(rect)
        self._rubberBand.setVisible(bool(rect))
        if rect != old:
            self.selectionChanged.emit(rect)
        
    def selection(self):
        """Returns the selection rectangle (normalized) or an invalid QRect()."""
        return QRect(self._selection)
    
    def clearSelection(self):
        """Hides the selection rectangle."""
        self.setSelection(QRect())
        
    def redraw(self, rect):
        """Called when the Layout wants to redraw a rectangle."""
        self.update(rect)
        
    def updateLayout(self):
        """Conforms ourselves to our layout (that must already be updated.)"""
        self.clearSelection()
        self.resize(self._pageLayout.size())
        self.update()
        
    def highlight(self, highlighter, areas, msec=0):
        """Highlights the list of areas using the given highlighter.
        
        Every area is a two-tuple (page, rect), where rect is a rectangle inside (0, 0, 1, 1) like the
        linkArea attribute of a Poppler.Link.
        
        """
        d = weakref.WeakKeyDictionary()
        for page, areas in itertools.groupby(sorted(areas), lambda a: a[0]):
            d[page] = list(area[1] for area in areas)
        if msec:
            def clear(selfref=weakref.ref(self)):
                self = selfref()
                if self:
                    self.clearHighlight(highlighter)
            t = QTimer(singleShot = True, timeout = clear)
            t.start(msec)
        else:
            t = None
        self.clearHighlight(highlighter)
        self._highlights[highlighter] = (d, t)
        self.update(sum((page.rect() for page in d), QRegion()))
        
    def clearHighlight(self, highlighter):
        """Removes the highlighted areas of the given highlighter."""
        try:
            (d, t) = self._highlights[highlighter]
        except KeyError:
            return
        del self._highlights[highlighter]
        self.update(sum((page.rect() for page in d), QRegion()))
    
    def paintEvent(self, ev):
        """Handle PaintEvent on the surface to highlight the selection."""
        painter = QPainter(self)
        pages = list(self.pageLayout().pagesAt(ev.rect()))
        for page in pages:
            page.paint(painter, ev.rect())
        
        for highlighter, (d, t) in self._highlights.items():
            rects = []
            for page in pages:
                try:
                    rects.extend(map(page.linkRect, d[page]))
                except KeyError:
                    continue
            if rects:
                highlighter.paintRects(painter, rects)
    
    def handleMousePressEvent(self, ev):
        """Handle mouse press for various operations
            - links to source,
            - magnifier, 
            - selection highlight,
            
            If event was used, return true to indicate processing should stop.
        """
        
        # As the event comes from the view, we need to map it locally.
        pos = self.mapFromParent(ev.pos())
               
        # selecting?
        if self._selectionEnabled:
            if self.hasSelection():
                edge = selectionEdge(pos, self.selection())
                if edge == _OUTSIDE:
                    self.clearSelection()
                else:
                    if ev.button() != Qt.RightButton or edge != _INSIDE:
                        self._selecting = True
                        self._selectionEdge = edge
                        self._selectionRect = self.selection()
                        self._selectionPos = pos
                        if edge == _INSIDE:
                            self.setCursor(Qt.SizeAllCursor)
                    return True
            if not self._selecting:
                if ev.modifiers() & Qt.ShiftModifier and ev.button() == Qt.LeftButton and self._linksEnabled:
                    page, link = self.pageLayout().linkAt(pos)
                    if link:
                        self.linkClickEvent(ev, page, link)
                        return True
                if ev.button() == Qt.RightButton or int(ev.modifiers()) & _SCAM:
                    if not (int(ev.modifiers()) & _SCAM == self._magnifierModifiers 
                            and  ev.button() == Qt.LeftButton):
                        self._selecting = True
                        self._selectionEdge = _RIGHT | _BOTTOM
                        self._selectionRect = QRect(pos, QSize(0, 0))
                        self._selectionPos = pos
                        return True
        
        # link?
        if self._linksEnabled:
            page, link = self.pageLayout().linkAt(pos)
            if link:
                self.linkClickEvent(ev, page, link)
                return True
        # magnifier?
        if (self._magnifier and
            int(ev.modifiers()) & _SCAM == self._magnifierModifiers and
            ev.button() == Qt.LeftButton):
            self._magnifier.moveCenter(pos)
            self._magnifier.show()
            self._magnifier.raise_()
            self._magnifying = True
            self.setCursor(QCursor(Qt.BlankCursor))
            return True

        return False
        
    def handleMouseReleaseEvent(self, ev):
        """Handle mouse release events for various operations:
            - hide magnifier,
            - selection.
            
            If event was used, return true to indicate processing should stop.
        """
        consumed = False
        if self._magnifying:
            self._magnifier.hide()
            self._magnifying = False
            self.unsetCursor() 
            consumed = True
        elif self._selecting:
            self._selecting = False
            selection = self._selectionRect.normalized()
            if selection.width() < 8 and selection.height() < 8:
                self.clearSelection()
            else:
                self.setSelection(selection)
            if self._scrolling:
                self.stopScrolling()
            self.unsetCursor() 
            consumed = True
        if ev.button() == Qt.RightButton:
            # As the event comes from the view, we need to map it locally.
            self.rightClick(self.mapFromParent(ev.pos()))
            consumed = True
        
        return consumed
            
    def handleMouseMoveEvent(self, ev):
        """Handle mouse move events for various operations:
            - move magnifier,
            - selection extension.
            
            If event was used, return true to indicate processing should stop.
        """
        consumed = False 
        if self._magnifying:
            # As the event comes from the view, we need to map it locally.
            self._magnifier.moveCenter(self.mapFromParent(ev.pos()))
            consumed = True
        elif self._selecting:
            # As the event comes from the view, we need to map it locally.
            pos = self.mapFromParent(ev.pos())
            self._moveSelection(pos)
            self._rubberBand.show()
            # check if we are dragging close to the edge of the view, scroll if needed
            view = self.viewportRect()
            dx = pos.x() - view.left() - 12
            if dx >= 0:
                dx = pos.x() - view.right() + 12
                if dx < 0:
                    dx = 0
            dy = pos.y() - view.top() - 12
            if dy >= 0:
                dy = pos.y() - view.bottom() + 12
                if dy < 0:
                    dy = 0
            if dx or dy:
                self.startScrolling(dx, dy)
            elif self._scrolling:
                self.stopScrolling()
            consumed = True
              
        return consumed
        
    def handleMoveEvent(self, ev):
        """Handle  move events for various operations:
            - move magnifier,
            - selection extension.
            
            If event was used, return true to indicate processing should stop.
        """
        consumed = False
        pos = self.mapFromGlobal(QCursor.pos())
        if self._selecting:
            self._moveSelection(pos)
            consumed = True
        elif self._magnifying:
            self._magnifier.moveCenter(pos)
            consumed = True

        return consumed
        
    def handleHelpEvent(self, ev):
        """Handle help event: show link if any."""
        if self._linksEnabled:
            page, link = self.pageLayout().linkAt(self.mapFromParent(ev.pos()))
            if link:
                self.linkHelpEvent(ev.globalPos(), page, link)
        return True

    def updateKineticCursor(self, active):
        """Cursor handling when kinetic move starts/stops.
        
        - reset the cursor and hide tooltips if visible at start,
        - update the cursor and show the appropriate tooltips at stop.
        
        Used as a slot linked to the kineticStarted() signal.
        """
        if active:
            self.unsetCursor()
            if QToolTip.isVisible():
                QToolTip.hideText()
        else:
            self.updateCursor(QCursor.pos())
            if self._linksEnabled:
                page, link = self.pageLayout().linkAt(self.mapFromGlobal(QCursor.pos()))
                if link:
                    self.linkHelpEvent(QCursor.pos(), page, link)

    def updateCursor(self, evpos):
        """Set the cursor to the right glyph, depending on action""" 
        pos = self.mapFromGlobal(evpos)
        cursor = None
        edge = _OUTSIDE
        if self._selectionEnabled and self.hasSelection():
            edge = selectionEdge(pos, self.selection())
            
        if edge is not _OUTSIDE:
            if edge in (_TOP, _BOTTOM):
                cursor = Qt.SizeVerCursor
            elif edge in (_LEFT, _RIGHT):
                cursor = Qt.SizeHorCursor
            elif edge in (_LEFT | _TOP, _RIGHT | _BOTTOM):
                cursor = Qt.SizeFDiagCursor
            elif edge in (_TOP | _RIGHT, _BOTTOM | _LEFT):
                cursor = Qt.SizeBDiagCursor
            elif edge is _INSIDE:
                cursor = Qt.SizeAllCursor

        elif self._linksEnabled:
            page, link = self.pageLayout().linkAt(pos)
            if link:
                cursor = Qt.PointingHandCursor
                lid = id(link)
            else:
                lid = None
            if lid != self._currentLinkId:
                if self._currentLinkId is not None:
                    self.linkHoverLeave()
                self._currentLinkId = lid
                if link:
                    self.linkHoverEnter(page, link)
        
        self.setCursor(cursor) if cursor else self.unsetCursor()
    
    def linkHelpEvent(self, globalPos, page, link):
        """Called when a QHelpEvent occurs on a link.
        
        The default implementation shows a tooltip if showUrls() is True,
        and emits the linkHelpRequested() signal.
        
        """
        if self._showUrlTips and isinstance(link, popplerqt4.Poppler.LinkBrowse):
            QToolTip.showText(globalPos, link.url(), self, page.linkRect(link.linkArea()))
        self.linkHelpRequested.emit(globalPos, page, link)
        
    def rightClick(self, pos):
        """Called when the right mouse button is released.
        
        (Use this instead of the contextMenuEvent as that one also
        fires when starting a right-button selection.)
        The default implementation emite the rightClicked(pos) signal and also
        sends a ContextMenu event to the View widget.
        
        """
        self.rightClicked.emit(pos)
        QApplication.postEvent(self.view().viewport(), QContextMenuEvent(QContextMenuEvent.Mouse, pos + self.pos()))
        
    def linkClickEvent(self, ev, page, link):
        """Called when a link is clicked.
        
        The default implementation emits the linkClicked(event, page, link) signal.
        
        """
        self.linkClicked.emit(ev, page, link)
        
    def linkHoverEnter(self, page, link):
        """Called when the mouse hovers over a link.
        
        The default implementation emits the linkHovered(page, link) signal.
        
        """
        self.linkHovered.emit(page, link)
        
    def linkHoverLeave(self):
        """Called when the mouse does not hover a link anymore.
        
        The default implementation emits the linkLeft() signal.
        
        """
        self.linkLeft.emit()

    def startScrolling(self, dx, dy):
        """Starts scrolling dx, dy about 10 times a second.
        
        Stops automatically when the end is reached.
        
        """
        self._scrolling = QPoint(dx, dy)
        self._scrollTimer.isActive() or self._scrollTimer.start()
        
    def stopScrolling(self):
        """Stops scrolling."""
        self._scrolling = False
        self._scrollTimer.stop()
        
    def _scrollTimeout(self):
        """(Internal) Called by the _scrollTimer."""
        # change the scrollbars, but check how far they really moved.
        pos = self.pos()
        self.view().fastScrollBy(self._scrolling)
        diff = pos - self.pos()
        if not diff:
            self.stopScrolling()
    
    def _moveSelection(self, pos):
        """(Internal) Moves the dragged selection edge or corner to the given pos (QPoint)."""
        diff = pos - self._selectionPos
        self._selectionPos = pos
        edge = self._selectionEdge
        self._selectionRect.adjust(
            diff.x() if edge & _LEFT   else 0,
            diff.y() if edge & _TOP    else 0,
            diff.x() if edge & _RIGHT  else 0,
            diff.y() if edge & _BOTTOM else 0)
        self._rubberBand.setGeometry(self._selectionRect.normalized())
        if self.cursor().shape() in (Qt.SizeBDiagCursor, Qt.SizeFDiagCursor):
            # we're dragging a corner, use correct diagonal cursor
            bdiag = (edge in (3, 12)) ^ (self._selectionRect.width() * self._selectionRect.height() >= 0)
            self.setCursor(Qt.SizeBDiagCursor if bdiag else Qt.SizeFDiagCursor)



def selectionEdge(point, rect):
    """Returns the edge where the point touches the rect."""
    if point not in rect.adjusted(-2, -2, 2, 2):
        return _OUTSIDE
    edge = 0
    if point.x() <= rect.left() + 4:
        edge |= _LEFT
    elif point.x() >= rect.right() - 4:
        edge |= _RIGHT
    if point.y() <= rect.top() + 4:
        edge |= _TOP
    elif point.y() >= rect.bottom() - 4:
        edge |= _BOTTOM
    return edge or _INSIDE


########NEW FILE########
__FILENAME__ = toc
# This file is part of the qpopplerview package.
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
Support for the Table of Contents in a PDF document.

To be implemented.

"""

try:
    import popplerqt4
except ImportError:
    from . import popplerqt4_dummy as popplerqt4


########NEW FILE########
__FILENAME__ = view
# This file is part of the qpopplerview package.
#
# Copyright (c) 2010 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
View widget to display PDF documents.
"""


from PyQt4.QtCore import QPoint, QSize, QTimer, Qt, pyqtSignal
from PyQt4.QtGui import QPalette, QScrollArea, QStyle, QHelpEvent

from math import sqrt
import copy
from . import surface
from .kineticscrollarea import KineticScrollArea
from . import cache

from . import (
    # viewModes:
    FixedScale,
    FitWidth,
    FitHeight,
    FitBoth,
)


# most used keyboard modifiers
_SCAM = (Qt.SHIFT | Qt.CTRL | Qt.ALT | Qt.META)


class View(KineticScrollArea):
    
    viewModeChanged = pyqtSignal(int)
    
    def __init__(self, parent=None):
        super(View, self).__init__(parent)
        
        self.setAlignment(Qt.AlignCenter)
        self.setBackgroundRole(QPalette.Dark)
        self.setMouseTracking(True)

        self._viewMode = FixedScale
        self._wheelZoomEnabled = True
        self._wheelZoomModifier = Qt.CTRL
        
        # delayed resize
        self._centerPos = False
        self._resizeTimer = QTimer(singleShot = True, timeout = self._resizeTimeout)
        
    def surface(self):
        """Returns our Surface, the widget drawing the page(s)."""
        sf = self.widget()
        if not sf:
            sf = surface.Surface(self)
            self.setSurface(sf)
        return sf
    
    def setSurface(self, sf):
        """Sets the given surface as our widget."""
        self.setWidget(sf)
        # For some reason mouse tracking *must* be enabled on the child as well...
        sf.setMouseTracking(True)
        self.kineticScrollingActive.connect(sf.updateKineticCursor)

    
    def viewMode(self):
        """Returns the current ViewMode."""
        return self._viewMode
        
    def setViewMode(self, mode):
        """Sets the current ViewMode."""
        if mode == self._viewMode:
            return
        self._viewMode = mode
        if mode:
            self.fit()
        self.viewModeChanged.emit(mode)
    
    def wheelZoomEnabled(self):
        """Returns whether wheel zoom is enabled."""
        return self._wheelZoomEnabled
        
    def setWheelZoomEnabled(self, enabled):
        """Sets whether wheel zoom is enabled.
        
        Wheel zoom is zooming using the mouse wheel and a keyboard modifier key
        (defaulting to Qt.CTRL).  Use setWheelZoomModifier() to set a key (or
        key combination).
        
        """
        self._wheelZoomEnabled = enabled
    
    def wheelZoomModifier(self):
        """Returns the modifier key to wheel-zoom with (defaults to Qt.CTRL)."""
        return self._wheelZoomModifier
        
    def setWheelZoomModifier(self, key):
        """Sets the modifier key to wheel-zoom with (defaults to Qt.CTRL).
        
        Can also be set to a ORed value, e.g. Qt.SHIFT|Qt.ALT.
        Only use Qt.ALT, Qt.CTRL, Qt.SHIFT and/or Qt.META.
        
        """
        self._wheelZoomModifier = key
        
    def load(self, document):
        """Convenience method to load all the pages from the given Poppler.Document."""
        self.surface().pageLayout().load(document)
        # dont do a fit() before the very first resize as the size is then bogus
        if self.viewMode():
            self.fit()
        self.surface().pageLayout().update()

    def clear(self):
        """Convenience method to clear the current layout."""
        self.surface().pageLayout().clear()
        self.surface().pageLayout().update()

    def scale(self):
        """Returns the scale of the pages in the View."""
        return self.surface().pageLayout().scale()
        
    def setScale(self, scale):
        """Sets the scale of all pages in the View."""
        self.surface().pageLayout().setScale(scale)
        self.surface().pageLayout().update()
        self.setViewMode(FixedScale)

    def visiblePages(self):
        """Yields the visible pages."""
        rect = self.viewport().rect()
        rect.translate(-self.surface().pos())
        rect.intersect(self.surface().rect())
        return self.surface().pageLayout().pagesAt(rect)

    def redraw(self):
        """Redraws, e.g. when you changed rendering hints or papercolor on the document."""
        pages = list(self.visiblePages())
        documents = set(page.document() for page in pages)
        for document in documents:
            cache.clear(document)
        for page in pages:
            page.repaint()

    def fit(self):
        """(Internal). Fits the layout according to the view mode.
        
        Prevents scrollbar/resize loops by precalculating which scrollbars will appear.
        
        """
        mode = self.viewMode()
        if mode == FixedScale:
            return
        
        maxsize = self.maximumViewportSize()
        
        # can vertical or horizontal scrollbars appear?
        vcan = self.verticalScrollBarPolicy() == Qt.ScrollBarAsNeeded
        hcan = self.horizontalScrollBarPolicy() == Qt.ScrollBarAsNeeded
        
        # width a scrollbar takes off the viewport size
        framewidth = 0
        if self.style().styleHint(QStyle.SH_ScrollView_FrameOnlyAroundContents, None, self):
            framewidth = self.style().pixelMetric(QStyle.PM_DefaultFrameWidth) * 2
        scrollbarextent = self.style().pixelMetric(QStyle.PM_ScrollBarExtent, None, self) + framewidth
        
        # first try to fit full size
        layout = self.surface().pageLayout()
        layout.fit(maxsize, mode)
        layout.reLayout()
        
        # minimal values
        minwidth = maxsize.width()
        minheight = maxsize.height()
        if vcan:
            minwidth -= scrollbarextent
        if hcan:
            minheight -= scrollbarextent
        
        # do width and/or height fit?
        fitw = layout.width() <= maxsize.width()
        fith = layout.height() <= maxsize.height()
        
        if not fitw and not fith:
            if vcan or hcan:
                layout.fit(QSize(minwidth, minheight), mode)
        elif mode & FitWidth and fitw and not fith and vcan:
            # a vertical scrollbar will appear
            w = minwidth
            layout.fit(QSize(w, maxsize.height()), mode)
            layout.reLayout()
            if layout.height() <= maxsize.height():
                # now the vert. scrollbar would disappear!
                # enlarge it as long as the vertical scrollbar would not be needed
                while True:
                    w += 1
                    layout.fit(QSize(w, maxsize.height()), mode)
                    layout.reLayout()
                    if layout.height() > maxsize.height():
                        layout.fit(QSize(w - 1, maxsize.height()), mode)
                        break
        elif mode & FitHeight and fith and not fitw and hcan:
            # a horizontal scrollbar will appear
            h = minheight
            layout.fit(QSize(maxsize.width(), h), mode)
            layout.reLayout()
            if layout.width() <= maxsize.width():
                # now the hor. scrollbar would disappear!
                # enlarge it as long as the horizontal scrollbar would not be needed
                while True:
                    h += 1
                    layout.fit(QSize(maxsize.width(), h), mode)
                    layout.reLayout()
                    if layout.width() > maxsize.width():
                        layout.fit(QSize(maxsize.width(), h - 1), mode)
                        break
        layout.update()
        
    def resizeEvent(self, ev):
        super(View, self).resizeEvent(ev)
        # Adjust the size of the document if desired
        if self.viewMode() and any(self.surface().pageLayout().pages()):
            if self._centerPos is False:
                self._centerPos = QPoint(0, 0)
            elif self._centerPos is None:
                # store the point currently in the center
                self._centerPos = self.viewport().rect().center() - self.surface().pos()
            if not self._resizeTimer.isActive():
                self._resizeTimeout()
            self._resizeTimer.start(150)
    
    def _resizeTimeout(self):
        if self._centerPos is None:
            return
        oldSize = self.surface().size()
        # resize the layout
        self.fit()
        # restore our position
        newSize = self.surface().size()
        newx = self._centerPos.x() * newSize.width() / oldSize.width()
        newy = self._centerPos.y() * newSize.height() / oldSize.height()
        # we explicitely want the non-kinetic centering function regardless of kinetic state.
        self.fastCenter(QPoint(newx, newy))
        self._centerPos = None

    def zoom(self, scale, pos=None):
        """Changes the display scale (1.0 is 100%).
        
        If pos is given, keeps that point at the same place if possible.
        Pos is a QPoint relative to ourselves.
        
        """
        scale = max(0.05, min(4.0, scale))
        if scale == self.scale():
            return
        
        if self.surface().pageLayout().count() == 0:
            self.setScale(scale)
            return
            
        if pos is None:
            pos = self.viewport().rect().center()
        
        surfacePos = pos - self.surface().pos()
        page = self.surface().pageLayout().pageAt(surfacePos)
        if page:
            pagePos = surfacePos - page.pos()
            x = pagePos.x() / float(page.width())
            y = pagePos.y() / float(page.height())
            self.setScale(scale)
            newPos = QPoint(round(x * page.width()), round(y * page.height())) + page.pos()
        else:
            x = surfacePos.x() / float(self.surface().width())
            y = surfacePos.y() / float(self.surface().height())
            self.setScale(scale)
            newPos = QPoint(round(x * self.surface().width()), round(y * self.surface().height()))
        surfacePos = pos - self.surface().pos()
        # use fastScrollBy as we do not want kinetic scrolling here regardless of its state.
        self.fastScrollBy(newPos - surfacePos)
            
    def zoomIn(self, pos=None, factor=1.1):
        self.zoom(self.scale() * factor, pos)
        
    def zoomOut(self, pos=None, factor=1.1):
        self.zoom(self.scale() / factor, pos)
        
    def wheelEvent(self, ev):
        if (self._wheelZoomEnabled and
            int(ev.modifiers()) & _SCAM == self._wheelZoomModifier):
            factor = 1.1 ** (ev.delta() / 120)
            if ev.delta():
                self.zoom(self.scale() * factor, ev.pos())
        else:
            super(View, self).wheelEvent(ev)
    
    def mousePressEvent(self, ev):
        """Mouse press event handler. Passes the event to the surface, and back to
        the base class if the surface did not do anything with it."""
        if not self.surface().handleMousePressEvent(ev):
            super(View, self).mousePressEvent(ev)

    def mouseReleaseEvent(self, ev):
        """Mouse release event handler. Passes the event to the surface, and back to
        the base class if the surface did not do anything with it."""
        if not self.surface().handleMouseReleaseEvent(ev):
            super(View, self).mouseReleaseEvent(ev)

    def mouseMoveEvent(self, ev):
        """Mouse move event handler. Passes the event to the surface, and back to
        the base class if the surface did not do anything with it."""
        if self.kineticIsIdle():
            if self.surface().handleMouseMoveEvent(ev):
                return
        super(View, self).mouseMoveEvent(ev)

    def moveEvent(self, ev):
        """Move event handler. Passes the event to the surface if we've not started any kinetic move,
        and back to the base class if the surface did not do anything with it."""
        if self.kineticIsIdle():
            if self.surface().handleMoveEvent(ev):
                return
        super(View, self).moveEvent(ev)

    def event(self, ev):
        if isinstance(ev, QHelpEvent):
            if self.surface().handleHelpEvent(ev):
                ev.accept()
                return True
        
        return super(View, self).event(ev)
    
    def currentPage(self):
        """Returns the Page currently mostly in the center, or None if there are no pages."""
        pos = self.viewport().rect().center() - self.surface().pos()
        layout = self.surface().pageLayout()
        if len(layout):
            d = layout.spacing() * 2
            for dx, dy in ((0, 0), (-d, 0), (0, -d), (d, 0), (0, d)):
                dist = QPoint(dx, dy)
                page = layout.pageAt(pos + dist)
                if page:
                    return page
    
    def currentPageNumber(self):
        """Returns the number (index in the layout) of the currentPage(), or -1 if there are no pages."""
        page = self.currentPage()
        if page:
            return self.surface().pageLayout().index(page)
        return -1

    def gotoPageNumber(self, num):
        """Aligns the page at the given index in the layout to the topleft of our View."""
        layout = self.surface().pageLayout()
        if num < len(layout) and num != self.currentPageNumber():
            margin = QPoint(layout.margin(), layout.margin())
            self.scrollBy(layout[num].pos() + self.surface().pos() - margin)
            
    def position(self):
        """Returns a three-tuple(num, x, y) describing the page currently in the center of the View.
        
        the number is the index of the Page in the Layout, and x and y are the coordinates in the
        range 0.0 -> 1.0 of the point that is at the center of the View.
        
        This way a position can be retained even if the scale or the orientation of the Layout changed.
        
        Returns None, None, None if the layout is empty.
        
        """
        page = self.currentPage()
        if page:
            layout = self.surface().pageLayout()
            pos = self.viewport().rect().center() - self.surface().pos()
            pagePos = pos - page.pos()
            x = pagePos.x() / float(page.width())
            y = pagePos.y() / float(page.height())
            return layout.index(page), x, y
        return None, None, None

    def setPosition(self, position, overrideKinetic=False):
        """Sets the position to a three-tuple as previously returned by position().
        
        Setting overrideKinetic to true allows for fast setup, instead of scrolling all the way to the visible point.
        """
        layout = self.surface().pageLayout()
        pageNum, x, y = position
        if pageNum is None or pageNum >= len(layout):
            return
        page = layout[pageNum]
        # center this point
        newPos = QPoint(round(x * page.width()), round(y * page.height())) + page.pos()
        if overrideKinetic:
            self.fastCenter(newPos)
        else:
            self.center(newPos)

########NEW FILE########
__FILENAME__ = articulations
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Quick Insert panel Articulations Tool.
"""

from __future__ import unicode_literals

import itertools

from PyQt4.QtGui import QCheckBox, QHBoxLayout, QToolButton

import app
import symbols
import cursortools
import lydocument
import ly.document
import documentinfo
import ly.lex.lilypond
import ly.rhythm
import icons
import documentactions

from . import tool
from . import buttongroup


# a dict mapping long articulation names to their short sign
shorthands = {
    'marcato': '^',
    'stopped': '+',
    'tenuto': '-',
    'staccatissimo': '|', # in Lily >= 2.17.25 this changed to '!', handled below
    'accent': '>',
    'staccato': '.',
    'portato': '_',
}


class Articulations(tool.Tool):
    """Articulations tool in the quick insert panel toolbox.
    
    """
    def __init__(self, panel):
        super(Articulations, self).__init__(panel)
        self.shorthands = QCheckBox(self)
        self.shorthands.setChecked(True)
        self.removemenu = QToolButton(self,
            autoRaise=True,
            popupMode=QToolButton.InstantPopup,
            icon=icons.get('edit-clear'))
        
        mainwindow = panel.parent().mainwindow()
        mainwindow.selectionStateChanged.connect(self.removemenu.setEnabled)
        self.removemenu.setEnabled(mainwindow.hasSelection())
        
        ac = documentactions.DocumentActions.instance(mainwindow).actionCollection
        self.removemenu.addAction(ac.tools_quick_remove_articulations)
        self.removemenu.addAction(ac.tools_quick_remove_ornaments)
        self.removemenu.addAction(ac.tools_quick_remove_instrument_scripts)
        
        layout = QHBoxLayout()
        layout.addWidget(self.shorthands)
        layout.addWidget(self.removemenu)
        layout.addStretch(1)
        
        self.layout().addLayout(layout)
        for cls in (
                ArticulationsGroup,
                OrnamentsGroup,
                SignsGroup,
                OtherGroup,
            ):
            self.layout().addWidget(cls(self))
        self.layout().addStretch(1)
        app.translateUI(self)
        
    def translateUI(self):
        self.shorthands.setText(_("Allow shorthands"))
        self.shorthands.setToolTip(_(
            "Use short notation for some articulations like staccato."))
        self.removemenu.setToolTip(_(
            "Remove articulations etc."))
    
    def icon(self):
        """Should return an icon for our tab."""
        return symbols.icon("articulation_prall")
    
    def title(self):
        """Should return a title for our tab."""
        return _("Articulations")
  
    def tooltip(self):
	"""Returns a tooltip"""
	return _("Different kinds of articulations and other signs.")


class Group(buttongroup.ButtonGroup):
    def actionData(self):
        for name, title in self.actionTexts():
            yield name, symbols.icon('articulation_'+name), None

    def actionTriggered(self, name):
        if self.tool().shorthands.isChecked() and name in shorthands:
            short = shorthands[name]
            # LilyPond >= 2.17.25 changed -| to -!
            if name == 'staccatissimo':
                version = documentinfo.docinfo(self.mainwindow().currentDocument()).version()
                if version >= (2, 17, 25):
                    short = '!'
            text = '_-^'[self.direction()+1] + short
        else:
            text = ('_', '', '^')[self.direction()+1] + '\\' + name
        cursor = self.mainwindow().textCursor()
        selection = cursor.hasSelection()
        cursors = articulation_positions(cursor)
        if cursors:
            with cursortools.compress_undo(cursor):
                for c in cursors:
                    c.insertText(text)
            if not selection:
                self.mainwindow().currentView().setTextCursor(c)
        elif not selection:
            cursor.insertText(text)


class ArticulationsGroup(Group):
    def translateUI(self):
        self.setTitle(_("Articulations"))
        
    def actionTexts(self):
        yield 'accent', _("Accent")
        yield 'marcato', _("Marcato")
        yield 'staccatissimo', _("Staccatissimo")
        yield 'staccato', _("Staccato")
        yield 'portato', _("Portato")
        yield 'tenuto', _("Tenuto")
        yield 'espressivo', _("Espressivo")


class OrnamentsGroup(Group):
    def translateUI(self):
        self.setTitle(_("Ornaments"))
        
    def actionTexts(self):
        yield 'trill', _("Trill")
        yield 'prall', _("Prall")
        yield 'mordent', _("Mordent")
        yield 'turn', _("Turn")
        yield 'prallprall', _("Prall prall")
        yield 'prallmordent', _("Prall mordent")
        yield 'upprall', _("Up prall")
        yield 'downprall', _("Down prall")
        yield 'upmordent', _("Up mordent")
        yield 'downmordent', _("Down mordent")
        yield 'prallup', _("Prall up")
        yield 'pralldown', _("Prall down")
        yield 'lineprall', _("Line prall")
        yield 'reverseturn', _("Reverse turn")


class SignsGroup(Group):
    def translateUI(self):
        self.setTitle(_("Signs"))
        
    def actionTexts(self):
        yield 'fermata', _("Fermata")
        yield 'shortfermata', _("Short fermata")
        yield 'longfermata', _("Long fermata")
        yield 'verylongfermata', _("Very long fermata")
        yield 'segno', _("Segno")
        yield 'coda', _("Coda")
        yield 'varcoda', _("Varcoda")
        yield 'signumcongruentiae', _("Signumcongruentiae")


class OtherGroup(Group):
    def translateUI(self):
        self.setTitle(_("Other"))
    
    def actionTexts(self):
        yield 'upbow', _("Upbow")
        yield 'downbow', _("Downbow")
        yield 'snappizzicato', _("Snappizzicato")
        yield 'open', _("Open (e.g. brass)")
        yield 'stopped', _("Stopped (e.g. brass)")
        yield 'flageolet', _("Flageolet")
        yield 'thumb', _("Thumb")
        yield 'lheel', _("Left heel")
        yield 'rheel', _("Right heel")
        yield 'ltoe', _("Left toe")
        yield 'rtoe', _("Right toe")
        yield 'halfopen', _("Half open (e.g. hi-hat)")


def articulation_positions(cursor):
    """Returns a list of positions where an articulation can be added.
    
    Every position is given as a QTextCursor instance.
    If the cursor has a selection, all positions in the selection are returned.
    
    """
    c = lydocument.cursor(cursor)
    if not cursor.hasSelection():
        # just select til the end of the current line
        c.select_end_of_block()
        rests = True
        partial = ly.document.OUTSIDE
    else:
        rests = False
        partial = ly.document.INSIDE
    source = lydocument.Source(c, True, partial, True)
    
    positions = []
    for p in ly.rhythm.music_tokens(source):
        if not rests and isinstance(p[0], ly.lex.lilypond.Rest):
            continue
        positions.append(source.cursor(p[-1], start=len(p[-1])))
        if not cursor.hasSelection():
            break # leave if first found, that's enough
    return positions



########NEW FILE########
__FILENAME__ = barlines
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Quick Insert panel barlines and breathing sings Tool.
"""

from __future__ import unicode_literals

import app
import symbols
import documentinfo

from . import tool
from . import buttongroup


class BarLines(tool.Tool):
    """Barlines tool in the quick insert panel toolbox.
    
    """
    def __init__(self, panel):
        super(BarLines, self).__init__(panel)
        self.layout().addWidget(BarlinesGroup(self))
        self.layout().addWidget(BreatheGroup(self))
        self.layout().addStretch(1)

    def icon(self):
        """Should return an icon for our tab."""
        return symbols.icon("bar_single")
    
    def title(self):
        """Should return a title for our tab."""
        return _("Bar Lines")
  
    def tooltip(self):
        """Returns a tooltip"""
        return _("Bar lines, breathing signs, etcetera.")


class BarlinesGroup(buttongroup.ButtonGroup):
    def translateUI(self):
        self.setTitle(_("Bar Lines"))
        
    def barlines(self):
        yield "bar_double", "||", "||", _("Double bar line")
        yield "bar_end", "|.", "|.", _("Ending bar line")
        yield "bar_dotted", ":", ";", _("Dotted bar line")
        yield "bar_dashed", "dashed", "!", _("Dashed bar line")
        yield "bar_invisible", "", "", _("Invisible bar line")
        yield "bar_repeat_start", "|:", ".|:", _("Repeat start")
        yield "bar_repeat_double", ":|:", ":..:", _("Repeat both")
        yield "bar_repeat_end", ":|", ":|.", _("Repeat end")
        yield "bar_cswc", ":|.:", ":|.:", _("Repeat both (old)")
        yield "bar_cswsc", ":|.|:", ":|.|:", _("Repeat both (classic)")
        yield "bar_tick", "'", "'", _("Tick bar line")
        yield "bar_single", "|", "|", _("Single bar line")
        yield "bar_sws", "|.|", "|.|", _("Small-Wide-Small bar line")
        yield "bar_ws", ".|", ".|", _("Wide-Small bar line")
        yield "bar_ww", ".|.", "..", _("Double wide bar line")
        yield "bar_segno", "S", "S", _("Segno bar line")
        yield "bar_w", ".", ".", _("Single wide bar line")
        # 2.18+
        yield "bar_repeat_angled_start", None, "[|:", _("Angled repeat start")
        yield "bar_repeat_angled_end", None, ":|]", _("Angled repeat end")
        yield "bar_repeat_angled_double", None, ":|][|:", _("Angled repeat both")
        yield "bar_kievan", None, "k", _("Kievan bar line")
    
    def actionData(self):
        self._barlines = {}
        for name, ly_text, ly_text_2_18, title in self.barlines():
            yield name, symbols.icon(name), None
            self._barlines[name] = ly_text, ly_text_2_18
        
    def actionTexts(self):
        for name, ly_text, ly_text_2_18, title in self.barlines():
            yield name, title
    
    def actionTriggered(self, name):
        version = documentinfo.docinfo(self.mainwindow().currentDocument()).version()
        glyphs = self._barlines[name]
        if version and version < (2, 18):
            glyph = glyphs[0] or glyphs[1]
        else:
            glyph = glyphs[1]
        text = '\\bar "{0}"'.format(glyph)
        self.insertText(text)


class BreatheGroup(buttongroup.ButtonGroup):
    def translateUI(self):
        self.setTitle(_("Breathing Signs"))

    def actionData(self):
        for name, title in self.actionTexts():
            yield name, symbols.icon(name), None
            
    def actionTexts(self):
        yield 'breathe_rcomma', _("Default Breathing Sign")
        yield 'breathe_rvarcomma', _("Straight Breathing Sign")
        yield 'breathe_caesura_curved', _("Curved Caesura")
        yield 'breathe_caesura_straight', _("Straight Caesura")

    def actionTriggered(self, name):
        if name == 'breathe_rcomma':
            self.insertText('\\breathe')
        else:
            glyph = name[8:].replace('_', '.')
            text = ("\\once \\override BreathingSign #'text = "
                    '#(make-musicglyph-markup "scripts.{0}")\n'
                    "\\breathe").format(glyph)
            self.insertText(text, blankline=True)




########NEW FILE########
__FILENAME__ = buttongroup
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A QGroupBox in the Quick Insert Panel that auto-layouts its buttons.
"""

from __future__ import unicode_literals

import weakref

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import actioncollection
import actioncollectionmanager
import app
import cursortools
import widgets.shortcuteditdialog


class ButtonGroup(QGroupBox):
    """Inherit this class to create a group of buttons.
    
    You should implement:
    - translateUI() to set the title
    - actionData() to yield name, icon, function for every button
    - actionTexts() to yield name, text for every button
    - actionTriggered() (if you don't supply a function) to implement the
      handler for the action.
    
    """
      
    def __init__(self, tool):
        super(ButtonGroup, self).__init__(tool)
        self._tool = weakref.ref(tool)
        grid = QGridLayout()
        grid.setSpacing(0)
        grid.setContentsMargins(0, 0, 0, 0)
        self.setLayout(grid)
        self.createActions()
        self.setActionTexts()
        self.createButtons()
        app.translateUI(self)
        app.languageChanged.connect(self.setActionTexts)
        
    def translateUI(self):
        """Should set our title."""
        pass
    
    def tool(self):
        return self._tool()
    
    def mainwindow(self):
        return self.tool().panel().parent().mainwindow()
    
    def actionDict(self):
        """Returns the Quick Insert action dictionary."""
        return self.tool().panel().actionDict
        
    def direction(self):
        """ The value of the generic direction widget.
        
        -1 == Down
         0 == Neutral
         1 == Up
         
        """
        return 1 - self.tool().panel().direction.currentIndex()
        
    def createActions(self):
        actionDict = self.actionDict()
        self._names = []
        for name, icon, function in self.actionData():
            a = actionDict[name] = QAction(self, icon=icon)
            a.triggered.connect(self.focusView)
            if function is None:
                function = (lambda name: lambda: self.actionTriggered(name))(name)
            a.triggered.connect(function)
            self._names.append(name)
    
    def setActionTexts(self):
        actionDict = self.actionDict()
        for name, text in self.actionTexts():
            actionDict[name].setText(text)
            actionDict[name].setToolTip(text)
    
    def createButtons(self):
        actionDict = self.actionDict()
        layout = self.layout()
        row = layout.rowCount()
        columns = 5
        for num, name in enumerate(self._names, row*columns):
            b = Button(self, name, actionDict[name])
            layout.addWidget(b, *divmod(num, columns))
            
    def focusView(self):
        """Always called when an action is triggered; focuses the main view."""
        self.mainwindow().currentView().setFocus()
        
    def actionData(self):
        """Should yield name, icon, function (may be None) for every action."""
        pass
    
    def actionTexts(self):
        """Should yield name, text for very action."""
        pass
    
    def actionTriggered(self, name):
        """Called by default when a button is activated."""
        print (("Action triggered: {0}").format(name)) # DEBUG
    
    def insertText(self, text, indent=True, blankline=False):
        """Insert text in the current document and focuses the document again.
        
        Besides the text, the following keyword arguments may be used:
        
        indent (default: True): The text will be indented if there are one or
            more newlines in it.
        blankline (default: False): A newline will be prepended to text if the
            cursor is currently not on a blank line.
        
        """
        cursor = self.mainwindow().textCursor()
        if blankline and not cursor.hasSelection() and not cursortools.isblank_before(cursor):
            text = '\n' + text
        pos = cursor.selectionStart()
        cursor.insertText(text)
        if indent and '\n' in text:
            cursor.setPosition(pos, cursor.KeepAnchor)
            import indent
            with cursortools.compress_undo(cursor, True):
                indent.re_indent(cursor)


class Button(QToolButton):
    def __init__(self, group, name, action):
        super(Button, self).__init__(group)
        self.setObjectName(name)
        self.setDefaultAction(action)
        self.setAutoRaise(True)
        self.setIconSize(QSize(22, 22))
    
    def actionCollection(self):
        return self.parent().tool().panel().parent().actionCollection
    
    def key(self):
        """Returns a textual representation of the configured shortcut if it exists."""
        shortcuts = self.actionCollection().shortcuts(self.objectName())
        if shortcuts:
            key = shortcuts[0].toString(QKeySequence.NativeText)
            if len(shortcuts) > 1:
                key += "..."
            return key
    
    def event(self, ev):
        if ev.type() == QEvent.ToolTip:
            text = self.defaultAction().text()
            key = self.key()
            if key:
                text = _("{name} ({key})").format(name=text, key=key)
            QToolTip.showText(ev.globalPos(), text)
            return True
        return super(Button, self).event(ev)
    
    def contextMenuEvent(self, ev):
        m = QMenu(self)
        a = m.addAction(_("Configure Keyboard Shortcut ({key})").format(key = self.key() or _("None")))
        a.triggered.connect(self.editShortcut)
        m.exec_(ev.globalPos())
        m.deleteLater()

    def editShortcut(self):
        """Edit our shortcut."""
        from widgets import shortcuteditdialog
        mainwindow = self.parent().mainwindow()
        action = QAction(self.defaultAction().icon(), self.defaultAction().text(), None)
        action.setShortcuts(self.actionCollection().shortcuts(self.objectName()) or [])
        default = self.actionCollection().defaults().get(self.objectName())
        mgr = actioncollectionmanager.manager(mainwindow)
        skip = (self.actionCollection(), self.objectName())
        cb = mgr.findShortcutConflict
        
        dlg = shortcuteditdialog.ShortcutEditDialog(self, cb, skip)
        if dlg.editAction(action, default):
            mgr.removeShortcuts(action.shortcuts())
            self.actionCollection().setShortcuts(self.objectName(), action.shortcuts())
        

########NEW FILE########
__FILENAME__ = dynamics
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Quick Insert panel dynamics Tool.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QHBoxLayout, QToolButton

import app
import icons
import symbols
import cursortools
import tokeniter
import lydocument
import ly.document
import ly.lex.lilypond
import ly.rhythm
import documentactions

from . import tool
from . import buttongroup


class Dynamics(tool.Tool):
    """Dynamics tool in the quick insert panel toolbox."""
    def __init__(self, panel):
        super(Dynamics, self).__init__(panel)
        self.removemenu = QToolButton(self,
            autoRaise=True,
            popupMode=QToolButton.InstantPopup,
            icon=icons.get('edit-clear'))
        
        mainwindow = panel.parent().mainwindow()
        mainwindow.selectionStateChanged.connect(self.removemenu.setEnabled)
        self.removemenu.setEnabled(mainwindow.hasSelection())
        
        ac = documentactions.DocumentActions.instance(mainwindow).actionCollection
        self.removemenu.addAction(ac.tools_quick_remove_dynamics)
        
        layout = QHBoxLayout()
        layout.addWidget(self.removemenu)
        layout.addStretch(1)
        
        self.layout().addLayout(layout)
        self.layout().addWidget(DynamicGroup(self))
        self.layout().addWidget(SpannerGroup(self))
        self.layout().addStretch(1)

    def icon(self):
        """Should return an icon for our tab."""
        return symbols.icon("dynamic_f")
    
    def title(self):
        """Should return a title for our tab."""
        return _("Dynamics")
  
    def tooltip(self):
        """Returns a tooltip"""
        return _("Dynamic symbols.")


class Group(buttongroup.ButtonGroup):
    """Base class for dynamic button groups with insert implementation."""
    def actionTriggered(self, name):
        name = name[8:]
        direction = ['_', '', '^'][self.direction() + 1]
        isSpanner = name not in dynamic_marks
        if isSpanner:
            dynamic = dynamic_spanners[name]
        else:
            dynamic = '\\' + name
        cursor = self.mainwindow().textCursor()
        if not cursor.hasSelection():
            # dynamic right before the cursor?
            left = tokeniter.partition(cursor).left
            if not left or not isinstance(left[-1], ly.lex.lilypond.Dynamic):
                # no, find the first pitch
                c = lydocument.cursor(cursor)
                c.end = None
                source = lydocument.Source(c, True, ly.document.OUTSIDE, True)
                for p in ly.rhythm.music_tokens(source):
                    cursor = source.cursor(p[-1], start=len(p[-1]))
                    break
            cursor.insertText(direction + dynamic)
            self.mainwindow().currentView().setTextCursor(cursor)
        else:
            c = lydocument.cursor(cursor)
            source = lydocument.Source(c, True, tokens_with_position=True)
            cursors = [source.cursor(p[-1], start=len(p[-1]))
                for p in ly.rhythm.music_tokens(source)]
            if not cursors:
                return
            c1, c2 = cursors[0], cursors[-1]
            # are there dynamics at the cursor? then skip them
            d1 = dynamics(c1)
            if d1:
                c1 = tokeniter.cursor(c1.block(), d1[-1], start=len(d1[-1]))
            with cursortools.compress_undo(cursor):
                if len(cursors) > 1:
                    # dynamics after the end cursor?
                    d2 = dynamics(c2)
                    if isSpanner and not d2:
                        # don't terminate the spanner if there's a dynamic there
                        c2.insertText('\\!')
                    elif set(d1).intersection(dynamic_spanners.values()):
                        # write the dynamic at the end if there's a spanner at start
                        # remove ending \! if there
                        terminator = tokeniter.find("\\!", d2)
                        if terminator:
                            c2 = tokeniter.cursor(c2.block(), terminator)
                        if direction in d1:
                            c2.insertText(dynamic)
                        else:
                            c2.insertText(direction + dynamic)
                        return
                c1.insertText(direction + dynamic)


class DynamicGroup(Group):
    def translateUI(self):
        # L10N: dynamic signs
        self.setTitle(_("Signs"))
    
    def actionData(self):
        """Should yield name, icon, function (may be None) for every action."""
        for m in dynamic_marks:
            name = 'dynamic_' + m
            yield name, symbols.icon(name), None
    
    def actionTexts(self):
        """Should yield name, text for very action."""
        for m in dynamic_marks:
            name = 'dynamic_' + m
            bold = "<b><i>{0}</i></b>".format
            yield name, _("Dynamic sign {name}").format(name=bold(m))


class SpannerGroup(Group):
    def translateUI(self):
        self.setTitle(_("Spanners"))
    
    def actionData(self):
        """Should yield name, icon, function (may be None) for every action."""
        for name, title in self.actionTexts():
            yield name, symbols.icon(name), None
    
    def actionTexts(self):
        """Should yield name, text for very action."""
        yield 'dynamic_hairpin_cresc', _("Hairpin crescendo")
        yield 'dynamic_cresc', _("Crescendo")
        yield 'dynamic_hairpin_dim', _("Hairpin diminuendo")
        yield 'dynamic_dim', _("Diminuendo")
        yield 'dynamic_decresc', _("Decrescendo")
        

def dynamics(cursor):
    """Returns a tuple of dynamic tokens (including _ or ^) at the cursor."""
    right = tokeniter.partition(cursor).right
    i = 0
    for j, t in enumerate(right, 1):
        if isinstance(t, ly.lex.lilypond.Dynamic):
            i = j
        elif not isinstance(t, (ly.lex.Space, ly.lex.lilypond.Direction)):
            break
    return right[:i]


dynamic_marks = (
    'f', 'ff', 'fff', 'ffff', 'fffff',
    'p', 'pp', 'ppp', 'pppp', 'ppppp',
    'mf', 'mp', 'fp', 'sfz', 'rfz',
    'sf', 'sff', 'sp', 'spp',
)

dynamic_spanners = {
    'hairpin_cresc': '\\<',
    'hairpin_dim':   '\\>',
    'cresc':         '\\cresc',
    'decresc':       '\\decresc',
    'dim':           '\\dim',
}



########NEW FILE########
__FILENAME__ = spanners
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Quick Insert panel spanners Tool.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QHBoxLayout, QToolButton

import app
import icons
import cursortools
import tokeniter
import lydocument
import documentactions
import symbols
import ly.document
import ly.rhythm

from . import tool
from . import buttongroup


class Spanners(tool.Tool):
    """Dynamics tool in the quick insert panel toolbox."""
    def __init__(self, panel):
        super(Spanners, self).__init__(panel)
        self.removemenu = QToolButton(self,
            autoRaise=True,
            popupMode=QToolButton.InstantPopup,
            icon=icons.get('edit-clear'))
        
        mainwindow = panel.parent().mainwindow()
        mainwindow.selectionStateChanged.connect(self.removemenu.setEnabled)
        self.removemenu.setEnabled(mainwindow.hasSelection())
        
        ac = documentactions.DocumentActions.instance(mainwindow).actionCollection
        self.removemenu.addAction(ac.tools_quick_remove_slurs)
        
        layout = QHBoxLayout()
        layout.addWidget(self.removemenu)
        layout.addStretch(1)
        
        self.layout().addLayout(layout)
        self.layout().addWidget(ArpeggioGroup(self))
        self.layout().addWidget(GlissandoGroup(self))
        self.layout().addWidget(SpannerGroup(self))
        self.layout().addWidget(GraceGroup(self))
        self.layout().addStretch(1)

    def icon(self):
        """Should return an icon for our tab."""
        return symbols.icon("spanner_phrasingslur")
    
    def title(self):
        """Should return a title for our tab."""
        return _("Spanners")
  
    def tooltip(self):
        """Returns a tooltip"""
        return _("Slurs, spanners, etcetera.")


class ArpeggioGroup(buttongroup.ButtonGroup):
    def translateUI(self):
        self.setTitle(_("Arpeggios"))
    
    def actionData(self):
        """Should yield name, icon, function (may be None) for every action."""
        for name, title in self.actionTexts():
            yield name, symbols.icon(name), None
    
    def actionTexts(self):
        """Should yield name, text for very action."""
        yield 'arpeggio_normal', _("Arpeggio")
        yield 'arpeggio_arrow_up', _("Arpeggio with Up Arrow")
        yield 'arpeggio_arrow_down', _("Arpeggio with Down Arrow")
        yield 'arpeggio_bracket', _("Bracket Arpeggio")
        yield 'arpeggio_parenthesis', _("Parenthesis Arpeggio")
        
    def actionTriggered(self, name):
        # convert arpeggio_normal to arpeggioNormal, etc.
        name = _arpeggioTypes[name]
        cursor = self.mainwindow().textCursor()
        # which arpeggio type is last used?
        lastused = '\\arpeggioNormal'
        types = set(_arpeggioTypes.values())
        block = cursor.block()
        while block.isValid():
            s = types.intersection(tokeniter.tokens(block))
            if s:
                lastused = s.pop()
                break
            block = block.previous()
        # where to insert
        c = lydocument.cursor(cursor)
        c.select_end_of_block()
        source = lydocument.Source(c, True, ly.document.OUTSIDE, True)
        with cursortools.compress_undo(cursor):
            for p in ly.rhythm.music_tokens(source):
                c = source.cursor(p[-1], start=len(p[-1]))
                c.insertText('\\arpeggio')
                if name != lastused:
                    cursortools.strip_indent(c)
                    indent = c.block().text()[:c.position()-c.block().position()]
                    c.insertText(name + '\n' + indent)
                # just pick the first place
                return
        

class GlissandoGroup(buttongroup.ButtonGroup):
    def translateUI(self):
        self.setTitle(_("Glissandos"))
    
    def actionData(self):
        """Should yield name, icon, function (may be None) for every action."""
        for name, title in self.actionTexts():
            yield name, symbols.icon(name), None
    
    def actionTexts(self):
        """Should yield name, text for very action."""
        yield 'glissando_normal', _("Glissando")
        yield 'glissando_dashed', _("Dashed Glissando")
        yield 'glissando_dotted', _("Dotted Glissando")
        yield 'glissando_zigzag', _("Zigzag Glissando")
        yield 'glissando_trill', _("Trill Glissando")

    def actionTriggered(self, name):
        cursor = self.mainwindow().textCursor()
        style = _glissandoStyles[name]
        c = lydocument.cursor(cursor)
        c.select_end_of_block()
        source = lydocument.Source(c, True, ly.document.OUTSIDE, True)
        for p in ly.rhythm.music_tokens(source):
            c = source.cursor(p[-1], start=len(p[-1]))
            if style:
                text = "-\\tweak #'style #'{0} \\glissando".format(style)
            else:
                text = '\\glissando'
            c.insertText(text)
            return
     
class SpannerGroup(buttongroup.ButtonGroup):
    def translateUI(self):
        self.setTitle(_("Spanners"))
    
    def actionData(self):
        for name, title in self.actionTexts():
            yield name, symbols.icon(name), None

    def actionTexts(self):
        yield 'spanner_slur', _("Slur")
        yield 'spanner_phrasingslur', _("Phrasing Slur")
        yield 'spanner_beam16', _("Beam")
        yield 'spanner_trill', _("Trill")
        yield 'spanner_melisma', _("Melisma")

    def actionTriggered(self, name):
        d = ['_', '', '^'][self.direction()+1]
        if name == "spanner_slur":
            spanner = d + '(', ')'
        elif name == "spanner_phrasingslur":
            spanner = d + '\\(', '\\)'
        elif name == "spanner_beam16":
            spanner = d + '[', ']'
        elif name == "spanner_trill":
            spanner = '\\startTrillSpan', '\\stopTrillSpan'
        elif name == "spanner_melisma":
            spanner = '\\melisma', '\\melismaEnd'

        cursor = self.mainwindow().textCursor()
        with cursortools.compress_undo(cursor):
            for s, c in zip(spanner, spanner_positions(cursor)):
                c.insertText(s)

class GraceGroup(buttongroup.ButtonGroup):
    def translateUI(self):
        self.setTitle(_("Grace Notes"))
        
    def actionData(self):
        for name, title in self.actionTexts():
            yield name, symbols.icon(name), None
            
    def actionTexts(self):
        yield 'grace_grace', _("Grace Notes")
        yield 'grace_beam', _("Grace Notes w. beaming")
        yield 'grace_accia', _("Acciaccatura")
        yield 'grace_appog', _("Appoggiatura")
        yield 'grace_slash', _("Slashed no slur")
        yield 'grace_after', _("After grace")
        
    def actionTriggered(self, name):
        d = ['_', '', '^'][self.direction()+1]
        single = ''
        if name == "grace_grace":
            inner = ''
            outer = '\\grace { ', ' }'
            single = '\\grace '
        elif name == "grace_beam":
            inner = d + '[', ']'
            outer = '\\grace { ', ' }'
        elif name == "grace_accia":
            inner = ''
            outer = '\\acciaccatura { ', ' }'
            single = '\\acciaccatura '
        elif name == "grace_appog":
            inner = ''
            outer = '\\appoggiatura { ', ' }'
            single = '\\appoggiatura '
        elif name == "grace_slash":
            inner = d + '[', ']'
            outer = '\\slashedGrace { ', ' }'
        elif name == "grace_after":
            inner = d + '{ '
            outer = '\\afterGrace ', ' }'               

        cursor = self.mainwindow().textCursor()
        with cursortools.compress_undo(cursor):
            if inner:     
                for i, ci in zip(inner, spanner_positions(cursor)):
                    ci.insertText(i)
            if cursor.hasSelection():
                ins = self.mainwindow().textCursor()      
                ins.setPosition(cursor.selectionStart())
                ins.insertText(outer[0])
                ins.setPosition(cursor.selectionEnd())
                ins.insertText(outer[1])
            else:
                if single:
                    cursor.insertText(single)
                else:
                    c = lydocument.cursor(cursor)
                    c.end = None
                    source = lydocument.Source(c, True, ly.document.OUTSIDE, True)
                    music_list = list(ly.rhythm.music_tokens(source))
                    try:
                        m = music_list[2][0]
                        after = source.cursor(m, 1)
                    except IndexError:                      
                        after = self.mainwindow().textCursor()
                        after.movePosition(cursor.EndOfLine)        
                    after.insertText(outer[1])
                    cursor.insertText(outer[0])


def spanner_positions(cursor):
    """Return a list with 0 to 2 QTextCursor instances.
    
    At the first cursor a starting spanner item can be inserted, at the
    second an ending item.
    
    """   
    c = lydocument.cursor(cursor)
    if cursor.hasSelection():
        partial = ly.document.INSIDE
    else:
        # just select til the end of the current line
        c.select_end_of_block()
        partial = ly.document.OUTSIDE
    source = lydocument.Source(c, True, partial, True)
      
    positions = [source.cursor(p[-1], start=len(p[-1]))
        for p in ly.rhythm.music_tokens(source)]
    
    if cursor.hasSelection():
        del positions[1:-1]
    else:
        del positions[2:]
    return positions
        
    


_arpeggioTypes = {
    'arpeggio_normal': '\\arpeggioNormal',
    'arpeggio_arrow_up': '\\arpeggioArrowUp',
    'arpeggio_arrow_down': '\\arpeggioArrowDown',
    'arpeggio_bracket': '\\arpeggioBracket',
    'arpeggio_parenthesis': '\\arpeggioParenthesis',
}

_glissandoStyles = {
    'glissando_normal': '',
    'glissando_dashed': 'dashed-line',
    'glissando_dotted': 'dotted-line',
    'glissando_zigzag': 'zigzag',
    'glissando_trill':  'trill',
}


########NEW FILE########
__FILENAME__ = tool
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Quick Insert panel widget.
"""

from __future__ import unicode_literals

import weakref

from PyQt4.QtCore import *
from PyQt4.QtGui import *


class Tool(QWidget):
    """Base class for a tool in the quick insert panel toolbox.
    
    """
    def __init__(self, panel):
        super(Tool, self).__init__(panel)
        self._panel = weakref.ref(panel)
        layout = QVBoxLayout()
        self.setLayout(layout)
        layout.setContentsMargins(0, 0, 0, 0)
    
    def panel(self):
        """Returns the panel."""
        return self._panel()
    
    def icon(self):
        """Should return an icon for our tab."""
        pass
    
    def title(self):
        """Should return a title for our tab."""
        pass

    def tooltip(self):
        """Should return a tooltip for our tab."""
        pass


########NEW FILE########
__FILENAME__ = widget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Quick Insert panel widget.
"""

from __future__ import unicode_literals

import weakref

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import userguide.util
import icons
import symbols
import widgets.toolboxwheeler

from . import articulations
from . import barlines
from . import dynamics
from . import spanners


class QuickInsert(QWidget):
    def __init__(self, dockwidget):
        super(QuickInsert, self).__init__(dockwidget)
        self._dockwidget = weakref.ref(dockwidget)
        # filled in by ButtonGroup subclasses
        self.actionDict = {}
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        layout.setContentsMargins(0, 0, 0, 0)
        
        self.helpButton = QToolButton(
            icon = icons.get("help-contents"),
            autoRaise = True,
            clicked = lambda: userguide.show("quickinsert"))
        self.directionLabel = QLabel()
        self.direction = QComboBox()
        self.direction.addItems(['', '', ''])
        self.direction.setItemIcon(0, icons.get("go-up"))
        self.direction.setItemIcon(2, icons.get("go-down"))
        self.direction.setCurrentIndex(1)
        hor = QHBoxLayout()
        hor.setContentsMargins(0, 0, 0, 0)
        hor.addWidget(self.helpButton)
        hor.addWidget(self.directionLabel)
        hor.addWidget(self.direction)
        layout.addLayout(hor)
        
        self.toolbox = QToolBox(self)
        widgets.toolboxwheeler.ToolBoxWheeler(self.toolbox)
        layout.addWidget(self.toolbox)
        
        for cls in (
                articulations.Articulations,
                dynamics.Dynamics,
                spanners.Spanners,
                barlines.BarLines,
            ):
            widget = cls(self)
            self.toolbox.addItem(widget, widget.icon(), '')
        
        app.translateUI(self)
        userguide.openWhatsThis(self)
        
        # restore remembered current page
        name = QSettings().value("quickinsert/current_tool", "", type(""))
        if name:
            for i in range(self.toolbox.count()):
                if name == self.toolbox.widget(i).__class__.__name__.lower():
                    self.toolbox.setCurrentIndex(i)
                    break
        self.toolbox.currentChanged.connect(self.slotCurrentChanged)
        
    def slotCurrentChanged(self, index):
        name = self.toolbox.widget(index).__class__.__name__.lower()
        QSettings().setValue("quickinsert/current_tool", name)
    
    def translateUI(self):
        self.setWhatsThis(_(
            "<p>With the Quick Insert Panel you can add various music "
            "elements to the current note or selected music.</p>\n"
            "<p>See {link} for more information.</p>").format(link=
                userguide.util.format_link("quickinsert")))
        self.helpButton.setToolTip(_("Help"))
        self.directionLabel.setText(_("Direction:"))
        for item, text in enumerate((_("Up"), _("Neutral"), _("Down"))):
            self.direction.setItemText(item, text)
        for i in range(self.toolbox.count()):
            self.toolbox.setItemText(i, self.toolbox.widget(i).title())
            self.toolbox.setItemToolTip(i, self.toolbox.widget(i).tooltip())
            
    def actionForName(self, name):
        """This is called by the ShortcutCollection of our dockwidget, e.g. if the user presses a key."""
        try:
            return self.actionDict[name]
        except KeyError:
            pass

    def dockwidget(self):
        return self._dockwidget()



########NEW FILE########
__FILENAME__ = quickremove
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Remove certain types of LilyPond input from selected regions.

The functions are called by actions defined in the documentactions.py module.

"""

from __future__ import unicode_literals

import functools

import lydocument
import ly.document
import ly.words
import ly.lex.lilypond


def remove(func):
    """Decorator turning a function yielding ranges into removing the ranges.
    
    Note that you should call the function with a QTextCursor as the first 
    argument. The returned decorator converts the QTextCursor to a 
    ly.document.Cursor, calls the function and removes the ranges returned 
    by the function.
    
    """
    @functools.wraps(func)
    def decorator(cursor, *args):
        c = lydocument.cursor(cursor)
        remove = func(c, *args)
        with c.document as d:
            for start, end in remove:
                del d[start:end]
    return decorator


def is_articulation(token):
    """Return True if token is an articulation."""
    return (isinstance(token, ly.lex.lilypond.Articulation)
            and token[1:] in ly.words.articulations)


def is_ornament(token):
    """Return True if token is an ornament."""
    return (isinstance(token, ly.lex.lilypond.Articulation)
            and token[1:] in ly.words.ornaments)


def is_instrument_script(token):
    """Return True if token is an instrument script."""
    return (isinstance(token, ly.lex.lilypond.Articulation)
            and token[1:] in ly.words.instrument_scripts)


def find_positions(cursor, predicate, predicate_dir=None):
    """Yields positions (start, end) for tokens predicate returns True for.
    
    The tokens (gotten from the cursor's selection) may be preceded by a
    ly.lex.lilypond.Direction token.
    If predicate_dir is specified, it is used for the items following a
    Direction tokens, otherwise predicate is also used for that case.
    
    """
    if predicate_dir is None:
        predicate_dir = predicate
    source = ly.document.Source(cursor, None, ly.document.PARTIAL, True)
    for t in source:
        if isinstance(t, ly.lex.lilypond.Direction):
            start = t.pos
            for t in source.tokens:
                if isinstance(t, ly.lex.Space):
                    continue
                elif predicate_dir(t):
                    yield start, t.end
                break
        elif predicate(t):
            yield t.pos, t.end


@remove
def articulations(cursor):
    """Remove articulations from the cursor's selection."""
    return find_positions(cursor, is_articulation,
        lambda t: isinstance(t, ly.lex.lilypond.ScriptAbbreviation) or is_articulation(t))


@remove
def ornaments(cursor):
    """Remove ornaments from the cursor's selection."""
    return find_positions(cursor, is_ornament)


@remove
def instrument_scripts(cursor):
    """Remove instrument_scripts from the cursor's selection."""
    return find_positions(cursor, is_instrument_script)


@remove
def slurs(cursor):
    """Remove slurs from the cursor's selection."""
    return find_positions(cursor, lambda t: isinstance(t, ly.lex.lilypond.Slur))


@remove
def dynamics(cursor):
    """Remove dynamics from the cursor's selection."""
    return find_positions(cursor, lambda t: isinstance(t, ly.lex.lilypond.Dynamic))


@remove
def markup(cursor):
    """Remove (postfix) markup texts from the cursor's selection."""
    source = ly.document.Source(cursor, True, tokens_with_position=True)
    for token in source:
        if isinstance(token, ly.lex.lilypond.Direction):
            start = token.pos
            for token in source:
                if token == '\\markup':
                    # find the end of the markup expression
                    depth = source.state.depth()
                    for token in source:
                        if source.state.depth() < depth:
                            yield start, token.end
                            break
                elif token == '"':
                    # find the end of the string
                    for token in source:
                        if isinstance(token, ly.lex.StringEnd):
                            yield start, token.end
                            break
                elif token.isalpha():
                    yield start, token.end
                elif isinstance(token, ly.lex.Space):
                    continue
                break


@remove
def smart_delete(cursor, backspace=False):
    """This function intelligently deletes an item the cursor is at.
    
    Basically it behaves like normal Delete (cursor.deleteChar()) or BackSpace
    (cursor.deletePreviousChar()), but it performs the following:
    
    - if the item is a matching object (, ), [, ], \[, \] etc, the other item is
      deleted as well
    - if the item is an articulation it is deleted completely with direction
      specifier if present
    - if the cursor is on a note, the whole notename is deleted including
      postfix stuff
    - if the cursor is on the '<' of a chord, the whole chord is deleted
    
    TODO: implement
    """
    pass



########NEW FILE########
__FILENAME__ = qutil
# qutil.py -- various Qt4-related utility functions
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Some Qt4-related utility functions.
"""

from __future__ import unicode_literals

import contextlib
import re
import weakref

from PyQt4.QtCore import QEventLoop, QSettings, QSize, QTimer, Qt
from PyQt4.QtGui import (
    QAction, QApplication, QColor, QKeySequence, QProgressDialog)

import info


def saveDialogSize(dialog, key, default=QSize()):
    """Makes the size of a QDialog persistent.
    
    Resizes a QDialog from the setting saved in QSettings().value(key),
    defaulting to the optionally specified default size, and stores the
    size of the dialog at its finished() signal.
    
    Call this method at the end of the dialog constructor, when its
    widgets are instantiated.
    
    """
    size = QSettings().value(key, default, QSize)
    if size:
        dialog.resize(size)
    dialogref = weakref.ref(dialog)
    def save():
        dialog = dialogref()
        if dialog:
            QSettings().setValue(key, dialog.size())
    dialog.finished.connect(save)


@contextlib.contextmanager
def signalsBlocked(*objs):
    """Blocks the signals of the given QObjects and then returns a contextmanager"""
    blocks = [obj.blockSignals(True) for obj in objs]
    try:
        yield
    finally:
        for obj, block in zip(objs, blocks):
            obj.blockSignals(block)


@contextlib.contextmanager
def deleteLater(*qobjs):
    """Performs code and calls deleteLater() when done on the specified QObjects."""
    try:
        yield
    finally:
        for obj in qobjs:
            obj.deleteLater()


def addAccelerators(actions, used=[]):
    """Adds accelerators to the list of QActions (or QLabels used as buddy).
    
    Actions that have accelerators are skipped, the accelerators that they use
    are not used. This can be used for e.g. menus that are created on the fly.
    
    used is a sequence of already used accelerators (in lower case).
    
    """
    # filter out the actions that already have an accelerator
    todo = []
    used = set(used)
    for a in actions:
        if a.text():
            accel = getAccelerator(a.text())
            used.add(accel) if accel else todo.append(a)
    
    def finditers(action):
        """Yields two-tuples (priority, re.finditer object).
        
        The finditer object finds suitable accelerator positions.
        The priority can be used if multiple actions want the same shortcut.
        
        """
        text = action.text()
        if isinstance(action, QAction) and not action.shortcut().isEmpty():
            # if the action has a shortcut with A-Z or 0-9, match that character
            shortcut = action.shortcut()[action.shortcut().count()-1]
            key = shortcut & ~Qt.ALT & ~Qt.SHIFT & ~Qt.CTRL & ~Qt.META
            if 48 < key < 58 or 64 < key < 91 or 96 < key < 123:
                yield 0, re.finditer(r'\b{0:c}'.format(key), text, re.I)
        yield 1, re.finditer(r'\b\w', text)
        yield 2, re.finditer(r'\B\w', text)
    
    def find(action):
        """Yields three-tuples (priority, pos, accel) from finditers()."""
        for prio, matches in finditers(action):
            for m in matches:
                yield prio, m.start(), m.group().lower()
    
    todo = [(a, find(a)) for a in todo]
    
    while todo:
        # just pick the first accel for every action
        accels = {}
        for a, source in todo:
            for prio, pos, accel in source:
                if accel not in used:
                    accels.setdefault(accel, []).append((prio, pos, a, source))
                    break
        
        # now, fore every accel, if more than one action wants the same accel,
        # pick the action with the first priority or position, and try again the
        # other actions.
        todo = []
        used.update(accels)
        for action_list in accels.itervalues():
            action_list.sort(key=lambda i: i[:2])
            pos, a = action_list[0][1:3]
            a.setText(a.text()[:pos] + '&' + a.text()[pos:])
            todo.extend((a, source) for prio, pos, a, source in action_list[1:])


def getAccelerator(text):
    """Returns the accelerator (in lower case) contained in the text, if any.
    
    An accelerator is a character preceded by an ampersand &.
    
    """
    m = re.search(r'&(\w)', text.replace('&&', ''))
    if m:
        return m.group(1).lower()


def removeAccelerator(text):
    """Removes accelerator ampersands from a QAction.text() string."""
    return text.replace('&&', '\0').replace('&', '').replace('\0', '&')


def removeShortcut(action, key):
    """Removes matching QKeySequence from the list of the action."""
    key = QKeySequence(key)
    shortcuts = action.shortcuts()
    for s in action.shortcuts():
        if key.matches(s) or s.matches(key):
            shortcuts.remove(s)
    action.setShortcuts(shortcuts)


def addcolor(color, r, g, b):
    """Adds r, g and b values to the given color and returns a new QColor instance."""
    r += color.red()
    g += color.green()
    b += color.blue()
    d = max(r, g, b) - 255
    if d > 0:
        r = max(0, r - d)
        g = max(0, g - d)
        b = max(0, b - d)
    return QColor(r, g, b)


def mixcolor(color1, color2, mix):
    """Returns a QColor as if color1 is painted on color2 with alpha value mix (0.0 - 1.0)."""
    r1, g1, b1 = color1.red(), color1.green(), color1.blue()
    r2, g2, b2 = color2.red(), color2.green(), color2.blue()
    r = r1 * mix + r2 * (1 - mix)
    g = g1 * mix + g2 * (1 - mix)
    b = b1 * mix + b2 * (1 - mix)
    return QColor(r, g, b)


@contextlib.contextmanager
def busyCursor(cursor=Qt.WaitCursor, processEvents=True):
    """Performs the contained code using a busy cursor.
    
    The default cursor used is Qt.WaitCursor.
    If processEvents is True (the default), QApplication.processEvents()
    will be called once before the contained code is executed.
    
    """
    QApplication.setOverrideCursor(cursor)
    processEvents and QApplication.processEvents()
    try:
        yield
    finally:
        QApplication.restoreOverrideCursor()


def waitForSignal(signal, message="", timeout=0):
    """Waits (max timeout msecs if given) for a signal to be emitted.
    
    It the waiting lasts more than 2 seconds, a progress dialog is displayed
    with the message.
    
    Returns True if the signal was emitted.
    Return False if the wait timed out or the dialog was canceled by the user.
    
    """
    loop = QEventLoop()
    dlg = QProgressDialog(minimum=0, maximum=0, labelText=message)
    dlg.setWindowTitle(info.appname)
    dlg.setWindowModality(Qt.ApplicationModal)
    QTimer.singleShot(2000, dlg.show)
    dlg.canceled.connect(loop.quit)
    if timeout:
        QTimer.singleShot(timeout, dlg.cancel)
    stop = lambda: loop.quit()
    signal.connect(stop)
    loop.exec_()
    signal.disconnect(stop)
    dlg.hide()
    dlg.deleteLater()
    return not dlg.wasCanceled()



########NEW FILE########
__FILENAME__ = recentfiles
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Recent files handling.
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import QSettings, QUrl

import app

__all__ = ['urls', 'add', 'remove']


_recentfiles = None

# the maximum number of items remembered
MAXLEN = 10


def load():
    global _recentfiles
    if _recentfiles is not None:
        return
    _recentfiles = []
    
    try:
        urls = QSettings().value("recent_files", [], QUrl)
    except TypeError:
        urls = []
    for url in urls:
        if os.access(url.toLocalFile(), os.R_OK):
            _recentfiles.append(url)
    del _recentfiles[MAXLEN:]
    app.aboutToQuit.connect(save)

def save():
    QSettings().setValue("recent_files", _recentfiles)

def urls():
    load()
    return _recentfiles
    
def add(url):
    load()
    if url in _recentfiles:
        _recentfiles.remove(url)
    _recentfiles.insert(0, url)
    del _recentfiles[MAXLEN:]

def remove(url):
    load()
    if url in _recentfiles:
        _recentfiles.remove(url)
        

########NEW FILE########
__FILENAME__ = reformat
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Reformat the selection or the whole document, only adjusting whitespace.

What it does:

- remove trialing whitespace
- newline after all { or << in lilypond mode, unless terminated on same line
- same way newline before >> or }
- remove indent for commented lines with more than two comment characters
- never removes existing newlines
- Html, scheme, strings, etc are left alone

What it also could do, but not yet:

- newline before and after many non-postfix commands, such as \set, \override
- at least one blank line between multiline top-level blocks (unless comment)
- wordwrap lines longer than 79 characters

"""

from __future__ import unicode_literals

import indent
import lydocument
import ly.reformat


def reformat(cursor):
    """Reformat the selection or the whole document."""
    i = indent.indenter(cursor.document())
    c = lydocument.cursor(cursor, select_all=True)
    ly.reformat.reformat(c, i)


def remove_trailing_whitespace(cursor):
    """Remove trailing whitespace from all lines in the selection.
    
    If there is no selection, the whole document is used.
    
    """
    ly.reformat.remove_trailing_whitespace(lydocument.cursor(cursor, select_all=True))



########NEW FILE########
__FILENAME__ = api
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2012 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Inter-Process Communication with already running Frescobaldi instances.

This is done via a local (unix domain) socket, to which simple commands
are written. Every command is a line of ASCII characters, terminated by a
newline. Arguments are separated with spaces.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QUrl
from PyQt4.QtGui import QApplication
from PyQt4.QtNetwork import QLocalSocket

import app


_incoming_handlers = []


class Remote(object):
    """Speak to the remote Frescobaldi."""
    def __init__(self, socket):
        self.socket = socket
    
    def close(self):
        """Close and disconnect."""
        self.write(b'bye\n')
        self.socket.waitForBytesWritten()
        self.socket.disconnectFromServer()
        if self.socket.state() == QLocalSocket.ConnectedState:
            self.socket.waitForDisconnected(5000)
    
    def write(self, data):
        """Writes binary data."""
        while data:
            l = self.socket.write(data)
            data = data[l:]
    
    def command_line(self, options, urls):
        """Let remote Frescobaldi handle a command line."""
        if urls:
            if options.encoding:
                self.write(b'encoding {0}\n'.format(options.encoding))
            for u in urls:
                self.write(b'open {0}\n'.format(u.toEncoded()))
            self.write(b'set_current {0}\n'.format(u.toEncoded()))
            if options.line is not None:
                self.write(b'set_cursor {0} {1}\n'.format(options.line, options.column))
        self.write(b'activate_window\n')


class Incoming(object):
    """Handle an incoming connection."""
    def __init__(self, socket):
        """Start reading from the socket and perform the commands."""
        self.socket = socket
        self.data = bytearray()
        self.encoding = None
        _incoming_handlers.append(self)
        socket.readyRead.connect(self.read)
        socket.disconnected.connect(self.close)
    
    def close(self):
        self.socket.deleteLater()
        _incoming_handlers.remove(self)
    
    def read(self):
        """Read from the socket and let command() handle the commands."""
        self.data.extend(self.socket.readAll())
        pos = self.data.find(b'\n')
        end = 0
        while pos != -1:
            self.command(self.data[end:pos])
            end = pos + 1
            pos = self.data.find(b'\n', end)
        del self.data[:end]
    
    def command(self, command):
        """Perform one command."""
        command = command.split()
        cmd = command[0]
        args = command[1:]
        
        win = QApplication.activeWindow()
        if win not in app.windows:
            if not app.windows:
                import mainwindow
                mainwindow.MainWindow().show()
            win = app.windows[0]
        
        if cmd == b'open':
            url = QUrl.fromEncoded(args[0])
            win.openUrl(url, self.encoding)
        elif cmd == b'encoding':
            self.encoding = str(args[0])
        elif cmd == b'activate_window':
            win.activateWindow()
            win.raise_()
        elif cmd == b'set_current':
            url = QUrl.fromEncoded(args[0])
            win.setCurrentDocument(app.openUrl(url, self.encoding))
        elif cmd == b'set_cursor':
            line, column = map(int, args)
            cursor = win.textCursor()
            pos = cursor.document().findBlockByNumber(line - 1).position() + column
            cursor.setPosition(pos)
            win.currentView().setTextCursor(cursor)
        elif cmd == b'bye':
            self.close()



########NEW FILE########
__FILENAME__ = resultfiles
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Finds out which files are created by running the engraver.
"""

from __future__ import unicode_literals

import itertools
import glob
import os

import app
import documentinfo
import jobmanager
import plugin
import util


def results(document):
    return Results.instance(document)


# Set the basenames of the resulting documents to expect when a job starts
@app.jobStarted.connect
def _init_basenames(document):
    results(document).saveDocumentInfo()
    


class Results(plugin.DocumentPlugin):
    """Can be queried to get the files created by running the engraver (LilyPond) on our document."""
    def __init__(self, document):
        self._jobfile = None
        self._basenames = None
        document.saved.connect(self.forgetDocumentInfo)
        
    def saveDocumentInfo(self):
        """Takes over some vital information from a DocumentInfo instance.
        
        The file a job is run on and the basenames expected to be created are saved.
        When the user saves a Document after a Job has run, this information is 'forgotten' again.
        
        Otherwise the results of a Job would not be seen if the user starts a Job and then
        saves the Document while the job is still running.  The Job uses the scratcharea if the
        document was modified but saving it would result in DocumentInfo.jobinfo()[0] pointing
        to the real document instead.
        
        """
        info = documentinfo.info(self.document())
        self._jobfile = info.jobinfo()[0]
        self._basenames = info.basenames()

    def forgetDocumentInfo(self):
        """Called when the user saves a Document.
        
        'Forgets' the basenames and job filename if set, but only if no job is currently running.
        
        """
        if not jobmanager.isRunning(self.document()):
            self._jobfile = None
            self._basenames = None
            
    def jobfile(self):
        """Returns the file that is currently being, or will be, engraved."""
        if self._jobfile is None:
            return documentinfo.info(self.document()).jobinfo()[0]
        return self._jobfile

    def basenames(self):
        """Returns the list of basenames the last or running Job is expected to create."""
        if self._basenames is None:
            return documentinfo.info(self.document()).basenames()
        return self._basenames

    def files(self, extension = '*', newer = True):
        """Returns a list of existing files matching our basenames and the given extension.
        
        First the files basename + extension are returned,
        then basename + '-[0-9]+' + extension,
        then basename + '-.+' + extension.
        
        If newer is True (the default), only files that are newer than the jobfile() are returned.
        
        """
        jobfile = self.jobfile()
        if jobfile:
            files = util.files(self.basenames(), extension)
            if newer:
                try:
                    mtime = os.path.getmtime(jobfile)
                    files = filter(lambda fname: os.path.getmtime(fname) >= mtime, files)
                except (OSError, IOError):
                    pass
            return list(files)
        return []
    
    def is_newer(self, filename):
        """Return True if the given (generated) file is newer than the jobfile().
        
        Also return True if the mtime of one of the files could not be read.
        
        """
        jobfile = self.jobfile()
        if jobfile:
            try:
                return os.path.getmtime(filename) > os.path.getmtime(jobfile)
            except (OSError, IOError):
                pass
        return True
        
    def currentDirectory(self):
        """Returns the directory the document resides in.
        
        Returns the temporary directory if that was used last.
        
        """
        directory = os.path.dirname(self.jobfile())
        if os.path.isdir(directory):
            return directory



########NEW FILE########
__FILENAME__ = rhythm
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Implementation of the tools to edit durations of selected music.

Durations are represented simply by lists of ly.lex.lilypond.Duration tokens.
"""

from __future__ import unicode_literals

import itertools

import icons
import inputdialog
import lydocument
import ly.rhythm


_clipboard = [] # clipboard for rhythm copy and paste

_history = set() # earlier rhythms typed in apply dialog


def rhythm_double(cursor):
    ly.rhythm.rhythm_double(lydocument.cursor(cursor))

def rhythm_halve(cursor):
    ly.rhythm.rhythm_halve(lydocument.cursor(cursor))

def rhythm_dot(cursor):
    ly.rhythm.rhythm_dot(lydocument.cursor(cursor))

def rhythm_undot(cursor):
    ly.rhythm.rhythm_undot(lydocument.cursor(cursor))

def rhythm_remove_scaling(cursor):
    ly.rhythm.rhythm_remove_scaling(lydocument.cursor(cursor))

def rhythm_remove_fraction_scaling(cursor):
    ly.rhythm.rhythm_remove_fraction_scaling(lydocument.cursor(cursor))

def rhythm_remove(cursor):
    ly.rhythm.rhythm_remove(lydocument.cursor(cursor))

def rhythm_implicit(cursor):
    ly.rhythm.rhythm_implicit(lydocument.cursor(cursor))

def rhythm_implicit_per_line(cursor):
    ly.rhythm.rhythm_implicit_per_line(lydocument.cursor(cursor))

def rhythm_explicit(cursor):
    ly.rhythm.rhythm_explicit(lydocument.cursor(cursor))

def rhythm_apply(cursor, mainwindow):
    durs = inputdialog.getText(mainwindow,
        _("Apply Rhythm"), _("Enter a rhythm:"),
        complete = sorted(_history),
        regexp = r'([0-9./* ]|\\breve|\\longa|\\maxima)+',
        help = "rhythm", icon = icons.get('tools-rhythm'))
    durations = durs.split()
    if durations:
        _history.add(durs.strip())
    ly.rhythm.rhythm_overwrite(lydocument.cursor(cursor), durations)

def rhythm_copy(cursor):
    _clipboard[:] = ly.rhythm.rhythm_extract(lydocument.cursor(cursor))

def rhythm_paste(cursor):
    ly.rhythm.rhythm_overwrite(lydocument.cursor(cursor), _clipboard)


########NEW FILE########
__FILENAME__ = build
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Builds the LilyPond score from the settings in the Score Wizard.
"""

from __future__ import unicode_literals

import collections
import fractions
import re

import ly.dom
import po.mofile

from . import parts
import parts._base
import parts.containers


class PartNode(object):
    """Represents an item with sub-items in the parts tree.
    
    Sub-items of this items are are split out in two lists: the 'parts' and
    'groups' attributes.
    
    Parts ('parts' attribute) are vertically stacked (instrumental parts or
    staff groups). Groups ('groups' attribute) are horizontally added (score,
    book, bookpart).
    
    The Part (containing the widgets) is in the 'part' attribute.
    
    """
    def __init__(self, item):
        """item is a PartItem (QTreeWidgetItem)."""
        self.part = getattr(item, 'part', None)
        self.groups = []
        self.parts = []
        for i in range(item.childCount()):
            node = PartNode(item.child(i))
            if isinstance(node.part, parts._base.Group):
                self.groups.append(node)
            else:
                self.parts.append(node)


class PartData(object):
    """Represents what a Part wants to add to the LilyPond score.
    
    A Part may append to the following instance attributes (which are lists):
    
    includes:           (string) filename to be included
    codeblocks:         (ly.dom.LyNode) global blocks of code a part depends on
    assignments:        (ly.dom.Assignment) assignment of an expression to a
                        variable, most times the music stub for a part
    nodes:              (ly.dom.LyNode) the nodes a part adds to the parent \score
    afterblocks:        (ly.dom.LyNode) other blocks, appended ad the end
    
    The num instance attribute is set to 0 by default but can be increased by
    the Builder, when there are more parts of the exact same type in the same
    score.
    
    This is used by the builder afterwards to adjust identifiers and instrument
    names to this.
    
    """
    def __init__(self, part, parent=None):
        """part is a parts._base.Part instance, parent may be another PartData."""
        if parent:
            parent.children.append(self)
        self.isChild = bool(parent)
        self._name = part.__class__.__name__
        self.children = []
        self.num = 0
        self.includes = []
        self.codeblocks = []
        self.assignments = []
        self.nodes = []
        self.afterblocks = []
    
    def name(self):
        """Returns a name for this part data.
        
        The name consists of the class name of the part with the value of the num
        attribute appended as a roman number.
        
        """
        if self.num:
            return self._name + ly.util.int2roman(self.num)
        return self._name

    def assign(self, name=None):
        """Creates a ly.dom.Assignment.
        
        name is a string name, if not given the class name is used with the
        first letter lowered.
        
        A ly.dom.Reference is used as the name for the Assignment.
        The assignment is appended to our assignments and returned.
        
        The Reference is in the name attribute of the assignment.
        
        """
        a = ly.dom.Assignment(ly.dom.Reference(name or ly.util.mkid(self.name())))
        self.assignments.append(a)
        return a
    
    def assignMusic(self, name=None, octave=0, transposition=None):
        """Creates a ly.dom.Assignment with a \\relative music stub."""
        a = self.assign(name)
        stub = ly.dom.Relative(a)
        ly.dom.Pitch(octave, 0, 0, stub)
        s = ly.dom.Seq(stub)
        ly.dom.Identifier(self.globalName, s).after = 1
        if transposition is not None:
            toct, tnote, talter = transposition
            ly.dom.Pitch(toct, tnote, fractions.Fraction(talter, 2), ly.dom.Transposition(s))
        ly.dom.LineComment(_("Music follows here."), s)
        ly.dom.BlankLine(s)
        return a


class BlockData(object):
    """Represents the building blocks of a global section of a ly.dom.Document."""
    def __init__(self):
        self.assignments = ly.dom.Block()
        self.scores = ly.dom.Block()
        self.backmatter = ly.dom.Block()


class Builder(object):
    """Builds the LilyPond score from all user input in the score wizard.
    
    Reads settings and other input from the dialog on construction.
    Does not need the dialog after that.
    
    """
    def __init__(self, dialog):
        """Initializes ourselves from all user settings in the dialog."""
        self._includeFiles = []
        self.globalUsed = False
        
        scoreProperties = dialog.settings.widget().scoreProperties
        generalPreferences = dialog.settings.widget().generalPreferences
        lilyPondPreferences = dialog.settings.widget().lilyPondPreferences
        instrumentNames = dialog.settings.widget().instrumentNames
        
        # attributes the Part and Container types may read and we need later as well
        self.header = list(dialog.header.widget().headers())
        self.headerDict = dict(self.header)
        self.lyVersionString = lilyPondPreferences.version.currentText().strip()
        self.lyVersion = tuple(map(int, re.findall('\\d+', self.lyVersionString)))
        self.midi = generalPreferences.midi.isChecked()
        self.pitchLanguage = dialog.pitchLanguage()
        self.suppressTagLine = generalPreferences.tagl.isChecked()
        self.removeBarNumbers = generalPreferences.barnum.isChecked()
        self.smartNeutralDirection = generalPreferences.neutdir.isChecked()
        self.showMetronomeMark = generalPreferences.metro.isChecked()
        self.paperSize = generalPreferences.getPaperSize()
        self.paperLandscape = generalPreferences.paperLandscape.isChecked()
        self.showInstrumentNames = instrumentNames.isChecked()
        names = ['long', 'short', None]
        self.firstInstrumentName = names[instrumentNames.firstSystem.currentIndex()]
        self.otherInstrumentName = names[instrumentNames.otherSystems.currentIndex()]
        
        # translator for instrument names
        self._ = _
        if instrumentNames.isChecked():
            lang = instrumentNames.getLanguage()
            if lang == 'C':
                self._ = po.translator(None)
            elif lang:
                mofile = po.find(lang)
                if mofile:
                    self._ = po.translator(po.mofile.MoFile(mofile))
        
        # global score preferences
        self.scoreProperties = scoreProperties
        self.globalSection = scoreProperties.globalSection(self)
        
        # printer that converts the ly.dom tree to text
        p = self._printer = ly.dom.Printer()
        p.indentString = "  " # will be re-indented anyway
        p.typographicalQuotes = generalPreferences.typq.isChecked()
        if self.pitchLanguage:
            p.language = self.pitchLanguage
        
        # get the parts
        globalGroup = PartNode(dialog.parts.widget().rootPartItem())
        
        # move parts down the tree to subgroups that have no parts
        assignparts(globalGroup)
        
        # now prepare the different blocks
        self.usePrefix = needsPrefix(globalGroup)
        self.currentScore = 0
        
        # make a part of the document (assignments, scores, backmatter) for
        # every group (book, bookpart or score) in the global group
        if globalGroup.parts:
            groups = [globalGroup]
        else:
            groups = globalGroup.groups
        
        self.blocks = []
        for group in groups:
            block = BlockData()
            self.makeBlock(group, block.scores, block)
            self.blocks.append(block)
    
    def makeBlock(self, group, node, block):
        """Recursively populates the Block with data from the group.
        
        The group can contain parts and/or subgroups.
        ly.dom.LyNodes representing the LilyPond document are added to the node.
        
        """
        if group.part:
            node = group.part.makeNode(node)
        if group.parts:
            # prefix for this block, used if necessary
            self.currentScore += 1
            prefix = 'score' + ly.util.int2letter(self.currentScore)
            
            # is this a score and has it its own score properties?
            globalName = 'global'
            scoreProperties = self.scoreProperties
            if isinstance(group.part, parts.containers.Score):
                globalSection = group.part.globalSection(self)
                if globalSection:
                    scoreProperties = group.part
                    globalName = prefix + 'Global'
                    a = ly.dom.Assignment(globalName, block.assignments)
                    a.append(globalSection)
                    ly.dom.BlankLine(block.assignments)
            if globalName == 'global':
                self.globalUsed = True
            
            # add parts here, always in \score { }
            score = node if isinstance(node,ly.dom.Score) else ly.dom.Score(node)
            ly.dom.Layout(score)
            if self.midi:
                midi = ly.dom.Midi(score)
                # set MIDI tempo if necessary
                if not self.showMetronomeMark:
                    if self.lyVersion >= (2, 16, 0):
                        scoreProperties.lySimpleMidiTempo(midi)
                        midi[0].after = 1
                    else:
                        scoreProperties.lyMidiTempo(ly.dom.Context('Score', midi))
            music = ly.dom.Simr()
            score.insert(0, music)
            
            # a PartData subclass "knowing" the globalName and scoreProperties
            class _PartData(PartData): pass
            _PartData.globalName = globalName
            _PartData.scoreProperties = scoreProperties
                
            # make the parts
            partData = self.makeParts(group.parts, _PartData)
            
            # record the include files a part wants to add
            for p in partData:
                for i in p.includes:
                    if i not in self._includeFiles:
                        self._includeFiles.append(i)
            
            # collect all 'prefixable' assignments for this group
            assignments = []
            for p in partData:
                assignments.extend(p.assignments)
                
            # add the assignments to the block
            for p in partData:
                for a in p.assignments:
                    block.assignments.append(a)
                    ly.dom.BlankLine(block.assignments)
                block.backmatter.extend(p.afterblocks)
                
            # make part assignments if there is more than one part that has assignments
            if sum(1 for p in partData if p.assignments) > 1:
                def make(part, music):
                    if part.assignments:
                        a = ly.dom.Assignment(ly.dom.Reference(ly.util.mkid(part.name() + "Part")))
                        ly.dom.Simr(a).extend(part.nodes)
                        ly.dom.Identifier(a.name, music).after = 1
                        block.assignments.append(a)
                        ly.dom.BlankLine(block.assignments)
                        assignments.append(a)
                    else:
                        music.extend(part.nodes)
            else:
                def make(part, music):
                    music.extend(part.nodes)
            
            def makeRecursive(parts, music):
                for part in parts:
                    make(part, music)
                    if part.children:
                        makeRecursive(part.children, part.music)
            
            parents = [p for p in partData if not p.isChild]
            makeRecursive(parents, music)
            
            # add the prefix to the assignments if necessary
            if self.usePrefix:
                for a in assignments:
                    a.name.name = ly.util.mkid(prefix, a.name.name)
            
        for g in group.groups:
            self.makeBlock(g, node, block)
    
    def makeParts(self, parts, partDataClass):
        """Lets the parts build the music stubs and assignments.
        
        parts is a list of PartNode instances.
        partDataClass is a subclass or PartData containing some attributes:
            - globalName is either 'global' (for the global time/key signature
              section) or something like 'scoreAGlobal' (when a score has its
              own properties).
            - scoreProperties is the ScoreProperties instance currently in effect
              (the global one or a particular Score part's one).
        
        Returns the list of PartData object for the parts.
        
        """
        # number instances of the same type (Choir I and Choir II, etc.)
        data = {}
        types = collections.defaultdict(list)
        def _search(parts, parent=None):
            for group in parts:
                pd = data[group] = partDataClass(group.part, parent)
                types[pd.name()].append(group)
                _search(group.parts, pd)
        _search(parts)
        for t in types.values():
            if len(t) > 1:
                for num, group in enumerate(t, 1):
                    data[group].num = num

        # now build all the parts
        for group in allparts(parts):
            group.part.build(data[group], self)
        
        # check for name collisions in assignment identifiers
        # add the part class name and a roman number if necessary
        refs = collections.defaultdict(list)
        for group in allparts(parts):
            for a in data[group].assignments:
                ref = a.name
                name = ref.name
                refs[name].append((ref, group))
        for reflist in refs.values():
            if len(reflist) > 1:
                for ref, group in reflist:
                    # append the class name and number
                    ref.name = ly.util.mkid(ref.name, data[group].name())
        
        # return all PartData instances
        return [data[group] for group in allparts(parts)]
        
    def text(self, doc=None):
        """Return LilyPond formatted output. """
        return self.printer().indent(doc or self.document())
        
    def printer(self):
        """Returns a ly.dom.Printer, that converts the ly.dom structure to LilyPond text. """
        return self._printer
        
    def document(self):
        """Creates and returns a ly.dom tree representing the full LilyPond document."""
        doc = ly.dom.Document()
        
        # version
        ly.dom.Version(self.lyVersionString, doc)
        
        # language
        if self.pitchLanguage:
            if self.lyVersion >= (2, 13, 38):
                ly.dom.Line('\\language "{0}"'.format(self.pitchLanguage), doc)
            else:
                ly.dom.Include("{0}.ly".format(self.pitchLanguage), doc)
        ly.dom.BlankLine(doc)

        # other include files
        if self._includeFiles:
            for filename in self._includeFiles:
                ly.dom.Include(filename, doc)
            ly.dom.BlankLine(doc)
            
        # general header
        h = ly.dom.Header()
        for name, value in self.header:
            h[name] = value
        if 'tagline' not in h and self.suppressTagLine:
            ly.dom.Comment(_("Remove default LilyPond tagline"), h)
            h['tagline'] = ly.dom.Scheme('#f')
        if len(h):
            doc.append(h)
            ly.dom.BlankLine(doc)

        # paper size
        if self.paperSize:
            ly.dom.Scheme(
                '(set-paper-size "{0}"{1})'.format(
                    self.paperSize, " 'landscape" if self.paperLandscape else ""),
                ly.dom.Paper(doc)
            ).after = 1
            ly.dom.BlankLine(doc)

        layout = ly.dom.Layout()
        
        # remove bar numbers
        if self.removeBarNumbers:
            ly.dom.Line('\\remove "Bar_number_engraver"',
                ly.dom.Context('Score', layout))
        
        # smart neutral direction
        if self.smartNeutralDirection:
            ctxt_voice = ly.dom.Context('Voice', layout)
            ly.dom.Line('\\consists "Melody_engraver"', ctxt_voice)
            ly.dom.Line("\\override Stem #'neutral-direction = #'()", ctxt_voice)
        
        if len(layout):
            doc.append(layout)
            ly.dom.BlankLine(doc)

        # global section
        if self.globalUsed:
            a = ly.dom.Assignment('global')
            a.append(self.globalSection)
            doc.append(a)
            ly.dom.BlankLine(doc)
        
        # add the main scores
        for block in self.blocks:
            doc.append(block.assignments)
            doc.append(block.scores)
            ly.dom.BlankLine(doc)
            if len(block.backmatter):
                doc.append(block.backmatter)
                ly.dom.BlankLine(doc)
        return doc

    def setMidiInstrument(self, node, midiInstrument):
        """Sets the MIDI instrument for the node, if the user wants MIDI output."""
        if self.midi:
            node.getWith()['midiInstrument'] = midiInstrument

    def setInstrumentNames(self, staff, longName, shortName):
        """Sets the instrument names to the staff (or group).
        
        longName and shortName may either be a string or a ly.dom.LyNode object (markup)
        The settings in the score wizard are honored.
        
        """
        if self.showInstrumentNames:
            staff.addInstrumentNameEngraverIfNecessary()
            w = staff.getWith()
            first = longName if self.firstInstrumentName == 'long' else shortName
            w['instrumentName'] = first
            if self.otherInstrumentName:
                other = longName if self.otherInstrumentName == 'long' else shortName
                # If these are markup objects, copy them otherwise the assignment
                # to shortInstrumentName takes it away from the instrumentName.
                if other is first and isinstance(first, ly.dom.LyNode):
                    other = other.copy()
                w['shortInstrumentName'] = other

    def instrumentName(self, function, num=0):
        """Returns an instrument name.
        
        The name is constructed by calling the 'function' with our translator as
        argument, and appending the number 'num' in roman literals, if num > 0.
        
        """
        name = function(self._)
        if num:
            name += ' ' + ly.util.int2roman(num)
        return name
    
    def setInstrumentNamesFromPart(self, node, part, data):
        """Sets the long and short instrument names for the node.
        
        Calls part.title(translator) and part.short(translator) to get the
        names, appends roman literals if data.num > 0, and sets them on the node.
        
        """
        longName = self.instrumentName(part.title, data.num)
        shortName = self.instrumentName(part.short, data.num)
        self.setInstrumentNames(node, longName, shortName)


def assignparts(group):
    """Moves the parts to sub-groups that contain no parts.
    
    If at least one subgroup uses the parts, the parent's parts are removed.
    This way a user can specify some parts and then multiple scores, and they will all
    use the same parts again.
    
    """
    partsOfParentUsed = False
    for g in group.groups:
        if not g.parts:
            g.parts = group.parts
            partsOfParentUsed = True
        assignparts(g)
    if partsOfParentUsed:
        group.parts = []


def itergroups(group):
    """Iterates over the group and its subgroups as an event list.
    
    When a group is yielded, it means the group starts.
    When None is yielded, it means that the last started groups ends.
    
    """
    yield group
    for g in group.groups:
        for i in itergroups(g):
            yield i
    yield None # end a group


def descendants(group):
    """Iterates over the descendants of a group (including the group itself).
    
    First the group, then its children, then the grandchildren, etc.
    
    """
    def _descendants(group):
        children = group.groups
        while children:
            new = []
            for g in children:
                yield g
                new.extend(g.groups)
            children = new
    yield group
    for g in _descendants(group):
        yield g


def needsPrefix(globalGroup):
    """Returns True if there are multiple scores in group with shared part types.
    
    This means the music assignments will need a prefix (e.g. scoreAsoprano,
    scoreBsoprano, etc.)
    
    """
    counter = {}    # collections.Counter() would be nice but requires Python 2.7
    for group in itergroups(globalGroup):
        if group:
            partTypes = set(type(g.part) for g in group.parts)
            for partType in partTypes:
                counter[partType] = counter.get(partType, 0) + 1
    return any(v for v in counter.values() if v > 1)


def allparts(parts):
    """Yields all the parts and child parts."""
    for group in parts:
        yield group
        for group in allparts(group.parts):
            yield group
        

########NEW FILE########
__FILENAME__ = dialog
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Score Wizard dialog.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import indent
import qutil
import userguide
import ly.document


class ScoreWizardDialog(QDialog):
    
    pitchLanguageChanged = pyqtSignal(type(""))
    
    def __init__(self, mainwindow):
        super(ScoreWizardDialog, self).__init__(mainwindow)
        self.addAction(mainwindow.actionCollection.help_whatsthis)
        self._pitchLanguage = None
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.tabs = QTabWidget()
        b = self.dialogButtons = QDialogButtonBox()
        b.setStandardButtons(
            QDialogButtonBox.Reset
            | QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        b.accepted.connect(self.accept)
        b.rejected.connect(self.reject)
        userguide.addButton(b, "scorewiz")
        b.button(QDialogButtonBox.Reset).clicked.connect(self.reset)
        self.previewButton = b.addButton('', QDialogButtonBox.ActionRole)
        self.previewButton.clicked.connect(self.showPreview)
        layout.addWidget(self.tabs)
        layout.addWidget(b)
        
        self.header = Header(self)
        self.tabs.addTab(self.header, '')
        self.parts = Parts(self)
        self.tabs.addTab(self.parts, '')
        self.settings = Settings(self)
        self.tabs.addTab(self.settings, '')
        
        self.tabs.setCurrentIndex(0)
        self.tabs.widget(0).widget() # activate it
        self.tabs.currentChanged.connect(self.slotCurrentChanged)
        qutil.saveDialogSize(self, "scorewiz/dialog/size")
        app.translateUI(self)
        self.accepted.connect(self.slotAccepted)
    
    def translateUI(self):
        self.setWindowTitle(app.caption(_("Score Setup Wizard")))
        for i in range(self.tabs.count()):
            self.tabs.setTabText(i, self.tabs.widget(i).title())
        self.dialogButtons.button(QDialogButtonBox.Reset).setText(_("Clear"))
        self.dialogButtons.button(QDialogButtonBox.Reset).setToolTip(_(
            "Clears the current page of the Score Wizard."))
        self.previewButton.setText(_("Preview"))
        
    def slotCurrentChanged(self, i):
        """Lazy-loads the tab's page if shown for the first time."""
        self.tabs.widget(i).widget()
        
    def reset(self):
        self.tabs.currentWidget().widget().clear()

    def setPitchLanguage(self, language):
        if language != self._pitchLanguage:
            self._pitchLanguage = language
            self.pitchLanguageChanged.emit(language)
    
    def pitchLanguage(self):
        if self._pitchLanguage is None:
            # load setting; saving occurs in .settings.py
            lang = QSettings().value('scorewiz/lilypond/pitch_language', '', type(""))
            from .scoreproperties import keyNames
            if lang not in keyNames:
                lang = ''
            self._pitchLanguage = lang
        return self._pitchLanguage

    def slotAccepted(self):
        """Makes the score and puts it in the editor."""
        from . import build
        builder = build.Builder(self)       # get the builder
        text = builder.text()               # get the source text
        lydoc = ly.document.Document(text)  # temporarily store it in a lydoc
        cursor = ly.document.Cursor(lydoc)  # make a cursor selecting it
        indent.indenter().indent(cursor)    # indent it according to user prefs
        doc = app.openUrl(QUrl())           # get a new Frescobaldi document
        doc.setPlainText(lydoc.plaintext()) # write the text in it
        doc.setModified(False)              # make it "not modified"
        self.parent().setCurrentDocument(doc)
    
    def showPreview(self):
        """Shows a preview."""
        # get the document and fill in some example music
        from . import preview, build
        builder = build.Builder(self)
        doc = builder.document()
        preview.examplify(doc)
        # preview it
        import musicpreview
        dlg = musicpreview.MusicPreviewDialog(self)
        dlg.preview(builder.text(doc), _("Score Preview"))
        dlg.exec_()
        dlg.cleanup()


class Page(QWidget):
    """A Page in the tab widget.
    
    Basically this is just a QWidget that loads the desired page
    as soon as the widget() is called for the first time.
    
    """
    def __init__(self, dialog):
        super(Page, self).__init__(dialog)
        self._widget = None
        
    def title(self):
        """Should return a title."""

    def widget(self):
        if self._widget is None:
            layout = QVBoxLayout()
            layout.setContentsMargins(0, 0, 0, 0)
            self.setLayout(layout)
            w = self._widget = self.createWidget(self)
            layout.addWidget(w)
        return self._widget

    def createWidget(self, parent):
        """Should return the widget for this tab."""
        

class Header(Page):
    def title(self):
        return _("&Titles and Headers")

    def createWidget(self, parent):
        from . import header
        return header.HeaderWidget(parent)

        
class Parts(Page):
    def title(self):
        return _("&Parts")

    def createWidget(self, parent):
        from . import score
        return score.ScorePartsWidget(parent)


class Settings(Page):
    def title(self):
        return _("&Score settings")
    
    def createWidget(self, parent):
        from . import settings
        return settings.SettingsWidget(parent)



########NEW FILE########
__FILENAME__ = header
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Header (titles) widget.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import qutil
import textformats
import completionmodel

from . import __path__


class HeaderWidget(QWidget):
    def __init__(self, parent):
        super(HeaderWidget, self).__init__(parent)
        
        layout = QHBoxLayout()
        self.setLayout(layout)
        
        # The html view with the score layout example
        t = self.htmlView = QTextBrowser()
        t.setOpenLinks(False)
        t.setOpenExternalLinks(False)
        t.setSearchPaths(__path__)
        t.setTextInteractionFlags(Qt.LinksAccessibleByMouse)
        t.setFocusPolicy(Qt.NoFocus)
        
        # ensure that the full HTML example page is displayed
        t.setContentsMargins(2, 2, 2, 2)
        t.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        t.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        t.setMinimumSize(QSize(350, 350))
        layout.addWidget(t)
        
        t.anchorClicked.connect(self.slotAnchorClicked)
        
        grid = QGridLayout()
        layout.addLayout(grid)
        
        grid.setVerticalSpacing(1)
        grid.setColumnMinimumWidth(1, 200)
        
        self.labels = {}
        self.edits = {}
        for row, (name, desc) in enumerate(headers()):
            l = QLabel()
            e = QLineEdit()
            l.setBuddy(e)
            grid.addWidget(l, row, 0)
            grid.addWidget(e, row, 1)
            self.labels[name] = l
            self.edits[name] = e
            completionmodel.complete(e, "scorewiz/completion/header/"+name)
            e.completer().setCaseSensitivity(Qt.CaseInsensitive)
        
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
        app.translateUI(self)
        
    def translateUI(self):
        msg = _("Click to enter a value.")
        self.htmlView.setHtml(titles_html.format(
            copyrightmsg = _("bottom of first page"),
            taglinemsg = _("bottom of last page"),
            imgurl = QUrl.fromLocalFile(__path__[0]).toString(),
            **dict((name, "<a title='{0}' href='{1}'>{2}</a>".format(msg, name, desc))
                    for name, desc in headers())))
        for name, desc in headers():
            self.labels[name].setText(desc + ":")
        # add accelerators to names, avoiding the tab names
        tabwidget = self.window().tabs
        used = filter(None, (qutil.getAccelerator(tabwidget.widget(i).title())
                             for i in range(tabwidget.count())))
        qutil.addAccelerators([self.labels[name] for name, desc in headers()], used)

    def readSettings(self):
        p = self.htmlView.palette()
        p.setColor(QPalette.Base, textformats.formatData('editor').baseColors['paper'])
        self.htmlView.setPalette(p)
    
    def slotAnchorClicked(self, url):
        try:
            e = self.edits[url.toString()]
        except KeyError:
            return
        e.setFocus()

    def clear(self):
        """Empties all text entries."""
        for edit in self.edits.values():
            edit.clear()
    
    def headers(self):
        """Yields two-tuples (headername, entered text) for the headers that are non-empty."""
        for name, desc in headers():
            text = self.edits[name].text().strip()
            if text:
                yield name, text
            


def headers():
    """Yields two-tuples (headername, translated name) in a sensible order."""
    yield 'dedication',  _("Dedication")
    yield 'title',       _("Title")
    yield 'subtitle',    _("Subtitle")
    yield 'subsubtitle', _("Subsubtitle")
    yield 'instrument',  _("Instrument")
    yield 'composer',    _("Composer")
    yield 'arranger',    _("Arranger")
    yield 'poet',        _("Poet")
    yield 'meter',       _("Meter")
    yield 'piece',       _("Piece")
    yield 'opus',        _("Opus")
    yield 'copyright',   _("Copyright")
    yield 'tagline',     _("Tagline")


titles_html = r"""<html><head><style type='text/css'>
body {{
  color: black;
}}
a {{
  text-decoration: none;
  color: black;
}}
</style></head>
<body><table width='100%' style='font-family:serif;'>
<tr><td colspan=3 align=center>{dedication}</td></tr>
<tr><td colspan=3 align=center style='font-size:20pt;'><b>{title}</b></td></tr>
<tr><td colspan=3 align=center style='font-size:12pt;'><b>{subtitle}</b></td></tr>
<tr><td colspan=3 align=center><b>{subsubtitle}</b></td></tr>
<tr>
    <td align=left width='25%'>{poet}</td>
    <td align=center><b>{instrument}</b></td>
    <td align=right width='25%'>{composer}</td>
</tr>
<tr>
    <td align=left>{meter}</td>
    <td> </td>
    <td align=right>{arranger}</td>
</tr>
<tr>
    <td align=left>{piece}</td>
    <td> </td>
    <td align=right>{opus}</td>
</tr>
<tr><td colspan=3 align=center><img src="{imgurl}/scorewiz.png"></td></tr>
<tr><td colspan=3 align=center>{copyright} <i>({copyrightmsg})</i></td></tr>
<tr><td colspan=3 align=center>{tagline} <i>({taglinemsg})</i></td></tr>
</table></body></html>
"""

########NEW FILE########
__FILENAME__ = brass
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Brass part types.
"""

from __future__ import unicode_literals

from . import _base
from . import register


class BrassPart(_base.SingleVoicePart):
    """Base class for brass types."""
    
    
class HornF(BrassPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Horn in F")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Horn in F", "Hn.F.")

    midiInstrument = 'french horn'
    transposition = (-1, 3, 0)


class TrumpetC(BrassPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Trumpet in C")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Trumpet in C", "Tr.C.")

    midiInstrument = 'trumpet'
    
    
class TrumpetBb(TrumpetC):
    @staticmethod
    def title(_=_base.translate):
        return _("Trumpet in Bb")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Trumpet in Bb", "Tr.Bb.")

    transposition = (-1, 6, -1)
    
    
class CornetBb(BrassPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Cornet in Bb")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Cornet in Bb", "Crt.Bb.")

    transposition = (-1, 6, -1)
    
   
class Flugelhorn(BrassPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Flugelhorn")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Flugelhorn", "Fgh.")

    midiInstrument = 'trumpet'
   
    
class Mellophone(BrassPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Mellophone")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Mellophone", "Mph.")

    midiInstrument = 'french horn'
    transposition = (-1, 3, 0)


class Trombone(BrassPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Trombone")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Trombone", "Trb.")

    midiInstrument = 'trombone'
    clef = 'bass'
    octave = -1
    
    
class Baritone(BrassPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Baritone")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Baritone", "Bar.")

    midiInstrument = 'trombone'
    clef = 'bass'
    octave = -1
    

class Euphonium(BrassPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Euphonium")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Euphonium", "Euph.")

    midiInstrument = 'trombone'
    clef = 'bass'
    octave = -1
    
    
class Tuba(BrassPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Tuba")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Tuba", "Tb.")

    midiInstrument = 'tuba'
    transposition = (-2, 6, -1)
    

class BassTuba(BrassPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Bass Tuba")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Bass Tuba", "B.Tb.")
    
    midiInstrument = 'tuba'
    clef = 'bass'
    octave = -1
    transposition = (-2, 0, 0)


register(
    lambda: _("Brass"),
    [
        HornF,
        TrumpetC,
        TrumpetBb,
        CornetBb,
        Flugelhorn,
        Mellophone,
        Trombone,
        Baritone,
        Euphonium,
        Tuba,
        BassTuba,
    ])

########NEW FILE########
__FILENAME__ = containers
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Container part types.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import ly.dom
import listmodel
import symbols
import widgets.lineedit
from scorewiz import scoreproperties

from . import _base
from . import register

class StaffGroup(_base.Container):
    @staticmethod
    def title(_=_base.translate):
        return _("Staff Group")

    def accepts(self):
        return (StaffGroup, _base.Part)

    def createWidgets(self, layout):
        self.systemStartLabel = QLabel()
        self.systemStart = QComboBox()
        self.systemStartLabel.setBuddy(self.systemStart)
        self.systemStart.setModel(listmodel.ListModel((
            # L10N: Brace like a piano staff
            (lambda: _("Brace"), 'system_start_brace'),
            # L10N: Bracket like a choir staff
            (lambda: _("Bracket"), 'system_start_bracket'),
            # L10N: Square bracket like a sub-group
            (lambda: _("Square"), 'system_start_square'),
            ), self.systemStart, display=listmodel.translate_index(0),
            icon=lambda item: symbols.icon(item[1])))
        self.systemStart.setIconSize(QSize(64, 64))
        self.connectBarLines = QCheckBox(checked=True)
        
        box = QHBoxLayout()
        box.addWidget(self.systemStartLabel)
        box.addWidget(self.systemStart)
        layout.addLayout(box)
        layout.addWidget(self.connectBarLines)
    
    def translateWidgets(self):
        self.systemStartLabel.setText(_("Type:"))
        self.connectBarLines.setText(_("Connect Barlines"))
        self.connectBarLines.setToolTip(_("If checked, barlines are connected between the staves."))
        self.systemStart.model().update()
    
    def build(self, data, builder):
        s = self.systemStart.currentIndex()
        b = self.connectBarLines.isChecked()
        if s == 0:
            node = ly.dom.GrandStaff()
            if not b:
                ly.dom.Line("\\remove Span_bar_engraver", node.getWith())
        else:
            node = ly.dom.StaffGroup() if b else ly.dom.ChoirStaff()
            if s == 2:
                node.getWith()['systemStartDelimiter'] = ly.dom.Scheme("'SystemStartSquare")
        data.nodes.append(node)
        data.music = ly.dom.Simr(node)


class Score(_base.Group, scoreproperties.ScoreProperties):
    @staticmethod
    def title(_=_base.translate):
        return _("Score")

    def createWidgets(self, layout):
        self.pieceLabel = QLabel()
        self.piece = QLineEdit()
        self.pieceLabel.setBuddy(self.piece)
        self.opusLabel = QLabel()
        self.opus = QLineEdit()
        self.opusLabel.setBuddy(self.opus)
        self.scoreProps = QGroupBox(checkable=True, checked=False)
        scoreproperties.ScoreProperties.createWidgets(self)
        
        grid = QGridLayout()
        grid.addWidget(self.pieceLabel, 0 ,0)
        grid.addWidget(self.piece, 0, 1)
        grid.addWidget(self.opusLabel, 1, 0)
        grid.addWidget(self.opus, 1, 1)
        layout.addLayout(grid)
        layout.addWidget(self.scoreProps)
        layout = QVBoxLayout()
        self.scoreProps.setLayout(layout)
        scoreproperties.ScoreProperties.layoutWidgets(self, layout)
        
        scorewiz = self.scoreProps.window()
        self.setPitchLanguage(scorewiz.pitchLanguage())
        scorewiz.pitchLanguageChanged.connect(self.setPitchLanguage)
        
    def translateWidgets(self):
        self.pieceLabel.setText(_("Piece:"))
        self.opusLabel.setText(_("Opus:"))
        self.scoreProps.setTitle(_("Properties"))
        scoreproperties.ScoreProperties.translateWidgets(self)
        
    def accepts(self):
        return (StaffGroup, _base.Part)

    def makeNode(self, node):
        score = ly.dom.Score(node)
        h = ly.dom.Header()
        piece = self.piece.text().strip()
        opus = self.opus.text().strip()
        if piece:
            h['piece'] = ly.dom.QuotedString(piece)
        if opus:
            h['opus'] = ly.dom.QuotedString(opus)
        if len(h):
            score.append(h)
        return score
    
    def globalSection(self, builder):
        if self.scoreProps.isChecked():
            return scoreproperties.ScoreProperties.globalSection(self, builder)
            


class BookPart(_base.Group):
    @staticmethod
    def title(_=_base.translate):
        return _("Book Part")

    def accepts(self):
        return (Score, StaffGroup, _base.Part)

    def makeNode(self, node):
        bookpart = ly.dom.BookPart(node)
        return bookpart


class Book(_base.Group):
    @staticmethod
    def title(_=_base.translate):
        return _("Book")

    def accepts(self):
        return (BookPart, Score, StaffGroup, _base.Part)

    def createWidgets(self, layout):
        self.bookOutputInfo = QLabel(wordWrap=True)
        self.bookOutputLabel = QLabel()
        self.bookOutput = widgets.lineedit.LineEdit()
        self.bookOutputFileName = QRadioButton()
        self.bookOutputSuffix = QRadioButton(checked=True)
        
        layout.addWidget(self.bookOutputInfo)
        grid = QGridLayout(spacing=0)
        grid.addWidget(self.bookOutputLabel, 0, 0)
        grid.addWidget(self.bookOutput, 0, 1, 1, 2)
        grid.addWidget(self.bookOutputFileName, 1, 1)
        grid.addWidget(self.bookOutputSuffix, 1, 2)
        layout.addLayout(grid)
    
    def translateWidgets(self):
        self.bookOutputInfo.setText(_(
            "<p>Here you can specify a filename or suffix (without extension) "
            "to set the names of generated output files for this book.</p>\n"
            "<p>If you choose \"Suffix\" the entered name will be appended "
            "to the document's file name; if you choose \"Filename\", just "
            "the entered name will be used.</p>"))
        self.bookOutputLabel.setText(_("Output Filename:"))
        self.bookOutputFileName.setText(_("Filename"))
        self.bookOutputSuffix.setText(_("Suffix"))

    def makeNode(self, node):
        book = ly.dom.Book(node)
        name = self.bookOutput.text().strip()
        if name:
            cmd = 'bookOutputName' if self.bookOutputFileName.isChecked() else 'bookOutputSuffix'
            ly.dom.Line(r'\{0} "{1}"'.format(cmd, name.replace('"', r'\"')), book)
        return book


register(
    lambda: _("Containers"),
    [
        StaffGroup,
        Score,
        BookPart,
        Book,
    ])

########NEW FILE########
__FILENAME__ = keyboard
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Keyboard part types.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QGridLayout, QLabel, QSpinBox

import ly.dom
import ly.util

from . import _base
from . import register


class KeyboardPart(_base.PianoStaffPart):
    pass


class Piano(KeyboardPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Piano")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Piano", "Pno.")
    
    midiInstrument = 'acoustic grand'


class Harpsichord(KeyboardPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Harpsichord")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Harpsichord", "Hs.")
    
    midiInstrument = 'harpsichord'


class Clavichord(KeyboardPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Clavichord")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Clavichord", "Clv.")
    
    midiInstrument = 'clav'


class Organ(KeyboardPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Organ")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Organ", "Org.")
    
    midiInstrument = 'church organ'

    def createWidgets(self, layout):
        super(Organ, self).createWidgets(layout)
        grid = layout.itemAt(layout.count() - 1).layout()
        self.pedalVoices = QSpinBox(minimum=0, maximum=4, value=1)
        self.pedalVoicesLabel = QLabel()
        self.pedalVoicesLabel.setBuddy(self.pedalVoices)
        grid.addWidget(self.pedalVoicesLabel, 2, 0)
        grid.addWidget(self.pedalVoices)
        
    def translateWidgets(self):
        super(Organ, self).translateWidgets()
        self.pedalVoicesLabel.setText(_("Pedal:"))
        self.pedalVoices.setToolTip(_(
            "Set to 0 to disable the pedal altogether."))
    
    def build(self, data, builder):
        super(Organ, self).build(data, builder)
        if self.pedalVoices.value():
            data.nodes.append(self.buildStaff(data, builder,
                'pedal', -1, self.pedalVoices.value(), clef="bass"))



class Celesta(KeyboardPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Celesta")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Celesta", "Cel.")
    
    midiInstrument = 'celesta'


register(
    lambda: _("Keyboard instruments"),
    [
        Piano,
        Harpsichord,
        Clavichord,
        Organ,
        Celesta,
    ])



########NEW FILE########
__FILENAME__ = percussion
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Percussion part types.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QCheckBox, QComboBox, QGridLayout, QHBoxLayout, QLabel, QSpinBox

import listmodel
import ly.dom

from . import _base
from . import register



class PitchedPercussionPart(_base.SingleVoicePart):
    """Base class for pitched percussion types."""
    
    
class Timpani(PitchedPercussionPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Timpani")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Timpani", "Tmp.")
        
    midiInstrument = 'timpani'
    clef = 'bass'
    octave = -1


class Xylophone(PitchedPercussionPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Xylophone")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Xylophone", "Xyl.")
        
    midiInstrument = 'xylophone'


class Marimba(_base.PianoStaffPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Marimba")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Marimba", "Mar.")
    
    midiInstrument = 'marimba'

    def createWidgets(self, layout):
        super(Marimba, self).createWidgets(layout)
        self.lowerVoices.setMinimum(0)
    
    def translateWidgets(self):
        self.upperVoicesLabel.setText(_("Upper staff:"))
        self.lowerVoicesLabel.setText(_("Lower staff:"))
        self.lowerVoices.setToolTip(_(
            "Set the number of voices to 0 to disable the second staff."))

    def build(self, data, builder):
        if self.lowerVoices.value():
            super(Marimba, self).build(data, builder)
        else:
            data.nodes.append(self.buildStaff(data, builder, None, 1))


class Vibraphone(Marimba):
    @staticmethod
    def title(_=_base.translate):
        return _("Vibraphone")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Vibraphone", "Vib.")
        
    midiInstrument = 'vibraphone'


class TubularBells(PitchedPercussionPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Tubular bells")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Tubular bells", "Tub.")
        
    midiInstrument = 'tubular bells'


class Glockenspiel(PitchedPercussionPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Glockenspiel")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Glockenspiel", "Gls.")
        
    midiInstrument = 'glockenspiel'


class Carillon(_base.PianoStaffPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Carillon")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Carillon", "Car.")
    
    midiInstrument = 'tubular bells' # anyone knows better?
    
    def translateWidgets(self):
        super(Carillon, self).translateWidgets()
        self.upperVoicesLabel.setText(_("Manual staff:"))
        self.lowerVoicesLabel.setText(_("Pedal staff:"))
    
    def build(self, data, builder):
        p = ly.dom.PianoStaff()
        builder.setInstrumentNamesFromPart(p, self, data)
        s = ly.dom.Sim(p)
        # add two staves, with a respective number of voices.
        self.buildStaff(data, builder, 'manual', 1, self.upperVoices.value(), s)
        self.buildStaff(data, builder, 'pedal', 0, self.lowerVoices.value(), s, "bass")
        data.nodes.append(p)


class Drums(_base.Part):
    @staticmethod
    def title(_=_base.translate):
        return _("Drums")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Drums", "Dr.")
        
    def createWidgets(self, layout):
        self.voicesLabel = QLabel()
        self.voices = QSpinBox(minimum=1, maximum=4, value=1)
        self.drumStyleLabel = QLabel()
        self.drumStyle = QComboBox()
        self.drumStyle.setModel(listmodel.ListModel(drumStyles, self.drumStyle, display=listmodel.translate))
        self.drumStems = QCheckBox()
        
        box = QHBoxLayout()
        box.addWidget(self.voicesLabel)
        box.addWidget(self.voices)
        layout.addLayout(box)
        box = QHBoxLayout()
        box.addWidget(self.drumStyleLabel)
        box.addWidget(self.drumStyle)
        layout.addLayout(box)
        layout.addWidget(self.drumStems)
        
    def translateWidgets(self):
        self.voicesLabel.setText(_("Voices:"))
        self.drumStyleLabel.setText(_("Style:"))
        self.drumStems.setText(_("Remove stems"))
        self.drumStems.setToolTip(_("Remove the stems from the drum notes."))
        self.drumStyle.model().update()
    
    def assignDrums(self, data, name = None):
        """Creates an empty name = \drummode assignment.

        Returns the assignment.
        
        """
        a = data.assign(name)
        s = ly.dom.DrumMode(a)
        ly.dom.Identifier(data.globalName, s)
        ly.dom.LineComment(_("Drums follow here."), s)
        ly.dom.BlankLine(s)
        return a

    def build(self, data, builder):
        p = ly.dom.DrumStaff()
        s = ly.dom.Simr(p)
        if self.voices.value() > 1:
            for i in range(1, self.voices.value() + 1):
                q = ly.dom.Seq(ly.dom.DrumVoice(parent=s))
                ly.dom.Text('\\voice' + ly.util.int2text(i), q)
                a = self.assignDrums(data, 'drum' + ly.util.int2text(i))
                ly.dom.Identifier(a.name, q)
        else:
            a = self.assignDrums(data, 'drum')
            ly.dom.Identifier(a.name, s)
        builder.setInstrumentNamesFromPart(p, self, data)
        i = self.drumStyle.currentIndex()
        if i > 0:
            v = ('drums', 'timbales', 'congas', 'bongos', 'percussion')[i]
            p.getWith()['drumStyleTable'] = ly.dom.Scheme(v + '-style')
            v = (5, 2, 2, 2, 1)[i]
            ly.dom.Line("\\override StaffSymbol #'line-count = #{0}".format(v), p.getWith())
        if self.drumStems.isChecked():
            ly.dom.Line("\\override Stem #'stencil = ##f", p.getWith())
            ly.dom.Line("\\override Stem #'length = #3  % " + _("keep some distance."),
                p.getWith())
        data.nodes.append(p)


drumStyles = (
    lambda: _("Drums (5 lines, default)"),
    lambda: _("Timbales-style (2 lines)"),
    lambda: _("Congas-style (2 lines)"),
    lambda: _("Bongos-style (2 lines)"),
    lambda: _("Percussion-style (1 line)"),
)
    


register(
    lambda: _("Percussion"),
    [
        Timpani,
        Xylophone,
        Marimba,
        Vibraphone,
        TubularBells,
        Glockenspiel,
        Carillon,
        Drums,
    ])

########NEW FILE########
__FILENAME__ = plucked_strings
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Plucked string part types.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import (
    QCheckBox, QComboBox, QCompleter, QGridLayout, QHBoxLayout, QLabel,
    QLineEdit, QSpinBox,
)

import listmodel
import completionmodel
import ly.dom

from . import _base
from . import register


class TablaturePart(_base.Part):
    """Base class for tablature instrument part types."""
    
    octave = 0
    clef = None
    transposition = None
    tunings = ()    # may contain a list of tunings.
    tabFormat = ''  # can contain a tablatureFormat value.
    
    def createWidgets(self, layout):
        self.staffTypeLabel = QLabel()
        self.staffType = QComboBox()
        self.staffTypeLabel.setBuddy(self.staffType)
        self.staffType.setModel(listmodel.ListModel(tablatureStaffTypes,
            self.staffType, display=listmodel.translate))
        box = QHBoxLayout()
        layout.addLayout(box)
        box.addWidget(self.staffTypeLabel)
        box.addWidget(self.staffType)
        if self.tunings:
            self.createTuningWidgets(layout)
            self.staffType.activated.connect(self.slotTabEnable)
            self.slotTabEnable(0)
        
    def createTuningWidgets(self, layout):
        self.tuningLabel = QLabel()
        self.tuning = QComboBox()
        self.tuningLabel.setBuddy(self.tuning)
        tunings = [('', lambda: _("Default"))]
        tunings.extend(self.tunings)
        tunings.append(('', lambda: _("Custom tuning")))
        self.tuning.setModel(listmodel.ListModel(tunings, self.tuning,
            display=listmodel.translate_index(1)))
        self.tuning.setCurrentIndex(1)
        self.customTuning = QLineEdit(enabled=False)
        completionmodel.complete(self.customTuning,
            "scorewiz/completion/plucked_strings/custom_tuning")
        self.tuning.currentIndexChanged.connect(self.slotCustomTuningEnable)
        box = QHBoxLayout()
        layout.addLayout(box)
        box.addWidget(self.tuningLabel)
        box.addWidget(self.tuning)
        layout.addWidget(self.customTuning)
    
    def translateWidgets(self):
        self.staffTypeLabel.setText(_("Staff type:"))
        self.staffType.model().update()
        if self.tunings:
            self.translateTuningWidgets()
    
    def translateTuningWidgets(self):
        self.tuningLabel.setText(_("Tuning:"))
        self.customTuning.setToolTip('<qt>' + _(
            "Select custom tuning in the combobox and "
            "enter a custom tuning here, e.g. <code>e, a d g b e'</code>. "
            "Use absolute note names in the same language as you want to use "
            "in your document (by default: \"nederlands\")."))
        try:
            self.customTuning.setPlaceholderText(_("Custom tuning..."))
        except AttributeError:
            pass # only in Qt 4.7+
        self.tuning.model().update()
    
    def slotTabEnable(self, enable):
        """Called when the user changes the staff type.
        
        Non-zero if the user wants a TabStaff.
        
        """
        self.tuning.setEnabled(bool(enable))
        if enable:
            self.slotCustomTuningEnable(self.tuning.currentIndex())
        else:
            self.customTuning.setEnabled(False)
    
    def slotCustomTuningEnable(self, index):
        self.customTuning.setEnabled(index > len(self.tunings))
    
    def voiceCount(self):
        """Returns the number of voices.
        
        Inherit to make this user-settable.
        
        """
        return 1
        
    def build(self, data, builder):
        # First make assignments for the voices we want to create
        numVoices = self.voiceCount()
        if numVoices == 1:
            voices = (ly.util.mkid(data.name()),)
        elif numVoices == 2:
            order = 1, 2
            voices = 'upper', 'lower'
        elif numVoices == 3:
            order = 1, 3, 2
            voices = 'upper', 'middle', 'lower'
        else:
            order = 1, 2, 3, 4
            voices = [ly.util.mkid(data.name(), "voice") + ly.util.int2text(i) for i in order]
        
        assignments = [data.assignMusic(name, self.octave, self.transposition)
                       for name in voices]
        
        staffType = self.staffType.currentIndex()
        if staffType in (0, 2):
            # create a normal staff
            staff = ly.dom.Staff()
            seq = ly.dom.Seqr(staff)
            if self.clef:
                ly.dom.Clef(self.clef, seq)
            mus = ly.dom.Simr(seq)
            for a in assignments[:-1]:
                ly.dom.Identifier(a.name, mus)
                ly.dom.VoiceSeparator(mus)
            ly.dom.Identifier(assignments[-1].name, mus)
            builder.setMidiInstrument(staff, self.midiInstrument)
        
        if staffType in (1, 2):
            # create a tab staff
            tabstaff = ly.dom.TabStaff()
            if self.tabFormat:
                tabstaff.getWith()['tablatureFormat'] = ly.dom.Scheme(self.tabFormat)
            self.setTunings(tabstaff)
            sim = ly.dom.Simr(tabstaff)
            if numVoices == 1:
                ly.dom.Identifier(assignments[0].name, sim)
            else:
                for num, a in zip(order, assignments):
                    s = ly.dom.Seq(ly.dom.TabVoice(parent=sim))
                    ly.dom.Text('\\voice' + ly.util.int2text(num), s)
                    ly.dom.Identifier(a.name, s)
        
        if staffType == 0:
            # only a normal staff
            p = staff
        elif staffType == 1:
            # only a TabStaff
            builder.setMidiInstrument(tabstaff, self.midiInstrument)
            p = tabstaff
        else:
            # both TabStaff and normal staff
            p = ly.dom.StaffGroup()
            s = ly.dom.Sim(p)
            s.append(staff)
            s.append(tabstaff)
        
        builder.setInstrumentNamesFromPart(p, self, data)
        data.nodes.append(p)

    def setTunings(self, tab):
        if self.tunings:
            i = self.tuning.currentIndex()
            if i == 0:
                return
            elif i > len(self.tunings):
                value = ly.dom.Text("\\stringTuning <{0}>".format(self.customTuning.text()))
            else:
                tuning = self.tunings[self.tuning.currentIndex() - 1][0]
                value = ly.dom.Scheme(tuning)
            tab.getWith()['stringTunings'] = value


tablatureStaffTypes = (
    lambda: _("Normal staff"),
    lambda: _("Tablature"),
    #L10N: Both a Normal and a Tablature staff
    lambda: _("Both"),
)


class Mandolin(TablaturePart):
    @staticmethod
    def title(_=_base.translate):
        return _("Mandolin")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Mandolin", "Mdl.")
    
    midiInstrument = 'acoustic guitar (steel)'
    tunings = (
        ('mandolin-tuning', lambda: _("Mandolin tuning")),
    )
    

class Ukulele(TablaturePart):
    @staticmethod
    def title(_=_base.translate):
        return _("Ukulele")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Ukulele", "Uk.")
    
    midiInstrument = 'acoustic guitar (steel)'
    tunings = (
        ('ukulele-tuning', lambda: _("Ukulele tuning")),
        ('ukulele-d-tuning', lambda: _("Ukulele D-tuning")),
        ('tenor-ukulele-tuning', lambda: _("Tenor Ukulele tuning")),
        ('baritone-ukulele-tuning', lambda: _("Baritone Ukulele tuning")),
    )


class Banjo(TablaturePart):
    @staticmethod
    def title(_=_base.translate):
        return _("Banjo")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Banjo", "Bj.")
    
    midiInstrument = 'banjo'
    tabFormat = 'fret-number-tablature-format-banjo'
    tunings = (
        ('banjo-open-g-tuning', lambda: _("Open G-tuning (aDGBD)")),
        ('banjo-c-tuning', lambda: _("C-tuning (gCGBD)")),
        ('banjo-modal-tuning', lambda: _("Modal tuning (gDGCD)")),
        ('banjo-open-d-tuning', lambda: _("Open D-tuning (aDF#AD)")),
        ('banjo-open-dm-tuning', lambda: _("Open Dm-tuning (aDFAD)")),
    )
    
    def createTuningWidgets(self, layout):
        super(Banjo, self).createTuningWidgets(layout)
        self.fourStrings = QCheckBox()
        layout.addWidget(self.fourStrings)
        
    def translateTuningWidgets(self):
        super(Banjo, self).translateTuningWidgets()
        self.fourStrings.setText(_("Four strings (instead of five)"))
    
    def setTunings(self, tab):
        i = self.tuning.currentIndex()
        if i > len(self.tunings) or not self.fourStrings.isChecked():
            super(Banjo, self).setTunings(tab)
        else:
            tab.getWith()['stringTunings'] = ly.dom.Scheme(
                '(four-string-banjo {0})'.format(
                    self.tunings[i][0]))

    def slotCustomTuningEnable(self, index):
        super(Banjo, self).slotCustomTuningEnable(index)
        self.fourStrings.setEnabled(index <= len(self.tunings))
    

class ClassicalGuitar(TablaturePart):
    @staticmethod
    def title(_=_base.translate):
        return _("Classical guitar")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Classical guitar", "Gt.")
    
    midiInstrument = 'acoustic guitar (nylon)'
    clef = "treble_8"
    tunings = (
        ('guitar-tuning', lambda: _("Guitar tuning")),
        ('guitar-seven-string-tuning', lambda: _("Guitar seven-string tuning")),
        ('guitar-drop-d-tuning', lambda: _("Guitar drop-D tuning")),
        ('guitar-drop-c-tuning', lambda: _("Guitar drop-C tuning")),
        ('guitar-open-g-tuning', lambda: _("Open G-tuning")),
        ('guitar-open-d-tuning', lambda: _("Guitar open D tuning")),
        ('guitar-dadgad-tuning', lambda: _("Guitar d-a-d-g-a-d tuning")),
        ('guitar-lute-tuning', lambda: _("Lute tuning")),
        ('guitar-asus4-tuning', lambda: _("Guitar A-sus4 tuning")),
    )
    def createWidgets(self, layout):
        super(ClassicalGuitar, self).createWidgets(layout)
        self.voicesLabel = QLabel()
        self.voices = QSpinBox(minimum=1, maximum=4, value=1)
        box = QHBoxLayout()
        box.addWidget(self.voicesLabel)
        box.addWidget(self.voices)
        layout.addLayout(box)
        
    def translateWidgets(self):
        super(ClassicalGuitar, self).translateWidgets()
        self.voicesLabel.setText(_("Voices:"))
    
    def voiceCount(self):
        return self.voices.value()


class JazzGuitar(ClassicalGuitar):
    @staticmethod
    def title(_=_base.translate):
        return _("Jazz guitar")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Jazz guitar", "J.Gt.")
    
    midiInstrument = 'electric guitar (jazz)'


class Bass(TablaturePart):
    @staticmethod
    def title(_=_base.translate):
        return _("Bass")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Bass", "Bs.") #FIXME

    midiInstrument = 'acoustic bass'
    clef = 'bass_8'
    octave = -2
    tunings = (
        ('bass-tuning', lambda: _("Bass tuning")),
        ('bass-four-string-tuning', lambda: _("Four-string bass tuning")),
        ('bass-drop-d-tuning', lambda: _("Bass drop-D tuning")),
        ('bass-five-string-tuning', lambda: _("Five-string bass tuning")),
        ('bass-six-string-tuning', lambda: _("Six-string bass tuning")),
    )


class ElectricBass(Bass):
    @staticmethod
    def title(_=_base.translate):
        return _("Electric bass")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Electric bass", "E.Bs.")

    midiInstrument = 'electric bass (finger)'


class Harp(_base.PianoStaffPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Harp")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Harp", "Hp.")

    midiInstrument = 'orchestral harp'

    def translateWidgets(self):
        super(Harp, self).translateWidgets()
        self.upperVoicesLabel.setText(_("Upper staff:"))
        self.lowerVoicesLabel.setText(_("Lower staff:"))
    
    def build(self, data, builder):
        p = ly.dom.PianoStaff()
        builder.setInstrumentNamesFromPart(p, self, data)
        s = ly.dom.Sim(p)
        # add two staves, with a respective number of voices.
        self.buildStaff(data, builder, 'upper', 1, self.upperVoices.value(), s)
        self.buildStaff(data, builder, 'lower', 0, self.lowerVoices.value(), s, "bass")
        data.nodes.append(p)

        



register(
    lambda: _("Plucked strings"),
    [
        Mandolin,
        Banjo,
        Ukulele,
        ClassicalGuitar,
        JazzGuitar,
        Bass,
        ElectricBass,
        Harp,
    ])


########NEW FILE########
__FILENAME__ = special
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Some special part types.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QCheckBox

import ly.dom

from . import _base
from . import register


class Chords(_base.ChordNames, _base.Part):
    @staticmethod
    def title(_=_base.translate):
        return _("Chord names")
    

class BassFigures(_base.Part):
    @staticmethod
    def title(_=_base.translate):
        return _("Figured Bass")

    def createWidgets(self, layout):
        self.extenderLines = QCheckBox()
        layout.addWidget(self.extenderLines)
    
    def translateWidgets(self):
        self.extenderLines.setText(_("Use extender lines"))

    def build(self, data, builder):
        a = data.assign('figBass')
        s = ly.dom.FigureMode(a)
        p = ly.dom.FiguredBass()
        ly.dom.Identifier(a.name, p)
        ly.dom.Identifier(data.globalName, s)
        ly.dom.LineComment(_("Figures follow here."), s)
        ly.dom.BlankLine(s)
        if self.extenderLines.isChecked():
            p.getWith()['useBassFigureExtenders'] = ly.dom.Scheme('#t')
        data.nodes.append(p)


class Staff(_base.Part):
    @staticmethod
    def title(_=_base.translate):
        return _("Staff")




register(
    lambda: _("Special"),
    [
        Chords,
        BassFigures,
        #Staff,
    ])

########NEW FILE########
__FILENAME__ = strings
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
String part types.
"""

from __future__ import unicode_literals

import ly.dom

from . import _base
from . import register


class StringPart(_base.SingleVoicePart):
    """Base class for string part types."""


class Violin(StringPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Violin")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Violin", "Vl.")

    midiInstrument = 'violin'


class Viola(StringPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Viola")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Viola", "Vla.")
    
    midiInstrument = 'viola'
    clef = 'alto'
    octave = 0


class Cello(StringPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Cello")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Cello", "Cl.")
    
    midiInstrument = 'cello'
    clef = 'bass'
    octave = -1


class Contrabass(StringPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Contrabass")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Contrabass", "Cb.")
    
    midiInstrument = 'contrabass'
    clef = 'bass'
    octave = -1


class BassoContinuo(Cello):
    @staticmethod
    def title(_=_base.translate):
        return _("Basso Continuo")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Basso Continuo", "B.c.")
    
    def build(self, data, builder):
        super(BassoContinuo, self).build(data, builder)
        data.assignments[0].name.name = 'bcMusic'
        a = data.assign('bcFigures')
        b = ly.dom.FigureMode(a)
        ly.dom.Identifier(data.globalName, b)
        ly.dom.Line("\\override Staff.BassFigureAlignmentPositioning "
                    "#'direction = #DOWN", b)
        ly.dom.LineComment(_("Figures follow here."), b)
        ly.dom.BlankLine(b)
        s = ly.dom.Sim(data.nodes[0][-1])
        s.append(data.nodes[0][-1][-2])
        ly.dom.Identifier(a.name, s)
    

register(
    lambda: _("Strings"),
    [
        Violin,
        Viola,
        Cello,
        Contrabass,
        BassoContinuo,
    ])





########NEW FILE########
__FILENAME__ = vocal
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Vocal part types.
"""

from __future__ import unicode_literals

import collections
import itertools
import re

from PyQt4.QtCore import QRegExp, Qt
from PyQt4.QtGui import (
    QCheckBox, QComboBox, QGroupBox, QHBoxLayout, QLabel, QRegExpValidator,
    QSpinBox, QVBoxLayout)

import listmodel
import ly.dom

from . import _base
from . import register


class VocalPart(_base.Part):
    """Base class for vocal parts."""
    midiInstrument = 'choir aahs'

    def createWidgets(self, layout):
        self.createStanzaWidget(layout)
        self.createAmbitusWidget(layout)
        
    def translateWidgets(self):
        self.translateStanzaWidget()
        self.translateAmbitusWidget()
        
    def createStanzaWidget(self, layout):
        self.stanzas = QSpinBox(minimum=1, maximum=99, value=1)
        self.stanzasLabel = QLabel()
        self.stanzasLabel.setBuddy(self.stanzas)
        box = QHBoxLayout(spacing=0)
        box.addWidget(self.stanzasLabel)
        box.addWidget(self.stanzas)
        layout.addLayout(box)
        
    def translateStanzaWidget(self):
        self.stanzasLabel.setText(_("Stanzas:"))
        self.stanzas.setToolTip(_("The number of stanzas."))
    
    def createAmbitusWidget(self, layout):
        self.ambitus = QCheckBox()
        layout.addWidget(self.ambitus)
        
    def translateAmbitusWidget(self):
        self.ambitus.setText(_("Ambitus"))
        self.ambitus.setToolTip(_(
            "Show the pitch range of the voice at the beginning of the staff."))
    
    def assignLyrics(self, data, name, verse=0):
        """Creates an empty assignment for lyrics.
        
        Returns the assignment.
        
        """
        l = ly.dom.LyricMode()
        if verse:
            name = name + ly.util.int2text(verse)
            ly.dom.Line('\\set stanza = "{0}."'.format(verse), l)
        a = data.assign(name)
        a.append(l)
        ly.dom.LineComment(_("Lyrics follow here."), l)
        ly.dom.BlankLine(l)
        return a
    
    def addStanzas(self, data, node):
        """Add stanzas to the given (Voice) node.
        
        The stanzas (as configured in self.stanzas.value()) are added
        using \\addlyrics.
        
        """
        if self.stanzas.value() == 1:
            ly.dom.Identifier(self.assignLyrics(data, 'verse').name, ly.dom.AddLyrics(node))
        else:
            for i in range(self.stanzas.value()):
                ly.dom.Identifier(self.assignLyrics(data, 'verse', i + 1).name, ly.dom.AddLyrics(node))


class VocalSoloPart(VocalPart, _base.SingleVoicePart):
    """Base class for vocal solo parts."""
    octave = 1
    clef = None
    
    def build(self, data, builder):
        super(VocalSoloPart, self).build(data, builder)
        stub = data.assignments[-1][0][-1]
        stub.insert(1, ly.dom.Line('\\dynamicUp')) # just after the \global
        staff = data.nodes[-1]
        staff[-1].may_remove_brackets = False
        self.addStanzas(data, staff)
        if self.ambitus.isChecked():
            ly.dom.Line('\\consists "Ambitus_engraver"', staff.getWith())


class SopranoVoice(VocalSoloPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Soprano")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Soprano", "S.")


class MezzoSopranoVoice(VocalSoloPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Mezzo-soprano")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Mezzo-soprano", "Ms.")


class AltoVoice(VocalSoloPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Alto")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Alto", "A.")
    
    octave = 0


class TenorVoice(VocalSoloPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Tenor")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Tenor", "T.")

    octave = 0
    clef = 'treble_8'


class BassVoice(VocalSoloPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Bass")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Bass", "B.")

    octave = -1
    clef = 'bass'


class LeadSheet(VocalPart, _base.ChordNames):
    @staticmethod
    def title(_=_base.translate):
        return _("Lead sheet")
    
    def createWidgets(self, layout):
        self.label = QLabel(wordWrap=True)
        self.chords = QGroupBox(checkable=True, checked=True)
        layout.addWidget(self.label)
        layout.addWidget(self.chords)
        box = QVBoxLayout()
        self.chords.setLayout(box)
        _base.ChordNames.createWidgets(self, box)
        self.accomp = QCheckBox()
        layout.addWidget(self.accomp)
        VocalPart.createWidgets(self, layout)
    
    def translateWidgets(self):
        VocalPart.translateWidgets(self)
        _base.ChordNames.translateWidgets(self)
        self.label.setText('<i>{0}</i>'.format(_(
            "The Lead Sheet provides a staff with chord names above "
            "and lyrics below it. A second staff is optional.")))
        self.chords.setTitle(_("Chord names"))
        self.accomp.setText(_("Add accompaniment staff"))
        self.accomp.setToolTip(_(
            "Adds an accompaniment staff and also puts an accompaniment "
            "voice in the upper staff."))

    def build(self, data, builder):
        """Create chord names, song and lyrics.
        
        Optionally a second staff with a piano accompaniment.
        
        """
        if self.chords.isChecked():
            _base.ChordNames.build(self, data, builder)
        if self.accomp.isChecked():
            p = ly.dom.ChoirStaff()
            #TODO: instrument names ?
            #TODO: different midi instrument for voice and accompaniment ?
            s = ly.dom.Sim(p)
            mel = ly.dom.Sim(ly.dom.Staff(parent=s))
            v1 = ly.dom.Voice(parent=mel)
            s1 = ly.dom.Seq(v1)
            ly.dom.Text('\\voiceOne', s1)
            a = data.assignMusic('melody', 1)
            ly.dom.Identifier(a.name, s1)
            s2 = ly.dom.Seq(ly.dom.Voice(parent=mel))
            ly.dom.Text('\\voiceTwo', s2)
            a = data.assignMusic('accRight', 0)
            ly.dom.Identifier(a.name, s2)
            acc = ly.dom.Seq(ly.dom.Staff(parent=s))
            ly.dom.Clef('bass', acc)
            a = data.assignMusic('accLeft', -1)
            ly.dom.Identifier(a.name, acc)
            if self.ambitus.isChecked():
                # We can't use \addlyrics when the voice has a \with {}
                # section, because it creates a nested Voice context.
                # So if the ambitus engraver should be added to the Voice,
                # we don't use \addlyrics but create a new Lyrics context.
                # So in that case we don't use addStanzas, but insert the
                # Lyrics contexts manually inside our ChoirStaff.
                v1.cid = ly.dom.Reference('melody')
                ly.dom.Line('\\consists "Ambitus_engraver"', v1.getWith())
                count = self.stanzas.value() # number of stanzas
                if count == 1:
                    l = ly.dom.Lyrics()
                    s.insert_before(acc.parent(), l)
                    a = self.assignLyrics(data, 'verse')
                    ly.dom.Identifier(a.name, ly.dom.LyricsTo(v1.cid, l))
                else:
                    for i in range(count):
                        l = ly.dom.Lyrics()
                        s.insert_before(acc.parent(), l)
                        a = self.assignLyrics(data, 'verse', i + 1)
                        ly.dom.Identifier(a.name, ly.dom.LyricsTo(v1.cid, l))
            else:
                self.addStanzas(data, v1)
        else:
            a = data.assignMusic('melody', 1)
            p = ly.dom.Staff()
            ly.dom.Identifier(a.name, ly.dom.Seq(p))
            self.addStanzas(data, p)
            if self.ambitus.isChecked():
                ly.dom.Line('\\consists "Ambitus_engraver"', p.getWith())
        data.nodes.append(p)


class Choir(VocalPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Choir")

    def createWidgets(self, layout):
        self.label = QLabel(wordWrap=True)
        self.voicingLabel = QLabel()
        self.voicing = QComboBox(editable=True)
        self.voicingLabel.setBuddy(self.voicing)
        self.voicing.setCompleter(None)
        self.voicing.setValidator(QRegExpValidator(
            QRegExp("[SATB]+(-[SATB]+)*", Qt.CaseInsensitive), self.voicing))
        self.voicing.addItems((
            'SA-TB', 'S-A-T-B',
            'SA', 'S-A', 'SS-A', 'S-S-A',
            'TB', 'T-B', 'TT-B', 'T-T-B',
            'SS-A-T-B', 'S-A-TT-B', 'SS-A-TT-B',
            'S-S-A-T-T-B', 'S-S-A-A-T-T-B-B',
            ))
        self.lyricsLabel = QLabel()
        self.lyrics = QComboBox()
        self.lyricsLabel.setBuddy(self.lyrics)
        self.lyrics.setModel(listmodel.ListModel(lyricStyles, self.lyrics,
            display=listmodel.translate_index(0),
            tooltip=listmodel.translate_index(1)))
        self.lyrics.setCurrentIndex(0)
        self.pianoReduction = QCheckBox()
        self.rehearsalMidi = QCheckBox()
        
        layout.addWidget(self.label)
        box = QHBoxLayout()
        layout.addLayout(box)
        box.addWidget(self.voicingLabel)
        box.addWidget(self.voicing)
        self.createStanzaWidget(layout)
        box = QHBoxLayout()
        layout.addLayout(box)
        box.addWidget(self.lyricsLabel)
        box.addWidget(self.lyrics)
        self.createAmbitusWidget(layout)
        layout.addWidget(self.pianoReduction)
        layout.addWidget(self.rehearsalMidi)
    
    def translateWidgets(self):
        self.translateStanzaWidget()
        self.translateAmbitusWidget()
        self.lyrics.model().update()
        self.label.setText('<p>{0} <i>({1})</i></p>'.format(
            _("Please select the voices for the choir. "
              "Use the letters S, A, T, or B. A hyphen denotes a new staff."),
            _("Hint: For a double choir you can use two choir parts.")))
        self.voicingLabel.setText(_("Voicing:"))
        self.lyricsLabel.setText(_("Lyrics:"))
        self.pianoReduction.setText(_("Piano reduction"))
        self.pianoReduction.setToolTip(_(
            "Adds an automatically generated piano reduction."))
        self.rehearsalMidi.setText(_("Rehearsal MIDI files"))
        self.rehearsalMidi.setToolTip(_(
            "Creates a rehearsal MIDI file for every voice, "
            "even if no MIDI output is generated for the main score."))

    def build(self, data, builder):
        # normalize voicing
        staves = self.voicing.currentText().upper()
        # remove unwanted characters
        staves = re.sub(r'[^SATB-]+', '', staves)
        # remove double hyphens, and from begin and end
        staves = re.sub('-+', '-', staves).strip('-')
        if not staves:
            return
        
        splitStaves = staves.split('-')
        numStaves = len(splitStaves)
        staffCIDs = collections.defaultdict(int)    # number same-name staff Context-IDs
        voiceCounter = collections.defaultdict(int) # dict to number same voice types
        maxNumVoices = max(map(len, splitStaves))   # largest number of voices
        numStanzas = self.stanzas.value()
        lyrics = collections.defaultdict(list)      # lyrics grouped by stanza number
        pianoReduction = collections.defaultdict(list)
        rehearsalMidis = []
        
        p = ly.dom.ChoirStaff()
        choir = ly.dom.Sim(p)
        data.nodes.append(p)
        
        # print main instrumentName if there are more choirs, and we
        # have more than one staff.
        if numStaves > 1 and data.num:
            builder.setInstrumentNames(p,
                builder.instrumentName(lambda _: _("Choir"), data.num),
                builder.instrumentName(lambda _: _("abbreviation for Choir", "Ch."), data.num))
        
        # get the preferred way of adding lyrics
        lyrAllSame, lyrEachSame, lyrEachDiff, lyrSpread = (
            self.lyrics.currentIndex() == i for i in range(4))
        lyrEach = lyrEachSame or lyrEachDiff
        
        # stanzas to print (0 = don't print stanza number):
        if numStanzas == 1:
            allStanzas = [0]
        else:
            allStanzas = list(range(1, numStanzas + 1))
        
        # Which stanzas to print where:
        if lyrSpread and numStanzas > 1 and numStaves > 2:
            spaces = numStaves - 1
            count, rest = divmod(max(numStanzas, spaces), spaces)
            stanzaSource = itertools.cycle(allStanzas)
            stanzaGroups = (itertools.islice(stanzaSource, num)
                            for num in itertools.chain(
                                itertools.repeat(count + 1, rest),
                                itertools.repeat(count, numStaves - rest)))
        else:
            stanzaGroups = itertools.repeat(allStanzas, numStaves)
        
        # a function to set staff affinity (in LilyPond 2.13.4 and above):
        if builder.lyVersion >= (2, 13, 4):
            def setStaffAffinity(context, affinity):
                ly.dom.Line("\\override VerticalAxisGroup "
                     "#'staff-affinity = #" + affinity, context.getWith())
        else:
            def setStaffAffinity(lyricsContext, affinity):
                pass
        
        # a function to make a column markup:
        if builder.lyVersion >= (2, 11, 57):
            columnCommand = 'center-column'
        else:
            columnCommand = 'center-align'
        def makeColumnMarkup(names):
            node = ly.dom.Markup()
            column = ly.dom.MarkupEnclosed(columnCommand, node)
            for name in names:
                ly.dom.QuotedString(name, column)
            return node
        
        stavesLeft = numStaves
        for staff, stanzas in zip(splitStaves, stanzaGroups):
            # are we in the last staff?
            stavesLeft -= 1
            # the number of voices in this staff
            numVoices = len(staff)
            # sort the letters in order SATB
            staff = ''.join(i * staff.count(i) for i in 'SATB')
            # Create the staff for the voices
            s = ly.dom.Staff(parent=choir)
            builder.setMidiInstrument(s, self.midiInstrument)
            
            # Build a list of the voices in this staff.
            # Each entry is a tuple(name, num).
            # name is one of 'S', 'A', 'T', or 'B'
            # num is an integer: 0 when a voice occurs only once, or >= 1 when
            # there are more voices of the same type (e.g. Soprano I and II)
            voices = []
            for voice in staff:
                if staves.count(voice) > 1:
                    voiceCounter[voice] += 1
                voices.append((voice, voiceCounter[voice]))
            
            # Add the instrument names to the staff:
            if numVoices == 1:
                voice, num = voices[0]
                longName = builder.instrumentName(voice2Voice[voice].title, num)
                shortName = builder.instrumentName(voice2Voice[voice].short, num)
                builder.setInstrumentNames(s, longName, shortName)
            else:
                # stack instrument names (long and short) in a markup column.
                # long names
                longNames = makeColumnMarkup(
                    builder.instrumentName(voice2Voice[voice].title, num) for voice, num in voices)
                shortNames = makeColumnMarkup(
                    builder.instrumentName(voice2Voice[voice].short, num) for voice, num in voices)
                builder.setInstrumentNames(s, longNames, shortNames)
            
            # Make the { } or << >> holder for this staff's children.
            # If *all* staves have only one voice, addlyrics is used.
            # In that case, don't remove the braces.
            staffMusic = (ly.dom.Seq if lyrEach and maxNumVoices == 1 else
                          ly.dom.Seqr if numVoices == 1 else ly.dom.Simr)(s)
            
            # Set the clef for this staff:
            if 'B' in staff:
                ly.dom.Clef('bass', staffMusic)
            elif 'T' in staff:
                ly.dom.Clef('treble_8', staffMusic)

            # Determine voice order (\voiceOne, \voiceTwo etc.)
            if numVoices == 1:
                order = (0,)
            elif numVoices == 2:
                order = 1, 2
            elif staff in ('SSA', 'TTB'):
                order = 1, 3, 2
            elif staff in ('SAA', 'TBB'):
                order = 1, 2, 4
            elif staff in ('SSAA', 'TTBB'):
                order = 1, 3, 2, 4
            else:
                order = range(1, numVoices + 1)
            
            # What name would the staff get if we need to refer to it?
            # If a name (like 's' or 'sa') is already in use in this part,
            # just add a number ('ss2' or 'sa2', etc.)
            staffCIDs[staff] += 1
            cid = ly.dom.Reference(staff.lower() +
                str(staffCIDs[staff] if staffCIDs[staff] > 1 else ""))
            
            # Create voices and their lyrics:
            for (voice, num), voiceNum in zip(voices, order):
                name = voice2id[voice]
                if num:
                    name += ly.util.int2text(num)
                a = data.assignMusic(name, voice2Voice[voice].octave)
                lyrName = name + 'Verse' if lyrEachDiff else 'verse'
            
                # Use \addlyrics if all staves have exactly one voice.
                if lyrEach and maxNumVoices == 1:
                    for verse in stanzas:
                        lyrics[verse].append((ly.dom.AddLyrics(s), lyrName))
                    ly.dom.Identifier(a.name, staffMusic)
                else:
                    voiceName = voice2id[voice] + str(num or '')
                    v = ly.dom.Voice(voiceName, parent=staffMusic)
                    voiceMusic = ly.dom.Seqr(v)
                    if voiceNum:
                        ly.dom.Text('\\voice' + ly.util.int2text(voiceNum), voiceMusic)
                    ly.dom.Identifier(a.name, voiceMusic)
                    
                    if stanzas and (lyrEach or (voiceNum <= 1 and
                                    (stavesLeft or numStaves == 1))):
                        # Create the lyrics. If they should be above the staff,
                        # give the staff a suitable name, and use alignAbove-
                        # Context to align the Lyrics above the staff.
                        above = voiceNum & 1 if lyrEach else False
                        if above and s.cid is None:
                            s.cid = cid

                        for verse in stanzas:
                            l = ly.dom.Lyrics(parent=choir)
                            if above:
                                l.getWith()['alignAboveContext'] = cid
                                setStaffAffinity(l, "DOWN")
                            elif not lyrEach and stavesLeft:
                                setStaffAffinity(l, "CENTER")
                            lyrics[verse].append((ly.dom.LyricsTo(voiceName, l), lyrName))

                # Add ambitus:
                if self.ambitus.isChecked():
                    ambitusContext = (s if numVoices == 1 else v).getWith()
                    ly.dom.Line('\\consists "Ambitus_engraver"', ambitusContext)
                    if voiceNum > 1:
                        ly.dom.Line("\\override Ambitus #'X-offset = #{0}".format(
                                 (voiceNum - 1) * 2.0), ambitusContext)
            
                pianoReduction[voice].append(a.name)
                rehearsalMidis.append((voice, num, a.name, lyrName))
            
        # Assign the lyrics, so their definitions come after the note defs.
        # (These refs are used again below in the midi rehearsal routine.)
        refs = {}
        for verse in allStanzas:
            for node, name in lyrics[verse]:
                if (name, verse) not in refs:
                    refs[(name, verse)] = self.assignLyrics(data, name, verse).name
                ly.dom.Identifier(refs[(name, verse)], node)

        # Create the piano reduction if desired
        if self.pianoReduction.isChecked():
            a = data.assign('pianoReduction')
            data.nodes.append(ly.dom.Identifier(a.name))
            piano = ly.dom.PianoStaff(parent=a)
            
            sim = ly.dom.Sim(piano)
            rightStaff = ly.dom.Staff(parent=sim)
            leftStaff = ly.dom.Staff(parent=sim)
            right = ly.dom.Seq(rightStaff)
            left = ly.dom.Seq(leftStaff)
            
            # Determine the ordering of voices in the staves
            upper = pianoReduction['S'] + pianoReduction['A']
            lower = pianoReduction['T'] + pianoReduction['B']
            
            preferUpper = 1
            if not upper:
                # Male choir
                upper = pianoReduction['T']
                lower = pianoReduction['B']
                ly.dom.Clef("treble_8", right)
                ly.dom.Clef("bass", left)
                preferUpper = 0
            elif not lower:
                # Female choir
                upper = pianoReduction['S']
                lower = pianoReduction['A']
            else:
                ly.dom.Clef("bass", left)

            # Otherwise accidentals can be confusing
            ly.dom.Line("#(set-accidental-style 'piano)", right)
            ly.dom.Line("#(set-accidental-style 'piano)", left)
            
            # Move voices if unevenly spread
            if abs(len(upper) - len(lower)) > 1:
                voices = upper + lower
                half = (len(voices) + preferUpper) / 2
                upper = voices[:half]
                lower = voices[half:]
            
            for staff, voices in (ly.dom.Simr(right), upper), (ly.dom.Simr(left), lower):
                if voices:
                    for v in voices[:-1]:
                        ly.dom.Identifier(v, staff)
                        ly.dom.VoiceSeparator(staff).after = 1
                    ly.dom.Identifier(voices[-1], staff)

            # Make the piano part somewhat smaller
            ly.dom.Line("fontSize = #-1", piano.getWith())
            ly.dom.Line("\\override StaffSymbol #'staff-space = #(magstep -1)",
                piano.getWith())
            
            # Nice to add Mark engravers
            ly.dom.Line('\\consists "Mark_engraver"', rightStaff.getWith())
            ly.dom.Line('\\consists "Metronome_mark_engraver"', rightStaff.getWith())
            
            # Keep piano reduction out of the MIDI output
            if builder.midi:
                ly.dom.Line('\\remove "Staff_performer"', rightStaff.getWith())
                ly.dom.Line('\\remove "Staff_performer"', leftStaff.getWith())
        
        # Create MIDI files if desired
        if self.rehearsalMidi.isChecked():
            a = data.assign('rehearsalMidi')
            rehearsalMidi = a.name
            
            func = ly.dom.SchemeList(a)
            func.pre = '#\n(' # hack
            ly.dom.Text('define-music-function', func)
            ly.dom.Line('(parser location name midiInstrument lyrics) '
                 '(string? string? ly:music?)', func)
            choir = ly.dom.Sim(ly.dom.Command('unfoldRepeats', ly.dom.SchemeLily(func)))
            
            data.afterblocks.append(ly.dom.Comment(_("Rehearsal MIDI files:")))
            
            for voice, num, ref, lyrName in rehearsalMidis:
                # Append voice to the rehearsalMidi function
                name = voice2id[voice] + str(num or '')
                seq = ly.dom.Seq(ly.dom.Voice(name, parent=ly.dom.Staff(name, parent=choir)))
                if builder.lyVersion < (2, 18, 0):
                    ly.dom.Text('<>\\f', seq) # add one dynamic
                ly.dom.Identifier(ref, seq) # add the reference to the voice
                
                book = ly.dom.Book()
                
                # Append score to the aftermath (stuff put below the main score)
                suffix = "choir{0}-{1}".format(data.num, name) if data.num else name
                if builder.lyVersion < (2, 12, 0):
                    data.afterblocks.append(
                        ly.dom.Line('#(define output-suffix "{0}")'.format(suffix)))
                else:
                    ly.dom.Line('\\bookOutputSuffix "{0}"'.format(suffix), book)
                data.afterblocks.append(book)
                data.afterblocks.append(ly.dom.BlankLine())
                score = ly.dom.Score(book)
                
                # TODO: make configurable
                midiInstrument = voice2Midi[voice]

                cmd = ly.dom.Command(rehearsalMidi, score)
                ly.dom.QuotedString(name, cmd)
                ly.dom.QuotedString(midiInstrument, cmd)
                ly.dom.Identifier(refs[(lyrName, allStanzas[0])], cmd)
                ly.dom.Midi(score)
            
            ly.dom.Text("\\context Staff = $name", choir)
            seq = ly.dom.Seq(choir)
            ly.dom.Line("\\set Score.midiMinimumVolume = #0.5", seq)
            ly.dom.Line("\\set Score.midiMaximumVolume = #0.5", seq)
            ly.dom.Line("\\set Score.tempoWholesPerMinute = #" + data.scoreProperties.schemeMidiTempo(), seq)
            ly.dom.Line("\\set Staff.midiMinimumVolume = #0.8", seq)
            ly.dom.Line("\\set Staff.midiMaximumVolume = #1.0", seq)
            ly.dom.Line("\\set Staff.midiInstrument = $midiInstrument", seq)
            lyr = ly.dom.Lyrics(parent=choir)
            lyr.getWith()['alignBelowContext'] = ly.dom.Text('$name')
            ly.dom.Text("\\lyricsto $name $lyrics", lyr)



lyricStyles = (
    (lambda: _("All voices same lyrics"),
        lambda: _("A set of the same lyrics is placed between all staves.")),
    (lambda: _("Every voice same lyrics"),
        lambda: _("Every voice gets its own lyrics, using the same text as the"
                  " other voices.")),
    (lambda: _("Every voice different lyrics"),
        lambda: _("Every voice gets a different set of lyrics.")),
    (lambda: _("Distribute stanzas"),
        lambda: _("One set of stanzas is distributed across the staves.")),
)

voice2Voice = {
    'S': SopranoVoice,
    'A': AltoVoice,
    'T': TenorVoice,
    'B': BassVoice,
}

voice2id = {
    'S': 'soprano',
    'A': 'alto',
    'T': 'tenor',
    'B': 'bass',
}

voice2Midi = {
    'S': 'soprano sax',
    'A': 'soprano sax',
    'T': 'tenor sax',
    'B': 'tenor sax',
}

register(
    lambda: _("Vocal"),
    [
        LeadSheet,
        SopranoVoice,
        MezzoSopranoVoice,
        AltoVoice,
        TenorVoice,
        BassVoice,
        Choir,
    ])


########NEW FILE########
__FILENAME__ = woodwind
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Wood wind part types.
"""

from __future__ import unicode_literals

from . import _base
from . import register


class WoodWindPart(_base.SingleVoicePart):
    """Base class for wood wind part types."""
    
    
class Flute(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Flute")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Flute", "Fl.")

    midiInstrument = 'flute'

    
class Piccolo(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Piccolo")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Piccolo", "Pic.")

    midiInstrument = 'piccolo'
    transposition = (1, 0, 0)

    
class AltoFlute(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Alto Flute")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation Alto flute", "Afl.")

    midiInstrument = 'flute'
    transposition = (-1, 4, 0) 	


class BassFlute(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Bass flute")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Bass flute", "Bfl.")

    midiInstrument = 'flute'
    transposition = (-1, 0, 0)


class Oboe(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Oboe")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Oboe", "Ob.")

    midiInstrument = 'oboe'


class OboeDAmore(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Oboe d'amore")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Oboe d'amore", "Ob.d'am.")

    midiInstrument = 'oboe'
    transposition = (-1, 5, 0)


class EnglishHorn(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("English horn")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for English horn", "Eng.h.")

    midiInstrument = 'english horn'
    transposition = (-1, 3, 0)


class Bassoon(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Bassoon")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Bassoon", "Bn.")

    midiInstrument = 'bassoon'
    clef = 'bass'
    octave = -1


class ContraBassoon(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Contrabassoon")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Contrabassoon", "C.Bn.")

    midiInstrument = 'bassoon'
    transposition = (-1, 0, 0)
    clef = 'bass'
    octave = -1


class Clarinet(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Clarinet")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Clarinet", "Cl.")

    midiInstrument = 'clarinet'
    transposition = (-1, 6, -1)

    
class EflatClarinet(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("E-flat clarinet ")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for E-flat Clarinet", "Cl. in Eb")

    midiInstrument = 'clarinet'
    transposition = (0, 2, -1)
    
    
class AClarinet(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("A clarinet ")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for A Clarinet", "Cl. in A")

    midiInstrument = 'clarinet'
    transposition = (-1, 5, 0)
    

class BassClarinet(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Bass clarinet")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Bass clarinet", "BCl.")

    midiInstrument = 'clarinet'
    transposition = (-2, 6, -1)


class SopraninoSax(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Sopranino Sax")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Sopranino Sax", "SiSx.")
    
    midiInstrument = 'soprano sax'
    transposition = (0, 2, -1)    # es'


class SopranoSax(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Soprano Sax")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Soprano Sax", "SoSx.")
    
    midiInstrument = 'soprano sax'
    transposition = (-1, 6, -1)   # bes


class AltoSax(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Alto Sax")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Alto Sax", "ASx.")
    
    midiInstrument = 'alto sax'
    transposition = (-1, 2, -1)   # es


class TenorSax(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Tenor Sax")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Tenor Sax", "TSx.")
    
    midiInstrument = 'tenor sax'
    transposition = (-2, 6, -1)   # bes,


class BaritoneSax(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Baritone Sax")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Baritone Sax", "BSx.")
    
    midiInstrument = 'baritone sax'
    transposition = (-2, 2, -1)   # es,


class BassSax(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Bass Sax")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Bass Sax", "BsSx.")
    
    midiInstrument = 'baritone sax'
    transposition = (-3, 6, -1)   # bes,,


class SopraninoRecorder(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Sopranino recorder")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Sopranino recorder", "Si.rec.")
    
    midiInstrument = 'recorder'
    transposition = (1, 0, 0)

class SopranoRecorder(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Soprano recorder")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Soprano recorder", "S.rec.")
    
    midiInstrument = 'recorder'
    transposition = (1, 0, 0)


class AltoRecorder(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Alto recorder")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Alto recorder", "A.rec.")
    
    midiInstrument = 'recorder'


class TenorRecorder(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Tenor recorder")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Tenor recorder", "T.rec.")
    
    midiInstrument = 'recorder'


class BassRecorder(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Bass recorder")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Bass recorder", "B.rec.")
    
    midiInstrument = 'recorder'
    transposition = (1, 0, 0)
    clef = 'bass'
    octave = -1
    
    
class ContraBassRecorder(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Contra Bass recorder")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Contra Bass recorder", "Cb.rec.")
    
    midiInstrument = 'recorder'
    clef = 'bass'
    octave = -1
    
    
class SubContraBassRecorder(WoodWindPart):
    @staticmethod
    def title(_=_base.translate):
        return _("Subcontra Bass recorder")
    
    @staticmethod
    def short(_=_base.translate):
        return _("abbreviation for Subcontra Bass recorder", "Scb.rec.")
    
    midiInstrument = 'recorder'
    clef = 'bass'
    octave = -1



register(
    lambda: _("Woodwinds"),
    [
        Flute,
        Piccolo,
        AltoFlute,
        BassFlute,
        Oboe,
        OboeDAmore,
        EnglishHorn,
        Bassoon,
        ContraBassoon,
        Clarinet,
        EflatClarinet,
        AClarinet,
        BassClarinet,
        SopraninoSax,
        SopranoSax,
        AltoSax,
        TenorSax,
        BaritoneSax,
        BassSax,
        SopraninoRecorder,
        SopranoRecorder,
        AltoRecorder,
        TenorRecorder,
        BassRecorder,
        ContraBassRecorder,
        SubContraBassRecorder
    ])

########NEW FILE########
__FILENAME__ = _base
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Base types for parts.
"""

from __future__ import unicode_literals

import collections

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import listmodel
import ly.dom


Category = collections.namedtuple("Category", "title items icon")


def translate(*args):
    """Translate the arguments using the application's language."""
    return _(*args)


class Base(object):
    """Base class for both Part and Container."""
    @staticmethod
    def title(_=translate):
        """Should return a title.
        
        If a translator is given, it is used instead of the builtin.
        
        """
    
    @staticmethod
    def short(_=translate):
        """Should return an abbreviated title.
        
        If a translator is given, it is used instead of the builtin.
        
        """

    def createWidgets(self, layout):
        """Should create widgets to adjust settings."""
        self.noSettingsLabel = QLabel()
        layout.addWidget(self.noSettingsLabel)
        
    def translateWidgets(self):
        """Should set the text in the widgets when the language changes."""
        self.noSettingsLabel.setText('({0})'.format(_("No settings available.")))

    def accepts(self):
        """Should return a tuple of classes this part item accepts as child items."""
        return ()
    
    def build(self, data, builder):
        """Should populate the PartData (see build.py)."""
        data.nodes.append(ly.dom.Comment("Part {0}".format(self.__class__.__name__)))


class Part(Base):
    """Base class for Parts (that can't contain other parts)."""



class Container(Base):
    """Base class for "part" types that can contain others, like a Staff Group or Score, Book etc."""
    def accepts(self):
        return (Part, Container)
    

class Group(Container):
    """Base class for "part" types that are a group such as Book, BookPart and Score."""


# Mixin- or base classes with basic behaviour
class SingleVoicePart(Part):
    """Base class for a part creating a single single-voice staff."""
    midiInstrument = ''
    clef = None
    octave = 1
    transposition = None # or a three tuple (octave, note, alteration)

    def build(self, data, builder):
        a = data.assignMusic(None, self.octave, self.transposition)
        staff = ly.dom.Staff()
        builder.setInstrumentNamesFromPart(staff, self, data)
        if self.midiInstrument:
            builder.setMidiInstrument(staff, self.midiInstrument)
        seq = ly.dom.Seqr(staff)
        if self.clef:
            ly.dom.Clef(self.clef, seq)
        ly.dom.Identifier(a.name, seq)
        data.nodes.append(staff)


class PianoStaffPart(Part):
    """Base class for parts creating a piano staff."""
    def createWidgets(self, layout):
        self.label = QLabel(wordWrap=True)
        self.upperVoicesLabel = QLabel()
        self.lowerVoicesLabel = QLabel()
        self.upperVoices = QSpinBox(minimum=1, maximum=4, value=1)
        self.lowerVoices = QSpinBox(minimum=1, maximum=4, value=1)
        
        self.upperVoicesLabel.setBuddy(self.upperVoices)
        self.lowerVoicesLabel.setBuddy(self.lowerVoices)
        
        layout.addWidget(self.label)
        grid = QGridLayout()
        grid.addWidget(self.upperVoicesLabel, 0, 0)
        grid.addWidget(self.upperVoices, 0, 1)
        grid.addWidget(self.lowerVoicesLabel, 1, 0)
        grid.addWidget(self.lowerVoices, 1, 1)
        layout.addLayout(grid)
    
    def translateWidgets(self):
        self.label.setText('{0} <i>({1})</i>'.format(
            _("Adjust how many separate voices you want on each staff."),
            _("This is primarily useful when you write polyphonic music "
              "like a fuge.")))
        self.upperVoicesLabel.setText(_("Right hand:"))
        self.lowerVoicesLabel.setText(_("Left hand:"))
    
    def buildStaff(self, data, builder, name, octave, numVoices=1, node=None, clef=None):
        """Build a staff with the given number of voices and name."""
        staff = ly.dom.Staff(name, parent=node)
        builder.setMidiInstrument(staff, self.midiInstrument)
        c = ly.dom.Seqr(staff)
        if clef:
            ly.dom.Clef(clef, c)
        if numVoices == 1:
            a = data.assignMusic(name, octave)
            ly.dom.Identifier(a.name, c)
        else:
            c = ly.dom.Sim(c)
            for i in range(1, numVoices):
                a = data.assignMusic(name + ly.util.int2text(i), octave)
                ly.dom.Identifier(a.name, c)
                ly.dom.VoiceSeparator(c)
            a = data.assignMusic(name + ly.util.int2text(numVoices), octave)
            ly.dom.Identifier(a.name, c)
        return staff

    def build(self, data, builder):
        """ Setup structure for a 2-staff PianoStaff. """
        p = ly.dom.PianoStaff()
        builder.setInstrumentNamesFromPart(p, self, data)
        s = ly.dom.Sim(p)
        # add two staves, with a respective number of voices.
        self.buildStaff(data, builder, 'right', 1, self.upperVoices.value(), s)
        self.buildStaff(data, builder, 'left', 0, self.lowerVoices.value(), s, "bass")
        data.nodes.append(p)


class ChordNames(object):
    def createWidgets(self, layout):
        self.chordStyleLabel = QLabel()
        self.chordStyle = QComboBox()
        self.chordStyleLabel.setBuddy(self.chordStyle)
        self.chordStyle.setModel(listmodel.ListModel(chordNameStyles, self.chordStyle,
            display=listmodel.translate))
        self.guitarFrets = QCheckBox()
        
        box = QHBoxLayout()
        box.addWidget(self.chordStyleLabel)
        box.addWidget(self.chordStyle)
        layout.addLayout(box)
        layout.addWidget(self.guitarFrets)
        
    def translateWidgets(self):
        self.chordStyleLabel.setText(_("Chord style:"))
        self.guitarFrets.setText(_("Guitar fret diagrams"))
        self.guitarFrets.setToolTip(_(
            "Show predefined guitar fret diagrams below the chord names "
            "(LilyPond 2.12 and above)."))
        self.chordStyle.model().update()

    def build(self, data, builder):
        p = ly.dom.ChordNames()
        a = data.assign('chordNames')
        ly.dom.Identifier(a.name, p)
        s = ly.dom.ChordMode(a)
        ly.dom.Identifier(data.globalName, s).after = 1
        i = self.chordStyle.currentIndex()
        if i > 0:
            ly.dom.Line('\\{0}Chords'.format(
                ('german', 'semiGerman', 'italian', 'french')[i-1]), s)
        ly.dom.LineComment(_("Chords follow here."), s)
        ly.dom.BlankLine(s)
        data.nodes.append(p)
        if self.guitarFrets.isChecked():
            f = ly.dom.FretBoards()
            ly.dom.Identifier(a.name, f)
            data.nodes.append(f)
            data.includes.append("predefined-guitar-fretboards.ly")


chordNameStyles = (
    lambda: _("Default"),
    lambda: _("German"),
    lambda: _("Semi-German"),
    lambda: _("Italian"),
    lambda: _("French"),
)


########NEW FILE########
__FILENAME__ = preview
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Fill in a ly.dom Document with example music for previewing.
"""

from __future__ import unicode_literals

import itertools
import math

import ly.dom


def examplify(doc):
    """Fills in some example music in the given ly.dom.Document."""
    stubs = []
    globals = {}
    for a in doc.find_children(ly.dom.Assignment, 2):
        if isinstance(a.name, ly.dom.Reference):
            g = None
            for i in a.find_children(ly.dom.Identifier):
                if not isinstance(i.name, ly.dom.Reference):
                    g = i.name
                    break
            stubs.append((g, a[-1]))
        else:
            keysig = a.find_child(ly.dom.KeySignature) 
            timesig = a.find_child(ly.dom.TimeSignature)
            partial = a.find_child(ly.dom.Partial)
            
            # create a list of durations for the example notes.
            durations = []
            if partial:
                durations.append((partial.dur, partial.dots))
            if timesig:
                dur = int(math.log(int(timesig.beat), 2))
                num = min(int(timesig.num)*2, 10)
            else:
                dur, num = 2, 4
            durations += [(dur, 0)] * num

            globals[a.name] = (keysig, durations)
    
    # other lyrics on each request
    lyrics = itertools.cycle('ha hi he ho hu'.split())
    
    # fill assignment stubs with suitable example music input
    num = 10
    for g, stub in stubs:
        try:
            keysig, durations = globals[g]
            num = len(durations)
        except KeyError:
            pass
        
        def addItems(stub, generator):
            for dur, dots in durations:
                node = next(generator)
                node.append(ly.dom.Duration(dur, dots))
                stub.append(node)
        
        if isinstance(stub, ly.dom.LyricMode):
            stub.append(ly.dom.Text(' '.join(itertools.repeat(next(lyrics), num))))
        elif isinstance(stub, ly.dom.Relative):
            addItems(stub[-1], pitchGen(keysig))
        elif isinstance(stub, ly.dom.ChordMode):
            addItems(stub, chordGen(keysig))
        elif isinstance(stub, ly.dom.FigureMode):
            addItems(stub, figureGen())
        elif isinstance(stub, ly.dom.DrumMode):
            addItems(stub, drumGen())


# Generators for different kinds of example input
def pitchGen(startPitch):
    note = startPitch.note
    while True:
        for n in (note, note, (note + 9 ) % 7, (note + 8) % 7,
                  note, (note + 11) % 7, note):
            chord = ly.dom.Chord()
            ly.dom.Pitch(-1, n, startPitch.alter, parent=chord)
            yield chord


def chordGen(startPitch):
    for n in pitchGen(startPitch):
        yield n
        for i in 1, 2, 3:
            yield ly.dom.TextDur("\\skip")
        

def figureGen():
    while True:
        for i in 5, 6, 3, 8, 7:
            for s in "<{0}>".format(i), "\\skip", "\\skip":
                yield ly.dom.TextDur(s)
            

def drumGen():
    while True:
        for s in "bd", "hh", "sn", "hh":
            yield ly.dom.TextDur(s)



########NEW FILE########
__FILENAME__ = score
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Parts widget.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import icons
import widgets.treewidget

from . import parts
import parts._base
import parts.containers


class ScorePartsWidget(QSplitter):
    def __init__(self, parent):
        super(ScorePartsWidget, self).__init__(parent)
        
        self.typesLabel = QLabel()
        self.typesView = QTreeView(
            selectionMode=QTreeView.ExtendedSelection,
            selectionBehavior=QTreeView.SelectRows,
            animated=True,
            headerHidden=True)
        self.scoreLabel = QLabel()
        self.scoreView = widgets.treewidget.TreeWidget(
            selectionMode=QTreeView.ExtendedSelection,
            selectionBehavior=QTreeView.SelectRows,
            headerHidden=True,
            animated=True,
            dragDropMode=QTreeView.InternalMove)
        self.addButton = QPushButton(icon = icons.get("list-add"))
        self.removeButton = QPushButton(icon = icons.get("list-remove"))
        self.upButton = QToolButton(icon = icons.get("go-up"))
        self.downButton = QToolButton(icon = icons.get("go-down"))
        self.partSettings = QStackedWidget()
        
        w = QWidget()
        self.addWidget(w)
        layout = QVBoxLayout(spacing=0)
        w.setLayout(layout)
        
        layout.addWidget(self.typesLabel)
        layout.addWidget(self.typesView)
        layout.addWidget(self.addButton)
        
        w = QWidget()
        self.addWidget(w)
        layout = QVBoxLayout(spacing=0)
        w.setLayout(layout)
        
        layout.addWidget(self.scoreLabel)
        layout.addWidget(self.scoreView)
        
        box = QHBoxLayout(spacing=0)
        layout.addLayout(box)
        
        box.addWidget(self.removeButton)
        box.addWidget(self.upButton)
        box.addWidget(self.downButton)
        
        self.addWidget(self.partSettings)

        self.typesView.setModel(parts.model())
        app.translateUI(self)
        
        # signal connections
        self.addButton.clicked.connect(self.slotAddButtonClicked)
        self.removeButton.clicked.connect(self.slotRemoveButtonClicked)
        self.typesView.doubleClicked.connect(self.slotDoubleClicked)
        self.scoreView.currentItemChanged.connect(self.slotCurrentItemChanged)
        self.upButton.clicked.connect(self.scoreView.moveSelectedChildrenUp)
        self.downButton.clicked.connect(self.scoreView.moveSelectedChildrenDown)
        
    def translateUI(self):
        bold = "<b>{0}</b>".format
        self.typesLabel.setText(bold(_("Available parts:")))
        self.scoreLabel.setText(bold(_("Score:")))
        self.addButton.setText(_("&Add"))
        self.removeButton.setText(_("&Remove"))
        self.upButton.setToolTip(_("Move up"))
        self.downButton.setToolTip(_("Move down"))

    def slotDoubleClicked(self, index):
        self.addParts([index])
        
    def slotAddButtonClicked(self):
        self.addParts(self.typesView.selectedIndexes())

    def addParts(self, indexes):
        """Adds the parts for the given indexes."""
        # add to current if that is a container type
        currentItem = self.scoreView.currentItem()
        for index in indexes:
            category = index.internalPointer()
            if category:
                part = category.items[index.row()]
                box = QGroupBox(self.partSettings)
                self.partSettings.addWidget(box)
                # determine the parent: current or root
                if currentItem and issubclass(part, currentItem.part.accepts()):
                    parent = currentItem
                    parent.setExpanded(True)
                else:
                    parent = self.scoreView
                item = PartItem(parent, part, box)
    
    def slotCurrentItemChanged(self, item):
        if isinstance(item, PartItem):
            self.partSettings.setCurrentWidget(item.box)
    
    def slotRemoveButtonClicked(self):
        self.scoreView.removeSelectedItems()
       
    def clear(self):
        """Called when the user clicks the clear button on this page."""
        self.scoreView.clear()

    def rootPartItem(self):
        """Returns the invisibleRootItem(), representing the tree of parts in the score view."""
        return self.scoreView.invisibleRootItem()
        

class PartItem(widgets.treewidget.TreeWidgetItem):
    """An item in the score tree widget."""
    def __init__(self, tree, part, box):
        """Initializes the item.
        
        tree: is the score tree widget,
        part: is the Part instance that creates the widgets
        box: the QGroupBox that is created for this item in the stacked widget.
        
        """
        super(PartItem, self).__init__(tree)
        self.part = part()
        self.box = box
        layout = QVBoxLayout()
        box.setLayout(layout)
        self.part.createWidgets(layout)
        layout.addStretch(1)
        app.translateUI(self)
        
        flags = (
            Qt.ItemIsSelectable |
            Qt.ItemIsDragEnabled |
            Qt.ItemIsEnabled
        )
        if issubclass(part, parts._base.Container):
            flags |= Qt.ItemIsDropEnabled
        self.setFlags(flags)
        
    def translateUI(self):
        self.setText(0, self.part.title())
        self.box.setTitle(self.part.title())
        self.part.translateWidgets()
        
    def cleanup(self):
        self.box.deleteLater()



########NEW FILE########
__FILENAME__ = scoreproperties
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Properties of a score:
- key signature
- time signature
- pickup beat
- metronome value [note]=[time][tap]
- tempo indication
"""

from __future__ import unicode_literals

import fractions
import re

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import ly.dom
import completionmodel
import listmodel
import symbols
import widgets.lineedit
import widgets.tempobutton


class ScoreProperties(object):
    """This is only the base class, it should be mixed in with a widget or a different way."""

    def createWidgets(self):
        """Creates all widgets."""
        self.createKeySignatureWidget()
        self.createTimeSignatureWidget()
        self.createPickupWidget()
        self.createMetronomeWidget()
        self.createTempoWidget()
        
    def layoutWidgets(self, layout):
        """Adds all widgets to a vertical layout."""
        self.layoutKeySignatureWidget(layout)
        self.layoutTimeSignatureWidget(layout)
        self.layoutPickupWidget(layout)
        self.layoutMetronomeWidget(layout)
        self.layoutTempoWidget(layout)
        
    def translateWidgets(self):
        self.translateKeySignatureWidget()
        self.translateTimeSignatureWidget()
        self.translatePickupWidget()
        self.tranlateMetronomeWidget()
        self.translateTempoWidget()
    
    def ly(self, node, builder):
        """Adds appropriate LilyPond command nodes to the parent node.
        
        Settings from the builder are used where that makes sense.
        All widgets must be present.
        
        """
        self.lyKeySignature(node, builder)
        self.lyTimeSignature(node, builder)
        self.lyPickup(node, builder)
        self.lyTempo(node, builder)
    
    def globalSection(self, builder):
        """Returns a sequential expression between { } containing the output of ly()."""
        seq = ly.dom.Seq()
        self.ly(seq, builder)
        return seq
        
    # Key signature
    def createKeySignatureWidget(self):
        self.keySignatureLabel = QLabel()
        self.keyNote = QComboBox()
        self.keyNote.setModel(listmodel.ListModel(keyNames['nederlands'], self.keyNote))
        self.keyMode = QComboBox()
        self.keyMode.setModel(listmodel.ListModel(modes, self.keyMode, display=listmodel.translate_index(1)))
        self.keySignatureLabel.setBuddy(self.keyNote)
        
    def translateKeySignatureWidget(self):
        self.keySignatureLabel.setText(_("Key signature:"))
        self.keyMode.model().update()
    
    def layoutKeySignatureWidget(self, layout):
        """Adds our widgets to a layout, assuming it is a QVBoxLayout."""
        box = QHBoxLayout()
        box.addWidget(self.keySignatureLabel)
        box.addWidget(self.keyNote)
        box.addWidget(self.keyMode)
        layout.addLayout(box)

    def setPitchLanguage(self, language='nederlands'):
        self.keyNote.model()._data = keyNames[language or 'nederlands']
        self.keyNote.model().update()
    
    def lyKeySignature(self, node, builder):
        """Adds the key signature to the ly.dom node parent."""
        note, alter = keys[self.keyNote.currentIndex()]
        alter = fractions.Fraction(alter, 2)
        mode = modes[self.keyMode.currentIndex()][0]
        ly.dom.KeySignature(note, alter, mode, node).after = 1
        
    # Time signature
    def createTimeSignatureWidget(self):
        self.timeSignatureLabel = QLabel()
        self.timeSignature = QComboBox(editable=True)
        icons = {
            '(4/4)': symbols.icon('time_c44'),
            '(2/2)': symbols.icon('time_c22'),
        }
        self.timeSignature.setModel(listmodel.ListModel(timeSignaturePresets, self.timeSignature,
            icon=icons.get))
        self.timeSignature.setCompleter(None)
        self.timeSignatureLabel.setBuddy(self.timeSignature)
    
    def translateTimeSignatureWidget(self):
        self.timeSignatureLabel.setText(_("Time signature:"))
    
    def layoutTimeSignatureWidget(self, layout):
        """Adds our widgets to a layout, assuming it is a QVBoxLayout."""
        box = QHBoxLayout()
        box.addWidget(self.timeSignatureLabel)
        box.addWidget(self.timeSignature)
        layout.addLayout(box)
    
    def lyTimeSignature(self, node, builder):
        """Adds the time signature to the ly.dom node parent."""
        sig = self.timeSignature.currentText().strip()
        if '+' in sig:
            pass # TODO: implement support for \compoundMeter
        else:
            if sig == '(2/2)':
                ly.dom.TimeSignature(2, 2, node).after = 1
            elif sig == '(4/4)':
                ly.dom.TimeSignature(4, 4, node).after = 1
            else:
                match = re.search(r'(\d+).*?(\d+)', sig)
                if match:
                    if builder.lyVersion >= (2, 11, 44):
                        ly.dom.Line(r"\numericTimeSignature", node)
                    else:
                        ly.dom.Line(r"\override Staff.TimeSignature #'style = #'()", node)
                    num, beat = map(int, match.group(1, 2))
                    ly.dom.TimeSignature(num, beat, node).after = 1

    # Pickup bar
    def createPickupWidget(self):
        self.pickupLabel = QLabel()
        self.pickup = QComboBox()
        pickups = ['']
        pickups.extend(durations)
        self.pickup.setModel(listmodel.ListModel(pickups, self.pickup,
            display = lambda item: item or _("None"),
            icon = lambda item: symbols.icon('note_{0}'.format(item.replace('.', 'd'))) if item else None))
        self.pickup.view().setIconSize(QSize(22, 22))
        self.pickupLabel.setBuddy(self.pickup)
        
    def translatePickupWidget(self):
        self.pickupLabel.setText(_("Pickup measure:"))
        self.pickup.model().update()
        
    def layoutPickupWidget(self, layout):
        box = QHBoxLayout()
        box.addWidget(self.pickupLabel)
        box.addWidget(self.pickup)
        layout.addLayout(box)
    
    def lyPickup(self, node, builder):
         if self.pickup.currentIndex() > 0:
            dur, dots = partialDurations[self.pickup.currentIndex() - 1]
            ly.dom.Partial(dur, dots, parent=node)
    
    # Metronome value
    def createMetronomeWidget(self):
        self.metronomeLabel = QLabel()
        self.metronomeNote = QComboBox()
        self.metronomeNote.setModel(listmodel.ListModel(durations, display=None,
            icon = lambda item: symbols.icon('note_{0}'.format(item.replace('.', 'd')))))
        self.metronomeNote.setCurrentIndex(durations.index('4'))
        self.metronomeNote.view().setIconSize(QSize(22, 22))
        self.metronomeEqualSign = QLabel('=')
        self.metronomeEqualSign.setFixedWidth(self.metronomeEqualSign.minimumSizeHint().width())
        self.metronomeValue = QComboBox(editable=True)
        self.metronomeValue.setModel(listmodel.ListModel(metronomeValues, self.metronomeValue,
            display=format))
        self.metronomeValue.setCompleter(None)
        self.metronomeValue.setValidator(QIntValidator(0, 999, self.metronomeValue))
        self.metronomeValue.setCurrentIndex(metronomeValues.index(100))
        self.metronomeTempo = widgets.tempobutton.TempoButton()
        self.metronomeTempo.tempo.connect(self.setMetronomeValue)
        self.metronomeLabel.setBuddy(self.metronomeNote)
    
    def layoutMetronomeWidget(self, layout):
        box = QHBoxLayout(spacing=0)
        box.addWidget(self.metronomeLabel)
        box.addWidget(self.metronomeNote)
        box.addWidget(self.metronomeEqualSign)
        box.addWidget(self.metronomeValue)
        box.addWidget(self.metronomeTempo)
        layout.addLayout(box)
        
    def tranlateMetronomeWidget(self):
        self.metronomeLabel.setText(_("Metronome mark:"))
    
    def setMetronomeValue(self, bpm):
        """ Tap the tempo tap button """
        l = [abs(t - bpm) for t in metronomeValues]
        m = min(l)
        if m < 6:
            self.metronomeValue.setCurrentIndex(l.index(m))

    # Tempo indication
    def createTempoWidget(self):
        self.tempoLabel = QLabel()
        self.tempo = widgets.lineedit.LineEdit()
        completionmodel.complete(self.tempo, "scorewiz/completion/scoreproperties/tempo")
        self.tempo.completer().setCaseSensitivity(Qt.CaseInsensitive)
        self.tempoLabel.setBuddy(self.tempo)

    def layoutTempoWidget(self, layout):
        box = QHBoxLayout()
        box.addWidget(self.tempoLabel)
        box.addWidget(self.tempo)
        layout.addLayout(box)

    def translateTempoWidget(self):
        self.tempoLabel.setText(_("Tempo indication:"))

    def lyTempo(self, node, builder):
        """Returns an appropriate tempo indication."""
        text = self.tempo.text().strip()
        if builder.showMetronomeMark:
            dur = durations[self.metronomeNote.currentIndex()]
            val = self.metronomeValue.currentText()
        elif text:
            dur = None
            val = None
        else:
            return
        tempo = ly.dom.Tempo(dur, val, node)
        if text:
            ly.dom.QuotedString(text, tempo)

    def lyMidiTempo(self, node):
        """Sets the configured tempo in the tempoWholesPerMinute variable."""
        node['tempoWholesPerMinute'] = ly.dom.Scheme(self.schemeMidiTempo())
    
    def schemeMidiTempo(self):
        """Returns a string with the tempo like '(ly:make-moment 100 4)' from the settings."""
        base, mul = midiDurations[self.metronomeNote.currentIndex()]
        val = int(self.metronomeValue.currentText()) * mul
        return "(ly:make-moment {0} {1})".format(val, base)
    
    def lySimpleMidiTempo(self, node):
        """Return a simple \tempo x=y node for the currently set tempo."""
        dur = durations[self.metronomeNote.currentIndex()]
        val = self.metronomeValue.currentText()
        return ly.dom.Tempo(dur, val, node)
        

def metronomeValues():
    v, start = [], 40
    for end, step in (60, 2), (72, 3), (120, 4), (144, 6), (210, 8):
        v.extend(range(start, end, step))
        start = end
    return v
metronomeValues = metronomeValues()


timeSignaturePresets = (
    '(4/4)', '(2/2)', # with symbols
    '2/4', '3/4', '4/4', '5/4', '6/4', '7/4',
    '2/2', '3/2', '4/2',
    '3/8', '5/8', '6/8', '7/8', '8/8', '9/8', '12/8',
    '3/16', '6/16', '12/16',
    '3+2/8', '3/4+3/8',
)

# durations for pickup and metronome
durations = ('16', '16.', '8', '8.', '4', '4.', '2', '2.', '1', '1.')
midiDurations = ((16,1),(32,3),(8,1),(16,3),(4,1),(8,3),(2,1),(4,3),(1,1),(2,3))
partialDurations = ((4,0),(4,1),(3,0),(3,1),(2,0),(2,1),(1,0),(1,1),(0,0),(0,1))
 

keyNames = {
    'nederlands': (
        'C', 'Cis',
        'Des', 'D', 'Dis',
        'Es', 'E',
        'F', 'Fis',
        'Ges', 'G', 'Gis',
        'As', 'A', 'Ais',
        'Bes', 'B',
    ),
    'english': (
        'C', 'C#',
        'Db', 'D', 'D#',
        'Eb', 'E',
        'F', 'F#',
        'Gb', 'G', 'G#',
        'Ab', 'A', 'A#',
        'Bb', 'B',
    ),
    'deutsch': (
        'C', 'Cis',
        'Des', 'D', 'Dis',
        'Es', 'E',
        'F', 'Fis',
        'Ges', 'G', 'Gis',
        'As', 'A', 'Ais',
        'B', 'H',
    ),
    'norsk': (
        'C', 'Ciss',
        'Dess', 'D', 'Diss',
        'Ess', 'E',
        'F', 'Fiss',
        'Gess', 'G', 'Giss',
        'Ass', 'A', 'Aiss',
        'B', 'H',
    ),
    'italiano': (
        'Do', 'Do diesis',
        'Re bemolle', 'Re', 'Re diesis',
        'Mi bemolle', 'Mi',
        'Fa', 'Fa diesis',
        'Sol bemolle', 'Sol', 'Sol diesis',
        'La bemolle', 'La', 'La diesis',
        'Si bemolle', 'Si',
    ),
    'espanol': (
        'Do', 'Do sostenido',
        'Re bemol', 'Re', 'Re sostenido',
        'Mi bemol', 'Mi',
        'Fa', 'Fa sostenido',
        'Sol bemol', 'Sol', 'Sol sostenido',
        'La bemol', 'La', 'La sostenido',
        'Si bemol', 'Si',
    ),
    'vlaams': (
        'Do', 'Do kruis',
        'Re mol', 'Re', 'Re kruis',
        'Mi mol', 'Mi',
        'Fa', 'Fa kruis',
        'Sol mol', 'Sol', 'Sol kruis',
        'La mol', 'La', 'La kruis',
        'Si mol', 'Si',
    ),
}
keyNames['svenska'] = keyNames['norsk']
keyNames['suomi'] = keyNames['deutsch']
keyNames['catalan'] = keyNames['italiano']
keyNames['portugues'] = keyNames['espanol']

keys = (
    (0, 0), (0, 1),
    (1, -1), (1, 0), (1, 1),
    (2, -1), (2, 0),
    (3, 0), (3, 1),
    (4, -1), (4, 0), (4, 1),
    (5, -1), (5, 0), (5, 1),
    (6, -1), (6, 0),
)

modes = (
    ('major',       lambda: _("Major")),
    ('minor',       lambda: _("Minor")),
    ('ionian',      lambda: _("Ionian")),
    ('dorian',      lambda: _("Dorian")),
    ('phrygian',    lambda: _("Phrygian")),
    ('lydian',      lambda: _("Lydian")),
    ('mixolydian',  lambda: _("Mixolydian")),
    ('aeolian',     lambda: _("Aeolian")),
    ('locrian',     lambda: _("Locrian")),
)


########NEW FILE########
__FILENAME__ = settings
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The score settings widget.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import po.setup
import language_names
import listmodel
import lilypondinfo

from . import scoreproperties

class SettingsWidget(QWidget):
    def __init__(self, parent):
        super(SettingsWidget, self).__init__(parent)
        grid = QGridLayout()
        self.setLayout(grid)
        
        self.scoreProperties = ScoreProperties(self)
        self.generalPreferences = GeneralPreferences(self)
        self.lilyPondPreferences = LilyPondPreferences(self)
        self.instrumentNames = InstrumentNames(self)
        
        grid.addWidget(self.scoreProperties, 0, 0)
        grid.addWidget(self.generalPreferences, 0, 1)
        grid.addWidget(self.lilyPondPreferences, 1, 0)
        grid.addWidget(self.instrumentNames, 1, 1)
    
    def clear(self):
        self.scoreProperties.tempo.clear()
        self.scoreProperties.keyNote.setCurrentIndex(0)
        self.scoreProperties.keyMode.setCurrentIndex(0)
        self.scoreProperties.pickup.setCurrentIndex(0)


class ScoreProperties(QGroupBox, scoreproperties.ScoreProperties):
    def __init__(self, parent):
        super(ScoreProperties, self).__init__(parent)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.createWidgets()
        self.layoutWidgets(layout)
        
        app.translateUI(self)
        
        scorewiz = self.window()
        scorewiz.pitchLanguageChanged.connect(self.setPitchLanguage)
        self.setPitchLanguage(scorewiz.pitchLanguage())
        
    def translateUI(self):
        self.translateWidgets()
        self.setTitle(_("Score properties"))
    


class GeneralPreferences(QGroupBox):
    def __init__(self, parent):
        super(GeneralPreferences, self).__init__(parent)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.typq = QCheckBox()
        self.tagl = QCheckBox()
        self.barnum = QCheckBox()
        self.neutdir = QCheckBox()
        self.midi = QCheckBox()
        self.metro = QCheckBox()
        self.paperSizeLabel = QLabel()
        self.paper = QComboBox()
        self.paper.addItems(paperSizes)
        self.paperLandscape = QCheckBox(enabled=False)
        self.paper.activated.connect(self.slotPaperChanged)
        
        layout.addWidget(self.typq)
        layout.addWidget(self.tagl)
        layout.addWidget(self.barnum)
        layout.addWidget(self.neutdir)
        layout.addWidget(self.midi)
        layout.addWidget(self.metro)
        
        box = QHBoxLayout(spacing=2)
        box.addWidget(self.paperSizeLabel)
        box.addWidget(self.paper)
        box.addWidget(self.paperLandscape)
        layout.addLayout(box)
        app.translateUI(self)
        
        self.loadSettings()
        self.window().finished.connect(self.saveSettings)
        
    def translateUI(self):
        self.setTitle(_("General preferences"))
        self.typq.setText(_("Use typographical quotes"))
        self.typq.setToolTip(_(
            "Replace normal quotes in titles with nice typographical quotes."))
        self.tagl.setText(_("Remove default tagline"))
        self.tagl.setToolTip(_(
            "Suppress the default tagline output by LilyPond."))
        self.barnum.setText(_("Remove bar numbers"))
        self.barnum.setToolTip(_(
            "Suppress the display of measure numbers at the beginning of "
            "every system."))
        self.neutdir.setText(_("Smart neutral stem direction"))
        self.neutdir.setToolTip(_(
            "Use a logical direction (up or down) for stems on the middle "
            "line of a staff."))
        self.midi.setText(_("Create MIDI output"))
        self.midi.setToolTip(_(
            "Create a MIDI file in addition to the PDF file."))
        self.metro.setText(_("Show metronome mark"))
        self.metro.setToolTip(_(
            "If checked, show the metronome mark at the beginning of the "
            "score. The MIDI output also uses the metronome setting."))
        # paper size:
        self.paperSizeLabel.setText(_("Paper size:"))
        self.paper.setItemText(0, _("Default"))
        self.paperLandscape.setText(_("Landscape"))
  
    def slotPaperChanged(self, index):
        self.paperLandscape.setEnabled(bool(index))
    
    def getPaperSize(self):
        """Returns the configured papersize or the empty string for default."""
        return paperSizes[self.paper.currentIndex()]
    
    def loadSettings(self):
        s = QSettings()
        s.beginGroup('scorewiz/preferences')
        self.typq.setChecked(s.value('typographical_quotes', True, bool))
        self.tagl.setChecked(s.value('remove_tagline', False, bool))
        self.barnum.setChecked(s.value('remove_barnumbers', False, bool))
        self.neutdir.setChecked(s.value('smart_neutral_direction', False, bool))
        self.midi.setChecked(s.value('midi', True, bool))
        self.metro.setChecked(s.value('metronome_mark', False, bool))
        psize = s.value('paper_size', '', type(""))
        enable = bool(psize and psize in paperSizes)
        self.paper.setCurrentIndex(paperSizes.index(psize) if enable else 0)
        self.paperLandscape.setChecked(s.value('paper_landscape', False, bool))
        self.paperLandscape.setEnabled(enable)

    def saveSettings(self):
        s = QSettings()
        s.beginGroup('scorewiz/preferences')
        s.setValue('typographical_quotes', self.typq.isChecked())
        s.setValue('remove_tagline', self.tagl.isChecked())
        s.setValue('remove_barnumbers', self.barnum.isChecked())
        s.setValue('smart_neutral_direction', self.neutdir.isChecked())
        s.setValue('midi', self.midi.isChecked())
        s.setValue('metronome_mark', self.metro.isChecked())
        s.setValue('paper_size', paperSizes[self.paper.currentIndex()])
        s.setValue('paper_landscape', self.paperLandscape.isChecked())

        
class InstrumentNames(QGroupBox):
    def __init__(self, parent):
        super(InstrumentNames, self).__init__(parent, checkable=True, checked=True)
        
        grid = QGridLayout()
        self.setLayout(grid)
        
        self.firstSystemLabel = QLabel()
        self.firstSystem = QComboBox()
        self.firstSystemLabel.setBuddy(self.firstSystem)
        self.otherSystemsLabel = QLabel()
        self.otherSystems = QComboBox()
        self.otherSystemsLabel.setBuddy(self.otherSystems)
        self.languageLabel = QLabel()
        self.language = QComboBox()
        self.languageLabel.setBuddy(self.language)

        self.firstSystem.setModel(listmodel.ListModel(
            (lambda: _("Long"), lambda: _("Short")), self.firstSystem,
            display = listmodel.translate))
        self.otherSystems.setModel(listmodel.ListModel(
            (lambda: _("Long"), lambda: _("Short"), lambda: _("None")), self.otherSystems,
            display = listmodel.translate))
        
        self._langs = l = ['','C']
        l.extend(sorted(po.available()))
        def display(lang):
            if lang == 'C':
                return _("English (untranslated)")
            elif not lang:
                return _("Default")
            return language_names.languageName(lang, po.setup.current())
        self.language.setModel(listmodel.ListModel(l, self.language, display=display))
        
        grid.addWidget(self.firstSystemLabel, 0, 0)
        grid.addWidget(self.firstSystem, 0, 1)
        grid.addWidget(self.otherSystemsLabel, 1, 0)
        grid.addWidget(self.otherSystems, 1, 1)
        grid.addWidget(self.languageLabel, 2, 0)
        grid.addWidget(self.language, 2, 1)
        app.translateUI(self)
        self.loadSettings()
        self.window().finished.connect(self.saveSettings)
        
    def translateUI(self):
        self.setTitle(_("Instrument names"))
        self.firstSystemLabel.setText(_("First system:"))
        self.otherSystemsLabel.setText(_("Other systems:"))
        self.languageLabel.setText(_("Language:"))
        self.firstSystem.setToolTip(_(
            "Use long or short instrument names before the first system."))
        self.otherSystems.setToolTip(_(
            "Use short, long or no instrument names before the next systems."))
        self.language.setToolTip(_(
            "Which language to use for the instrument names."))
        self.firstSystem.model().update()
        self.otherSystems.model().update()
        self.language.model().update()
    
    def getLanguage(self):
        """Returns the language the user has set.
        
        '' means:  default (use same translation as system)
        'C' means: English (untranslated)
        or a languagecode that is available in Frescobaldi's translation.
        
        """
        return self._langs[self.language.currentIndex()]

    def loadSettings(self):
        s = QSettings()
        s.beginGroup('scorewiz/instrumentnames')
        self.setChecked(s.value('enabled', True, bool))
        allow = ['long', 'short']
        first = s.value('first', '', type(""))
        self.firstSystem.setCurrentIndex(allow.index(first) if first in allow else 0)
        allow = ['long', 'short', 'none']
        other = s.value('other', '', type(""))
        self.otherSystems.setCurrentIndex(allow.index(other) if other in allow else 2)
        language = s.value('language', '', type(""))
        self.language.setCurrentIndex(self._langs.index(language) if language in self._langs else 0)
    
    def saveSettings(self):
        s = QSettings()
        s.beginGroup('scorewiz/instrumentnames')
        s.setValue('enable', self.isChecked())
        s.setValue('first', ('long', 'short')[self.firstSystem.currentIndex()])
        s.setValue('other', ('long', 'short', 'none')[self.otherSystems.currentIndex()])
        s.setValue('language', self._langs[self.language.currentIndex()])

        
class LilyPondPreferences(QGroupBox):
    def __init__(self, parent):
        super(LilyPondPreferences, self).__init__(parent)
        
        grid = QGridLayout()
        self.setLayout(grid)
        
        self.pitchLanguageLabel = QLabel()
        self.pitchLanguage = QComboBox()
        self.versionLabel = QLabel()
        self.version = QComboBox(editable=True)
        
        self.pitchLanguage.addItem('')
        self.pitchLanguage.addItems([lang.title() for lang in sorted(scoreproperties.keyNames)])
        self.version.addItem(lilypondinfo.preferred().versionString())
        for v in ("2.18.0", "2.16.0", "2.14.0", "2.12.0"):
            if v != lilypondinfo.preferred().versionString():
                self.version.addItem(v)
        
        grid.addWidget(self.pitchLanguageLabel, 0, 0)
        grid.addWidget(self.pitchLanguage, 0, 1)
        grid.addWidget(self.versionLabel, 1, 0)
        grid.addWidget(self.version, 1, 1)
        
        self.pitchLanguage.activated.connect(self.slotPitchLanguageChanged)
        app.translateUI(self)
        self.loadSettings()
        self.window().finished.connect(self.saveSettings)

    def translateUI(self):
        self.setTitle(_("LilyPond"))
        self.pitchLanguageLabel.setText(_("Pitch name language:"))
        self.pitchLanguage.setToolTip(_(
            "The LilyPond language you want to use for the pitch names."))
        self.pitchLanguage.setItemText(0, _("Default"))
        self.versionLabel.setText(_("Version:"))
        self.version.setToolTip(_(
            "The LilyPond version you will be using for this document."))

    def slotPitchLanguageChanged(self, index):
        if index == 0:
            language = ''
        else:
            language = self.pitchLanguage.currentText().lower()
        self.window().setPitchLanguage(language)
        
    def loadSettings(self):
        language = self.window().pitchLanguage()
        languages = list(sorted(scoreproperties.keyNames))
        index = languages.index(language) + 1 if language in languages else 0
        self.pitchLanguage.setCurrentIndex(index)

    def saveSettings(self):
        QSettings().setValue('scorewiz/lilypond/pitch_language', self.window().pitchLanguage())


paperSizes = ['', 'a3', 'a4', 'a5', 'a6', 'a7', 'legal', 'letter', '11x17']

########NEW FILE########
__FILENAME__ = scratchdir
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages a local temporary directory for a Document (e.g. unnamed or remote).
"""

from __future__ import unicode_literals

import os

import util
import ly.lex
import documentinfo
import plugin


def scratchdir(document):
    return ScratchDir.instance(document)
    

class ScratchDir(plugin.DocumentPlugin):
    
    def __init__(self, document):
        self._directory = None
        
    def create(self):
        """Creates the local temporary directory."""
        if not self._directory:
            self._directory = util.tempdir()
    
    def directory(self):
        """Returns the directory if a temporary area was created, else None."""
        return self._directory
    
    def path(self):
        """Returns the path the saved document text would have if a temporary area was created, else None."""
        if self._directory:
            basename = None
            if not self.document().url().isEmpty():
                basename = os.path.basename(self.document().url().path())
            if not basename:
                basename = 'document' + ly.lex.extensions[documentinfo.mode(self.document())]
            return os.path.join(self._directory, basename)
            
    def saveDocument(self):
        """Writes the text of the document to our path()."""
        if not self._directory:
            self.create()
        with open(self.path(), 'w') as f:
            f.write(self.document().encodedText())
            



########NEW FILE########
__FILENAME__ = session
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Stuff dealing with the QSessionManager.

If this script is called directly instead of imported,
it discards the session information given as the argument.

If this script is imported, it connects the saveState and commitData functions
to the QApplication signals.

"""

from __future__ import unicode_literals

import os
import sys

from PyQt4.QtCore import QObject, QSettings, Qt, SIGNAL
from PyQt4.QtGui import QApplication, QSessionManager

import info
import app

def sessionSettings():
    """Returns the QSettings object for sessiondata."""
    settings = QSettings()
    settings.beginGroup("sessiondata")
    return settings


if __name__ == '__main__':
    settings = sessionSettings()
    settings.remove(sys.argv[-1])
    sys.exit(0)


### Continued here if normally imported

import mainwindow

def sessionKey():
    """ Returns the full session key. """
    return '{0}_{1}'.format(app.qApp.sessionId(), app.qApp.sessionKey())

def saveState(sm):
    """Save session state on behalf of the session manager."""
    sm.setRestartHint(QSessionManager.RestartIfRunning)

    key = sessionKey()
    restartCommand = [sys.executable, os.path.abspath(sys.argv[0]), '-session', key]
    sm.setRestartCommand(restartCommand)
    
    discardCommand = [sys.executable, __file__, key]
    sm.setDiscardCommand(discardCommand)

def commitData(sm):
    """Save a session on behalf of the session manager."""
    if not sm.allowsInteraction():
        pass # TODO: can implement saving unsaved/unnamed docs to cache buffers
    sm.release()
    saveState(sm)
    settings = sessionSettings()
    settings.beginGroup(sessionKey())
    settings.setValue('numwindows', len(app.windows))
    for index, win in enumerate(app.windows):
        settings.beginGroup("mainwindow{0}".format(index))
        win.writeSessionSettings(settings)
        settings.endGroup()
    settings.endGroup()
    settings.sync()

def restoreSession():
    """Restore a session saved by the session manager."""
    settings = sessionSettings()
    settings.beginGroup(sessionKey())
    for index in range(settings.value('numwindows', 0, int)):
        settings.beginGroup("mainwindow{0}".format(index))
        win = mainwindow.MainWindow()
        win.readSessionSettings(settings)
        win.show()
        settings.endGroup()
    settings.endGroup()

# the new-style way of connecting fails on PyQt4 4.8.x...
QObject.connect(app.qApp, SIGNAL("saveStateRequest(QSessionManager&)"), saveState)
QObject.connect(app.qApp, SIGNAL("commitDataRequest(QSessionManager&)"), commitData)

########NEW FILE########
__FILENAME__ = dialog
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Session dialog for named session stuff.
"""

from __future__ import unicode_literals


from PyQt4.QtCore import Qt
from PyQt4.QtGui import (
    QCheckBox, QDialog, QDialogButtonBox, QGridLayout, QLabel, QLineEdit,
    QMessageBox, QVBoxLayout)

import app
import widgets.listedit
import widgets.urlrequester
import sessions
import userguide


class SessionManagerDialog(QDialog):
    def __init__(self, mainwindow):
        super(SessionManagerDialog, self).__init__(mainwindow)
        self.setWindowModality(Qt.WindowModal)
        self.setWindowTitle(app.caption(_("Manage Sessions")))
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.sessions = SessionList(self)
        layout.addWidget(self.sessions)
        layout.addWidget(widgets.Separator())
        
        self.buttons = b = QDialogButtonBox(self)
        layout.addWidget(b)
        b.setStandardButtons(QDialogButtonBox.Close)
        b.rejected.connect(self.accept)
        userguide.addButton(b, "sessions")
        self.sessions.load()


class SessionList(widgets.listedit.ListEdit):
    """Manage the list of sessions."""
    def load(self):
        names = sessions.sessionNames()
        current = sessions.currentSession()
        self.setValue(names)
        if current in names:
            self.setCurrentRow(names.index(current))

    def removeItem(self, item):
        sessions.deleteSession(item.text())
        super(SessionList, self).removeItem(item)

    def openEditor(self, item):
        name = SessionEditor(self).edit(item.text())
        if name:
            item.setText(name)
            return True


class SessionEditor(QDialog):
    def __init__(self, parent=None):
        super(SessionEditor, self).__init__(parent)
        self.setWindowModality(Qt.WindowModal)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        grid = QGridLayout()
        layout.addLayout(grid)
        
        self.name = QLineEdit()
        self.nameLabel = l = QLabel()
        l.setBuddy(self.name)
        grid.addWidget(l, 0, 0)
        grid.addWidget(self.name, 0, 1)
        
        self.autosave = QCheckBox()
        grid.addWidget(self.autosave, 1, 1)
        
        self.basedir = widgets.urlrequester.UrlRequester()
        self.basedirLabel = l = QLabel()
        l.setBuddy(self.basedir)
        grid.addWidget(l, 2, 0)
        grid.addWidget(self.basedir, 2, 1)
        
        layout.addWidget(widgets.Separator())
        self.buttons = b = QDialogButtonBox(self)
        layout.addWidget(b)
        b.setStandardButtons(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        b.accepted.connect(self.accept)
        b.rejected.connect(self.reject)
        userguide.addButton(b, "sessions")
        app.translateUI(self)
        
    def translateUI(self):
        self.nameLabel.setText(_("Name:"))
        self.autosave.setText(_("Always save the list of documents in this session"))
        self.basedirLabel.setText(_("Base directory:"))
    
    def load(self, name):
        settings = sessions.sessionGroup(name)
        self.autosave.setChecked(settings.value("autosave", True, bool))
        self.basedir.setPath(settings.value("basedir", "", type("")))
        # more settings here
        
    def save(self, name):
        settings = sessions.sessionGroup(name)
        settings.setValue("autosave", self.autosave.isChecked())
        settings.setValue("basedir", self.basedir.path())
        # more settings here
        
    def defaults(self):
        self.autosave.setChecked(True)
        self.basedir.setPath('')
        # more defaults here
        
    def edit(self, name=None):
        self._originalName = name
        if name:
            caption = _("Edit session: {name}").format(name=name)
            self.name.setText(name)
            self.load(name)
        else:
            caption = _("Edit new session")
            self.name.clear()
            self.name.setFocus()
            self.defaults()
        self.setWindowTitle(app.caption(caption))
        if self.exec_():
            # name changed?
            name = self.name.text()
            if self._originalName and name != self._originalName:
                sessions.renameSession(self._originalName, name)
            self.save(name)
            return name

    def done(self, result):
        if not result or self.validate():
            super(SessionEditor, self).done(result)
        
    def validate(self):
        """Checks if the input is acceptable.
        
        If this method returns True, the dialog is accepted when OK is clicked.
        Otherwise a messagebox could be displayed, and the dialog will remain
        visible.
        """
        name = self.name.text().strip()
        self.name.setText(name)
        if not name:
            self.name.setFocus()
            QMessageBox.warning(self, app.caption(_("Warning")),
                _("Please enter a session name."))
            if self._originalName:
                self.name.setText(self._originalName)
            return False
        
        elif name == '-':
            self.name.setFocus()
            QMessageBox.warning(self, app.caption(_("Warning")),
                _("Please do not use the name '{name}'.".format(name="-")))
            return False
        
        elif self._originalName != name and name in sessions.sessionNames():
            self.name.setFocus()
            box = QMessageBox(QMessageBox.Warning, app.caption(_("Warning")),
                _("Another session with the name {name} already exists.\n\n"
                  "Do you want to overwrite it?").format(name=name),
                QMessageBox.Discard | QMessageBox.Cancel, self)
            box.button(QMessageBox.Discard).setText(_("Overwrite"))
            result = box.exec_()
            if result != QMessageBox.Discard:
                return False
            
        return True


########NEW FILE########
__FILENAME__ = manager
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Per-MainWindow session manager
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QAction, QActionGroup

import actioncollection
import actioncollectionmanager
import plugin
import document
import icons
import util
import sessions
import signals


def get(mainwindow):
    """Returns the SessionManager for the specified MainWindow."""
    return SessionManager.instance(mainwindow)


class SessionManager(plugin.MainWindowPlugin):
    """Per-MainWindow session manager.
    
    Emits the saveSessionData(name) signal when a session wants to be saved.
    Connect to this if you only want the notification for the current MainWindow
    (the one the user initated the action from).
    
    Use app.saveSessionData(name) if you want to get the global notification.
    
    """
    
    # This signal is emitted when a session wants to save its data.
    saveSessionData = signals.Signal() # Session name

    def __init__(self, mainwindow):
        self.actionCollection = ac = SessionActions()
        actioncollectionmanager.manager(mainwindow).addActionCollection(ac)
        ac.session_new.triggered.connect(self.newSession)
        ac.session_save.triggered.connect(self.saveSession)
        ac.session_manage.triggered.connect(self.manageSessions)
        ac.session_none.triggered.connect(self.noSession)
    
    def newSession(self):
        from . import dialog
        name = dialog.SessionEditor(self.mainwindow()).edit()
        if name:
            sessions.setCurrentSession(name)
            self.saveCurrentSession()
    
    def saveSession(self):
        if not sessions.currentSession():
            return self.newSession()
        self.saveCurrentSession()
        
    def manageSessions(self):
        from . import dialog
        dialog.SessionManagerDialog(self.mainwindow()).exec_()

    def noSession(self):
        if sessions.currentSession():
            self.saveCurrentSessionIfDesired()
            sessions.setCurrentSession(None)
    
    def startSession(self, name):
        """Switches to the given session."""
        if name == sessions.currentSession():
            return
        if self.mainwindow().queryClose():
            active = sessions.loadSession(name)
            if active:
                self.mainwindow().setCurrentDocument(active)
            else:
                self.mainwindow().cleanStart()
        
    def saveCurrentSessionIfDesired(self):
        """Saves the current session if it is configured to save itself on exit."""
        cur = sessions.currentSession()
        if cur:
            s = sessions.sessionGroup(cur)
            if s.value("autosave", True, bool):
                self.saveCurrentSession()
    
    def saveCurrentSession(self):
        """Saves the current session."""
        cur = sessions.currentSession()
        if cur:
            documents = self.mainwindow().documents()
            active = self.mainwindow().currentDocument()
            sessions.saveSession(cur, documents, active)
            self.saveSessionData(cur)


class SessionActions(actioncollection.ActionCollection):
    name = "session"
    def createActions(self, parent=None):
        self.session_new = QAction(parent)
        self.session_save = QAction(parent)
        self.session_manage = QAction(parent)
        self.session_none = QAction(parent)
        self.session_none.setCheckable(True)
        
        self.session_new.setIcon(icons.get('document-new'))
        self.session_save.setIcon(icons.get('document-save'))
        self.session_manage.setIcon(icons.get('view-choose'))
        
    def translateUI(self):
        self.session_new.setText(_("New Session", "&New..."))
        self.session_save.setText(_("&Save"))
        self.session_manage.setText(_("&Manage..."))
        self.session_none.setText(_("No Session"))



########NEW FILE########
__FILENAME__ = menu
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Session menu.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QActionGroup, QMenu

import app
import qutil
import sessions

from . import manager


class SessionMenu(QMenu):
    def __init__(self, mainwindow):
        super(SessionMenu, self).__init__(mainwindow)
        app.translateUI(self)
        mgr = manager.get(mainwindow)
        ac = mgr.actionCollection
        ag = self._actionGroup = QActionGroup(self)
        ag.setExclusive(True)
        ag.addAction(ac.session_none)
        ag.triggered.connect(self.slotSessionsAction)
        self.addAction(ac.session_new)
        self.addAction(ac.session_save)
        self.addSeparator()
        self.addAction(ac.session_manage)
        self.addSeparator()
        self.addAction(ac.session_none)
        self.addSeparator()
        self.aboutToShow.connect(self.populate)
    
    def translateUI(self):
        self.setTitle(_('menu title', '&Session'))
    
    def populate(self):
        ac = manager.get(self.parentWidget()).actionCollection
        ag = self._actionGroup
        for a in ag.actions():
            if a is not ac.session_none:
                self.removeAction(a)
                ag.removeAction(a)
        ac.session_none.setChecked(not sessions.currentSession())
        for name in sessions.sessionNames():
            a = self.addAction(name.replace('&', '&&'))
            a.setCheckable(True)
            if name == sessions.currentSession():
                a.setChecked(True)
            a.setObjectName(name)
            ag.addAction(a)
        qutil.addAccelerators(self.actions())

    def slotSessionsAction(self, action):
        if action.objectName() in sessions.sessionNames():
            manager.get(self.parentWidget()).startSession(action.objectName())



########NEW FILE########
__FILENAME__ = signals
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A simple signal/slot implementation.

Functions or methods can be connected to Signal instances, and when the
Signal instance is called (or its emit() method is called, which is equivalent),
all connected methods or function are automatically called.

When a Signal is created as a class attribute and accessed via an instance of
that class, it creates a Signal instance specifically for that object.

When methods are connected, no reference is kept to the method's object. When
the object is garbage collected, the signal is automatically disconnected.

A special Signal variation is also available, the SignalContext. Methods or
functions connected to this signal should return context managers which are
entered when the signal is entered in a context (with) block.

"""

import bisect
import contextlib
import types
import weakref
import sys


__all__ = ["Signal", "SignalContext"]


class Signal(object):
    """A Signal can be emitted and receivers (slots) can be connected to it.
    
    An example:
    
    class MyObject(object):
    
        somethingChanged = Signal()
        
        def __init__(self):
            pass # etc
            
        def doSomething(self):
            ... do things ...
            self.somethingChanged("Hi there!")     # emit the signal
    
    def receiver(arg):
        print("Received message:", arg)
    
    
    >>> o = MyObject()
    >>> o.somethingChanged.connect(receiver)
    >>> o.doSomething()
    Received message: Hi there!
    
    A Signal() can be used directly or as a class attribute, but can also be
    accessed as an attribute of an instance, in which case it creates a Signal
    instance for that instance.

    The signal is emitted by the emit() method or by simply invoking it.
    
    It is currently not possible to enforce argument types that should be used
    when emitting the signal. But if called methods or functions expect fewer
    arguments than were given on emit(), the superfluous arguments are left out.
    
    Methods or functions are connected using connect() and disconnected using
    disconnect(). It is no problem to call connect() or disconnect() more than
    once for the same function or method. Only one connection to the same method
    or function can exist.
    
    """
    
    def __init__(self, owner=None):
        """Creates the Signal.
        
        If owner is given (must be a keyword argument) a weak reference to it is
        kept, and this allows a Signal to be connected to another Signal. When
        the owner dies, the connection is removed.
        
        """
        self.listeners = []
        self._blocked = False
        self._owner = weakref.ref(owner) if owner else lambda: None
        
    def __get__(self, instance, cls):
        """Called when accessing as a descriptor: returns another instance."""
        if instance is None:
            return self
        try:
            return self._instances[instance]
        except AttributeError:
            self._instances = weakref.WeakKeyDictionary()
        except KeyError:
            pass
        ret = self._instances[instance] = type(self)(owner=instance)
        return ret
    
    def owner(self):
        """Returns the owner of this Signal, if any."""
        return self._owner()
        
    def connect(self, slot, priority=0, owner=None):
        """Connects a method or function ('slot') to this Signal.
        
        The priority argument determines the order the connected slots are
        called. A lower value calls the slot earlier.
        If owner is given, the connection will be removed if owner is garbage
        collected.
        
        A slot that is already connected will not be connected twice.
        
        If slot is an instance method (bound method), the Signal keeps no
        reference to the object the method belongs to. So if the object is
        garbage collected, the signal is automatically disconnected.
        
        If slot is a (normal or lambda) function, the Signal will keep a
        reference to the function. If you want to have the function disconnected
        automatically when some object dies, you should provide that object
        through the owner argument. Be sure that the connected function does not
        keep a reference to that object in that case!
        
        """
        key = self.makeListener(slot, owner)
        if key not in self.listeners:
            key.add(self, priority)
            
    def disconnect(self, func):
        """Disconnects the method or function.
        
        No exception is raised if there wasn't a connection.
        
        """
        key = self.makeListener(func)
        try:
            self.listeners.remove(key)
        except ValueError:
            pass
    
    def clear(self):
        """Removes all connected slots."""
        del self.listeners[:]
    
    @contextlib.contextmanager
    def blocked(self):
        """Returns a contextmanager that suppresses the signal.
        
        An example (continued from the class documentation):
        
        >>> o = MyObject()
        >>> o.somethingChanged.connect(receiver)
        >>> with o.somethingChanged.blocked():
        ...     o.doSomething()
        (no output)
        
        The doSomething() method will emit the signal but the connected slots
        will not be called.
        
        """
        blocked, self._blocked = self._blocked, True
        try:
            yield
        finally:
            self._blocked = blocked

    def emit(self, *args, **kwargs):
        """Emits the signal.
        
        Unless blocked, all slots will be called with the supplied arguments.
        
        """
        if not self._blocked:
            for l in self.listeners[:]:
                l.call(args, kwargs)
    
    __call__ = emit

    def makeListener(self, func, owner=None):
        """Returns a suitable listener for the given method or function."""
        if isinstance(func, (types.MethodType, types.BuiltinMethodType)):
            return MethodListener(func)
        elif isinstance(func, Signal):
            return FunctionListener(func, owner or func.owner())
        else:
            return FunctionListener(func, owner)


class SignalContext(Signal):
    """A Signal variant where the connected methods or functions should return
    a context manager.
    
    You should use the SignalContext itself also as a context manager, e.g.:
    
    sig = signals.SignalContext()
    
    with sig(args):
        do_something()
    
    This will first call all the connected methods or functions, and then
    enter all the returned context managers. When the context ends,
    all context managers will be exited.
    
    """
    def emit(self, *args, **kwargs):
        if self._blocked:
            managers = []
        else:
            managers = [l.call(args, kwargs) for l in self.listeners]
        return self.signalcontextmanager(managers)
    
    __call__ = emit

    @contextlib.contextmanager
    def signalcontextmanager(self, managers):
        """A context manager handling all contextmanagers from the listeners."""
        # ideas taken from Python's contextlib.nested()
        exits = []
        exc = (None, None, None)
        try:
            for m in managers:
                m.__enter__()
                exits.append(m.__exit__)
            yield
        except:
            exc = sys.exc_info()
        finally:
            while exits:
                exit = exits.pop()
                try:
                    if exit(*exc):
                        exc = (None, None, None)
                except:
                    exc = sys.exc_info()
            if exc != (None, None, None):
                raise # exc[0], exc[1], exc[2]


class ListenerBase(object):
    def __lt__(self, other):
        return self.priority < other.priority
    
    def add(self, signal, priority):
        self.priority = priority
        bisect.insort_right(signal.listeners, self)
        if self.obj is not None:
            def remove(wr, selfref=weakref.ref(self), sigref=weakref.ref(signal)):
                self, signal = selfref(), sigref()
                if self and signal:
                    signal.listeners.remove(self)
            self.obj = weakref.ref(self.obj, remove)
        
        # determine the number of arguments allowed
        end = None
        try:
            co = self.func.func_code
            if not co.co_flags & 12:
                # no *args or **kwargs are used, cut off the unwanted arguments
                end = co.co_argcount - self.removeargs
        except AttributeError:
            pass
        self.argslice = slice(0, end)


class MethodListener(ListenerBase):
    removeargs = 1
    def __init__(self, meth):
        self.obj = meth.__self__
        self.objid = id(meth.__self__)
        try:
            self.func = meth.__func__
        except AttributeError:
            # c++ methods from PyQt4 object sometimes do not have the __func__ attribute
            self.func = getattr(meth.__self__.__class__, meth.__name__)
    
    def __eq__(self, other):
        return self.__class__ is other.__class__ and self.objid == other.objid and self.func is other.func

    def call(self, args, kwargs):
        obj = self.obj()
        if obj is not None:
            return self.func(obj, *args[self.argslice], **kwargs)


class FunctionListener(ListenerBase):
    removeargs = 0
    def __init__(self, func, owner=None):
        self.obj = owner
        self.func = func

    def __eq__(self, other):
        return self.__class__ is other.__class__ and self.func is other.func

    def call(self, args, kwargs):
        return self.func(*args[self.argslice], **kwargs)
        


########NEW FILE########
__FILENAME__ = simplemarkdown
#!python
# SimpleMarkdown -- a basic markdown-like parser.
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
SimpleMarkdown -- a basic markdown-like parser.

It supports different ways to iterate over the parsed text fragments and events.

It supports the following blocklevel items:

=== heading 1

== heading 2

= heading 3

plain text paragraph

* unordered list

1. ordered list

  * nested lists are possible
  
    a paragraph without bullet item

* compact item list
* item 2 (here no paragraphs will be put in the list items)

term of definition list
: definition text


```language
verbatim code
```

Block quotes are not supported

inline level:

*emphasis*

`code`

[link]
[link text]
[image:filename]

"""


from __future__ import unicode_literals

import contextlib


def chop_left(string, chars=None):
    """Return the string that string.lstrip(chars) would chop off."""
    return string[:-len(string.lstrip(chars))]

def find_first(string, chars, start=0, end=None):
    """Return a tuple (char, pos) for the first occurrence of any of the chars.
    
    If char is None, then pos is undefined and it means there is no occurrence.
    The start and end arguments can be used as in "".find, to restrict the
    search to a certain part of the string.
    
    """
    pos = end
    char = None
    for c in chars:
        i = string.find(c, start, pos)
        if i == start:
            return c, start
        elif i != -1:
            char = c
            pos = i
    return char, pos

def iter_split(text, separator):
    """Yield pairs of text before and after the separator."""
    while True:
        t = text.split(separator, 2)
        if len(t) < 3:
            if text:
                yield text, ''
            break
        yield t[:2]
        text = t[2]

def iter_split2(text, separator, separator2):
    """Yield pairs of text outside and inside the separators.
    
    This can be used to parse e.g. "text with [bracketed words] in it".
    
    """
    while True:
        t = text.split(separator, 1)
        if len(t) > 1:
            t2 = t[1].split(separator2, 1)
            if len(t2) > 1:
                yield t[0], t2[0]
                text = t2[1]
                continue
        if text:
            yield text, ''
        return

def html(text):
    """Convenience function converting markdown text to HTML."""
    o = HtmlOutput()
    p = Parser()
    p.parse(text, o)
    return o.html()

def html_inline(text):
    """Convenience function converting markdown text to HTML.
    
    Only inline text is parsed, i.e. links, emphasized, code.
    
    """
    p = Parser()
    o = p.output = HtmlOutput()
    p.parse_inline_text(text)
    return o.html()

def html_escape(text):
    """Escapes &, < and >."""
    return text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

def tree(text):
    """Convenience function returning the Tree object with the parsed markdown."""
    t = Tree()
    p = Parser()
    p.parse(text, t)
    return t


class Parser(object):
    """A basic Markdown-like parser.
    
    Usage:
    
    p = simplemarkdown.Parser()
    o = simplemarkdown.HtmlOutput() # or a different Output subclass instance
    text = "some markdown-formatted text"
    p.parse(text, o)
    o.html()
    
    You can also set an Output instance directly and use other parsing methods:
    
    p = simplemarkdown.Parser()
    p.output = simplemarkdown.HtmlOutput()
    p.parse_inline_text('text with *emphasized* words')
    p.output.html()
    
    While parsing, the linenumber is available in the lineno attribute.
    The default implementation sets the line number on every call to
    parse_inline_lines.
    
    """
    def __init__(self):
        self._lists = []
        self.output = Output()
        self.lineno = 1
    
    ##
    # block level parsing
    ##
    
    def parse(self, text, output=None, lineno=None):
        """Parse the text.
        
        Calls the push and pop methods on the output object, if specified.
        The lineno, if given, sets the lineno attribute for the current line.
        
        """
        self.parse_lines(text.splitlines(), output, lineno)
    
    def parse_lines(self, lines, output=None, lineno=None):
        """Parse text line by line.
        
        The lines may be a generator.
        Calls the push and pop methods on the output object, if specified.
        The lineno, if given, sets the lineno attribute for the current line.
        
        """
        if output is not None:
            self.output = output
        if lineno is not None:
            self.lineno = lineno
        lines = iter(lines)
        para = []
        for line in lines:
            if line.lstrip().startswith('```'):
                # code
                if para:
                    self.parse_paragraph(para)
                    para = []
                indent = len(chop_left(line))
                specifier = line.lstrip('` ').rstrip() or None
                code = []
                for line in lines:
                    if line.lstrip().startswith('```'):
                        break
                    code.append(line)
                self.handle_lists(indent)
                self.output.append('code', '\n'.join(code), specifier)
                self.lineno += len(code) + 2
            elif not line or line.isspace():
                if para:
                    self.parse_paragraph(para)
                    para = []
                self.lineno += 1
            else:
                para.append(line)
        if para:
            self.parse_paragraph(para)
    
    def parse_paragraph(self, lines):
        """Parse a list of one or more lines without blank lines in between.
        
        Dispatches the lines to handle headings, lists or plain text paragraphs.
        
        """
        indent = len(chop_left(lines[0]))
        if lines[0].lstrip().startswith('='):
            self.handle_lists(indent)
            self.parse_heading(lines)
        elif self.is_ul_item(lines[0]):
            self.handle_lists(indent, 'unorderedlist')
            self.parse_ul(lines)
        elif self.is_ol_item(lines[0]):
            self.handle_lists(indent, 'orderedlist')
            self.parse_ol(lines)
        elif self.is_dl_item(lines):
            self.handle_lists(indent, 'definitionlist')
            self.parse_dl(lines)
        elif not self.special_paragraph(lines):
            self.handle_lists(indent)
            with self.output('paragraph'):
                self.parse_inline_lines(lines)
    
    def special_paragraph(self, lines):
        """Called when a paragraph is not a heading or a list item.
        
        If this method returns True, it is assumed to have handled the contents.
        This can be used to extend the paragraph-level parser to understand more
        types of paragraphs.
        
        The default implementation does nothing and returns None, which causes
        the lines to be assumed to be a normal paragraph.
        
        """
        pass
    
    def is_ul_item(self, line):
        """Return True if the line is a unordered list prefix ("*")."""
        try:
            prefix, line = line.split(None, 1)
            return prefix == '*'
        except ValueError:
            return False

    def is_ol_item(self, line):
        """Return True if the line is a ordered list prefix (number period)."""
        try:
            prefix, line = line.split(None, 1)
            return prefix.endswith('.') and prefix[:-1].isdigit()
        except ValueError:
            return False
    
    def is_dl_item(self, lines):
        """Return True lines are a description list item."""
        return len(lines) > 1 and lines[1].lstrip().startswith(': ')
    
    def parse_heading(self, lines):
        """Parse a header text."""
        prefix = chop_left(lines[0], '= ')
        heading_type = 4 - min(prefix.count('='), 3)
        lines[0] = lines[0].strip('= ')
        with self.output('heading', heading_type):
            self.parse_inline_lines(lines)
    
    def parse_ol(self, lines):
        """Parse ordered lists.
        
        Every line of the supplied group of lines is checked for a number,
        if they are separate items, no paragraph tags are put around the list
        items.
        
        """
        # split in list items
        items = self.split_list_items(lines, self.is_ol_item)
        paragraph_item = len(items) == 1
        for item in items:
            with self.output('orderedlist_item'):
                if paragraph_item:
                    with self.output('paragraph'):
                        self.parse_inline_lines(item)
                else:
                    self.parse_inline_lines(item)
            
    def parse_ul(self, lines):
        """Parse unordered lists.
        
        Every line of the supplied group of lines is checked for an asterisk,
        if they are separate items, no paragraph tags are put around the list
        items.
        
        """
        items = self.split_list_items(lines, self.is_ul_item)
        paragraph_item = len(items) == 1
        for item in items:
            with self.output('unorderedlist_item'):
                if paragraph_item:
                    with self.output('paragraph'):
                        self.parse_inline_lines(item)
                else:
                    self.parse_inline_lines(item)
    
    def split_list_items(self, lines, pred):
        """Returns lists of lines that each represent a list item.
        
        The pred function should return true for a line that has an item prefix.
        
        """
        items = []
        item = []
        for line in lines:
            if pred(line):
                if item:
                    items.append(item)
                item = [line.split(None, 1)[1]]
            else:
                item.append(line)
        if item:
            items.append(item)
        return items
        
    def parse_dl(self, lines):
        """Parse a definition list item."""
        definition = lines[0]
        lines[1] = lines[1].split(':', 1)[1]
        with self.output('definitionlist_item'):
            with self.output('definitionlist_item_term'):
                self.parse_inline_lines([definition])
            with self.output('definitionlist_item_definition'):
                self.parse_inline_lines(lines[1:])
    
    def handle_lists(self, indent, list_type=None):
        """Close ongoing lists or start new lists if needed.
        
        If given, list_type should be 'orderedlist', 'unorderedlist', or
        'definitionlist'.
        
        """
        if list_type and (not self._lists or self._lists[-1][1] < indent):
            self._lists.append((list_type, indent))
            self.output.push(list_type)
        else:
            while self._lists:
                if self._lists[-1][1] > indent:
                    self.output.pop()
                    self._lists.pop()
                    continue
                elif self._lists[-1][1] == indent and self._lists[-1][0] != list_type:
                    self.output.pop()
                    self._lists.pop()
                    if list_type:
                        self._lists.append((list_type, indent))
                        self.output.push(list_type)
                break
            
    ##
    # inline level parsing
    ##
    
    def parse_inline_lines(self, lines):
        """Parse plain text lines with possibly inline markup.
        
        This implementation strip()s the lines, joins them with a newline
        and calls parse_inline_text() with the text string.
        
        """
        lineno = self.lineno
        self.parse_inline_text('\n'.join(line.strip() for line in lines))
        self.lineno = lineno + len(lines)
        
    def parse_inline_text(self, text):
        """Parse a continuous text block with possibly inline markup."""
        with self.output('inline'):
            nest = []
            for text, code in iter_split(text, '`'):
                while text:
                    in_link = 'link' in nest
                    in_emph = nest and nest[-1] == 'emph'
                    char, pos = find_first(text, '*]' if in_link else '*[')
                    if not char:
                        self.output_inline_text(text)
                        break
                    if pos:
                        self.output_inline_text(text[:pos])
                    if char == '*':
                        if in_emph:
                            self.output.pop()
                            nest.pop()
                        else:
                            self.output.push('inline_emphasis')
                            nest.append('emph')
                        text = text[pos+1:]
                    else:
                        if in_link:
                            while True:
                                self.output.pop()
                                if nest.pop() == 'link':
                                    break
                            text = text[pos+1:]
                        else:
                            char, end = find_first(text, ' \n\t]', pos + 1)
                            if not char:
                                self.output.push('link', text[pos+1:])
                                nest.append('link')
                                break
                            elif char == ']':
                                with self.output('link', text[pos+1:end]):
                                    self.output_inline_text(text[pos+1:end])
                                text = text[end+1:]
                            else:
                                self.output.push('link', text[pos+1:end])
                                nest.append('link')
                                text = text[end+1:].lstrip()
                if code:
                    with self.output('inline_code'):
                        self.output_inline_text(code)
            while nest:
                nest.pop()
                self.output.pop()
    
    def output_inline_text(self, text):
        """Append an 'inline_text' to the output."""
        self.output.append('inline_text', text)


class Output(object):
    """Base class for output handler objects.
    
    You should inherit from this class and implement the push() and pop() methods.
    
    """
    @contextlib.contextmanager
    def __call__(self, name, *args):
        """Context manager to push a new node and perform code, pop on exit."""
        self.push(name, *args)
        try:
            yield
        finally:
            self.pop()
    
    def append(self, name, *args):
        """Append a new node to the current node."""
        self.push(name, *args)
        self.pop()
    
    def push(self, name, *args):
        """Append a new node to the current node and make it current."""
        pass
    
    def pop(self):
        """Make the current node's parent the current node."""
        pass


class Tree(Output):
    """An Output that represents the tree structure of the parsed text."""
    
    class Node(list):
        def __new__(cls, name, *args):
            n = list.__new__(cls)
            n.name = name
            n.args = args
            return n

        def __init__(self, name, *args):
            list.__init__(self)
        
        def __nonzero__(self):
            return True
        
        def __repr__(self):
            return '<Node "{0}" {1} [{2}]>'.format(self.name, self.args, len(self))

        def __str__(self):
            return "{0} {1}".format(self.name, self.args)
    
    
    def __init__(self):
        self._root = self.Node('root')
        self._cursor = [self._root]
    
    # build the tree
    def push(self, name, *args):
        """Append a Node to the current node, and make that the current Node."""
        node = self.Node(name, *args)
        self._cursor[-1].append(node)
        self._cursor.append(node)
    
    def pop(self):
        """End the current Node and go back to the parent node."""
        if len(self._cursor) > 1:
            self._cursor.pop()
    
    # query the tree
    def root(self):
        """Return the root (which is a plain Python list)."""
        return self._root
    
    def dump(self, node=None, indent_start=0, indent_string='  '):
        """Show the node or the entire tree in a pretty-printed string."""
        def dump(n, indent):
            yield '{0}{1}'.format(indent_string * indent, n)
            for n1 in n:
                for s in dump(n1, indent + 1):
                    yield s
        nodes = [node] if node is not None else self._root
        return '\n'.join(s for n in nodes for s in dump(n, indent_start))

    def copy(self, output, node=None):
        """Copy the tree to the other output instance.
        
        If node is not specified, the entire tree is copied.
        
        """
        if node in (None, self._root):
            for n in self._root:
                self.copy(output, n)
        else:
            with output(node.name, *node.args):
                for n in node:
                    self.copy(output, n)
    
    def find(self, path, node=None):
        """Iter over the elements described by path.
        
        Currently this just yields all elements with the specified name.
        
        If node is not given, the entire tree is searched.
        
        """
        if node is None:
            node = self._root
        for n in node:
            if n.name == path:
                yield n
            for n1 in self.find(path, n):
                yield n1
    
    def iter_tree(self, node=None):
        """Iter over all elements of the tree.
        
        Every 'yield' is a list from the node's child up to the element itself.
        If node is not given, the root node is used.
        
        """
        def iter_tree(node, cursor=[]):
            for n in node:
                l = cursor + [n]
                yield l
                for l in iter_tree(n, l):
                    yield l
        return iter_tree(node or self._root)
    
    def iter_tree_find(self, path, node=None):
        """Iter over the elements described by path.
        
        Currently this just yields all elements with the specified name.
        Every 'yield' is a list from the node's child up to the element itself.
        
        If node is not given, the entire tree is searched.
        
        """
        def iter_tree_find(node, cursor=[]):
            for n in node:
                l = cursor + [n]
                if n.name == path:
                    yield l
                for l in iter_tree_find(n, l):
                    yield l
        return iter_tree_find(node or self._root)
    
    def text(self, node):
        """Convenience method to return plain text from the specified node.
        
        This method concatenates all text, so it is only useful on inline parts
        of a document.
        
        """
        return ''.join(e.args[0] for e in self.find('inline_text', node))
        
    def html(self, node=None):
        """Convenience method to return HTML text from the specified node.
        
        If node is not given, the entire document is returned as HTML text.
        This method uses the HtmlOutput class to create the HTML text.
        
        """
        o = HtmlOutput()
        self.copy(o, node)
        return o.html()


class HtmlOutput(Output):
    """Converts output to HTML.
    
    A heading type 1 gets converted to H1 by default, but you can set the
    heading_offset attribute to a value > 0 to make heading 1 output H2,
    heading 2 -> H3 etc.
    
    """
    heading_offset = 0
    
    def __init__(self):
        self._html = []
        self._tags = []
    
    def push(self, name, *args):
        getattr(self, name + '_start')(*args)
        self._tags.append((name, args))
        
    def pop(self):
        name, args = self._tags.pop()
        getattr(self, name + '_end')(*args)
        
    def html(self):
        return ''.join(self._html)
    
    def html_escape(self, text):
        """Escapes &, < and >."""
        return html_escape(text)
    
    def tag(self, name, attrs=None):
        """Add a tag. Use a name like '/p' to write a close tag.
        
        attrs may be a dictionary of attributes.
        
        """
        if attrs:
            a = ''.join(' {0}="{1}"'.format(
                name, self.html_escape(value).replace('"', '&quot;'))
                for name, value in attrs.items())
        else:
            a = ''
        self._html.append('<{0}{1}>'.format(name, a))
    
    def nl(self):
        """Add a newline."""
        self._html.append('\n')
    
    def text(self, text):
        self._html.append(self.html_escape(text))
    
    ##
    # block level handlers
    ##

    def code_start(self, code, specifier=None):
        self.tag('code')
        self.tag('pre')
        self.text(code)
    
    def code_end(self, code, specifier=None):
        self.tag('/pre')
        self.tag('/code')
        self.nl()
    
    def heading_start(self, heading_type):
        h = min(self.heading_offset + heading_type, 6)
        self.tag('h{0}'.format(h))
    
    def heading_end(self, heading_type):
        h = min(self.heading_offset + heading_type, 6)
        self.tag('/h{0}'.format(h))
        self.nl()
        
    def paragraph_start(self):
        if self._tags and self._tags[-1][0] == "definitionlist":
            self.tag('dd')
        self.tag('p')
    
    def paragraph_end(self):
        self.tag('/p')
        if self._tags and self._tags[-1][0] == "definitionlist":
            self.tag('/dd')
        self.nl()
    
    def orderedlist_start(self):
        self.tag('ol')
        self.nl()
    
    def orderedlist_item_start(self):
        self.tag('li')
    
    def orderedlist_item_end(self):
        self.tag('/li')
        self.nl()
    
    def orderedlist_end(self):
        self.tag('/ol')
        self.nl()
    
    def unorderedlist_start(self):
        self.tag('ul')
        self.nl()
    
    def unorderedlist_item_start(self):
        self.tag('li')
    
    def unorderedlist_item_end(self):
        self.tag('/li')
        self.nl()

    def unorderedlist_end(self):
        self.tag('/ul')
        self.nl()
    
    def definitionlist_start(self):
        self.tag('dl')
        self.nl()
        
    def definitionlist_item_term_start(self):
        self.tag('dt')
        
    def definitionlist_item_term_end(self):
        self.tag('/dt')
        self.nl()
        
    def definitionlist_item_definition_start(self):
        self.tag('dd')
        
    def definitionlist_item_definition_end(self):
        self.tag('/dd')
        self.nl()
        
    def definitionlist_item_start(self):
        pass
        
    def definitionlist_item_end(self):
        pass
        
    def definitionlist_end(self):
        self.tag('/dl')
        self.nl()

    ##
    # inline handlers
    ##

    def inline_start(self):
        """Called when a block of inline text is parsed."""
        pass
        
    def inline_end(self):
        """Called at the end of parsing a block of inline text.""" 
        pass
    
    def inline_code_start(self):
        self.tag('code')
    
    def inline_code_end(self):
        self.tag('/code')
    
    def inline_emphasis_start(self):
        self.tag('em')
    
    def inline_emphasis_end(self):
        self.tag('/em')
    
    def link_start(self, url):
        self.tag('a', {'href': url})
    
    def link_end(self, url):
        self.tag('/a')
    
    def inline_text_start(self, text):
        self.text(text)

    def inline_text_end(self, text):
        pass



########NEW FILE########
__FILENAME__ = simplestate
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

r"""
Represents a ly.lex.State as a simplified list of strings.

    \book {
      \header {
        title = \markup { #"

e.g. yields:

    ['lilypond', 'book', 'header', 'markup', 'scheme', 'string']

This is done by examining the state's parsers.
It can be used in snippets or plugin scripts.

The first word is always the mode of the file (e.g. 'lilypond', 'html', etc.).

"""

from __future__ import unicode_literals

import ly.lex.lilypond
import ly.lex.scheme
import ly.lex.html


def state(state):
    names = []
    def append(name):
        if not names or names[-1] != name:
            names.append(name)
    
    for p in state.state:
        name = parserClasses.get(p.__class__)
        if name:
            append(name)
        elif p.mode:
            append(p.mode)
        else:
            for c, name in parserTypes:
                if isinstance(p, c):
                    append(name)
                    break
    
    return names
    

parserClasses = {
    # lilypond
    ly.lex.lilypond.ParseMusic: "music",
    ly.lex.lilypond.ParseChord: "chord",
    ly.lex.lilypond.ParseLyricMode: "lyricmode",
    ly.lex.lilypond.ParseChordMode: "chordmode",
    ly.lex.lilypond.ParseFigureMode: "figuremode",
    ly.lex.lilypond.ParseDrumMode: "drummode",
    ly.lex.lilypond.ParsePaper: "paper",
    ly.lex.lilypond.ParseHeader: "header",
    ly.lex.lilypond.ParseLayout: "layout",
    ly.lex.lilypond.ParseBook: "book",
    ly.lex.lilypond.ParseBookPart: "bookpart",
    ly.lex.lilypond.ParseScore: "score",
    ly.lex.lilypond.ParseMidi: "midi",
    ly.lex.lilypond.ParseContext: "context",
    ly.lex.lilypond.ParseWith: "with",
    ly.lex.lilypond.ParseTranslator: "translator",
    ly.lex.lilypond.ParseMarkup: "markup",
    ly.lex.lilypond.ParseOverride: "override",
    ly.lex.lilypond.ParseString: "string",
    
    # scheme
    ly.lex.scheme.ParseScheme: "scheme",
    ly.lex.scheme.ParseString: "string",
    
    # html
    ly.lex.html.ParseAttr: "htmlattribute",
    ly.lex.html.ParseStringSQ: "single-quoted-string",
    ly.lex.html.ParseStringDQ: "double-quoted-string",
    ly.lex.html.ParseComment: "comment",
}

parserTypes = (

)


if __name__ == "__main__":
    # test
    text = r"""
    @title bla
    @lilypond
    \relative c' {
      c d e-\markup {
      
    """
    s = ly.lex.guessState(text)
    list(s.tokens(text))
    print(state(s))




########NEW FILE########
__FILENAME__ = slexer
# === Python slexer (Stateful Lexer) module ===
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
slexer -- Stateful Lexer

parses text, searching for tokens represented by a regular expression.

Only depends on the standard Python re module.

You need to create at least one subclass of Parser, and a subclass of Token for
every type of text to search for. Then you list the token class names in the
'items' tuple of the Parser subclass definition.

Different contexts can be parsed by creating multiple Parser subclasses.
A Parser searches for tokens using the list of Token classes. (Token is simply a
subclass of str in Python 3 and of unicode in Python 2). Every Token subclass
has the regular expression part to search for in its 'rx' class attribute.

You start parsing text by instantiating a State (you don't need to subclass
that) with the Parser subclass you want to parse the text with. Then you iterate
over the generated tokens using the tokens(text) method of the State instance.
You can use the tokens just as strings (e.g. if token == 'text'...) but you can
also test for the type of the token (e.g. if isinstance(token, Number)...).
The tokens also carry a 'pos' and an 'end' attribute, specifying their position
in the parsed text string.

A token may cause a different Parser to be enterend, of the current Parser to be
left, etc. This is done by implementing the update_state() method of the Token
subclass. This method is called automatically when the Token is instantiated.

The State maintains the parsing state (the list of active Parser instances).
A State can be frozen to be thawn later to resume parsing text starting in a
particular context. A Fridge can be used to store and recover a state under a
simple integer number.

How to use slexer:

from slexer import Token, Parser, State

# create token classes:
class Word(Token):
    rx = r'\w+'

class Number(Token):
    rx = r'\d+'

class String(Token):
    pass

class StringStart(String):
    rx = '"'
    def update_state(self, state):
        state.enter(PString())

class StringEnd(String):
    rx = '"'
    def update_state(self, state):
        state.leave()

# create parsers:
class PTest(Parser):
    '''Looks for numbers, words and the double quote.'''
    items = (
        Number,
        Word,
        StringStart,
    )

class PString(Parser):
    '''Returns String by default, quits at double quote.'''
    default = String
    items = (
        StringEnd,
    )

s = State(PTest)
for t in s.tokens(
    'een tekst met 7 woorden, '
    'een "tekst met 2 aanhalingstekens" '
    'en 2 of 3 nummers'):
    print(t.__class__, t)

# results in:
<class '__main__.Word'> een
<class '__main__.Word'> tekst
<class '__main__.Word'> met
<class '__main__.Number'> 7
<class '__main__.Word'> woorden
<class '__main__.Word'> een
<class '__main__.StringStart'> "
<class '__main__.String'> tekst met 2 aanhalingstekens
<class '__main__.StringEnd'> "
<class '__main__.Word'> en
<class '__main__.Number'> 2
<class '__main__.Word'> of
<class '__main__.Number'> 3
<class '__main__.Word'> nummers

"""

# remove the following 5 lines if sure Python 3.x is used
from __future__ import unicode_literals
import sys
if sys.version_info[0] < 3:
    str = unicode
del sys


import re


__all__ = ['Token', 'Parser', 'FallthroughParser', 'State', 'Fridge']


class State(object):
    """Maintains state while parsing text.
    
    You instantiate a State object with an initial parser class.
    Then you use tokens(text) to start parsing for tokens.
    
    The state is basically a list of Parser instances; the last one is the
    active one. The enter() and leave() methods respectively enter a new parser
    or leave the current parser.
    
    You can't leave() the initial parser instance.
    
    """
    def __init__(self, initialParserClass):
        """Construct the State with an initial Parser instance."""
        self.state = [initialParserClass()]
    
    def parser(self):
        """Return the currently active Parser instance."""
        return self.state[-1]
    
    def parsers(self):
        """Return all active parsers, the most current one first."""
        return self.state[::-1]
    
    def tokens(self, text, pos=0):
        """Parse a text string using our state info.
        
        Yields Token instances. All tokens are a subclass of str (or unicode in
        Python 2.x) and have a pos and an end attribute, describing their
        position in the original string. If the current parser defines a
        'default' class attribute, it is the Token subclass to use for pieces of
        text that would otherwise be skipped.
        
        """
        while True:
            parser = self.parser()
            m = parser.parse(text, pos)
            if m:
                if parser.default and pos < m.start():
                    token =  parser.default(text[pos:m.start()], pos)
                    token.update_state(self)
                    yield token
                token = parser.token(m)
                token.update_state(self)
                yield token
                pos = m.end()
            elif pos == len(text) or parser.fallthrough(self):
                break
        if parser.default and pos < len(text):
            token = parser.default(text[pos:], pos)
            token.update_state(self)
            yield token
    
    def enter(self, parser):
        """Enter a new parser.
        
        Note: 'parser' is an instantiated Parser subclass.
        Most times this method will be called from with the update_state()
        method of a Token subclass (or from a Parser subclass, which is also
        possible: the default implementation of Token.update_state() calls
        Parser.update_state(), which does nothing by default).
        
        E.g. in the Token subclass:
        
            def update_state(self, state):
                state.enter(SomeDifferentParser())
        
        """
        self.state.append(parser)
        
    def leave(self):
        """Leave the current parser and pop back to the previous.
        
        The first parser (specified on instantiation) will never be left.
        
        """
        if len(self.state) > 1:
            self.state.pop()
    
    def replace(self, parser):
        """Replace the current parser with a new one.
        
        Somewhat equivalent to:
            state.leave()
            state.enter(SomeDifferentParser)
        
        But using this method you can also replace the first parser.
        
        """
        self.state[-1] = parser
    
    def depth(self):
        """Return the number of parsers currenly active (1 or more).
        
        You can use this e.g. to keep parsing until some context ends:
        
        tokens = state.tokens(text) # iterator
        depth = state.depth()
        for token in tokens:
            if state.depth() < depth:
                break
            # do something
        
        """
        return len(self.state)
    
    def follow(self, token):
        """Act as if the token has been instantiated with the current state.
        
        You need this when you already have the parsed tokens, (e.g. cached or
        saved somehow) but want to know which parser created them.
        
        This method changes state according to the token. Basically it calls the
        update_state() method of the token instance, but it does some more work
        behind the scenes to ensure that the FallthroughParser type (see below)
        also is handled correctly.
        
        """
        while self.parser()._follow(token, self):
            pass
        token.update_state(self)

    def freeze(self):
        """Return the current state as a tuple (hashable object)."""
        return tuple((p.__class__, p.freeze()) for p in self.state)
    
    @classmethod
    def thaw(cls, frozen):
        """Reproduce a State object from the frozen state argument."""
        state = cls.__new__(cls)
        state.state = [cls.thaw(attrs) for cls, attrs in frozen]
        return state
        

class Token(str):
    """Represents a parsed piece of text.
    
    The subclass determines the type.
    
    You should put the regular expression string in the rx class attribute.
    In the rx string, you may not use named groups starting with "g_".
    
    To add token types to a Parser class, list the token class in the items
    attribute of the Parser class.
    
    """
    __slots__ = ['pos', 'end']
    
    rx = None
    
    @classmethod
    def test_match(cls, match):
        """Should return True if the match should indeed instantiate this class.
        
        This class method is only called if multiple Token classes in the
        Parser's items list have the same rx attribute. This method is then
        called for every matching Token subclass until one returns True.
        That token is then instantiated. (The method is not called for the last
        class in the list that have the same rx attribute, and also not if there
        is only one class with that rx attribute.)
        
        The default implementation always returns True.
        
        """
        return True
    
    def __new__(cls, string, pos):
        token = str.__new__(cls, string)
        token.pos = pos
        token.end = pos + len(token)
        return token
        
    def update_state(self, state):
        """Lets the token update the state, e.g. enter a different parser.
        
        This method is called by the State upon instantiation of the tokens.
        
        Don't use it later on to have a State follow already instantiated Tokens
        because the FallthroughParser type can also change the state without
        generating a Token. Use State.follow() to have a State follow
        instantiated Tokens.
        
        The default implementation lets the Parser decide on state change.
        
        """
        state.parser().update_state(state, self)


class PatternProperty(object):
    """A descriptor that lazily generates a regular expression.
    
    The expression is based on the list of Token subclasses in the items
    attribute of a Parser class. Also creates an index attribute for the parser
    class that maps the lastindex property of a match object to the token class.
    
    When the pattern is requested for the first time, it is created and also
    written in the class, overwriting this descriptor.
    
    """
    def __get__(self, instance, owner):
        try:
            owner.pattern = self.pattern
            owner.index = self.index
        except AttributeError:
            # if Token classes have the same regexp string, group them
            patterns = []
            counter = {}
            for cls in uniq(owner.items):
                rx = cls.rx
                try:
                    counter[rx].append(cls)
                except KeyError:
                    counter[rx] = [cls]
                    patterns.append(rx)
            # make the pattern
            owner.pattern = self.pattern = pattern = re.compile("|".join(
                "(?P<g_{0}>{1})".format(i, rx)
                for i, rx in enumerate(patterns)), owner.re_flags)
            # make a fast mapping list from matchObj.lastindex to the token class
            indices = sorted(v for k, v in pattern.groupindex.items() if k.startswith('g_'))
            owner.index = self.index = index = [None] * (indices[-1] + 1)
            for i, rx in zip(indices, patterns):
                index[i] = counter[rx]
        return owner.pattern


class ParserMeta(type):
    """Metaclass for Parser subclasses.
    
    Adds a 'pattern' attribute with a PatternProperty() when the class also
    defines 'items'.
    
    """
    def __new__(cls, name, bases, attrd):
        if attrd.get('items'):
            attrd['pattern'] = PatternProperty()
        return type.__new__(cls, name, bases, attrd)


class Parser(object):
    """Abstract base class for Parsers.
    
    When creating Parser subclasses, you should set the 'items' attribute to a
    tuple of Token subclasses. On class construction, a large regular expression
    pattern is built by combining the expressions from the 'rx' attributes of
    the Token subclasses.
    
    Additionally, you may implement the update_state() method which is called
    by the default implementation of update_state() in Token.
    
    """
    re_flags = 0   # the re.compile flags to use
    default = None # if not None, the default class for unparsed pieces of text
    
    # tuple of Token classes to look for in text
    items = ()
    
    def parse(self, text, pos):
        """Parse text from position pos and returns a Match Object or None."""
        return self.pattern.search(text, pos)
    
    def token(self, match):
        """Return a Token instance of the correct class.
        
        The match object is returned by the parse() method.
        
        """
        clss = self.index[match.lastindex]
        for c in clss[:-1]:
            if c.test_match(match):
                return c(match.group(), match.start())
        return clss[-1](match.group(), match.start())
    
    def _follow(self, token, state):
        """(Internal) Called by State.follow(). Does nothing."""
        pass
    
    def freeze(self):
        """Return our instance values as a hashable tuple."""
        return ()
    
    @classmethod
    def thaw(cls, attrs):
        return cls(*attrs)

    def fallthrough(self, state):
        """Called when no match is returned by parse().
        
        If this function returns True, the tokenizer stops parsing, assuming all
        text has been consumed.  If this function returns False or None, it
        should alter the state (switch parsers) and parsing continues using the
        new Parser.
        
        The default implementation simply returns True.
        
        """
        return True

    def update_state(self, state, token):
        """Called by the default implementation of Token.update_state().
        
        Does nothing by default.
        
        """
        pass


# This syntax to make Parser use the metaclass works in both Python2 and 3
Parser = ParserMeta(Parser.__name__, Parser.__bases__, dict(Parser.__dict__))


class FallthroughParser(Parser):
    """Base class for parsers that 'match' instead of 'search' for a pattern.
    
    You can also implement the fallthrough() method to do something with
    the state if there is no match. The default is to leave the current parser.
    See Parser().
    
    """
    def parse(self, text, pos):
        """Match text at position pos and returns a Match Object or None."""
        return self.pattern.match(text, pos)
    
    def _follow(self, token, state):
        """(Internal) Called by State.follow().
        
        Falls through if the token can't have been generated by this parser.
        
        """
        if type(token) not in self.items:
            self.fallthrough(state)
            return True

    def fallthrough(self, state):
        """Called when no match is returned by parse().
        
        This implementation leaves the current parser and returns None
        (causing the State to continue parsing).
        
        """
        state.leave()


class Fridge(object):
    """Stores frozen States under an integer number."""
    def __init__(self, stateClass = State):
        self._stateClass = stateClass
        self._states = []
    
    def freeze(self, state):
        """Stores a state and return an identifying integer."""
        frozen = state.freeze()
        try:
            return self._states.index(frozen)
        except ValueError:
            i = len(self._states)
            self._states.append(frozen)
            return i

    def thaw(self, num):
        """Returns the state stored under the specified number."""
        if 0 <= num < len(self._states):
            return self._stateClass.thaw(self._states[num])

    def count(self):
        """Returns the number of stored frozen states."""
        return len(self._states)


def uniq(iterable):
    """Yields unique items from iterable."""
    seen, l = set(), 0
    for i in iterable:
        seen.add(i)
        if len(seen) > l:
            yield i
            l = len(seen)


if __name__ == "__main__":
    # test
    class Word(Token):
        rx = r'\w+'
    
    class Number(Token):
        rx = r'\d+'
    
    class String(Token):
        pass
    
    class StringStart(String):
        rx = '"'
        def update_state(self, state):
            state.enter(PString())
    
    class StringEnd(String):
        rx = '"'
        def update_state(self, state):
            state.leave()
    
    class PTest(Parser):
        items = (
            Number,
            Word,
            StringStart,
        )
    
    class PString(Parser):
        default = String
        items = (
            StringEnd,
        )
    
    s = State(PTest)
    print('test:')
    for t in s.tokens(
        'een tekst met 7 woorden, '
        'een "tekst met 2 aanhalingstekens" '
        'en 2 of 3 nummers'):
        print(t.__class__, t)

    print('test the Fridge:')
    s = State(PTest)
    f = Fridge()
    
    for t in s.tokens('text with "part of a '):
        print(t.__class__, t)
    
    n = f.freeze(s)
    
    # recover
    print('freeze and recover:')
    s = f.thaw(n)
    for t in s.tokens('quoted string" in the middle'):
        print(t.__class__, t)



########NEW FILE########
__FILENAME__ = actions
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Functions to access the built-in and user defined templates.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QAction

from . import snippets


def action(name, parent=None, collection=None):
    """Returns a QAction with text and icon for the given snippet name.

    Returns None is no such snippet is available.
    If collection is provided, it is used to set shortcuts to the action.
    """
    title = snippets.title(name)
    if not title:
        return
    a = QAction(parent)
    a.setObjectName(name)
    a.setText(title.replace('&', '&&'))
    icon = snippets.icon(name)
    if icon:
        a.setIcon(icon)
    if collection:
        shortcuts = collection.shortcuts(name)
        if shortcuts:
            a.setShortcuts(shortcuts)
    return a



########NEW FILE########
__FILENAME__ = builtin
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Builtin snippets.
"""

from __future__ import unicode_literals

try:
    import builtins # py3
except ImportError:
    import __builtin__ as builtins # py2

import collections

# postpone translation
_ = lambda *args: lambda: builtins._(*args)


T = collections.namedtuple("Template", "title text")


builtin_snippets = {

'blankline': T(_("Blank Line"),
r"""
$CURSOR
"""),


'removelines': T(_("Delete Line(s)"),
r"""-*- python;

import cursortools

def main():
    start = end = cursortools.block(cursor)
    while end.position() + end.length() < cursor.selectionEnd():
        end = end.next()
    cursor.setPosition(start.position())
    cursor.setPosition(end.position(), cursor.KeepAnchor)
    cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
    cursor.movePosition(cursor.NextBlock, cursor.KeepAnchor)
    cursor.removeSelectedText()

"""),


'remove_matching_pair': T(_("Delete Matching Pair"),
r"""-*- python; indent: no;

import cursortools
import matcher

def main():
    cursors = matcher.matches(cursor)
    if cursors:
        with cursortools.compress_undo(cursor):
            for c in cursors:
                c.removeSelectedText()

"""),


'next_blank_line': T(_("Next Blank Line"),
r"""-*- python; indent: no;

import cursortools

def main():
    block = cursortools.next_blank(cursor.block())
    if block:
        cursor.setPosition(block.position() + block.length() - 1)
        return cursor

"""),


'previous_blank_line': T(_("Previous Blank Line"),
r"""-*- python; indent: no;

import cursortools

def main():
    block = cursortools.previous_blank(cursor.block())
    if block:
        cursor.setPosition(block.position() + block.length() - 1)
        return cursor

"""),


'next_blank_line_select': T(_("Select until Next Blank Line"),
r"""-*- python; indent: no;

import cursortools

def main():
    block = cursortools.next_blank(cursor.block())
    if block:
        cursor.setPosition(block.position() + block.length() - 1, cursor.KeepAnchor)
        return cursor

"""),


'previous_blank_line_select': T(_("Select until Previous Blank Line"),
r"""-*- python; indent: no;

import cursortools

def main():
    block = cursortools.previous_blank(cursor.block())
    if block:
        cursor.setPosition(block.position() + block.length() - 1, cursor.KeepAnchor)
        return cursor

"""),


'quotes_s': T(_("Single Typographical Quotes"),
"""-*- menu: text;
\u2018$SELECTION\u2019"""),


'quotes_d': T(_("Double Typographical Quotes"),
"""-*- menu: text;
\u201C$SELECTION\u201D"""),


'voice1': T(None,
r"""-*- name: v1;
\voiceOne"""),


'voice2': T(None,
r"""-*- name: v2;
\voiceTwo"""),


'voice3': T(None,
r"""-*- name: v3;
\voiceThree"""),


'voice4': T(None,
r"""-*- name: v4;
\voiceFour"""),


'1voice': T(None,
r"""-*- name: 1v;
\oneVoice"""),


'stanza1': T(None,
r"""-*- name: s1;
\set stanza = "1."
"""),


'stanza2': T(None,
r"""-*- name: s2;
\set stanza = "2."
"""),


'stanza3': T(None,
r"""-*- name: s3;
\set stanza = "3."
"""),


'stanza4': T(None,
r"""-*- name: s4;
\set stanza = "4."
"""),


'stanza5': T(None,
r"""-*- name: s5;
\set stanza = "5."
"""),


'stanza6': T(None,
r"""-*- name: s6;
\set stanza = "6."
"""),


'times23': T(_("Tuplets"),
r"""-*- menu: blocks; selection: strip;
\times 2/3 { $SELECTION }"""),


'onceoverride': T(None,
r"""-*- name: oo;
\once \override """),


'm22': T(_("Modern 2/2 Time Signature"),
r"""-*- name: 22;
\numericTimeSignature
\time 2/2"""),


'm44': T(_("Modern 4/4 Time Signature"),
r"""-*- name: 44;
\numericTimeSignature
\time 4/4"""),


'tactus': T(_("Tactus Time Signature (number with note)"),
r"""-*- name: tac;
\once \override Staff.TimeSignature #'style = #'()
\once \override Staff.TimeSignature #'stencil = #ly:text-interface::print
\once \override Staff.TimeSignature #'text = \markup {
  \override #'(baseline-skip . 0.5)
  \column { \number $CURSOR1$ANCHOR \tiny \note #"2" #-.6 }
}
"""),


'ly_version': T(_("LilyPond Version"),
r"""-*- menu;
\version "$LILYPOND_VERSION"
"""),


'repeat': T(_("Repeat"),
r"""-*- menu: blocks; name: rep; selection: strip; symbol: bar_repeat_start;
\repeat volta 2 { $SELECTION }"""),


'relative': T(_("Relative Music"),
r"""-*- name: rel;
\relative c$CURSOR'$ANCHOR {
""" '  ' r"""  
}"""),


'score': T(None,
r"""-*- menu: blocks;
\score {
  $SELECTION
  \layout {}
  \midi {}
}
"""),


'uppercase': T(_("Upper case selection"),
r"""-*- python; selection: yes, keep;
text = text.upper()
"""),


'lowercase': T(_("Lower case selection"),
r"""-*- python; selection: yes, keep;
text = text.lower()
"""),


'titlecase': T(_("Title case selection"),
r"""-*- python; selection: yes, keep;
text = text.title()
"""),


'markup': T(_("Markup"),
r"""-*- name: m; selection: strip;
\markup { $SELECTION }"""),


'markup_lines_selection': T(_("Markup lines"),
r"""-*- name: l; python; selection: yes, keep, strip;
text = '\n'.join(r'\line { %s }' % l for l in text.splitlines())
if state[-1] != 'markup':
    text = '\\markup {\n%s\n}' % text
"""),


'markup_column': T(_("Markup column"),
r"""-*- name: c; selection: yes, keep, strip;
\column { $SELECTION }"""),


'tagline_date_version': T(_("Tagline with date and LilyPond version"),
r"""tagline = \markup {
  Engraved at
  \simple #(strftime "%Y-%m-%d" (localtime (current-time)))
  with \with-url #"http://lilypond.org/"
  \line { LilyPond \simple #(lilypond-version) (http://lilypond.org/) }
}
"""),


'header': T(_("Header Template"),
r"""-*- name: h; menu: blocks;
\header {
  title = "$CURSOR"
  composer = ""
  tagline = \markup {
    Engraved at
    \simple #(strftime "%Y-%m-%d" (localtime (current-time)))
    with \with-url #"http://lilypond.org/"
    \line { LilyPond \simple #(lilypond-version) (http://lilypond.org/) }
  }
}
"""),


'no_tagline': T(_("No Tagline"),
r"""-*- name: nt; python; menu: properties;
text = 'tagline = ##f'
if state[-1] != 'header':
    text = '\\header {\n%s\n}' % text
"""),


'no_barnumbers': T(_("No Barnumbers"),
r"""-*- name: nb; python; menu: properties;
text = r'\remove "Bar_number_engraver"'
if state[-1] not in ('context', 'with'):
    text = '\\context {\n\\Score\n%s\n}' % text
    if state[-1] != 'layout':
        text = '\\layout {\n%s\n}' % text
"""),


'midi_tempo': T(_("Midi Tempo"),
r"""-*- name: mt; python;
text = ['tempoWholesPerMinute = #(ly:make-moment ', CURSOR, '100 4)']
if state[-1] not in ('context', 'with'):
    text = ['\\context {\n\\Score\n'] + text + ['\n}']
    if state[-1] != 'midi':
        text = ['\\midi {\n'] + text + ['\n}']
"""),


'staff_size': T(_("Staff Size"),
r"""-*- name: ss; python;
if state[-1] == 'music':
    text = (
        "\\set Staff.fontSize = #-1\n"
        "\\override Staff.StaffSymbol #'staff-space = #(magstep -1)\n")
else:
    text = (
        "fontSize = #-1\n"
        "\\override StaffSymbol #'staff-space = #(magstep -1)")
    if state[-1] == 'new':
        text = '\\with {\n%s\n}' % text
    elif state[-1] not in ('context', 'with'):
        text = '\\context {\n\\Staff\n%s\n}' % text
        if state[-1] != 'layout':
            text = '\\layout {\n%s\n}' % text
"""),


'double': T(_("Double selection or current line"),
r"""-*- python; indent: no;
def main():
    if not cursor.hasSelection():
        while not cursor.block().text() or cursor.block().text().isspace():
            if not cursor.movePosition(cursor.PreviousBlock):
                break
        cursor.movePosition(cursor.StartOfBlock)
        if not cursor.movePosition(cursor.NextBlock, cursor.KeepAnchor):
            cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
            t = '\n' + cursor.selection().toPlainText() + '\n'
        else:
            t = cursor.selection().toPlainText()
    else:
        t = cursor.selection().toPlainText()
    cursor.movePosition(cursor.selectionEnd())
    cursor.clearSelection()
    cursor.insertText(t)
    if t.endswith('\n'):
        cursor.movePosition(cursor.Left)
    return cursor
"""),


'comment': T(_("Comment"),
r"""-*- python; indent: no;
# determine state
for s in state[::-1]:
    if s in ('lilypond', 'html', 'scheme'):
        break
else:
    s = 'lilypond'

def html():
    if text:
        return '<!-- ' + text + ' -->'
    else:
        return ['<!-- ', CURSOR, ' -->']

def lilypond():
    if '\n' in text:
        return '% ' + text.replace('\n', '\n% ')
    elif text:
        return '%{ ' + text + '%}'
    else:
        return '% '

def scheme():
    if text:
        return '; ' + text.replace('\n', '\n; ')
    else:
        return '; '

if s == 'lilypond':
    text = lilypond()
elif s == 'html':
    text = html()
elif s == 'scheme':
    text = scheme()
"""),


'uncomment': T(_("Uncomment"),
r"""-*- python; indent: no;
import re

# determine state
for s in state[::-1]:
    if s in ('lilypond', 'html', 'scheme'):
        break
else:
    s = 'lilypond'

def html(text):
    if text:
        text = text.replace('<!-- ', '')
        text = text.replace(' -->', '')
        text = text.replace('<!--', '')
        text = text.replace('-->', '')
        return text

def lilypond(text):
    if text.lstrip().startswith('%{'):
        if text.lstrip().startswith('%{ '):
            text = text.lstrip()[3:]
        else:
            text = text.lstrip()[2:]
        if text.rstrip().endswith('%}'):
            text = text.rstrip()[:-2]
    else:
        text = re.compile(r'^(\s*)%+ ?', re.M).sub(r'\1', text)
    return text

def scheme(text):
    return re.compile(r'^(\s*);+', re.M).sub(r'\1', text)

if s == 'lilypond':
    text = lilypond(text)
elif s == 'html':
    text = html(text)
elif s == 'scheme':
    text = scheme(text)
"""),


'paper_a5': T(_("A5 Paper"),
r"""-*- name: a5; python;
text = r'#(set-paper-size "a5")'
if state[-1] != 'paper':
    text = '\\paper {\n%s\n}' % text
"""),


'document_fonts': T(_("Document Fonts..."),
r"""-*- menu: paper; name: fo; python; icon: preferences-desktop-font;
snippet = '''\
fonts = #
(make-pango-font-tree
  "{roman}"
  "{sans}"
  "{typewriter}"
  (/ (* staff-height pt) 2.5))
'''

import globalfontdialog
dlg = globalfontdialog.GlobalFontDialog(view)
if dlg.exec_():
    text = snippet.format(
        roman = dlg.romanFont(),
        sans = dlg.sansFont(),
        typewriter = dlg.typewriterFont())
    if state[-1] != "paper":
        text = "\\paper {{\n{0}}}\n".format(text)

"""),


'last_note': T(_("Last note or chord"),
r"""-*- python; menu: music; symbol: note_4d;
# This snippet reads back the last entered note or chord and 
# inserts it again. It removes the octave mark from a note of the first
# note of a chord if the music is in relative mode.

import lydocument
import ly.lex.lilypond as lp

# space needed before cursor?
block = cursor.document().findBlock(cursor.selectionStart())
beforecursor = block.text()[:cursor.selectionStart()-block.position()]
spaceneeded = bool(beforecursor and beforecursor[-1] not in "\t ")

chordstart, chordend = None, None
notestart = None
relative = False
found = False

c = lydocument.cursor(cursor)
runner = lydocument.Runner.at(c, True)

for t in runner.backward():
    if t == '\\relative':
        relative = True
        break
    elif isinstance(t, (lp.Score, lp.Book, lp.BookPart, lp.Name)):
        break
    if found:
        continue
    if chordend is not None:
        if isinstance(t, lp.ChordStart):
            chordstart = runner.position()
            found = True
        continue
    if isinstance(t, lp.ChordEnd):
        chordend = runner.position() + len(t)
    elif isinstance(t, lp.Note) and t not in ('R' ,'q', 's', 'r'):
        notestart = runner.position()
        found = True

if found:
    if chordstart is not None:
        text = []
        removeOctave = 1 if relative else 0
        c.start, c.end = chordstart, chordend
        for t in lydocument.Source(c):
            # remove octave from first pitch in relative
            if isinstance(t, lp.Note):
                removeOctave -= 1
            elif isinstance(t, lp.Octave) and removeOctave == 0:
                continue
            text.append(t)
        text = ''.join(text)
    elif notestart is not None:
        text = []
        c.start, c.end = notestart, None
        for t in lydocument.Source(c):
            if isinstance(t, lp.Note):
                text.append(t)
            elif not relative and isinstance(t, lp.Octave):
                text.append(t)
            else:
                break
        text = ''.join(text)
    if spaceneeded:
        text = " " + text
"""),


'color_dialog': T(_("Color"),
r"""-*- name: col; python; icon: applications-graphics;

# Insert a color from a dialog


import inputdialog
colors = {
    (0, 0, 0): "black",
    (255, 255, 255): "white",
    (255, 0, 0): "red",
    (0, 255, 0): "green",
    (0, 0, 255): "blue",
    (0, 255, 255): "cyan",
    (255, 0, 255): "magenta",
    (255, 255, 0): "yellow",
    (128, 128, 128): "grey",
    (128, 0, 0): "darkred",
    (0, 128, 0): "darkgreen",
    (0, 0, 128): "darkblue",
    (0, 128, 128): "darkcyan",
    (128, 0, 128): "darkmagenta",
    (128, 128, 0): "darkyellow",
}

color = inputdialog.getColor(view)
if color is not None:
    rgb = color.getRgb()[:-1]

    if rgb in colors:
        text = '#' + colors[rgb]
    else:
        rgb = tuple(map(lambda v: format(v / 255.0, ".4"), rgb))
        text = "#(rgb-color {0} {1} {2})".format(*rgb)
"""),


'template_leadsheet': T(_("Basic Leadsheet"),
r"""-*- template; template-run;
\version "$LILYPOND_VERSION"

\header {
  title = ""
}

global = {
  \time 4/4
  \key c \major
  \tempo 4=100
}

chordNames = \chordmode {
  \global
  c1
  
}

melody = \relative c'' {
  \global
  c4 d e f
  $CURSOR
}

words = \lyricmode {
  
  
}

\score {
  <<
    \new ChordNames \chordNames
    \new FretBoards \chordNames
    \new Staff { \melody }
    \addlyrics { \words }
  >>
  \layout { }
  \midi { }
}
"""),


'template_choir_hymn': T(_("Choir Hymn"),
r"""-*- template; template-run;
\version "$LILYPOND_VERSION"

\header {
  title = ""
}

global = {
  \time 4/4
  \key c \major
  \tempo 4=100
}

soprano = \relative c'' {
  \global
  $CURSORc4
  
}

alto = \relative c' {
  \global
  c4
  
}

tenor = \relative c' {
  \global
  c4
  
}

bass = \relative c {
  \global
  c4
  
}

verseOne = \lyricmode {
  \set stanza = "1."
  hi
  
}

verseTwo = \lyricmode {
  \set stanza = "2."
  ha
  
}

verseThree = \lyricmode {
  \set stanza = "3."
  ho
  
}

\score {
  \new ChoirStaff <<
    \new Staff \with {
      midiInstrument = "choir aahs"
      instrumentName = \markup \center-column { S A }
    } <<
      \new Voice = "soprano" { \voiceOne \soprano }
      \new Voice = "alto" { \voiceTwo \alto }
    >>
    \new Lyrics \with {
      \override VerticalAxisGroup #'staff-affinity = #CENTER
    } \lyricsto "soprano" \verseOne
    \new Lyrics \with {
      \override VerticalAxisGroup #'staff-affinity = #CENTER
    } \lyricsto "soprano" \verseTwo
    \new Lyrics \with {
      \override VerticalAxisGroup #'staff-affinity = #CENTER
    } \lyricsto "soprano" \verseThree
    \new Staff \with {
      midiInstrument = "choir aahs"
      instrumentName = \markup \center-column { T B }
    } <<
      \clef bass
      \new Voice = "tenor" { \voiceOne \tenor }
      \new Voice = "bass" { \voiceTwo \bass }
    >>
  >>
  \layout { }
  \midi { }
}
"""),


}


########NEW FILE########
__FILENAME__ = completer
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2012 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The completer for the snippet editing dialog.
"""


from __future__ import unicode_literals

import keyword
import re

import app
import listmodel
import textformats
import widgets.completer

from . import snippets


class Completer(widgets.completer.Completer):
    def __init__(self, textedit):
        super(Completer, self).__init__()
        self.setWidget(textedit)
        self.setParent(textedit) # othw. PyQt4 looses us
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
    
    def readSettings(self):
        self.popup().setFont(textformats.formatData('editor').font)
        self.popup().setPalette(textformats.formatData('editor').palette())
 
    def completionCursor(self):
        cursor = self.textCursor()
        
        if self.popup().isVisible() and self._pos < cursor.position():
            cursor.setPosition(self._pos, cursor.KeepAnchor)
            return cursor
        
        # alter the model
        pos = cursor.position()
        text = cursor.document().toPlainText()
        
        # skip '-*- ' lines declaring variables, and check if it is python
        python = False
        block = cursor.document().firstBlock()
        start = 0
        while block.text().startswith('-*- '):
            if not python:
                python = any(True
                    for m in snippets._variables_re.finditer(block.text())
                    if m.group(1) == 'python')
            block = block.next()
            if not block.isValid():
                break
            start = block.position()
        
        # determine the word set to complete on
        if python:
            pattern = r'\w+'
        else:
            pattern = r'\\?[\w-]+'
        rx = re.compile(pattern)
        words = set(m.group() for m in rx.finditer(text, start)
                    if len(m.group()) > 4 and m.end() != pos)
        if python:
            words.update(keyword.kwlist)
            words.update(('cursor', 'state', 'text'))
        if words:
            self.setModel(listmodel.ListModel(sorted(words)))
            cursor.movePosition(cursor.StartOfWord, cursor.KeepAnchor)
            self._pos = cursor.position()
            return cursor



########NEW FILE########
__FILENAME__ = edit
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The dialog for editing a snippet
"""


from __future__ import unicode_literals

import re

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import actioncollectionmanager
import app
import qutil
import userguide
import homekey
import icons
import textformats
import wordboundary
import widgets.indenter
import widgets.matcher

from . import model
from . import snippets
from . import builtin
from . import expand
from . import highlight
from . import completer


class Edit(QDialog):
    """Dialog for editing a snippet. It is used for one edit.
    
    Use None as the name to create a new snippet. In that case, text
    is set as a default in the text edit.
    
    """
    def __init__(self, widget, name, text=""):
        super(Edit, self).__init__(widget)
        
        self._name = name

        layout = QVBoxLayout()
        self.setLayout(layout)
        
        self.topLabel = QLabel()
        self.text = QTextEdit(cursorWidth=2, acceptRichText=False)
        self.titleLabel = QLabel()
        self.titleEntry = QLineEdit()
        self.shortcutLabel = QLabel()
        self.shortcutButton = ShortcutButton(clicked=self.editShortcuts)
        
        layout.addWidget(self.topLabel)
        layout.addWidget(self.text)
        
        grid = QGridLayout()
        layout.addLayout(grid)
        
        grid.addWidget(self.titleLabel, 0, 0)
        grid.addWidget(self.titleEntry, 0, 1)
        grid.addWidget(self.shortcutLabel, 1, 0)
        grid.addWidget(self.shortcutButton, 1, 1)
        
        layout.addWidget(widgets.Separator())
        
        b = QDialogButtonBox(accepted=self.accept, rejected=self.reject)
        layout.addWidget(b)
        
        buttons = QDialogButtonBox.Ok | QDialogButtonBox.Cancel
        if name and name in builtin.builtin_snippets:
            b.setStandardButtons(buttons | QDialogButtonBox.RestoreDefaults)
            b.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.slotDefaults)
        else:
            b.setStandardButtons(buttons)
        userguide.addButton(b, "snippet_editor")
        
        # PyQt4.10 en sip4.14.5 delete the Highlighter, even though it is
        # constructed with a parent, that's why we save it in an unused attribute.
        self._highlighter = highlight.Highlighter(self.text.document())
        Matcher(self.text)
        widgets.indenter.Indenter(self.text)
        self.text.installEventFilter(homekey.handler)
        wordboundary.handler.install_textedit(self.text)
        completer.Completer(self.text)
        
        if name:
            self.titleEntry.setText(snippets.title(name, False) or '')
            self.text.setPlainText(snippets.text(name))
            ac = self.parent().parent().snippetActions
            self.setShortcuts(ac.shortcuts(name))
        else:
            self.text.setPlainText(text)
            self.setShortcuts(None)
        
        app.translateUI(self)
        
        self.readSettings()
        app.settingsChanged.connect(self.readSettings)
        qutil.saveDialogSize(self, "snippettool/editor/size", QSize(400, 300))
        self.show()
        
    def translateUI(self):
        title = _("Edit Snippet") if self._name else _("New Snippet")
        self.setWindowTitle(app.caption(title))
        self.topLabel.setText(_("Snippet Text:"))
        self.titleLabel.setText(_("Title:"))
        self.shortcutLabel.setText(_("Shortcut:"))
        self.shortcutButton.updateText()
    
    def done(self, result):
        if result:
            if not self.text.toPlainText():
                QMessageBox.warning(self,
                    _("Empty Snippet"),
                    _("A snippet can't be empty."))
                return
            self.saveSnippet()
        elif self.text.document().isModified():
            res = QMessageBox.warning(self, self.windowTitle(),
                _("The snippet has been modified.\n"
                  "Do you want to save your changes or discard them?"),
                QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel)
            if res == QMessageBox.Cancel:
                return
            elif res != QMessageBox.Discard:
                self.saveSnippet()
        super(Edit, self).done(result)

    def readSettings(self):
        data = textformats.formatData('editor')
        self.text.setFont(data.font)
        self.text.setPalette(data.palette())

    def shortcuts(self):
        return self.shortcutButton.shortcuts()
    
    def setShortcuts(self, shortcuts):
        self.shortcutButton.setShortcuts(shortcuts)
        
    def editShortcuts(self):
        from widgets import shortcuteditdialog
        ac = self.parent().parent().snippetActions
        action = QAction(None)
        if self._name:
            action.setShortcuts(self.shortcuts())
            action.setIcon(snippets.icon(self._name) or QIcon())
            default = ac.defaults().get(self._name)
            text = snippets.title(self._name)
        else:
            default = None
            text = self.titleEntry.text() or _("Untitled")
        action.setText(text.replace('&', '&&'))
        
        cb = self.actionManager().findShortcutConflict
        skip = (self.parent().parent().snippetActions, self._name)
        dlg = shortcuteditdialog.ShortcutEditDialog(self, cb, skip)
        
        if dlg.editAction(action, default):
            self.setShortcuts(action.shortcuts())
    
    def saveSnippet(self):
        index = model.model().saveSnippet(self._name,
            self.text.toPlainText(), self.titleEntry.text())
        # set snippet current in the editor that called us
        self.parent().treeView.selectionModel().setCurrentIndex(
            index, QItemSelectionModel.SelectCurrent | QItemSelectionModel.Rows)
        #remove the shortcuts conflicts
        self.actionManager().removeShortcuts(self.shortcuts())
        self.parent().treeView.update()
        # get the name that was used
        name = model.model().name(index)
        self.parent().parent().snippetActions.setShortcuts(name, self.shortcuts())
        self.text.document().setModified(False)

    def actionManager(self):
        mainwindow = self.parent().parent().mainwindow()
        return actioncollectionmanager.manager(mainwindow)

    def slotDefaults(self):
        t = builtin.builtin_snippets[self._name]
        self.text.setPlainText(t.text)
        self.titleEntry.setText(t.title() if t.title else '')
        self.setShortcuts(self.parent().parent().snippetActions.defaults().get(self._name))


class ShortcutButton(QPushButton):
    def __init__(self, **args):
        super(ShortcutButton, self).__init__(**args)
        self.setIcon(icons.get("preferences-desktop-keyboard-shortcuts"))
        self._shortcuts = []
        
    def shortcuts(self):
        return self._shortcuts
    
    def setShortcuts(self, shortcuts):
        self._shortcuts = shortcuts or []
        self.updateText()
        
    def updateText(self):
        if not self._shortcuts:
            self.setText(_("None"))
        else:
            key = self._shortcuts[0].toString(QKeySequence.NativeText)
            if len(self._shortcuts) > 1:
                key += "..."
            self.setText(key.replace('&', '&&'))
        self.setToolTip(_("Click to change the keyboard shortcut."))


class Matcher(widgets.matcher.Matcher):
    def __init__(self, edit):
        super(Matcher, self).__init__(edit)
        self.readSettings()
        app.settingsChanged.connect(self.readSettings)
    
    def readSettings(self):
        self.format = QTextCharFormat()
        self.format.setBackground(textformats.formatData('editor').baseColors['match'])



########NEW FILE########
__FILENAME__ = expand
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Expand variables like $DATE, $LILYPOND_VERSION etc. in snippets. 
"""

from __future__ import unicode_literals

try:
    import builtins # py3
except ImportError:
    import __builtin__ as builtins # py2

import time

import info
import lilypondinfo


def _(docstring):
    """Returns a decorator.
    
    The decorator gives a function a doc() method, returning the translated docstring.
    The untranslated docstring will be added as __doc__ to the function.
    
    builtins._ is expected to be the translation function.
    
    We use the underscore as function name so xgettext picks up the strings
    to be translated.
    
    """
    def deco(f):
        f.__doc__ = docstring
        f.doc = lambda: builtins._(docstring)
        return f
    return deco
    

def documentation(cls):
    """Yields tuples documenting the methods of the specified class.
    
    The tuples are: (function_name, docstring). The docstrings are translated.
    The tuples are sorted on function_name.
    
    """
    for name, meth in sorted(cls.__dict__.items()):
        if name.startswith('_'):
            return
        yield name, meth.doc()


ANCHOR, CURSOR, SELECTION = constants = 1, 2, 3 # just some constants

class Expander(object):
    """Expands variables.
    
    The methods return text or other events (currently simply integer constants).
    
    """
    def __init__(self, cursor):
        self.cursor = cursor
    
    @_("The current date in YYYY-MM-DD format.")
    def DATE(self):
        return time.strftime('%Y-%m-%d')

    @_("The version of the default LilyPond program.")
    def LILYPOND_VERSION(self):
        return lilypondinfo.preferred().versionString()

    @_("The version of Frescobaldi.")
    def FRESCOBALDI_VERSION(self):
        return info.version
    
    @_("The URL of the current document.")
    def URL(self):
        return self.cursor.document().url().toString()
    
    @_("The full local filename of the current document.")
    def FILE_NAME(self):
        return self.cursor.document().url().toLocalFile()
    
    @_("The name of the current document.")
    def DOCUMENT_NAME(self):
        return self.cursor.document().documentName()

    @_("Moves the text cursor here after insert.")
    def CURSOR(self):
        return CURSOR
        
    @_("Selects text from here to the position given using the <code>$CURSOR</code> variable")
    def ANCHOR(self):
        return ANCHOR
    
    @_("The selected text if available. If not, the text cursor is moved here.")
    def SELECTION(self):
        return SELECTION if self.cursor.hasSelection() else CURSOR



########NEW FILE########
__FILENAME__ = highlight
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Highlighter for the snippet editor and view.
"""

from __future__ import unicode_literals

try:
    import builtins # py3
except ImportError:
    import __builtin__ as builtins # py2

import keyword

from PyQt4.QtGui import QSyntaxHighlighter

import slexer

import app
import textformats

from . import snippets


class Highlighter(QSyntaxHighlighter):
    
    def __init__(self, document):
        super(Highlighter, self).__init__(document)
        self.python = None
        self._fridge = slexer.Fridge()
        self.readSettings()
        app.settingsChanged.connect(self.readSettingsAgain)
        
    def readSettings(self):
        self._styles = textformats.formatData('editor').defaultStyles
        
    def readSettingsAgain(self):
        self.readSettings()
        self.rehighlight()
        
    def setPython(self, python):
        """Force Python or generic snippet highlighting.
        
        Use True for Python, False for Snippet, or None to let the highlighter
        decide based on the variable lines.
        
        """
        if self.python is not python:
            self.python = python
            self.rehighlight()
    
    def highlightBlock(self, text):
        prev = self.previousBlockState()
        python = self.python if self.python is not None else prev == -2
        if text.startswith('-*- '):
            # the line defines variables, highlight them and check if 'python' is defined
            self.setFormat(0, 3, self._styles['keyword'])
            for m in snippets._variables_re.finditer(text):
                self.setFormat(m.start(1), m.end(1)-m.start(1), self._styles['variable'])
                if m.group(2):
                    self.setFormat(m.start(2), m.end(2)-m.start(2), self._styles['value'])
                python = python or m.group(1) == 'python'
            self.setCurrentBlockState(-2 if python else -1)
        else:
            # we are in the snippet text
            state = self._fridge.thaw(prev) or slexer.State(Python if python else Snippet)
            for t in state.tokens(text):
                if isinstance(t, Stylable):
                    self.setFormat(t.pos, len(t), self._styles[t.style])
            self.setCurrentBlockState(self._fridge.freeze(state))


# Basic types:
class Stylable(slexer.Token):
    """A token type with style ;-) to highlight."""
    style = '<set style here>'

class String(Stylable):
    style = 'string'

class Comment(Stylable):
    style = 'comment'

class Escape(Stylable):
    style = 'escape'

class Function(Stylable):
    style = 'function'

class Keyword(Stylable):
    style = 'keyword'

class Variable(Stylable):
    style = 'variable'

class Value(Stylable):
    style = 'value'


# Snippet types:

class StringStart(String):
    rx = '"'
    def update_state(self, state):
        state.enter(StringParser())

class StringEnd(StringStart):
    def update_state(self, state):
        state.leave()

class StringEscape(Escape):
    rx = r'\\["\\]'

class Expansion(Escape):
    rx = snippets._expansions_re.pattern
    
# Python types:

class PyKeyword(Keyword):
    rx = r"\b({0})\b".format('|'.join(keyword.kwlist))

class PyBuiltin(Function):
    rx = r"\b({0})\b".format('|'.join(builtins.__dict__))

class PyStringStartDQ1(String):
    rx = '[uUbB]?"'
    def update_state(self, state):
        state.enter(PyStringParserDQ1())

class PyStringStartDQ3(String):
    rx = '[uUbB]?"""'
    def update_state(self, state):
        state.enter(PyStringParserDQ3())

class PyStringStartSQ1(String):
    rx = "[uUbB]?'"
    def update_state(self, state):
        state.enter(PyStringParserSQ1())

class PyStringStartSQ3(String):
    rx = "[uUbB]?'''"
    def update_state(self, state):
        state.enter(PyStringParserSQ3())

class PyStringStartDQ1R(String):
    rx = '[uUbB]?[rR]"'
    def update_state(self, state):
        state.enter(PyStringParserDQ1R())

class PyStringStartDQ3R(String):
    rx = '[uUbB]?[rR]"""'
    def update_state(self, state):
        state.enter(PyStringParserDQ3R())

class PyStringStartSQ1R(String):
    rx = "[uUbB]?[rR]'"
    def update_state(self, state):
        state.enter(PyStringParserSQ1R())

class PyStringStartSQ3R(String):
    rx = "[uUbB]?[rR]'''"
    def update_state(self, state):
        state.enter(PyStringParserSQ3R())

class PyStringEndDQ1(StringEnd):
    rx = '"'

class PyStringEndDQ3(StringEnd):
    rx = '"""'

class PyStringEndSQ1(StringEnd):
    rx = "'"

class PyStringEndSQ3(StringEnd):
    rx = "'''"

class PyStringEscape(Escape):
    rx = (
        r"""\\([\\'"abfnrtv]"""
        r'|[0-7]{3}|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8}'
        r'|N\{[A-Z]+( [A-Z]+)*\})'
    )

class PyStringEscapedNewline(Escape):
    """Highlights escaped newline."""
    rx = r'\\$'

class PyStringDoubleBackslashAtLineEnd(PyStringEscape):
    """Use this to leave a string at line end. Prevents staying in PyStringEOL."""
    rx = r'\\\\$'
    def update_state(self, state):
        state.leave()

class PyStringDoubleBackslashAtLineEndR(String):
    """Use this to leave a string at line end in raw. Prevents staying in PyStringEOL."""
    rx = r'\\\\$'
    def update_state(self, state):
        state.leave()

class PyStringEOL(slexer.Token):
    """Leaves a string at unescaped Newline."""
    rx = r'(?<!\\)$'
    def update_state(self, state):
        state.leave()

class PyComment(Comment):
    rx = "#"
    def update_state(self, state):
        state.enter(PyCommentParser())

class LineEnd(slexer.Token):
    """Newline to leave context."""
    rx = r'$'
    def update_state(self, state):
        state.leave()

class PyIdentifier(slexer.Token):
    rx = r"\b[^\W\d]\w+"

class PySpecialVariable(Variable):
    rx = r"\b(self|state|cursor|text|view|ANCHOR|CURSOR)\b"

class PyValue(Value):
    rx = (
        "(0[bB][01]+|0[oO][0-7]+|0[xX][0-9A-Fa-f]+|\d+)[lL]?"
        "|(\d+\.\d*|\.\d+)([eE][+-]?\d+)?"
    )

# Parsers, many because of complicated string quote types in Python
class StringParser(slexer.Parser):
    default = String
    items = (
        StringEnd,
        StringEscape,
        Expansion,
    )

class Python(slexer.Parser):
    items = (
        PyKeyword,
        PyBuiltin,
        PySpecialVariable,
        PyIdentifier,
        PyValue,
        PyStringStartDQ3,
        PyStringStartDQ1,
        PyStringStartSQ3,
        PyStringStartSQ1,
        PyStringStartDQ3R,
        PyStringStartDQ1R,
        PyStringStartSQ3R,
        PyStringStartSQ1R,
        PyComment,
    )

class PyStringParserDQ1(StringParser):
    """Parses string with one double quote."""
    items = (
        PyStringDoubleBackslashAtLineEnd,
        PyStringEscape,
        PyStringEscapedNewline,
        PyStringEOL,
        PyStringEndDQ1,
    )

class PyStringParserDQ3(StringParser):
    """Parses string with three double quotes."""
    items = (
        PyStringEscape,
        PyStringEscapedNewline,
        PyStringEndDQ3,
    )

class PyStringParserSQ1(StringParser):
    """Parses string with one single quote."""
    items = (
        PyStringDoubleBackslashAtLineEnd,
        PyStringEscape,
        PyStringEscapedNewline,
        PyStringEOL,
        PyStringEndSQ1,
    )

class PyStringParserSQ3(StringParser):
    """Parses string with three single quotes."""
    items = (
        PyStringEscape,
        PyStringEscapedNewline,
        PyStringEndSQ3,
    )

class PyStringParserDQ1R(StringParser):
    """Parses raw string with one double quote."""
    items = (
        PyStringDoubleBackslashAtLineEndR,
        PyStringEscapedNewline,
        PyStringEOL,
        PyStringEndDQ1,
    )

class PyStringParserDQ3R(StringParser):
    """Parses raw string with three double quotes."""
    items = (
        PyStringEscapedNewline,
        PyStringEndDQ3,
    )

class PyStringParserSQ1R(StringParser):
    """Parses raw string with one single quote."""
    items = (
        PyStringDoubleBackslashAtLineEndR,
        PyStringEscapedNewline,
        PyStringEOL,
        PyStringEndSQ1,
    )

class PyStringParserSQ3R(StringParser):
    """Parses raw string with three single quotes."""
    items = (
        PyStringEscapedNewline,
        PyStringEndSQ3,
    )

class PyCommentParser(slexer.Parser):
    """Parses comment."""
    default = Comment
    items = (
        LineEnd,
    )

class Snippet(slexer.Parser):
    """Just parses simple double-quoted string and dollar-sign expansions."""
    items = (
        StringStart,
        Expansion,
    )



########NEW FILE########
__FILENAME__ = import_export
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Import and export of snippets.
"""

from __future__ import unicode_literals

import os

try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import info
import qutil
import userguide
import widgets.dialog

from . import model
from . import snippets
from . import builtin


def save(names, filename):
    """Saves the named snippets to a file."""
    root = ET.Element('snippets')
    root.text = '\n\n'
    root.tail = '\n'
    d = ET.ElementTree(root)
    
    comment = ET.Comment(_comment.format(info=info))
    comment.tail = '\n\n'
    root.append(comment)
    
    for name in names:
        snippet = ET.Element('snippet')
        snippet.set('id', name)
        snippet.text = '\n'
        snippet.tail = '\n\n'
        
        title = ET.Element('title')
        title.text = snippets.title(name, False)
        title.tail = '\n'
        
        shortcuts = ET.Element('shortcuts')
        ss = model.shortcuts(name)
        if ss:
            shortcuts.text = '\n'
            for s in ss:
                shortcut = ET.Element('shortcut')
                shortcut.text = s.toString()
                shortcut.tail = '\n'
                shortcuts.append(shortcut)
        shortcuts.tail = '\n'
        
        body = ET.Element('body')
        body.text = snippets.text(name)
        body.tail = '\n'
        
        snippet.append(title)
        snippet.append(shortcuts)
        snippet.append(body)
        root.append(snippet)
    d.write(filename, "UTF-8")


def load(filename, widget):
    """Loads snippets from a file, displaying them in a list.
    
    The user can then choose:
    - overwrite builtin snippets or not
    - overwrite own snippets with same title or not
    - select and view snippets contents.
    
    """
    try:
        d = ET.parse(filename)
        elements = list(d.findall('snippet'))
        if not elements:
            raise ValueError(_("No snippets found."))
    except Exception as e:
        QMessageBox.critical(widget, app.caption(_("Error")),
        _("Can't read from source:\n\n{url}\n\n{error}").format(
            url=filename, error=e))
        return


    dlg = widgets.dialog.Dialog(widget)
    dlg.setWindowModality(Qt.WindowModal)
    dlg.setWindowTitle(app.caption(_("dialog title", "Import Snippets")))
    tree = QTreeWidget(headerHidden=True, rootIsDecorated=False)
    dlg.setMainWidget(tree)
    userguide.addButton(dlg.buttonBox(), "snippet_import_export")
    
    allnames = frozenset(snippets.names())
    builtins = frozenset(builtin.builtin_snippets)
    titles = dict((snippets.title(n), n) for n in allnames if n not in builtins)
    
    new = QTreeWidgetItem(tree, [_("New Snippets")])
    updated = QTreeWidgetItem(tree, [_("Updated Snippets")])
    unchanged = QTreeWidgetItem(tree, [_("Unchanged Snippets")])
    
    new.setFlags(Qt.ItemIsEnabled)
    updated.setFlags(Qt.ItemIsEnabled)
    unchanged.setFlags(Qt.ItemIsEnabled)
    
    new.setExpanded(True)
    updated.setExpanded(True)
    
    items = []
    for snip in elements:
        item = QTreeWidgetItem()
        
        item.body = snip.find('body').text
        item.title = snip.find('title').text
        item.shortcuts = list(e.text for e in snip.findall('shortcuts/shortcut'))
        
        title = item.title or snippets.maketitle(snippets.parse(item.body).text)
        item.setText(0, title)
        
        name = snip.get('id')
        name = name if name in builtins else None
        
        
        # determine if new, updated or unchanged
        if not name:
            name = titles.get(title)
        item.name = name
        
        if not name or name not in allnames:
            new.addChild(item)
            items.append(item)
            item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsUserCheckable)
            item.setCheckState(0, Qt.Checked)
        elif name:
            if (item.body != snippets.text(name)
                or title != snippets.title(name)
                or (item.shortcuts and item.shortcuts != 
                    [s.toString() for s in model.shortcuts(name) or ()])):
                updated.addChild(item)
                items.append(item)
                item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsUserCheckable)
                item.setCheckState(0, Qt.Checked)
            else:
                unchanged.addChild(item)
                item.setFlags(Qt.ItemIsEnabled)
    # count:
    for i in new, updated, unchanged:
        i.setText(0, i.text(0) + " ({0})".format(i.childCount()))
    for i in new, updated:
        if i.childCount():
            i.setFlags(Qt.ItemIsEnabled | Qt.ItemIsUserCheckable)
            i.setCheckState(0, Qt.Checked)
    
    def changed(item):
        if item in (new, updated):
            for i in range(item.childCount()):
                c = item.child(i)
                c.setCheckState(0, item.checkState(0))
            
    tree.itemChanged.connect(changed)
    
    importShortcuts = QTreeWidgetItem([_("Import Keyboard Shortcuts")])
    if items:
        tree.addTopLevelItem(importShortcuts)
        importShortcuts.setFlags(Qt.ItemIsEnabled | Qt.ItemIsUserCheckable)
        importShortcuts.setCheckState(0, Qt.Checked)
        dlg.setMessage(_("Choose which snippets you want to import:"))
    else:
        dlg.setMessage(_("There are no new or updated snippets in the file."))
        unchanged.setExpanded(True)
    
    tree.setWhatsThis(_(
        "<p>Here the snippets from {filename} are displayed.</p>\n"
        "<p>If there are new or updated snippets, you can select or deselect "
        "them one by one, or all at once, using the checkbox of the group. "
        "Then click OK to import all the selected snippets.</p>\n"
        "<p>Existing, unchanged snippets can't be imported.</p>\n"
        ).format(filename=os.path.basename(filename)))
        
    qutil.saveDialogSize(dlg, "snippettool/import/size", QSize(400, 300))
    if not dlg.exec_() or not items:
        return
    ac = model.collection()
    m = model.model()
    with qutil.busyCursor():
        for i in items:
            if i.checkState(0) == Qt.Checked:
                index = m.saveSnippet(i.name, i.body, i.title)
                if i.shortcuts and importShortcuts.checkState(0):
                    shortcuts = list(map(QKeySequence.fromString, i.shortcuts))
                    ac.setShortcuts(m.name(index), shortcuts)
        widget.updateColumnSizes()


_comment = """
  Created by {info.appname} {info.version}.
  
  Every snippet is represented by:
    title:      title text
    shortcuts:  list of shortcut elements, every shortcut is a key sequence
    body:       the snippet text
  
  The snippet id attribute can be the name of a builtin snippet or a random
  name like 'n123456'. In the latter case, the title is used to determine
  whether a snippet is new or updated.
"""



########NEW FILE########
__FILENAME__ = insert
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Insert snippets into a Document.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSettings
from PyQt4.QtGui import QTextCursor, QMessageBox

import cursortools
import tokeniter
import indent

from . import snippets
from . import expand


def insert(name, view):
    """Insert named snippet into the view."""
    text, variables = snippets.get(name)
    cursor = view.textCursor()
    
    selection = variables.get('selection', '')
    if 'yes' in selection and not cursor.hasSelection():
        return
    if 'strip' in selection:
        cursortools.strip_selection(cursor)
    
    pos = cursor.selectionStart()
    with cursortools.compress_undo(cursor):
        
        # insert the snippet, might return a new cursor
        if 'python' in variables:
            new = insert_python(text, cursor, name, view)
        else:
            new = insert_snippet(text, cursor, variables)
        
    # QTextBlocks the snippet starts and ends
    block = cursor.document().findBlock(pos)
    last = cursor.block()
    
    # re-indent if not explicitly suppressed by a 'indent: no' variable
    if last != block and 'no' not in variables.get('indent', ''):
        c = QTextCursor(last)
        c.setPosition(block.position(), QTextCursor.KeepAnchor)
        with cursortools.compress_undo(c, True):
            indent.re_indent(c, True)
    
    if not new and 'keep' in selection:
        end = cursor.position()
        cursor.setPosition(pos)
        cursor.setPosition(end, QTextCursor.KeepAnchor)
    view.setTextCursor(new or cursor)


def insert_snippet(text, cursor, variables):
    """Inserts a normal text snippet.
    
    After the insert, the cursor points to the end of the inserted snippet.
    
    If this function returns a cursor it must be set as the cursor for the view
    after the snippet has been inserted.
    
    """
    exp_base = expand.Expander(cursor)
    
    evs = [] # make a list of events, either text or a constant
    for text, key in snippets.expand(text):
        if text:
            evs.append(text)
        if key == '$':
            evs.append('$')
        elif key:
            # basic variables
            func = getattr(exp_base, key, None)
            if func:
                evs.append(func())
    
    selectionUsed = expand.SELECTION in evs
    # do the padding if 'selection: strip;' is used
    if selectionUsed and 'strip' in variables.get('selection', ''):
        space = '\n' if '\n' in cursor.selection().toPlainText() else ' '
        # change whitespace in previous and next piece of text
        i = evs.index(expand.SELECTION)
        for j in range(i-1, -i, -1):
            if evs[j] not in expand.constants:
                evs[j] = evs[j].rstrip() + space
                break
        for j in range(i+1, len(evs)):
            if evs[j] not in expand.constants:
                evs[j] = space + evs[j].lstrip()
                break
    # now insert the text
    ins = QTextCursor(cursor)
    selectionUsed and ins.setPosition(cursor.selectionStart())
    a, c = -1, -1
    for e in evs:
        if e == expand.ANCHOR:
            a = ins.position()
        elif e == expand.CURSOR:
            c = ins.position()
        elif e == expand.SELECTION:
            ins.setPosition(cursor.selectionEnd())
        else:
            ins.insertText(e)
    cursor.setPosition(ins.position())
    # return a new cursor if requested
    if (a, c) != (-1, -1):
        new = QTextCursor(cursor)
        if a != -1:
            new.setPosition(a)
        if c != -1:
            new.setPosition(c, QTextCursor.KeepAnchor if a != -1 else QTextCursor.MoveAnchor)
        return new


def insert_python(text, cursor, name, view):
    """Regards the text as Python code, and exec it.
    
    name and view are given in case an exception occurs.
    
    The following variables are available:
    
    - text: contains selection or '', set it to insert new text
    - state: contains simplestate for the cursor position
    - cursor: the QTextCursor

    After the insert, the cursor points to the end of the inserted snippet.
    
    """
    namespace = {
        'cursor': QTextCursor(cursor),
        'state': state(cursor),
        'text': cursor.selection().toPlainText(),
        'view': view,
        'ANCHOR': 1,
        'CURSOR': 2,
    }
    try:
        code = compile(text, "<snippet>", "exec")
        exec code in namespace
        if 'main' in namespace:
            return namespace['main']()
    except Exception:
        handle_exception(name, view)
    else:
        text = namespace.get('text', '')
        if isinstance(text, (tuple, list)):
            ANCHOR = namespace.get('ANCHOR', 1)
            CURSOR = namespace.get('CURSOR', 2)
            a, c = -1, -1
            for t in text:
                if t == ANCHOR:
                    a = cursor.selectionStart()
                elif t == CURSOR:
                    c = cursor.selectionStart()
                else:
                    cursor.insertText(t)
            if (a, c) != (-1, -1):
                new = QTextCursor(cursor)
                if a != -1:
                    new.setPosition(a)
                if c != -1:
                    new.setPosition(c, QTextCursor.KeepAnchor if a != -1 else QTextCursor.MoveAnchor)
                return new
        else:
            cursor.insertText(namespace['text'])


def state(cursor):
    """Returns the simplestate string for the position of the cursor."""
    import simplestate
    pos = cursor.selectionStart()
    block = cursor.document().findBlock(pos)
    tokens = tokeniter.tokens(block)
    state = tokeniter.state(block)
    column = pos - block.position()
    for t in tokens:
        if t.end > column:
            break
        state.follow(t)
    return simplestate.state(state)


def handle_exception(name, view):
    """Called when a snippet raises a Python exception.
    
    Shows the error message and offers the option to edit the offending snippet.
    
    """
    import sys, traceback
    exc_type, exc_value, exc_traceback = sys.exc_info()
    tb = traceback.extract_tb(exc_traceback)
    while tb and tb[0][0] != "<snippet>":
        del tb[0]
    msg = ''.join(traceback.format_list(tb) +
                    traceback.format_exception_only(exc_type, exc_value))
    dlg = QMessageBox(QMessageBox.Critical, _("Snippet error"), msg,
        QMessageBox.Ok | QMessageBox.Cancel)
    dlg.button(QMessageBox.Ok).setText(_("Edit Snippet"))
    dlg.setDefaultButton(QMessageBox.Cancel)
    dlg.setEscapeButton(QMessageBox.Cancel)
    if dlg.exec_() != QMessageBox.Ok:
        return
    
    # determine line number
    if exc_type is SyntaxError:
        lineno = exc_value.lineno
    elif tb:
        lineno = tb[0][1]
    else:
        lineno = None
    
    import panelmanager
    from . import edit
    widget = panelmanager.manager(view.window()).snippettool.widget()
    textedit = edit.Edit(widget, name).text
    if lineno is not None:
        # convert to line number in full snippet text
        for block in cursortools.all_blocks(textedit.document()):
            if block.text().startswith('-*- '):
                lineno += 1
            else:
                break
        block = textedit.document().findBlockByNumber(lineno-1)
        if block.isValid():
            textedit.setTextCursor(QTextCursor(block))



########NEW FILE########
__FILENAME__ = menu
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Place snippets in menu.

If a snippet defines the variable 'menu' it is placed in the menu, sorted
on its internal action name and grouped by the value of the 'menu' variable.

If a snippet defines the variable 'template' it is placed in File->New from
template, sorted on its action name and grouped by the value of the 'template'
variable.

TODO:
- provide submenus
- caching (keep actions alive?)

"""

from __future__ import unicode_literals

from PyQt4.QtCore import Qt, QUrl
from PyQt4.QtGui import QMenu

import app
import document
import qutil
import panelmanager


class SnippetMenu(QMenu):
    def __init__(self, parent=None):
        super(SnippetMenu, self).__init__(parent)
        self.aboutToShow.connect(self.populate)
        self.aboutToHide.connect(self.clearMenu, Qt.QueuedConnection)
        self.triggered.connect(self.slotTriggered)
        app.translateUI(self)
        
    def mainwindow(self):
        return self.parent().window()
    
    def tool(self):
        """Returns the snippets tool."""
        return panelmanager.manager(self.mainwindow()).snippettool
    
    def populate(self):
        """Populates the menu with snippet actions."""
        self.clearMenu() # on some systems aboutToHide does not fire...
        from . import model, snippets, actions
        last = self.insertBeforeAction()
        shortcuts = self.tool().snippetActions
        groups = {}
        for name in sorted(model.model().names()):
            variables = snippets.get(name).variables
            group = self.snippetGroup(variables)
            if group:
                action = actions.action(name, self.mainwindow(), shortcuts)
                self.visitAction(action, variables)
                groups.setdefault(group, []).append(action)
        for group in sorted(groups):
            for action in groups[group]:
                self.insertAction(last, action)
            self.insertSeparator(last)
        qutil.addAccelerators(self.actions())
        
    def insertBeforeAction(self):
        """Should return an action to insert out stuff before, or None."""
        return None
    
    def snippetGroup(self, variables):
        """Should a group name if the snippet is to appear in the menu."""
    
    def visitAction(self, action, variables):
        """May change the action depending on variables."""
        
    def clearMenu(self):
        """Should delete the inserted actions."""
        for a in self.actions():
            self.removeAction(a)
            a.deleteLater()
    
    def slotTriggered(self, action):
        """Called when an action is triggered."""
        name = action.objectName()
        if name:
            self.applySnippet(name)

    def applySnippet(self, name):
        """Applies the named snippet."""
        from . import insert
        view = self.mainwindow().currentView()
        view.setFocus()
        insert.insert(name, view)


class InsertMenu(SnippetMenu):
    def __init__(self, parent=None):
        super(InsertMenu, self).__init__(parent)
        self.addAction(self.tool().actionCollection.snippettool_activate)
        
    def translateUI(self):
        self.setTitle(_("menu title", "&Insert"))
    
    def insertBeforeAction(self):
        return self.actions()[-1]
    
    def snippetGroup(self, variables):
        return variables.get('menu')
    
    def visitAction(self, action, variables):
        if 'yes' in variables.get('selection', ''):
            action.setEnabled(self.mainwindow().hasSelection())
    
    def clearMenu(self):
        """Deletes the actions on menu hide, excepts the "Snippets..." action."""
        for a in self.actions()[:-1]:
            self.removeAction(a)
            a.deleteLater()


class TemplateMenu(SnippetMenu):
    def __init__(self, parent=None):
        super(TemplateMenu, self).__init__(parent)
        self.addAction(self.tool().actionCollection.templates_manage)
        
    def translateUI(self):
        self.setTitle(_("New from &Template"))
    
    def insertBeforeAction(self):
        return self.actions()[-1]
    
    def snippetGroup(self, variables):
        return variables.get('template')
    
    def applySnippet(self, name):
        d = app.openUrl(QUrl())
        self.mainwindow().setCurrentDocument(d)
        super(TemplateMenu, self).applySnippet(name)
        d.setUndoRedoEnabled(False)
        d.setUndoRedoEnabled(True) # d.clearUndoRedoStacks() only in Qt >= 4.7
        d.setModified(False)
        from . import snippets
        if 'template-run' in snippets.get(name).variables:
            import engrave
            engrave.engraver(self.mainwindow()).engrave('preview', d)
    
    def clearMenu(self):
        """Deletes the actions on menu hide, except "Manage templates..."."""
        for a in self.actions()[:-1]:
            self.removeAction(a)
            a.deleteLater()



########NEW FILE########
__FILENAME__ = model
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The model containing the snippets data.
"""


from __future__ import unicode_literals

import bisect

from PyQt4.QtCore import QAbstractItemModel, QModelIndex, Qt
from PyQt4.QtGui import QKeySequence

import app
import actioncollection

from . import snippets


def model():
    """Returns the global model containing snippets."""
    m = SnippetModel(app.qApp)
    global model
    model = lambda: m
    return m


class SnippetModel(QAbstractItemModel):
    """Presents the snippets as a Qt Model."""
    def __init__(self, parent = None):
        super(SnippetModel, self).__init__(parent)
        self._names = []
        self.load()
        app.settingsChanged.connect(self.slotSettingsChanged)
        app.languageChanged.connect(self.slotLanguageChanged)
        
    # methods needed to be a well-behaved model
    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            if section == 0:
                return _("Name")
            elif section == 1:
                return _("Description")
            else:
                return _("Shortcut")
    
    def index(self, row, column, parent=None):
        return self.createIndex(row, column)
    
    def parent(self, index):
        return QModelIndex()
    
    def columnCount(self, parent=QModelIndex()):
        return 3 if not parent.isValid() else 0
    
    def rowCount(self, parent=QModelIndex()):
        return len(self._names) if not parent.isValid() else 0
    
    def data(self, index, role=Qt.DisplayRole):
        name = self.name(index)
        if role == Qt.DisplayRole:
            if index.column() == 0:
                return snippets.get(name).variables.get('name')
            elif index.column() == 1:
                return snippets.title(name)
            else:
                return shortcut(name)
        elif role == Qt.DecorationRole and index.column() == 1:
            return snippets.icon(name)
    
    # slots
    def slotSettingsChanged(self):
        """Called when settings change, e.g. when keyboard shortcuts are altered."""
        self.load()
        
    def slotLanguageChanged(self):
        """Called when the user changes the language."""
        self.headerDataChanged.emit(Qt.Horizontal, 0, 2)
        
    def load(self):
        self.beginResetModel()
        self._names = sorted(snippets.names(), key=snippets.title)
        self.endResetModel()
    
    # interface for getting/altering snippets
    def names(self):
        """Returns the internal list of snippet names in title order. Do not alter!"""
        return self._names
        
    def name(self, index):
        """The internal snippet id for the given QModelIndex."""
        return self._names[index.row()]

    def removeRows(self, row, count, parent=QModelIndex()):
        end = row + count
        self.beginRemoveRows(parent, row, end)
        try:
            for name in self._names[row:end]:
                snippets.delete(name)
            del self._names[row:end]
        finally:
            self.endRemoveRows()
            return True
        
    def saveSnippet(self, name, text, title):
        """Store a snippet.
        
        If name is None or does not exist in names(), a new snippet is created.
        Returns the QModelIndex the snippet was stored at.
        
        Title may be None.
        
        """
        # first, get the old titles list
        titles = list(snippets.title(n) for n in self._names)
        
        oldrow = None
        if name is None:
            name = snippets.name(self._names)
        else:
            try:
                oldrow = self._names.index(name)
            except ValueError:
                pass
        snippets.save(name, text, title)
        # sort the new snippet in
        # if oldrow is not None, it is the row to be removed.
        title = snippets.title(name)
        i = bisect.bisect_right(titles, title)
        
        if oldrow is None:
            # just insert new snippet
            self.beginInsertRows(QModelIndex(), i, i )
            self._names.insert(i, name)
            self.endInsertRows()
            return self.createIndex(i, 0)
        elif i in (oldrow, oldrow+1):
            # just replace
            self._names[oldrow] = name
            self.dataChanged.emit(self.createIndex(oldrow, 0), self.createIndex(oldrow, 2))
            return self.createIndex(oldrow, 0)
        else:
            # move the old row to the new place
            if self.beginMoveRows(QModelIndex(), oldrow, oldrow, QModelIndex(), i):
                del self._names[oldrow]
                if i > oldrow:
                    i -= 1
                self._names.insert(i, name)
                self.endMoveRows()
                self.dataChanged.emit(self.createIndex(i, 0), self.createIndex(i, 2))
                return self.createIndex(i, 0)
            raise RuntimeError("wrong row move offset")


def shortcut(name):
    """Returns a shortcut text for the named snippets, if any, else None."""
    s = shortcuts(name)
    if s:
        text = s[0].toString(QKeySequence.NativeText)
        if len(s) > 1:
            text += "..."
        return text


def shortcuts(name):
    """Returns a (maybe empty) list of QKeySequences for the named snippet."""
    ac = collection()
    return ac and ac.shortcuts(name) or []


def collection():
    """Returns an instance of the 'snippets' ShortcutCollection, if existing."""
    try:
        # HACK alert :-) access an instance of the ShortcutCollection named 'snippets'
        ref = actioncollection.ShortcutCollection.others['snippets'][0]
    except (KeyError, IndexError):
        return
    return ref()



########NEW FILE########
__FILENAME__ = restore
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Restored changed or deleted builtin snippets.
"""

from __future__ import unicode_literals


from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import userguide
import qutil
import widgets.dialog

from . import builtin
from . import snippets
from . import model
from . import widget


class RestoreDialog(widgets.dialog.Dialog):
    def __init__(self, parent=None):
        super(RestoreDialog, self).__init__(parent)
        self.messageLabel().setWordWrap(True)
        userguide.addButton(self.buttonBox(), "snippets")
        self.tree = QTreeWidget(headerHidden=True, rootIsDecorated=False)
        self.setMainWidget(self.tree)
        
        self.deletedItem = QTreeWidgetItem(self.tree)
        self.deletedItem.setFlags(Qt.ItemIsUserCheckable)
        self.changedItem = QTreeWidgetItem(self.tree)
        self.changedItem.setFlags(Qt.ItemIsUserCheckable)
        self.tree.itemChanged.connect(self.slotItemChanged)
        
        app.translateUI(self)
        app.languageChanged.connect(self.populate)
        self.accepted.connect(self.updateSnippets)
        qutil.saveDialogSize(self, "snippettool/restoredialog/size")
    
    def translateUI(self):
        self.setWindowTitle(
            app.caption(_("dialog title", "Restore Built-in Snippets")))
        self.setMessage(_(
            "This dialog allows you to recover built-in snippets that have "
            "been changed or deleted. Check the snippets you want to recover "
            "and click the button \"Restore Checked Snippets.\""))
        self.button("ok").setText(_("Restore Checked Snippets"))
        self.deletedItem.setText(0, _("Deleted Snippets"))
        self.changedItem.setText(0, _("Changed Snippets"))
        
    def populate(self):
        """Puts the deleted/changed snippets in the tree."""
        self.deletedItem.takeChildren()
        self.deletedItem.setExpanded(True)
        self.deletedItem.setCheckState(0, Qt.Unchecked)
        self.changedItem.takeChildren()
        self.changedItem.setExpanded(True)
        self.changedItem.setCheckState(0, Qt.Unchecked)
        
        builtins = list(builtin.builtin_snippets)
        builtins.sort(key = snippets.title)
        
        names = frozenset(snippets.names())
        
        for name in builtins:
            if name in names:
                if snippets.isoriginal(name):
                    continue
                parent = self.changedItem
            else:
                parent = self.deletedItem
            
            item = QTreeWidgetItem(parent)
            item.name = name
            item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
            item.setCheckState(0, Qt.Unchecked)
            item.setText(0, snippets.title(name))
        
        self.deletedItem.setDisabled(self.deletedItem.childCount() == 0)
        self.changedItem.setDisabled(self.changedItem.childCount() == 0)
        self.checkOkButton()
    
    def slotItemChanged(self, item):
        if item in (self.deletedItem, self.changedItem):
            for i in range(item.childCount()):
                item.child(i).setCheckState(0, item.checkState(0))
        self.checkOkButton()
        
    def checkedSnippets(self):
        """Yields the names of the checked snippets."""
        for parent in (self.deletedItem, self.changedItem):
            for i in range(parent.childCount()):
                child = parent.child(i)
                if child.checkState(0) == Qt.Checked:
                    yield child.name
    
    def updateSnippets(self):
        """Restores the checked snippets."""
        collection = self.parent().parent().snippetActions
        for name in self.checkedSnippets():
            collection.restoreDefaultShortcuts(name)
            model.model().saveSnippet(name, None, None)

    def checkOkButton(self):
        """Enables the OK button if there are selected snippets."""
        self.button("ok").setEnabled(any(self.checkedSnippets()))



########NEW FILE########
__FILENAME__ = snippets
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Accessing the snippets data.
"""

from __future__ import unicode_literals


import collections
import functools
import itertools
import random
import re

import app
import icons
import symbols

textvars = collections.namedtuple('textvars', 'text variables')

# cache parsed snippets
_cache = {}

# match variables in a '-*- ' line
_variables_re = re.compile(br'\s*?([a-z]+(?:-[a-z]+)*)(?::[ \t]*(.*?))?;')

# match expansions $$, $NAME or ${text} (the latter may contain escaped right brace: '\}')
_expansions_re = re.compile(r'\$(?P<_bracket_>\{)?((?(_bracket_)(?:\\\}|[^\}])*|(?:\$|[A-Z]+(?:_[A-Z]+)*)))(?(_bracket_)\})')


# builtin snippets
from .builtin import builtin_snippets


def memoize(f):
    """Decorator memoizing stuff for a name."""
    @functools.wraps(f)
    def func(name):
        try:
            result = _cache[name][f]
        except KeyError:
            result = _cache.setdefault(name, {})[f] = f(name)
        return result
    return func


def unmemoize(f):
    """Decorator forgetting memoized information for a name."""
    @functools.wraps(f)
    def func(name, *args, **kwargs):
        try:
            del _cache[name]
        except KeyError:
            pass
        return f(name, *args, **kwargs)
    return func


def settings():
    return app.settings("snippets")


def names():
    """Yields the names of available builtin snippets."""
    s = settings()
    return set(filter(lambda name: not s.value(name+"/deleted"),
                      itertools.chain(builtin_snippets, s.childGroups())))


def title(name, fallback=True):
    """Returns the title of the specified snippet or the empty string.
    
    If fallback, returns a shortened display of the text if no title is
    available.
    
    """
    s = settings()
    title = s.value(name+"/title")
    if title:
        return title
    try:
        t = builtin_snippets[name]
    except KeyError:
        pass
    else:
        if t.title:
            return t.title()   # call to translate
    if fallback:
        # no title found, send shorttext instead
        return shorttext(name)


def text(name):
    """Returns the full snippet text for the name, or the empty string."""
    text = settings().value(name+"/text")
    if text:
        return text
    try:
        t = builtin_snippets[name]
    except KeyError:
        return ""
    return t.text


@memoize
def shorttext(name):
    """Returns the abridged text, in most cases usable for display or matching."""
    return maketitle(get(name).text)


def maketitle(text):
    """Returns the text abridged, usable as a title."""
    lines = _expansions_re.sub(' ... ', text).splitlines()
    if not lines:
        return ''
    start, end  = 0, len(lines) - 1
    while start < end and (not lines[start] or lines[start].isspace()):
        start += 1
    while end > start and (not lines[end] or lines[end].isspace()):
        end -= 1
    if end == start:
        return lines[start]
    else:
        return lines[start] + " ... " + lines[end]
    

@memoize
def get(name):
    """Returns a tuple (text, variables) for the specified name.
    
    Equivalent to parse(text(name)). See parse().
    
    """
    return parse(text(name))


def parse(text):
    """Parses a piece of text and returns a named tuple (text, variables).
    
    text is the template text, with lines starting with '-*- ' removed.
    variables is a dictionary containing variables read from lines starting
    with '-*- '.
    
    The syntax is as follows:
    
    -*- name: value; name1: value2; (etc)
    
    Names without value are also possible:
    
    -*- name;
    
    In that case the value is set to True.
    
    """
    lines = text.split('\n')
    start = 0
    while start < len(lines) and lines[start].startswith('-*- '):
        start += 1
    t = '\n'.join(lines[start:])
    d = dict(m.groups(True) for l in lines[:start] for m in _variables_re.finditer(l))
    return textvars(t, d)


def icon(name):
    """Returns an icon if defined."""
    d = get(name).variables
    icon = d.get('icon')
    if icon:
        return icons.get(icon)
    icon = d.get('symbol')
    if icon:
        return symbols.icon(icon)


@unmemoize
def delete(name):
    """Deletes a snippet. For builtins, name/deleted is set to true."""
    s = settings()
    s.remove(name)
    if name in builtin_snippets:
        s.setValue(name+"/deleted", True)


def name(names):
    """Returns a name to be used for a new snippet..
    
    names is a list of strings for which the newly returned name will be unique.
    
    """
    while True:
        u = "n{0:06.0f}".format(random.random()*1000000)
        if u not in names:
            break
    return u


@unmemoize
def save(name, text, title=None):
    """Stores a snippet."""
    try:
        t = builtin_snippets[name]
    except KeyError:
        # not builtin
        pass
    else:
        # builtin
        if not title or (t.title and title == t.title()):
            title = None
        if text == t.text:
            text = None
    s = settings()
    if title or text:
        s.beginGroup(name)
        s.setValue("text", text) if text else s.remove("text")
        s.setValue("title", title) if title else s.remove("title")
    else:
        # the snippet exactly matches the builtin, no saving needed
        s.remove(name)


def isoriginal(name):
    """Returns True if the built-in snippet is not changed or deleted."""
    return name in builtin_snippets and name not in settings().childGroups()


def expand(text):
    """Yields tuples (text, expansion) for text.
    
    Parses text for expressions like '$VAR_NAME', '${other text}' or '$$'.
    
    An expansion starts with a '$' and is an uppercase word (which can have
    single underscores in the middle), or other text between braces (which may
    contain a right brace espaced: '\}', those are already unescaped by this
    function).

    One of (text, expansion) may be an empty string.
    
    """
    pos = 0
    for m in _expansions_re.finditer(text):
        expansion = m.group(2) if not m.group(1) else m.group(2).replace('\\}', '}')
        yield text[pos:m.start()], expansion
        pos = m.end()
    if pos < len(text):
        yield text[pos:], ''



########NEW FILE########
__FILENAME__ = template
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Save the current document as a snippet that appears in File->New from Template.
"""

from __future__ import unicode_literals

import documentinfo
import inputdialog

from PyQt4.QtGui import QMessageBox

from . import model
from . import snippets


def save(mainwindow):
    
    titles = dict((snippets.title(name), name)
                  for name in model.model().names()
                  if 'template' in snippets.get(name).variables)
    title = inputdialog.getText(mainwindow,
        _("Save as Template"),
        _("Please enter a template name:"),
        regexp=r"\w(.*\w)?", complete=sorted(titles))
    if not title:
        return
    
    if title in titles:
        if QMessageBox.critical(mainwindow,
            _("Overwrite Template?"),
            _("A template named \"{name}\" already exists.\n\n"
              "Do you want to overwrite it?").format(name=title),
            QMessageBox.Yes | QMessageBox.Cancel) != QMessageBox.Yes:
            return
        name = titles[title]
    else:
        name = None
    
    # get the text and insert cursor position or selection
    cursor = mainwindow.textCursor()
    text = cursor.document().toPlainText()
    
    repls = [(cursor.position(), '${CURSOR}')]
    if cursor.hasSelection():
        repls.append((cursor.anchor(), '${ANCHOR}'))
        repls.sort()
        
    result = []
    prev = 0
    for pos, what in repls:
        result.append(text[prev:pos].replace('$', '$$'))
        result.append(what)
        prev = pos
    result.append(text[prev:].replace('$', '$$'))
    text = ''.join(result)
    
    # add header line, if it is lilypond, enable autorun
    headerline = '-*- template; indent: no;'
    if documentinfo.mode(cursor.document()) == 'lilypond':
        dinfo = documentinfo.docinfo(cursor.document())
        if dinfo.complete() and dinfo.has_output():
            headerline += ' template-run;'
    text = headerline + '\n' + text
    
    # save the new snippet
    model.model().saveSnippet(name, text, title)



########NEW FILE########
__FILENAME__ = tool
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The snippets dockwindow.
"""

from __future__ import unicode_literals

import weakref

from PyQt4.QtCore import Qt
from PyQt4.QtGui import QAction, QKeySequence

import actioncollection
import actioncollectionmanager
import app
import panel


class SnippetTool(panel.Panel):
    """A dockwidget for selecting, applying and editing the list of snippets."""
    def __init__(self, mainwindow):
        super(SnippetTool, self).__init__(mainwindow)
        self.hide()
        self.snippetActions = SnippetActions(self)
        actioncollectionmanager.manager(mainwindow).addActionCollection(self.snippetActions)
        self.toggleViewAction().setShortcut(QKeySequence("Meta+Alt+S"))
        ac = self.actionCollection = Actions()
        mainwindow.addAction(ac.snippettool_activate)
        ac.snippettool_activate.triggered.connect(self.activate)
        ac.file_save_as_template.triggered.connect(self.saveAsTemplate)
        ac.copy_to_snippet.triggered.connect(self.copyToSnippet)
        ac.templates_manage.triggered.connect(self.manageTemplates)
        actioncollectionmanager.manager(mainwindow).addActionCollection(ac)
        mainwindow.addDockWidget(Qt.BottomDockWidgetArea, self)
        mainwindow.selectionStateChanged.connect(self.updateActions)
        self.updateActions()
        
    def translateUI(self):
        self.setWindowTitle(_("Snippets"))
        self.toggleViewAction().setText(_("&Snippets"))
        
    def createWidget(self):
        from . import widget
        return widget.Widget(self)

    def activate(self):
        super(SnippetTool, self).activate()
        if self.isFloating():
            self.activateWindow()
        self.mainwindow().currentView().ensureCursorVisible()
        self.widget().searchEntry.setFocus()
        self.widget().searchEntry.selectAll()
    
    def updateActions(self):
        self.actionCollection.copy_to_snippet.setEnabled(self.mainwindow().hasSelection())
    
    def saveAsTemplate(self):
        from . import template
        template.save(self.mainwindow())
    
    def copyToSnippet(self):
        text = self.mainwindow().textCursor().selection().toPlainText()
        from . import edit
        edit.Edit(self.widget(), None, text)
    
    def manageTemplates(self):
        super(SnippetTool, self).activate()
        if self.isFloating():
            self.activateWindow()
        self.widget().searchEntry.setText(":template")


class Actions(actioncollection.ActionCollection):
    name = "snippettool"
    def createActions(self, parent=None):
        self.file_save_as_template = QAction(parent)
        self.copy_to_snippet = QAction(parent)
        self.templates_manage = QAction(parent)
        self.snippettool_activate = QAction(parent)
        self.snippettool_activate.setShortcut(QKeySequence("Ctrl+T"))

    def translateUI(self):
        self.file_save_as_template.setText(_("Save as Template..."))
        self.copy_to_snippet.setText(_("Copy to &Snippet..."))
        self.templates_manage.setText(_("Manage Templates..."))
        self.snippettool_activate.setText(_("&Snippets..."))


class SnippetActions(actioncollection.ShortcutCollection):
    """Manages keyboard shortcuts for the snippets."""
    name = "snippets"
    def __init__(self, tool):
        super(SnippetActions, self).__init__(tool.mainwindow().centralWidget())
        self.tool = weakref.ref(tool)
    
    def createDefaultShortcuts(self):
        self.setDefaultShortcuts('voice1', [QKeySequence('Alt+1')])
        self.setDefaultShortcuts('voice2', [QKeySequence('Alt+2')])
        self.setDefaultShortcuts('voice3', [QKeySequence('Alt+3')])
        self.setDefaultShortcuts('voice4', [QKeySequence('Alt+4')])
        self.setDefaultShortcuts('1voice', [QKeySequence('Alt+0')])
        self.setDefaultShortcuts('times23', [QKeySequence('Ctrl+3')])
        self.setDefaultShortcuts('ly_version', [QKeySequence('Ctrl+Shift+V')])
        self.setDefaultShortcuts('blankline', [QKeySequence('Ctrl+Shift+Return')])
        self.setDefaultShortcuts('next_blank_line', [QKeySequence('Alt+Down')])
        self.setDefaultShortcuts('previous_blank_line', [QKeySequence('Alt+Up')])
        self.setDefaultShortcuts('next_blank_line_select', [QKeySequence('Alt+Shift+Down')])
        self.setDefaultShortcuts('previous_blank_line_select', [QKeySequence('Alt+Shift+Up')])
        self.setDefaultShortcuts('removelines', [QKeySequence('Ctrl+K')])
        self.setDefaultShortcuts('repeat', [QKeySequence('Ctrl+Shift+R')])
        self.setDefaultShortcuts('quotes_s', [QKeySequence("Ctrl+'")])
        self.setDefaultShortcuts('quotes_d', [QKeySequence('Ctrl+"')])
        self.setDefaultShortcuts('uppercase', [QKeySequence('Ctrl+U')])
        self.setDefaultShortcuts('lowercase', [QKeySequence('Ctrl+Shift+U')])
        self.setDefaultShortcuts('last_note', [QKeySequence('Ctrl+;')])
        self.setDefaultShortcuts('double', [QKeySequence('Ctrl+D')])
        
    def realAction(self, name):
        from . import actions, model
        if name in model.model().names():
            return actions.action(name)
    
    def triggerAction(self, name):
        from . import insert, model
        if name in model.model().names():
            view = self.tool().mainwindow().currentView()
            if view.hasFocus() or self.tool().widget().searchEntry.hasFocus():
                insert.insert(name, view)
            
    def title(self):
        return _("Snippets")



########NEW FILE########
__FILENAME__ = widget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The snippets widget.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import userguide
import icons
import widgets.lineedit
import textformats
import actioncollectionmanager

from . import actions
from . import model
from . import snippets
from . import edit
from . import insert
from . import highlight


class Widget(QWidget):
    def __init__(self, panel):
        super(Widget, self).__init__(panel)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        layout.setSpacing(0)
        
        self.searchEntry = SearchLineEdit()
        self.treeView = QTreeView(contextMenuPolicy=Qt.CustomContextMenu)
        self.textView = QTextBrowser()
        
        applyButton = QToolButton(autoRaise=True)
        editButton = QToolButton(autoRaise=True)
        addButton = QToolButton(autoRaise=True)
        self.menuButton = QPushButton(flat=True)
        menu = QMenu(self.menuButton)
        self.menuButton.setMenu(menu)
        
        splitter = QSplitter(Qt.Vertical)
        top = QHBoxLayout()
        layout.addLayout(top)
        splitter.addWidget(self.treeView)
        splitter.addWidget(self.textView)
        layout.addWidget(splitter)
        splitter.setSizes([200, 100])
        splitter.setCollapsible(0, False)
        
        top.addWidget(self.searchEntry)
        top.addWidget(applyButton)
        top.addSpacing(10)
        top.addWidget(addButton)
        top.addWidget(editButton)
        top.addWidget(self.menuButton)
        
        # action generator for actions added to search entry
        def act(slot, icon=None):
            a = QAction(self, triggered=slot)
            self.addAction(a)
            a.setShortcutContext(Qt.WidgetWithChildrenShortcut)
            icon and a.setIcon(icons.get(icon))
            return a
        
        # hide if ESC pressed in lineedit
        a = act(self.slotEscapePressed)
        a.setShortcut(QKeySequence(Qt.Key_Escape))
        
        # import action
        a = self.importAction = act(self.slotImport, 'document-open')
        menu.addAction(a)
        
        # export action
        a = self.exportAction = act(self.slotExport, 'document-save-as')
        menu.addAction(a)
        
        # apply button
        a = self.applyAction = act(self.slotApply, 'edit-paste')
        applyButton.setDefaultAction(a)
        menu.addSeparator()
        menu.addAction(a)
        
        # add button
        a = self.addAction_ = act(self.slotAdd, 'list-add')
        a.setShortcut(QKeySequence(Qt.Key_Insert))
        addButton.setDefaultAction(a)
        menu.addSeparator()
        menu.addAction(a)
        
        # edit button
        a = self.editAction = act(self.slotEdit, 'document-edit')
        a.setShortcut(QKeySequence(Qt.Key_F2))
        editButton.setDefaultAction(a)
        menu.addAction(a)
        
        # set shortcut action
        a = self.shortcutAction = act(self.slotShortcut, 'preferences-desktop-keyboard-shortcuts')
        menu.addAction(a)
        
        # delete action
        a = self.deleteAction = act(self.slotDelete, 'list-remove')
        a.setShortcut(QKeySequence(Qt.CTRL + Qt.Key_Delete))
        menu.addAction(a)
        
        # restore action
        a = self.restoreAction = act(self.slotRestore)
        menu.addSeparator()
        menu.addAction(a)
        
        # help button
        a = self.helpAction = act(self.slotHelp, 'help-contents')
        menu.addSeparator()
        menu.addAction(a)
        
        self.treeView.setSelectionBehavior(QTreeView.SelectRows)
        self.treeView.setSelectionMode(QTreeView.ExtendedSelection)
        self.treeView.setRootIsDecorated(False)
        self.treeView.setAllColumnsShowFocus(True)
        self.treeView.setModel(model.model())
        self.treeView.setCurrentIndex(QModelIndex())
        
        # signals
        self.searchEntry.returnPressed.connect(self.slotReturnPressed)
        self.searchEntry.textChanged.connect(self.updateFilter)
        self.treeView.doubleClicked.connect(self.slotDoubleClicked)
        self.treeView.customContextMenuRequested.connect(self.showContextMenu)
        self.treeView.selectionModel().currentChanged.connect(self.updateText)
        self.treeView.model().dataChanged.connect(self.updateFilter)
        
        # highlight text
        self.highlighter = highlight.Highlighter(self.textView.document())
        
        # complete on snippet variables
        self.searchEntry.setCompleter(QCompleter([
            ':icon', ':indent', ':menu', ':name', ':python', ':selection',
            ':set', ':symbol', ':template', ':template-run'], self.searchEntry))
        self.readSettings()
        app.settingsChanged.connect(self.readSettings)
        app.translateUI(self)
        self.updateColumnSizes()
        self.setAcceptDrops(True)

    def dropEvent(self, ev):
        if not ev.source() and ev.mimeData().hasUrls():
            filename = ev.mimeData().urls()[0].toLocalFile()
            if filename:
                ev.accept()
                from . import import_export
                import_export.load(filename, self)
        
    def dragEnterEvent(self, ev):
        if not ev.source() and ev.mimeData().hasUrls():
            ev.accept()
        
    def translateUI(self):
        try:
            self.searchEntry.setPlaceholderText(_("Search..."))
        except AttributeError:
            pass # not in Qt 4.6
        shortcut = lambda a: a.shortcut().toString(QKeySequence.NativeText)
        self.menuButton.setText(_("&Menu"))
        self.addAction_.setText(_("&Add..."))
        self.addAction_.setToolTip(
            _("Add a new snippet. ({key})").format(key=shortcut(self.addAction_)))
        self.editAction.setText(_("&Edit..."))
        self.editAction.setToolTip(
            _("Edit the current snippet. ({key})").format(key=shortcut(self.editAction)))
        self.shortcutAction.setText(_("Configure Keyboard &Shortcut..."))
        self.deleteAction.setText(_("&Remove"))
        self.deleteAction.setToolTip(_("Remove the selected snippets."))
        self.applyAction.setText(_("A&pply"))
        self.applyAction.setToolTip(_("Apply the current snippet."))
        self.importAction.setText(_("&Import..."))
        self.importAction.setToolTip(_("Import snippets from a file."))
        self.exportAction.setText(_("E&xport..."))
        self.exportAction.setToolTip(_("Export snippets to a file."))
        self.restoreAction.setText(_("Restore &Built-in Snippets..."))
        self.restoreAction.setToolTip(
            _("Restore deleted or changed built-in snippets."))
        self.helpAction.setText(_("&Help"))
        self.searchEntry.setToolTip(_(
            "Enter text to search in the snippets list.\n"
            "See \"What's This\" for more information."))
        self.searchEntry.setWhatsThis(''.join(map("<p>{0}</p>\n".format, (
            _("Enter text to search in the snippets list, and "
              "press Enter to apply the currently selected snippet."),
            _("If the search text fully matches the value of the '{name}' variable "
              "of a snippet, that snippet is selected.").format(name="name"),
            _("If the search text starts with a colon ':', the rest of the "
              "search text filters snippets that define the given variable. "
              "After a space a value can also be entered, snippets will then "
              "match if the value of the given variable contains the text after "
              "the space."),
            _("E.g. entering {menu} will show all snippets that are displayed "
              "in the insert menu.").format(menu="<code>:menu</code>"),
            ))))
    
    def sizeHint(self):
        return self.parent().mainwindow().size() / 4
        
    def readSettings(self):
        data = textformats.formatData('editor')
        self.textView.setFont(data.font)
        self.textView.setPalette(data.palette())

    def showContextMenu(self, pos):
        """Called when the user right-clicks the tree view."""
        self.menuButton.menu().popup(self.treeView.viewport().mapToGlobal(pos))
    
    def slotReturnPressed(self):
        """Called when the user presses Return in the search entry. Applies current snippet."""
        name = self.currentSnippet()
        if name:
            view = self.parent().mainwindow().currentView()
            insert.insert(name, view)
            self.parent().hide() # make configurable?
            view.setFocus()

    def slotEscapePressed(self):
        """Called when the user presses ESC in the search entry. Hides the panel."""
        self.parent().hide()
        self.parent().mainwindow().currentView().setFocus()
    
    def slotDoubleClicked(self, index):
        name = self.treeView.model().name(index)
        view = self.parent().mainwindow().currentView()
        insert.insert(name, view)
        
    def slotAdd(self):
        """Called when the user wants to add a new snippet."""
        edit.Edit(self, None)
        
    def slotEdit(self):
        """Called when the user wants to edit a snippet."""
        name = self.currentSnippet()
        if name:
            edit.Edit(self, name)
        
    def slotShortcut(self):
        """Called when the user selects the Configure Shortcut action."""
        from widgets import shortcuteditdialog
        name = self.currentSnippet()
        if name:
            collection = self.parent().snippetActions
            action = actions.action(name, None, collection)
            default = collection.defaults().get(name)
            mgr = actioncollectionmanager.manager(self.parent().mainwindow())
            cb = mgr.findShortcutConflict
            dlg = shortcuteditdialog.ShortcutEditDialog(self, cb, (collection, name))
            
            if dlg.editAction(action, default):
                mgr.removeShortcuts(action.shortcuts())
                collection.setShortcuts(name, action.shortcuts())
                self.treeView.update()
            
    def slotDelete(self):
        """Called when the user wants to delete the selected rows."""
        rows = sorted(set(i.row() for i in self.treeView.selectedIndexes()), reverse=True)
        if rows:
            for row in rows:
                name = self.treeView.model().names()[row]
                self.parent().snippetActions.setShortcuts(name, [])
                self.treeView.model().removeRow(row)
            self.updateFilter()
    
    def slotApply(self):
        """Called when the user clicks the apply button. Applies current snippet."""
        name = self.currentSnippet()
        if name:
            view = self.parent().mainwindow().currentView()
            insert.insert(name, view)
    
    def slotImport(self):
        """Called when the user activates the import action."""
        filetypes = "{0} (*.xml);;{1} (*)".format(_("XML Files"), _("All Files"))
        caption = app.caption(_("dialog title", "Import Snippets"))
        filename = None
        filename = QFileDialog.getOpenFileName(self, caption, filename, filetypes)
        if filename:
            from . import import_export
            import_export.load(filename, self)
        
    def slotExport(self):
        """Called when the user activates the export action."""
        allrows = [row for row in range(model.model().rowCount())
                       if not self.treeView.isRowHidden(row, QModelIndex())]
        selectedrows = [i.row() for i in self.treeView.selectedIndexes()
                                if i.column() == 0 and i.row() in allrows]
        names = self.treeView.model().names()
        names = [names[row] for row in selectedrows or allrows]
        
        filetypes = "{0} (*.xml);;{1} (*)".format(_("XML Files"), _("All Files"))
        n = len(names)
        caption = app.caption(_("dialog title",
            "Export {num} Snippet", "Export {num} Snippets", n).format(num=n))
        filename = QFileDialog.getSaveFileName(self, caption, None, filetypes)
        if filename:
            from . import import_export
            try:
                import_export.save(names, filename)
            except (IOError, OSError) as e:
                QMessageBox.critical(self, _("Error"), _(
                    "Can't write to destination:\n\n{url}\n\n{error}").format(
                    url=filename, error=e.strerror))
        
    def slotRestore(self):
        """Called when the user activates the Restore action."""
        from . import restore
        dlg = restore.RestoreDialog(self)
        dlg.setWindowModality(Qt.WindowModal)
        dlg.populate()
        dlg.show()
        dlg.finished.connect(dlg.deleteLater)
        
    def slotHelp(self):
        """Called when the user clicks the small help button."""
        userguide.show("snippets")
        
    def currentSnippet(self):
        """Returns the name of the current snippet if it is visible."""
        row = self.treeView.currentIndex().row()
        if row != -1 and not self.treeView.isRowHidden(row, QModelIndex()):
            return self.treeView.model().names()[row]

    def updateFilter(self):
        """Called when the text in the entry changes, updates search results."""
        text = self.searchEntry.text()
        ltext = text.lower()
        filterVars = text.startswith(':')
        if filterVars:
            try:
                fvar, fval = text[1:].split(None, 1)
                fhide = lambda v: v.get(fvar) in (True, None) or fval not in v.get(fvar)
            except ValueError:
                fvar = text[1:].strip()
                fhide = lambda v: not v.get(fvar)
        for row in range(self.treeView.model().rowCount()):
            name = self.treeView.model().names()[row]
            nameid = snippets.get(name).variables.get('name', '')
            if filterVars:
                hide = fhide(snippets.get(name).variables)
            elif nameid == text:
                i = self.treeView.model().createIndex(row, 0)
                self.treeView.selectionModel().setCurrentIndex(i, QItemSelectionModel.SelectCurrent | QItemSelectionModel.Rows)
                hide = False
            elif nameid.lower().startswith(ltext):
                hide = False
            elif ltext in snippets.title(name).lower():
                hide = False
            else:
                hide = True
            self.treeView.setRowHidden(row, QModelIndex(), hide)
        self.updateText()
            
    def updateText(self):
        """Called when the current snippet changes."""
        name = self.currentSnippet()
        self.textView.clear()
        if name:
            s = snippets.get(name)
            self.highlighter.setPython('python' in s.variables)
            self.textView.setPlainText(s.text)
        
    def updateColumnSizes(self):
        self.treeView.resizeColumnToContents(0)
        self.treeView.resizeColumnToContents(1)
        

class SearchLineEdit(widgets.lineedit.LineEdit):
    def __init__(self, *args):
        super(SearchLineEdit, self).__init__(*args)
    
    def event(self, ev):
        if ev.type() == QEvent.KeyPress and any(ev.matches(key) for key in (
            QKeySequence.MoveToNextLine, QKeySequence.SelectNextLine,
            QKeySequence.MoveToPreviousLine, QKeySequence.SelectPreviousLine,
            QKeySequence.MoveToNextPage, QKeySequence.SelectNextPage,
            QKeySequence.MoveToPreviousPage, QKeySequence.SelectPreviousPage)):
            QApplication.sendEvent(self.parent().treeView, ev)
            return True
        return super(SearchLineEdit, self).event(ev)



########NEW FILE########
__FILENAME__ = svgfiles
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Handles SVG files.
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import Qt, QUrl

import icons
import plugin
import signals
import jobmanager
import resultfiles
import listmodel


class SvgFiles(plugin.DocumentPlugin):
    def __init__(self, document):
        self._files = None
        self.current = 0
        document.loaded.connect(self.invalidate, -100)
        jobmanager.manager(document).finished.connect(self.invalidate, -100)
    
    def invalidate(self):
        self._files = None
        
    def update(self):
        files = resultfiles.results(self.document()).files('.svg*')
        self._files = files
        if files and self.current >= len(files):
            self.current = len(files) - 1
        return bool(files)
    
    def __nonzero__(self):
        return bool(self._files)
    
    def model(self):
        """Returns a model for a combobox."""
        if self._files is None:
            self.update()
        m = listmodel.ListModel(self._files,
            display = os.path.basename, icon = icons.file_type)
        m.setRoleFunction(Qt.UserRole, lambda f: f)
        return m

    def url(self, index):
        """Return the filename at index as a QUrl.fromLocalFile()"""
        if self._files is None:
            self.update()
        return QUrl.fromLocalFile(self._files[index])

    def filename(self, index):
        """Return the filename at index."""
        if self._files is None:
            self.update()
        return self._files[index]


########NEW FILE########
__FILENAME__ = view
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The SVG view (a QWebView displaying a SVG file).

Interaction between the SVG object and Python is done via a JavaScript bridge
that runs inside the displayed SVG file.

"""

from __future__ import unicode_literals
from __future__ import absolute_import

import os
import sys

from PyQt4 import QtCore
from PyQt4 import QtGui
from PyQt4 import QtWebKit

import app
import util
import textedit
import textformats
import pointandclick
import scratchdir


from . import __path__


def getJsScript(filename):
    """fetch the js file"""
    directory = __path__[0]
    with open(os.path.join(directory, filename), 'r') as fileObject:
        jsValue = fileObject.read()
	return jsValue


class View(QtWebKit.QWebView):
    zoomFactorChanged = QtCore.pyqtSignal(float)
    objectDragged = QtCore.pyqtSignal(float, float)
    objectDragging = QtCore.pyqtSignal(float, float)
    objectStartDragging = QtCore.pyqtSignal(float, float)

    cursor = QtCore.pyqtSignal(QtGui.QTextCursor)
    selectedObject = QtCore.pyqtSignal(str)
    selectedUrl = QtCore.pyqtSignal(QtGui.QTextCursor)
    
    def __init__(self, parent):
        super(View, self).__init__(parent)
        self._highlightFormat = QtGui.QTextCharFormat()
        self.jslink = JSLink(self)
        self.loadFinished.connect(self.svgLoaded)
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
    
    def mainwindow(self):
        return self.parent().mainwindow()
        
    def currentSVG(self):
        return self.parent().getCurrent()

    def document(self, filename, load=False):
        """Get the document with the specified filename.
        
        If load is True, the document is loaded if it wasn't already.
        Also takes scratchdir into account for unnamed or non-local documents.
        
        """
        for d in app.documents:
            s = scratchdir.scratchdir(d)
            if (s.directory() and util.equal_paths(filename, s.path())
                or d.url().toLocalFile() == filename):
                return d
        if load:
            doc = app.openUrl(QtCore.QUrl.fromLocalFile(filename))
            
            return doc
        

    def svgLoaded(self):
        if not self.url().isEmpty():
            frame = self.page().mainFrame()
            frame.addToJavaScriptWindowObject("pyLinks", self.jslink)
            frame.evaluateJavaScript(getJsScript('pointandclick.js'))
            frame.evaluateJavaScript(getJsScript('editsvg.js')) #remove this for stable releases
            
    def evalSave(self):
        frame = self.page().mainFrame()
        # to enable useful save of SVG edits to file uncomment the line below
        # frame.evaluateJavaScript(getJsScript('cleansvg.js'))
        frame.evaluateJavaScript(getJsScript('savesvg.js'))
    
    def clear(self):
        """Empty the View."""
        self.load(QtCore.QUrl())
    
    def dragElement(self, url):
        t = textedit.link(url)
        # Only process textedit links
        if not t:
            return False
        doc = self.document(t.filename, True)
        if doc:
            cursor = QtGui.QTextCursor(doc)
            b = doc.findBlockByNumber(t.line - 1)
            p = b.position() + t.column
            cursor.setPosition(p)
        self.emitCursor(cursor)
    
    def doObjectDragged(self, offsX, offsY):
        """announce extra-offsets an element has been dragged to"""
        self.objectDragged.emit(offsX, offsY)
    
    def doObjectDragging(self, offsX, offsY):
        """announce extra-offsets while dragging an element"""
        self.objectDragging.emit(offsX, offsY)    

    def doObjectStartDragging(self, offsX, offsY):
        """announce extra-offsets when starting to drag an element"""
        self.objectStartDragging.emit(offsX, offsY)

    def doTextEdit(self, url, setCursor = False):
        """Process a textedit link and either highlight
           the corresponding source code or set the 
           cursor to it.
        """
        t = textedit.link(url)
        # Only process textedit links
        if not t:
            return False
        doc = self.document(t.filename, setCursor)
        if doc:
            cursor = QtGui.QTextCursor(doc)
            b = doc.findBlockByNumber(t.line - 1)
            p = b.position() + t.column
            cursor.setPosition(p)
            cursors = pointandclick.positions(cursor)
            # Do highlighting if the document is active
            if cursors and doc == self.mainwindow().currentDocument():
                import viewhighlighter
                view = self.mainwindow().currentView()
                viewhighlighter.highlighter(view).highlight(self._highlightFormat, cursors, 2, 0)
            # set the cursor and bring the document to front
            if setCursor:
                mainwindow = self.mainwindow()
                mainwindow.setTextCursor(cursor)
                import widgets.blink
                widgets.blink.Blinker.blink_cursor(mainwindow.currentView())
                self.mainwindow().setCurrentDocument(doc)
                mainwindow.activateWindow()
                mainwindow.currentView().setFocus()
        return True
    
    def emitCursor(self, cursor):
        self.cursor.emit(cursor)    
    
    def readSettings(self):
        """Reads the settings from the user's preferences."""
        color = textformats.formatData('editor').baseColors['selectionbackground']
        color.setAlpha(128)
        self._highlightFormat.setBackground(color)
    
    def saveSVG(self, svg_string):
        """Pass string from JavaScript and save to current SVG page."""
        f = open(self.currentSVG(),'w')
        f.write(svg_string.encode('utf8'))
        f.close()

    def unHighlight(self):
        import viewhighlighter
        view = self.mainwindow().currentView()
        viewhighlighter.highlighter(view).clear(self._highlightFormat)

    def zoomIn(self):
        self.setZoomFactor(self.zoomFactor() * 1.1)
        
    def zoomOut(self):
        self.setZoomFactor(self.zoomFactor() / 1.1)
        
    def zoomOriginal(self):
        self.setZoomFactor(1.0)
    
    def setZoomFactor(self, value):
        changed = self.zoomFactor() != value
        super(View, self).setZoomFactor(value)
        if changed:
            self.zoomFactorChanged.emit(self.zoomFactor())


class JSLink(QtCore.QObject):
    """functions to be called from JavaScript
    
    using addToJavaScriptWindowObject
    
    """
    def __init__(self, view):
        super(JSLink, self).__init__()
        self.view = view

    @QtCore.pyqtSlot(str)
    def click(self, url):
        """set cursor in source by clicked textedit link""" 
        if not self.view.doTextEdit(url, True):
            import helpers
            helpers.openUrl(QtCore.QUrl(url))

    @QtCore.pyqtSlot(float, float)
    def dragged(self, offX, offY):
        """announce extra-offsets an element has been dragged to"""
        self.view.doObjectDragged(offX, offY)
        
    @QtCore.pyqtSlot(str)
    def draggedObject(self, JSON_string):
        # leave the following commented code as an idea how to proceed from here
        #print "Dragged object JSON representation:"
        #import json
        #js = json.JSONDecoder()
        #print js.decode(JSON_string)
        pass
        
    @QtCore.pyqtSlot(str)
    def dragElement(self, url):
        self.view.dragElement(url)

    @QtCore.pyqtSlot(float, float)
    def dragging(self, offX, offY):
        """announce extra-offsets while dragging an element"""
        self.view.doObjectDragging(offX, offY)
        
    @QtCore.pyqtSlot(str)	    
    def hover(self, url):
        """actions when user set mouse over link"""
        self.view.doTextEdit(url, False)
    
    @QtCore.pyqtSlot(str)	    
    def leave(self, url):
        """actions when user moves mouse off link"""
        self.view.unHighlight()
        
    @QtCore.pyqtSlot(str)	    
    def pyLog(self, txt):
        """Temporary function. Print to Python console."""
        print(txt)
    
    @QtCore.pyqtSlot(str)	    
    def saveSVG(self, svg_string):
        """Pass string from JavaScript and save to current SVG page."""
        self.view.saveSVG(svg_string)

    @QtCore.pyqtSlot(float, float)
    def startDragging(self, offX, offY):
        """announce extra-offsets when starting to drag an element"""
        self.view.doObjectStartDragging(offX, offY)

########NEW FILE########
__FILENAME__ = widget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The SVG preview panel widget.
"""

from __future__ import unicode_literals

import os
import sys

from PyQt4 import QtCore
from PyQt4.QtGui import *

import app
import qutil
import resultfiles

from . import view
from . import svgfiles


class SvgView(QWidget):
    def __init__(self, dockwidget):
        super(SvgView, self).__init__(dockwidget)
        
        self._document = None
        self._setting_zoom = False
        
        self.view = view.View(self)
        
        self.pageLabel = QLabel()
        self.pageCombo = QComboBox(sizeAdjustPolicy=QComboBox.AdjustToContents)
		
        layout = QVBoxLayout(spacing=0)
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)
        hbox = QHBoxLayout(spacing=0)
        hbox.addWidget(self.pageLabel)
        hbox.addWidget(self.pageCombo)
        
        self.zoomInButton = QToolButton(autoRaise=True)
        self.zoomOutButton = QToolButton(autoRaise=True)
        self.zoomOriginalButton = QToolButton(autoRaise=True)
        self.zoomNumber = QSpinBox(minimum=10, maximum=1000, suffix='%')
        ac = dockwidget.actionCollection
        self.zoomInButton.setDefaultAction(ac.svg_zoom_in)
        self.zoomOutButton.setDefaultAction(ac.svg_zoom_out)
        self.zoomOriginalButton.setDefaultAction(ac.svg_zoom_original)
        hbox.addWidget(self.zoomInButton)
        hbox.addWidget(self.zoomNumber)
        hbox.addWidget(self.zoomOutButton)
        hbox.addWidget(self.zoomOriginalButton)
        
        self.resetButton = QPushButton("reload", self)
        self.resetButton.clicked.connect(self.reLoadDoc)
        hbox.addWidget(self.resetButton)
        
        self.saveButton = QPushButton("save edits", self)
        self.saveButton.clicked.connect(self.callSave)
        hbox.addWidget(self.saveButton)
        
        hbox.addStretch(1)
        layout.addLayout(hbox)
        layout.addWidget(self.view)
        
        app.jobFinished.connect(self.initSvg)
        app.documentClosed.connect(self.slotDocumentClosed)
        app.documentLoaded.connect(self.initSvg)
        self.pageCombo.currentIndexChanged.connect(self.changePage)
        self.zoomNumber.valueChanged.connect(self.slotZoomNumberChanged)
        self.view.zoomFactorChanged.connect(self.slotViewZoomChanged)
        dockwidget.mainwindow().currentDocumentChanged.connect(self.initSvg)
        self.zoomNumber.setValue(100)
        doc = dockwidget.mainwindow().currentDocument()
        if doc:
            self.initSvg(doc)
        app.translateUI(self)
    
    def translateUI(self):
        self.pageLabel.setText(_("Page:"))
        
    def mainwindow(self):
        return self.parent().mainwindow()       
        
    def initSvg(self, doc):
        """Opens first page of score after compilation"""
        if doc == self.mainwindow().currentDocument():
            files = svgfiles.SvgFiles.instance(doc)
            model = files.model() # forces update
            if files:
                self._document = doc
                with qutil.signalsBlocked(self.pageCombo):
                    self.pageCombo.setModel(model)
                    self.pageCombo.setCurrentIndex(files.current)
                self.view.load(files.url(files.current))
                
    def reLoadDoc(self):
        """Reloads current document."""
        if self._document:
            self.initSvg(self._document)
            
    def callSave(self):
        """Call save function"""
        self.view.evalSave()
		
    def getCurrent(self):
        files = svgfiles.SvgFiles.instance(self._document)
        return files.filename(files.current)
			
    def slotZoomNumberChanged(self, value):
        self._setting_zoom = True
        self.view.setZoomFactor(value / 100.0)
        self._setting_zoom = False
    
    def slotViewZoomChanged(self):
        if not self._setting_zoom:
            self.zoomNumber.setValue(int(self.view.zoomFactor() * 100))
    
    def changePage(self, page_index):
        """change page of score"""
        doc = self._document
        if doc:
            files = svgfiles.SvgFiles.instance(doc)
            if files:
                files.current = page_index
                svg = files.url(page_index)
                self.view.load(svg)
		
    def slotDocumentClosed(self, doc):
        if doc == self._document:
            self._document = None
            if self.pageCombo.model():
                self.pageCombo.model().deleteLater()
            self.pageCombo.clear()
            self.pageCombo.update() # otherwise it doesn't redraw
            self.view.clear()


########NEW FILE########
__FILENAME__ = tabbar
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The tab bar with the documents.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import Qt, QUrl, pyqtSignal
from PyQt4.QtGui import QMenu, QTabBar

import app
import icons
import document
import documentcontextmenu
import jobmanager
import jobattributes
import util


class TabBar(QTabBar):
    """The tabbar above the editor window."""
    
    currentDocumentChanged = pyqtSignal(document.Document)
    
    def __init__(self, parent=None):
        super(TabBar, self).__init__(parent)
        
        self.setFocusPolicy(Qt.NoFocus)
        self.setTabsClosable(True) # TODO: make configurable
        self.setMovable(True)      # TODO: make configurable
        self.setExpanding(False)
        
        mainwin = self.window()
        self.docs = []
        for doc in app.documents:
            self.addDocument(doc)
            if doc is mainwin.currentDocument():
                self.setCurrentDocument(doc)
        
        app.documentCreated.connect(self.addDocument)
        app.documentClosed.connect(self.removeDocument)
        app.documentUrlChanged.connect(self.setDocumentStatus)
        app.documentModificationChanged.connect(self.setDocumentStatus)
        app.jobStarted.connect(self.setDocumentStatus)
        app.jobFinished.connect(self.setDocumentStatus)
        mainwin.currentDocumentChanged.connect(self.setCurrentDocument)
        self.currentChanged.connect(self.slotCurrentChanged)
        self.tabMoved.connect(self.slotTabMoved)
        self.tabCloseRequested.connect(self.slotTabCloseRequested)
        
    def documents(self):
        return list(self.docs)
        
    def addDocument(self, doc):
        if doc not in self.docs:
            self.docs.append(doc)
            self.blockSignals(True)
            self.addTab('')
            self.blockSignals(False)
            self.setDocumentStatus(doc)

    def removeDocument(self, doc):
        if doc in self.docs:
            index = self.docs.index(doc)
            self.docs.remove(doc)
            self.blockSignals(True)
            self.removeTab(index)
            self.blockSignals(False)

    def setDocumentStatus(self, doc):
        if doc in self.docs:
            index = self.docs.index(doc)
            self.setTabText(index, doc.documentName().replace('&', '&&'))
            if doc.url().toLocalFile():
                tooltip = util.homify(doc.url().toLocalFile())
            elif not doc.url().isEmpty():
                tooltip = doc.url().toString(QUrl.RemoveUserInfo)
            else:
                tooltip = None
            self.setTabToolTip(index, tooltip)
            # icon
            job = jobmanager.job(doc)
            if job and job.isRunning() and not jobattributes.get(job).hidden:
                icon = 'lilypond-run'
            elif doc.isModified():
                icon = 'document-save'
            else:
                icon = 'text-plain'
            self.setTabIcon(index, icons.get(icon))
    
    def setCurrentDocument(self, doc):
        """ Raise the tab belonging to this document."""
        if doc in self.docs:
            index = self.docs.index(doc)
            self.blockSignals(True)
            self.setCurrentIndex(index)
            self.blockSignals(False)

    def slotCurrentChanged(self, index):
        """ Called when the user clicks a tab. """
        self.currentDocumentChanged.emit(self.docs[index])
    
    def slotTabCloseRequested(self, index):
        """ Called when the user clicks the close button. """
        self.window().closeDocument(self.docs[index])
    
    def slotTabMoved(self, index_from, index_to):
        """ Called when the user moved a tab. """
        doc = self.docs.pop(index_from)
        self.docs.insert(index_to, doc)
        
    def nextDocument(self):
        """ Switches to the next document. """
        index = self.currentIndex() + 1
        if index == self.count():
            index = 0
        self.setCurrentIndex(index)
        
    def previousDocument(self):
        index = self.currentIndex() - 1
        if index < 0:
            index = self.count() - 1
        self.setCurrentIndex(index)
    
    def contextMenuEvent(self, ev):
        index = self.tabAt(ev.pos())
        if index >= 0:
            self.contextMenu().exec_(self.docs[index], ev.globalPos())

    def contextMenu(self):
        try:
            return self._contextMenu
        except AttributeError:
            import documentcontextmenu
            self._contextMenu = documentcontextmenu.DocumentContextMenu(
                self.window())
        return self._contextMenu



########NEW FILE########
__FILENAME__ = textedit
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Parse textedit:// urls.
"""

from __future__ import unicode_literals

import re
import sys
import collections

import util
import percentcoding


textedit_match = re.compile(r"^textedit://(.*?):(\d+):(\d+)(?::\d+)$").match

Link = collections.namedtuple("Link", "filename line column")


def link(url):
    """Return Link(filename, line, column) for the url if it's valid.
    
    Link is a named tuple (filename, line, column).
    
    """
    m = textedit_match(url)
    if m:
        return readurl(m)

def readurl(match):
    """Return Link(filename, line, col) for the match object resulting from textedit_match.
    
    Link is a named tuple (filename, line, column).
    
    """
    return Link(readfilename(match), int(match.group(2)), int(match.group(3)))

def readfilename(match):
    """Return the filename from the match object resulting from textedit_match."""
    fname = match.group(1)
    lat1 = fname.encode('latin1')
    try:
        lat1 = percentcoding.decode(lat1)
    except ValueError:
        pass
    try:
        fname = lat1.decode(sys.getfilesystemencoding())
    except UnicodeError:
        pass
    # normalize path (although this might change a path if it contains
    # symlinks followed by '/../' !
    fname = util.normpath(fname)
    return fname


########NEW FILE########
__FILENAME__ = textformats
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Loading and defaults for the different textformats used for Syntax Highlighting.
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import QSettings
from PyQt4.QtGui import QApplication, QColor, QFont, QPalette, QTextCharFormat, QTextFormat

import app
import ly.colorize


# When formatData() is requested for the first time, it is loaded from the config
# When the settings are changed, it is cleared again so that it is reloaded when
# requested again.


def formatData(format_type):
    """Return a TextFormatData instance of type 'editor' or 'printer'."""
    if _currentData[format_type] is None:
        _currentData[format_type] = TextFormatData(QSettings().value('{0}_scheme'.format(format_type), 'default', type("")))
    return _currentData[format_type]

def _resetFormatData():
    global _currentData
    _currentData = {
        'editor': None,
        'printer': None,
    }

app.settingsChanged.connect(_resetFormatData, -100) # before all others
_resetFormatData()

    
class TextFormatData(object):
    """Encapsulates all settings in the Fonts & Colors page for a scheme."""
    def __init__(self, scheme):
        """Loads the data from scheme."""
        self.font = None
        self.baseColors = {}
        self.defaultStyles = {}
        self.allStyles = {}
        self._inherits = {}
        self.load(scheme)
        
    def load(self, scheme):
        """Load the settings for the scheme. Called on init."""
        s = QSettings()
        s.beginGroup("fontscolors/" + scheme)
        
        # load font
        defaultfont = "Lucida Console" if os.name == "nt" else "monospace"
        self.font = QFont(s.value("fontfamily", defaultfont, type("")))
        self.font.setPointSizeF(s.value("fontsize", 10.0, float))
        
        # load base colors
        s.beginGroup("basecolors")
        for name in baseColors:
            if s.contains(name):
                self.baseColors[name] = QColor(s.value(name, "", type("")))
            else:
                self.baseColors[name] = baseColorDefaults[name]()
        s.endGroup()
        
        # get the list of supported styles from ly.colorize
        all_styles = ly.colorize.default_mapping()
        default_styles = set()
        for group, styles in all_styles:
            d = self._inherits[group] = {}
            for style in styles:
                if style.base:
                    default_styles.add(style.base)
                    d[style.name] = style.base
        
        default_scheme = ly.colorize.default_scheme
        
        # load default styles
        s.beginGroup("defaultstyles")
        for name in default_styles:
            self.defaultStyles[name] = f = QTextCharFormat()
            css = default_scheme[None].get(name)
            if css:
                css2fmt(css, f)
            s.beginGroup(name)
            self.loadTextFormat(f, s)
            s.endGroup()
        s.endGroup()
        
        # load specific styles
        s.beginGroup("allstyles")
        for group, styles in all_styles:
            self.allStyles[group]= {}
            s.beginGroup(group)
            for style in styles:
                self.allStyles[group][style.name] = f = QTextCharFormat()
                css = default_scheme[group].get(style.name)
                if css:
                    css2fmt(css, f)
                s.beginGroup(style.name)
                self.loadTextFormat(f, s)
                s.endGroup()
            s.endGroup()
        s.endGroup()
        
    def save(self, scheme):
        """Save the settings to the scheme."""
        s = QSettings()
        s.beginGroup("fontscolors/" + scheme)
        
        # save font
        s.setValue("fontfamily", self.font.family())
        s.setValue("fontsize", self.font.pointSizeF())
        
        # save base colors
        for name in baseColors:
            s.setValue("basecolors/"+name, self.baseColors[name].name())
        
        # save default styles
        s.beginGroup("defaultstyles")
        for name in defaultStyles:
            s.beginGroup(name)
            self.saveTextFormat(self.defaultStyles[name], s)
            s.endGroup()
        s.endGroup()
        
        # save all specific styles
        s.beginGroup("allstyles")
        for group, styles in ly.colorize.default_mapping():
            s.beginGroup(group)
            for style in styles:
                s.beginGroup(style.name)
                self.saveTextFormat(self.allStyles[group][style.name], s)
                s.endGroup()
            s.endGroup()
        s.endGroup()

    def textFormat(self, group, name):
        """Return a QTextCharFormat() for the specified group and name."""
        inherit = self._inherits[group].get(name)
        f = QTextCharFormat(self.defaultStyles[inherit]) if inherit else QTextCharFormat()
        f.merge(self.allStyles[group][name])
        return f
    
    def css_scheme(self):
        """Return a dictionary of css dictionaries representing this scheme.
        
        This can be fed to the ly.colorize.format_stylesheet() function.
        
        """
        scheme = {}
        # base/default styles
        d = scheme[None] = {}
        for name, fmt in self.defaultStyles.items():
            d[name] = fmt2css(fmt)
        # mode/group styles
        for mode, styles in self.allStyles.items():
            d = scheme[mode] = {}
            for name, fmt in styles.items():
                d[name] = fmt2css(fmt)
        return scheme
    
    def palette(self):
        """Return a basic palette with text, background, selection and selection background filled in."""
        p = QApplication.palette()
        p.setColor(QPalette.Text, self.baseColors['text'])
        p.setColor(QPalette.Base, self.baseColors['background'])
        p.setColor(QPalette.HighlightedText, self.baseColors['selectiontext'])
        p.setColor(QPalette.Highlight, self.baseColors['selectionbackground'])
        return p
        
    def saveTextFormat(self, fmt, settings):
        """(Internal) Store one QTextCharFormat in the QSettings instance."""
        if fmt.hasProperty(QTextFormat.FontWeight):
            settings.setValue('bold', fmt.fontWeight() >= 70)
        else:
            settings.remove('bold')
        if fmt.hasProperty(QTextFormat.FontItalic):
            settings.setValue('italic', fmt.fontItalic())
        else:
            settings.remove('italic')
        if fmt.hasProperty(QTextFormat.TextUnderlineStyle):
            settings.setValue('underline', fmt.fontUnderline())
        else:
            settings.remove('underline')
        if fmt.hasProperty(QTextFormat.ForegroundBrush):
            settings.setValue('textColor', fmt.foreground().color().name())
        else:
            settings.remove('textColor')
        if fmt.hasProperty(QTextFormat.BackgroundBrush):
            settings.setValue('backgroundColor', fmt.background().color().name())
        else:
            settings.remove('backgroundColor')
        if fmt.hasProperty(QTextFormat.TextUnderlineColor):
            settings.setValue('underlineColor', fmt.underlineColor().name())
        else:
            settings.remove('underlineColor')
        
    def loadTextFormat(self, fmt, settings):
        """(Internal) Merge values from the QSettings instance into the QTextCharFormat."""
        if settings.contains('bold'):
            fmt.setFontWeight(QFont.Bold if settings.value('bold', False, bool) else QFont.Normal)
        if settings.contains('italic'):
            fmt.setFontItalic(settings.value('italic', False, bool))
        if settings.contains('underline'):
            fmt.setFontUnderline(settings.value('underline', False, bool))
        if settings.contains('textColor'):
            fmt.setForeground(QColor(settings.value('textColor', '' , type(""))))
        if settings.contains('backgroundColor'):
            fmt.setBackground(QColor(settings.value('backgroundColor', '' , type(""))))
        if settings.contains('underlineColor'):
            fmt.setUnderlineColor(QColor(settings.value('underlineColor', '' , type(""))))


def css2fmt(d, f=None):
    """Convert a css dictionary to a QTextCharFormat."""
    if f is None:
        f = QTextCharFormat()
    v = d.get('font-style')
    if v:
        f.setFontItalic(v in ('oblique', 'italic'))
    v = d.get('font-weight')
    if v:
        if v == 'bold':
            f.setFontWeight(QFont.Bold)
        elif v == 'normal':
            f.setFontWeight(QFont.Normal)
        elif v.isdigit():
            f.setFontWeight(int(v) / 10)
    v = d.get('color')
    if v:
        f.setForeground(QColor(v))
    v = d.get('background')
    if v:
        f.setBackground(QColor(v))
    v = d.get('text-decoration')
    if v:
        f.setFontUnderline(v == 'underline')
    v = d.get('text-decoration-color')
    if v:
        f.setUnderlineColor(QColor(v))
    return f

def fmt2css(f, d=None):
    """Convert a QTextCharFormat to a css dictionary."""
    if d is None:
        d = {}
    if f.hasProperty(QTextFormat.FontWeight):
        d['font-weight'] = 'bold' if f.fontWeight() >= 70 else 'normal'
    if f.hasProperty(QTextFormat.FontItalic):
        d['font-style'] = 'italic' if f.fontItalic() else 'normal'
    if f.hasProperty(QTextFormat.TextUnderlineStyle):
        d['text-decoration'] = 'underline' if f.fontUnderline() else 'none'
    if f.hasProperty(QTextFormat.ForegroundBrush):
        d['color'] = f.foreground().color().name()
    if f.hasProperty(QTextFormat.BackgroundBrush):
        d['background'] = f.background().color().name()
    if f.hasProperty(QTextFormat.TextUnderlineColor):
        d['text-decoration-color'] = f.underlineColor().name()
    return d


baseColors = (
    'text',
    'background',
    'selectiontext',
    'selectionbackground',
    'current',
    'mark',
    'error',
    'search',
    'match',
    'paper',
    'musichighlight',
)

baseColorDefaults = dict(
    text =                lambda: QApplication.palette().color(QPalette.Text),
    background =          lambda: QApplication.palette().color(QPalette.Base),
    selectiontext =       lambda: QApplication.palette().color(QPalette.HighlightedText),
    selectionbackground = lambda: QApplication.palette().color(QPalette.Highlight),
    current =             lambda: QColor(255, 252, 149),
    mark =                lambda: QColor(192, 192, 255),
    error =               lambda: QColor(255, 192, 192),
    search =              lambda: QColor(192, 255, 192),
    match =               lambda: QColor(0, 192, 255),
    paper =               lambda: QColor(255, 253, 240),
    musichighlight =      lambda: QApplication.palette().color(QPalette.Highlight),
)

defaultStyles = (
    'keyword',
    'function',
    'variable',
    'value',
    'string',
    'escape',
    'comment',
    'error',
)


########NEW FILE########
__FILENAME__ = tokeniter
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Use this module to get the parsed tokens of a document.

The tokens are created by the syntax highlighter, see highlighter.py.
The core methods of this module are tokens() and state(). These access
the token information from the highlighter, and also run the highlighter
if it has not run yet.

If you alter the document and directly after that need the new tokens,
use update().

"""

from __future__ import unicode_literals

import collections

from PyQt4.QtGui import QTextBlock, QTextCursor

import cursortools
import highlighter


def tokens(block):
    """Returns the tokens for the given block as a (possibly empty) tuple."""
    try:
        return block.userData().tokens
    except AttributeError:
        # we used to call highlighter.highlighter(block.document()).rehighlight()
        # here, but there is a bug in PyQt-4.9.6 causing QTextBlockUserData to
        # lose its Python attributes. So we only run the highlighter when the
        # previous block's userState() is -1.
        return tuple(state(block).tokens(block.text()))


def state(block):
    """Return the ly.lex.State() object at the beginning of the given QTextBlock."""
    hl = highlighter.highlighter(block.document())
    if block.previous().userState() == -1 and block.blockNumber() > 0:
        hl.rehighlight()
    return hl.state(block.previous())


def state_end(block):
    """Return the ly.lex.State() object at the end of the given QTextBlock."""
    hl = highlighter.highlighter(block.document())
    if block.userState() == -1:
        hl.rehighlight()
    return hl.state(block)


def update(block):
    """Retokenize the given block, saving the tokens in the UserData.
    
    You only need to call this if you immediately need the new tokens again,
    e.g. for more manipulations in the same moment. The tokens will
    automatically be updated when Qt re-enters the event loop.
    
    """
    highlighter.highlighter(block.document()).rehighlightBlock(block)


def cursor(block, token, start=0, end=None):
    """Returns a QTextCursor for the given token in the given block.
    
    If start is given the cursor will start at position start in the token
    (from the beginning of the token). Start defaults to 0.
    If end is given, the cursor will end at that position in the token (from
    the beginning of the token). End defaults to the length of the token.
    
    """
    if end is None:
        end = len(token)
    cursor = QTextCursor(block)
    cursor.setPosition(block.position() + token.pos + start)
    cursor.setPosition(block.position() + token.pos + end, QTextCursor.KeepAnchor)
    return cursor


def find(text, tokens):
    """Finds text in tokens.
    
    Consumes the tokens iterable until a token with text text is found.
    Returns the found token or None.
    
    """
    if isinstance(tokens, (tuple, list)):
        try:
            i = tokens.index(text)
        except ValueError:
            return
        return tokens[i]
    for t in tokens:
        if t == text:
            return t


def index(cursor):
    """Returns the index of the token at the cursor (right or overlapping).
    
    The index can range from 0 (if there are no tokens or the cursor is in the
    first token) to the total count of tokens in the cursor's block (if the
    cursor is at the very end of the block).
    
    """
    block = cursortools.block(cursor)
    tokens_ = tokens(block)
    if cursor.atBlockEnd():
        return len(tokens_)
    pos = cursor.selectionStart() - block.position()
    lo, hi = 0, len(tokens_)
    while lo < hi:
        mid = (lo + hi) // 2
        if pos < tokens_[mid].pos:
            hi = mid
        else:
            lo = mid + 1
    return lo - 1


Partition = collections.namedtuple('Partition', 'left middle right')


def partition(cursor):
    """Returns a named three-tuple (left, middle, right).
    
    left is a tuple of tokens left to the cursor.
    middle is the token that overlaps the cursor at both sides (or None).
    right is a tuple of tokens right to the cursor.
    
    """
    block = cursortools.block(cursor)
    t = tokens(block)
    i = index(cursor)
    if t:
        if i < len(t) and t[i].pos < cursor.selectionStart() - block.position():
            return Partition(t[:i], t[i], t[i+1:])
    return Partition(t[:i], None, t[i:])


def all_tokens(document):
    """Yields all tokens of a document."""
    return (token for block in cursortools.all_blocks(document) for token in tokens(block))



########NEW FILE########
__FILENAME__ = toplevel
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Importing this module makes all other modules and packages inside this
package available as toplevel modules and packages.
"""

import os
import sys

from . import __path__ as path
sys.path[0:0] = map(os.path.abspath, path)
del path[:], path


########NEW FILE########
__FILENAME__ = unicode_blocks
#! python

"""
Unicode Block data,
http://www.unicode.org/Public/5.2.0/ucd/Blocks.txt

The blocks() function returns a list of Block named tuples: (start, end, name).
The block() function returns the Block named tuple containing the given charcode,
if any.

"""

from __future__ import unicode_literals

import collections

__all__ = ['blocks', 'block']


Block = collections.namedtuple('Block', 'start end name')


def blocks():
    """Returns a sorted list of Block tuples: (start, end, name)."""
    global _blocks
    try:
        return _blocks
    except NameError:
        _blocks = []
        for line in block_data.splitlines():
            if line and not line.startswith('#'):
                try:
                    range_, text = line.split(';', 1)
                    start, end = range_.split('..', 1)
                    _blocks.append(Block(int(start, 16), int(end, 16), text.strip()))
                except ValueError:
                    pass
        _blocks.sort()
    return _blocks


def block(charcode):
    """Returns the Block for the charcode, if any."""
    blocks_ = blocks()
    lo, hi = 0, len(blocks_)
    while lo < hi:
        mid = (lo + hi) // 2
        if blocks_[mid].start > charcode:
            hi = mid
        elif blocks_[mid].end < charcode:
            lo = mid + 1
        else:
            return blocks_[mid]


# literal Blocks-5.2.0.txt
block_data = """\
# Blocks-5.2.0.txt
# Date: 2009-05-19, 16:21:00 PDT [KW]
#
# Unicode Character Database
# Copyright (c) 1991-2009 Unicode, Inc.
# For terms of use, see http://www.unicode.org/terms_of_use.html
# For documentation, see http://www.unicode.org/reports/tr44/
#
# Note:   The casing of block names is not normative.
#         For example, "Basic Latin" and "BASIC LATIN" are equivalent.
#
# Format:
# Start Code..End Code; Block Name

# ================================================

# Note:   When comparing block names, casing, whitespace, hyphens,
#         and underbars are ignored.
#         For example, "Latin Extended-A" and "latin extended a" are equivalent.
#         For more information on the comparison of property values, 
#            see UAX #44: http://www.unicode.org/reports/tr44/
#
#  All code points not explicitly listed for Block
#  have the value No_Block.

# Property:	Block
#
# @missing: 0000..10FFFF; No_Block

0000..007F; Basic Latin
0080..00FF; Latin-1 Supplement
0100..017F; Latin Extended-A
0180..024F; Latin Extended-B
0250..02AF; IPA Extensions
02B0..02FF; Spacing Modifier Letters
0300..036F; Combining Diacritical Marks
0370..03FF; Greek and Coptic
0400..04FF; Cyrillic
0500..052F; Cyrillic Supplement
0530..058F; Armenian
0590..05FF; Hebrew
0600..06FF; Arabic
0700..074F; Syriac
0750..077F; Arabic Supplement
0780..07BF; Thaana
07C0..07FF; NKo
0800..083F; Samaritan
0900..097F; Devanagari
0980..09FF; Bengali
0A00..0A7F; Gurmukhi
0A80..0AFF; Gujarati
0B00..0B7F; Oriya
0B80..0BFF; Tamil
0C00..0C7F; Telugu
0C80..0CFF; Kannada
0D00..0D7F; Malayalam
0D80..0DFF; Sinhala
0E00..0E7F; Thai
0E80..0EFF; Lao
0F00..0FFF; Tibetan
1000..109F; Myanmar
10A0..10FF; Georgian
1100..11FF; Hangul Jamo
1200..137F; Ethiopic
1380..139F; Ethiopic Supplement
13A0..13FF; Cherokee
1400..167F; Unified Canadian Aboriginal Syllabics
1680..169F; Ogham
16A0..16FF; Runic
1700..171F; Tagalog
1720..173F; Hanunoo
1740..175F; Buhid
1760..177F; Tagbanwa
1780..17FF; Khmer
1800..18AF; Mongolian
18B0..18FF; Unified Canadian Aboriginal Syllabics Extended
1900..194F; Limbu
1950..197F; Tai Le
1980..19DF; New Tai Lue
19E0..19FF; Khmer Symbols
1A00..1A1F; Buginese
1A20..1AAF; Tai Tham
1B00..1B7F; Balinese
1B80..1BBF; Sundanese
1C00..1C4F; Lepcha
1C50..1C7F; Ol Chiki
1CD0..1CFF; Vedic Extensions
1D00..1D7F; Phonetic Extensions
1D80..1DBF; Phonetic Extensions Supplement
1DC0..1DFF; Combining Diacritical Marks Supplement
1E00..1EFF; Latin Extended Additional
1F00..1FFF; Greek Extended
2000..206F; General Punctuation
2070..209F; Superscripts and Subscripts
20A0..20CF; Currency Symbols
20D0..20FF; Combining Diacritical Marks for Symbols
2100..214F; Letterlike Symbols
2150..218F; Number Forms
2190..21FF; Arrows
2200..22FF; Mathematical Operators
2300..23FF; Miscellaneous Technical
2400..243F; Control Pictures
2440..245F; Optical Character Recognition
2460..24FF; Enclosed Alphanumerics
2500..257F; Box Drawing
2580..259F; Block Elements
25A0..25FF; Geometric Shapes
2600..26FF; Miscellaneous Symbols
2700..27BF; Dingbats
27C0..27EF; Miscellaneous Mathematical Symbols-A
27F0..27FF; Supplemental Arrows-A
2800..28FF; Braille Patterns
2900..297F; Supplemental Arrows-B
2980..29FF; Miscellaneous Mathematical Symbols-B
2A00..2AFF; Supplemental Mathematical Operators
2B00..2BFF; Miscellaneous Symbols and Arrows
2C00..2C5F; Glagolitic
2C60..2C7F; Latin Extended-C
2C80..2CFF; Coptic
2D00..2D2F; Georgian Supplement
2D30..2D7F; Tifinagh
2D80..2DDF; Ethiopic Extended
2DE0..2DFF; Cyrillic Extended-A
2E00..2E7F; Supplemental Punctuation
2E80..2EFF; CJK Radicals Supplement
2F00..2FDF; Kangxi Radicals
2FF0..2FFF; Ideographic Description Characters
3000..303F; CJK Symbols and Punctuation
3040..309F; Hiragana
30A0..30FF; Katakana
3100..312F; Bopomofo
3130..318F; Hangul Compatibility Jamo
3190..319F; Kanbun
31A0..31BF; Bopomofo Extended
31C0..31EF; CJK Strokes
31F0..31FF; Katakana Phonetic Extensions
3200..32FF; Enclosed CJK Letters and Months
3300..33FF; CJK Compatibility
3400..4DBF; CJK Unified Ideographs Extension A
4DC0..4DFF; Yijing Hexagram Symbols
4E00..9FFF; CJK Unified Ideographs
A000..A48F; Yi Syllables
A490..A4CF; Yi Radicals
A4D0..A4FF; Lisu
A500..A63F; Vai
A640..A69F; Cyrillic Extended-B
A6A0..A6FF; Bamum
A700..A71F; Modifier Tone Letters
A720..A7FF; Latin Extended-D
A800..A82F; Syloti Nagri
A830..A83F; Common Indic Number Forms
A840..A87F; Phags-pa
A880..A8DF; Saurashtra
A8E0..A8FF; Devanagari Extended
A900..A92F; Kayah Li
A930..A95F; Rejang
A960..A97F; Hangul Jamo Extended-A
A980..A9DF; Javanese
AA00..AA5F; Cham
AA60..AA7F; Myanmar Extended-A
AA80..AADF; Tai Viet
ABC0..ABFF; Meetei Mayek
AC00..D7AF; Hangul Syllables
D7B0..D7FF; Hangul Jamo Extended-B
D800..DB7F; High Surrogates
DB80..DBFF; High Private Use Surrogates
DC00..DFFF; Low Surrogates
E000..F8FF; Private Use Area
F900..FAFF; CJK Compatibility Ideographs
FB00..FB4F; Alphabetic Presentation Forms
FB50..FDFF; Arabic Presentation Forms-A
FE00..FE0F; Variation Selectors
FE10..FE1F; Vertical Forms
FE20..FE2F; Combining Half Marks
FE30..FE4F; CJK Compatibility Forms
FE50..FE6F; Small Form Variants
FE70..FEFF; Arabic Presentation Forms-B
FF00..FFEF; Halfwidth and Fullwidth Forms
FFF0..FFFF; Specials
10000..1007F; Linear B Syllabary
10080..100FF; Linear B Ideograms
10100..1013F; Aegean Numbers
10140..1018F; Ancient Greek Numbers
10190..101CF; Ancient Symbols
101D0..101FF; Phaistos Disc
10280..1029F; Lycian
102A0..102DF; Carian
10300..1032F; Old Italic
10330..1034F; Gothic
10380..1039F; Ugaritic
103A0..103DF; Old Persian
10400..1044F; Deseret
10450..1047F; Shavian
10480..104AF; Osmanya
10800..1083F; Cypriot Syllabary
10840..1085F; Imperial Aramaic
10900..1091F; Phoenician
10920..1093F; Lydian
10A00..10A5F; Kharoshthi
10A60..10A7F; Old South Arabian
10B00..10B3F; Avestan
10B40..10B5F; Inscriptional Parthian
10B60..10B7F; Inscriptional Pahlavi
10C00..10C4F; Old Turkic
10E60..10E7F; Rumi Numeral Symbols
11080..110CF; Kaithi
12000..123FF; Cuneiform
12400..1247F; Cuneiform Numbers and Punctuation
13000..1342F; Egyptian Hieroglyphs
1D000..1D0FF; Byzantine Musical Symbols
1D100..1D1FF; Musical Symbols
1D200..1D24F; Ancient Greek Musical Notation
1D300..1D35F; Tai Xuan Jing Symbols
1D360..1D37F; Counting Rod Numerals
1D400..1D7FF; Mathematical Alphanumeric Symbols
1F000..1F02F; Mahjong Tiles
1F030..1F09F; Domino Tiles
1F100..1F1FF; Enclosed Alphanumeric Supplement
1F200..1F2FF; Enclosed Ideographic Supplement
20000..2A6DF; CJK Unified Ideographs Extension B
2A700..2B73F; CJK Unified Ideographs Extension C
2F800..2FA1F; CJK Compatibility Ideographs Supplement
E0000..E007F; Tags
E0100..E01EF; Variation Selectors Supplement
F0000..FFFFF; Supplementary Private Use Area-A
100000..10FFFF; Supplementary Private Use Area-B

# EOF
"""

########NEW FILE########
__FILENAME__ = browser
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The help browser window.
"""

from __future__ import unicode_literals

import os

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import app
import helpers
import icons
import simplemarkdown

from . import __path__
from . import page
from . import util


class Window(QMainWindow):
    """The help browser window."""
    def __init__(self):
        super(Window, self).__init__()
        self.setAttribute(Qt.WA_QuitOnClose, False)
        
        self.browser = Browser(self)
        self.setCentralWidget(self.browser)
        
        self._toolbar = tb = self.addToolBar('')
        self._back = tb.addAction(icons.get('go-previous'), '')
        self._forw = tb.addAction(icons.get('go-next'), '')
        self._home = tb.addAction(icons.get('go-home'), '')
        self._toc = tb.addAction(icons.get('help-contents'), '')
        self._print = tb.addAction(icons.get('document-print'), '')
        self._back.triggered.connect(self.browser.backward)
        self._forw.triggered.connect(self.browser.forward)
        self._home.triggered.connect(self.home)
        self._toc.triggered.connect(self.toc)
        self._print.triggered.connect(self.print_)
        
        self.browser.sourceChanged.connect(self.slotSourceChanged)
        self.browser.historyChanged.connect(self.slotHistoryChanged)
        app.translateUI(self)
        self.loadSettings()
    
    def closeEvent(self, ev):
        self.saveSettings()
        super(Window, self).closeEvent(ev)
        
    def loadSettings(self):
        self.resize(QSettings().value("helpbrowser/size", QSize(400, 300), QSize))
    
    def saveSettings(self):
        QSettings().setValue("helpbrowser/size", self.size())
    
    def translateUI(self):
        self.setCaption()
        self._toolbar.setWindowTitle(_("Toolbar"))
        self._back.setText(_("Back"))
        self._forw.setText(_("Forward"))
        self._home.setText(_("Start"))
        self._toc.setText(_("Contents"))
        self._print.setText(_("Print"))
        
    def slotSourceChanged(self):
        self.setCaption()
    
    def setCaption(self):
        title = self.browser.documentTitle() or _("Help")
        self.setWindowTitle(app.caption(title) + " " + _("Help"))

    def slotHistoryChanged(self):
        self._back.setEnabled(self.browser.isBackwardAvailable())
        self._forw.setEnabled(self.browser.isForwardAvailable())
    
    def home(self):
        self.displayPage('index')
        
    def toc(self):
        self.displayPage('toc')
    
    def displayPage(self, name=None):
        """Opens the help browser showing the specified help page."""
        if name:
            self.browser.setSource(QUrl("help:" + name))
        self.show()
        self.activateWindow()
        self.raise_()
    
    def print_(self):
        printer = QPrinter()
        dlg = QPrintDialog(printer, self)
        dlg.setWindowTitle(app.caption(_("Print")))
        options = (QAbstractPrintDialog.PrintToFile
                   | QAbstractPrintDialog.PrintShowPageSize
                   | QAbstractPrintDialog.PrintPageRange)
        if self.browser.textCursor().hasSelection():
            options |= QAbstractPrintDialog.PrintSelection
        dlg.setOptions(options)
        if dlg.exec_():
            self.browser.print_(printer)


class Browser(QTextBrowser):
    def __init__(self, parent):
        super(Browser, self).__init__(parent)
        app.settingsChanged.connect(self.reload, 1)
        self.anchorClicked.connect(self.slotAnchorClicked)
        self.setOpenLinks(False)
        
    def slotAnchorClicked(self, url):
        url = self.source().resolved(url)
        if url.scheme() == "help":
            self.setSource(url)
        else:
            helpers.openUrl(url)
        
    def loadResource(self, type, url):
        if type == QTextDocument.HtmlResource:
            return util.Formatter().html(url.path())
        elif type == QTextDocument.ImageResource:
            url = QUrl.fromLocalFile(os.path.join(__path__[0], url.path()))
        return super(Browser, self).loadResource(type, url)
    
    def keyPressEvent(self, ev):
        if ev.key() == Qt.Key_Escape and int(ev.modifiers()) == 0:
            self.window().close()
        super(Browser, self).keyPressEvent(ev)



########NEW FILE########
__FILENAME__ = export
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Export the user guide to other formats and destinations.
"""

from __future__ import unicode_literals

import re

import simplemarkdown

from . import page
from . import util


class Exporter(object):
    """Export userguide pages to other formats or destinations."""
    def __init__(self):
        self._pages = []
    
    def add_page(self, name):
        """Add a help page. Return True if the page was not already added."""
        if name not in self._pages:
            self._pages.append(name)
            return True
    
    def add_recursive(self, name):
        """Add a help page and its child pages recursively."""
        def add(name):
            if self.add_page(name):
                for c in util.cache.children(name):
                    add(c)
        add(name)
    
    def replace_links(self, text):
        """Alter links in the text to other help pages.
        
        Calls replace_link() for every match of a HTML <a href...> construct.
        
        """
        return re.sub(r'<a href="([^"])">', self.replace_link, re.I)
    
    def replace_link(self, match):
        url = match.group(1)
        if '/' in url:
            return match.group()
        if url in self._pages:
            return '<a href="#{0}">'.format(match.group(1))
        return '<a href="{0}.html">'.format(match.group(1))






########NEW FILE########
__FILENAME__ = page
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Page, a page from the Frescobaldi User Manual.
"""

from __future__ import unicode_literals

import re

from PyQt4.QtCore import QSettings
from PyQt4.QtGui import QKeySequence

import simplemarkdown

from . import read
from . import resolve


class Page(object):
    def __init__(self, name=None):
        self._attrs = {}
        self._title = None
        self._body = None
        self._name = None
        if name:
            self.load(name)
    
    def load(self, name):
        """Parse and translate the named document."""
        self._name = name
        try:
            doc, attrs = read.document(name)
        except (OSError, IOError):
            doc, attrs = read.document('404')
        attrs.setdefault('VARS', []).append('userguide_page md `{0}`'.format(name))
        self.parse_text(doc, attrs)
        
    def parse_text(self, text, attrs=None):
        """Parse and translate the document."""
        self._attrs = attrs or {}
        t = self._tree = simplemarkdown.Tree()
        read.Parser().parse(text, t)
    
    def is_popup(self):
        """Return True if the helppage should be displayed as a popup."""
        try:
            return 'popup' in self._attrs['PROPERTIES']
        except KeyError:
            return False
    
    def title(self):
        """Return the title"""
        if self._title is None:
            self._title = "No Title"
            for heading in self._tree.find('heading'):
                self._title = self._tree.text(heading)
                break
        return self._title
    
    def body(self):
        """Return the HTML body."""
        if self._body is None:
            output = HtmlOutput()
            output.resolver = Resolver(self._attrs.get('VARS'))
            self._tree.copy(output)
            html = output.html()
            # remove empty paragraphs (could result from optional text)
            html = html.replace('<p></p>', '')
            self._body = html
        return self._body
        
    def children(self):
        """Return the list of names of child documents."""
        return self._attrs.get("SUBDOCS") or []
    
    def seealso(self):
        """Return the list of names of "see also" documents."""
        return self._attrs.get("SEEALSO") or []
    

class HtmlOutput(simplemarkdown.HtmlOutput):
    """Colorizes LilyPond source and replaces {variables}.
    
    Put a Resolver instance in the resolver attribute before populating
    the output.
    
    """
    heading_offset = 1
    
    def code_start(self, code, specifier=None):
        if specifier == "lilypond":
            import highlight2html
            self._html.append(highlight2html.html_text(code, full_html=False))
        else:
            self.tag('code')
            self.tag('pre')
            self.text(code)
    
    def code_end(self, code, specifier=None):
        if specifier != "lilypond":
            self.tag('/pre')
            self.tag('/code')
        self.nl()
    
    def inline_text_start(self, text):
        text = self.html_escape(text)
        text = self.resolver.format(text)   # replace {variables} ...
        self._html.append(text)


class Resolver(object):
    """Resolves variables in help documents."""
    def __init__(self, variables=None):
        """Initialize with a list of variables from the #VARS section.
        
        Every item is simply a line, where the first word is the name,
        the second the type and the rest is the contents.
        
        """
        self._variables = d = {}
        if variables:
            for v in variables:
                try:
                    name, type, text = v.split(None, 2)
                except ValueError:
                    continue
                d[name] = (type, text)
    
    def format(self, text):
        """Replaces all {variable} items in the text."""
        return read._variable_re.sub(self.replace, text)
        
    def replace(self, matchObj):
        """Return the replace string for the match.
        
        For a match like {blabla}, self.resolve('blabla') is called, and if
        the result is not None, '{blabla}' is replaced with the result.
        
        """
        result = self.resolve(matchObj.group(1))
        return matchObj.group() if result is None else result
    
    def resolve(self, name):
        """Try to find the value for the named variable.
        
        First, the #VARS section is searched. If that yields no result,
        the named function in the resolve module is called. If that yields
        no result either, None is returned.
        
        """
        
        try:
            typ, text = self._variables[name]
        except KeyError:
            try:
                return getattr(resolve, name)()
            except AttributeError:
                return
        try:
            method = getattr(self, 'handle_' + typ.lower())
        except AttributeError:
            method = self.handle_text
        return method(text)

    def handle_md(self, text):
        """Convert inline markdown to HTML."""
        return simplemarkdown.html_inline(text)

    def handle_html(self, text):
        """Return text as is, it may contain HTML."""
        return text
    
    def handle_text(self, text):
        """Return text escaped, it will not be represented as HTML."""
        return simplemarkdown.html_escape(text)

    def handle_url(self, text):
        """Return a clickable url."""
        url = text
        if text.startswith('http://'):
            text = text[7:]
        if text.endswith('/'):
            text = text[:-1]
        url = simplemarkdown.html_escape(url).replace('"', '&quot;')
        text = simplemarkdown.html_escape(text)
        return '<a href="{0}">{1}</a>'.format(url, text)

    def handle_help(self, text):
        """Return a link to the specified help page, with the title."""
        title = Page(text).title()
        url = text
        return '<a href="{0}">{1}</a>'.format(url, title)

    def handle_shortcut(self, text):
        """Return the keystroke currently defined for the action."""
        collection_name, action_name = text.split(None, 1)
        import actioncollectionmanager
        action = actioncollectionmanager.action(collection_name, action_name)
        seq = action.shortcut()
        key = seq.toString(QKeySequence.NativeText) or _("(no key defined)")
        return '<span class="shortcut">{0}</span>'.format(simplemarkdown.html_escape(key))
    
    def handle_menu(self, text):
        """Split the text on '->' in menu or action titles and translate them.
        
        The pieces are then formatted as a nice menu path.
        When an item contains a "|", the part before the "|" is the message
        context.
        
        When an item starts with "!", the accelerators are not removed (i.e.
        it is not an action or menu name).
        
        """
        pieces = [name.strip() for name in text.split('->')]
        import qutil
        def title(name):
            """Return a translated title for the name."""
            try:
                name = {
                    # untranslated standard menu names
                    'file': 'menu title|&File',
                    'edit': 'menu title|&Edit',
                    'view': 'menu title|&View',
                    'insert': 'menu title|&Insert',
                    'music': 'menu title|&Music',
                    'lilypond': 'menu title|&LilyPond',
                    'tools': 'menu title|&Tools',
                    'window': 'menu title|&Window',
                    'session': 'menu title|&Session',
                    'help': 'menu title|&Help',
                }[name]
            except KeyError:
                pass
            if name.startswith('!'):
                removeAccel = False
                name = name[1:]
            else:
                removeAccel = True
            try:
                ctxt, msg = name.split('|', 1)
                translation = _(ctxt, msg)
            except ValueError:
                translation = _(name)
            if removeAccel:
                translation = qutil.removeAccelerator(translation).strip('.')
            return translation
            
        translated = [title(name) for name in pieces]
        return '<em>{0}</em>'.format(' &#8594; '.join(translated))
        
    def handle_image(self, filename):
        url = simplemarkdown.html_escape(filename).replace('"', '&quot;')
        return '<img src="{0}" alt="{0}"/>'.format(url)

    def handle_languagename(self, code):
        """Return a language name in the current language."""
        import po.setup
        import language_names
        return language_names.languageName(code, po.setup.current())


########NEW FILE########
__FILENAME__ = read
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Reading the Frescobaldi User Manual.
"""

from __future__ import unicode_literals

import os
import re

import simplemarkdown


_variable_re = re.compile(r"\{([a-z]+(_[a-z]+)*)\}", re.UNICODE)
_document_split_re = re.compile(r'^#([A-Z]\w+)\s*$', re.MULTILINE)


def split_document(s):
    """Split the help page text and its #SUBDOCS and other headers.
    
    Returns a tuple consisting of the document text and a dictionary
    representing the #-named blocks; every value is the content of the block
    with a list of lines for every block.
    
    """
    l = _document_split_re.split(s)
    i = iter(l[1:])
    return l[0], dict((name, split_lines(value)) for name, value in zip(i, i))

def split_lines(s):
    """Split s in lines and strip() all lines. Returns a list."""
    return list(line.strip() for line in s.strip().splitlines())

def document(filename):
    if not filename.endswith('.md'):
        filename += '.md'
    if not os.path.isabs(filename):
        from . import __path__
        filename = os.path.join(__path__[0], filename)
    with open(filename, 'rb') as f:
        return split_document(f.read().decode('utf-8'))


class Parser(simplemarkdown.Parser):
    def parse_inline_text(self, text):
        text = text.replace('\n', ' ')
        if not text.startswith('!'):
            result = self.probably_translate(text)
            if result:
                super(Parser, self).parse_inline_text(result)
        else:
            result = []
            for t, tx in simplemarkdown.iter_split2(text[1:], '_(', ')_'):
                if t:
                    result.append(t)
                if tx:
                    result.append(self.probably_translate(tx))
            if None not in result:
                super(Parser, self).parse_inline_text(''.join(result))
    
    def probably_translate(self, s):
        """Translates the string if it is a sensible translatable message.
        
        The string is not translated if it does not contain any letters
        or if it is is a Python format string without any text outside the
        variable names.
        
        """
        pos = 0
        for m in _variable_re.finditer(s):
            if m.start() > pos and any(c.isalpha() for c in s[pos:m.start()]):
                return self.translate(s)
            pos = m.end()
        if pos < len(s) and any(c.isalpha() for c in s[pos:]):
            return self.translate(s)
        return s

    def translate(self, text):
        """Translates the text."""
        return _(text)



########NEW FILE########
__FILENAME__ = resolve
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
These functions return values for python format variables in user guide pages.

Some generic functions are called by several pages, but there are also some
specialistic, auto-generated parts of text that are used in a specific user
guide page.

"""

from __future__ import unicode_literals

import info


def appname():
    return info.appname

def version():
    return info.version

def author():
    return info.maintainer

def manual_translated_by():
    # L10N: Translate this sentence and fill in your own name to have it appear in the About Dialog.
    translator = _("Translated by Your Name.")
    if translator != "Translated by Your Name.":
        return translator
    return ''

def table_of_contents():
    """Return the body of the table of contents page."""
    from .util import cache, format_link
    from simplemarkdown import html_escape
    html = ['<ul>']
    seen = set()
    def addpage(page):
        if page not in seen:
            seen.add(page)
            html.append("<li>" + format_link(page) + "</li>\n")
            children = cache.children(page)
            if children:
                html.append('<ul>')
                for p in children:
                    addpage(p)
                html.append('</ul>\n')
    for page in cache.children('index'):
        addpage(page)
    html.append('</ul>\n')
    return ''.join(html)

def snippet_editor_expander():
    """Return the auto-generated list of docstrings of the snippet variables."""
    from snippet import expand
    text = []
    text.append("<dl>")
    text.extend(map("<dt><code>${0[0]}</code></dt><dd>{0[1]}</dd>".format,
                    expand.documentation(expand.Expander)))
    text.append("</dl>")
    return ''.join(text)


########NEW FILE########
__FILENAME__ = util
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Utility functions for the user guide.
"""

from __future__ import unicode_literals

import re

import app
import simplemarkdown

from .page import Page


class Formatter(object):
    """Format a full userguide page HTML."""
    def html(self, name):
        """Return a full userguide page HTML."""
        page = Page(name)
        from info import appname, version
        
        parents = cache.parents(name) if name != 'index' else []
        children = cache.children(name)
        
        qt_detail = '<qt type=detail>' if page.is_popup() else ''
        title = page.title()
        nav_up = ''
        if parents and not page.is_popup():
            pp = parents
            links = []
            while pp:
                p = pp[0]
                links.append(p)
                pp = cache.parents(p)
            nav_up = '<p>{0} {1}</p>'.format(
                _("Up:"),
                ' &#8594; '.join(map(self.format_link, reversed(links))))
        body = self.markexternal(page.body())
        nav_children, nav_next, nav_seealso = '', '', ''
        if children:
            nav_children = '<p>{0}</p>\n<ul>{1}</ul>'.format(
                _("In this chapter:"),
                '\n'.join('<li>{0}</li>'.format(self.format_link(c))
                for c in children))
        else:
            # add navigation to next page, or if last page, to next page in 
            # the first parent document that has a next page.
            html = []
            def sibling(parent, name):
                """Return the next sibling page name."""
                c = cache.children(parent)
                i = c.index(name)
                if i < len(c) - 1:
                    return c[i+1]
            for p in parents:
                next_page = sibling(p, name)
                if next_page:
                    html.append('<div>{0} {1}</div>'.format(
                        _("Next:"), self.format_link(next_page)))
                else:
                    pp = [(parent, p) for parent in cache.parents(p)]
                    while pp:
                        p1, p = pp.pop(0)
                        next_chapter = sibling(p1, p)
                        if next_chapter:
                            html.append('<div>{0} {1}</div>'.format(
                                _("Next Chapter:"), self.format_link(next_chapter)))
                        else:
                            pp.extend((parent, p1) for parent in cache.parents(p1))
            nav_next = '\n'.join(html)
        if page.seealso():
            nav_seealso = "<p>{0} {1}</p>".format(
                _("See also:"),
                ', '.join(map(self.format_link, page.seealso())))
        return self._html_template().format(**locals())

    def format_link(self, name):
        """Make a clickable link to the page."""
        return format_link(name)
    
    def markexternal(self, text):
        """Marks http(s)/ftp(s) links as external with an arrow."""
        return markexternal(text)
    
    def _html_template(self):
        """Return the userguide html template to render the html().
        
        The default implementation returns _userguide_html_template.
        
        """
        return _userguide_html_template


def format_link(name):
    """Make a clickable link to the page."""
    title = simplemarkdown.html_escape(cache.title(name))
    return '<a href="{0}">{1}</a>'.format(name, title)

def markexternal(text):
    """Marks http(s)/ftp(s) links as external with an arrow."""
    pat = re.compile(r'''<a\s+.*?href\s*=\s*(['"])(ht|f)tps?.*?\1[^>]*>''', re.I)
    return pat.sub(r'\g<0>&#11008;', text)


_userguide_html_template = '''\
{qt_detail}<html>
<head>
<style type="text/css">
body {{
  margin: 10px;
}}
</style>
<title>{title}</title>
</head>
<body>
{nav_up}
{body}
{nav_children}
{nav_next}
{nav_seealso}
<br/><hr width=80%/>
<address><center>{appname} {version}</center></address>
</body>
</html>
'''


class Cache(object):
    """Cache certain information about pages.
    
    Just one instance of this is created and put in the cache global.
    
    """
    def __init__(self):
        self._title = {}
        self._children = {}
        app.languageChanged.connect(lambda: self._title.clear(), -999)
    
    def title(self, name):
        """Return the title of the named page."""
        try:
            t = self._title[name]
        except KeyError:
            t = self._title[name] = Page(name).title()
        return t
    
    def children(self, name):
        """Return the list of children of the named page."""
        try:
            c = self._children[name]
        except KeyError:
            c = self._children[name] = Page(name).children()
        return c
        
    def parents(self, name):
        """Return the list of parents (zero or more) of the named page."""
        try:
            self._parents
        except AttributeError:
            self._parents = {}
            self._compute_parents()
        try:
            return self._parents[name]
        except KeyError:
            return []
    
    def _compute_parents(self):
        def _compute(n1):
            for n in self.children(n1):
                self._parents.setdefault(n, []).append(n1)
                _compute(n)
        _compute('index')


# one global Cache instance
cache = Cache()


########NEW FILE########
__FILENAME__ = whatsthis
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Link help:urls in WhatsThis text to the help browser.
"""

from __future__  import unicode_literals

from PyQt4.QtCore import QEvent, QObject, QUrl

from . import show


class WhatsThisHandler(QObject):
    def eventFilter(self, obj, ev):
        if ev.type() == QEvent.WhatsThisClicked:
            show(ev.href())
        return False


handler = WhatsThisHandler()


########NEW FILE########
__FILENAME__ = util
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Some utility functions.
"""

from __future__ import unicode_literals

import codecs
import glob
import itertools
import os
import re

from PyQt4.QtCore import QDir

import info
import variables


def findexe(cmd, path=None):
    """Checks the PATH for the executable and returns the absolute path or None.
    
    If path (a list or tuple of directory names) is given, it is searched as
    well when the operating system's PATH did not contain the executable.
    
    """
    if os.path.isabs(cmd):
        return cmd if os.access(cmd, os.X_OK) else None
    else:
        ucmd = os.path.expanduser(cmd)
        if os.path.isabs(ucmd):
            return ucmd if os.access(ucmd, os.X_OK) else None
        elif os.sep in cmd and os.access(cmd, os.X_OK):
            return os.path.abspath(cmd)
        else:
            paths = os.environ.get("PATH", os.defpath).split(os.pathsep)
            if path:
                paths = itertools.chain(paths, path)
            for p in paths:
                if os.access(os.path.join(p, cmd), os.X_OK):
                    return os.path.join(p, cmd)


def iswritable(path):
    """Returns True if the path can be written to or created."""
    return ((os.path.exists(path) and os.access(path, os.W_OK))
            or os.access(os.path.dirname(path), os.W_OK))


if os.name == 'nt':
    def equal_paths(p1, p2):
        """Returns True if the paths are equal (case and separator insensitive)."""
        return p1.lower().replace('\\', '/') == p2.lower().replace('\\', '/')
else:
    def equal_paths(p1, p2):
        """Returns True if the paths are equal."""
        return p1 == p2
        

# Make sure that also on Windows, directory slashes remain forward
if os.name == 'nt':
    def normpath(path):
        """A version of os.path.normpath that keeps slashes forward."""
        return os.path.normpath(path).replace('\\', '/')
else:
    normpath = os.path.normpath


def homify(path):
    """Replaces the homedirectory (if present) in the path with a tilde (~)."""
    homedir = QDir.homePath()
    if equal_paths(path[:len(homedir)+1], homedir + '/'):
        path = "~" + path[len(homedir):]
    return path


def tempdir():
    """Returns a temporary directory that is erased on app quit."""
    import tempfile
    global _tempdir
    try:
        _tempdir
    except NameError:
        _tempdir = tempfile.mkdtemp(prefix = info.name +'-')
        import atexit
        @atexit.register
        def remove():
            import shutil
            shutil.rmtree(_tempdir, ignore_errors=True)
    return tempfile.mkdtemp(dir=_tempdir)


def files(basenames, extension = '.*'):
    """Yields filenames with the given basenames matching the given extension."""
    def source():
        for name in basenames:
            name = name.replace('[', '[[]').replace('?', '[?]').replace('*', '[*]')
            if name.endswith(('/', '\\')):
                yield glob.iglob(name + '*' + extension)
            else:
                yield glob.iglob(name + extension)
                yield glob.iglob(name + '-*[0-9]' + extension)
    return sorted(uniq(itertools.chain.from_iterable(source())), key=filenamesort)


def group_files(names, groups):
    """Groups the given filenames by extension.
    
    names: an iterable (or list or tuple) yielding filenames.
    groups: an iterable (or list or tuple) yielding strings.
    
    Each group is a string containing one or more extensions, without period,
    separated by a space. If a filename has one of the extensions in the group,
    the names is added to the list of file for that group.
    An exclamation sign at the beginning of the string negates the match.
    
    Yields the same number of lists as there were group arguments.
    
    """
    allgroups = []
    for group in groups:
        if group.startswith('!'):
            pred = lambda e, ext=group[1:].split(): e not in ext
        else:
            pred = lambda e, ext=group.split(): e in ext
        allgroups.append(([], pred))
    for name in names:
        ext = os.path.splitext(name)[1][1:].lower()
        for files, pred in allgroups:
            if pred(ext):
                files.append(name)
                break
    return (files for files, pred in allgroups)


def naturalsort(text):
    """Returns a key for the list.sort() method.
    
    Intended to sort strings in a human way, for e.g. version numbers.
    
    """
    return tuple(int(s) if s.isdigit() else s for s in re.split(r'(\d+)', text))


def filenamesort(filename):
    """Return a key for sorting filenames."""
    name, ext = os.path.splitext(filename)
    return naturalsort(name), ext


def next_file(filename):
    """Return a similar filename with e.g. "-1" added before the extension.
    
    If there is already a "-n" before the extension, where n is a number,
    the number is increased by one.
    
    """
    name, ext = os.path.splitext(filename)
    try:
        a, b = name.rsplit('-', 1)
        num = int(b)
    except ValueError:
        name += '-1'
    else:
        name = a + '-' + format(num+1)
    return name + ext


def bytes_environ(encoding='latin1'):
    """Return the environment as a dictionary with bytes keys and values.
    
    This can be used for subprocess, as it chokes on Windows on unicode strings
    in Python 2.x.
    
    """
    return dict((s.encode(encoding) if type(s) is not type(b'') else s
                 for s in v) for v in os.environ.items())

    
def uniq(iterable):
    """Returns an iterable, removing duplicates. The items should be hashable."""
    s, l = set(), 0
    for i in iterable:
        s.add(i)
        if len(s) > l:
            yield i
            l = len(s)


def decode(data, encoding=None):
    """Returns the unicode text from the encoded, data. Prefer encoding if given.
    
    The text is also checked for the 'coding' document variable.
    
    """
    encodings = [encoding] if encoding else []
    for bom, encoding in (
        (codecs.BOM_UTF8, 'utf-8'),
        (codecs.BOM_UTF16_LE, 'utf_16_le'),
        (codecs.BOM_UTF16_BE, 'utf_16_be'),
            ):
        if data.startswith(bom):
            encodings.append(encoding)
            data = data[len(bom):]
            break
    else:
        var_coding = variables.variables(data).get("coding")
        if var_coding:
            encodings.append(var_coding)
    encodings.append('utf-8')
    encodings.append('latin1')
    
    for encoding in encodings:
        try:
            return data.decode(encoding)
        except (UnicodeError, LookupError):
            continue
    return data.decode('utf-8', 'replace')


def encode(text, default_encoding='utf-8'):
    """Returns the bytes representing the text, encoded.
    
    Looks at the 'coding' variable to determine the encoding,
    otherwise falls back to the given default encoding, defaulting to 'utf-8'.
    
    """
    encoding = variables.variables(text).get("coding")
    if encoding:
        try:
            return text.encode(encoding)
        except (LookupError, UnicodeError):
            pass
    return text.encode(default_encoding)



########NEW FILE########
__FILENAME__ = variables
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Infrastructure to get local variables embedded in comments in a document.
"""

from __future__ import unicode_literals

import re

from PyQt4.QtCore import QTimer

import signals
import plugin


__all__ = ['get', 'update', 'manager', 'variables']


_variable_re = re.compile(br'\s*?([a-z]+(?:-[a-z]+)*):[ \t]*(.*?);')

_LINES = 5      # how many lines from top and bottom to scan for variables


def get(document, varname, default=None):
    """Get a single value from the document.
    
    If a default is given and the type is bool or int, the value is converted to the same type.
    If no value exists, the default is returned.
    
    """
    variables = manager(document).variables()
    try:
        return prepare(variables[varname], default)
    except KeyError:
        return default


def update(document, dictionary):
    """Updates the given dictionary with values from the document, using present values as default."""
    for name, value in manager(document).variables().items():
        if name in dictionary:
            dictionary[name] = prepare(value, dictionary[name])
    return dictionary


def manager(document):
    """Returns a VariableManager for this document."""
    return VariableManager.instance(document)
    
    
def variables(text):
    """Reads variables from the first and last _LINES lines of text. Also accepts byte strings."""
    lines = text.split(b'\n')
    start, count = 0, len(lines)
    d = {}
    if count > 2 * _LINES:
        d.update(m.group(1, 2) for n, m in positions(lines[:_LINES]))
        start = count - _LINES
    d.update(m.group(1, 2) for n, m in positions(lines[start:]))
    return d
    
    
class VariableManager(plugin.DocumentPlugin):
    """Caches variables in the document and monitors for changes.
    
    The changed() Signal is emitted some time after the list of variables has been changed.
    It is recommended to not change the document itself in response to this signal.
    
    """
    changed = signals.Signal() # without argument
    
    def __init__(self, document):
        self._updateTimer = QTimer(singleShot=True, timeout=self.slotTimeout)
        self._variables = self.readVariables()
        document.contentsChange.connect(self.slotContentsChange)
        document.closed.connect(self._updateTimer.stop) # just to be sure
    
    def slotTimeout(self):
        variables = self.readVariables()
        if variables != self._variables:
            self._variables = variables
            self.changed()
        
    def slotContentsChange(self, position, removed, added):
        """Called if the document changes."""
        if (self.document().findBlock(position).blockNumber() < _LINES or
            self.document().findBlock(position + added).blockNumber() > self.document().blockCount() - _LINES):
            self._updateTimer.start(500)
    
    def variables(self):
        """Returns the document variables (cached) as a dictionary. This method is recommended."""
        if self._updateTimer.isActive():
            # an update is pending, force it
            self._updateTimer.stop()
            self.slotTimeout()
        return self._variables
    
    def readVariables(self):
        """Reads the variables from the document and returns a dictionary. Internal."""
        count = self.document().blockCount()
        blocks = [self.document().firstBlock()]
        if count > _LINES * 2:
            blocks.append(self.document().findBlockByNumber(count - _LINES))
            count = _LINES
        def lines(block):
            for i in range(count):
                yield block.text()
                block = block.next()
        variables = {}
        for block in blocks:
            variables.update(m.group(1, 2) for n, m in positions(lines(block)))
        return variables
        

def positions(lines):
    """Lines should be an iterable returning lines of text.
    
    Returns an iterable yielding tuples (lineNum, matchObj) for every variable found.
    Every matchObj has group(1) pointing to the variable name and group(2) to the value.
    
    """
    commentstart = ''
    interesting = False
    for lineNum, text in enumerate(lines):
        # first check the line start
        start = 0
        if interesting:
            # already parsing? then skip comment start tokens
            m = re.match(br'\s*{0}'.format(re.escape(commentstart)), text)
            if m:
                start = m.end()
        else:
            # does the line have '-*-' ?
            m = re.search(br'(\S*)\s*-\*-', text)
            if m:
                interesting = True
                commentstart = m.group(1)
                start = m.end()
        # now parse the line
        if interesting:
            while True:
                m = _variable_re.match(text, start)
                if m:
                    yield lineNum, m
                    start = m.end()
                else:
                    if start < len(text) and not text[start:].isspace():
                        interesting = False
                    break


def prepare(value, default):
    """Try to convert the value (which is a string) to the type of the default value.
    
    If (for int and bool) that fails, returns the default, otherwise returns the string unchanged.
    
    """
    if isinstance(default, bool):
        if value.lower() in ('true', 'yes', 'on', 't', '1'):
            return True
        elif value.lower() in ('false', 'no', 'off', 'f', '0'):
            return False
        return default
    elif isinstance(default, int):
        try:
            return int(value)
        except ValueError:
            return default
    return value



########NEW FILE########
__FILENAME__ = abstractrepo
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
VCS interface (application and documents)
"""

import sys
import os
from abc import ABCMeta, abstractmethod

class AbstractVCSRepo(object):
    """
    Interface for classes managing VCS repositories.
    Currently we only support Git, but this level of
    abstraction is intended to offer an interface to
    add other VCS comparably easily.
    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def branches(self, local=True):
        pass

    @abstractmethod
    def checkout(self, branch):
        pass
        
    @abstractmethod
    def current_branch(self):
        """
        Returns the name of the current branch.
        """
        pass

    @abstractmethod
    def has_branch(self, branch):
        """
        Returns True if the given branch exists.
        Checks by actually running git branch.
        """
        pass
    
    @abstractmethod
    def has_remote(self, remote):
        """Returns True if the given remote name is registered."""
        pass

    @abstractmethod
    def has_remote_branch(self, branch):
        """
        Return True if the given branch
        is tracking a remote branch.
        """
        pass
    
    @abstractmethod
    def remotes(self):
        """Return a string list with registered remote names"""
        pass

    @abstractmethod
    def tracked_remote(self, branch):
        """
        Return a tuple with the remote and branch tracked by
        the given branch.
        In most cases both values will be identical, but a branch
        can also track a differently named remote branch.
        Return ('local', 'local') if it doesn't track any branch.
        """
        pass
    
    @abstractmethod
    def tracked_remote_label(self, branch):
        """
        Return a string to be used for remote branch info.
        Either 'local', the remote name or remote/branch.
        """
        pass

########NEW FILE########
__FILENAME__ = apprepo
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Repository of Frescobaldi application.
"""

from __future__ import unicode_literals

import sys
import os

from gitrepo import GitRepo

# Reference to distinguish the official repository from forks.
upstream_repository = "wbsoft/frescobaldi"

class AppRepo(GitRepo):
    """
    Subclass to be used for the Frescobaldi Git repository.
    Offers methods exclusively useful for this specific repo.
    """
    def __init__(self):
        super(AppRepo, self).__init__((os.path.normpath(
                                        os.path.join(sys.path[0], '..'))))
        self._activeBranch = self.current_branch()
    
    def active_branch(self):
        """
        Returns the name of the branch that was current_branch
        when the application has started.
        current_branch() may of course change during the
        runtime of the application
        """
        return self._activeBranch
    
    def upstream_remote(self):
        """
        Returns the name of the official
        upstream remote or '' in case this shouldn't be registered
        (e.g. one runs from a fork)
        """
        for remote in self.remotes():
            if upstream_repository in self.config['remote'][remote]['url']:
                return remote
        return ''

########NEW FILE########
__FILENAME__ = gitrepo
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manage a Git repository
"""

from __future__ import unicode_literals

import sys
import os
import subprocess

from abstractrepo import AbstractVCSRepo

class GitError(Exception):
    pass
    
class GitRepo(AbstractVCSRepo):
    """
    Manage a git repository, be it
    the running Frescobaldi application
    or a document's project.
    """
    def __init__(self, root):
        if not os.path.isdir(os.path.join(root, '.git')):
            raise Exception(_("The given directory '{rootdir} "
                              "doesn't seem to be a Git repository.".format(rootdir=root)))
        self.rootDir = root
        self._read_config()
    
    # #########################
    # Internal helper functions
    
    def _key_value(self, line):
        """
        Return a tuple with the key and value parts of a
        .git/config section entry.
        """
        line = line.strip()
        sep = line.find('=')
        return (line[:sep-1], line[sep+2:])
        
    def _read_config(self):
        """
        Produce a hierarchical dictionary representing the
        .git/config file.
        Currently we will only use the 'branch' and 'remote'
        dictionaries:
        - self.config['branch']
        - self.config['remote']
        """
        
        # The Git object can only be instantiated with a valid repo.
        # So we can assume .git/config to be present 
        fin = open(os.path.join(self.rootDir, '.git', 'config'))
        lines = fin.read().split('\n')
        
        # reset config dictionary
        cf = self.config = {}
        # target will be the (sub-)dictionary to add keys to
        target = {}
        # parse file
        for line in lines:
            if line == '' or line.strip().startswith('#'):
                continue
            elif line.startswith('['):
                # add new section
                items = line.strip('[').strip(']').split()
                if not items[0] in cf:
                    cf[items[0]] = {}
                target = cf[items[0]]
                if len(items) > 1:
                    name = items[1].strip('"')
                    if not name in target:
                        target[name] = {}
                    target = target[name]
            else:
                # add new key-value pair
                key, value = self._key_value(line)
                target[key] = value        
        return
                
    def _run_git_command(self, cmd, args = []): 
        """
        run a git command and return its output
        as a string list.
        Raise an exception if it returns an error.
        - cmd is the git command (without 'git')
        - args is a string or a list of strings
        """
        from PyQt4.QtCore import QSettings
        s = QSettings()
        s.beginGroup("helper_applications")
        git_cmd = s.value("git", "git", type(""))
        git_cmd = git_cmd if git_cmd else "git"
        cmd = [git_cmd, cmd]
        if isinstance(args, str) or isinstance(args, unicode):
            cmd.append(args)
        else:
            cmd.extend(args)
        pr = subprocess.Popen(' '.join(cmd), cwd = self.rootDir, 
                              shell = True, 
                              stdout = subprocess.PIPE, 
                              stderr = subprocess.PIPE)
        (out, error) = pr.communicate()
        if error:
            raise GitError(str(error))
        result = str(out).split('\n')
        if result[-1] == '':
            result.pop()
        return result

    # ####################
    # Public API functions

    def branches(self, local=True):
        """
        Returns a string list of branch names.
        The currently checked out branch will have a
        leading '* '.
        If local == False also return 'remote' branches.
        """
        args = [] if local else ['-a']
        args.append('--color=never')
        return [line.strip() for line in self._run_git_command('branch', args)]
        
    def checkout(self, branch):
        """
        Tries to checkout a branch.
        Add '-q' option because git checkout will
        return its confirmation message on stderr.
        May raise a GitError exception"""
        self._run_git_command('checkout', ['-q', branch])
        
    def current_branch(self):
        """
        Returns the name of the current branch.
        """
        for branch in self.branches():
            if branch[0] == '*':
                return branch[2:]
        raise GitError('current_branch: No branch found')

    def has_branch(self, branch):
        """
        Returns True if the given branch exists.
        Checks by actually running git branch.
        """
        for br in self.branches():
            if br.strip('* ') == branch :
                return True 
        return False
    
    def has_remote(self, remote):
        """Returns True if the given remote name is registered."""
        return remote in self.config['remote']
        
    def has_remote_branch(self, branch):
        """
        Return True if the given branch
        is tracking a remote branch.
        Checks if the branch is present in .git/config
        """
        return branch in self.config['branch']
        
    def remotes(self):
        """Return a string list with registered remote names"""
        return self._run_git_command('remote show')
        
    def tracked_remote(self, branch):
        """
        Return a tuple with the remote and branch tracked by
        the given branch.
        In most cases both values will be identical, but a branch
        can also track a differently named remote branch.
        Return ('local', 'local') if it doesn't track any branch.
        """
        if not self.has_branch(branch):
            raise GitError('Branch not found: ' + branch)
        if self.has_remote_branch(branch):
            remote_name = self.config['branch'][branch]['remote']
            remote_merge = self.config['branch'][branch]['merge']
            remote_branch = remote_merge[remote_merge.rfind('/')+1:]
            return (remote_name, remote_branch)
        else:
            return ('local', 'local')
    
    def tracked_remote_label(self, branch):
        """
        Returns a label for the tracked branch to be used in the GUI.
        Consists of one of
        - 'local'
        - the remote name
        - remote name concatenated with the remote branch
          (if it should differ from the local branch name).
        """
        remote, remote_branch = self.tracked_remote(branch)
        if remote == 'local':
            return 'local'
        if branch == remote_branch:
            return remote
        else:
            return remote + '/' + remote_branch


########NEW FILE########
__FILENAME__ = menu
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
The Git menu.
Currently only list local branches, allowing one to switch to that branch.
"""

from __future__ import unicode_literals

from PyQt4.QtGui import QAction, QActionGroup, QMenu, QMessageBox

import app
import mainwindow
import plugin
import vcs

class GitMenu(QMenu):
    def __init__(self, mainwindow):
        super(GitMenu, self).__init__(mainwindow)
        self.aboutToShow.connect(self.populate)
        app.translateUI(self)
    
    def translateUI(self):
        self.setTitle(_('menu title', '&Git'))
    
    def populate(self):
        self.clear()
        mainwindow = self.parentWidget()
        for a in GitBranchGroup.instance(mainwindow).actions():
            self.addAction(a)
            

class GitBranchGroup(QActionGroup, plugin.MainWindowPlugin):
    """
    Maintains a list of actions to switch the branch
    Frescobali is run from.
    
    The actions are added to the Git menu in order to be able
    to switch the branch Frescobaldi is run from.
    The actions also get accelerators that are kept
    during their lifetime.
    
    """
    def __init__(self, mainwindow):
        super(GitBranchGroup, self).__init__(mainwindow)
        self._acts = {}
        self._accels = {}
        self.setExclusive(True)
        for branch in vcs.app_repo.branches():
            self.addBranch(branch.lstrip('* '))
        self.triggered.connect(self.slotTriggered)
    
    def actions(self):
        """
        Returns a list with actions for each branch.
        If a branch has been externally created since
        the last run of this function a new action
        is added to self._acts.
        If a branch has been removed the action is kept,
        so if the branch is reintroduced later the action
        will have the same accelerator.
        """
        result = []
        for branch in vcs.app_repo.branches():
            branch = branch.lstrip('* ')
            if not branch in self._acts:
                self.addBranch(branch)
            result.append(self._acts[branch])
        return result

    def addBranch(self, branch):
        a = QAction(self)
        a.setCheckable(True)
        if branch == vcs.app_repo.current_branch():
            a.setChecked(True)
            a.setEnabled(False)
        self._acts[branch] = a
        self.setBranchStatus(branch)

    def setBranchStatus(self, branch):
        # create accels
        accels = [self._accels[b] for b in self._accels if b != branch]
        name = branch = branch.lstrip('* ')
        for index, char in enumerate(name):
            if char.isalnum() and char.lower() not in accels:
                name = name[:index] + '&' + name[index:]
                self._accels[branch] = char.lower()
                break
        else:
            self._accels[branch] = ''
        name = name + " ({0})".format(vcs.app_repo.tracked_remote_label(branch))
        self._acts[branch].setText(name)
    
    def slotTriggered(self, action):
        msgBox = QMessageBox()
        new_branch = self._acts.keys()[self._acts.values().index(action)]
        try:
            vcs.app_repo.checkout(new_branch)
            msgBox.setText(_("Checkout Successful"))
            msgBox.setInformativeText(_("Successfully checked out branch {name}.\n"
                "Changes will take effect after restart.\n"
                "Do you want to restart now?").format(name=new_branch))
            msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
            if msgBox.exec_() == QMessageBox.Ok:
                self.parent().restart()
        except git.GitError as giterror:
            msgBox.setText(_("Git Checkout Error"))
            msgBox.setInformativeText(str(giterror))
            msgBox.exec_()
            action.setChecked(False)
            self._acts[vcs.app_repo.current_branch()].setChecked(True)

########NEW FILE########
__FILENAME__ = test
# Test file to test and demonstrate the API for the vcs module.

from vcs import app_repo

print('Debugging the git module')
print('List of remotes:')
print(app_repo.remotes())
print('List of branches (local):')
print(app_repo.branches())
print('List of branches(incl. remotes):')
print(app_repo.branches(False))
print()
print('List of branches with tracked remotes:')
for branch in app_repo.branches():
    print(branch, app_repo.tracked_remote_label(branch.lstrip('* ')))
print('Current branch:')
print(app_repo.current_branch())
if app_repo.has_branch('master'):
    if app_repo.has_remote_branch('master'):
        remote, rem_branch = app_repo.tracked_remote('master')
        print('master has remote: ', remote, rem_branch)
    else:
        print('master doesn\'t have a remote branch')
print('has remote dummy:', app_repo.has_remote('dummy'))
print('has remote origin:', app_repo.has_remote('origin'))
print('has remote upstream:', app_repo.has_remote('upstream'))

upstream = app_repo.upstream_remote()
if upstream == '':
    print('No remote tracking upstream')
else:
    print()
    print('remote tracking the official repo:', upstream)
    print('URL:', app_repo.config['remote'][upstream]['url'])

########NEW FILE########
__FILENAME__ = view
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
View is basically a QPlainTextEdit instance.

It is used to edit a Document. The ViewManager (see viewmanager.py)
has support for showing multiple Views in a window.
"""

from __future__ import unicode_literals

import weakref

from PyQt4.QtCore import QEvent, QSettings, Qt, QTimer, pyqtSignal
from PyQt4.QtGui import (
    QApplication, QContextMenuEvent, QKeySequence, QPainter, QPlainTextEdit,
    QTextCursor)

import app
import homekey
import metainfo
import textformats
import cursortools
import variables


metainfo.define('auto_indent', True)
metainfo.define('position', 0)


class View(QPlainTextEdit):
    """View is the text editor widget a Document is displayed and edited with.
    
    It is basically a QPlainTextEdit with some extra features:
    - it draws a grey cursor when out of focus
    - it reads basic palette colors from the preferences
    - it determines tab width from the document variables (defaulting to 8 characters)
    - it stores the cursor position in the metainfo
    - it runs the auto_indenter when enabled (also checked via metainfo)
    - it can display a widget in the bottom using showWidget and hideWidget.
    
    """
    def __init__(self, document):
        """Creates the View for the given document."""
        super(View, self).__init__()
        self.setDocument(document)
        self.setLineWrapMode(QPlainTextEdit.NoWrap)
        self.setCursorWidth(2)
        # restore saved cursor position (defaulting to 0)
        document.loaded.connect(self.restoreCursor)
        document.loaded.connect(self.setTabWidth)
        document.closed.connect(self.slotDocumentClosed)
        variables.manager(document).changed.connect(self.setTabWidth)
        self.restoreCursor()
        app.settingsChanged.connect(self.readSettings)
        self.readSettings() # will also call updateCursor
        # line wrap preference is only read on init
        wrap = QSettings().value("view_preferences/wrap_lines", False, bool)
        self.setLineWrapMode(QPlainTextEdit.WidgetWidth if wrap else QPlainTextEdit.NoWrap)
        app.viewCreated(self)

    def event(self, ev):
        if ev in (
                # avoid the line separator, makes no sense in plain text
                QKeySequence.InsertLineSeparator,
                # those can better be called via the menu actions, then they
                # work better
                QKeySequence.Undo,
                QKeySequence.Redo,
            ):
            return False
        # handle Tab and Backtab
        if ev.type() == QEvent.KeyPress:
            cursor = self.textCursor()
            if ev.key() == Qt.Key_Tab and ev.modifiers() == Qt.NoModifier:
                # tab pressed, insert a tab when no selection and in text,
                # else increase the indent
                if not cursor.hasSelection():
                    block = cursor.block()
                    text = block.text()[:cursor.position() - block.position()]
                    if text and not text.isspace():
                        if variables.get(self.document(), 'document-tabs', True):
                            cursor.insertText('\t')
                        else:
                            tabwidth = variables.get(self.document(), 'tab-width', 8)
                            spaces = tabwidth - len(text.expandtabs(tabwidth)) % tabwidth
                            cursor.insertText(' ' * spaces)
                        self.setTextCursor(cursor)
                        return True
                import indent
                indent.increase_indent(cursor)
                if not cursor.hasSelection():
                    cursortools.strip_indent(cursor)
                    self.setTextCursor(cursor)
                return True
            elif ev.key() == Qt.Key_Backtab and ev.modifiers() == Qt.ShiftModifier:
                # shift-tab pressed, decrease the indent
                import indent
                indent.decrease_indent(cursor)
                if not cursor.hasSelection():
                    cursortools.strip_indent(cursor)
                    self.setTextCursor(cursor)
                return True
        return super(View, self).event(ev)

    def keyPressEvent(self, ev):
        if homekey.handle(self, ev):
            return
        super(View, self).keyPressEvent(ev)
        
        if metainfo.info(self.document()).auto_indent:
            # run the indenter on Return or when the user entered a dedent token.
            import indent
            cursor = self.textCursor()
            if ev.text() == '\r' or (ev.text() in ('}', '#', '>') and indent.indentable(cursor)):
                indent.auto_indent_block(cursor.block())
                # fix subsequent vertical moves
                cursor.setPosition(cursor.position())
                self.setTextCursor(cursor)
            
    def focusOutEvent(self, ev):
        """Reimplemented to store the cursor position on focus out."""
        super(View, self).focusOutEvent(ev)
        self.storeCursor()

    def dragEnterEvent(self, ev):
        """Reimplemented to avoid showing the cursor when dropping URLs."""
        if ev.mimeData().hasUrls():
            ev.accept()
        else:
            super(View, self).dragEnterEvent(ev)
        
    def dragMoveEvent(self, ev):
        """Reimplemented to avoid showing the cursor when dropping URLs."""
        if ev.mimeData().hasUrls():
            ev.accept()
        else:
            super(View, self).dragMoveEvent(ev)
        
    def dropEvent(self, ev):
        """Called when something is dropped.
        
        Calls dropEvent() of MainWindow if URLs are dropped.
        
        """
        if ev.mimeData().hasUrls():
            self.window().dropEvent(ev)
        else:
            super(View, self).dropEvent(ev)

    def paintEvent(self, ev):
        """Reimplemented to paint a cursor if we have no focus."""
        super(View, self).paintEvent(ev)
        if not self.hasFocus():
            rect = self.cursorRect()
            if rect.intersects(ev.rect()):
                color = self.palette().text().color()
                color.setAlpha(128)
                QPainter(self.viewport()).fillRect(rect, color)
    
    def readSettings(self):
        data = textformats.formatData('editor')
        self.setFont(data.font)
        self.setPalette(data.palette())
        self.setTabWidth()
        
    def slotDocumentClosed(self):
        if self.hasFocus():
            self.storeCursor()
            
    def restoreCursor(self):
        """Places the cursor on the position saved in metainfo."""
        cursor = QTextCursor(self.document())
        cursor.setPosition(metainfo.info(self.document()).position)
        self.setTextCursor(cursor)
        QTimer.singleShot(0, self.ensureCursorVisible)
    
    def storeCursor(self):
        """Stores our cursor position in the metainfo."""
        metainfo.info(self.document()).position = self.textCursor().position()

    def setTabWidth(self):
        """(Internal) Reads the tab-width variable and the font settings to set the tabStopWidth."""
        tabwidth = QSettings().value("indent/tab_width", 8, int)
        tabwidth = self.fontMetrics().width(" ") * variables.get(self.document(), 'tab-width', tabwidth)
        self.setTabStopWidth(tabwidth)
    
    def contextMenuEvent(self, ev):
        """Called when the user requests the context menu."""
        cursor = self.textCursor()
        if ev.reason() == QContextMenuEvent.Mouse:
            # if clicked inside the selection, retain it, otherwise de-select
            # and move the cursor to the clicked position
            pos = self.mapToGlobal(ev.pos())
            clicked = self.cursorForPosition(ev.pos())
            if not cursor.selectionStart() <= clicked.position() < cursor.selectionEnd():
                self.setTextCursor(clicked)
        else:
            pos = self.viewport().mapToGlobal(self.cursorRect().center())
        import contextmenu
        menu = contextmenu.contextmenu(self)
        menu.popup(pos)
        menu.setFocus() # so we get a FocusOut event and the grey cursor gets painted
        menu.exec_()
        menu.deleteLater()

    def mousePressEvent(self, ev):
        """Called when a mouse button is clicked."""
        # implements ctrl-click
        if ev.button() == Qt.LeftButton and ev.modifiers() == Qt.ControlModifier:
            cursor = self.textCursor()
            clicked = self.cursorForPosition(ev.pos())
            if cursor.selectionStart() <= clicked.position() < cursor.selectionEnd():
                clicked = cursor
            # include files?
            import open_file_at_cursor
            if open_file_at_cursor.open_file_at_cursor(self.window(), clicked):
                return
            # go to definition?
            import definition
            if definition.goto_definition(self.window(), clicked):
                return
        super(View, self).mousePressEvent(ev)



########NEW FILE########
__FILENAME__ = viewhighlighter
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages highlighting of arbitrary things in a View, e.g.
the current line, marked lines, search results etc.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QEvent
from PyQt4.QtGui import QColor, QTextCharFormat, QTextFormat

import app
import plugin
import bookmarks
import textformats
import widgets.arbitraryhighlighter


def highlighter(view):
    return ViewHighlighter.instance(view)


app.viewCreated.connect(highlighter)


class ViewHighlighter(widgets.arbitraryhighlighter.ArbitraryHighlighter, plugin.Plugin):
    def __init__(self, view):
        super(ViewHighlighter, self).__init__(view)
        self._cursorFormat = QTextCharFormat()
        self._cursorFormat.setProperty(QTextFormat.FullWidthSelection, True)
        app.settingsChanged.connect(self.readSettings)
        self.readSettings()
        bookmarks.bookmarks(view.document()).marksChanged.connect(self.updateMarkedLines)
        self.updateMarkedLines()
        view.cursorPositionChanged.connect(self.updateCursor)
        view.installEventFilter(self)

    def updateMarkedLines(self):
        """Called when something changes in the bookmarks."""
        for type, marks in bookmarks.bookmarks(self.parent().document()).marks().items():
            self.highlight(type, marks, -1)
    
    def eventFilter(self, view, ev):
        if ev.type() in (QEvent.FocusIn, QEvent.FocusOut):
            self.updateCursor(view)
        return False
    
    def updateCursor(self, view=None):
        """Called when the textCursor has moved. Highlights the current line.
        
        If view is None (the default), our parent() is assumed to be the
        view. The eventFilter() method calls us with the view, this is
        done because the event filter is sometimes called very late in
        the destructor phase, when our parent is possibly not valid
        anymore.
        
        """
        if view is None:
            view = self.parent()
        # sometimes in the destruction phase, view is a generic QWidget...
        try:
            cursor = view.textCursor()
        except AttributeError:
            return
        # highlight current line
        cursor.clearSelection()
        color = QColor(self._baseColors['current'])
        color.setAlpha(200 if view.hasFocus() else 100)
        self._cursorFormat.setBackground(color)
        self.highlight(self._cursorFormat, [cursor], 0)
        
    def readSettings(self):
        data = textformats.formatData('editor')
        self._baseColors = data.baseColors
        self.updateCursor()
        self.reload()

    def textFormat(self, name):
        """(Internal) Returns a QTextCharFormat setup according to the preferences.
        
        For bookmarks and the current line, FullWidthSelection is automatically enabled.
        
        """
        f = QTextCharFormat()
        f.setBackground(self._baseColors[name])
        if name in ('current', 'mark', 'error'):
            f.setProperty(QTextFormat.FullWidthSelection, True)
        return f



########NEW FILE########
__FILENAME__ = viewmanager
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
ViewManager is a QSplitter containing sub-splitters to display multiple
ViewSpaces.
ViewSpace is a QStackedWidget with a statusbar, capable of displaying one of
multiple views.
"""

from __future__ import unicode_literals

import contextlib
import weakref

from PyQt4.QtCore import QEvent, Qt, pyqtSignal
from PyQt4.QtGui import (
    QAction, QHBoxLayout, QKeySequence, QLabel, QMenu, QPixmap, QProgressBar,
    QSplitter, QStackedWidget, QVBoxLayout, QWidget)

import actioncollection
import app
import icons
import view as view_
import qutil


class ViewStatusBar(QWidget):
    def __init__(self, parent=None):
        super(ViewStatusBar, self).__init__(parent)
        
        layout = QHBoxLayout()
        layout.setContentsMargins(2, 1, 0, 1)
        layout.setSpacing(4)
        self.setLayout(layout)
        self.pos = QLabel()
        layout.addWidget(self.pos)
        
        self.state = QLabel()
        self.state.setFixedSize(16, 16)
        layout.addWidget(self.state)
        
        self.info = QLabel()
        layout.addWidget(self.info, 1)
        
        self.installEventFilter(self)
        self.translateUI()
        app.languageChanged.connect(self.translateUI)
        
    def translateUI(self):
        text = _("Line: {line}, Col: {column}").format(line=9999, column=99)
        self.pos.setMinimumWidth(self.pos.fontMetrics().width(text))
    
    def eventFilter(self, obj, ev):
        if ev.type() == QEvent.MouseButtonPress:
            if ev.button() == Qt.RightButton:
                self.showContextMenu(ev.globalPos())
            else:
                self.parent().activeView().setFocus()
            return True
        return False

    def showContextMenu(self, pos):
        menu = QMenu(self)
        menu.aboutToHide.connect(menu.deleteLater)
        viewspace = self.parent()
        manager = viewspace.manager()
        
        a = QAction(icons.get('view-split-top-bottom'), _("Split &Horizontally"), menu)
        menu.addAction(a)
        a.triggered.connect(lambda: manager.splitViewSpace(viewspace, Qt.Vertical))
        a = QAction(icons.get('view-split-left-right'), _("Split &Vertically"), menu)
        menu.addAction(a)
        a.triggered.connect(lambda: manager.splitViewSpace(viewspace, Qt.Horizontal))
        menu.addSeparator()
        a = QAction(icons.get('view-close'), _("&Close View"), menu)
        a.triggered.connect(lambda: manager.closeViewSpace(viewspace))
        a.setEnabled(manager.canCloseViewSpace())
        menu.addAction(a)
        
        menu.exec_(pos)


class ViewSpace(QWidget):
    """A ViewSpace manages a stack of views, one of them is visible.
    
    The ViewSpace also has a statusbar, accessible in the status attribute.
    The viewChanged(View) signal is emitted when the current view for this ViewSpace changes.
    
    Also, when a ViewSpace is created (e.g. when a window is created or split), the
    app.viewSpaceCreated(space) signal is emitted.
    
    You can use the app.viewSpaceCreated() and the ViewSpace.viewChanged() signals to implement
    things on a per ViewSpace basis, e.g. in the statusbar of a ViewSpace.
    
    """
    viewChanged = pyqtSignal(view_.View)
    
    def __init__(self, manager, parent=None):
        super(ViewSpace, self).__init__(parent)
        self.manager = weakref.ref(manager)
        self.views = []
        
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        self.setLayout(layout)
        self.stack = QStackedWidget(self)
        layout.addWidget(self.stack)
        self.status = ViewStatusBar(self)
        self.status.setEnabled(False)
        layout.addWidget(self.status)
        app.languageChanged.connect(self.updateStatusBar)
        app.viewSpaceCreated(self)
        
    def activeView(self):
        if self.views:
            return self.views[-1]

    def document(self):
        """Returns the currently active document in this space.
        
        If there are no views, returns None.
        
        """
        if self.views:
            return self.views[-1].document()
    
    def showDocument(self, doc):
        """Shows the document, creating a View if necessary."""
        if doc is self.document():
            return
        cur = self.activeView()
        for view in self.views[:-1]:
            if doc is view.document():
                self.views.remove(view)
                break
        else:
            view = view_.View(doc)
            self.stack.addWidget(view)
        self.views.append(view)
        if cur:
            self.disconnectView(cur)
        self.connectView(view)
        self.stack.setCurrentWidget(view)
        self.updateStatusBar()
        
    def removeDocument(self, doc):
        active = doc is self.document()
        if active:
            self.disconnectView(self.activeView())
        for view in self.views:
            if doc is view.document():
                self.views.remove(view)
                view.deleteLater()
                break
        else:
            return
        if active and self.views:
            self.connectView(self.views[-1])
            self.stack.setCurrentWidget(self.views[-1])
            self.updateStatusBar()
    
    def connectView(self, view):
        view.installEventFilter(self)
        view.cursorPositionChanged.connect(self.updateCursorPosition)
        view.modificationChanged.connect(self.updateModificationState)
        view.document().urlChanged.connect(self.updateDocumentName)
        self.viewChanged.emit(view)

    def disconnectView(self, view):
        view.removeEventFilter(self)
        view.cursorPositionChanged.disconnect(self.updateCursorPosition)
        view.modificationChanged.disconnect(self.updateModificationState)
        view.document().urlChanged.disconnect(self.updateDocumentName)
    
    def eventFilter(self, view, ev):
        if ev.type() == QEvent.FocusIn:
            self.setActiveViewSpace()
        return False

    def setActiveViewSpace(self):
        self.manager().setActiveViewSpace(self)
        
    def updateStatusBar(self):
        """Update all info in the statusbar, e.g. on document change."""
        if self.views:
            self.updateCursorPosition()
            self.updateModificationState()
            self.updateDocumentName()
        
    def updateCursorPosition(self):
        cur = self.activeView().textCursor()
        line = cur.blockNumber() + 1
        try:
            column = cur.positionInBlock()
        except AttributeError: # only in very recent PyQt4
            column = cur.position() - cur.block().position()
        self.status.pos.setText(_("Line: {line}, Col: {column}").format(
            line = line, column = column))
    
    def updateModificationState(self):
        modified = self.document().isModified()
        pixmap = icons.get('document-save').pixmap(16) if modified else QPixmap()
        self.status.state.setPixmap(pixmap)
    
    def updateDocumentName(self):
        self.status.info.setText(self.document().documentName())


class ViewManager(QSplitter):
    
    # This signal is always emitted on setCurrentDocument,
    # even if the view is the same as before.
    # use MainWindow.currentViewChanged() to be informed about
    # real View changes.
    viewChanged = pyqtSignal(view_.View)
    
    # This signal is emitted when another ViewSpace becomes active.
    activeViewSpaceChanged = pyqtSignal(ViewSpace, ViewSpace)
    
    def __init__(self, parent=None):
        super(ViewManager, self).__init__(parent)
        self._viewSpaces = []
        
        viewspace = ViewSpace(self)
        viewspace.status.setEnabled(True)
        self.addWidget(viewspace)
        self._viewSpaces.append(viewspace)
        
        self.createActions()
        app.documentClosed.connect(self.slotDocumentClosed)
    
    def setCurrentDocument(self, doc, findOpenView=False):
        if doc is not self.activeViewSpace().document():
            done = False
            if findOpenView:
                for space in self._viewSpaces[-2::-1]:
                    if doc is space.document():
                        done = True
                        self.setActiveViewSpace(space)
                        break
            if not done:
                self.activeViewSpace().showDocument(doc)
        self.viewChanged.emit(self.activeViewSpace().activeView())
        # the active space now displays the requested document
        # now also set this document in spaces that are empty
        for space in self._viewSpaces[:-1]:
            if not space.document():
                space.showDocument(doc)
        self.focusActiveView()
        
    def focusActiveView(self):
        self.activeViewSpace().activeView().setFocus()
        
    def setActiveViewSpace(self, space):
        prev = self._viewSpaces[-1]
        if space is prev:
            return
        self._viewSpaces.remove(space)
        self._viewSpaces.append(space)
        prev.status.setEnabled(False)
        space.status.setEnabled(True)
        self.activeViewSpaceChanged.emit(space, prev)
        self.viewChanged.emit(space.activeView())

    def slotDocumentClosed(self, doc):
        activeDocument = self.activeViewSpace().document()
        for space in self._viewSpaces:
            space.removeDocument(doc)
        if doc is not activeDocument:
            # setCurrentDocument will not be called, fill empty spaces with our
            # document.
            for space in self._viewSpaces[:-1]:
                if not space.document():
                    space.showDocument(activeDocument)
            
    def createActions(self):
        self.actionCollection = ac = ViewActions()
        # connections
        ac.window_close_view.setEnabled(False)
        ac.window_close_others.setEnabled(False)
        ac.window_split_horizontal.triggered.connect(self.splitCurrentVertical)
        ac.window_split_vertical.triggered.connect(self.splitCurrentHorizontal)
        ac.window_close_view.triggered.connect(self.closeCurrent)
        ac.window_close_others.triggered.connect(self.closeOthers)
        ac.window_next_view.triggered.connect(self.nextViewSpace)
        ac.window_previous_view.triggered.connect(self.previousViewSpace)

    def splitCurrentVertical(self):
        self.splitViewSpace(self.activeViewSpace(), Qt.Vertical)
        
    def splitCurrentHorizontal(self):
        self.splitViewSpace(self.activeViewSpace(), Qt.Horizontal)
        
    def closeCurrent(self):
        self.closeViewSpace(self.activeViewSpace())
    
    def closeOthers(self):
        for space in self._viewSpaces[-2::-1]:
            self.closeViewSpace(space)
    
    def nextViewSpace(self):
        self.focusNextChild()
        
    def previousViewSpace(self):
        self.focusPreviousChild()
        
    def activeViewSpace(self):
        return self._viewSpaces[-1]
    
    def splitViewSpace(self, viewspace, orientation):
        """Split the given view.
        
        If orientation == Qt.Horizontal, adds a new view to the right.
        If orientation == Qt.Vertical, adds a new view to the bottom.
        
        """
        active = viewspace is self.activeViewSpace()
        splitter = viewspace.parentWidget()
        newspace = ViewSpace(self)
        
        if splitter.count() == 1:
            splitter.setOrientation(orientation)
            size = splitter.sizes()[0]
            splitter.addWidget(newspace)
            splitter.setSizes([size / 2, size / 2])
        elif splitter.orientation() == orientation:
            index = splitter.indexOf(viewspace)
            splitter.insertWidget(index + 1, newspace)
        else:
            index = splitter.indexOf(viewspace)
            newsplitter = QSplitter()
            newsplitter.setOrientation(orientation)
            sizes = splitter.sizes()
            splitter.insertWidget(index, newsplitter)
            newsplitter.addWidget(viewspace)
            splitter.setSizes(sizes)
            size = newsplitter.sizes()[0]
            newsplitter.addWidget(newspace)
            newsplitter.setSizes([size / 2, size / 2])
        self._viewSpaces.insert(0, newspace)
        newspace.showDocument(viewspace.document())
        if active:
            newspace.activeView().setFocus()
        self.actionCollection.window_close_view.setEnabled(self.canCloseViewSpace())
        self.actionCollection.window_close_others.setEnabled(self.canCloseViewSpace())
        
    def closeViewSpace(self, viewspace):
        """Closes the given view."""
        active = viewspace is self.activeViewSpace()
        if active:
            self.setActiveViewSpace(self._viewSpaces[-2])
        splitter = viewspace.parentWidget()
        if splitter.count() > 2:
            viewspace.setParent(None)
            viewspace.deleteLater()
        elif splitter is self:
            if self.count() < 2:
                return
            # we contain only one other widget.
            # if that is a QSplitter, add all its children to ourselves
            # and copy the sizes and orientation.
            other = self.widget(1 - self.indexOf(viewspace))
            viewspace.setParent(None)
            viewspace.deleteLater()
            if isinstance(other, QSplitter):
                sizes = other.sizes()
                self.setOrientation(other.orientation())
                while other.count():
                    self.insertWidget(0, other.widget(other.count()-1))
                other.setParent(None)
                other.deleteLater()
                self.setSizes(sizes)
        else:
            # this splitter contains only one other widget.
            # if that is a ViewSpace, just add it to the parent splitter.
            # if it is a splitter, add all widgets to the parent splitter.
            other = splitter.widget(1 - splitter.indexOf(viewspace))
            parent = splitter.parentWidget()
            sizes = parent.sizes()
            index = parent.indexOf(splitter)
            
            if isinstance(other, ViewSpace):
                parent.insertWidget(index, other)
            else:
                #QSplitter
                sizes[index:index+1] = other.sizes()
                while other.count():
                    parent.insertWidget(index, other.widget(other.count()-1))
            viewspace.setParent(None)
            splitter.setParent(None)
            viewspace.deleteLater()
            splitter.deleteLater()
            parent.setSizes(sizes)
        self._viewSpaces.remove(viewspace)
        self.actionCollection.window_close_view.setEnabled(self.canCloseViewSpace())
        self.actionCollection.window_close_others.setEnabled(self.canCloseViewSpace())
        
    def canCloseViewSpace(self):
        return bool(self.count() > 1)
        
            


class ViewActions(actioncollection.ActionCollection):
    name = "view"
    def createActions(self, parent=None):
        self.window_split_horizontal = QAction(parent)
        self.window_split_vertical = QAction(parent)
        self.window_close_view = QAction(parent)
        self.window_close_others = QAction(parent)
        self.window_next_view = QAction(parent)
        self.window_previous_view = QAction(parent)
        
        # icons
        self.window_split_horizontal.setIcon(icons.get('view-split-top-bottom'))
        self.window_split_vertical.setIcon(icons.get('view-split-left-right'))
        self.window_close_view.setIcon(icons.get('view-close'))
        self.window_next_view.setIcon(icons.get('go-next-view'))
        self.window_previous_view.setIcon(icons.get('go-previous-view'))
        
        # shortcuts
        self.window_close_view.setShortcut(Qt.CTRL + Qt.SHIFT + Qt.Key_W)
        self.window_next_view.setShortcuts(QKeySequence.NextChild)
        qutil.removeShortcut(self.window_next_view, "Ctrl+,")
        self.window_previous_view.setShortcuts(QKeySequence.PreviousChild)
        qutil.removeShortcut(self.window_previous_view, "Ctrl+.")

    def translateUI(self):
        self.window_split_horizontal.setText(_("Split &Horizontally"))
        self.window_split_vertical.setText(_("Split &Vertically"))
        self.window_close_view.setText(_("&Close Current View"))
        self.window_close_others.setText(_("Close &Other Views"))
        self.window_next_view.setText(_("&Next View"))
        self.window_previous_view.setText(_("&Previous View"))
    

########NEW FILE########
__FILENAME__ = handlerbase
# vimode -- Vi Mode package for QPlainTextEdit
#
# Copyright (c) 2012 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Base class for mode handlers.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *


from . import NORMAL, VISUAL, INSERT, REPLACE


class Handler(object):
    def __init__(self, vimode):
        self.vimode = vimode

    def enter(self):
        """Called when the mode is entered."""
    
    def leave(self):
        """Called when the mode is left."""

    def textCursor(self):
        """Returns the text cursor of the Q(Plain)TextEdit."""
        return self.vimode.textEdit().textCursor()
    
    def setTextCursor(self, cursor):
        """Sets the text cursor of the Q(Plain)TextEdit."""
        self.vimode.textEdit().setTextCursor(cursor)
        
    def handleKeyPress(self, ev):
        """Called when a key is pressed in this mode.
        
        Should return True if the keypress is not to be handled anymore
        by the widget.
        
        """
    
    def updateCursorPosition(self):
        """Should redraw the cursor position."""
    
    def setNormalMode(self):
        self.vimode.setMode(NORMAL)

    def setVisualMode(self):
        self.vimode.setMode(VISUAL)

    def setInsertMode(self):
        self.vimode.setMode(INSERT)

    def setReplaceMode(self):
        self.vimode.setMode(REPLACE)



########NEW FILE########
__FILENAME__ = insert
# vimode -- Vi Mode package for QPlainTextEdit
#
# Copyright (c) 2012 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Insert ViMode.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import *
from PyQt4.QtGui import *

from . import handlerbase


class InsertMode(handlerbase.Handler):
    
    def enter(self):
        m = self.vimode
        m.textEdit().setCursorWidth(m._originalCursorWidth)
        m.clearCursor()

    def handleKeyPress(self, ev):
        if ev.key() == Qt.Key_Escape and ev.modifiers() == Qt.NoModifier:
            self.setNormalMode()
            return True


########NEW FILE########
__FILENAME__ = normal
# vimode -- Vi Mode package for QPlainTextEdit
#
# Copyright (c) 2012 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Normal ViMode.
"""

from __future__ import unicode_literals

import re

from PyQt4.QtCore import *
from PyQt4.QtGui import *

from . import handlerbase

commands = []


class NormalMode(handlerbase.Handler):
    def __init__(self, vimode):
        super(NormalMode, self).__init__(vimode)
        self._command = []
        self._count = 0
        
    def enter(self):
        self.vimode.textEdit().setCursorWidth(0)
    
    def updateCursorPosition(self):
        cursor = self.textCursor()
        if cursor.hasSelection() and cursor.position() > cursor.anchor():
            cursor.clearSelection()
            cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.KeepAnchor)
        else:
            cursor.clearSelection()
            cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor)
        self.vimode.drawCursor(cursor)

    def handleKeyPress(self, ev):
        # is a number being entered?
        if not self._command and Qt.Key_0 <= ev.key() <= Qt.Key_9:
            self._count *= 10
            self._count += ev.key() - Qt.Key_0
            return True
        # backspace?
        if ev.key() == Qt.Key_Backspace:
            if self._command:
                # remove last key typed
                del self._command[-1]
            else:
                self._count = 0
            return True
        
        # TEMP
        if ev.text():
            self._command.append(ev.text())
        
        cmd = ''.join(self._command)
        for s, f in commands:
            if re.compile(s).match(cmd):
                f(self)
                self._count = 0
                self._command = []
                return True
        
        return True
    
    
    def command(cmds, count=True, set_cursor=True):
        def decorator(func):
            def wrapper(self):
                cursor = self.textCursor()
                if count:
                    for i in range(max(1, self._count)):
                        func(self, cursor)
                else:
                    func(self, cursor)
                if set_cursor:
                    self.setTextCursor(cursor)
            for c in cmds:
                commands.append((c, wrapper))
        return decorator
    
    @command(['h', '<left>'])
    def move_left(self, cursor):
        if cursor.position() > cursor.block().position():
            cursor.movePosition(QTextCursor.PreviousCharacter)
    
    @command(['l', '<right>'])
    def move_right(self, cursor):
        if cursor.position() < cursor.block().position() + cursor.block().length() - 2:
            cursor.movePosition(QTextCursor.NextCharacter)
    
    @command('i', set_cursor=False)
    def insert_mode(self, cursor):
        self.setInsertMode()
    
    
        


########NEW FILE########
__FILENAME__ = arbitraryhighlighter
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages highlighting of arbitrary sections in a Q(Plain)TextEdit
using QTextEdit.ExtraSelections.
"""

import weakref

from PyQt4.QtCore import QObject, QTimer
from PyQt4.QtGui import QTextCharFormat, QTextEdit, QTextFormat


class ArbitraryHighlighter(QObject):
    """Manages highlighting of arbitrary sections in a Q(Plain)TextEdit.
    
    Stores and highlights lists of QTextCursors on a per-format basis.
    
    """
    def __init__(self, edit):
        """Initializes ourselves with a Q(Plain)TextEdit as parent."""
        super(ArbitraryHighlighter, self).__init__(edit)
        self._selections = {}
    
    def highlight(self, format, cursors, priority=0, msec=0):
        """Highlights the selection of an arbitrary list of QTextCursors.
        
        format can be a name for a predefined text format or a QTextCharFormat;
        in the first case the textFormat() method should return a qtextformat to use.
        priority determines the order of drawing, highlighting with higher priority
        is drawn over highlighting with lower priority.
        msec, if > 0, removes the highlighting after that many milliseconds.
        
        """
        fmt = format if isinstance(format, QTextFormat) else self.textFormat(format)
        selections = []
        for cursor in cursors:
            es = QTextEdit.ExtraSelection()
            es.cursor = cursor
            es.format = fmt
            selections.append(es)
        if msec:
            def clear(selfref=weakref.ref(self)):
                self = selfref()
                if self:
                    self.clear(format)
            timer = QTimer(timeout=clear, singleShot=True)
            timer.start(msec)
            self._selections[format] = (priority, selections, timer)
        else:
            self._selections[format] = (priority, selections)
        self.update()

    def clear(self, format):
        """Removes the highlighting for the given format (name or QTextCharFormat)."""
        try:
            del self._selections[format]
        except KeyError:
            pass
        else:
            self.update()

    def textFormat(self, name):
        """Implement this to return a QTextCharFormat for the given name."""
        raise NotImplementedError

    def update(self):
        """(Internal) Called whenever the arbitrary highlighting changes."""
        textedit = self.parent()
        if textedit:
            textedit.setExtraSelections(
                sum((s[1] for s in sorted(self._selections.values())), []))

    def reload(self):
        """Reloads the named formats in the highlighting (e.g. in case of settings change)."""
        for format in self._selections:
            if not isinstance(format, QTextFormat):
                fmt = self.textFormat(format)
                for es in self._selections[format][1]:
                    es.format = fmt
        self.update()



########NEW FILE########
__FILENAME__ = blink
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Shortly blinks a region on a widget.
"""

from PyQt4.QtCore import QTimer, pyqtSignal
from PyQt4.QtGui import QColor, QFontMetrics, QPainter, QPalette, QPen, QWidget


class Blinker(QWidget):
    """Can draw a blinking region above its parent widget."""
    
    finished = pyqtSignal()
    
    lineWidth = 3
    radius = 3
    
    @classmethod
    def blink(cls, widget, rect=None, color=None):
        """Shortly blinks a rectangular region on a widget.
        
        If rect is not given, the full rect() of the widget is used.
        If color is not given, the highlight color of the widget is used.
        This method instantiates a Blinker widget and discards it after use.
        
        """
        window = widget.window()
        if rect is None:
            rect = widget.rect()
        rect.moveTo(widget.mapTo(window, rect.topLeft()))
        b = cls(window)
        p = widget.palette()
        if color:
            p.setColor(QPalette.Highlight, color)
        b.setPalette(p)
        b.start(rect)
        b.finished.connect(b.deleteLater)

    @classmethod
    def blink_cursor(cls, textedit, color=None):
        """Highlights the cursor in a Q(Plain)TextEdit."""
        metrics = QFontMetrics(textedit.textCursor().charFormat().font())
        width = metrics.boundingRect("m").width()
        rect = textedit.cursorRect().normalized().adjusted(0, 0, width, 0)
        cls.blink(textedit, rect.translated(textedit.viewport().pos()), color)
    
    def __init__(self, widget):
        """Initializes ourselves to draw on the widget."""
        super(Blinker, self).__init__(widget)
        self._color = None
        self._animation = ()
        self._timer = QTimer(singleShot=True, timeout=self._updateAnimation)
        
    def start(self, rect):
        """Starts blinking the specified rectangle."""
        self._blink_rect = rect
        adj = self.lineWidth
        self.setGeometry(rect.adjusted(-adj, -adj, adj, adj))
        self.show()
        self._animation = self.animateColor()
        self._updateAnimation()
        
    def done(self):
        """(Internal) Called when the animation ends."""
        self.hide()
        self._animation = ()
        self.finished.emit()
    
    def _updateAnimation(self):
        try:
            delta, self._color = next(self._animation)
        except StopIteration:
            self.done()
            return
        self.update()
        self._timer.start(delta)
        
    def animateColor(self):
        """A generator yielding tuples (msec_delta, color) to animate colors.
        
        When the generator exits, the animation ends.
        The color is taken from the Highlight palette value.
        
        """
        color = self.palette().color(QPalette.Highlight)
        for delta, alpha in self.animateAlpha():
            color.setAlpha(alpha)
            yield delta, color
    
    def animateAlpha(self):
        """A generator yielding (msec_delta, alpha) tuples."""
        for alpha in (255, 0, 255, 0, 255):
            yield 120, alpha
        for alpha in range(255, 0, -15):
            yield 40, alpha
    
    def paintEvent(self, ev):
        color = self._color
        if not color or color.alpha() == 0:
            return
        painter = QPainter(self)
        adj = self.lineWidth / 2
        rect = self.rect().adjusted(adj, adj, -adj, -adj)
        pen = QPen(color)
        pen.setWidth(self.lineWidth)
        painter.setPen(pen)
        painter.setRenderHint(QPainter.Antialiasing, True)
        painter.drawRoundedRect(rect, self.radius, self.radius)



########NEW FILE########
__FILENAME__ = borderlayout
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Manages widgets in the borders of a QScrollArea.
"""

from PyQt4.QtCore import QEvent, QObject, QPoint, QRect, QSize


LEFT, TOP, RIGHT, BOTTOM = 0, 1, 2, 3

class BorderLayout(QObject):
    
    # order in which the widget spaces are filled.
    # if top and bottom are first, they get the full width.
    order = TOP, BOTTOM, LEFT, RIGHT
    
    def __init__(self, scrollarea):
        super(BorderLayout, self).__init__(scrollarea)
        self._resizing = False
        self._margins = 0, 0, 0, 0
        self._widgets = ([], [], [], [])
        scrollarea.viewport().installEventFilter(self)
    
    @classmethod
    def get(cls, scrollarea):
        """Gets the BorderLayout for the given scrollarea.
        
        If None exists, creates and returns a new instance.
        
        """
        for c in scrollarea.children():
            if type(c) is cls:
                return c
        return cls(scrollarea)
    
    def scrollarea(self):
        """Returns our scrollarea instance (our parent)."""
        return self.parent()
    
    def addWidget(self, widget, side):
        """Adds a widget to our scrollarea."""
        self.insertWidget(widget, side, -1)
        
    def insertWidget(self, widget, side, position):
        """Inserts a widget in a specific position."""
        assert side in (LEFT, TOP, RIGHT, BOTTOM)
        new = False
        for l in self._widgets:
            if widget in l:
                l.remove(widget)
                break
        else:
            new = True
            widget.setParent(self.scrollarea())
            widget.installEventFilter(self)
        if position == -1:
            self._widgets[side].append(widget)
        else:
            self._widgets[side].insert(widget, position)
        if new:
            widget.show()
        self.updateGeometry()
            
    def removeWidget(self, widget):
        """Removes the widget, it is not deleted."""
        for l in self._widgets:
            if widget in l:
                l.remove(widget)
                widget.removeEventFilter(self)
                widget.setParent(None)
                self.updateGeometry()
    
    def setViewportMargins(self, left, top, right, bottom):
        """(Internal) Sets the viewport margins and remembers them."""
        self._margins = (left, top, right, bottom)
        try:
            self.scrollarea().setViewportMargins(left, top, right, bottom)
        except RuntimeError:
            # this can happen when the scrollarea already is deleted by Python
            # because setViewportMargins is a protected method
            pass
    
    def viewportGeometry(self):
        """(Internal) Returns the viewport geometry as if with 0 margins."""
        g = self.scrollarea().viewport().geometry()
        left, top, right, bottom = self._margins
        return g.adjusted(-left, -top, right, bottom)
        
    def eventFilter(self, obj, ev):
        """Reimplemented to handle resizes and avoid resize loops."""
        if self._resizing:
            return False
        elif ev.type() == QEvent.Resize and obj is self.scrollarea().viewport():
            self.updateGeometry()
        elif ev.type() in (QEvent.Resize, QEvent.ShowToParent, QEvent.HideToParent):
            self.updateGeometry()
        elif ev.type() in (QEvent.ParentChange, QEvent.DeferredDelete) and obj is not self.scrollarea().viewport():
            for l in self._widgets:
                if obj in l:
                    l.remove(obj)
                    obj.removeEventFilter(self)
                    self.updateGeometry()
                    break
        return False
    
    def updateGeometry(self):
        """(Internal) Positions all widgets in the scrollarea edges."""
        self._resizing = True
        g = self.viewportGeometry()
        pos = g.topLeft()
        size = g.size()
        left, right, top, bottom = 0, 0, 0, 0
        
        for side in self.order:
            def widgets():
                for w in self._widgets[side][::-1]:
                    if w.isVisibleTo(self.scrollarea()):
                        yield w
            if side is LEFT:
                for widget in widgets():
                    w = widget.sizeHint().width()
                    h = size.height() - top - bottom
                    x = left
                    y = top
                    g = QRect(pos + QPoint(x, y), QSize(w, h))
                    widget.setGeometry(g)
                    left += w
            elif side is RIGHT:
                for widget in widgets():
                    w = widget.sizeHint().width()
                    h = size.height() - top - bottom
                    x = size.width() - right - w
                    y = top
                    g = QRect(pos + QPoint(x, y), QSize(w, h))
                    widget.setGeometry(g)
                    right += w
            elif side is TOP:
                for widget in widgets():
                    w = size.width() - left - right
                    h = widget.heightForWidth(w)
                    if h == -1:
                        h = widget.sizeHint().height()
                    x = left
                    y = top
                    g = QRect(pos + QPoint(x, y), QSize(w, h))
                    widget.setGeometry(g)
                    top += h
            elif side is BOTTOM:
                for widget in widgets():
                    w = size.width() - left - right
                    h = widget.heightForWidth(w)
                    if h == -1:
                        h = widget.sizeHint().height()
                    x = left
                    y = size.height() - bottom - h
                    g = QRect(pos + QPoint(x, y), QSize(w, h))
                    widget.setGeometry(g)
                    bottom += h
        self.setViewportMargins(left, top, right, bottom)
        self._resizing = False




########NEW FILE########
__FILENAME__ = charmap
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Provides a widget displaying characters from a font.

When a character is clicked, a signal is emitted.

"""

from __future__ import unicode_literals

import unicodedata

from PyQt4.QtCore import *
from PyQt4.QtGui import *


class CharMap(QWidget):
    """A widget displaying a table of characters."""
    characterSelected = pyqtSignal(unicode)
    characterClicked = pyqtSignal(unicode)
    
    def __init__(self, parent=None):
        super(CharMap, self).__init__(parent)
        self._showToolTips = True
        self._showWhatsThis = True
        self._selected = -1
        self._column_count = 32
        self._square = 24
        self._range = (0, 0)
        self._font = QFont()
        
    def setRange(self, first, last):
        self._range = (first, last)
        self._selected = -1
        self.adjustSize()
        self.update()
    
    def range(self):
        return self._range
    
    def square(self):
        """Returns the width of one item (determined by font size)."""
        return self._square
    
    def select(self, charcode):
        """Selects the specifed character (int or str)."""
        if not isinstance(charcode, int):
            charcode = ord(charcode)
        if not self._range[0] <= charcode <= self._range[1]:
            charcode = -1
        if self._selected != charcode:
            self._selected = charcode
            self.characterSelected.emit(unichr(charcode))
            self.update()
    
    def character(self):
        """Returns the currently selected character, if any."""
        if self._selected != -1:
            return unichr(self._selected)
    
    def setDisplayFont(self, font):
        self._font.setFamily(font.family())
        self.update()
    
    def displayFont(self):
        return QFont(self._font)
    
    def setDisplayFontSize(self, size):
        self._font.setPointSize(size)
        self._square = max(24, QFontMetrics(self._font).xHeight() * 3)
        self.adjustSize()
        self.update()
    
    def displayFontSize(self):
        return self._font.pointSize()
    
    def setDisplayFontSizeF(self, size):
        self._font.setPointSizeF(size)
        self._square = max(24, QFontMetrics(self._font).xHeight() * 3)
        self.adjustSize()
        self.update()
    
    def displayFontSizeF(self):
        return self._font.pointSizeF()
    
    def setColumnCount(self, count):
        """Sets how many columns should be used."""
        count = max(1, count)
        self._column_count = count
        self.adjustSize()
        self.update()
    
    def columnCount(self):
        return self._column_count
        
    def sizeHint(self):
        return self.sizeForColumnCount(self._column_count)

    def paintEvent(self, ev):
        rect = ev.rect()
        s = self._square
        rows = range(rect.top() / s, rect.bottom() / s + 1)
        cols = range(rect.left() / s, rect.right() / s + 1)
        
        painter = QPainter(self)
        painter.setPen(QPen(self.palette().color(QPalette.Window)))
        painter.setFont(self._font)
        metrics = QFontMetrics(self._font)
        
        # draw characters on white tiles
        tile = self.palette().color(QPalette.Base)
        selected_tile = self.palette().color(QPalette.Highlight)
        selected_tile.setAlpha(96)
        selected_box = self.palette().color(QPalette.Highlight)
        
        text_pen = QPen(self.palette().text())
        disabled_pen = QPen(self.palette().color(QPalette.Disabled, QPalette.Text))
        selection_pen = QPen(selected_box)
        for row in rows:
            for col in cols:
                char = row * self._column_count + col + self._range[0]
                if char > self._range[1]:
                    break
                printable = self.isprint(char)
                painter.setClipRect(col * s, row * s, s, s)
                if char == self._selected:
                    painter.fillRect(col * s + 1, row * s + 1, s - 2, s - 2, selected_tile)
                    painter.setPen(selection_pen)
                    painter.drawRect(col * s, row * s, s - 1, s - 1)
                elif printable:
                    painter.fillRect(col * s + 1, row * s + 1, s - 2, s - 2, tile)
                painter.setPen(text_pen if printable else disabled_pen)
                t = unichr(char)
                x = col * s + s / 2 - metrics.width(t) / 2
                y = row * s + 4 + metrics.ascent()
                painter.drawText(x, y, t)
            else:
                continue
            break
    
    def sizeForColumnCount(self, count):
        """Returns the size the widget would have in a certain column count.
        
        This can be used in e.g. a resizable scroll area.
        
        """
        first, last = self._range
        rows = ((last - first) // count) + 1
        return QSize(count, rows) * self._square

    def columnCountForWidth(self, width):
        """Returns the number of columns that would fit into the given width."""
        return width // self._square

    def mousePressEvent(self, ev):
        charcode = self.charcodeAt(ev.pos())
        if charcode != -1 and self.isprint(charcode):
            self.select(charcode)
            if ev.button() != Qt.RightButton:
                self.characterClicked.emit(unichr(charcode))
    
    def charcodeRect(self, charcode):
        """Returns the rectangular box around the given charcode, if any."""
        if self._range[0] <= charcode <= self._range[1]:
            row, col = divmod(charcode - self._range[0], self._column_count)
            s = self._square
            return QRect(col * s, row * s, s, s)
        
    def charcodeAt(self, position):
        row = position.y() // self._square
        col = position.x() // self._square
        if col <= self._column_count:
            charcode = self._range[0] + row * self._column_count + col
            if charcode <= self._range[1]:
                return charcode
        return -1

    def event(self, ev):
        if ev.type() == QEvent.ToolTip:
            if self._showToolTips:
                c = self.charcodeAt(ev.pos())
                if c:
                    text = self.getToolTipText(c)
                    if text:
                        rect = self.charcodeRect(c)
                        QToolTip.showText(ev.globalPos(), text, self, rect)
                        ev.accept()
                        return True
        elif ev.type() == QEvent.QueryWhatsThis:
            if self._showWhatsThis:
                ev.accept()
                return True
        elif ev.type() == QEvent.WhatsThis:
            ev.accept()
            if self._showWhatsThis:
                c = self.charcodeAt(ev.pos())
                text = self.getWhatsThisText(c) if c else None
                if text:
                    QWhatsThis.showText(ev.globalPos(), text, self)
                else:
                    QWhatsThis.leaveWhatsThisMode()
            return True
        return super(CharMap, self).event(ev)
    
    def getToolTipText(self, charcode):
        try:
            return unicodedata.name(unichr(charcode))
        except ValueError:
            pass
    
    def getWhatsThisText(self, charcode):
        try:
            name = unicodedata.name(unichr(charcode))
        except ValueError:
            return
        return whatsthis_html.format(
            self._font.family(), unichr(charcode), name, charcode)
    
    def setShowToolTips(self, enabled):
        self._showToolTips = bool(enabled)
    
    def showToolTips(self):
        return self._showToolTips

    def setShowWhatsThis(self, enabled):
        self._showWhatsThis = bool(enabled)
    
    def showWhatsThis(self):
        return self._showWhatsThis

    def isprint(self, charcode):
        """Returns True if the given charcode is printable."""
        return isprint(charcode)


def isprint(charcode):
    """Returns True if the given charcode is printable."""
    return unicodedata.category(unichr(charcode)) not in ('Cc', 'Cn')


whatsthis_html = """\
<qt>
<p align=center style="font-size: 40pt; font-family: {0};">{1}</p>
<p align=center>{2}</p>
<p align=center>0x{3:04X}</p>
"""


########NEW FILE########
__FILENAME__ = colorbutton
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A button to select a color.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import Qt, pyqtSignal
from PyQt4.QtGui import (
    QColor, QColorDialog, QPainter, QPushButton, QStyle, QStyleOptionButton,
    qDrawShadeRect)


class ColorButton(QPushButton):
    """A PushButton displaying a color.
    
    When clicked, opens a color dialog to change the color.
    
    """
    colorChanged = pyqtSignal(QColor)
    
    def __init__(self, parent=None):
        super(ColorButton, self).__init__(parent)
        
        self.setFixedSize(self.sizeHint())
        self._color = QColor()
        self.clicked.connect(self.openDialog)
    
    def color(self):
        """Returns the currently set color."""
        return self._color
    
    def setColor(self, color):
        """Sets the current color. Maybe QColor() to indicate 'unset'."""
        if self._color != color:
            self._color = color
            self.update()
            self.colorChanged.emit(color)

    def clear(self):
        """Unsets the current color (setting it to QColor())."""
        self.setColor(QColor())
        
    def openDialog(self):
        """Called when clicked, opens a dialog to change the color."""
        color = self._color if self._color.isValid() else QColor(Qt.white)
        color = QColorDialog.getColor(color, self)
        if color.isValid():
            self.setColor(color)

    def paintEvent(self, ev):
        """Reimplemented to display a colored rectangle."""
        QPushButton.paintEvent(self, ev)
        if not self._color.isValid():
            return
        style = self.style()
        opt = QStyleOptionButton()
        self.initStyleOption(opt)
        r = style.subElementRect(QStyle.SE_PushButtonContents, opt, self)
        shift = style.pixelMetric(QStyle.PM_ButtonMargin, opt, self) // 2
        r.adjust(shift, shift, -shift, -shift)
        if self.isChecked() or self.isDown():
            dx = style.pixelMetric(QStyle.PM_ButtonShiftHorizontal, opt, self)
            dy = style.pixelMetric(QStyle.PM_ButtonShiftVertical, opt, self)
            r.translate(dx, dy)
        p = QPainter(self)
        qDrawShadeRect(p, r, self.palette(), True, 1, 0, self._color)


########NEW FILE########
__FILENAME__ = completer
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Completer providing completions in a Q(Plain)TextEdit.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QEvent, QModelIndex, Qt
from PyQt4.QtGui import QCompleter, QKeySequence, QTextCursor


class Completer(QCompleter):
    """A QCompleter providing completions in a Q(Plain)TextEdit.
    
    Use setWidget() to assign the completer to a text edit.
    
    You can reimplement completionCursor() to make your own, other than simple
    string-based completions.
    
    Call showCompletionPopup() to force the popup to show.
    
    """
    autoComplete = True
    autoCompleteLength = 2
    
    def __init__(self, *args, **kwargs):
        super(Completer, self).__init__(*args, **kwargs)
        self.activated[QModelIndex].connect(self.insertCompletion)
        
    def eventFilter(self, obj, ev):
        if ev.type() != QEvent.KeyPress:
            return super(Completer, self).eventFilter(obj, ev)
        # we can't test for self.popup() as that will recursively call
        # eventFilter during instantiation.
        popupVisible = obj != self.widget()
        if popupVisible:
            # a key was pressed while the popup is visible
            if ev.key() in (Qt.Key_Return, Qt.Key_Enter):
                # insert the highlighted completion
                self.setCurrentRow(self.popup().currentIndex().row())
                self.insertCompletion(self.currentIndex())
                self.popup().hide()
                return True
            elif ev.key() == Qt.Key_Backspace:
                # deliver event, hide popup if completionPrefix already none
                self.widget().event(ev)
                if self.completionPrefix():
                    self.showCompletionPopup()
                else:
                    self.popup().hide()
                return True
            elif self.isTextEvent(ev, True):
                # deliver event and keep showing popup if necessary
                self.widget().event(ev)
                self.showCompletionPopup()
                return True
            elif ev.key() not in (
                Qt.Key_Up, Qt.Key_Down, Qt.Key_PageUp, Qt.Key_PageDown,
                Qt.Key_Shift, Qt.Key_Control, Qt.Key_Alt, Qt.Key_Meta):
                # hide on anything except navigation keys
                self.popup().hide()
            return super(Completer, self).eventFilter(obj, ev)
        # a key was pressed while the popup is not visible
        if self.autoComplete and self.isTextEvent(ev, False):
            self.widget().event(ev)
            self.showCompletionPopup(False)
            return True
        return False
    
    def isTextEvent(self, ev, visible):
        """Called when a key is pressed.
        
        Should return True if the given KeyPress event 'ev' represents text that
        makes sense for showing the completions popup.
        
        The 'visible' argument is True when the popup is currently visible.
        
        """
        return ev.text()[-1:] > " " and ev.key() != Qt.Key_Delete

    def textCursor(self):
        """Returns the current text cursor of the TextEdit."""
        return self.widget().textCursor()
        
    def completionCursor(self):
        """Should return a QTextCursor or None.
        
        If a QTextCursor is returned, its selection is used as the completion
        prefix and its selectionStart() as the place to popup the popup.
        
        This method may also alter the completion model.
        
        """
        cursor = self.textCursor()
        cursor.movePosition(QTextCursor.StartOfWord, QTextCursor.KeepAnchor)
        return cursor
    
    def showCompletionPopup(self, forced=True):
        """Shows the completion popup.
        
        Calls completionCursor() to get the place where to popup, and that
        method may also alter the completion model.
        
        If forced is True (the default) the popup is always shown (if it
        contains any entries). Otherwise it is only shown self.autoComplete is
        True and the cursor returned by completionCursor() has at least
        self.autoCompleteLength characters selected.
        
        """
        cursor = self.completionCursor()
        if not cursor:
            self.popup().hide()
            return
        text = cursor.selectedText()
        if forced or (self.autoComplete and len(text) >= self.autoCompleteLength):
            self.setCompletionPrefix(text)
            # hide if there is only one completion left
            if (not self.setCurrentRow(1) and self.setCurrentRow(0)
                and self.currentCompletion() == text):
                self.popup().hide()
                return
            self.setCurrentRow(0)
            rect = self.widget().cursorRect(cursor)
            rect.setWidth(self.popup().sizeHintForColumn(0)
                + self.popup().verticalScrollBar().sizeHint().width())
            rect.translate(self.widget().viewport().pos())
            frameWidth = self.popup().frameWidth()
            rect.translate(-frameWidth, frameWidth + 2)
            rect.translate(-self.popup().viewport().pos())
            self.complete(rect)
        
    def insertCompletion(self, index):
        """Inserts the completion at the given index.
        
        The default implementation reads the model data under the Qt.EditRole,
        and inserts that with the (already entered) completionPrefix removed.
        
        """
        text = self.completionModel().data(index, Qt.EditRole)
        text = text[len(self.completionPrefix()):]
        self.textCursor().insertText(text)




########NEW FILE########
__FILENAME__ = customtooltip
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Displays any widget as a tooltip.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QEvent, QObject, QTimer, Qt
from PyQt4.QtGui import QApplication, QCursor


__all__ = ['hide', 'show']


# the currently displayed widget
_widget = None

# the timer to hide (connected later)
_timer = QTimer(singleShot=True)

# the event handler (setup later)
_handler = None


def hide():
    """Hide the currently displayed widget (if any)."""
    global _widget
    if _widget:
        _widget.hide()
        _widget = None
        QApplication.instance().removeEventFilter(_handler)
    
def show(widget, pos=None, timeout=10000):
    """Show the widget at position."""
    if pos is None:
        pos = QCursor.pos()
    global _widget
    if _widget:
        if _widget is not widget:
            _widget.hide()
    else:
        global _handler
        if _handler is None:
            _handler = EventHandler()
        QApplication.instance().installEventFilter(_handler)
    
    # where to display the tooltip
    screen = QApplication.desktop().availableGeometry(pos)
    x = pos.x() + 2
    y = pos.y() + 20
    if x + widget.width() > screen.x() + screen.width():
        x -= 4 + widget.width()
    if y + widget.height() > screen.y() + screen.height():
        y -= 24 + widget.height();
    if y < screen.y():
        y = screen.y()
    if x < screen.x():
        x = screen.x()
    widget.move(x, y)
    if widget.windowFlags() & Qt.ToolTip != Qt.ToolTip:
        widget.setWindowFlags(Qt.ToolTip)
        widget.ensurePolished()
    
    widget.show()
    _widget = widget
    _timer.start(timeout)


_hideevents = set((
    QEvent.KeyPress,
    QEvent.KeyRelease,
    QEvent.Leave,
    QEvent.WindowActivate,
    QEvent.WindowDeactivate,
    QEvent.MouseButtonPress,
    QEvent.MouseButtonRelease,
    QEvent.MouseButtonDblClick,
    QEvent.FocusIn,
    QEvent.FocusOut,
    QEvent.Wheel,
    QEvent.MouseMove,
))

class EventHandler(QObject):
    def eventFilter(self, obj, ev):
        if ev.type() in _hideevents:
            hide()
        return False



# setup
_timer.timeout.connect(hide)



########NEW FILE########
__FILENAME__ = dialog
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A basic Dialog class.
"""

from __future__ import unicode_literals

import functools
import operator

from PyQt4.QtCore import QRegExp, QSize, Qt
from PyQt4.QtGui import (
    QDialog, QDialogButtonBox, QGridLayout, QIcon, QLabel, QLineEdit, QPixmap,
    QRegExpValidator, QStyle, QWidget)

from . import Separator


__all__ = ['Dialog', 'TextDialog']


standardicons = {
    'info': QStyle.SP_MessageBoxInformation,
    'warning': QStyle.SP_MessageBoxWarning,
    'critical': QStyle.SP_MessageBoxCritical,
    'question': QStyle.SP_MessageBoxQuestion,
}

standardbuttons = {
    'ok': QDialogButtonBox.Ok,
    'open': QDialogButtonBox.Open,
    'save': QDialogButtonBox.Save,
    'cancel': QDialogButtonBox.Cancel,
    'close': QDialogButtonBox.Close,
    'discard': QDialogButtonBox.Discard,
    'apply': QDialogButtonBox.Apply,
    'reset': QDialogButtonBox.Reset,
    'restoredefaults': QDialogButtonBox.RestoreDefaults,
    'help': QDialogButtonBox.Help,
    'saveall': QDialogButtonBox.SaveAll,
    'yes': QDialogButtonBox.Yes,
    'yestoall': QDialogButtonBox.YesToAll,
    'no': QDialogButtonBox.No,
    'notoall': QDialogButtonBox.NoToAll,
    'abort': QDialogButtonBox.Abort,
    'retry': QDialogButtonBox.Retry,
    'ignore': QDialogButtonBox.Ignore,
}


class Dialog(QDialog):
    """A Dialog with basic layout features:
    
    a main widget,
    an icon or pixmap,
    a separator,
    buttons (provided by a QDialogButtonBox)
    
    """
    def __init__(self,
                 parent = None,
                 message = "",
                 title = "",
                 icon = None,
                 iconSize = QSize(64, 64),
                 pixmap = None,
                 separator = True,
                 buttonOrientation = Qt.Horizontal,
                 buttons = ('ok', 'cancel'),
                 help = None,
                 **kwargs):
        """Initializes the dialog.
        
        parent = a parent widget or None.
        
        The following keyword arguments are recognized:
        - message: the text to display in the message label
        - title: the window title
        - icon or pixmap: shown in the left area
        - iconSize: size of the icon in the left (QSize, default: 64x64)
        - separator: draw a separator line or not (default: True)
        - buttonOrientation: Qt.Horizontal (default) or Qt.Vertical
        - buttons: which buttons to use (default: Ok, Cancel)
        - help: function to call when a help button is clicked.
        
        Other keyword arguments are passed to QDialog.
        
        """
        super(Dialog, self).__init__(parent, **kwargs)
        self._icon = QIcon()
        self._separatorWidget = Separator()
        self._mainWidget = QWidget()
        self._pixmap = QPixmap()
        self._pixmapLabel = QLabel(self)
        self._messageLabel = QLabel(self)
        self._buttonBox = b = QDialogButtonBox(self)
        b.accepted.connect(self.accept)
        b.rejected.connect(self.reject)
        layout = QGridLayout()
        layout.setSpacing(10)
        self.setLayout(layout)
        
        # handle keyword args
        self._buttonOrientation = buttonOrientation
        self._iconSize = iconSize
        self._separator = separator
        if title:
            self.setWindowTitle(title)
        self.setMessage(message)
        if icon:
            self.setIcon(icon)
        elif pixmap:
            self.setPixmap(pixmap)
        b.helpRequested.connect(help or self.helpRequest)
        self.setStandardButtons(buttons)
        self.reLayout()
        
    def helpRequest(self):
        """Called when a help button is clicked."""
        pass
    
    def setButtonOrientation(self, orientation):
        """Sets the button orientation.
        
        Qt.Horizontal (default) puts the buttons at the bottom of the dialog
        in a horizonzal row, Qt.Vertical puts the buttons at the right in a
        vertical column.
        
        """
        if orientation != self._buttonOrientation:
            self._buttonOrientation = orientation
            self._buttonBox.setOrientation(orientation)
            self.reLayout()
    
    def buttonOrientation(self):
        """Returns the button orientation."""
        return self._buttonOrientation
        
    def setIcon(self, icon):
        """Sets the icon to display in the left area.
        
        May be:
        - None or QIcon()
        - one of 'info', 'warning', 'critical', 'question'
        - a QStyle.StandardPixmap
        - a QIcon.
        
        """
        if icon in standardicons:
            icon = standardicons[icon]
        if isinstance(icon, QStyle.StandardPixmap):
            icon = self.style().standardIcon(icon)
        if icon is None:
            icon = QIcon()
        self._icon = icon
        self.setPixmap(icon.pixmap(self._iconSize))
    
    def icon(self):
        """Returns the currently set icon as a QIcon."""
        return self._icon
        
    def setIconSize(self, size):
        """Sets the icon size (QSize or int)."""
        if isinstance(size, int):
            size = QSize(size, size)
        changed = size != self._iconSize
        self._iconSize = size
        if changed and not self._icon.isNull():
            self.setPixmap(self._icon.pixmap(size))
    
    def iconSize(self):
        """Returns the icon size (QSize)."""
        return self._iconSize
        
    def setPixmap(self, pixmap):
        """Sets the pixmap to display in the left area."""
        changed = self._pixmap.isNull() != pixmap.isNull()
        self._pixmap = pixmap
        self._pixmapLabel.setPixmap(pixmap)
        if not pixmap.isNull():
            self._pixmapLabel.setFixedSize(pixmap.size())
        if changed:
            self.reLayout()
        
    def pixmap(self):
        """Returns the currently set pixmap."""
        return self._pixmap
    
    def setMessage(self, text):
        """Sets the main text in the dialog."""
        self._messageLabel.setText(text)
    
    def message(self):
        """Returns the main text."""
        return self._messageLabel.text()
    
    def messageLabel(self):
        """Returns the QLabel displaying the message text."""
        return self._messageLabel
        
    def buttonBox(self):
        """Returns our QDialogButtonBox instance."""
        return self._buttonBox
    
    def setStandardButtons(self, buttons):
        """Convenience method to set standard buttons in the button box.
        
        Accepts a sequence of string names from the standardbuttons constant,
        or a QDialogButtonBox.StandardButtons value.
        
        """
        if isinstance(buttons, (set, tuple, list)):
            buttons = functools.reduce(operator.or_,
                map(standardbuttons.get, buttons),
                QDialogButtonBox.StandardButtons())
        self._buttonBox.setStandardButtons(buttons)
    
    def button(self, button):
        """Returns the given button.
        
        May be a QDialogButtonBox.StandardButton or a key from standardbuttons.
        
        """
        if button in standardbuttons:
            button = standardbuttons[button]
        return self._buttonBox.button(button)
    
    def setSeparator(self, enabled):
        """Sets whether to show a line between contents and buttons."""
        changed = self._separator != enabled
        self._separator = enabled
        if changed:
            self.reLayout()
    
    def hasSeparator(self):
        """Returns whether a separator line is shown."""
        return self._separator
        
    def setMainWidget(self, widget):
        """Sets the specified widget as our main widget."""
        old = self._mainWidget
        if old:
            old.setParent(None)
        self._mainWidget = widget
        self.reLayout()
    
    def mainWidget(self):
        """Returns the current main widget (an empty QWidget by default)."""
        return self._mainWidget
    
    def reLayout(self):
        """(Internal) Lays out all items in this dialog."""
        layout = self.layout()
        while layout.takeAt(0):
            pass
        
        if not self._pixmap.isNull():
            col = 1
            layout.addWidget(self._pixmapLabel, 0, 0, 2, 1)
        else:
            layout.setColumnStretch(1, 0)
            col = 0
        layout.setColumnStretch(col, 1)
        self._pixmapLabel.setVisible(not self._pixmap.isNull())    
        layout.addWidget(self._messageLabel, 0, col)
        layout.addWidget(self._mainWidget, 1, col)
        if self._buttonOrientation == Qt.Horizontal:
            if self._separator:
                layout.addWidget(self._separatorWidget, 2, 0, 1, col+1)
            layout.addWidget(self._buttonBox, 3, 0, 1, col+1)
        else:
            if self._separator:
                layout.addWidget(self._separatorWidget, 0, col+1, 2, 1)
            layout.addWidget(self._buttonBox, 0, col+2, 2, 1)
        self._separatorWidget.setVisible(self._separator)


class TextDialog(Dialog):
    """A dialog with text string input and validation."""
    def __init__(self, parent, *args, **kwargs):
        super(TextDialog, self).__init__(parent, *args, **kwargs)
        self._validateFunction = None
        self.setMainWidget(QLineEdit())
        self.lineEdit().setFocus()
    
    def lineEdit(self):
        """Returns the QLineEdit widget."""
        return self.mainWidget()
    
    def setText(self, text):
        """Sets the text in the lineEdit()."""
        self.lineEdit().setText(text)
    
    def text(self):
        """Returns the text in the lineEdit()."""
        return self.lineEdit().text()
        
    def setValidateFunction(self, func):
        """Sets a function to run on every change in the lineEdit().
        
        If the function returns True, the OK button is enabled, otherwise
        disabled.
        
        If func is None, an earlier validate function will be removed.
        
        """
        old = self._validateFunction
        self._validateFunction = func
        if func:
            self._validate(self.lineEdit().text())
            if not old:
                self.lineEdit().textChanged.connect(self._validate)
        elif old:
            self.lineEdit().textChanged.disconnect(self._validate)
            self.button('ok').setEnabled(True)
    
    def setValidateRegExp(self, regexp):
        """Sets a regular expression the text must match.
        
        If the regular expression matches the full text, the OK button is
        enabled, otherwise disabled.
        
        If regexp is None, an earlier set regular expression is removed.
        
        """
        validator = function = None
        if regexp is not None:
            rx = QRegExp(regexp)
            validator = QRegExpValidator(rx, self.lineEdit())
            function = rx.exactMatch
        self.lineEdit().setValidator(validator)
        self.setValidateFunction(function)
    
    def _validate(self, text):
        self.button('ok').setEnabled(self._validateFunction(text))



########NEW FILE########
__FILENAME__ = drag
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Event-filtering objects and helper functions to drag things.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QEvent, QFileInfo, QMimeData, QObject, Qt, QUrl
from PyQt4.QtGui import QApplication, QDrag, QFileIconProvider


class ComboDrag(QObject):
    """Enables dragging from a QComboBox.
    
    Instantiate this with a QComboBox as parent to enable dragging the
    current item.
    
    By default, drags a filename got from the current index under the
    Qt.EditRole. Change the role by changing the 'role' instance attribute.
    
    """
    column = 0
    role = Qt.EditRole
    
    def __init__(self, combobox):
        super(ComboDrag, self).__init__(combobox)
        self._dragpos = None
        combobox.installEventFilter(self)
    
    def eventFilter(self, combobox, ev):
        if ev.type() == QEvent.MouseButtonPress and ev.button() == Qt.LeftButton:
            self._dragpos = ev.pos()
            return not combobox.isEditable()
        elif (ev.type() == QEvent.MouseMove and ev.buttons() & Qt.LeftButton
              and combobox.count() >0):
            return self.mouseMoved(combobox, ev.pos()) or False
        elif (ev.type() == QEvent.MouseButtonRelease
            and ev.button() == Qt.LeftButton and not combobox.isEditable()):
            combobox.mousePressEvent(ev)
        return False
    
    def mouseMoved(self, combobox, pos):
        if (self._dragpos is not None
            and (pos - self._dragpos).manhattanLength()
                >= QApplication.startDragDistance()):
            self.startDrag(combobox)
            return True
    
    def startDrag(self, combobox):
        index = combobox.model().index(combobox.currentIndex(), self.column)
        filename = combobox.model().data(index, self.role)
        icon = combobox.model().data(index, Qt.DecorationRole)
        dragFile(combobox, filename, icon, Qt.CopyAction)


class Dragger(QObject):
    """Drags anything from any widget.
    
    Use dragger.installEventFilter(widget) to have it drag.

    """
    def __init__(self, parent=None):
        super(Dragger, self).__init__(parent)
        self._dragpos = None
        if parent:
            parent.installEventFilter(self)
        
    def eventFilter(self, widget, ev):
        if ev.type() == QEvent.MouseButtonPress and ev.button() == Qt.LeftButton:
            self._dragpos = ev.pos()
            return True
        elif ev.type() == QEvent.MouseMove and ev.buttons() & Qt.LeftButton:
            return self.mouseMoved(widget, ev.pos()) or False
        return False
    
    def mouseMoved(self, widget, pos):
        if (self._dragpos is not None
            and (pos - self._dragpos).manhattanLength()
                >= QApplication.startDragDistance()):
            self.startDrag(widget)
            return True
    
    def startDrag(self, widget):
        """Reimplement to start a drag."""


class FileDragger(Dragger):
    def filename(self):
        """Should return the filename to drag."""
    
    def startDrag(self, widget):
        filename = self.filename()
        if filename:
            dragFile(widget, filename)


def dragFile(widget, filename, icon=None, dropactions=Qt.CopyAction):
    """Starts dragging the given local file from the widget."""
    if icon is None or icon.isNull():
        icon = QFileIconProvider().icon(QFileInfo(filename))
    drag = QDrag(widget)
    data = QMimeData()
    data.setUrls([QUrl.fromLocalFile(filename)])
    drag.setMimeData(data)
    drag.setPixmap(icon.pixmap(32))
    drag.exec_(dropactions)



########NEW FILE########
__FILENAME__ = folding
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2012 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Fold regions in a QTextDocument/Q(Plain)TextEdit.

Due to Qt4's design the folding applies to a QTextDocument instead of its
Q(Plain)TextEdit.

To get foldable regions in your QPlainTextEdit, you need to subclass Folder,
and implement its fold_events() method. It should yield START or STOP events
(which are simply integers) in the order they occur in the specified text block.

Then you should subclass FoldingArea, just to provide your Folder subclass
as a class attribute. Then add the FoldingArea to the left of your text edit.
The folding area will automatically instantiate the Folder for the document
of the text edit and use it for the lifetime of the document.

Finally, install a LinePainter as event filter on the viewport() of the text-
edit. This can be one global instance. It simply draws a line below any text
block that is followed by an invisible block.

Folding is handled automatically and needs no further data structures or state
information.

"""

from __future__ import unicode_literals

import collections

from PyQt4.QtCore import QEvent, QObject, QPoint, QRect, QSize, Qt, QTimer
from PyQt4.QtGui import QPainter, QPalette, QWidget

import cursortools

START = 1
STOP = -1

OPEN = 1
CLOSE = -1

Region = collections.namedtuple('Region', 'start end')
Level = collections.namedtuple('Level', 'stop start')


class LinePainter(QObject):
    """Paints a line below a block if the next block is invisible.
    
    Install this as an event filter on the viewport() of a textedit,
    it then intercepts the paint event.
    
    """
    def eventFilter(self, obj, ev):
        if ev.type() == QEvent.Paint:
            return self.paintEvent(obj, ev)
        return False

    def paintEvent(self, obj, ev):
        """Paint a line below a block is the next block is invisible.
        
        Normally it calls the paintEvent of the edit, then paints its
        own stuff and returns True.
        
        """
        edit = obj.parent()
        edit.paintEvent(ev)
        painter = QPainter(obj)
        offset = edit.contentOffset()
        for block in visible_blocks(edit, ev.rect()):
            n = block.next()
            if n.isValid() and not n.isVisible():
                # draw a line
                y = edit.blockBoundingGeometry(block).translated(offset).bottom() - 1
                x1 = ev.rect().left()
                x2 = ev.rect().right()
                painter.drawLine(x1, y, x2, y)
        return True


class Folder(QObject):
    """Manages the folding of a QTextDocument.
    
    You should inherit from this class to provide folding events.
    It is enough to implement the fold_events() method.
    
    By default, simple caching is used to store the nesting depth every
    20 lines. This makes the depth() method faster, which would otherwise count
    the fold_events() for every block from the beginning of the document.
    
    The depth() caching expects that the fold_events that a text block
    generates do not depend on the contents of a text block later in the
    document.
    
    If your fold_events() method generates events for a text block that depend
    on a later block, you should disable caching by setting the
    cache_depth_lines instance (or class) attribute to zero.
    
    """
    # cache depth() for every n lines (0=disable)
    cache_depth_lines = 20
    
    def __init__(self, doc):
        QObject.__init__(self, doc)
        self._depth_cache = []      # cache result of depth()
        self._all_visible = None    # True when all are certainly visible
        doc.contentsChange.connect(self.slot_contents_change)
        self._timer = QTimer(singleShot=True, timeout=self.check_consistency)
    
    @classmethod
    def find(cls, doc):
        for c in doc.children():
            if type(c) is cls:
                return c
    
    @classmethod
    def get(cls, doc):
        return cls.find(doc) or cls(doc)
    
    def slot_contents_change(self, position, removed, added):
        """Called when the document changes.
        
        Provides limited support for unhiding regions when the user types
        text in it, and deletes the depth() cache for lines from position.
        
        """
        block = self.document().findBlock(position)
        if self.cache_depth_lines:
            chunk = block.blockNumber() // self.cache_depth_lines
            del self._depth_cache[chunk:]
        
        if self._all_visible:
            return
        
        if not block.isVisible():
            self.ensure_visible(block)
        else:
            n = block.next()
            if n.isValid() and not n.isVisible() and not self.fold_level(block).start:
                # the block is visible, but not the next. Just unfold the lines,
                # skipping sub-regions, until a visible block is encountered.
                self.mark(block, False)
                while n.isValid() and not n.isVisible():
                    n.setVisible(True)
                    if self.fold_level(n).start and self.mark(n):
                        r = self.region(n)
                        if r:
                            n = r.end
                            if self.fold_level(n).start:
                                continue
                    n = n.next()
                self.document().markContentsDirty(block.next().position(), n.position())
        self._timer.start(250 + self.document().blockCount())
    
    def invalidate_depth_cache(self, block):
        """Makes sure the depth is recomputed from the specified block."""
        if self.cache_depth_lines:
            chunk = block.blockNumber() // self.cache_depth_lines
            del self._depth_cache[chunk:]
    
    def check_consistency(self):
        """Called some time after the last document change.
        
        Walk through the whole document, unfolding folded lines that
        - are in the toplevel
        - are in regions that have visible lines
        - are in regions that have visible sub-regions
        
        """
        show_blocks = set()
        self._all_visible = True    # for now at least ...
        
        def blocks_gen():
            """Yield depth (before block), block and fold_level per block."""
            depth = 0
            for b in cursortools.all_blocks(self.document()):
                l = self.fold_level(b)
                yield depth, b, l
                depth += sum(l)

        blocks = blocks_gen()
        
        def check_region(start_block, start_depth):
            """Check a region from a starting block for visible lines.
            
            Return a four-tuple (must_show, depth, block, level).
            must_show is True if the region contains visible lines (in that case
                the invisible lines are already made visible)
            depth, block, and level are the result of the last block_gen yield.
            If level.start is True, a new region starts on the same line the
            former one ends.
            
            """
            must_show = False
            invisible_blocks = []
            start_block.isVisible() or invisible_blocks.append(start_block)
            for depth, block, level in blocks:
                block.isVisible() or invisible_blocks.append(block)
                if depth + level.stop < start_depth:
                    # the region ends
                    if block.isVisible() and not level.start:
                        must_show = True
                    if must_show:
                        show_blocks.update(invisible_blocks)
                    elif invisible_blocks:
                        self._all_visible = False
                    return must_show, depth, block, level
                elif block.isVisible():
                    must_show = True
                while level.start:
                    must_show_region, depth, block, level = check_region(block, depth + sum(level))
                    if must_show_region:
                        must_show = True
            # happens if region is not closed
            return must_show, 0, None, Level(0, 0)
        
        # toplevel
        for depth, block, level in blocks:
            block.isVisible() or show_blocks.add(block)
            while level.start:
                must_show, depth, block, level = check_region(block, depth + sum(level))
        
        if show_blocks:
            for block in show_blocks:
                block.setVisible(True)
            self.document().markContentsDirty(
                min(show_blocks).position(), max(show_blocks).position())
    
    def document(self):
        """Return our document."""
        return self.parent()
        
    def fold_events(self, block):
        """Return an iterable of fold events for the block.
        
        An event is simply an integer constant START or END.
        The default implementation considers '{' as a start and '}' as end.
        
        """
        for c in block.text():
            if c == '{':
                yield START
            elif c == '}':
                yield STOP
    
    def fold_level(self, block):
        """Returns a named two-tuple Level(stop, start) about the block.
        
        stop is the number (negative!) of fold-levels that end in that block,
        start is the number of fold-levels that start in that block.
        
        This methods uses fold_events() to get the information, it discards
        folding regions that start and stop on the same text line.
        
        """
        start, stop = 0, 0
        for e in self.fold_events(block):
            if e is START:
                start += 1
            elif start:
                start -= 1
            else:
                stop -= 1
        return Level(stop, start)
        
    def depth(self, block):
        """Return the number of active regions at the start of this block.
        
        The default implementation simply counts all the fold_events from
        the beginning of the document, using caching if the cache_depth_lines
        instance attribute is set to a value > 0.
        
        """
        depth = 0
        last = block.document().firstBlock()
        if self.cache_depth_lines:
            chunk = block.blockNumber() // self.cache_depth_lines
            if chunk:
                target = block.document().findBlockByNumber(chunk * self.cache_depth_lines)
                if chunk <= len(self._depth_cache):
                    depth = self._depth_cache[chunk - 1]
                    last = target
                else:
                    # some values need to be computed first
                    if self._depth_cache:
                        depth = self._depth_cache[-1]
                        last = block.document().findBlockByNumber(len(self._depth_cache) * self.cache_depth_lines)
                    while last < target:
                        depth += sum(self.fold_events(last))
                        last = last.next()
                        if last.blockNumber() % self.cache_depth_lines == 0:
                            self._depth_cache.append(depth)
        while last < block:
            depth += sum(self.fold_events(last))
            last = last.next()
        return depth
        
    def region(self, block, depth=0):
        """Return as Region (start, end) the region of the specified block.
        
        start is the block the region starts, end the block the region ends.
        When collapsing the block, dont hide the last block if it starts a new
        fold region.
        
        The depth argument specifies how deep a region may be nested.
        The default value 0 searches the first containing region, 1 tries to
        find one more above that, etc. Use -1 to get the top-most region.
        
        """
        start = None
        start_depth = 0
        count = 0
        for b in cursortools.backwards(block):
            l = self.fold_level(b)
            if l.start:
                count += l.start
                if count > start_depth:
                    start = b
                    start_depth = count
                    if count > depth > -1:
                        break
            count += l.stop
        if start:
            count = start_depth
            end = None
            for end in cursortools.forwards(block.next()):
                l = self.fold_level(end)
                if count <= -l.stop:
                    return Region(start, end)
                count += sum(l)
            if end:
                return Region(start, end)
        
    def fold(self, block, depth=0):
        """Fold the region the block is in.
        
        The depth argument specifies how deep a region may be nested.
        The default value 0 searches the first containing region, 1 tries to
        find one more above that, etc. Use -1 to get the top-most region.
        
        """
        r = self.region(block, depth)
        if not r:
            return
        # if the last block starts a new region, don't hide it
        count = 0
        end = r.end.previous() if self.fold_level(r.end).start else r.end
        # don't hide the first block of the region
        for block in cursortools.forwards(r.start.next(), end):
            block.setVisible(False)
        self.mark(r.start, True)
        self.document().markContentsDirty(r.start.next().position(), end.position())
        self._all_visible = False

    def unfold(self, block, depth=0, full=False):
        """Unfolds the region the block is in.
        
        (Most times the block will be the first block of the region.)
        If multiple regions start at the same starting block, they will unfold
        all.
        
        The depth argument specifies how deep a region may be nested.
        The default value 0 searches the first containing region, 1 tries to
        find one more above that, etc. Use -1 to get the top-most region.
        
        If full is False (the default) sub-regions that were collapsed remain
        collapsed (provided that the mark() method is implemented).
        
        """
        r = self.region(block, depth)
        if not r:
            return
        blocks = cursortools.forwards(r.start, r.end)
        for block in blocks:
            # is there a sub-region? then skip if marked as collapsed
            if block not in r:
                l = self.fold_level(block)
                if l.start:
                    if full:
                        self.mark(block, False)
                    elif self.mark(block):
                        count = l.start
                        for b in blocks:
                            l = self.fold_level(b)
                            if count <= -l.stop:
                                break
                            count += sum(l)
            block.setVisible(True)
        self.mark(r.start, False)
        self.document().markContentsDirty(r.start.position(), r.end.position())
        
    def fold_toplevel(self):
        """Folds all toplevel regions, without touching inner regions."""
        for block in cursortools.all_blocks(self.document()):
            if not block.isVisible():
                continue
            elif self.fold_level(block).start:
                self.fold(block)
    
    def fold_all(self):
        """Folds all regions."""
        for block in cursortools.all_blocks(self.document()):
            if self.fold_level(block).start:
                if block.isVisible():
                    self.fold(block)
                else:
                    self.mark(block, True)
    
    def unfold_all(self):
        """Fully unfolds the document."""
        first = None
        for block in cursortools.all_blocks(self.document()):
            if self.fold_level(block).start:
                self.mark(block, False)
            if not block.isVisible():
                block.setVisible(True)
                if first is None:
                    first = block
                last = block
        if first:
            self.document().markContentsDirty(first.position(), last.position())
        # no need to check consistency
        self._all_visible = True
        self._timer.isActive() and self._timer.stop()
        
    def mark(self, block, state=None):
        """This can be used to remember the folded state of a block.
        
        When folding or unfolding a block, this method is called with the first
        block and state True (for fold) or False (for unfold).
        
        When unfolding a region, this method is called for every block without
        state value, and its return value is checked. If the value evaluates to
        True, the sub-region will remain collapsed.
        
        The default implementation does, and returns, nothing.
        
        """ 
        pass

    def ensure_visible(self, block):
        """Unfolds everything needed to make just the block visible."""
        if block.isVisible():
            return
        for d in range(self.depth(block), -1, -1):
            self.unfold(block, d)
            if block.isVisible():
                return


class FoldingArea(QWidget):
    
    Folder = Folder
    
    class Painter(object):
        """Used for one paint event, draws the folding area per-block."""
        def __init__(self, widget):
            self.w = widget
            self.p = QPainter(widget)
        
        def draw(self, rect, indicator, depth, new_depth):
            p = self.p
            if depth:
                p.drawLine(rect.center(), QPoint(rect.center().x(), rect.y()))
            if new_depth:
                p.drawLine(rect.center(), QPoint(rect.center().x(), rect.bottom()))
            if new_depth < depth and not indicator:
                p.drawLine(rect.center(), QPoint(rect.right()-1, rect.center().y()))
            if indicator:
                square = QRect(0, 0, 8, 8)
                square.moveCenter(rect.center() - QPoint(1, 1))
                p.fillRect(square, self.w.palette().color(QPalette.Base))
                p.drawRect(square)
                x = rect.center().x()
                y = rect.center().y()
                p.drawLine(QPoint(x-2, y), QPoint(x+2, y))
                if indicator == OPEN:
                    p.drawLine(QPoint(x, y-2), QPoint(x, y+2))
    
    def __init__(self, textedit=None):
        super(FoldingArea, self).__init__(textedit)
        self._textedit = None
        self.setAutoFillBackground(True)
        self.setTextEdit(textedit)
    
    def setTextEdit(self, edit):
        """Set a QPlainTextEdit instance to show folding indicators for, or None."""
        if self._textedit:
            self._textedit.updateRequest.disconnect(self.slotUpdateRequest)
            self._textedit.cursorPositionChanged.disconnect(self.slotCursorPositionChanged)
        self._textedit = edit
        if edit:
            edit.updateRequest.connect(self.slotUpdateRequest)
            edit.cursorPositionChanged.connect(self.slotCursorPositionChanged)
        self.update()
        
    def textEdit(self):
        """Return our QPlainTextEdit."""
        return self._textedit
        
    def sizeHint(self):
        return QSize(11, 50)
    
    def folder(self):
        """Return the Folder instance for our document."""
        return self.Folder.get(self.textEdit().document())
        
    def slotUpdateRequest(self, rect, dy):
        if dy:
            self.scroll(0, dy)
        else:
            self.update(0, rect.y(), self.width(), rect.height())

    def slotCursorPositionChanged(self):
        """Unfold the block the cursor is in if it is invisible."""
        block = self.textEdit().textCursor().block()
        if not block.isVisible():
            self.folder().ensure_visible(block)
            self.textEdit().ensureCursorVisible()
    
    def paintEvent(self, ev):
        edit = self._textedit
        if not edit:
            return
        painter = self.Painter(self)
        block = edit.firstVisibleBlock()
        folder = self.folder()
        depth = folder.depth(block)
        offset = edit.contentOffset()
        while block.isValid():
            next_block = block.next()
            level = folder.fold_level(block)
            count = sum(level)
            if block.isVisible():
                rect = edit.blockBoundingGeometry(block).translated(offset).toRect()
                if rect.top() > ev.rect().bottom():
                    break
                elif rect.bottom() >= ev.rect().top():
                    rect.setX(0)
                    rect.setWidth(self.width())
                    # draw a folder indicator
                    if level.start:
                        folded = next_block.isValid() and not next_block.isVisible()
                        if folded:
                            indicator = OPEN
                            while next_block.isValid() and not next_block.isVisible():
                                count += sum(folder.fold_events(next_block))
                                next_block = next_block.next()
                        else:
                            indicator = CLOSE
                    else:
                        indicator = None
                    painter.draw(rect, indicator, depth, depth + count)
            depth += count
            block = next_block
    
    def mousePressEvent(self, ev):
        if ev.buttons() == Qt.LeftButton:
            block = self.textEdit().cursorForPosition(QPoint(0, ev.y())).block()
            folder = self.folder()
            if folder.fold_level(block).start:
                if block.next().isValid() and not block.next().isVisible():
                    folder.unfold(block)
                else:
                    folder.fold(block)


def visible_blocks(edit, rect=None):
    """Yield the visible blocks in the specified rectangle.
    
    If no rectangle is given, the edit's viewport() is used.
    
    """
    if rect is None:
        rect = edit.viewport().rect()
    offset = edit.contentOffset()
    for block in cursortools.forwards(edit.firstVisibleBlock()):
        if block.isVisible():
            geom = edit.blockBoundingGeometry(block).translated(offset).toRect()
            if geom.top() >= rect.bottom():
                return
            elif geom.bottom() >= rect.top():
                yield block


########NEW FILE########
__FILENAME__ = growingtext
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Provides a QTextEdit subclass that grows vertically to accomodate document size.

You should set maximumHeight to restrict its vertical size.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QSize, Qt
from PyQt4.QtGui import QPlainTextEdit, QStyle, QTextEdit


__all__ = ["GrowingPlainTextEdit", "GrowingTextEdit"]


class _GrowingTextEditBase(object):
    """Base class."""
    def __init__(self, parent=None):
        super(_GrowingTextEditBase, self).__init__(parent)
        self.setLineWrapMode(self.NoWrap)
        self.document().documentLayout().documentSizeChanged.connect(self.updateVerticalSize)
        self.updateVerticalSize()
        
    def updateVerticalSize(self):
        # can vertical or horizontal scrollbars appear?
        vcan = self.verticalScrollBarPolicy() == Qt.ScrollBarAsNeeded
        hcan = self.horizontalScrollBarPolicy() == Qt.ScrollBarAsNeeded
        
        # width a scrollbar takes off the viewport size
        framewidth = 0
        if self.style().styleHint(QStyle.SH_ScrollView_FrameOnlyAroundContents, None, self):
            framewidth = self.style().pixelMetric(QStyle.PM_DefaultFrameWidth) * 2
        scrollbarextent = self.style().pixelMetric(QStyle.PM_ScrollBarExtent, None, self) + framewidth
        
        margin = framewidth + self.document().documentMargin()
        size = self.documentSize() + QSize(margin, margin)
        width = size.width()
        height = size.height()
        
        max_width = self.width()
        max_height = self.maximumHeight()
        
        # will scrollbars appear?
        hwill, vwill = False, False
        if hcan and width > max_width:
            hwill = True
        if vcan and height > max_height:
            vwill = True
        if vcan and hwill and height + scrollbarextent > max_height:
            vwill = True
        if hcan and vwill and width + scrollbarextent > max_width:
            hwill = True
        if hwill:
            height += scrollbarextent
        self.resize(self.width(), min(max_height, height))
    
    def documentSize(self):
        """Implemented differently for QTextEdit and QPlainTextEdit."""
        raise NotImplementedError
    
    def setLineWrapMode(self, mode):
        """Reimplemented to avoid WidgetWidth wrap mode, which causes resize loops."""
        if mode == self.WidgetWidth:
            raise ValueError("cant use WidgetWidth wrap mode")
        else:
            super(_GrowingTextEditBase, self).setLineWrapMode(mode)


class GrowingTextEdit(_GrowingTextEditBase, QTextEdit):
    """Growing QTextEdit"""
    def documentSize(self):
        return self.document().documentLayout().documentSize().toSize()


class GrowingPlainTextEdit(_GrowingTextEditBase, QPlainTextEdit):
    """Growing QPlainTextEdit"""
    def documentSize(self):
        doc = self.document()
        layout = doc.documentLayout()
        size = layout.documentSize().toSize()
        block = doc.firstBlock()
        line_height = layout.blockBoundingRect(block).height() / block.lineCount()
        return QSize(size.width(), size.height() * line_height + 2 * doc.documentMargin())



########NEW FILE########
__FILENAME__ = imageviewer
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A simple scrollarea that can display an image.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import pyqtSignal, QMimeData, QSize, QRect, Qt
from PyQt4.QtGui import (
    QApplication, QColor, QDrag, QImage, QPainter, QPalette, QPixmap,
    QScrollArea, QSizePolicy, QWidget)


__all__ = ['ImageViewer']


# internal constants
MOVE = 1
DRAG = 2


class ImageViewer(QScrollArea):
    
    actualSizeChanged = pyqtSignal(bool)
    
    def __init__(self, parent=None):
        super(ImageViewer, self).__init__(parent, alignment=Qt.AlignCenter)
        self._actualsize = True
        self._image = QImage()
        self.setBackgroundRole(QPalette.Dark)
        self.setWidget(ImageWidget(self))
        
    def setActualSize(self, enabled=True):
        if enabled == self._actualsize:
            return
        self.setWidgetResizable(not enabled)
        if enabled and not self._image.isNull():
            self.widget().resize(self._image.size())
        self._actualsize = enabled
        self.actualSizeChanged.emit(enabled)
    
    def actualSize(self):
        return self._actualsize
    
    def setImage(self, image):
        self._image = image
        self._pixmap = None
        self._pixmapsize = None
        if self._actualsize:
            self.widget().resize(image.size())
        self.widget().update()
    
    def image(self):
        return self._image
        
    def pixmap(self, size):
        """Returns (and caches) a scaled pixmap for the image."""
        if self._pixmapsize == size:
            return self._pixmap
        self._pixmap = QPixmap.fromImage(
            self._image.scaled(size, Qt.KeepAspectRatio, Qt.SmoothTransformation))
        self._pixmapsize = size
        return self._pixmap
    
    def startDrag(self):
        image = self.image()
        data = QMimeData()
        data.setImageData(image)
        drag = QDrag(self)
        drag.setMimeData(data)
        if max(image.width(), image.height()) > 256:
            image = image.scaled(QSize(256, 256), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        p = QPainter()
        p.begin(image)
        p.setCompositionMode(QPainter.CompositionMode_DestinationIn)
        p.fillRect(image.rect(), QColor(0, 0, 0, 160))
        p.end()
        pixmap = QPixmap.fromImage(image)
        drag.setPixmap(pixmap)
        drag.setHotSpot(pixmap.rect().center())
        drag.exec_(Qt.CopyAction)


class ImageWidget(QWidget):
    def __init__(self, viewer):
        super(ImageWidget, self).__init__()
        self.viewer = viewer
        self.setBackgroundRole(QPalette.Dark)
        self.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)
        self._mode = None
        self._startpos = None
    
    def paintEvent(self, ev):
        image = self.viewer.image()
        painter = QPainter(self)
        if self.size() == image.size():
            painter.drawImage(ev.rect(), image, ev.rect())
        else:
            s = image.size()
            s.scale(self.size(), Qt.KeepAspectRatio)
            r = QRect()
            r.setSize(s)
            r.moveCenter(self.rect().center())
            painter.drawPixmap(r, self.viewer.pixmap(s))

    def mousePressEvent(self, ev):
        if ev.button() == Qt.LeftButton:
            if ev.modifiers() & Qt.ControlModifier:
                self._mode = MOVE
            else:
                self._mode = DRAG
            self._startpos = ev.globalPos()
    
    def mouseMoveEvent(self, ev):
        diff = self._startpos - ev.globalPos()
        if self._mode == MOVE:
            self._startpos = ev.globalPos()
            h = self.viewer.horizontalScrollBar()
            v = self.viewer.verticalScrollBar()
            h.setValue(h.value() + diff.x())
            v.setValue(v.value() + diff.y())
        elif self._mode == DRAG and diff.manhattanLength() >= QApplication.startDragDistance():
            self.viewer.startDrag()
    
    def mouseReleaseEvent(self, ev):
        mode, self._mode = self._mode, None
        if (ev.button() == Qt.LeftButton and
                mode == DRAG and ev.globalPos() == self._startpos):
            self.viewer.setActualSize(not self.viewer.actualSize())



########NEW FILE########
__FILENAME__ = indenter
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A basic auto-indenter for a textedit widget.
"""


from __future__ import unicode_literals

import contextlib

from PyQt4.QtCore import QEvent, QObject, Qt
from PyQt4.QtGui import QTextCursor


class Indenter(QObject):
    """A basic indenter for a Q(Plain)TextEdit.

    When instantiated it automatically installs itself
    as an event filter for the textedit, catching some
    keypresses:
    
    Return:
        enters a newline and the same indent as the current line
    Tab:
        indents the current line
    Backtab:
        dedents the current line
    
    These instance attributes may be set:
    
    indentWidth:
        how many characters to indent (default 2)
    indentChar:
        which character to use (default " ")
    
    """

    indentWidth = 2
    indentChar = ' '
    
    def __init__(self, textedit):
        """Installs ourselves as event filter for textedit.
        
        The textedit also becomes our parent.
        
        """
        super(Indenter, self).__init__(textedit)
        textedit.installEventFilter(self)
    
    def eventFilter(self, edit, ev):
        """Handles Return, Tab and Backtab."""
        if ev.type() == QEvent.KeyPress:
            modifiers = int(ev.modifiers() & (Qt.SHIFT | Qt.CTRL | Qt.ALT | Qt.META))
            if ev.text() == '\r' and modifiers == 0:
                cursor = edit.textCursor()
                self.newline(cursor)
                edit.setTextCursor(cursor)
                return True
            elif ev.key() == Qt.Key_Tab and modifiers == 0:
                self.indent(edit.textCursor())
                return True
            elif ev.key() == Qt.Key_Backtab and modifiers & ~Qt.SHIFT == 0:
                self.dedent(edit.textCursor())
                return True
        return False

    def newline(self, cursor):
        """Inserts a newline and then the same indent as the current line."""
        indent = self.get_indent(cursor)
        cursor.insertText('\n' + indent)
    
    def get_indent(self, cursor):
        """Returns the whitespace with which the current line starts."""
        text = cursor.document().findBlock(cursor.selectionStart()).text()
        return text[:len(text) - len(text.lstrip())]
        
    def indent(self, cursor):
        """Indents the line with the cursor or the selected lines (one step more)."""
        with compress_undo(cursor):
            for block in blocks(cursor):
                cursor.setPosition(block.position())
                cursor.setPosition(block.position() + len(self.get_indent(cursor)))
                cursor.insertText(self.indentChar * self.indentWidth)
    
    def dedent(self, cursor):
        """Dedents the line with the cursor or the selected lines (one step less)."""
        with compress_undo(cursor):
            for block in blocks(cursor):
                cursor.setPosition(block.position())
                end = len(self.get_indent(cursor))
                start = max(0, end - self.indentWidth)
                if start < end:
                    cursor.setPosition(block.position() + start)
                    cursor.setPosition(block.position() + end, QTextCursor.KeepAnchor)
                    cursor.removeSelectedText()


def blocks(cursor):
    """Yields the blocks (one or more) of the cursor or its selection."""
    block = cursor.document().findBlock(cursor.selectionStart())
    end = cursor.document().findBlock(cursor.selectionEnd())
    while True:
        yield block
        if block == end:
            break
        block = block.next()


@contextlib.contextmanager
def compress_undo(cursor):
    """Returns a context manager to perform operations on cursor as a single undo-item."""
    cursor.beginEditBlock()
    try:
        yield
    finally:
        cursor.endEditBlock()


########NEW FILE########
__FILENAME__ = keysequencewidget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A widget to enter a keyboard shortcut.

Loosely based on kkeysequencewidget.cpp from KDE :-)

"""

from __future__ import unicode_literals

from PyQt4.QtCore import QEvent, QSize, Qt, QTimer, pyqtSignal
from PyQt4.QtGui import (
    QApplication, QHBoxLayout, QKeySequence, QPushButton, QToolButton, QWidget)

import app
import icons

from . import ClearButton


class KeySequenceWidget(QWidget):

    keySequenceChanged = pyqtSignal(int)
    
    def __init__(self, parent=None, num=0):
        super(KeySequenceWidget, self).__init__(parent)
        self._num = num
        layout = QHBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(2)
        self.setLayout(layout)
        
        self.button = KeySequenceButton(self)
        self.clearButton = ClearButton(self, iconSize=QSize(16, 16))
        layout.addWidget(self.button)
        layout.addWidget(self.clearButton)
        
        self.clearButton.clicked.connect(self.clear)
        app.translateUI(self)
        
    def translateUI(self):
        self.button.setToolTip(_("Start recording a key sequence."))
        self.clearButton.setToolTip(_("Clear the key sequence."))
        
    def setShortcut(self, shortcut):
        """Sets the initial shortcut to display."""
        self.button.setKeySequence(shortcut)
    
    def shortcut(self):
        """Returns the currently set key sequence."""
        return self.button.keySequence()
        
    def clear(self):
        """Empties the displayed shortcut."""
        if self.button.isRecording():
            self.button.cancelRecording()
        if not self.button.keySequence().isEmpty():
            self.button.setKeySequence(QKeySequence())
            self.keySequenceChanged.emit(self._num)

    def setModifierlessAllowed(self, allow):
        self.button._modifierlessAllowed = allow
        
    def isModifierlessAllowed(self):
        return self.button._modifierlessAllowed
    
    def num(self):
        return self._num


class KeySequenceButton(QPushButton):
    
    def __init__(self, parent=None):
        super(KeySequenceButton, self).__init__(parent)
        self.setIcon(icons.get("configure"))
        self._modifierlessAllowed = False
        self._seq = QKeySequence()
        self._timer = QTimer()
        self._timer.setSingleShot(True)
        self._isrecording = False
        self.clicked.connect(self.startRecording)
        self._timer.timeout.connect(self.doneRecording)

    def setKeySequence(self, seq):
        self._seq = seq
        self.updateDisplay()

    def keySequence(self):
        if self._isrecording:
            self.doneRecording()
        return self._seq
    
    def updateDisplay(self):
        if self._isrecording:
            s = self._recseq.toString(QKeySequence.NativeText).replace('&', '&&')
            if self._modifiers:
                if s: s += ","
                s += QKeySequence(self._modifiers).toString(QKeySequence.NativeText)
            elif self._recseq.isEmpty():
                s = _("Input")
            s += " ..."
        else:
            s = self._seq.toString(QKeySequence.NativeText).replace('&', '&&')
        self.setText(s)

    def isRecording(self):
        return self._isrecording
        
    def event(self, ev):
        if self._isrecording:
            # prevent Qt from special casing Tab and Backtab
            if ev.type() == QEvent.KeyPress:
                self.keyPressEvent(ev)
                return True
        return super(KeySequenceButton, self).event(ev)
        
    def keyPressEvent(self, ev):
        if not self._isrecording:
            return super(KeySequenceButton, self).keyPressEvent(ev)
        if ev.isAutoRepeat():
            return
        modifiers = int(ev.modifiers() & (Qt.SHIFT | Qt.CTRL | Qt.ALT | Qt.META))
        ev.accept()
        
        key = ev.key()
        # check if key is a modifier or a character key without modifier (and if that is allowed)
        if (
            # don't append the key if the key is -1 (garbage) or a modifier ...
            key not in (-1, Qt.Key_AltGr, Qt.Key_Shift, Qt.Key_Control,
                            Qt.Key_Alt, Qt.Key_Meta, Qt.Key_Menu)
            # or if this is the first key and without modifier and modifierless keys are not allowed
            and (self._modifierlessAllowed
                 or self._recseq.count() > 0
                 or modifiers & ~Qt.SHIFT
                 or not ev.text()
                 or (modifiers & Qt.SHIFT
                     and key in (Qt.Key_Return, Qt.Key_Space, Qt.Key_Tab, Qt.Key_Backtab,
                                 Qt.Key_Backspace, Qt.Key_Delete, Qt.Key_Escape)))):
            # change Shift+Backtab into Shift+Tab
            if key == Qt.Key_Backtab and modifiers & Qt.SHIFT:
                key = Qt.Key_Tab | modifiers
            # remove the Shift modifier if it doen't make sense
#            elif (Qt.Key_Exclam <= key <= Qt.Key_At
#                  or Qt.Key_Z < key <= 0x0ff):
#                key = key | (modifiers & ~Qt.SHIFT)
            else:
                key = key | modifiers
            
            # append max. 4 keystrokes
            if self._recseq.count() < 4:
                l = list(self._recseq)
                l.append(key)
                self._recseq = QKeySequence(*l)
        
        self._modifiers = modifiers
        self.controlTimer()
        self.updateDisplay()
        
    def keyReleaseEvent(self, ev):
        if not self._isrecording:
            return super(KeySequenceButton, self).keyReleaseEvent(ev)
        modifiers = int(ev.modifiers() & (Qt.SHIFT | Qt.CTRL | Qt.ALT | Qt.META))
        ev.accept()
        
        self._modifiers = modifiers
        self.controlTimer()
        self.updateDisplay()
    
    def hideEvent(self, ev):
        if self._isrecording:
            self.cancelRecording()
        super(KeySequenceButton, self).hideEvent(ev)
        
    def controlTimer(self):
        if self._modifiers or self._recseq.isEmpty():
            self._timer.stop()
        else:
            self._timer.start(600)
    
    def startRecording(self):
        self.setFocus(True) # because of QTBUG 17810
        self.setDown(True)
        self.setStyleSheet("text-align: left;")
        self._isrecording = True
        self._recseq = QKeySequence()
        self._modifiers = int(QApplication.keyboardModifiers() & (Qt.SHIFT | Qt.CTRL | Qt.ALT | Qt.META))
        self.grabKeyboard()
        self.updateDisplay()
        
    def doneRecording(self):
        self._seq = self._recseq
        self.cancelRecording()
        self.clearFocus()
        self.parentWidget().keySequenceChanged.emit(self.parentWidget().num())
        
    def cancelRecording(self):
        if not self._isrecording:
            return
        self.setDown(False)
        self.setStyleSheet(None)
        self._isrecording = False
        self.releaseKeyboard()
        self.updateDisplay()



########NEW FILE########
__FILENAME__ = lineedit
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A lineedit with a clear button.
"""

from __future__ import unicode_literals


from PyQt4.QtCore import QEvent, QSize, Qt
from PyQt4.QtGui import QLineEdit, QStyle, QToolButton

import icons

class LineEdit(QLineEdit):
    """A QLineEdit with a clear button. No additional methods."""
    def __init__(self, *args, **kwargs):
        super(LineEdit, self).__init__(*args, **kwargs)
        self._clearButton = b = QToolButton(self, iconSize=QSize(16,16), autoRaise=True)
        b.setFixedSize(QSize(16, 16))
        b.setStyleSheet("QToolButton { border: none; }")
        b.clicked.connect(self.clear)
        b.setCursor(Qt.ArrowCursor)
        b.setFocusPolicy(Qt.NoFocus)
        self.textChanged.connect(self._updateClearButton)
        self._updateLayoutDirection()
        self._updateClearButton()
    
    def _updateLayoutDirection(self):
        b = self._clearButton
        if self.layoutDirection() == Qt.RightToLeft:
            self.setTextMargins(b.width(), 0, 0, 0)
            b.setIcon(icons.get('edit-clear-locationbar-ltr'))
        else:
            self.setTextMargins(0, 0, b.width(), 0)
            b.setIcon(icons.get('edit-clear-locationbar-rtl'))
        
    def _updateClearButton(self):
        b = self._clearButton
        if self.text():
            frame = self.style().pixelMetric(QStyle.PM_DefaultFrameWidth)
            y = max(0, (self.height() - b.height()) / 2)
            if self.layoutDirection() == Qt.RightToLeft:
                x = frame + 2
            else:
                x = self.rect().right() - b.width() - frame - 2
            b.move(x, y)
            b.show()
        else:
            b.hide()

    def resizeEvent(self, ev):
        super(LineEdit, self).resizeEvent(ev)
        if self.text():
            self._updateClearButton()

    def changeEvent(self, ev):
        super(LineEdit, self).changeEvent(ev)
        if ev.type() == QEvent.LayoutDirectionChange:
            self._updateLayoutDirection()
            self._updateClearButton()



########NEW FILE########
__FILENAME__ = linenumberarea
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2011 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A line number area to be used in a QPlainTextEdit.
"""

from PyQt4.QtCore import QEvent, QPoint, QRect, QSize, Qt
from PyQt4.QtGui import (
    QApplication, QFontMetrics, QMouseEvent, QPainter, QWidget)


class LineNumberArea(QWidget):
    def __init__(self, textedit=None):
        super(LineNumberArea, self).__init__(textedit)
        self._textedit = None
        self.setAutoFillBackground(True)
        self.setTextEdit(textedit)
    
    def setTextEdit(self, edit):
        """Sets a QPlainTextEdit instance to show linenumbers for, or None."""
        if self._textedit:
            self._textedit.updateRequest.disconnect(self.slotUpdateRequest)
            self._textedit.blockCountChanged.disconnect(self.updateWidth)
        self._textedit = edit
        if edit:
            edit.updateRequest.connect(self.slotUpdateRequest)
            edit.blockCountChanged.connect(self.updateWidth)
            self.updateWidth()
        else:
            self._width = 0
        self.update()
        
    def textEdit(self):
        """Returns our QPlainTextEdit."""
        return self._textedit
        
    def sizeHint(self):
        return QSize(self._width, 50)

    def updateWidth(self):
        fm = QFontMetrics(self._textedit.font())
        text = format(self._textedit.blockCount(), 'd')
        self._width = fm.width(text) + 3
        self.adjustSize()

    def slotUpdateRequest(self, rect, dy):
        if (dy):
            self.scroll(0, dy)
        else:
            self.update(0, rect.y(), self.width(), rect.height())

    def paintEvent(self, ev):
        edit = self._textedit
        if not edit:
            return
        painter = QPainter(self)
        painter.setFont(edit.font())
        rect = QRect(0, 0, self.width() - 2, QFontMetrics(edit.font()).height())
        block = edit.firstVisibleBlock()
        while block.isValid():
            geom = edit.blockBoundingGeometry(block)
            geom.translate(edit.contentOffset())
            if geom.top() >= ev.rect().bottom():
                break
            if block.isVisible() and geom.bottom() > ev.rect().top() + 1:
                rect.moveTop(geom.top())
                text = format(block.blockNumber() + 1, 'd')
                painter.drawText(rect, Qt.AlignRight, text)
            block = block.next()

    def event(self, ev):
        if self._textedit:
            if ((ev.type() in (QEvent.MouseButtonPress, QEvent.MouseButtonRelease)
                 and ev.button() == Qt.LeftButton)
                or (ev.type() == QEvent.MouseMove and ev.buttons() & Qt.LeftButton)):
                new = QMouseEvent(ev.type(), QPoint(0, ev.y()),
                    ev.button(), ev.buttons(), ev.modifiers())
                return QApplication.sendEvent(self._textedit.viewport(), new)
            elif ev.type() == QEvent.Wheel:
                return QApplication.sendEvent(self._textedit.viewport(), ev)
        return super(LineNumberArea, self).event(ev)




########NEW FILE########
__FILENAME__ = listedit
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Widgets to edit a list of items in a flexible way.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import pyqtSignal
from PyQt4.QtGui import (
    QFileDialog, QGridLayout, QListWidget, QListWidgetItem, QPushButton, QWidget)

import app
import icons


class ListEdit(QWidget):
    """A widget to edit a list of items (e.g. a list of directories)."""
    
    # emitted when anything changed in the listbox.
    changed = pyqtSignal()
    
    def __init__(self, *args, **kwargs):
        QWidget.__init__(self, *args, **kwargs)
        layout = QGridLayout(self)
        self.setLayout(layout)
        
        self.addButton = QPushButton(icons.get('list-add'), '')
        self.editButton = QPushButton(icons.get('document-edit'), '')
        self.removeButton = QPushButton(icons.get('list-remove'), '')
        self.listBox = QListWidget()
        
        layout.setContentsMargins(1, 1, 1, 1)
        layout.setSpacing(0)
        layout.addWidget(self.listBox, 0, 0, 4, 1)
        layout.addWidget(self.addButton, 0, 1)
        layout.addWidget(self.editButton, 1, 1)
        layout.addWidget(self.removeButton, 2, 1)
        
        @self.addButton.clicked.connect
        def addClicked():
            item = self.createItem()
            if self.openEditor(item):
                self.addItem(item)
                
        @self.editButton.clicked.connect
        def editClicked():
            item = self.listBox.currentItem()
            item and self.editItem(item)
        
        @self.removeButton.clicked.connect
        def removeClicked():
            item = self.listBox.currentItem()
            if item:
                self.removeItem(item)
        
        @self.listBox.itemDoubleClicked.connect
        def itemDoubleClicked(item):
            item and self.editItem(item)
            
        self.listBox.model().layoutChanged.connect(self.changed)
    
        def updateSelection():
            selected = bool(self.listBox.currentItem())
            self.editButton.setEnabled(selected)
            self.removeButton.setEnabled(selected)
        
        self.changed.connect(updateSelection)
        self.listBox.itemSelectionChanged.connect(updateSelection)
        updateSelection()
        app.translateUI(self)
    
    def translateUI(self):
        self.addButton.setText(_("&Add..."))
        self.editButton.setText(_("&Edit..."))
        self.removeButton.setText(_("&Remove"))
    
    def createItem(self):
        return QListWidgetItem()
        
    def addItem(self, item):
        self.listBox.addItem(item)
        self.itemChanged(item)
        self.changed.emit()
        
    def removeItem(self, item):
        self.listBox.takeItem(self.listBox.row(item))
        self.changed.emit()
        
    def editItem(self, item):
        if self.openEditor(item):
            self.itemChanged(item)
            self.changed.emit()
            
    def setCurrentItem(self, item):
        self.listBox.setCurrentItem(item)
        
    def setCurrentRow(self, row):
        self.listBox.setCurrentRow(row)
        
    def openEditor(self, item):
        """Opens an editor (dialog) for the item.
        
        Returns True if the dialog was accepted and the item edited.
        Returns False if the dialog was cancelled (the item must be left
        unedited).
        """
        pass
    
    def itemChanged(self, item):
        """Called after an item has been added or edited.
        
        Re-implement to do something at this moment if needed, e.g. alter the
        text or display of other items.
        """
        pass
    
    def setValue(self, strings):
        """Sets the listbox to a list of strings."""
        self.listBox.clear()
        self.listBox.addItems(strings)
        self.changed.emit()
        
    def value(self):
        """Returns the list of paths in the listbox."""
        return [self.listBox.item(i).text()
            for i in range(self.listBox.count())]
    
    def setItems(self, items):
        """Sets the listbox to a list of items."""
        self.listBox.clear()
        for item in items:
            self.listBox.addItem(item)
            self.itemChanged(item)
        self.changed.emit()
    
    def items(self):
        """Returns the list of items in the listbox."""
        return [self.listBox.item(i)
            for i in range(self.listBox.count())]
        
    def clear(self):
        """Clears the listbox."""
        self.listBox.clear()
        self.changed.emit()
        

class FilePathEdit(ListEdit):
    """
    A widget to edit a list of directories (e.g. a file path).
    """
    def __init__(self, *args, **kwargs):
        super(FilePathEdit, self).__init__(*args, **kwargs)
    
    def fileDialog(self):
        """The QFileDialog this widget is using."""
        try:
            return self._filedialog
        except AttributeError:
            self._filedialog = d = QFileDialog(self)
            d.setFileMode(QFileDialog.Directory)
            return d
    
    def openEditor(self, item):
        """Asks the user for an (existing) directory."""
        directory = item.text()
        dlg = self.fileDialog()
        dlg.selectFile(directory)
        if dlg.exec_():
            item.setText(dlg.selectedFiles()[0])
            return True
        return False


########NEW FILE########
__FILENAME__ = matcher
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A basic parenthesis/brace character matcher for a textedit widget.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QObject, QRegExp, Qt, QTimer
from PyQt4.QtGui import QTextCharFormat, QTextCursor, QTextDocument, QTextEdit


class Matcher(QObject):
    """Highlights matching characters in a textedit.
    
    The following attributes are available at the class level,
    and may be overridden by setting them as instance attributes:
    
    matchPairs: a string of characters that match in pairs with each other
                default: "{}()[]"
    format:     a QTextCharFormat used to highlight matching characters with
                default: a red foreground color
    time:       how many milliseconds to show the highlighting (0=forever)
                default: 2000
    
    """
    
    matchPairs = "{}()[]"
    format = QTextCharFormat()
    format.setForeground(Qt.red)
    time = 2000
    
    def __init__(self, edit):
        """Initialize the Matcher; edit is a Q(Plain)TextEdit instance."""
        super(Matcher, self).__init__(edit)
        self._timer = QTimer(singleShot=True, timeout=self.clear)
        edit.cursorPositionChanged.connect(self.slotCursorPositionChanged)
    
    def edit(self):
        """Returns our Q(Plain)TextEdit."""
        return self.parent()
    
    def slotCursorPositionChanged(self):
        """Called whenever the cursor position changes.
        
        Highlights matching characters if the cursor is at one of them.
        
        """
        cursor = self.edit().textCursor()
        block = cursor.block()
        text = block.text()
        
        # try both characters at the cursor
        col = cursor.position() - block.position()
        end = col + 1
        col = max(0, col - 1)
        for c in text[col:end]:
            if c in self.matchPairs:
                break
            col += 1
        else:
            self.clear()
            return
        
        # the cursor is at a character from matchPairs
        i = self.matchPairs.index(c)
        cursor.setPosition(block.position() + col)
        
        # find the matching character
        new = QTextCursor(cursor)
        if i & 1:
            # look backward
            match = self.matchPairs[i-1]
            flags = QTextDocument.FindBackward
        else:
            # look forward
            match = self.matchPairs[i+1]
            flags = QTextDocument.FindFlags()
            new.movePosition(QTextCursor.Right)
        
        # search, also nesting
        rx = QRegExp(QRegExp.escape(c) + '|' + QRegExp.escape(match))
        nest = 0
        while nest >= 0:
            new = cursor.document().find(rx, new, flags)
            if new.isNull():
                self.clear()
                return
            nest += 1 if new.selectedText() == c else -1
        cursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor)
        self.highlight([cursor, new])
    
    def highlight(self, cursors):
        """Highlights the selections of the specified QTextCursor instances."""
        selections = []
        for cursor in cursors:
            es = QTextEdit.ExtraSelection()
            es.cursor = cursor
            es.format = self.format
            selections.append(es)
        self.edit().setExtraSelections(selections)
        if self.time and selections:
            self._timer.start(self.time)
    
    def clear(self):
        """Removes the highlighting."""
        self.edit().setExtraSelections([])



########NEW FILE########
__FILENAME__ = matcher_ah
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Highlights matching characters in a textedit,
using an ArbitraryHighlighter.
"""

from . import matcher

class Matcher(matcher.Matcher):
    
    priority = 0
    
    def __init__(self, highlighter):
        """Initialize the Matcher; highlighter is an ArbitraryHighlighter instance."""
        super(matcher.Matcher, self).__init__(highlighter)
        self.edit().cursorPositionChanged.connect(self.slotCursorPositionChanged)

    def edit(self):
        """Reimplemented to return the parent of our parent:)"""
        return self.parent().parent()
    
    def highlight(self, cursors):
        """Highlights the selections of the specified QTextCursor instances."""
        self.parent().highlight(self.format, cursors, self.priority, self.time)
    
    def clear(self):
        """Removes the highlighting."""
        self.parent().clear(self.format)

########NEW FILE########
__FILENAME__ = progressbar
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
QProgressBar subclasses.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QTimeLine, QTimer
from PyQt4.QtGui import QProgressBar

class TimedProgressBar(QProgressBar):
    """A QProgressBar showing a certain time elapse."""
    hideOnTimeout = True
    def __init__(self, parent=None):
        super(TimedProgressBar, self).__init__(parent, minimum=0, maximum=100)
        self._timeline = QTimeLine(updateInterval=100, frameChanged=self.setValue)
        self._timeline.setFrameRange(0, 100)
        self._hideTimer = QTimer(timeout=self._done, singleShot=True, interval=3000)
    
    def start(self, total, elapsed=0.0):
        """Starts showing progress.
        
        total is the number of seconds (maybe float) the timeline will last,
        elapsed (defaulting to 0) is the value to start with.
        
        """
        self._hideTimer.stop()
        self._timeline.stop()
        self._timeline.setDuration(total * 1000)
        self._timeline.setCurrentTime(elapsed * 1000)
        self.setValue(self._timeline.currentFrame())
        self._timeline.resume()
        if self.hideOnTimeout:
            self.show()
        
    def stop(self, showFinished=True):
        """Ends the progress display.
        
        If showFinished is True (the default), 100% is shown for a few
        seconds and then the progress is reset.
        The progressbar is hidden if the hideOnTimeout attribute is True.
        
        """
        self._hideTimer.stop()
        self._timeline.stop()
        if showFinished:
            self.setValue(100)
            self._hideTimer.start()
        else:
            self._done()

    def _done(self):
        self.reset()
        if self.hideOnTimeout:
            self.hide()


########NEW FILE########
__FILENAME__ = schemeselector
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A widget that provides a scheme selector, with New and Remove buttons.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import QDir, QSettings, pyqtSignal, Qt
from PyQt4.QtGui import (
    QComboBox, QHBoxLayout, QInputDialog, QLabel, QPushButton, QWidget, 
    QAction, QMenu, QFileDialog)

import app
import icons
import os


class SchemeSelector(QWidget):
    
    currentChanged = pyqtSignal()
    changed = pyqtSignal()
    
    def __init__(self, parent=None):
        super(SchemeSelector, self).__init__(parent)
        layout = QHBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)
        
        self.label = QLabel()
        self.scheme = QComboBox()
        self.menuButton = QPushButton(flat=True)
        menu = QMenu(self.menuButton)
        self.menuButton.setMenu(menu)
        layout.addWidget(self.label)
        layout.addWidget(self.scheme)
        layout.addWidget(self.menuButton)
        layout.addStretch(1)
        # action generator
        def act(slot, icon=None):
            a = QAction(self, triggered=slot)
            self.addAction(a)
            icon and a.setIcon(icons.get(icon))
            return a
        
        # add action
        a = self.addAction_ = act(self.slotAdd, 'list-add')
        menu.addAction(a)
        
        # remove action
        a = self.removeAction = act(self.slotRemove, 'list-remove')
        menu.addAction(a)
        
       
        # rename action
        a = self.renameAction = act(self.slotRename, 'document-edit')
        menu.addAction(a)
        
        menu.addSeparator()
        
        # import action
        a = self.importAction = act(self.slotImport, 'document-open')
        menu.addAction(a)
        
        # export action
        a = self.exportAction = act(self.slotExport, 'document-save-as')
        menu.addAction(a)
        
        
        self.scheme.currentIndexChanged.connect(self.slotSchemeChanged)
        app.translateUI(self)
        
    def translateUI(self):
        self.label.setText(_("Scheme:"))
        self.menuButton.setText(_("&Menu"))
        self.addAction_.setText(_("&Add..."))
        self.removeAction.setText(_("&Remove"))
        self.renameAction.setText(_("Re&name..."))
        self.importAction.setText(_("&Import..."))
        self.exportAction.setText(_("&Export..."))
        
    def slotSchemeChanged(self, index):
        """Called when the Scheme combobox is changed by the user."""
        self.disableDefault(self.scheme.itemData(index) == 'default')
        self.currentChanged.emit()
        self.changed.emit()
    
    def disableDefault(self, val):
        self.removeAction.setDisabled(val)
        self.renameAction.setDisabled(val)
    
    def schemes(self):
        """Returns the list with internal names of currently available schemes."""
        return [self.scheme.itemData(i) for i in range(self.scheme.count())]
        
    def currentScheme(self):
        """Returns the internal name of the currently selected scheme"""
        return self.scheme.itemData(self.scheme.currentIndex())
        
    def insertSchemeItem(self, name, scheme):
        for i in range(1, self.scheme.count()):
            n = self.scheme.itemText(i)
            if n.lower() > name.lower():
                self.scheme.insertItem(i, name, scheme)
                break
        else:
            self.scheme.addItem(name, scheme)
    
    def addScheme(self, name):
        num, key = 1, 'user1'
        while key in self.schemes() or key in self._schemesToRemove:
            num += 1
            key = 'user{0}'.format(num)
        self.insertSchemeItem(name, key)
        self.scheme.setCurrentIndex(self.scheme.findData(key))
        return key
    
    def slotAdd(self):
        name, ok = QInputDialog.getText(self,
            app.caption(_("Add Scheme")),
            _("Please enter a name for the new scheme:"))
        if ok:
            self.addScheme(name)
        
    
    def slotRemove(self):
        index = self.scheme.currentIndex()
        scheme = self.scheme.itemData(index)
        if scheme == 'default':
            return # default can not be removed
        
        self._schemesToRemove.add(scheme)
        self.scheme.removeItem(index)
    
    def slotRename(self):
        index = self.scheme.currentIndex()
        name = self.scheme.itemText(index)
        scheme = self.scheme.itemData(index)
        newName, ok = QInputDialog.getText(self, _("Rename"), _("New name:"), text=name)
        if ok:
            self.scheme.blockSignals(True)
            self.scheme.removeItem(index)
            self.insertSchemeItem(newName, scheme)
            self.scheme.setCurrentIndex(self.scheme.findData(scheme))
            self.scheme.blockSignals(False)
            self.changed.emit()
           
    def slotImport(self):
        filetypes = "{0} (*.xml);;{1} (*)".format(_("XML Files"), _("All Files"))
        caption = app.caption(_("dialog title", "Import color theme"))
        filename = QFileDialog.getOpenFileName(self, caption, QDir.homePath(), filetypes)
        if filename:
            self.parent().import_(filename)
    
    def slotExport(self):
        name = self.scheme.currentText()
        filetypes = "{0} (*.xml);;{1} (*)".format(_("XML Files"), _("All Files"))
        caption = app.caption(_("dialog title",
            "Export {name}").format(name=name))
        path = os.path.join(QDir.homePath(), name+'.xml')
        filename = QFileDialog.getSaveFileName(self, caption, path, filetypes)
        if filename:
            if os.path.splitext(filename)[1] != '.xml':
                filename += '.xml'
            self.parent().export(name, filename)
            
    
    def loadSettings(self, currentKey, namesGroup):
        # dont mark schemes for removal anymore
        self._schemesToRemove = set()
        
        s = QSettings()
        cur = s.value(currentKey, "default", type(""))
        
        # load the names for the shortcut schemes
        s.beginGroup(namesGroup)
        block = self.scheme.blockSignals(True)
        self.scheme.clear()
        self.scheme.addItem(_("Default"), "default")
        lst = [(s.value(key, key, type("")), key) for key in s.childKeys()]
        for name, key in sorted(lst, key=lambda f: f[0].lower()):
            self.scheme.addItem(name, key)
        
        # find out index
        index = self.scheme.findData(cur)
        self.disableDefault(cur == 'default')
        self.scheme.setCurrentIndex(index)
        self.scheme.blockSignals(block)
        self.currentChanged.emit()
        
    def saveSettings(self, currentKey, namesGroup, removePrefix=None):
        # first save new scheme names
        s = QSettings()
        s.beginGroup(namesGroup)
        for i in range(self.scheme.count()):
            if self.scheme.itemData(i) != 'default':
                s.setValue(self.scheme.itemData(i), self.scheme.itemText(i))
        
        for scheme in self._schemesToRemove:
            s.remove(scheme)
        s.endGroup()
        if removePrefix:
            for scheme in self._schemesToRemove:
                s.remove("{0}/{1}".format(removePrefix, scheme))
        # then save current
        scheme = self.currentScheme()
        s.setValue(currentKey, scheme)
        # clean up
        self._schemesToRemove = set()



########NEW FILE########
__FILENAME__ = shortcuteditdialog
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A dialog to edit the keyboard shortcuts for an action.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import Qt, QTimer
from PyQt4.QtGui import (
    QDialog, QDialogButtonBox, QGridLayout, QHBoxLayout, QKeySequence, QLabel,
    QRadioButton, QVBoxLayout)


import app
from . import Separator
from keysequencewidget import KeySequenceWidget


class ShortcutEditDialog(QDialog):
    """A modal dialog to view and/or edit keyboard shortcuts."""
    
    def __init__(self, parent=None, conflictCallback=None, *cbArgs):
        """conflictCallback is a optional method called when a shortcut is changed.
        
        cbArgs is optional arguments of the conflictCallback method.
        it should return the name of the potential conflict or a null value """
        
        super(ShortcutEditDialog, self).__init__(parent)
        self.conflictCallback = conflictCallback
        self.cbArgs = cbArgs
        self.setMinimumWidth(400)
        # create gui
        
        layout = QVBoxLayout()
        layout.setSpacing(10)
        self.setLayout(layout)
        
        top = QHBoxLayout()
        top.setSpacing(4)
        p = self.toppixmap = QLabel()
        l = self.toplabel = QLabel()
        top.addWidget(p)
        top.addWidget(l, 1)
        layout.addLayout(top)
        grid = QGridLayout()
        grid.setSpacing(4)
        grid.setColumnStretch(1, 2)
        layout.addLayout(grid)
        
        self.buttonDefault = QRadioButton(self, toggled=self.slotButtonDefaultToggled)
        self.buttonNone = QRadioButton(self)
        self.lconflictDefault = QLabel('test')
        self.lconflictDefault.setStyleSheet("color : red;")
        self.lconflictDefault.setVisible(False)
        self.buttonCustom = QRadioButton(self)
        grid.addWidget(self.buttonDefault, 0, 0, 1, 2)
        grid.addWidget(self.lconflictDefault, 1, 0, 1, 2)
        grid.addWidget(self.buttonNone, 2, 0, 1, 2)
        grid.addWidget(self.buttonCustom, 3, 0, 1, 2)
        
        self.keybuttons = []
        self.keylabels = []
        self.conflictlabels = []
        for num in range(4):
            l = QLabel(self)
            l.setStyleSheet("margin-left: 2em;")
            l.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
            b = KeySequenceWidget(self, num)
            b.keySequenceChanged.connect(self.slotKeySequenceChanged)
            l.setBuddy(b)
            self.keylabels.append(l)
            self.keybuttons.append(b)
            grid.addWidget(l, num+4+num, 0)
            grid.addWidget(b, num+4+num, 1)
            lconflict = QLabel()
            lconflict.setStyleSheet("color : red;")
            self.conflictlabels.append(lconflict)
            lconflict.setVisible(False)
            grid.addWidget(lconflict, num+5+num, 0, 1, 2, Qt.AlignHCenter)
        
        layout.addWidget(Separator(self))
        
        b = QDialogButtonBox(self)
        b.setStandardButtons(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        layout.addWidget(b)
        b.accepted.connect(self.accept)
        b.rejected.connect(self.reject)
        app.translateUI(self)
    
    def translateUI(self):
        self.setWindowTitle(app.caption(_("window title", "Edit Shortcut")))
        self.buttonNone.setText(_("&No shortcut"))
        self.buttonCustom.setText(_("Use a &custom shortcut:"))
        for num in range(4):
            self.keylabels[num].setText(_("Alternative #{num}:").format(num=num) if num else _("Primary shortcut:"))
    
    def slotKeySequenceChanged(self, num):
        """Called when one of the keysequence buttons has changed."""
        self.checkConflict(num)
        self.buttonCustom.setChecked(True)
    
    def slotButtonDefaultToggled(self, val):
        if self.conflictCallback is not None:
            if not val:
                self.lconflictDefault.setVisible(False)
            else:
                if self._default:
                    conflictList = []
                    for s in self._default:
                        conflictName = self.conflictCallback(s, *self.cbArgs)
                        if conflictName:
                            conflictList.append(conflictName)
                    if conflictList:
                        text = _("Conflict with: {name}").format(
                            name="<b>{0}</b>".format(', '.join(conflictList)))
                        self.lconflictDefault.setText(text)
                        self.lconflictDefault.setVisible(True)
            QTimer.singleShot(0, self.adjustSize)
                    
    def checkConflict(self, num):
        if self.conflictCallback is not None:
            conflictName = self.conflictCallback(self.keybuttons[num].shortcut(), *self.cbArgs)
            if conflictName:
                text = _("Conflict with: {name}").format(
                    name="<b>{0}</b>".format(conflictName))
                self.conflictlabels[num].setText(text)
                self.conflictlabels[num].setVisible(True)
            else:
                self.conflictlabels[num].setVisible(False)
            QTimer.singleShot(0, self.adjustSize)
     
    def editAction(self, action, default=None):
        # load the action
        self._action = action
        self._default = default
        self.toplabel.setText('<p>{0}</p>'.format(
            _("Here you can edit the shortcuts for {name}").format(
                name='<br/><b>{0}</b>:'.format(action.text()))))
        self.toppixmap.setPixmap(action.icon().pixmap(32))
        shortcuts = action.shortcuts()
        self.buttonDefault.setVisible(bool(default))
        if default is not None and shortcuts == default:
            self.buttonDefault.setChecked(True)
        else:
            if shortcuts:
                self.buttonCustom.setChecked(True)
                for num, key in enumerate(shortcuts[:4]):
                    self.keybuttons[num].setShortcut(key)
                    self.checkConflict(num)
            else:
                self.buttonNone.setChecked(True)
            
        if default:
            ds = "; ".join(key.toString(QKeySequence.NativeText) for key in default)
        else:
            ds = _("no keyboard shortcut", "none")
        self.buttonDefault.setText(_("Use &default shortcut ({name})").format(name=ds))
        return self.exec_()
        
    def done(self, result):
        if result:
            shortcuts = []
            if self.buttonDefault.isChecked():
                shortcuts = self._default
            elif self.buttonCustom.isChecked():
                for num in range(4):
                    seq = self.keybuttons[num].shortcut()
                    if not seq.isEmpty():
                        shortcuts.append(seq)
            self._action.setShortcuts(shortcuts)
        super(ShortcutEditDialog, self).done(result)


########NEW FILE########
__FILENAME__ = tempobutton
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A button that emits a tempo(int) signal when the user clicks multiple times.
"""

from __future__ import unicode_literals

import time

from PyQt4.QtCore import pyqtSignal
from PyQt4.QtGui import QToolButton

import app
import icons


class TempoButton(QToolButton):
    """A button the user can tap a tempo on.

    emits tempo(bpm) when the user clicks the button multiple times.
    
    """
    tempo = pyqtSignal(int)
    
    def __init__(self, icon=None, parent=None):
        super(TempoButton, self).__init__(parent)
        self.setIcon(icon or icons.get("media-record"))
        self.tapStart = 0.0
        self.tapTime = 0.0
        self.tapCount = 0
        self.pressed.connect(self.slotPressed)
        app.translateUI(self)
        
    def translateUI(self):
        self.setToolTip(_("The tempo is set as you click this button."))
        self.setWhatsThis(_(
            "Tap this button to set the tempo.\n\n"
            "The average speed of clicking is used; wait 3 seconds to \"reset\"."))

    def slotPressed(self):
        self.tapTime, t = time.time(), self.tapTime
        if 0.1 < self.tapTime - t < 3.0:
            self.tapCount += 1
            bpm = int(60.0 * self.tapCount / (self.tapTime - self.tapStart))
            self.tempo.emit(bpm)
        else:
            self.tapStart = self.tapTime
            self.tapCount = 0



########NEW FILE########
__FILENAME__ = toolboxwheeler
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Pages through a QToolBox using the mouse wheel, by default with the
CTRL modifier.
"""

from PyQt4.QtCore import QEvent, QObject, Qt


class ToolBoxWheeler(QObject):
    """Pages through a QToolBox using the mouse wheel."""
    def __init__(self, toolbox):
        """Initializes us as eventfilter with the toolbox as parent."""
        super(ToolBoxWheeler, self).__init__(toolbox)
        self._wheeldelta = 0
        toolbox.installEventFilter(self)
    
    def eventFilter(self, toolbox, ev):
        if ev.type() == QEvent.Wheel and ev.modifiers() & Qt.CTRL:
            self.wheelEvent(toolbox, ev)
            return True
        return False
        
    def wheelEvent(self, toolbox, ev):
        self._wheeldelta -= ev.delta()
        steps, self._wheeldelta = divmod(self._wheeldelta, 120)
        i = toolbox.currentIndex() + steps
        if 0 <= i < toolbox.count():
            toolbox.setCurrentIndex(i)



########NEW FILE########
__FILENAME__ = treewidget
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
A TreeWidget with some useful methods to manupulate items.
"""


from PyQt4.QtGui import QTreeWidget, QTreeWidgetItem


class TreeWidget(QTreeWidget):
    """A QTreeWidget with some item-manipulation methods.
    
    We use a widget instead of a view with a standard model because
    this lets us really have control over the items. With a standard
    model, items are recreated e.g. when dragging and this looses the
    python subclassed instances with their own paramaters.
    
    Calls the cleanup() method on QTreeWidgetItems as they are removed,
    but does not error out if the QTreeWidgetItem does not have a cleanup()
    method.
    
    """
    def __init__(self, parent=None, **kws):
        super(TreeWidget, self).__init__(parent, **kws)
    
    def items(self, parent=None):
        """Yields all items from parent or the invisibleRootItem."""
        if parent is None:
            parent = self.invisibleRootItem()
        for i in range(parent.childCount()):
            c = parent.child(i)
            for i in self.items(c):
                yield i
            yield c
    
    def clear(self):
        """Removes all items, calling their cleanup() method (if available) first."""
        for item in self.items():
            self._cleanup(item)
        super(TreeWidget, self).clear()
    
    def removeSelectedItems(self, item=None):
        """Removes all selected items from the specified item or the root item."""
        if item is None:
            item = self.invisibleRootItem()
        itemsToRemove = []
        for i in range(item.childCount()):
            child = item.child(i)
            if child.isSelected():
                itemsToRemove.append(child)
            else:
                self.removeSelectedItems(child)
        for child in itemsToRemove:
            for descendant in self.items(child):
                self._cleanup(descendant)
            item.removeChild(child)
            self._cleanup(child)
    
    def findSelectedItem(self, item=None):
        """Returns an item that has selected children, if any exists.
        
        The item closest to the specified item or the root item that
        has selected children, is returned.
        
        """
        if item is None:
            item = self.invisibleRootItem()
        for i in range(item.childCount()):
            if item.child(i).isSelected():
                return item
        for i in range(item.childCount()):
            child = item.child(i)
            r = self.findSelectedItem(child)
            if r:
                return r
    
    def moveSelectedChildrenUp(self):
        item = self.findSelectedItem()
        if item:
            for row in range(1, item.childCount()):
                if item.child(row).isSelected():
                    i = item.takeChild(row)
                    item.insertChild(row - 1, i)
                    i.setSelected(True)

    def moveSelectedChildrenDown(self):
        item = self.findSelectedItem()
        if item:
            for row in range(item.childCount() - 2, -1, -1):
                if item.child(row).isSelected():
                    i = item.takeChild(row)
                    item.insertChild(row + 1, i)
                    i.setSelected(True)

    @staticmethod
    def _cleanup(item):
        """Calls item.cleanup() if the QTreeWidgetItem has that method."""
        if hasattr(item, 'cleanup'):
            item.cleanup()


class TreeWidgetItem(QTreeWidgetItem):
    def cleanup(self):
        """May be implemented to perform cleanup when an item is removed."""



########NEW FILE########
__FILENAME__ = urlrequester
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2008 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
UrlRequester, a lineedit with a Browse-button.
"""

from __future__ import unicode_literals

from PyQt4.QtCore import pyqtSignal
from PyQt4.QtGui import (
    QFileDialog, QHBoxLayout, QLineEdit, QToolButton, QWidget)

import app
import icons


class UrlRequester(QWidget):
    """Shows a lineedit and a button to select a file or directory.
    
    The lineEdit, button, and fileDialog attributes represent their
    respective objects.
    
    """
    changed = pyqtSignal()
    
    def __init__(self, parent=None):
        super(UrlRequester, self).__init__(parent)
        
        self._fileDialog = None
        self._dialogTitle = None
        self._fileMode = None
        
        layout = QHBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(2)
        self.setLayout(layout)
        
        self.lineEdit = QLineEdit()
        layout.addWidget(self.lineEdit)
        self.button = QToolButton(clicked=self.browse)
        layout.addWidget(self.button)
        
        self.lineEdit.textChanged.connect(self.changed)
        self.setFileMode(QFileDialog.Directory)
        app.translateUI(self)
    
    def translateUI(self):
        self.button.setToolTip(_("Open file dialog"))
    
    def fileDialog(self, create = False):
        """Returns the QFileDialog, if already instantiated.
        
        If create is True, the dialog is instantiated anyhow.
        
        """
        if create and self._fileDialog is None:
            self._fileDialog = QFileDialog(self)
        return self._fileDialog
            
    def setPath(self, path):
        self.lineEdit.setText(path)
        
    def path(self):
        return self.lineEdit.text()
        
    def setFileMode(self, mode):
        """Sets the mode for the dialog, is a QFileDialog.FileMode value."""
        if mode == QFileDialog.Directory:
            self.button.setIcon(icons.get('folder-open'))
        else:
            self.button.setIcon(icons.get('document-open'))
        self._fileMode = mode
    
    def fileMode(self):
        return self._fileMode
    
    def setDialogTitle(self, title):
        self._dialogTitle = title
        if self._fileDialog:
            self._fileDialog.setWindowTitle(title)
    
    def dialogTitle(self):
        return self._dialogTitle
        
    def browse(self):
        """Opens the dialog."""
        dlg = self.fileDialog(True)
        dlg.setFileMode(self._fileMode)
        if self._dialogTitle:
            title = self._dialogTitle
        elif self.fileMode() == QFileDialog.Directory:
            title = _("Select a directory")
        else:
            title = _("Select a file")
        dlg.setWindowTitle(app.caption(title))
        dlg.selectFile(self.path())
        result = dlg.exec_()
        if result:
            self.lineEdit.setText(dlg.selectedFiles()[0])



########NEW FILE########
__FILENAME__ = wordboundary
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Provides custom word-boundary behaviour for QTextCursor and QTextEdit etc.

You can inherit from BoundaryHandler to change the behaviour. You can just
change the word_regexp expression, or override the boundaries() method.

Install a BoundaryHandler as eventfilter on a QTextEdit or QPlainTextEdit.
If you also want the double-click word selection to work, install the handler
also as eventfilter on the textedit's viewport(). The install_textedit() and
remove_textedit() methods can do this.

The handler intercepts the word-related cursor movement and selection
keypress events.

It is enough to have one global handler object, it can be installed on as
many textedit widgets as you like.

"""

from __future__ import unicode_literals

import itertools
import operator
import re
import time

from PyQt4.QtCore import QEvent, QObject, Qt
from PyQt4.QtGui import QApplication, QKeySequence, QTextCursor


_move_operations = (
    QTextCursor.StartOfWord,
    QTextCursor.PreviousWord,
    QTextCursor.WordLeft,
    QTextCursor.EndOfWord,
    QTextCursor.NextWord,
    QTextCursor.WordRight,
)


class BoundaryHandler(QObject):
    
    _double_click_time = 0.0
    word_regexp = re.compile(r'\\?\w+|^|$', re.UNICODE)
    
    def boundaries(self, block):
        """Return a list of tuples specifying the position of words in the block.
        
        Each tuple denotes the start and end position of a "word" in the
        specified block.
        
        You can return other boundaries by changing the word_regexp or by
        inheriting from this class and overwriting this method.
        
        """
        return [m.span() for m in self.word_regexp.finditer(block.text())]
    
    def left_boundaries(self, block):
        left = operator.itemgetter(0)
        return [left(b) for b in self.boundaries(block)]
        
    def right_boundaries(self, block):
        right = operator.itemgetter(1)
        return [right(b) for b in self.boundaries(block)]
        
    def move(self, cursor, operation, mode=QTextCursor.MoveAnchor, n=1):
        """Reimplements Word-related cursor operations:
        
        StartOfWord
        PreviousWord
        WordLeft
        EndOfWord
        NextWord
        WordRight
        
        Other move operations are delegated to the QTextCursor ifself.
        """
        block = cursor.block()
        pos = cursor.position() - block.position()
        if operation == QTextCursor.StartOfWord:
            if pos:
                for start, end in reversed(self.boundaries(block)):
                    if start < pos:
                        if end < pos:
                            return False
                        cursor.setPosition(block.position() + start, mode)
                        return True
            return False
        elif operation == QTextCursor.EndOfWord:
            for start, end in self.boundaries(block):
                if end > pos:
                    if start > pos:
                        return False
                    cursor.setPosition(block.position() + end, mode)
                    return True
            return False
        elif operation in (QTextCursor.PreviousWord, QTextCursor.WordLeft):
            boundaries = list(itertools.takewhile(lambda b: b<pos, self.left_boundaries(block)))
            while True:
                if len(boundaries) >= n:
                    cursor.setPosition(block.position() + boundaries[-n], mode)
                    return True
                n -= len(boundaries)
                block = block.previous()
                if not block.isValid():
                    cursor.setPosition(0, mode)
                    return False
                boundaries = self.left_boundaries(block)
        elif operation in (QTextCursor.NextWord, QTextCursor.WordRight):
            boundaries = list(itertools.dropwhile(lambda b: b<=pos, self.left_boundaries(block)))
            while True:
                if len(boundaries) >= n:
                    cursor.setPosition(block.position() + boundaries[n-1], mode)
                    return True
                n -= len(boundaries)
                block = block.next()
                if not block.isValid():
                    cursor.movePosition(QTextCursor.End, mode)
                    return False
                boundaries = self.left_boundaries(block)
        else:
            return cursor.movePosition(operation, mode, n)
        
    def select(self, cursor, selection):
        """Reimplements the WordUnderCursor selection type.
        
        Other selection types are delegated to the QTextCursor ifself.
        
        """
        if selection == QTextCursor.WordUnderCursor:
            self.move(cursor, QTextCursor.StartOfWord)
            self.move(cursor, QTextCursor.EndOfWord, QTextCursor.KeepAnchor)
        else:
            cursor.select(selection)

    def install_textedit(self, edit):
        """Install ourselves as event filter on the textedit and its viewport."""
        edit.installEventFilter(self)
        edit.viewport().installEventFilter(self)
    
    def remove_textedit(self, edit):
        """Remove ourselves as event filter from the textedit and its viewport."""
        edit.removeEventFilter(self)
        edit.viewport().removeEventFilter(self)
    
    def get_textedit(self, obj):
        """Return the textedit widget if obj is its viewport.
        
        If obj is not the viewport of its parent, obj itself is returned.
        
        """
        parent = obj.parent()
        try:
            if obj is parent.viewport():
                return parent
        except AttributeError:
            pass
        return obj
    
    def eventFilter(self, obj, ev):
        """Intercept key events from a Q(Plain)TextEdit and handle them."""
        if ev.type() == QEvent.KeyPress:
            return self.keyPressEvent(obj, ev)
        elif ev.type() == QEvent.MouseButtonDblClick:
            edit = self.get_textedit(obj)
            self._double_click_time = time.time()
            return self.mouseDoubleClickEvent(edit, ev)
        elif ev.type() == QEvent.MouseButtonPress:
            edit = self.get_textedit(obj)
            if time.time() - self._double_click_time < QApplication.doubleClickInterval() / 1000.0:
                return self.mouseTripleClickEvent(edit, ev)
        return False
    
    def keyPressEvent(self, obj, ev):
        """Handles the Word-related key events for the Q(Plain)TextEdit."""
        c = obj.textCursor()
        if ev == QKeySequence.DeleteEndOfWord:
            self.move(c, QTextCursor.NextWord, QTextCursor.KeepAnchor)
            c.removeSelectedText()
        elif ev == QKeySequence.DeleteStartOfWord:
            self.move(c, QTextCursor.PreviousWord, QTextCursor.KeepAnchor)
            c.removeSelectedText()
        elif ev == QKeySequence.MoveToNextWord:
            self.move(c, QTextCursor.NextWord)
            obj.setTextCursor(c)
        elif ev == QKeySequence.MoveToPreviousWord:
            self.move(c, QTextCursor.PreviousWord)
            obj.setTextCursor(c)
        elif ev == QKeySequence.SelectNextWord:
            self.move(c, QTextCursor.NextWord, QTextCursor.KeepAnchor)
            obj.setTextCursor(c)
        elif ev == QKeySequence.SelectPreviousWord:
            self.move(c, QTextCursor.PreviousWord, QTextCursor.KeepAnchor)
            obj.setTextCursor(c)
        else:
            return False
        return True

    def mouseDoubleClickEvent(self, obj, ev):
        """Handles the double-click even to select a word."""
        if ev.button() == Qt.LeftButton:
            c = obj.cursorForPosition(ev.pos())
            self.select(c, QTextCursor.WordUnderCursor)
            obj.setTextCursor(c)
            return True
        return False

    def mouseTripleClickEvent(self, obj, ev):
        """Handles the triple-click even to select a line."""
        if ev.button() == Qt.LeftButton:
            c = obj.cursorForPosition(ev.pos())
            c.movePosition(QTextCursor.StartOfBlock)
            if c.block().next().isValid():
                c.movePosition(QTextCursor.NextBlock, QTextCursor.KeepAnchor)
            else:
                c.movePosition(QTextCursor.EndOfBlock, QTextCursor.KeepAnchor)
            obj.setTextCursor(c)
            return True
        return False



########NEW FILE########
__FILENAME__ = wordboundary
# This file is part of the Frescobaldi project, http://www.frescobaldi.org/
#
# Copyright (c) 2013 - 2014 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.

"""
Provides better word-boundary behaviour for View and other QPlainTextEdit
instances.
"""

from __future__ import unicode_literals

import re

from PyQt4.QtCore import QEvent, QObject, Qt
from PyQt4.QtGui import QKeySequence, QTextCursor

import app
import widgets.wordboundary


class BoundaryHandler(widgets.wordboundary.BoundaryHandler):
    word_regexp = re.compile(r'([-^_]?\\)?\w+(-\w+)*|\\\\|^|$', re.UNICODE)

handler = BoundaryHandler()

app.viewCreated.connect(handler.install_textedit)


########NEW FILE########
__FILENAME__ = mac-app
#!/usr/bin/env python
# coding=utf-8

"""
A setup file to build Frescobaldi.app with py2app.

Use the '-h' flag to see the usage notes.
"""

import argparse
import os
import sys
from setuptools import setup
import shutil

macosx = os.path.realpath(os.path.dirname(__file__))
root = os.path.dirname(macosx)

sys.path.append(root)

from frescobaldi_app import info

icon = '{0}/icons/{1}.icns'.format(macosx, info.name)
ipstrings = '{0}/app_resources/InfoPlist.strings'.format(macosx)

parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('-f', '--force', action = 'store_true', \
  help = 'force execution even if SCRIPT does not exist')
parser.add_argument('-v', '--version', \
  help = 'version string for the application bundle, \
  visible e.g. in \'Get Info\' and in \'Open with...\'', default = info.version)
parser.add_argument('-s', '--script', \
  help = 'path of {0}\'s main script; you should use an absolute path, \
  so that the application bundle can be moved to another \
  directory'.format(info.appname), default = '{0}/{1}'.format(root, info.name))
args = parser.parse_args()

if not (os.path.isfile(args.script) or args.force):
    sys.exit('Error: \'{0}\' does not exist or is not a file.\n\
If you really want to point the application bundle to \'{0}\',\n\
use the \'-f\' or \'--force\' flag.'.format(args.script))

plist = dict(
    CFBundleName                  = info.appname,
    CFBundleDisplayName           = info.appname,
    CFBundleShortVersionString    = args.version,
    CFBundleVersion               = args.version,
    CFBundleExecutable            = info.appname,
    CFBundleIdentifier            = 'org.{0}.{0}'.format(info.name),
    CFBundleIconFile              = '{0}.icns'.format(info.name),
    NSHumanReadableCopyright      = u'Copyright © 2008-2014 Wilbert Berendsen.',
    CFBundleDocumentTypes         = [
        {
            'CFBundleTypeExtensions': ['ly', 'lyi', 'ily'],
            'CFBundleTypeName': 'LilyPond file',
            'CFBundleTypeRole': 'Editor',
        },
        {
            'CFBundleTypeExtensions': ['tex', 'lytex', 'latex'],
            'CFBundleTypeName': 'LaTeX file',
            'CFBundleTypeRole': 'Editor',
        },
        {
            'CFBundleTypeExtensions': ['docbook', 'lyxml'],
            'CFBundleTypeName': 'DocBook file',
            'CFBundleTypeRole': 'Editor',
        },
        {
            'CFBundleTypeExtensions': ['html'],
            'CFBundleTypeName': 'HTML file',
            'CFBundleTypeRole': 'Editor',
            'LSItemContentTypes': ['public.html']
        },
        {
            'CFBundleTypeExtensions': ['xml'],
            'CFBundleTypeName': 'XML file',
            'CFBundleTypeRole': 'Editor',
            'LSItemContentTypes': ['public.xml']
        },
        {
            'CFBundleTypeExtensions': ['itely', 'tely', 'texi', 'texinfo'],
            'CFBundleTypeName': 'Texinfo file',
            'CFBundleTypeRole': 'Editor',
        },
        {
            'CFBundleTypeExtensions': ['scm'],
            'CFBundleTypeName': 'Scheme file',
            'CFBundleTypeRole': 'Editor',
        },
        {
            'CFBundleTypeExtensions': ['*'],
            'CFBundleTypeName': 'Text file',
            'CFBundleTypeRole': 'Editor',
            'LSItemContentTypes': ['public.text']
        }
    ]
)

options = {
    'argv_emulation': True,
    'semi_standalone': True,
    'alias': True,
    'plist': plist
}

setup(
    app = [args.script],
    name = info.appname,
    options = {'py2app': options},
    setup_requires = ['py2app'],
    script_args = ['py2app']
)

app_resources = 'dist/{0}.app/Contents/Resources'.format(info.appname)
icon_dest = '{0}/{1}.icns'.format(app_resources, info.name)
shutil.copyfile(icon, icon_dest)
os.chmod(icon_dest, 0644)
locales = ['cs', 'de', 'en', 'es', 'fr', 'gl', 'it', 'nl', 'pl', 'pt', 'ru', 'tr', 'uk']
for l in locales:
    app_lproj = '{0}/{1}.lproj'.format(app_resources, l)
    os.mkdir(app_lproj, 0755)
    ipstrings_dest = '{0}/InfoPlist.strings'.format(app_lproj)
    shutil.copyfile(ipstrings, ipstrings_dest)
    os.chmod(ipstrings_dest, 0644)

########NEW FILE########
